diff --git a/.gitattributes b/.gitattributes
index 9229c31f2c..daa2b71758 100755
--- a/.gitattributes
+++ b/.gitattributes
@@ -3,8 +3,9 @@
 
 # Explicitly declare text files we want to always be normalized and converted 
 # to native line endings on checkout.
-*.sh text
+*.css text
+*.html text
 *.java text
-*.xml text
 *.js text
-*.css text
\ No newline at end of file
+*.sh text
+*.xml text
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 929b7c52f5..a51f9e3f94 100755
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -34,9 +34,16 @@ keep in mind that this requires storing your Email there. The same applies if yo
 Note, our CLA does not influence your rights on your contribution but it makes sure for others that you agree to the Apache License, Version 2.
 After this you'll appear in the <a href="CONTRIBUTORS.md">contributors list</a> and your pull request can also be discussed technically.
 
-## Syntax:
+## Code formatting
 
-* Tell this your IDE or just use NetBeans which picks the format from pom.xml. E.g. no tabs - use 4 spaces instead!
-* Follow the conventions you see used in the source already.
+We use IntelliJ defaults and a very similar configuration for NetBeans defined in the root pom.xml. For eclipse there is this [configuration](https://github.com/graphhopper/graphhopper/files/481920/GraphHopper.Formatter.zip). Also for other IDEs 
+it should be simple to match:
+
+ * Java indent is 4 spaces
+ * Line width is 100 characters
+ * The rest is left to Java coding standards but disable "auto-format on save" to prevent unnecessary format changes. 
+ * Currently we do not care about import section that much, avoid changing it
+ * Unix line endings (should be handled via git)
+ * See discussion in [#770](https://github.com/graphhopper/graphhopper/issues/770)
 
 And in case we didn't emphasize it enough: we love tests!
diff --git a/.gitignore b/.gitignore
index 266d2af325..fd877b1f67 100755
--- a/.gitignore
+++ b/.gitignore
@@ -17,7 +17,7 @@ android/libs/graphhopper-*-android.jar
 .idea/
 *iml
 debug.sh
-web/src/main/webapp/js/config/options_prod.js
+/web/src/main/webapp/js/config/options_prod.js
 *.pbf
 !/reader-osm/src/test/resources/com/graphhopper/reader/osm/*.pbf
 *.dem
@@ -40,3 +40,4 @@ local.properties
 *.zip
 .DS_Store
 /core/nbproject/
+/reader-overlay-data/nbproject/
diff --git a/.travis.yml b/.travis.yml
index e8040b6cc7..45d1626935 100755
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,70 @@
 language: java
+sudo: false
+matrix:
+  fast_finish: true
+  include:
+      # Java 9 needs to be manually installed/upgraded
+      # see: https://github.com/travis-ci/travis-ci/issues/2968#issuecomment-149164058
+    - jdk: oraclejdk9
+      env: JVM=latest
+      sudo: required
+      dist: trusty
+      group: edge
+  allow_failures:
+    - jdk: oraclejdk9
+
+env:
+  global:
+    - BASEURL=https://www-eu.apache.org/dist/maven/maven-3/VERSION/binaries/apache-maven-VERSION-bin.zip
+    - FILE=apache-maven-VERSION-bin.zip
+    - DIR=apache-maven-VERSION
+    - VERSION=3.3.9
+    - secure: "kcd3BD+gagth90u8662Q91FHmtx/FEJEjtMnm2bxf1rX/cOYEUXtHvvh+rKmw5UAHjqMI00V8p8nBWL8blaCxJ+ItaxAHFRIMAcy3Qc65aTqnCt4wxDEXVxG1h3rylyKTXzxaHUT5XrsZbjLQX6L1BweTZlMGgkVn/yQcVFmkms="
+    - secure: "D1IOwe3ZTyw2CorYljXnHB3IuOJbH0B4YBfglNFoFsdCtn+SP+dqH/lClf5Hbeanhx/qPpgPKf331UCCpdSiLIZIHRWcsIXHSzJnqvH73eNyB4Awgm/IA0bS5D8iHJOhER1UtyTx5kT/KwKA9SD9ZBP3glrBzPDsyEbSZFsrACk="
+
 jdk:
   - oraclejdk8
-# do not install anything instead return true via unix command true
+
+before_install:
+   # update maven
+   - if [ "$TRAVIS_OS_NAME" == "linux" ]; then
+         wget --no-check-certificate $(echo -n $BASEURL | sed -e 's#VERSION#'$VERSION'#g');
+         unzip -qq $(echo -n $FILE | sed -e 's#VERSION#'$VERSION'#');
+         export M2_HOME=$PWD/$(echo -n $DIR | sed -e 's#VERSION#'$VERSION'#');
+         export PATH=$M2_HOME/bin:$PATH;
+     fi
+   # update java 9
+   - if [ "$TRAVIS_OS_NAME" == "linux" ] && [ "$JVM" == "latest" ]; then
+         sudo apt-get update -qq;
+         sudo /bin/echo -e oracle-java9-installer shared/accepted-oracle-license-v1-1 select true | sudo debconf-set-selections;
+         sudo apt-get install -y oracle-java9-installer;
+         sudo apt-get install -y oracle-java9-unlimited-jce-policy;
+         sudo update-java-alternatives -s java-9-oracle;
+     fi
+   - if [ "$TRAVIS_JDK_VERSION" == oraclejdk9 ]; then
+         sudo rm /etc/mavenrc;
+     fi
+
 install: true
-script: ./core/files/travis-build.sh
+
+script:
+  - mvn clean test verify -B
+  #- ./core/files/travis-build.sh
+
+after_success:
+  # deploy snapshot artifacts to maven central
+  - if [ "$TRAVIS_JDK_VERSION" == "oraclejdk8" ] &&
+       [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
+         travis_wait mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
+    else
+        echo "Not deploying snapshot artifact for $TRAVIS_BRANCH";
+    fi
+
 notifications:
   email:
     - github@graphhopper.com
 
-# enable container-based stack
-sudo: false
+cache:
+  directories:
+  - $HOME/.m2
+
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 132c2f139f..d96b6f5aee 100755
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -18,13 +18,13 @@ Most of the contributors are mentioned at Github as [Members](https://github.com
  * dos65, bug fixes in routing algo
  * drnextgis, ru translation and JS fixes
  * duongnt, fixes in storage
- * lmar, improved instructions information
  * fbonzon, UI improvements like #615
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
  * HarelM, improvements regarding elevation
  * HelgeKrueger, modularization of javascript, #590
  * henningvs, doc improvements
+ * highsource, more efficient geometry update, ui fixes
  * IsNull, improvements like #708
  * jansoe, many improvements regarding A* algorithm, forcing direction, roundabouts etc
  * jansonhanson, general host config
diff --git a/README.md b/README.md
index 9d93635a7d..6c8e51267a 100755
--- a/README.md
+++ b/README.md
@@ -51,13 +51,16 @@ Furthermore it allows you to use
 **speed mode** and in contrast to the speed mode we call everything without CH the
 **flexibility mode**. BTW: This does not mean that the flexibility mode is *slow*.
 
-The speed mode comes with much faster and lightweight (less RAM) responses and that although it does not use heuristics in its default settings. The downsides are that the speed mode allows only pre-defined vehicle profiles (multiple possible in GraphHopper) and requires a time consuming and resource intense preparation. And implementing certain features are not possible or very complex compared to the flexibility mode. 
+The speed mode comes with much faster and lightweight (less RAM) responses and that although it does not use heuristics in its default settings. 
+The downsides are that the speed mode allows only pre-defined vehicle profiles (multiple possible in GraphHopper) 
+and requires a time consuming and resource intense preparation. And implementing certain features are not possible 
+or very complex compared to the flexibility mode. 
 
 You can use both modes at the same time.
 
 ## License
 
-We chose the Apache License to make it easy for you to embed GraphHopper in your products.
+We chose the Apache License to make it easy for you to embed GraphHopper in your products, even closed source.
 We suggest to contribute back your changes, as GraphHopper evolves fast,
 but of course this is not necessary.
 
@@ -71,12 +74,13 @@ Other map data will need a custom import procedure, see e.g. <a href="https://gi
 ## Written in Java
 
 GraphHopper is written in Java and runs on Linux, Mac OS X,
-Windows, BSD, Solaris, Raspberry Pi,  Android, Blackberry and even iOS. Other 
+Windows, BSD, Solaris, Raspberry Pi, Android, Blackberry and even iOS. Other 
 environments which supports at least Java 7 will work too.
 
 ## Customizable
 
-We've build the GraphHopper class which makes simple things easy and complex things like multi-modal routing possible. Still you can use the low level API of GraphHopper and you'll see that
+We've build the GraphHopper class which makes simple things easy and complex things like multi-modal routing possible. 
+Still you can use the low level API of GraphHopper and you'll see that
 it was created to allow fast and memory efficient use of the underlying datastructures and algorithms.
 
 ### Android / Blackberry
@@ -115,13 +119,13 @@ Here is a list of the more detailed features including a link to the documentati
  * Offers turn instructions in more than 35 languages, contribute or improve [here](./docs/core/translations.md)
  * Displays and takes into account [elevation data](./docs/core/elevation.md) (per default disabled)
  * Can apply [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexibility only)
- * Customized routing profiles per request (flexibility only)
+ * Customize vehicle profiles per request (flexibility only)
  * Possibility to specify a '[heading parameter](./docs/core/routing.md)' for start, end and via points for navigation applications via `pass_through` or `heading` parameters (flexibility only)
- * [alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexibility only)
- * [turn costs and restrictions](https://github.com/graphhopper/graphhopper/pull/55#issuecomment-31089096) (flexibility only)
- * multiple profiles and weightings (flexibility and speed mode since 0.5)
- * several pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle
- * the core uses only a few dependencies (trove4j and slf4j)
- * scales from small indoor-sized to world-wide-sized graphs
+ * [Alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexibility only)
+ * [Turn costs and restrictions](https://github.com/graphhopper/graphhopper/pull/55#issuecomment-31089096) (flexibility only)
+ * Multiple profiles and weightings (flexibility and speed mode)
+ * Several pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
+ * The core uses only a few dependencies (trove4j and slf4j)
+ * Scales from small indoor-sized to world-wide-sized graphs
  * Find nearest point on street e.g. to get elevation or 'snapp to road'
- * Enables the [map matching component](https://github.com/graphhopper/map-matching) (flexibility only)
+ * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper (flexibility only)
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 420a710fc5..050e4645b9 100755
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion 24
+    buildToolsVersion "24.0.3"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
@@ -35,7 +35,7 @@ configurations.all {
  **/
 
 dependencies {
-    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.8-SNAPSHOT') {
+    compile(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.9-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 99cb632bf6..dec4c9bf33 100755
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.9-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -16,7 +16,7 @@
         <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <version>0.9-SNAPSHOT</version>
     </parent>
     <properties>
         <mapsforge.version>0.6.1</mapsforge.version>
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
index e5fdcda78f..eb1b128147 100755
--- a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -2,10 +2,8 @@
 
 import com.graphhopper.util.Downloader;
 
-public class AndroidDownloader extends Downloader
-{
-    public AndroidDownloader()
-    {
+public class AndroidDownloader extends Downloader {
+    public AndroidDownloader() {
         super("GraphHopper Android");
     }
 }
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
index c618ccc2db..c4add58ef0 100755
--- a/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
@@ -1,37 +1,31 @@
 package com.graphhopper.android;
 
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.List;
 
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-
-public class AndroidHelper
-{
-    public static List<String> readFile( Reader simpleReader ) throws IOException
-    {
+public class AndroidHelper {
+    public static List<String> readFile(Reader simpleReader) throws IOException {
         BufferedReader reader = new BufferedReader(simpleReader);
-        try
-        {
+        try {
             List<String> res = new ArrayList<String>();
             String line;
-            while ((line = reader.readLine()) != null)
-            {
+            while ((line = reader.readLine()) != null) {
                 res.add(line);
             }
             return res;
-        } finally
-        {
+        } finally {
             reader.close();
         }
     }
 
-    public static boolean isFastDownload( Context ctx )
-    {
+    public static boolean isFastDownload(Context ctx) {
         ConnectivityManager mgrConn = (ConnectivityManager) ctx
                 .getSystemService(Context.CONNECTIVITY_SERVICE);
         return mgrConn.getActiveNetworkInfo() != null
@@ -41,11 +35,9 @@ public static boolean isFastDownload( Context ctx )
         // || mgrTel.getNetworkType() == TelephonyManager.NETWORK_TYPE_UMTS) {
     }
 
-    public static String getFileName( String str )
-    {
+    public static String getFileName(String str) {
         int index = str.lastIndexOf("/");
-        if (index > 0)
-        {
+        if (index > 0) {
             return str.substring(index + 1);
         }
         return str;
diff --git a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index e60f0d4663..8ace22c386 100755
--- a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -2,38 +2,30 @@
 
 import android.os.AsyncTask;
 
-public abstract class GHAsyncTask<A, B, C> extends AsyncTask<A, B, C>
-{
+public abstract class GHAsyncTask<A, B, C> extends AsyncTask<A, B, C> {
     private Throwable error;
 
-    protected abstract C saveDoInBackground( A... params ) throws Exception;
+    protected abstract C saveDoInBackground(A... params) throws Exception;
 
-    protected C doInBackground( A... params )
-    {
-        try
-        {
+    protected C doInBackground(A... params) {
+        try {
             return saveDoInBackground(params);
-        } catch (Throwable t)
-        {
+        } catch (Throwable t) {
             error = t;
             return null;
         }
     }
 
-    public boolean hasError()
-    {
+    public boolean hasError() {
         return error != null;
     }
 
-    public Throwable getError()
-    {
+    public Throwable getError() {
         return error;
     }
 
-    public String getErrorMessage()
-    {
-        if (hasError())
-        {
+    public String getErrorMessage() {
+        if (hasError()) {
             return error.getMessage();
         }
         return "No Error";
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index a75b4c7588..d6cfb1e7de 100755
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -17,20 +17,17 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.Window;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.Spinner;
-import android.widget.TextView;
-import android.widget.Toast;
-import com.graphhopper.PathWrapper;
-
+import android.widget.*;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
-import com.graphhopper.util.*;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters.*;
-
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.StopWatch;
 import org.mapsforge.core.graphics.Bitmap;
 import org.mapsforge.core.graphics.Paint;
 import org.mapsforge.core.graphics.Style;
@@ -56,8 +53,8 @@
 import java.util.Map;
 import java.util.TreeMap;
 
-public class MainActivity extends Activity
-{
+public class MainActivity extends Activity {
+    private static final int NEW_MENU_ID = Menu.FIRST + 1;
     private MapView mapView;
     private GraphHopper hopper;
     private LatLong start;
@@ -75,43 +72,36 @@
     private File mapsFolder;
     private TileCache tileCache;
 
-    protected boolean onMapTap(LatLong tapLatLong)
-    {
+    protected boolean onMapTap(LatLong tapLatLong) {
         if (!isReady())
             return false;
 
-        if (shortestPathRunning)
-        {
+        if (shortestPathRunning) {
             logUser("Calculation still in progress");
             return false;
         }
         Layers layers = mapView.getLayerManager().getLayers();
 
-        if (start != null && end == null)
-        {
+        if (start != null && end == null) {
             end = tapLatLong;
             shortestPathRunning = true;
             Marker marker = createMarker(tapLatLong, R.drawable.flag_red);
-            if (marker != null)
-            {
+            if (marker != null) {
                 layers.add(marker);
             }
 
             calcPath(start.latitude, start.longitude, end.latitude,
                     end.longitude);
-        } else
-        {
+        } else {
             start = tapLatLong;
             end = null;
             // remove all layers but the first one, which is the map
-            while (layers.size() > 1)
-            {
+            while (layers.size() > 1) {
                 layers.remove(1);
             }
 
             Marker marker = createMarker(start, R.drawable.flag_green);
-            if (marker != null)
-            {
+            if (marker != null) {
                 layers.add(marker);
             }
         }
@@ -119,8 +109,7 @@ protected boolean onMapTap(LatLong tapLatLong)
     }
 
     @Override
-    protected void onCreate( Bundle savedInstanceState )
-    {
+    protected void onCreate(Bundle savedInstanceState) {
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
@@ -136,10 +125,8 @@ protected void onCreate( Bundle savedInstanceState )
         final EditText input = new EditText(this);
         input.setText(currentArea);
         boolean greaterOrEqKitkat = Build.VERSION.SDK_INT >= 19;
-        if (greaterOrEqKitkat)
-        {
-            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
-            {
+        if (greaterOrEqKitkat) {
+            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
                 logUser("GraphHopper is not usable without an external storage!");
                 return;
             }
@@ -165,8 +152,7 @@ protected void onCreate( Bundle savedInstanceState )
     }
 
     @Override
-    protected void onDestroy()
-    {
+    protected void onDestroy() {
         super.onDestroy();
         if (hopper != null)
             hopper.close();
@@ -180,14 +166,12 @@ protected void onDestroy()
         AndroidGraphicFactory.clearResourceMemoryCache();
     }
 
-    boolean isReady()
-    {
+    boolean isReady() {
         // only return true if already loaded
         if (hopper != null)
             return true;
 
-        if (prepareInProgress)
-        {
+        if (prepareInProgress) {
             logUser("Preparation still in progress");
             return false;
         }
@@ -195,28 +179,23 @@ boolean isReady()
         return false;
     }
 
-    private void initFiles( String area )
-    {
+    private void initFiles(String area) {
         prepareInProgress = true;
         currentArea = area;
         downloadingFiles();
     }
 
-    private void chooseAreaFromLocal()
-    {
+    private void chooseAreaFromLocal() {
         List<String> nameList = new ArrayList<>();
-        String[] files = mapsFolder.list(new FilenameFilter()
-        {
+        String[] files = mapsFolder.list(new FilenameFilter() {
             @Override
-            public boolean accept( File dir, String filename )
-            {
+            public boolean accept(File dir, String filename) {
                 return filename != null
                         && (filename.endsWith(".ghz") || filename
                         .endsWith("-gh"));
             }
         });
-        for (String file : files)
-        {
+        for (String file : files) {
             nameList.add(file);
         }
 
@@ -224,30 +203,23 @@ public boolean accept( File dir, String filename )
             return;
 
         chooseArea(localButton, localSpinner, nameList,
-                new MySpinnerListener()
-        {
+                new MySpinnerListener() {
             @Override
-            public void onSelect( String selectedArea, String selectedFile )
-            {
+            public void onSelect(String selectedArea, String selectedFile) {
                 initFiles(selectedArea);
             }
         });
     }
 
-    private void chooseAreaFromRemote()
-    {
-        new GHAsyncTask<Void, Void, List<String>>()
-        {
-            protected List<String> saveDoInBackground( Void... params )
-                    throws Exception
-            {
+    private void chooseAreaFromRemote() {
+        new GHAsyncTask<Void, Void, List<String>>() {
+            protected List<String> saveDoInBackground(Void... params)
+                    throws Exception {
                 String[] lines = new AndroidDownloader().downloadAsString(fileListURL, false).split("\n");
                 List<String> res = new ArrayList<>();
-                for (String str : lines)
-                {
+                for (String str : lines) {
                     int index = str.indexOf("href=\"");
-                    if (index >= 0)
-                    {
+                    if (index >= 0) {
                         index += 6;
                         int lastIndex = str.indexOf(".ghz", index);
                         if (lastIndex >= 0)
@@ -260,32 +232,25 @@ private void chooseAreaFromRemote()
             }
 
             @Override
-            protected void onPostExecute( List<String> nameList )
-            {
-                if (hasError())
-                {
+            protected void onPostExecute(List<String> nameList) {
+                if (hasError()) {
                     getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
-                } else if (nameList == null || nameList.isEmpty())
-                {
+                } else if (nameList == null || nameList.isEmpty()) {
                     logUser("No maps created for your version!? " + fileListURL);
                     return;
                 }
 
-                MySpinnerListener spinnerListener = new MySpinnerListener()
-                {
+                MySpinnerListener spinnerListener = new MySpinnerListener() {
                     @Override
-                    public void onSelect( String selectedArea, String selectedFile )
-                    {
+                    public void onSelect(String selectedArea, String selectedFile) {
                         if (selectedFile == null
                                 || new File(mapsFolder, selectedArea + ".ghz").exists()
-                                || new File(mapsFolder, selectedArea + "-gh").exists())
-                        {
+                                || new File(mapsFolder, selectedArea + "-gh").exists()) {
                             downloadURL = null;
-                        } else
-                        {
+                        } else {
                             downloadURL = selectedFile;
                         }
                         initFiles(selectedArea);
@@ -297,12 +262,10 @@ public void onSelect( String selectedArea, String selectedFile )
         }.execute();
     }
 
-    private void chooseArea( Button button, final Spinner spinner,
-                             List<String> nameList, final MySpinnerListener myListener )
-    {
+    private void chooseArea(Button button, final Spinner spinner,
+                            List<String> nameList, final MySpinnerListener myListener) {
         final Map<String, String> nameToFullName = new TreeMap<>();
-        for (String fullName : nameList)
-        {
+        for (String fullName : nameList) {
             String tmp = Helper.pruneFileEnd(fullName);
             if (tmp.endsWith("-gh"))
                 tmp = tmp.substring(0, tmp.length() - 3);
@@ -315,34 +278,23 @@ private void chooseArea( Button button, final Spinner spinner,
         ArrayAdapter<String> spinnerArrayAdapter = new ArrayAdapter<>(
                 this, android.R.layout.simple_spinner_dropdown_item, nameList);
         spinner.setAdapter(spinnerArrayAdapter);
-        button.setOnClickListener(new OnClickListener()
-        {
+        button.setOnClickListener(new OnClickListener() {
             @Override
-            public void onClick( View v )
-            {
+            public void onClick(View v) {
                 Object o = spinner.getSelectedItem();
-                if (o != null && o.toString().length() > 0 && !nameToFullName.isEmpty())
-                {
+                if (o != null && o.toString().length() > 0 && !nameToFullName.isEmpty()) {
                     String area = o.toString();
                     myListener.onSelect(area, nameToFullName.get(area));
-                } else
-                {
+                } else {
                     myListener.onSelect(null, null);
                 }
             }
         });
     }
 
-    public interface MySpinnerListener
-    {
-        void onSelect( String selectedArea, String selectedFile );
-    }
-
-    void downloadingFiles()
-    {
+    void downloadingFiles() {
         final File areaFolder = new File(mapsFolder, currentArea + "-gh");
-        if (downloadURL == null || areaFolder.exists())
-        {
+        if (downloadURL == null || areaFolder.exists()) {
             loadMap(areaFolder);
             return;
         }
@@ -354,63 +306,52 @@ void downloadingFiles()
         dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
         dialog.show();
 
-        new GHAsyncTask<Void, Integer, Object>()
-        {
-            protected Object saveDoInBackground( Void... _ignore )
-                    throws Exception
-            {
+        new GHAsyncTask<Void, Integer, Object>() {
+            protected Object saveDoInBackground(Void... _ignore)
+                    throws Exception {
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
                 AndroidDownloader downloader = new AndroidDownloader();
                 downloader.setTimeout(30000);
                 downloader.downloadAndUnzip(downloadURL, localFolder,
-                        new ProgressListener()
-                {
+                        new ProgressListener() {
                     @Override
-                    public void update( long val )
-                    {
+                    public void update(long val) {
                         publishProgress((int) val);
                     }
                 });
                 return null;
             }
 
-            protected void onProgressUpdate( Integer... values )
-            {
+            protected void onProgressUpdate(Integer... values) {
                 super.onProgressUpdate(values);
                 dialog.setProgress(values[0]);
             }
 
-            protected void onPostExecute( Object _ignore )
-            {
+            protected void onPostExecute(Object _ignore) {
                 dialog.dismiss();
-                if (hasError())
-                {
+                if (hasError()) {
                     String str = "An error happened while retrieving maps:" + getErrorMessage();
                     log(str, getError());
                     logUser(str);
-                } else
-                {
+                } else {
                     loadMap(areaFolder);
                 }
             }
         }.execute();
     }
 
-    void loadMap( File areaFolder )
-    {
+    void loadMap(File areaFolder) {
         logUser("loading map");
         MapDataStore mapDataStore = new MapFile(new File(areaFolder, currentArea + ".map"));
 
         mapView.getLayerManager().getLayers().clear();
 
         TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
-                mapView.getModel().mapViewPosition, false, true, false, AndroidGraphicFactory.INSTANCE)
-        {
+                mapView.getModel().mapViewPosition, false, true, false, AndroidGraphicFactory.INSTANCE) {
             @Override
-            public boolean onLongPress(LatLong tapLatLong, Point layerXY, Point tapXY)
-            {
+            public boolean onLongPress(LatLong tapLatLong, Point layerXY, Point tapXY) {
                 return onMapTap(tapLatLong);
             }
         };
@@ -423,13 +364,10 @@ public boolean onLongPress(LatLong tapLatLong, Point layerXY, Point tapXY)
         loadGraphStorage();
     }
 
-    void loadGraphStorage()
-    {
+    void loadGraphStorage() {
         logUser("loading graph (" + Constants.VERSION + ") ... ");
-        new GHAsyncTask<Void, Void, Path>()
-        {
-            protected Path saveDoInBackground( Void... v ) throws Exception
-            {
+        new GHAsyncTask<Void, Void, Path>() {
+            protected Path saveDoInBackground(Void... v) throws Exception {
                 GraphHopper tmpHopp = new GraphHopper().forMobile();
                 tmpHopp.load(new File(mapsFolder, currentArea).getAbsolutePath() + "-gh");
                 log("found graph " + tmpHopp.getGraphHopperStorage().toString() + ", nodes:" + tmpHopp.getGraphHopperStorage().getNodes());
@@ -437,14 +375,11 @@ protected Path saveDoInBackground( Void... v ) throws Exception
                 return null;
             }
 
-            protected void onPostExecute( Path o )
-            {
-                if (hasError())
-                {
+            protected void onPostExecute(Path o) {
+                if (hasError()) {
                     logUser("An error happened while creating graph:"
                             + getErrorMessage());
-                } else
-                {
+                } else {
                     logUser("Finished loading graph. Press long to define where to start and end the route.");
                 }
 
@@ -453,27 +388,21 @@ protected void onPostExecute( Path o )
         }.execute();
     }
 
-    private void finishPrepare()
-    {
+    private void finishPrepare() {
         prepareInProgress = false;
     }
 
-    private Polyline createPolyline( PathWrapper response )
-    {
+    private Polyline createPolyline(PathWrapper response) {
         Paint paintStroke = AndroidGraphicFactory.INSTANCE.createPaint();
         paintStroke.setStyle(Style.STROKE);
         paintStroke.setColor(Color.argb(128, 0, 0xCC, 0x33));
-        paintStroke.setDashPathEffect(new float[]
-        {
-            25, 15
-        });
+        paintStroke.setDashPathEffect(new float[]{25, 15});
         paintStroke.setStrokeWidth(8);
 
         Polyline line = new Polyline(paintStroke, AndroidGraphicFactory.INSTANCE);
         List<LatLong> geoPoints = line.getLatLongs();
         PointList tmp = response.getPoints();
-        for (int i = 0; i < response.getPoints().getSize(); i++)
-        {
+        for (int i = 0; i < response.getPoints().getSize(); i++) {
             geoPoints.add(new LatLong(tmp.getLatitude(i), tmp.getLongitude(i)));
         }
 
@@ -481,24 +410,20 @@ private Polyline createPolyline( PathWrapper response )
     }
 
     @SuppressWarnings("deprecation")
-    private Marker createMarker(LatLong p, int resource )
-    {
+    private Marker createMarker(LatLong p, int resource) {
         Drawable drawable = getResources().getDrawable(resource);
         Bitmap bitmap = AndroidGraphicFactory.convertToBitmap(drawable);
         return new Marker(p, bitmap, 0, -bitmap.getHeight() / 2);
     }
 
-    public void calcPath( final double fromLat, final double fromLon,
-                          final double toLat, final double toLon )
-    {
+    public void calcPath(final double fromLat, final double fromLon,
+                         final double toLat, final double toLon) {
 
         log("calculating path ...");
-        new AsyncTask<Void, Void, PathWrapper>()
-        {
+        new AsyncTask<Void, Void, PathWrapper>() {
             float time;
 
-            protected PathWrapper doInBackground( Void... v )
-            {
+            protected PathWrapper doInBackground(Void... v) {
                 StopWatch sw = new StopWatch().start();
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
                         setAlgorithm(Algorithms.DIJKSTRA_BI);
@@ -509,10 +434,8 @@ protected PathWrapper doInBackground( Void... v )
                 return resp.getBest();
             }
 
-            protected void onPostExecute( PathWrapper resp )
-            {
-                if (!resp.hasErrors())
-                {
+            protected void onPostExecute(PathWrapper resp) {
+                if (!resp.hasErrors()) {
                     log("from:" + fromLat + "," + fromLon + " to:" + toLat + ","
                             + toLon + " found path with distance:" + resp.getDistance()
                             / 1000f + ", nodes:" + resp.getPoints().getSize() + ", time:"
@@ -522,8 +445,7 @@ protected void onPostExecute( PathWrapper resp )
 
                     mapView.getLayerManager().getLayers().add(createPolyline(resp));
                     //mapView.redraw();
-                } else
-                {
+                } else {
                     logUser("Error:" + resp.getErrors());
                 }
                 shortestPathRunning = false;
@@ -531,40 +453,31 @@ protected void onPostExecute( PathWrapper resp )
         }.execute();
     }
 
-    private void log( String str )
-    {
+    private void log(String str) {
         Log.i("GH", str);
     }
 
-    private void log( String str, Throwable t )
-    {
+    private void log(String str, Throwable t) {
         Log.i("GH", str, t);
     }
 
-    private void logUser( String str )
-    {
+    private void logUser(String str) {
         log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
 
-    private static final int NEW_MENU_ID = Menu.FIRST + 1;
-
     @Override
-    public boolean onCreateOptionsMenu( Menu menu )
-    {
+    public boolean onCreateOptionsMenu(Menu menu) {
         super.onCreateOptionsMenu(menu);
         menu.add(0, NEW_MENU_ID, 0, "Google");
         // menu.add(0, NEW_MENU_ID + 1, 0, "Other");
         return true;
     }
 
-    public boolean onOptionsItemSelected( MenuItem item )
-    {
-        switch (item.getItemId())
-        {
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
             case NEW_MENU_ID:
-                if (start == null || end == null)
-                {
+                if (start == null || end == null) {
                     logUser("tap screen to set start and end of route");
                     break;
                 }
@@ -580,4 +493,8 @@ public boolean onOptionsItemSelected( MenuItem item )
         }
         return true;
     }
+
+    public interface MySpinnerListener {
+        void onSelect(String selectedArea, String selectedFile);
+    }
 }
diff --git a/android/build.gradle b/android/build.gradle
index 18c02c9c81..c2cf9e0b59 100755
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -4,7 +4,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.2'
+        classpath 'com.android.tools.build:gradle:2.2.1'
     }
 }
 
diff --git a/android/gradle.properties b/android/gradle.properties
index 1d3591c8a4..f2852858f4 100755
--- a/android/gradle.properties
+++ b/android/gradle.properties
@@ -9,10 +9,9 @@
 
 # Specifies the JVM arguments used for the daemon process.
 # The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+# org.gradle.jvmargs=-Xmx1536m
 
 # When configured, Gradle will run in incubating parallel mode.
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
+# org.gradle.parallel=true
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 122a0dca2e..edad11c6f7 100755
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Mon Dec 28 10:00:20 PST 2015
+#Tue Aug 16 13:14:49 EEST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/core/files/IntelliJ15GraphHopperFormatting.xml b/core/files/IntelliJ15GraphHopperFormatting.xml
deleted file mode 100755
index 74aef59849..0000000000
--- a/core/files/IntelliJ15GraphHopperFormatting.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<code_scheme name="GraphHopper">
-  <option name="ENABLE_JAVADOC_FORMATTING" value="false" />
-  <XML>
-    <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
-  </XML>
-  <codeStyleSettings language="JAVA">
-    <option name="BRACE_STYLE" value="2" />
-    <option name="CLASS_BRACE_STYLE" value="2" />
-    <option name="METHOD_BRACE_STYLE" value="2" />
-    <option name="SPACE_WITHIN_METHOD_PARENTHESES" value="true" />
-  </codeStyleSettings>
-</code_scheme>
\ No newline at end of file
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index e1342de696..96a71889d6 100755
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,8 +1,13 @@
 0.8
+    refactoring to Weighting class, see #807
+    removed FlagEncoder from parameters as weighting.getFlagEncoder can and is used
     all properties with prefix "osmreader." changed to "datareader." and osmreader.osm changed to datareader.file
     maven/gradle dependency graphhopper is now splitted into graphhopper-core and graphhopper-reader-osm, i.e. if you previouls depend on 'graphhopper' artificat you should now use graphhopper-reader-osm except environments like Android where you just load the graph and do no import
     use GraphHopperOSM as base class instead of GraphHopper
-    OSM reader separated from core
+    OSM reader separated from core, use new graphhopper-core package
+    moved subnetwork code into own package com.graphhopper.routing.subnetwork
+    moved weighting code into own package com.graphhopper.routing.weighting
+    code format has changed, so it is important to change your PRs too before you merge master, see discussion #770
 0.7        
     added snapped points to output JSON for every path
     the foot routing is now much smoother and only considers safe paths, to use beautiful roads (i.e. prefer hiking routes etc) use the new 'hike' profiles, see #633
diff --git a/core/files/intellij-settings.jar b/core/files/intellij-settings.jar
deleted file mode 100755
index a7553f8d0e..0000000000
Binary files a/core/files/intellij-settings.jar and /dev/null differ
diff --git a/core/files/settings.xml b/core/files/settings.xml
new file mode 100644
index 0000000000..80d2efb46d
--- /dev/null
+++ b/core/files/settings.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
+  <servers>
+    <server>
+      <id>ossrh</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
index e0641fe52a..60b1deacce 100755
--- a/core/files/travis-build.sh
+++ b/core/files/travis-build.sh
@@ -1,11 +1,9 @@
 HOME=$(dirname $0)
 cd $HOME/../..
 
-mvn clean test verify
-
 # npm tests disabled due to #632
 # cd $HOME/../../web
-# 
+#
 # sudo chown -R $USER ~/.npm
 # npm install
 # npm test && npm run lint
@@ -14,14 +12,14 @@ mvn clean test verify
 #for module in $modules; do
 #  echo "====== INSTALL $module ====="
 #  mvn -pl $module clean install -DskipTests=true
-#  EXIT_VAL="$?"    
+#  EXIT_VAL="$?"
 #  if [[ "x$EXIT_VAL" != "x0" ]]; then
 #    exit $EXIT_VAL
-#  fi 
-#  
+#  fi
+#
 #  echo "====== TEST $module ====="
 #  # verify necessary for failsafe, otherwise it won't fail the build!?
-#  mvn -pl $module test failsafe:integration-test verify  
+#  mvn -pl $module test failsafe:integration-test verify
 #  EXIT_VAL="$?"
 #  if [[ "x$EXIT_VAL" != "x0" ]]; then
 #    exit $EXIT_VAL
diff --git a/core/nb-configuration.xml b/core/nb-configuration.xml
index c95ec72546..ef9a362e2e 100755
--- a/core/nb-configuration.xml
+++ b/core/nb-configuration.xml
@@ -20,6 +20,6 @@
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
         <org-netbeans-modules-whitelist.whitelist-oracle>false</org-netbeans-modules-whitelist.whitelist-oracle>
-        <netbeans.compile.on.save>all</netbeans.compile.on.save>
+        <netbeans.compile.on.save>all</netbeans.compile.on.save>        
     </properties>
 </project-shared-configuration>
diff --git a/core/pom.xml b/core/pom.xml
index 5a04549e57..faf43d67be 100755
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -5,27 +5,27 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-core</artifactId>
-    <name>GraphHopper</name>
-    <version>0.8-SNAPSHOT</version>
-    <packaging>jar</packaging> 
+    <name>GraphHopper Core</name>
+    <version>0.9-SNAPSHOT</version>
+    <packaging>jar</packaging>
     <description>
-        GraphHopper is a fast and memory efficient Java road routing engine 
+        GraphHopper is a fast and memory efficient Java road routing engine
         working seamlessly with OpenStreetMap data.
     </description>
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.9-SNAPSHOT</version>
     </parent>
-        
+
     <properties>
-        <netbeans.hint.license>apache20</netbeans.hint.license>        
+        <netbeans.hint.license>apache20</netbeans.hint.license>
         <!-- Make sure that we use the same format as for Helper.createFormatter.
              We cannot force the UTC TimeZone so it will just throw away the local offset or is this
              fixed due to https://issues.apache.org/jira/browse/MNG-5647 ?
         -->
-        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ss'Z'</maven.build.timestamp.format>        
-        <builddate>${maven.build.timestamp}</builddate>        
+        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ss'Z'</maven.build.timestamp.format>
+        <builddate>${maven.build.timestamp}</builddate>
     </properties>
     <licenses>
         <license>
@@ -34,20 +34,20 @@
             <distribution>repo</distribution>
             <comments>A business-friendly OSS license</comments>
         </license>
-    </licenses> 
+    </licenses>
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-tools-lgpl</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-        
-        <!-- Trove is LGPL and slightly big (~3MB) -->        
+
+        <!-- Trove is LGPL and slightly big (~3MB) -->
         <dependency>
             <groupId>net.sf.trove4j</groupId>
             <artifactId>trove4j</artifactId>
             <version>3.0.3</version>
-        </dependency>        
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
@@ -61,7 +61,7 @@
             <scope>test</scope>
         </dependency>
         -->
-        
+
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
@@ -74,13 +74,13 @@
             <version>${log4j.version}</version>
             <scope>test</scope>
         </dependency>
-        
+
         <!-- for using CGIAR: elevation data importing via tif files-->
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
             <version>2.1</version>
-        </dependency>        
+        </dependency>
 
         <dependency>
             <groupId>org.json</groupId>
@@ -88,27 +88,29 @@
             <version>${json.org.version}</version>
             <scope>test</scope>
         </dependency>
-        
+
     </dependencies>
-        
+
     <build>
         <pluginManagement>
             <plugins>
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <configuration>                     
+                    <version>2.6</version>
+                    <configuration>
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
                     </configuration>
-                </plugin>                
-                
-                <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->                
+                </plugin>
+
+                <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
+                    <version>3.0.2</version>
                     <executions>
                         <execution>
                             <goals>
@@ -117,10 +119,10 @@
                         </execution>
                     </executions>
                 </plugin>
-                
+
             </plugins>
         </pluginManagement>
-        
+
         <!-- make version available at runtime via version file -->
         <resources>
             <resource>
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index d572e3ac6c..783c07a035 100755
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -33,25 +33,21 @@
  * @author Peter Karich
  * @author ratrun
  */
-public class GHRequest
-{
-    private String algo = "";
+public class GHRequest {
     private final List<GHPoint> points;
     private final HintsMap hints = new HintsMap();
-    private boolean possibleToAdd = false;
-    private Locale locale = Locale.US;
-
     // List of favored start (1st element) and arrival heading (all other).
     // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
     private final List<Double> favoredHeadings;
+    private String algo = "";
+    private boolean possibleToAdd = false;
+    private Locale locale = Locale.US;
 
-    public GHRequest()
-    {
+    public GHRequest() {
         this(5);
     }
 
-    public GHRequest( int size )
-    {
+    public GHRequest(int size) {
         points = new ArrayList<GHPoint>(size);
         favoredHeadings = new ArrayList<Double>(size);
         possibleToAdd = true;
@@ -62,17 +58,15 @@ public GHRequest( int size )
      * with a preferred start and end heading. Headings are north based azimuth (clockwise) in (0,
      * 360) or NaN for equal preference.
      */
-    public GHRequest( double fromLat, double fromLon, double toLat, double toLon,
-                      double startHeading, double endHeading )
-    {
+    public GHRequest(double fromLat, double fromLon, double toLat, double toLon,
+                     double startHeading, double endHeading) {
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon), startHeading, endHeading);
     }
 
     /**
      * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
      */
-    public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
-    {
+    public GHRequest(double fromLat, double fromLon, double toLat, double toLon) {
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
@@ -80,8 +74,7 @@ public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
      * Set routing request from specified startPlace to endPlace with a preferred start and end
      * heading. Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading )
-    {
+    public GHRequest(GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading) {
         if (startPlace == null)
             throw new IllegalStateException("'from' cannot be null");
 
@@ -99,27 +92,25 @@ public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, dou
         favoredHeadings.add(endHeading);
     }
 
-    public GHRequest( GHPoint startPlace, GHPoint endPlace )
-    {
+    public GHRequest(GHPoint startPlace, GHPoint endPlace) {
         this(startPlace, endPlace, Double.NaN, Double.NaN);
     }
 
     /**
      * Set routing request
      * <p>
-     * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     *
+     * @param points          List of stopover points in order: start, 1st stop, 2nd stop, ..., end
      * @param favoredHeadings List of favored headings for starting (start point) and arrival (via
-     * and end points) Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal
-     * preference
+     *                        and end points) Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal
+     *                        preference
      */
-    public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
-    {
+    public GHRequest(List<GHPoint> points, List<Double> favoredHeadings) {
         if (points.size() != favoredHeadings.size())
             throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size()
                     + ") must match size of points (" + points.size() + ")");
 
-        for (Double heading : favoredHeadings)
-        {
+        for (Double heading : favoredHeadings) {
             validateAzimuthValue(heading);
         }
         this.points = points;
@@ -129,21 +120,21 @@ public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
     /**
      * Set routing request
      * <p>
+     *
      * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
      */
-    public GHRequest( List<GHPoint> points )
-    {
+    public GHRequest(List<GHPoint> points) {
         this(points, Collections.nCopies(points.size(), Double.NaN));
     }
 
     /**
      * Add stopover point to routing request.
      * <p>
-     * @param point geographical position (see GHPoint)
+     *
+     * @param point          geographical position (see GHPoint)
      * @param favoredHeading north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest addPoint( GHPoint point, double favoredHeading )
-    {
+    public GHRequest addPoint(GHPoint point, double favoredHeading) {
         if (point == null)
             throw new IllegalArgumentException("point cannot be null");
 
@@ -160,10 +151,10 @@ public GHRequest addPoint( GHPoint point, double favoredHeading )
     /**
      * Add stopover point to routing request.
      * <p>
+     *
      * @param point geographical position (see GHPoint)
      */
-    public GHRequest addPoint( GHPoint point )
-    {
+    public GHRequest addPoint(GHPoint point) {
         addPoint(point, Double.NaN);
         return this;
     }
@@ -171,113 +162,95 @@ public GHRequest addPoint( GHPoint point )
     /**
      * @return north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public double getFavoredHeading( int i )
-    {
+    public double getFavoredHeading(int i) {
         return favoredHeadings.get(i);
     }
 
     /**
      * @return if there exist a preferred heading for start/via/end point i
      */
-    public boolean hasFavoredHeading( int i )
-    {
+    public boolean hasFavoredHeading(int i) {
         if (i >= favoredHeadings.size())
             return false;
 
         return !Double.isNaN(favoredHeadings.get(i));
     }
 
-    private void validateAzimuthValue( double heading )
-    {
+    private void validateAzimuthValue(double heading) {
         // heading must be in (0, 360) oder NaN
         if (!Double.isNaN(heading) && (Double.compare(heading, 360) > 0 || Double.compare(heading, 0) < 0))
             throw new IllegalArgumentException("Heading " + heading + " must be in range (0,360) or NaN");
     }
 
-    public List<GHPoint> getPoints()
-    {
+    public List<GHPoint> getPoints() {
         return points;
     }
 
+    public String getAlgorithm() {
+        return algo;
+    }
+
     /**
      * For possible values see AlgorithmOptions.*
      */
-    public GHRequest setAlgorithm( String algo )
-    {
+    public GHRequest setAlgorithm(String algo) {
         if (algo != null)
             this.algo = Helper.camelCaseToUnderScore(algo);
         return this;
     }
 
-    public String getAlgorithm()
-    {
-        return algo;
-    }
-
-    public Locale getLocale()
-    {
+    public Locale getLocale() {
         return locale;
     }
 
-    public GHRequest setLocale( Locale locale )
-    {
+    public GHRequest setLocale(Locale locale) {
         if (locale != null)
             this.locale = locale;
         return this;
     }
 
-    public GHRequest setLocale( String localeStr )
-    {
+    public GHRequest setLocale(String localeStr) {
         return setLocale(Helper.getLocale(localeStr));
     }
 
+    public String getWeighting() {
+        return hints.getWeighting();
+    }
+
     /**
      * By default it supports fastest and shortest. Or specify empty to use default.
      */
-    public GHRequest setWeighting( String w )
-    {
+    public GHRequest setWeighting(String w) {
         hints.setWeighting(w);
         return this;
     }
 
-    public String getWeighting()
-    {
-        return hints.getWeighting();
+    public String getVehicle() {
+        return hints.getVehicle();
     }
 
     /**
      * Specifiy car, bike or foot. Or specify empty to use default.
      */
-    public GHRequest setVehicle( String vehicle )
-    {
+    public GHRequest setVehicle(String vehicle) {
         hints.setVehicle(vehicle);
         return this;
     }
 
-    public String getVehicle()
-    {
-        return hints.getVehicle();
-    }
-
     @Override
-    public String toString()
-    {
+    public String toString() {
         String res = "";
-        for (GHPoint point : points)
-        {
-            if (res.isEmpty())
-            {
+        for (GHPoint point : points) {
+            if (res.isEmpty()) {
                 res = point.toString();
-            } else
-            {
+            } else {
                 res += "; " + point.toString();
             }
         }
         return res + "(" + algo + ")";
     }
 
-    public HintsMap getHints()
-    {
+    public HintsMap getHints() {
         return hints;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 0fc9491892..9c69411efd 100755
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -25,29 +25,26 @@
 /**
  * Wrapper containing path and error output of GraphHopper.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHResponse
-{
-    private String debugInfo = "";
+public class GHResponse {
     private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private final PMap hintsMap = new PMap();
     private final List<PathWrapper> pathWrappers = new ArrayList<PathWrapper>(5);
+    private String debugInfo = "";
 
-    public GHResponse()
-    {
+    public GHResponse() {
     }
 
-    public void add( PathWrapper altResponse )
-    {
+    public void add(PathWrapper altResponse) {
         pathWrappers.add(altResponse);
     }
 
     /**
      * Returns the best path.
      */
-    public PathWrapper getBest()
-    {
+    public PathWrapper getBest() {
         if (pathWrappers.isEmpty())
             throw new RuntimeException("Cannot fetch best response if list is empty");
 
@@ -57,21 +54,18 @@ public PathWrapper getBest()
     /**
      * This method returns the best path as well as all alternatives.
      */
-    public List<PathWrapper> getAll()
-    {
+    public List<PathWrapper> getAll() {
         return pathWrappers;
     }
 
     /**
      * This method returns true if there are alternative paths available besides the best.
      */
-    public boolean hasAlternatives()
-    {
+    public boolean hasAlternatives() {
         return pathWrappers.size() > 1;
     }
 
-    public void addDebugInfo( String debugInfo )
-    {
+    public void addDebugInfo(String debugInfo) {
         if (debugInfo == null)
             throw new IllegalStateException("Debug information has to be none null");
 
@@ -81,11 +75,9 @@ public void addDebugInfo( String debugInfo )
         this.debugInfo += debugInfo;
     }
 
-    public String getDebugInfo()
-    {
+    public String getDebugInfo() {
         String str = debugInfo;
-        for (PathWrapper ar : pathWrappers)
-        {
+        for (PathWrapper ar : pathWrappers) {
             if (!str.isEmpty())
                 str += "; ";
 
@@ -98,13 +90,11 @@ public String getDebugInfo()
      * This method returns true if one of the paths has an error or if the response itself is
      * errornous.
      */
-    public boolean hasErrors()
-    {
+    public boolean hasErrors() {
         if (!errors.isEmpty())
             return true;
 
-        for (PathWrapper ar : pathWrappers)
-        {
+        for (PathWrapper ar : pathWrappers) {
             if (ar.hasErrors())
                 return true;
         }
@@ -115,35 +105,29 @@ public boolean hasErrors()
     /**
      * This method returns all the explicitely added errors and the errors of all paths.
      */
-    public List<Throwable> getErrors()
-    {
+    public List<Throwable> getErrors() {
         List<Throwable> list = new ArrayList<Throwable>();
         list.addAll(errors);
-        for (PathWrapper ar : pathWrappers)
-        {
+        for (PathWrapper ar : pathWrappers) {
             list.addAll(ar.getErrors());
         }
         return list;
     }
 
-    public GHResponse addErrors( List<Throwable> errors )
-    {
+    public GHResponse addErrors(List<Throwable> errors) {
         this.errors.addAll(errors);
         return this;
     }
 
-    public GHResponse addError( Throwable error )
-    {
+    public GHResponse addError(Throwable error) {
         this.errors.add(error);
         return this;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = "";
-        for (PathWrapper a : pathWrappers)
-        {
+        for (PathWrapper a : pathWrappers) {
             str += "; " + a.toString();
         }
 
@@ -156,8 +140,7 @@ public String toString()
         return str;
     }
 
-    public PMap getHints()
-    {
+    public PMap getHints() {
         return hintsMap;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index d9efa82ed1..081e1a7ab5 100755
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -18,25 +18,30 @@
 package com.graphhopper;
 
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.dem.BridgeElevationInterpolator;
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.reader.dem.TunnelElevationInterpolator;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks;
 import com.graphhopper.routing.template.AlternativeRoutingTemplate;
 import com.graphhopper.routing.template.RoundTripRoutingTemplate;
 import com.graphhopper.routing.template.RoutingTemplate;
 import com.graphhopper.routing.template.ViaRoutingTemplate;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Parameters.Algorithms.*;
 import com.graphhopper.util.Parameters.CH;
 import com.graphhopper.util.Parameters.Routing;
+import com.graphhopper.util.exceptions.PointOutOfBoundsException;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -46,15 +51,24 @@
 import java.text.DateFormat;
 import java.util.*;
 
+import static com.graphhopper.util.Parameters.Algorithms.*;
+
 /**
  * Easy to use access point to configure import and (offline) routing.
  *
  * @author Peter Karich
  * @see GraphHopperAPI
  */
-public class GraphHopper implements GraphHopperAPI
-{
+public class GraphHopper implements GraphHopperAPI {
     private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final String fileLockName = "gh.lock";
+    private final Set<RoutingAlgorithmFactoryDecorator> algoDecorators = new LinkedHashSet<>();
+    // for CH prepare
+    private final CHAlgoFactoryDecorator chFactoryDecorator = new CHAlgoFactoryDecorator();
+    // utils
+    private final TranslationMap trMap = new TranslationMap().doImport();
+    boolean removeZipped = true;
+    boolean enableInstructions = true;
     // for graph:
     private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
@@ -62,19 +76,15 @@
     private String ghLocation = "";
     private DAType dataAccessType = DAType.RAM_STORE;
     private boolean sortGraph = false;
-    boolean removeZipped = true;
     private boolean elevation = false;
     private LockFactory lockFactory = new NativeFSLockFactory();
-    private final String fileLockName = "gh.lock";
     private boolean allowWrites = true;
-    boolean enableInstructions = true;
     private String preferredLanguage = "";
     private boolean fullyLoaded = false;
     // for routing
     private int maxRoundTripRetries = 3;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private final Set<RoutingAlgorithmFactoryDecorator> algoDecorators = new LinkedHashSet<>();
     private int maxVisitedNodes = Integer.MAX_VALUE;
     // for index
     private LocationIndex locationIndex;
@@ -83,20 +93,15 @@
     // for prepare
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
-    // for CH prepare    
-    private final CHAlgoFactoryDecorator chFactoryDecorator = new CHAlgoFactoryDecorator();
     // for data reader
     private String dataReaderFile;
     private double dataReaderWayPointMaxDistance = 1;
     private int dataReaderWorkerThreads = -1;
     private boolean calcPoints = true;
-    // utils
-    private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private FlagEncoderFactory flagEncoderFactory = FlagEncoderFactory.DEFAULT;
 
-    public GraphHopper()
-    {
+    public GraphHopper() {
         chFactoryDecorator.setEnabled(true);
         algoDecorators.add(chFactoryDecorator);
     }
@@ -104,20 +109,32 @@ public GraphHopper()
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph( GraphHopperStorage g )
-    {
+    protected GraphHopper loadGraph(GraphHopperStorage g) {
         this.ghStorage = g;
         fullyLoaded = true;
         initLocationIndex();
         return this;
     }
 
+    /**
+     * @return the first flag encoder of the encoding manager
+     */
+    FlagEncoder getDefaultVehicle() {
+        if (encodingManager == null)
+            throw new IllegalStateException("No encoding manager specified or loaded");
+
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
+    public EncodingManager getEncodingManager() {
+        return encodingManager;
+    }
+
     /**
      * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
      * how data from every vehicle is written (und read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager( EncodingManager em )
-    {
+    public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
         if (em.needsTurnCostsSupport())
@@ -126,24 +143,11 @@ public GraphHopper setEncodingManager( EncodingManager em )
         return this;
     }
 
-    /**
-     * @return the first flag encoder of the encoding manager
-     */
-    FlagEncoder getDefaultVehicle()
-    {
-        if (encodingManager == null)
-            throw new IllegalStateException("No encoding manager specified or loaded");
-
-        return encodingManager.fetchEdgeEncoders().get(0);
-    }
-
-    public EncodingManager getEncodingManager()
-    {
-        return encodingManager;
+    public ElevationProvider getElevationProvider() {
+        return eleProvider;
     }
 
-    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
-    {
+    public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
         if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
             setElevation(false);
         else
@@ -152,24 +156,17 @@ public GraphHopper setElevationProvider( ElevationProvider eleProvider )
         return this;
     }
 
-    public ElevationProvider getElevationProvider()
-    {
-        return eleProvider;
-    }
-
     /**
      * Threads for data reading.
      */
-    protected int getWorkerThreads()
-    {
+    protected int getWorkerThreads() {
         return dataReaderWorkerThreads;
     }
 
     /**
      * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
      */
-    protected double getWayPointMaxDistance()
-    {
+    protected double getWayPointMaxDistance() {
         return dataReaderWayPointMaxDistance;
     }
 
@@ -177,32 +174,28 @@ protected double getWayPointMaxDistance()
      * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
      * value means more details, unit is meter. Default is 1. Disable via 0.
      */
-    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
-    {
+    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
         this.dataReaderWayPointMaxDistance = wayPointMaxDistance;
         return this;
     }
 
+    public TraversalMode getTraversalMode() {
+        return traversalMode;
+    }
+
     /**
      * Sets the default traversal mode used for the algorithms and preparation.
      */
-    public GraphHopper setTraversalMode( TraversalMode traversalMode )
-    {
+    public GraphHopper setTraversalMode(TraversalMode traversalMode) {
         this.traversalMode = traversalMode;
         return this;
     }
 
-    public TraversalMode getTraversalMode()
-    {
-        return traversalMode;
-    }
-
     /**
      * Configures the underlying storage and response to be used on a well equipped server. Result
      * also optimized for usage in the web module i.e. try reduce network IO.
      */
-    public GraphHopper forServer()
-    {
+    public GraphHopper forServer() {
         setSimplifyResponse(true);
         return setInMemory();
     }
@@ -211,8 +204,7 @@ public GraphHopper forServer()
      * Configures the underlying storage to be used on a Desktop computer or within another Java
      * application with enough RAM but no network latency.
      */
-    public GraphHopper forDesktop()
-    {
+    public GraphHopper forDesktop() {
         setSimplifyResponse(false);
         return setInMemory();
     }
@@ -221,8 +213,7 @@ public GraphHopper forDesktop()
      * Configures the underlying storage to be used on a less powerful machine like Android or
      * Raspberry Pi with only few MB of RAM.
      */
-    public GraphHopper forMobile()
-    {
+    public GraphHopper forMobile() {
         setSimplifyResponse(false);
         return setMemoryMapped();
     }
@@ -232,15 +223,13 @@ public GraphHopper forMobile()
      * probably slower query times, which would be e.g. not suitable for Android. The resolution
      * specifies the tile width (in meter).
      */
-    public GraphHopper setPreciseIndexResolution( int precision )
-    {
+    public GraphHopper setPreciseIndexResolution(int precision) {
         ensureNotLoaded();
         preciseIndexResolution = precision;
         return this;
     }
 
-    public GraphHopper setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
-    {
+    public GraphHopper setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
         this.minNetworkSize = minNetworkSize;
         this.minOneWayNetworkSize = minOneWayNetworkSize;
         return this;
@@ -249,8 +238,7 @@ public GraphHopper setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSi
     /**
      * This method call results in an in-memory graph.
      */
-    public GraphHopper setInMemory()
-    {
+    public GraphHopper setInMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.RAM_STORE;
         return this;
@@ -263,8 +251,7 @@ public GraphHopper setInMemory()
      *
      * @param storeOnFlush true by default
      */
-    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
-    {
+    public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
         ensureNotLoaded();
         if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
@@ -276,8 +263,7 @@ public GraphHopper setStoreOnFlush( boolean storeOnFlush )
     /**
      * Enable memory mapped configuration if not enough memory is available on the target platform.
      */
-    public GraphHopper setMemoryMapped()
-    {
+    public GraphHopper setMemoryMapped() {
         ensureNotLoaded();
         dataAccessType = DAType.MMAP;
         return this;
@@ -286,8 +272,7 @@ public GraphHopper setMemoryMapped()
     /**
      * Not yet stable enough to offer it for everyone
      */
-    private GraphHopper setUnsafeMemory()
-    {
+    private GraphHopper setUnsafeMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.UNSAFE_STORE;
         return this;
@@ -301,8 +286,7 @@ private GraphHopper setUnsafeMemory()
      * {@link GraphHopper#setCHWeightings(String...)}
      */
     @Deprecated
-    public GraphHopper setCHWeighting( String weightingName )
-    {
+    public GraphHopper setCHWeighting(String weightingName) {
         return this.setCHWeightings(weightingName);
     }
 
@@ -312,36 +296,40 @@ public GraphHopper setCHWeighting( String weightingName )
      * @deprecated Use getCHFactoryDecorator().setWeightingsAsStrings() instead. Will be removed in
      * 0.8.
      */
-    public GraphHopper setCHWeightings( String... weightingNames )
-    {
+    public GraphHopper setCHWeightings(String... weightingNames) {
         return this.setCHWeightings(Arrays.asList(weightingNames));
     }
 
+    /**
+     * Returns all CHWeighting names
+     *
+     * @deprecated Use getCHFactoryDecorator().getWeightingsAsStrings() instead. Will be removed in
+     * 0.8.
+     */
+    public List<String> getCHWeightings() {
+        return chFactoryDecorator.getWeightingsAsStrings();
+    }
+
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      *
      * @param weightingList A list containing multiple weightings like: "fastest", "shortest" or
-     * your own weight-calculation type.
-     *
+     *                      your own weight-calculation type.
      * @deprecated Use getCHFactoryDecorator().setWeightingsAsStrings() instead. Will be removed in
      * 0.8.
      */
-    public GraphHopper setCHWeightings( List<String> weightingList )
-    {
+    public GraphHopper setCHWeightings(List<String> weightingList) {
         ensureNotLoaded();
         chFactoryDecorator.setWeightingsAsStrings(weightingList);
         return this;
     }
 
     /**
-     * Returns all CHWeighting names
-     *
-     * @deprecated Use getCHFactoryDecorator().getWeightingsAsStrings() instead. Will be removed in
+     * @deprecated Use getCHFactoryDecorator().getCHPrepareThreads() instead. Will be removed in
      * 0.8.
      */
-    public List<String> getCHWeightings()
-    {
-        return chFactoryDecorator.getWeightingsAsStrings();
+    public int getCHPrepareThreads() {
+        return chFactoryDecorator.getPreparationThreads();
     }
 
     /**
@@ -351,90 +339,74 @@ public GraphHopper setCHWeightings( List<String> weightingList )
      * @deprecated Use getCHFactoryDecorator().setCHPrepareThreads() instead. Will be removed in
      * 0.8.
      */
-    public GraphHopper setCHPrepareThreads( int prepareThreads )
-    {
+    public GraphHopper setCHPrepareThreads(int prepareThreads) {
         chFactoryDecorator.setPreparationThreads(prepareThreads);
         return this;
     }
 
     /**
-     * @deprecated Use getCHFactoryDecorator().getCHPrepareThreads() instead. Will be removed in
-     * 0.8.
-     */
-    public int getCHPrepareThreads()
-    {
-        return chFactoryDecorator.getPreparationThreads();
-    }
-
-    /**
-     *
      * @deprecated Use setEnabled() instead. Will be removed in 0.8.
      */
-    public GraphHopper setCHEnable( boolean enable )
-    {
+    public GraphHopper setCHEnable(boolean enable) {
         return setCHEnabled(enable);
     }
 
+    public final boolean isCHEnabled() {
+        return chFactoryDecorator.isEnabled();
+    }
+
     /**
      * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
      */
-    public GraphHopper setCHEnabled( boolean enable )
-    {
+    public GraphHopper setCHEnabled(boolean enable) {
         ensureNotLoaded();
         chFactoryDecorator.setEnabled(enable);
         return this;
     }
 
-    public final boolean isCHEnabled()
-    {
-        return chFactoryDecorator.isEnabled();
+    public int getMaxVisitedNodes() {
+        return maxVisitedNodes;
     }
 
     /**
      * This methods stops the algorithm from searching further if the resulting path would go over
      * the specified node count, important if none-CH routing is used.
      */
-    public void setMaxVisitedNodes( int maxVisitedNodes )
-    {
+    public void setMaxVisitedNodes(int maxVisitedNodes) {
         this.maxVisitedNodes = maxVisitedNodes;
     }
 
-    public int getMaxVisitedNodes()
-    {
-        return maxVisitedNodes;
-    }
-
     /**
      * @return true if storing and fetching elevation data is enabled. Default is false
      */
-    public boolean hasElevation()
-    {
+    public boolean hasElevation() {
         return elevation;
     }
 
     /**
      * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setElevation( boolean includeElevation )
-    {
+    public GraphHopper setElevation(boolean includeElevation) {
         this.elevation = includeElevation;
         return this;
     }
 
+    public boolean isEnableInstructions() {
+        return enableInstructions;
+    }
+
     /**
      * This method specifies if the import should include way names to be able to return
      * instructions for a route.
      */
-    public GraphHopper setEnableInstructions( boolean b )
-    {
+    public GraphHopper setEnableInstructions(boolean b) {
         ensureNotLoaded();
         enableInstructions = b;
         return this;
     }
 
-    public boolean isEnableInstructions()
-    {
-        return enableInstructions;
+    public String getPreferredLanguage() {
+        return preferredLanguage;
     }
 
     /**
@@ -448,8 +420,7 @@ public boolean isEnableInstructions()
      * to default language.</li>
      * </ul>
      */
-    public GraphHopper setPreferredLanguage( String preferredLanguage )
-    {
+    public GraphHopper setPreferredLanguage(String preferredLanguage) {
         ensureNotLoaded();
         if (preferredLanguage == null)
             throw new IllegalArgumentException("preferred language cannot be null");
@@ -458,16 +429,10 @@ public GraphHopper setPreferredLanguage( String preferredLanguage )
         return this;
     }
 
-    public String getPreferredLanguage()
-    {
-        return preferredLanguage;
-    }
-
     /**
      * This methods enables gps point calculation. If disabled only distance will be calculated.
      */
-    public GraphHopper setEnableCalcPoints( boolean b )
-    {
+    public GraphHopper setEnableCalcPoints(boolean b) {
         calcPoints = b;
         return this;
     }
@@ -476,17 +441,19 @@ public GraphHopper setEnableCalcPoints( boolean b )
      * This method specifies if the returned path should be simplified or not, via douglas-peucker
      * or similar algorithm.
      */
-    private GraphHopper setSimplifyResponse( boolean doSimplify )
-    {
+    private GraphHopper setSimplifyResponse(boolean doSimplify) {
         this.simplifyResponse = doSimplify;
         return this;
     }
 
+    public String getGraphHopperLocation() {
+        return ghLocation;
+    }
+
     /**
      * Sets the graphhopper folder.
      */
-    public GraphHopper setGraphHopperLocation( String ghLocation )
-    {
+    public GraphHopper setGraphHopperLocation(String ghLocation) {
         ensureNotLoaded();
         if (ghLocation == null)
             throw new IllegalArgumentException("graphhopper location cannot be null");
@@ -495,17 +462,15 @@ public GraphHopper setGraphHopperLocation( String ghLocation )
         return this;
     }
 
-    public String getGraphHopperLocation()
-    {
-        return ghLocation;
+    public String getDataReaderFile() {
+        return dataReaderFile;
     }
 
     /**
      * This file can be any file type supported by the DataReader. E.g. for the OSMReader it is the
      * OSM xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file (.pbf)
      */
-    public GraphHopper setDataReaderFile( String dataReaderFileStr )
-    {
+    public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
         if (Helper.isEmpty(dataReaderFileStr))
             throw new IllegalArgumentException("Data reader file cannot be empty.");
@@ -514,80 +479,66 @@ public GraphHopper setDataReaderFile( String dataReaderFileStr )
         return this;
     }
 
-    public String getDataReaderFile()
-    {
-        return dataReaderFile;
-    }
-
     /**
      * The underlying graph used in algorithms.
      *
      * @throws IllegalStateException if graph is not instantiated.
      */
-    public GraphHopperStorage getGraphHopperStorage()
-    {
+    public GraphHopperStorage getGraphHopperStorage() {
         if (ghStorage == null)
             throw new IllegalStateException("GraphHopper storage not initialized");
 
         return ghStorage;
     }
 
-    public void setGraphHopperStorage( GraphHopperStorage ghStorage )
-    {
+    public void setGraphHopperStorage(GraphHopperStorage ghStorage) {
         this.ghStorage = ghStorage;
         fullyLoaded = true;
     }
 
-    protected void setLocationIndex( LocationIndex locationIndex )
-    {
-        this.locationIndex = locationIndex;
-    }
-
     /**
      * The location index created from the graph.
      *
      * @throws IllegalStateException if index is not initialized
      */
-    public LocationIndex getLocationIndex()
-    {
+    public LocationIndex getLocationIndex() {
         if (locationIndex == null)
             throw new IllegalStateException("Location index not initialized");
 
         return locationIndex;
     }
 
+    protected void setLocationIndex(LocationIndex locationIndex) {
+        this.locationIndex = locationIndex;
+    }
+
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
-    public GraphHopper setSortGraph( boolean sortGraph )
-    {
+    public GraphHopper setSortGraph(boolean sortGraph) {
         ensureNotLoaded();
         this.sortGraph = sortGraph;
         return this;
     }
 
+    public boolean isAllowWrites() {
+        return allowWrites;
+    }
+
     /**
      * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
      * possible to create a lock file and so we can avoid write locks.
      */
-    public GraphHopper setAllowWrites( boolean allowWrites )
-    {
+    public GraphHopper setAllowWrites(boolean allowWrites) {
         this.allowWrites = allowWrites;
         return this;
     }
 
-    public boolean isAllowWrites()
-    {
-        return allowWrites;
-    }
-
-    public TranslationMap getTranslationMap()
-    {
+    public TranslationMap getTranslationMap() {
         return trMap;
     }
 
-    public GraphHopper setFlagEncoderFactory( FlagEncoderFactory factory )
-    {
+    public GraphHopper setFlagEncoderFactory(FlagEncoderFactory factory) {
         this.flagEncoderFactory = factory;
         return this;
     }
@@ -597,8 +548,7 @@ public GraphHopper setFlagEncoderFactory( FlagEncoderFactory factory )
      * args) ala CmdArgs.read(args) or via configuration file ala
      * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
      */
-    public GraphHopper init( CmdArgs args )
-    {
+    public GraphHopper init(CmdArgs args) {
         args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
         if (args.has("osmreader.osm"))
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
@@ -608,8 +558,7 @@ public GraphHopper init( CmdArgs args )
             dataReaderFile = tmpOsmFile;
 
         String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
-        {
+        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
             if (Helper.isEmpty(dataReaderFile))
                 throw new IllegalArgumentException("You need to specify an OSM file.");
 
@@ -653,11 +602,9 @@ public GraphHopper init( CmdArgs args )
 
         DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm"))
-        {
+        if (eleProviderStr.equalsIgnoreCase("srtm")) {
             tmpProvider = new SRTMProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
-        {
+        } else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
             CGIARProvider cgiarProvider = new CGIARProvider();
             cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
             tmpProvider = cgiarProvider;
@@ -695,8 +642,7 @@ public GraphHopper init( CmdArgs args )
         return this;
     }
 
-    private void printInfo()
-    {
+    private void printInfo() {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
         if (ghStorage != null)
             logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
@@ -707,14 +653,11 @@ private void printInfo()
      * graph will be stored to disc so on a second call this method will only load the graph from
      * disc which is usually a lot faster.
      */
-    public GraphHopper importOrLoad()
-    {
-        if (!load(ghLocation))
-        {
+    public GraphHopper importOrLoad() {
+        if (!load(ghLocation)) {
             printInfo();
             process(ghLocation);
-        } else
-        {
+        } else {
             printInfo();
         }
         return this;
@@ -723,44 +666,37 @@ public GraphHopper importOrLoad()
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process( String graphHopperLocation )
-    {
+    private GraphHopper process(String graphHopperLocation) {
         setGraphHopperLocation(graphHopperLocation);
         Lock lock = null;
-        try
-        {
-            if (ghStorage.getDirectory().getDefaultType().isStoring())
-            {
+        try {
+            if (ghStorage.getDirectory().getDefaultType().isStoring()) {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
                 if (!lock.tryLock())
                     throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
             }
 
-            try
-            {
+            try {
                 DataReader reader = importData();
                 DateFormat f = Helper.createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
                 if (reader.getDataDate() != null)
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 throw new RuntimeException("Cannot read file " + getDataReaderFile(), ex);
             }
             cleanUp();
             postProcessing();
             flush();
-        } finally
-        {
+        } finally {
             if (lock != null)
                 lock.release();
         }
         return this;
     }
 
-    protected DataReader importData() throws IOException
-    {
+    protected DataReader importData() throws IOException {
         ensureWriteAccess();
         if (ghStorage == null)
             throw new IllegalStateException("Load graph before importing OSM data");
@@ -777,14 +713,12 @@ protected DataReader importData() throws IOException
         return reader;
     }
 
-    protected DataReader createReader( GraphHopperStorage ghStorage )
-    {
+    protected DataReader createReader(GraphHopperStorage ghStorage) {
         throw new UnsupportedOperationException("Cannot create DataReader. Solutions: avoid import via calling load directly, "
                 + "provide a DataReader or use e.g. GraphHopperOSM or a different subclass");
     }
 
-    protected DataReader initDataReader( DataReader reader )
-    {
+    protected DataReader initDataReader(DataReader reader) {
         if (dataReaderFile == null)
             throw new IllegalArgumentException("No file for DataReader specified");
 
@@ -800,37 +734,29 @@ protected DataReader initDataReader( DataReader reader )
      * Opens existing graph.
      *
      * @param graphHopperFolder is the folder containing graphhopper files. Can be a compressed file
-     * too ala folder-content.ghz.
+     *                          too ala folder-content.ghz.
      */
     @Override
-    public boolean load( String graphHopperFolder )
-    {
+    public boolean load(String graphHopperFolder) {
         if (Helper.isEmpty(graphHopperFolder))
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
 
         if (fullyLoaded)
             throw new IllegalStateException("graph is already successfully loaded");
 
-        if (graphHopperFolder.endsWith("-gh"))
-        {
+        if (graphHopperFolder.endsWith("-gh")) {
             // do nothing  
-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
-        {
+        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml")) {
             throw new IllegalArgumentException("GraphHopperLocation cannot be the OSM file. Instead you need to use importOrLoad");
-        } else if (!graphHopperFolder.contains("."))
-        {
+        } else if (!graphHopperFolder.contains(".")) {
             if (new File(graphHopperFolder + "-gh").exists())
                 graphHopperFolder += "-gh";
-        } else
-        {
+        } else {
             File compressed = new File(graphHopperFolder + ".ghz");
-            if (compressed.exists() && !compressed.isDirectory())
-            {
-                try
-                {
+            if (compressed.exists() && !compressed.isDirectory()) {
+                try {
                     new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex)
-                {
+                } catch (IOException ex) {
                     throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
                             + " to " + graphHopperFolder, ex);
                 }
@@ -849,12 +775,10 @@ public boolean load( String graphHopperFolder )
         GraphExtension ext = encodingManager.needsTurnCostsSupport()
                 ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
 
-        if (chFactoryDecorator.isEnabled())
-        {
+        if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
             ghStorage = new GraphHopperStorage(chFactoryDecorator.getWeightings(), dir, encodingManager, hasElevation(), ext);
-        } else
-        {
+        } else {
             ghStorage = new GraphHopperStorage(dir, encodingManager, hasElevation(), ext);
         }
 
@@ -864,12 +788,10 @@ public boolean load( String graphHopperFolder )
             return false;
 
         Lock lock = null;
-        try
-        {
+        try {
             // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
             // (e.g. on a read only filesystem locks would fail)
-            if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites())
-            {
+            if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
                 if (!lock.tryLock())
@@ -882,18 +804,15 @@ public boolean load( String graphHopperFolder )
             postProcessing();
             fullyLoaded = true;
             return true;
-        } finally
-        {
+        } finally {
             if (lock != null)
                 lock.release();
         }
     }
 
-    public RoutingAlgorithmFactory getAlgorithmFactory( HintsMap map )
-    {
+    public RoutingAlgorithmFactory getAlgorithmFactory(HintsMap map) {
         RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
-        for (RoutingAlgorithmFactoryDecorator decorator : algoDecorators)
-        {
+        for (RoutingAlgorithmFactoryDecorator decorator : algoDecorators) {
             if (decorator.isEnabled())
                 routingAlgorithmFactory = decorator.getDecoratedAlgorithmFactory(routingAlgorithmFactory, map);
         }
@@ -901,26 +820,21 @@ public RoutingAlgorithmFactory getAlgorithmFactory( HintsMap map )
         return routingAlgorithmFactory;
     }
 
-    public GraphHopper addAlgorithmFactoryDecorator( RoutingAlgorithmFactoryDecorator algoFactoryDecorator )
-    {
+    public GraphHopper addAlgorithmFactoryDecorator(RoutingAlgorithmFactoryDecorator algoFactoryDecorator) {
         if (!algoDecorators.add(algoFactoryDecorator))
             throw new IllegalArgumentException("Decorator was already added " + algoFactoryDecorator.getClass());
 
         return this;
     }
 
-    public final CHAlgoFactoryDecorator getCHFactoryDecorator()
-    {
+    public final CHAlgoFactoryDecorator getCHFactoryDecorator() {
         return chFactoryDecorator;
     }
 
-    private void initCHAlgoFactoryDecorator()
-    {
+    private void initCHAlgoFactoryDecorator() {
         if (!chFactoryDecorator.hasWeightings())
-            for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
-            {
-                for (String chWeightingStr : chFactoryDecorator.getWeightingsAsStrings())
-                {
+            for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
+                for (String chWeightingStr : chFactoryDecorator.getWeightingsAsStrings()) {
                     Weighting weighting = createWeighting(new HintsMap(chWeightingStr), encoder);
                     chFactoryDecorator.addWeighting(weighting);
                 }
@@ -932,20 +846,17 @@ private void initCHAlgoFactoryDecorator()
      *
      * @deprecated use getCHFactoryDecorator().createPreparations() instead. Will be removed in 0.8.
      */
-    protected void createCHPreparations()
-    {
+    protected void createCHPreparations() {
         chFactoryDecorator.createPreparations(ghStorage, traversalMode);
     }
 
     /**
      * Does the preparation and creates the location index
      */
-    public void postProcessing()
-    {
+    public void postProcessing() {
         // Later: move this into the GraphStorage.optimize method
         // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
+        if (sortGraph) {
             if (ghStorage.isCHPossible() && isPrepared())
                 throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
 
@@ -955,6 +866,10 @@ public void postProcessing()
             ghStorage = newGraph;
         }
 
+        if (hasElevation()) {
+            interpolateBridgesAndOrTunnels();
+        }
+
         initLocationIndex();
         if (chFactoryDecorator.isEnabled())
             createCHPreparations();
@@ -963,43 +878,60 @@ public void postProcessing()
             prepare();
     }
 
-    private boolean isPrepared()
-    {
+    private void interpolateBridgesAndOrTunnels() {
+        if (ghStorage.getEncodingManager().supports("generic")) {
+            final FlagEncoder genericFlagEncoder = ghStorage.getEncodingManager()
+                    .getEncoder("generic");
+            if (!(genericFlagEncoder instanceof DataFlagEncoder)) {
+                throw new IllegalStateException("'generic' flag encoder for elevation interpolation of "
+                        + "bridges and tunnels is enabled but does not have the expected type "
+                        + DataFlagEncoder.class.getName() + ".");
+            }
+            final DataFlagEncoder dataFlagEncoder = (DataFlagEncoder) genericFlagEncoder;
+            StopWatch sw = new StopWatch().start();
+            new TunnelElevationInterpolator(ghStorage, dataFlagEncoder).execute();
+            float tunnel = sw.stop().getSeconds();
+            sw = new StopWatch().start();
+            new BridgeElevationInterpolator(ghStorage, dataFlagEncoder).execute();
+            logger.info("Bridge interpolation " + (int) sw.stop().getSeconds() + "s, "
+                    + "tunnel interpolation " + (int) tunnel + "s");
+        }
+    }
+
+    private boolean isPrepared() {
         return "true".equals(ghStorage.getProperties().get("prepare.done"));
     }
 
     /**
-     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
-     * created. Note that all URL parameters are available in the weightingParameters as String if
-     * you use the GraphHopper Web module.
+     * Based on the hintsMap and the specified encoder a Weighting instance can be
+     * created. Note that all URL parameters are available in the hintsMap as String if
+     * you use the web module.
      *
-     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
-     * GHRequest.getHints or directly via "&amp;api.xy=" from the URL of the web UI
-     * @param encoder the required vehicle
+     * @param hintsMap all parameters influencing the weighting. E.g. parameters coming via
+     *                 GHRequest.getHints or directly via "&amp;api.xy=" from the URL of the web UI
+     * @param encoder  the required vehicle
      * @return the weighting to be used for route calculation
      * @see HintsMap
      */
-    public Weighting createWeighting( HintsMap weightingMap, FlagEncoder encoder )
-    {
-        String weighting = weightingMap.getWeighting().toLowerCase();
+    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder) {
+        String weighting = hintsMap.getWeighting().toLowerCase();
 
-        if ("shortest".equalsIgnoreCase(weighting))
-        {
+        if (encoder.supports(GenericWeighting.class)) {
+            DataFlagEncoder dataEncoder = (DataFlagEncoder) encoder;
+            return new GenericWeighting(dataEncoder, dataEncoder.readStringMap(hintsMap));
+        } else if ("shortest".equalsIgnoreCase(weighting)) {
             return new ShortestWeighting(encoder);
-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-        {
+        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
             if (encoder.supports(PriorityWeighting.class))
-                return new PriorityWeighting(encoder, weightingMap);
+                return new PriorityWeighting(encoder, hintsMap);
             else
-                return new FastestWeighting(encoder, weightingMap);
-        } else if ("curvature".equalsIgnoreCase(weighting))
-        {
+                return new FastestWeighting(encoder, hintsMap);
+        } else if ("curvature".equalsIgnoreCase(weighting)) {
             if (encoder.supports(CurvatureWeighting.class))
-                return new CurvatureWeighting(encoder, weightingMap);
+                return new CurvatureWeighting(encoder, hintsMap);
 
-        } else if ("short_fastest".equalsIgnoreCase(weighting))
-        {
-            return new ShortFastestWeighting(encoder, weightingMap);
+        } else if ("short_fastest".equalsIgnoreCase(weighting)) {
+            return new ShortFastestWeighting(encoder, hintsMap);
         }
 
         throw new IllegalArgumentException("weighting " + weighting + " not supported");
@@ -1008,23 +940,21 @@ public Weighting createWeighting( HintsMap weightingMap, FlagEncoder encoder )
     /**
      * Potentially wraps the specified weighting into a TurnWeighting instance.
      */
-    public Weighting createTurnWeighting( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
+    public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
+        FlagEncoder encoder = weighting.getFlagEncoder();
         if (encoder.supports(TurnWeighting.class) && !tMode.equals(TraversalMode.NODE_BASED))
-            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+            return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
         return weighting;
     }
 
     @Override
-    public GHResponse route( GHRequest request )
-    {
+    public GHResponse route(GHRequest request) {
         GHResponse response = new GHResponse();
         calcPaths(request, response);
         return response;
     }
 
-    public List<Path> calcPaths( GHRequest request, GHResponse ghRsp )
-    {
+    public List<Path> calcPaths(GHRequest request, GHResponse ghRsp) {
         if (ghStorage == null || !fullyLoaded)
             throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
 
@@ -1033,14 +963,12 @@ public GHResponse route( GHRequest request )
 
         // default handling
         String vehicle = request.getVehicle();
-        if (vehicle.isEmpty())
-        {
+        if (vehicle.isEmpty()) {
             vehicle = getDefaultVehicle().toString();
             request.setVehicle(vehicle);
         }
 
-        try
-        {
+        try {
             if (!encodingManager.supports(vehicle))
                 throw new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
                         + "Supported are: " + getEncodingManager());
@@ -1055,6 +983,10 @@ public GHResponse route( GHRequest request )
             List<GHPoint> points = request.getPoints();
             String algoStr = request.getAlgorithm().isEmpty() ? DIJKSTRA_BI : request.getAlgorithm();
 
+            // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
+            // For example see #734
+            checkIfPointsAreInBounds(points);
+
             RoutingTemplate routingTemplate;
             if (ROUND_TRIP.equalsIgnoreCase(algoStr))
                 routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, maxRoundTripRetries);
@@ -1068,8 +1000,7 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
             int maxRetries = routingTemplate.getMaxRetries();
             Locale locale = request.getLocale();
             Translation tr = trMap.getWithFallBack(locale);
-            for (int i = 0; i < maxRetries; i++)
-            {
+            for (int i = 0; i < maxRetries; i++) {
                 StopWatch sw = new StopWatch().start();
                 qResults = routingTemplate.lookup(points, encoder);
                 ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
@@ -1084,8 +1015,7 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                 if (!chFactoryDecorator.isDisablingAllowed() && forceFlexibleMode)
                     throw new IllegalArgumentException("Flexible mode not enabled on the server-side");
 
-                if (chFactoryDecorator.isEnabled() && !forceFlexibleMode)
-                {
+                if (chFactoryDecorator.isEnabled() && !forceFlexibleMode) {
                     boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
                     if (!forceCHHeading && request.hasFavoredHeading(0))
                         throw new IllegalArgumentException("Heading is not (fully) supported for CHGraph. See issue #483");
@@ -1096,8 +1026,7 @@ else if (!(tmpAlgoFactory instanceof PrepareContractionHierarchies))
                     weighting = ((PrepareContractionHierarchies) tmpAlgoFactory).getWeighting();
                     routingGraph = ghStorage.getGraph(CHGraph.class, weighting);
 
-                } else
-                {
+                } else {
                     weighting = createWeighting(hints, encoder);
                     ghRsp.addDebugInfo("tmode:" + tMode.toString());
                 }
@@ -1108,10 +1037,10 @@ else if (!(tmpAlgoFactory instanceof PrepareContractionHierarchies))
 
                 QueryGraph queryGraph = new QueryGraph(routingGraph);
                 queryGraph.lookup(qResults);
-                weighting = createTurnWeighting(queryGraph, encoder, weighting, tMode);
+                weighting = createTurnWeighting(queryGraph, weighting, tMode);
 
                 AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                        algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                        algorithm(algoStr).traversalMode(tMode).weighting(weighting).
                         maxVisitedNodes(maxVisitedNodesForRequest).
                         hints(hints).
                         build();
@@ -1134,20 +1063,27 @@ else if (!(tmpAlgoFactory instanceof PrepareContractionHierarchies))
 
             return altPaths;
 
-        } catch (IllegalArgumentException ex)
-        {
+        } catch (IllegalArgumentException ex) {
             ghRsp.addError(ex);
             return Collections.emptyList();
         }
     }
 
-    protected LocationIndex createLocationIndex( Directory dir )
-    {
+    private void checkIfPointsAreInBounds(List<GHPoint> points) {
+        BBox bounds = getGraphHopperStorage().getBounds();
+        for (int i = 0; i < points.size(); i++) {
+            GHPoint point = points.get(i);
+            if (!bounds.contains(point.getLat(), point.getLon())) {
+                throw new PointOutOfBoundsException("Point " + i + " is ouf of bounds: " + point, i);
+            }
+        }
+    }
+
+    protected LocationIndex createLocationIndex(Directory dir) {
         LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
         tmpIndex.setMaxRegionSearch(maxRegionSearch);
-        if (!tmpIndex.loadExisting())
-        {
+        if (!tmpIndex.loadExisting()) {
             ensureWriteAccess();
             tmpIndex.prepareIndex();
         }
@@ -1158,19 +1094,16 @@ protected LocationIndex createLocationIndex( Directory dir )
     /**
      * Initializes the location index after the import is done.
      */
-    protected void initLocationIndex()
-    {
+    protected void initLocationIndex() {
         if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
         locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
 
-    protected void prepare()
-    {
+    protected void prepare() {
         boolean tmpPrepare = chFactoryDecorator.isEnabled();
-        if (tmpPrepare)
-        {
+        if (tmpPrepare) {
             ensureWriteAccess();
 
             if (chFactoryDecorator.getPreparationThreads() > 1 && dataAccessType.isMMap() && !dataAccessType.isSynched())
@@ -1185,8 +1118,7 @@ protected void prepare()
     /**
      * Internal method to clean up the graph.
      */
-    protected void cleanUp()
-    {
+    protected void cleanUp() {
         int prevNodeCount = ghStorage.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(ghStorage, encodingManager.fetchEdgeEncoders());
         preparation.setMinNetworkSize(minNetworkSize);
@@ -1200,8 +1132,7 @@ protected void cleanUp()
                 + " less nodes");
     }
 
-    protected void flush()
-    {
+    protected void flush() {
         logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
                 + Helper.getMemInfo() + ")");
         ghStorage.flush();
@@ -1213,19 +1144,16 @@ protected void flush()
      * Releases all associated resources like memory or files. But it does not remove them. To
      * remove the files created in graphhopperLocation you have to call clean().
      */
-    public void close()
-    {
+    public void close() {
         if (ghStorage != null)
             ghStorage.close();
 
         if (locationIndex != null)
             locationIndex.close();
 
-        try
-        {
+        try {
             lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             // silently fail e.g. on Windows where we cannot remove an unreleased native lock
         }
     }
@@ -1234,8 +1162,7 @@ public void close()
      * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
      * load
      */
-    public void clean()
-    {
+    public void clean() {
         if (getGraphHopperLocation().isEmpty())
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
@@ -1243,14 +1170,12 @@ public void clean()
         Helper.removeDir(folder);
     }
 
-    protected void ensureNotLoaded()
-    {
+    protected void ensureNotLoaded() {
         if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
     }
 
-    protected void ensureWriteAccess()
-    {
+    protected void ensureWriteAccess() {
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 512517631b..8576fb65c2 100755
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -20,22 +20,24 @@
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface GraphHopperAPI
-{
+public interface GraphHopperAPI {
     /**
      * Connects to the specified service (graphhopper URL) or loads a graph from the graphhopper
      * folder.
      * <p>
+     *
      * @return true if successfully connected or loaded
      */
-    boolean load( String urlOrFile );
+    boolean load(String urlOrFile);
 
     /**
      * Calculates the path from specified request visiting the specified locations.
      * <p>
+     *
      * @return the response with the route and possible errors
      */
-    GHResponse route( GHRequest request );
+    GHResponse route(GHRequest request);
 }
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 395615a42b..bb4d9034d2 100755
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -27,10 +28,11 @@
 /**
  * This class holds the data like points and instructions of a Path.
  * <p>
+ *
  * @author Peter Karich
  */
-public class PathWrapper
-{
+public class PathWrapper {
+    private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private List<String> description;
     private double distance;
     private double ascend;
@@ -41,27 +43,23 @@
     private InstructionList instructions;
     private PointList waypointList = PointList.EMPTY;
     private PointList pointList = PointList.EMPTY;
-    private final List<Throwable> errors = new ArrayList<Throwable>(4);
 
     /**
      * @return the description of this route alternative to make it meaningful for the user e.g. it
      * displays one or two main roads of the route.
      */
-    public List<String> getDescription()
-    {
+    public List<String> getDescription() {
         if (description == null)
             return Collections.emptyList();
         return description;
     }
 
-    public PathWrapper setDescription( List<String> names )
-    {
+    public PathWrapper setDescription(List<String> names) {
         this.description = names;
         return this;
     }
 
-    public PathWrapper addDebugInfo( String debugInfo )
-    {
+    public PathWrapper addDebugInfo(String debugInfo) {
         if (debugInfo == null)
             throw new IllegalStateException("Debug information has to be none null");
 
@@ -72,125 +70,109 @@ public PathWrapper addDebugInfo( String debugInfo )
         return this;
     }
 
-    public String getDebugInfo()
-    {
+    public String getDebugInfo() {
         return debugInfo;
     }
 
-    public PathWrapper setPoints( PointList points )
-    {
-        if (pointList != PointList.EMPTY)
-            throw new IllegalStateException("Cannot call setPoint twice");
-
-        pointList = points;
-        return this;
-    }
-
     /**
      * This method returns all points on the path. Keep in mind that calculating the distance from
      * these points might yield different results compared to getDistance as points could have been
      * simplified on import or after querying.
      */
-    public PointList getPoints()
-    {
+    public PointList getPoints() {
         check("getPoints");
         return pointList;
     }
 
-    /**
-     * This method initializes this path with the snapped input points.
-     */
-    public void setWaypoints( PointList wpList )
-    {
-        if (waypointList != PointList.EMPTY)
-            throw new IllegalStateException("Cannot call setWaypoints twice");
+    public PathWrapper setPoints(PointList points) {
+        if (pointList != PointList.EMPTY)
+            throw new IllegalStateException("Cannot call setPoint twice");
 
-        this.waypointList = wpList;
+        pointList = points;
+        return this;
     }
 
     /**
      * This method returns the input points snapped to the road network.
      */
-    public PointList getWaypoints()
-    {
+    public PointList getWaypoints() {
         check("getWaypoints");
         return waypointList;
     }
 
-    public PathWrapper setDistance( double distance )
-    {
-        this.distance = distance;
-        return this;
+    /**
+     * This method initializes this path with the snapped input points.
+     */
+    public void setWaypoints(PointList wpList) {
+        if (waypointList != PointList.EMPTY)
+            throw new IllegalStateException("Cannot call setWaypoints twice");
+
+        this.waypointList = wpList;
     }
 
     /**
      * This method returns the distance of the path. Always prefer this method over
      * getPoints().calcDistance
      * <p>
+     *
      * @return distance in meter
      */
-    public double getDistance()
-    {
+    public double getDistance() {
         check("getDistance");
         return distance;
     }
 
-    public PathWrapper setAscend( double ascend )
-    {
-        if (ascend < 0)
-            throw new IllegalArgumentException("ascend has to be strictly positive");
-
-        this.ascend = ascend;
+    public PathWrapper setDistance(double distance) {
+        this.distance = distance;
         return this;
     }
 
     /**
      * This method returns the total elevation change (going upwards) in meter.
      * <p>
+     *
      * @return ascend in meter
      */
-    public double getAscend()
-    {
+    public double getAscend() {
         return ascend;
     }
 
-    public PathWrapper setDescend( double descend )
-    {
-        if (descend < 0)
-            throw new IllegalArgumentException("descend has to be strictly positive");
+    public PathWrapper setAscend(double ascend) {
+        if (ascend < 0)
+            throw new IllegalArgumentException("ascend has to be strictly positive");
 
-        this.descend = descend;
+        this.ascend = ascend;
         return this;
     }
 
     /**
      * This method returns the total elevation change (going downwards) in meter.
      * <p>
+     *
      * @return decline in meter
      */
-    public double getDescend()
-    {
+    public double getDescend() {
         return descend;
     }
 
-    public PathWrapper setTime( long timeInMillis )
-    {
-        this.time = timeInMillis;
+    public PathWrapper setDescend(double descend) {
+        if (descend < 0)
+            throw new IllegalArgumentException("descend has to be strictly positive");
+
+        this.descend = descend;
         return this;
     }
 
     /**
      * @return time in millis
      */
-    public long getTime()
-    {
+    public long getTime() {
         check("getTimes");
         return time;
     }
 
-    public PathWrapper setRouteWeight( double weight )
-    {
-        this.routeWeight = weight;
+    public PathWrapper setTime(long timeInMillis) {
+        this.time = timeInMillis;
         return this;
     }
 
@@ -199,33 +181,33 @@ public PathWrapper setRouteWeight( double weight )
      * only if you know what you are doing, e.g. only to compare routes gained with the same query
      * parameters like vehicle.
      */
-    public double getRouteWeight()
-    {
+    public double getRouteWeight() {
         check("getRouteWeight");
         return routeWeight;
     }
 
+    public PathWrapper setRouteWeight(double weight) {
+        this.routeWeight = weight;
+        return this;
+    }
+
     /**
      * Calculates the bounding box of this route response
      */
-    public BBox calcRouteBBox( BBox _fallback )
-    {
+    public BBox calcRouteBBox(BBox _fallback) {
         check("calcRouteBBox");
         BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = pointList.getSize();
         if (len == 0)
             return _fallback;
 
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             double lat = pointList.getLatitude(i);
             double lon = pointList.getLongitude(i);
-            if (bounds.hasElevation())
-            {
+            if (bounds.hasElevation()) {
                 double ele = pointList.getEle(i);
                 bounds.update(lat, lon, ele);
-            } else
-            {
+            } else {
                 bounds.update(lat, lon);
             }
         }
@@ -233,8 +215,7 @@ public BBox calcRouteBBox( BBox _fallback )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = "nodes:" + pointList.getSize() + "; " + pointList.toString();
         if (instructions != null && !instructions.isEmpty())
             str += ", " + instructions.toString();
@@ -245,13 +226,7 @@ public String toString()
         return str;
     }
 
-    public void setInstructions( InstructionList instructions )
-    {
-        this.instructions = instructions;
-    }
-
-    public InstructionList getInstructions()
-    {
+    public InstructionList getInstructions() {
         check("getInstructions");
         if (instructions == null)
             throw new IllegalArgumentException("To access instructions you need to enable creation before routing");
@@ -259,10 +234,12 @@ public InstructionList getInstructions()
         return instructions;
     }
 
-    private void check( String method )
-    {
-        if (hasErrors())
-        {
+    public void setInstructions(InstructionList instructions) {
+        this.instructions = instructions;
+    }
+
+    private void check(String method) {
+        if (hasErrors()) {
             throw new RuntimeException("You cannot call " + method + " if response contains errors. Check this with ghResponse.hasErrors(). "
                     + "Errors are: " + getErrors());
         }
@@ -271,24 +248,20 @@ private void check( String method )
     /**
      * @return true if this alternative response contains one or more errors
      */
-    public boolean hasErrors()
-    {
+    public boolean hasErrors() {
         return !errors.isEmpty();
     }
 
-    public List<Throwable> getErrors()
-    {
+    public List<Throwable> getErrors() {
         return errors;
     }
 
-    public PathWrapper addError( Throwable error )
-    {
+    public PathWrapper addError(Throwable error) {
         errors.add(error);
         return this;
     }
 
-    public PathWrapper addErrors( List<Throwable> errors )
-    {
+    public PathWrapper addErrors(List<Throwable> errors) {
         this.errors.addAll(errors);
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/coll/BinHeapWrapper.java b/core/src/main/java/com/graphhopper/coll/BinHeapWrapper.java
index c406be5e2d..3db143816f 100755
--- a/core/src/main/java/com/graphhopper/coll/BinHeapWrapper.java
+++ b/core/src/main/java/com/graphhopper/coll/BinHeapWrapper.java
@@ -20,12 +20,11 @@
 /**
  * @author Peter Karich
  */
-public interface BinHeapWrapper<K, E>
-{
+public interface BinHeapWrapper<K, E> {
 
-    void update( K key, E element );
+    void update(K key, E element);
 
-    void insert( K key, E element );
+    void insert(K key, E element);
 
     boolean isEmpty();
 
@@ -40,5 +39,5 @@
     // not necessary? V pollValue();
     void clear();
 
-    void ensureCapacity( int size );
+    void ensureCapacity(int size);
 }
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index db273f9a15..9e9443f79d 100755
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -33,10 +33,10 @@
  * Stores the entries in compressed segments. The methods de(compress) are taken from lucene
  * CompressionTools. Before accessing the stored values be sure you called flush.
  * <p>
+ *
  * @author Peter Karich
  */
-public class CompressedArray
-{
+public class CompressedArray {
     private int compressionLevel = 5;
     private VLongStorage currentWriter;
     private int currentEntry = 0;
@@ -45,20 +45,17 @@
     private int approxBytesPerEntry;
     private SpatialKeyAlgo algo;
 
-    public CompressedArray()
-    {
+    public CompressedArray() {
         this(100, 200, 4);
     }
 
     /**
-     * @param _segments initialize with this number of segments
-     * @param entriesPerSeg a static number which sets the entries per segment
+     * @param _segments           initialize with this number of segments
+     * @param entriesPerSeg       a static number which sets the entries per segment
      * @param approxBytesPerEntry an *approximative* number (as entries can have different lengths)
      */
-    public CompressedArray( int _segments, int entriesPerSeg, int approxBytesPerEntry )
-    {
-        if (entriesPerSeg < 1)
-        {
+    public CompressedArray(int _segments, int entriesPerSeg, int approxBytesPerEntry) {
+        if (entriesPerSeg < 1) {
             throw new IllegalArgumentException("at least one entry should be per segment");
         }
         this.entriesPerSegment = entriesPerSeg;
@@ -67,16 +64,60 @@ public CompressedArray( int _segments, int entriesPerSeg, int approxBytesPerEntr
         algo = new SpatialKeyAlgo(63);
     }
 
-    public CompressedArray setCompressionLevel( int compressionLevel )
-    {
+    /**
+     * Compresses the specified byte range using the specified compressionLevel (constants are
+     * defined in java.util.zip.Deflater).
+     */
+    public static byte[] compress(byte[] value, int offset, int length, int compressionLevel) {
+        /* Create an expandable byte array to hold the compressed data.
+         * You cannot use an array that's the same size as the orginal because
+         * there is no guarantee that the compressed data will be smaller than
+         * the uncompressed data. */
+        ByteArrayOutputStream bos = new ByteArrayOutputStream(length);
+        Deflater compressor = new Deflater();
+        try {
+            compressor.setLevel(compressionLevel);
+            compressor.setInput(value, offset, length);
+            compressor.finish();
+            final byte[] buf = new byte[1024];
+            while (!compressor.finished()) {
+                int count = compressor.deflate(buf);
+                bos.write(buf, 0, count);
+            }
+        } finally {
+            compressor.end();
+        }
+        return bos.toByteArray();
+    }
+
+    /**
+     * Decompress the byte array previously returned by compress
+     */
+    public static byte[] decompress(byte[] value) throws DataFormatException {
+        // Create an expandable byte array to hold the decompressed data
+        ByteArrayOutputStream bos = new ByteArrayOutputStream(value.length);
+        Inflater decompressor = new Inflater();
+        try {
+            decompressor.setInput(value);
+            final byte[] buf = new byte[1024];
+            while (!decompressor.finished()) {
+                int count = decompressor.inflate(buf);
+                bos.write(buf, 0, count);
+            }
+        } finally {
+            decompressor.end();
+        }
+
+        return bos.toByteArray();
+    }
+
+    public CompressedArray setCompressionLevel(int compressionLevel) {
         this.compressionLevel = compressionLevel;
         return this;
     }
 
-    public void write( double lat, double lon )
-    {
-        try
-        {
+    public void write(double lat, double lon) {
+        try {
             if (currentWriter == null)
                 currentWriter = new VLongStorage(entriesPerSegment * approxBytesPerEntry);
 
@@ -85,131 +126,61 @@ public void write( double lat, double lon )
             // but compression of vlong is much more efficient than directly storing the integers
             currentWriter.writeVLong(latlon);
             currentEntry++;
-            if (currentEntry >= entriesPerSegment)
-            {
+            if (currentEntry >= entriesPerSegment) {
                 flush();
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    public GHPoint get( long index )
-    {
+    public GHPoint get(long index) {
         int segmentNo = (int) (index / entriesPerSegment);
         int entry = (int) (index % entriesPerSegment);
-        try
-        {
-            if (segmentNo >= segments.size())
-            {
+        try {
+            if (segmentNo >= segments.size()) {
                 return null;
             }
             byte[] bytes = segments.get(segmentNo);
             VLongStorage store = new VLongStorage(decompress(bytes));
             long len = store.getLength();
-            for (int i = 0; store.getPosition() < len; i++)
-            {
+            for (int i = 0; store.getPosition() < len; i++) {
                 long latlon = store.readVLong();
-                if (i == entry)
-                {
+                if (i == entry) {
                     GHPoint point = new GHPoint();
                     algo.decode(latlon, point);
                     return point;
                 }
             }
             return null;
-        } catch (ArrayIndexOutOfBoundsException ex)
-        {
+        } catch (ArrayIndexOutOfBoundsException ex) {
             throw new RuntimeException("index " + index + "=> segNo:" + segmentNo + ", entry=" + entry
                     + ", segments:" + segments.size(), ex);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    public void flush()
-    {
-        if (currentWriter == null)
-        {
+    public void flush() {
+        if (currentWriter == null) {
             return;
         }
-        try
-        {
+        try {
             currentWriter.trimToSize();
             byte[] input = currentWriter.getBytes();
             segments.add(compress(input, 0, input.length, compressionLevel));
             currentWriter = null;
             currentEntry = 0;
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    public float calcMemInMB()
-    {
+    public float calcMemInMB() {
         long bytes = 0;
-        for (int i = 0; i < segments.size(); i++)
-        {
+        for (int i = 0; i < segments.size(); i++) {
             bytes += segments.get(i).length;
         }
         return (float) (segments.size() * 4 + bytes) / Helper.MB;
     }
-
-    /**
-     * Compresses the specified byte range using the specified compressionLevel (constants are
-     * defined in java.util.zip.Deflater).
-     */
-    public static byte[] compress( byte[] value, int offset, int length, int compressionLevel )
-    {
-        /* Create an expandable byte array to hold the compressed data.
-         * You cannot use an array that's the same size as the orginal because
-         * there is no guarantee that the compressed data will be smaller than
-         * the uncompressed data. */
-        ByteArrayOutputStream bos = new ByteArrayOutputStream(length);
-        Deflater compressor = new Deflater();
-        try
-        {
-            compressor.setLevel(compressionLevel);
-            compressor.setInput(value, offset, length);
-            compressor.finish();
-            final byte[] buf = new byte[1024];
-            while (!compressor.finished())
-            {
-                int count = compressor.deflate(buf);
-                bos.write(buf, 0, count);
-            }
-        } finally
-        {
-            compressor.end();
-        }
-        return bos.toByteArray();
-    }
-
-    /**
-     * Decompress the byte array previously returned by compress
-     */
-    public static byte[] decompress( byte[] value ) throws DataFormatException
-    {
-        // Create an expandable byte array to hold the decompressed data
-        ByteArrayOutputStream bos = new ByteArrayOutputStream(value.length);
-        Inflater decompressor = new Inflater();
-        try
-        {
-            decompressor.setInput(value);
-            final byte[] buf = new byte[1024];
-            while (!decompressor.finished())
-            {
-                int count = decompressor.inflate(buf);
-                bos.write(buf, 0, count);
-            }
-        } finally
-        {
-            decompressor.end();
-        }
-
-        return bos.toByteArray();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSet.java b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
index e18356fcbd..74f8e1ad00 100755
--- a/core/src/main/java/com/graphhopper/coll/GHBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
@@ -21,15 +21,15 @@
  * Wrapper interface of an integer container for different implementations like OpenBitset, BitSet,
  * ...
  * <p>
+ *
  * @author Peter Karich
  */
-public interface GHBitSet
-{
-    boolean contains( int index );
+public interface GHBitSet {
+    boolean contains(int index);
 
-    void add( int index );
+    void add(int index);
 
-    void remove( int index );
+    void remove(int index);
 
     int getCardinality();
 
@@ -38,12 +38,13 @@
     /**
      * Searches for a greater or equal entry and returns it.
      * <p>
+     *
      * @return -1 if nothing found
      */
-    int next( int index );
+    int next(int index);
 
     /**
      * @return the specified MyBitSet bs
      */
-    GHBitSet copyTo( GHBitSet bs );
+    GHBitSet copyTo(GHBitSet bs);
 }
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index d2f0bfda66..26a83fd969 100755
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -22,64 +22,51 @@
 /**
  * @author Peter Karich
  */
-public class GHBitSetImpl extends BitSet implements GHBitSet
-{
-    public GHBitSetImpl()
-    {
+public class GHBitSetImpl extends BitSet implements GHBitSet {
+    public GHBitSetImpl() {
     }
 
-    public GHBitSetImpl( int nbits )
-    {
+    public GHBitSetImpl(int nbits) {
         super(nbits);
     }
 
     @Override
-    public final boolean contains( int index )
-    {
+    public final boolean contains(int index) {
         return super.get(index);
     }
 
     @Override
-    public final void add( int index )
-    {
+    public final void add(int index) {
         super.set(index);
     }
 
     @Override
-    public final int getCardinality()
-    {
+    public final int getCardinality() {
         return super.cardinality();
     }
 
     @Override
-    public final int next( int index )
-    {
+    public final int next(int index) {
         return super.nextSetBit(index);
     }
 
-    public final int nextClear( int index )
-    {
+    public final int nextClear(int index) {
         return super.nextClearBit(index);
     }
 
     @Override
-    public void remove( int index )
-    {
+    public void remove(int index) {
         super.clear(index);
     }
 
     @Override
-    public final GHBitSet copyTo( GHBitSet bs )
-    {
+    public final GHBitSet copyTo(GHBitSet bs) {
         bs.clear();
-        if (bs instanceof GHBitSetImpl)
-        {
+        if (bs instanceof GHBitSetImpl) {
             ((GHBitSetImpl) bs).or(this);
-        } else
-        {
+        } else {
             for (int index = super.nextSetBit(0); index >= 0;
-                    index = super.nextSetBit(index + 1))
-            {
+                 index = super.nextSetBit(index + 1)) {
                 bs.add(index);
             }
         }
diff --git a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
index 583ef85bef..5021ea4e2c 100755
--- a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
+++ b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
@@ -18,22 +18,21 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.Helper;
-
-import java.util.Arrays;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Arrays;
+
 /**
  * An in-memory simple B-Tree. Later we'll use DataAccess to allow on-disc storage for very large
  * data sets. Delete not supported.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHLongIntBTree implements LongIntMap
-{
-    private Logger logger = LoggerFactory.getLogger(getClass());
+public class GHLongIntBTree implements LongIntMap {
     private final int noNumberValue = -1;
+    private Logger logger = LoggerFactory.getLogger(getClass());
     private long size;
     private int maxLeafEntries;
     private int initLeafSize;
@@ -42,51 +41,67 @@
     private int height;
     private BTreeEntry root;
 
-    public GHLongIntBTree( int maxLeafEntries )
-    {
+    public GHLongIntBTree(int maxLeafEntries) {
         this.maxLeafEntries = maxLeafEntries;
-        if (maxLeafEntries < 1)
-        {
+        if (maxLeafEntries < 1) {
             throw new IllegalArgumentException("illegal maxLeafEntries:" + maxLeafEntries);
         }
-        if (maxLeafEntries % 2 == 0)
-        {
+        if (maxLeafEntries % 2 == 0) {
             maxLeafEntries++;
         }
 
         splitIndex = maxLeafEntries / 2;
-        if (maxLeafEntries < 10)
-        {
+        if (maxLeafEntries < 10) {
             factor = 2;
             initLeafSize = 1;
-        } else if (maxLeafEntries < 20)
-        {
+        } else if (maxLeafEntries < 20) {
             factor = 2;
             initLeafSize = 4;
-        } else
-        {
+        } else {
             factor = 1.7f;
             initLeafSize = maxLeafEntries / 10;
         }
         clear();
     }
 
+    // LATER: see OSMIDMap for a version where we use DataAccess
+    static int binarySearch(long keys[], int start, int len, long key) {
+        int high = start + len, low = start - 1, guess;
+        while (high - low > 1) {
+            // use >>> for average or we could get an integer overflow.
+            guess = (high + low) >>> 1;
+            long guessedKey = keys[guess];
+            if (guessedKey < key) {
+                low = guess;
+            } else {
+                high = guess;
+            }
+        }
+
+        if (high == start + len) {
+            return ~(start + len);
+        }
+
+        long highKey = keys[high];
+        if (highKey == key) {
+            return high;
+        } else {
+            return ~high;
+        }
+    }
+
     @Override
-    public int put( long key, int value )
-    {
-        if (key == noNumberValue)
-        {
+    public int put(long key, int value) {
+        if (key == noNumberValue) {
             throw new IllegalArgumentException("Illegal key " + key);
         }
 
         ReturnValue rv = root.put(key, value);
-        if (rv.tree != null)
-        {
+        if (rv.tree != null) {
             height++;
             root = rv.tree;
         }
-        if (rv.oldValue == noNumberValue)
-        {
+        if (rv.oldValue == noNumberValue) {
             // successfully inserted
             size++;
             if (size % 1000000 == 0)
@@ -96,19 +111,16 @@ public int put( long key, int value )
     }
 
     @Override
-    public int get( long key )
-    {
+    public int get(long key) {
         return root.get(key);
     }
 
-    int height()
-    {
+    int height() {
         return height;
     }
 
     @Override
-    public long getSize()
-    {
+    public long getSize() {
         return size;
     }
 
@@ -116,65 +128,74 @@ public long getSize()
      * @return memory usage in MB
      */
     @Override
-    public int getMemoryUsage()
-    {
+    public int getMemoryUsage() {
         return Math.round(root.getCapacity() / Helper.MB);
     }
 
-    void clear()
-    {
+    void clear() {
         size = 0;
         height = 1;
         root = new BTreeEntry(initLeafSize, true);
     }
 
-    int getNoNumberValue()
-    {
+    int getNoNumberValue() {
         return noNumberValue;
     }
 
-    void flush()
-    {
+    void flush() {
         throw new IllegalStateException("not supported yet");
     }
 
-    private int getEntries()
-    {
+    private int getEntries() {
         return root.getEntries();
     }
 
-    static class ReturnValue
-    {
+    @Override
+    public void optimize() {
+        if (getSize() > 10000) {
+//            StopWatch sw = new StopWatch().start();
+//            int old = memoryUsage();
+            root.compact();
+//            logger.info(size + "| osmIdMap.optimize took: " + sw.stop().getSeconds()
+//                    + " => freed: " + (old - memoryUsage()) + "MB");
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Height:" + height() + ", entries:" + getEntries();
+    }
+
+    void print() {
+        logger.info(root.toString(1));
+    }
+
+    static class ReturnValue {
         int oldValue;
         BTreeEntry tree;
 
-        public ReturnValue()
-        {
+        public ReturnValue() {
         }
 
-        public ReturnValue( int oldValue )
-        {
+        public ReturnValue(int oldValue) {
             this.oldValue = oldValue;
         }
     }
 
-    class BTreeEntry
-    {
+    class BTreeEntry {
         int entrySize;
         long keys[];
         int values[];
         BTreeEntry children[];
         boolean isLeaf;
 
-        public BTreeEntry( int tmpSize, boolean leaf )
-        {
+        public BTreeEntry(int tmpSize, boolean leaf) {
             this.isLeaf = leaf;
             keys = new long[tmpSize];
             values = new int[tmpSize];
 
-            if (!isLeaf)
-            // in a b-tree we need one more entry to point to all children!
-            {
+            if (!isLeaf) {
+                // in a b-tree we need one more entry to point to all children!
                 children = new BTreeEntry[tmpSize + 1];
             }
         }
@@ -183,11 +204,9 @@ public BTreeEntry( int tmpSize, boolean leaf )
          * @return the old value which was associated with the specified key or if no update it
          * returns noNumberValue
          */
-        ReturnValue put( long key, int newValue )
-        {
+        ReturnValue put(long key, int newValue) {
             int index = binarySearch(keys, 0, entrySize, key);
-            if (index >= 0)
-            {
+            if (index >= 0) {
                 // update
                 int oldValue = values[index];
                 values[index] = newValue;
@@ -196,50 +215,35 @@ ReturnValue put( long key, int newValue )
 
             index = ~index;
             ReturnValue downTreeRV;
-            if (isLeaf || children[index] == null)
-            {
+            if (isLeaf || children[index] == null) {
                 // insert
                 downTreeRV = new ReturnValue(noNumberValue);
                 downTreeRV.tree = checkSplitEntry();
-                if (downTreeRV.tree == null)
-                {
+                if (downTreeRV.tree == null) {
                     insertKeyValue(index, key, newValue);
-                } else
-                {
-                    if (index <= splitIndex)
-                    {
-                        downTreeRV.tree.children[0].insertKeyValue(index, key, newValue);
-                    } else
-                    {
-                        downTreeRV.tree.children[1].insertKeyValue(index - splitIndex - 1, key, newValue);
-                    }
+                } else if (index <= splitIndex) {
+                    downTreeRV.tree.children[0].insertKeyValue(index, key, newValue);
+                } else {
+                    downTreeRV.tree.children[1].insertKeyValue(index - splitIndex - 1, key, newValue);
                 }
                 return downTreeRV;
             }
 
             downTreeRV = children[index].put(key, newValue);
-            if (downTreeRV.oldValue != noNumberValue)
-            // only update
+            if (downTreeRV.oldValue != noNumberValue) // only update
             {
                 return downTreeRV;
             }
 
-            if (downTreeRV.tree != null)
-            {
+            if (downTreeRV.tree != null) {
                 // split this treeEntry if it is too big
                 BTreeEntry returnTree, downTree = returnTree = checkSplitEntry();
-                if (downTree == null)
-                {
+                if (downTree == null) {
                     insertTree(index, downTreeRV.tree);
-                } else
-                {
-                    if (index <= splitIndex)
-                    {
-                        downTree.children[0].insertTree(index, downTreeRV.tree);
-                    } else
-                    {
-                        downTree.children[1].insertTree(index - splitIndex - 1, downTreeRV.tree);
-                    }
+                } else if (index <= splitIndex) {
+                    downTree.children[0].insertTree(index, downTreeRV.tree);
+                } else {
+                    downTree.children[1].insertTree(index - splitIndex - 1, downTreeRV.tree);
                 }
 
                 downTreeRV.tree = returnTree;
@@ -251,10 +255,8 @@ ReturnValue put( long key, int newValue )
          * @return null if nothing to do or a new sub tree if this tree capacity is no longer
          * sufficient.
          */
-        BTreeEntry checkSplitEntry()
-        {
-            if (entrySize < maxLeafEntries)
-            {
+        BTreeEntry checkSplitEntry() {
+            if (entrySize < maxLeafEntries) {
                 return null;
             }
 
@@ -278,28 +280,23 @@ BTreeEntry checkSplitEntry()
             return newTree;
         }
 
-        void copy( BTreeEntry fromChild, BTreeEntry toChild, int from, int count )
-        {
+        void copy(BTreeEntry fromChild, BTreeEntry toChild, int from, int count) {
             System.arraycopy(fromChild.keys, from, toChild.keys, 0, count);
             System.arraycopy(fromChild.values, from, toChild.values, 0, count);
-            if (!fromChild.isLeaf)
-            {
+            if (!fromChild.isLeaf) {
                 System.arraycopy(fromChild.children, from, toChild.children, 0, count + 1);
             }
 
             toChild.entrySize = count;
         }
 
-        void insertKeyValue( int index, long key, int newValue )
-        {
+        void insertKeyValue(int index, long key, int newValue) {
             ensureSize(entrySize + 1);
             int count = entrySize - index;
-            if (count > 0)
-            {
+            if (count > 0) {
                 System.arraycopy(keys, index, keys, index + 1, count);
                 System.arraycopy(values, index, values, index + 1, count);
-                if (!isLeaf)
-                {
+                if (!isLeaf) {
                     System.arraycopy(children, index + 1, children, index + 2, count);
                 }
             }
@@ -309,11 +306,9 @@ void insertKeyValue( int index, long key, int newValue )
             entrySize++;
         }
 
-        void insertTree( int index, BTreeEntry tree )
-        {
+        void insertTree(int index, BTreeEntry tree) {
             insertKeyValue(index, tree.keys[0], tree.values[0]);
-            if (!isLeaf)
-            {
+            if (!isLeaf) {
                 // overwrite children
                 children[index] = tree.children[0];
                 // set
@@ -321,16 +316,13 @@ void insertTree( int index, BTreeEntry tree )
             }
         }
 
-        int get( long key )
-        {
+        int get(long key) {
             int index = binarySearch(keys, 0, entrySize, key);
-            if (index >= 0)
-            {
+            if (index >= 0) {
                 return values[index];
             }
             index = ~index;
-            if (isLeaf || children[index] == null)
-            {
+            if (isLeaf || children[index] == null) {
                 return noNumberValue;
             }
             return children[index].get(key);
@@ -339,16 +331,12 @@ int get( long key )
         /**
          * @return used bytes
          */
-        long getCapacity()
-        {
+        long getCapacity() {
             long cap = keys.length * (8 + 4) + 3 * 12 + 4 + 1;
-            if (!isLeaf)
-            {
+            if (!isLeaf) {
                 cap += children.length * 4;
-                for (int i = 0; i < children.length; i++)
-                {
-                    if (children[i] != null)
-                    {
+                for (int i = 0; i < children.length; i++) {
+                    if (children[i] != null) {
                         cap += children[i].getCapacity();
                     }
                 }
@@ -356,15 +344,11 @@ long getCapacity()
             return cap;
         }
 
-        int getEntries()
-        {
+        int getEntries() {
             int entries = 1;
-            if (!isLeaf)
-            {
-                for (int i = 0; i < children.length; i++)
-                {
-                    if (children[i] != null)
-                    {
+            if (!isLeaf) {
+                for (int i = 0; i < children.length; i++) {
+                    if (children[i] != null) {
                         entries += children[i].getEntries();
                     }
                 }
@@ -372,70 +356,53 @@ int getEntries()
             return entries;
         }
 
-        void ensureSize( int size )
-        {
-            if (size <= keys.length)
-            {
+        void ensureSize(int size) {
+            if (size <= keys.length) {
                 return;
             }
             int newSize = Math.min(maxLeafEntries, Math.max(size + 1, Math.round(size * factor)));
             keys = Arrays.copyOf(keys, newSize);
             values = Arrays.copyOf(values, newSize);
-            if (!isLeaf)
-            {
+            if (!isLeaf) {
                 children = Arrays.copyOf(children, newSize + 1);
             }
         }
 
-        void compact()
-        {
+        void compact() {
             int tolerance = 1;
-            if (entrySize + tolerance < keys.length)
-            {
+            if (entrySize + tolerance < keys.length) {
                 keys = Arrays.copyOf(keys, entrySize);
                 values = Arrays.copyOf(values, entrySize);
-                if (!isLeaf)
-                {
+                if (!isLeaf) {
                     children = Arrays.copyOf(children, entrySize + 1);
                 }
             }
 
-            if (!isLeaf)
-            {
-                for (int i = 0; i < children.length; i++)
-                {
-                    if (children[i] != null)
-                    {
+            if (!isLeaf) {
+                for (int i = 0; i < children.length; i++) {
+                    if (children[i] != null) {
                         children[i].compact();
                     }
                 }
             }
         }
 
-        String toString( int height )
-        {
+        String toString(int height) {
             String str = height + ": ";
-            for (int i = 0; i < entrySize; i++)
-            {
-                if (i > 0)
-                {
+            for (int i = 0; i < entrySize; i++) {
+                if (i > 0) {
                     str += ",";
                 }
-                if (keys[i] == noNumberValue)
-                {
+                if (keys[i] == noNumberValue) {
                     str += "-";
-                } else
-                {
+                } else {
                     str += keys[i];
                 }
             }
             str += "\n";
-            if (!isLeaf)
-            {
-                for (int i = 0; i < entrySize + 1; i++)
-                {
-                    if (children[i] != null)
-                    {
+            if (!isLeaf) {
+                for (int i = 0; i < entrySize + 1; i++) {
+                    if (children[i] != null) {
                         str += children[i].toString(height + 1) + "| ";
                     }
                 }
@@ -443,61 +410,4 @@ String toString( int height )
             return str;
         }
     }
-
-    @Override
-    public void optimize()
-    {
-        if (getSize() > 10000)
-        {
-//            StopWatch sw = new StopWatch().start();
-//            int old = memoryUsage();
-            root.compact();
-//            logger.info(size + "| osmIdMap.optimize took: " + sw.stop().getSeconds()
-//                    + " => freed: " + (old - memoryUsage()) + "MB");
-        }
-    }
-
-    @Override
-    public String toString()
-    {
-        return "Height:" + height() + ", entries:" + getEntries();
-    }
-
-    void print()
-    {
-        logger.info(root.toString(1));
-    }
-
-    // LATER: see OSMIDMap for a version where we use DataAccess
-    static int binarySearch( long keys[], int start, int len, long key )
-    {
-        int high = start + len, low = start - 1, guess;
-        while (high - low > 1)
-        {
-            // use >>> for average or we could get an integer overflow. 
-            guess = (high + low) >>> 1;
-            long guessedKey = keys[guess];
-            if (guessedKey < key)
-            {
-                low = guess;
-            } else
-            {
-                high = guess;
-            }
-        }
-
-        if (high == start + len)
-        {
-            return ~(start + len);
-        }
-
-        long highKey = keys[high];
-        if (highKey == key)
-        {
-            return high;
-        } else
-        {
-            return ~high;
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
index 4020c9dcfc..16bf8a2b61 100755
--- a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
+++ b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
@@ -27,86 +27,71 @@
  * A priority queue implemented by a treemap to allow fast key update. Or should we use a standard
  * b-tree?
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHSortedCollection
-{
-    private int size;
+public class GHSortedCollection {
     private final int slidingMeanValue = 20;
     private final TreeMap<Integer, TIntHashSet> map;
+    private int size;
 
-    public GHSortedCollection()
-    {
+    public GHSortedCollection() {
         // use size as indicator for maxEntries => try radix sort?
         map = new TreeMap<Integer, TIntHashSet>();
     }
 
-    public void clear()
-    {
+    public void clear() {
         size = 0;
         map.clear();
     }
 
-    void remove( int key, int value )
-    {
+    void remove(int key, int value) {
         TIntHashSet set = map.get(value);
-        if (set == null || !set.remove(key))
-        {
+        if (set == null || !set.remove(key)) {
             throw new IllegalStateException("cannot remove key " + key + " with value " + value
                     + " - did you insert " + key + "," + value + " before?");
         }
         size--;
-        if (set.isEmpty())
-        {
+        if (set.isEmpty()) {
             map.remove(value);
         }
     }
 
-    public void update( int key, int oldValue, int value )
-    {
+    public void update(int key, int oldValue, int value) {
         remove(key, oldValue);
         insert(key, value);
     }
 
-    public void insert( int key, int value )
-    {
+    public void insert(int key, int value) {
         TIntHashSet set = map.get(value);
-        if (set == null)
-        {
+        if (set == null) {
             map.put(value, set = new TIntHashSet(slidingMeanValue));
         }
 //        else
 //            slidingMeanValue = Math.max(5, (slidingMeanValue + set.size()) / 2);
-        if (!set.add(key))
-        {
+        if (!set.add(key)) {
             throw new IllegalStateException("use update if you want to update " + key);
         }
         size++;
     }
 
-    public int peekValue()
-    {
-        if (size == 0)
-        {
+    public int peekValue() {
+        if (size == 0) {
             throw new IllegalStateException("collection is already empty!?");
         }
         Entry<Integer, TIntHashSet> e = map.firstEntry();
-        if (e.getValue().isEmpty())
-        {
+        if (e.getValue().isEmpty()) {
             throw new IllegalStateException("internal set is already empty!?");
         }
         return map.firstEntry().getKey();
     }
 
-    public int peekKey()
-    {
-        if (size == 0)
-        {
+    public int peekKey() {
+        if (size == 0) {
             throw new IllegalStateException("collection is already empty!?");
         }
         TIntHashSet set = map.firstEntry().getValue();
-        if (set.isEmpty())
-        {
+        if (set.isEmpty()) {
             throw new IllegalStateException("internal set is already empty!?");
         }
         return set.iterator().next();
@@ -115,64 +100,52 @@ public int peekKey()
     /**
      * @return removes the smallest entry (key and value) from this collection
      */
-    public int pollKey()
-    {
+    public int pollKey() {
         size--;
-        if (size < 0)
-        {
+        if (size < 0) {
             throw new IllegalStateException("collection is already empty!?");
         }
         Entry<Integer, TIntHashSet> e = map.firstEntry();
         TIntHashSet set = e.getValue();
         TIntIterator iter = set.iterator();
-        if (set.isEmpty())
-        {
+        if (set.isEmpty()) {
             throw new IllegalStateException("internal set is already empty!?");
         }
         int val = iter.next();
         iter.remove();
-        if (set.isEmpty())
-        {
+        if (set.isEmpty()) {
             map.remove(e.getKey());
         }
         return val;
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return size;
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return size == 0;
     }
 
-    public int getSlidingMeanValue()
-    {
+    public int getSlidingMeanValue() {
         return slidingMeanValue;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         int min = Integer.MAX_VALUE;
         int max = Integer.MIN_VALUE;
-        for (Entry<Integer, TIntHashSet> e : map.entrySet())
-        {
+        for (Entry<Integer, TIntHashSet> e : map.entrySet()) {
             int tmpSize = e.getValue().size();
-            if (min > tmpSize)
-            {
+            if (min > tmpSize) {
                 min = tmpSize;
             }
-            if (max < tmpSize)
-            {
+            if (max < tmpSize) {
                 max = tmpSize;
             }
         }
         String str = "";
-        if (!isEmpty())
-        {
+        if (!isEmpty()) {
             str = ", minEntry=(" + peekKey() + "=>" + peekValue() + ")";
         }
         return "size=" + size + ", treeMap.size=" + map.size()
diff --git a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
index 6735339954..0cf1c615d3 100755
--- a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
@@ -23,75 +23,62 @@
 /**
  * Implements the bitset interface via a trove THashSet. More efficient for a few entries.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHTBitSet implements GHBitSet
-{
+public class GHTBitSet implements GHBitSet {
     private final TIntHashSet tHash;
 
-    public GHTBitSet( TIntHashSet set )
-    {
+    public GHTBitSet(TIntHashSet set) {
         tHash = set;
     }
 
-    public GHTBitSet( int no )
-    {
+    public GHTBitSet(int no) {
         tHash = new TIntHashSet(no, 0.7f, -1);
     }
 
-    public GHTBitSet()
-    {
+    public GHTBitSet() {
         this(1000);
     }
 
     @Override
-    public final boolean contains( int index )
-    {
+    public final boolean contains(int index) {
         return tHash.contains(index);
     }
 
     @Override
-    public final void add( int index )
-    {
+    public final void add(int index) {
         tHash.add(index);
     }
 
     @Override
-    public final String toString()
-    {
+    public final String toString() {
         return tHash.toString();
     }
 
     @Override
-    public final int getCardinality()
-    {
+    public final int getCardinality() {
         return tHash.size();
     }
 
     @Override
-    public final void clear()
-    {
+    public final void clear() {
         tHash.clear();
     }
 
     @Override
-    public void remove( int index )
-    {
+    public void remove(int index) {
         tHash.remove(index);
     }
 
     @Override
-    public final GHBitSet copyTo( GHBitSet bs )
-    {
+    public final GHBitSet copyTo(GHBitSet bs) {
         bs.clear();
-        if (bs instanceof GHTBitSet)
-        {
+        if (bs instanceof GHTBitSet) {
             ((GHTBitSet) bs).tHash.addAll(this.tHash);
-        } else
-        {
+        } else {
             TIntIterator iter = tHash.iterator();
-            while (iter.hasNext())
-            {
+            while (iter.hasNext()) {
                 bs.add(iter.next());
             }
         }
@@ -99,8 +86,7 @@ public final GHBitSet copyTo( GHBitSet bs )
     }
 
     @Override
-    public int next( int index )
-    {
+    public int next(int index) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index 38abd7f07f..90bc1abfc9 100755
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -25,54 +25,46 @@
  * A priority queue implemented by a TreeMap. As the tree map does not allow duplicated we compose
  * the key via priority | nodeId.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHTreeMapComposed
-{
+public class GHTreeMapComposed {
     private static final Integer NOT_EMPTY = new Integer(-3);
     private final BitUtil bitUtil = BitUtil.BIG;
     private final TreeMap<Long, Integer> map;
 
-    public GHTreeMapComposed()
-    {
+    public GHTreeMapComposed() {
         map = new TreeMap<Long, Integer>();
     }
 
-    public void clear()
-    {
+    public void clear() {
         map.clear();
     }
 
-    void remove( int key, int value )
-    {
+    void remove(int key, int value) {
         long v = bitUtil.toLong(value, key);
-        if (!map.remove(v).equals(NOT_EMPTY))
-        {
+        if (!map.remove(v).equals(NOT_EMPTY)) {
             throw new IllegalStateException("cannot remove key " + key + " with value " + value
                     + " - did you insert " + key + "," + value + " before?");
         }
     }
 
-    public void update( int key, int oldValue, int value )
-    {
+    public void update(int key, int oldValue, int value) {
         remove(key, oldValue);
         insert(key, value);
     }
 
-    public void insert( int key, int value )
-    {
+    public void insert(int key, int value) {
         long v = bitUtil.toLong(value, key);
         map.put(v, NOT_EMPTY);
     }
 
-    public int peekValue()
-    {
+    public int peekValue() {
         long key = map.firstEntry().getKey();
         return (int) (key >> 32);
     }
 
-    public int peekKey()
-    {
+    public int peekKey() {
         long key = map.firstEntry().getKey();
         return (int) (key & 0xFFFFFFFFL);
     }
@@ -80,8 +72,7 @@ public int peekKey()
     /**
      * @return removes the smallest entry (key and value) from this collection
      */
-    public int pollKey()
-    {
+    public int pollKey() {
         if (map.isEmpty())
             throw new IllegalStateException("Cannot poll collection is empty!");
 
@@ -89,19 +80,16 @@ public int pollKey()
         return (int) (key & 0xFFFFFFFFL);
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return map.size();
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return map.isEmpty();
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return map.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
index ac0f1b3323..d2f06e6990 100755
--- a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
+++ b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
@@ -20,14 +20,11 @@
 /**
  * @author Peter Karich
  */
-public class IntDoubleBinHeap extends OTPIntDoubleBinHeap implements BinHeapWrapper<Number, Integer>
-{
-    public IntDoubleBinHeap()
-    {
+public class IntDoubleBinHeap extends OTPIntDoubleBinHeap implements BinHeapWrapper<Number, Integer> {
+    public IntDoubleBinHeap() {
     }
 
-    public IntDoubleBinHeap( int capacity )
-    {
+    public IntDoubleBinHeap(int capacity) {
         super(capacity);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/LongIntMap.java b/core/src/main/java/com/graphhopper/coll/LongIntMap.java
index a9f12120bf..015e47b6b2 100755
--- a/core/src/main/java/com/graphhopper/coll/LongIntMap.java
+++ b/core/src/main/java/com/graphhopper/coll/LongIntMap.java
@@ -20,11 +20,10 @@
 /**
  * @author Peter Karich
  */
-public interface LongIntMap
-{
-    int put( long key, int value );
+public interface LongIntMap {
+    int put(long key, int value);
 
-    int get( long key );
+    int get(long key);
 
     long getSize();
 
diff --git a/core/src/main/java/com/graphhopper/coll/MapEntry.java b/core/src/main/java/com/graphhopper/coll/MapEntry.java
index bd740cc119..e68530d629 100755
--- a/core/src/main/java/com/graphhopper/coll/MapEntry.java
+++ b/core/src/main/java/com/graphhopper/coll/MapEntry.java
@@ -23,72 +23,61 @@
 /**
  * Simple impl of Map.Entry. So that we can have ordered maps.
  * <p>
+ *
  * @author Peter Karich
  */
-public class MapEntry<K, V> implements Map.Entry<K, V>, Serializable
-{
+public class MapEntry<K, V> implements Map.Entry<K, V>, Serializable {
     private static final long serialVersionUID = 1L;
     private K key;
     private V value;
 
-    public MapEntry( K key, V value )
-    {
+    public MapEntry(K key, V value) {
         this.key = key;
         this.value = value;
     }
 
     @Override
-    public K getKey()
-    {
+    public K getKey() {
         return key;
     }
 
     @Override
-    public V getValue()
-    {
+    public V getValue() {
         return value;
     }
 
     @Override
-    public V setValue( V value )
-    {
+    public V setValue(V value) {
         this.value = value;
         return value;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getKey() + ", " + getValue();
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-        {
+    public boolean equals(Object obj) {
+        if (obj == null) {
             return false;
         }
-        if (getClass() != obj.getClass())
-        {
+        if (getClass() != obj.getClass()) {
             return false;
         }
         final MapEntry<K, V> other = (MapEntry<K, V>) obj;
-        if (this.key != other.key && (this.key == null || !this.key.equals(other.key)))
-        {
+        if (this.key != other.key && (this.key == null || !this.key.equals(other.key))) {
             return false;
         }
-        if (this.value != other.value && (this.value == null || !this.value.equals(other.value)))
-        {
+        if (this.value != other.value && (this.value == null || !this.value.equals(other.value))) {
             return false;
         }
         return true;
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 7;
         hash = 19 * hash + (this.key != null ? this.key.hashCode() : 0);
         hash = 19 * hash + (this.value != null ? this.value.hashCode() : 0);
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index db0e38699c..2051b6f31e 100755
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -26,25 +26,23 @@
  * This is a special purpose map for writing increasing OSM IDs with consecutive values. It stores
  * a map from long to int in a memory friendly way and but does NOT provide O(1) access.
  * <p>
+ *
  * @author Peter Karich
  */
-public class OSMIDMap implements LongIntMap
-{
+public class OSMIDMap implements LongIntMap {
     private static final BitUtil bitUtil = BitUtil.LITTLE;
     private final DataAccess keys;
     private final DataAccess values;
-    private long lastKey = Long.MIN_VALUE;
-    private long size;
     private final int noEntryValue;
     private final Directory dir;
+    private long lastKey = Long.MIN_VALUE;
+    private long size;
 
-    public OSMIDMap( Directory dir )
-    {
+    public OSMIDMap(Directory dir) {
         this(dir, -1);
     }
 
-    public OSMIDMap( Directory dir, int noNumber )
-    {
+    public OSMIDMap(Directory dir, int noNumber) {
         this.dir = dir;
         this.noEntryValue = noNumber;
         keys = dir.find("osmid_map_keys");
@@ -53,19 +51,42 @@ public OSMIDMap( Directory dir, int noNumber )
         values.create(1000);
     }
 
-    public void remove()
-    {
+    static long binarySearch(DataAccess da, long start, long len, long key) {
+        long high = start + len, low = start - 1, guess;
+        byte[] longBytes = new byte[8];
+        while (high - low > 1) {
+            // use >>> for average or we could get an integer overflow.
+            guess = (high + low) >>> 1;
+            long tmp = guess << 3;
+            da.getBytes(tmp, longBytes, 8);
+            long guessedKey = bitUtil.toLong(longBytes);
+            if (guessedKey < key)
+                low = guess;
+            else
+                high = guess;
+        }
+
+        if (high == start + len)
+            return ~(start + len);
+
+        long tmp = high << 3;
+        da.getBytes(tmp, longBytes, 8);
+        long highKey = bitUtil.toLong(longBytes);
+        if (highKey == key)
+            return high;
+        else
+            return ~high;
+    }
+
+    public void remove() {
         dir.remove(keys);
     }
 
     @Override
-    public int put( long key, int value )
-    {
-        if (key <= lastKey)
-        {
+    public int put(long key, int value) {
+        if (key <= lastKey) {
             long oldValueIndex = binarySearch(keys, 0, getSize(), key);
-            if (oldValueIndex < 0)
-            {
+            if (oldValueIndex < 0) {
                 throw new IllegalStateException("Cannot insert keys lower than "
                         + "the last key " + key + " < " + lastKey + ". Only updating supported");
             }
@@ -89,8 +110,7 @@ public int put( long key, int value )
     }
 
     @Override
-    public int get( long key )
-    {
+    public int get(long key) {
         long retIndex = binarySearch(keys, 0, getSize(), key);
         if (retIndex < 0)
             return noEntryValue;
@@ -98,54 +118,21 @@ public int get( long key )
         return values.getInt(retIndex * 4);
     }
 
-    static long binarySearch( DataAccess da, long start, long len, long key )
-    {
-        long high = start + len, low = start - 1, guess;
-        byte[] longBytes = new byte[8];
-        while (high - low > 1)
-        {
-            // use >>> for average or we could get an integer overflow. 
-            guess = (high + low) >>> 1;
-            long tmp = guess << 3;
-            da.getBytes(tmp, longBytes, 8);
-            long guessedKey = bitUtil.toLong(longBytes);
-            if (guessedKey < key)
-                low = guess;
-            else
-                high = guess;
-        }
-
-        if (high == start + len)
-            return ~(start + len);
-
-        long tmp = high << 3;
-        da.getBytes(tmp, longBytes, 8);
-        long highKey = bitUtil.toLong(longBytes);
-        if (highKey == key)
-            return high;
-        else
-            return ~high;
-    }
-
     @Override
-    public long getSize()
-    {
+    public long getSize() {
         return size / 4;
     }
 
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return keys.getCapacity();
     }
 
     @Override
-    public int getMemoryUsage()
-    {
+    public int getMemoryUsage() {
         return Math.round(getCapacity() / Helper.MB);
     }
 
     @Override
-    public void optimize()
-    {
+    public void optimize() {
     }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
index 6fca682236..a60d8fd920 100755
--- a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
@@ -22,16 +22,17 @@
  * <p>
  * SparseArrays map ints to ints. Unlike a normal array of ints, there can be gaps in the indices.
  */
-public class SparseIntIntArray
-{
+public class SparseIntIntArray {
     private static final int DELETED = Integer.MIN_VALUE;
     private boolean mGarbage = false;
+    private int[] mKeys;
+    private int[] mValues;
+    private int mSize;
 
     /**
      * Creates a new SparseIntIntArray containing no mappings.
      */
-    public SparseIntIntArray()
-    {
+    public SparseIntIntArray() {
         this(10);
     }
 
@@ -39,27 +40,45 @@ public SparseIntIntArray()
      * Creates a new SparseIntIntArray containing no mappings that will not require any additional
      * memory allocation to store the specified number of mappings.
      */
-    public SparseIntIntArray( int cap )
-    {
-        try
-        {
+    public SparseIntIntArray(int cap) {
+        try {
             cap = Helper.idealIntArraySize(cap);
             mKeys = new int[cap];
             mValues = new int[cap];
             mSize = 0;
-        } catch (OutOfMemoryError err)
-        {
+        } catch (OutOfMemoryError err) {
             System.err.println("requested capacity " + cap);
             throw err;
         }
     }
 
+    static int binarySearch(int[] a, int start, int len, int key) {
+        int high = start + len, low = start - 1, guess;
+        while (high - low > 1) {
+            // use >>> for average or we could get an integer overflow.
+            guess = (high + low) >>> 1;
+
+            if (a[guess] < key) {
+                low = guess;
+            } else {
+                high = guess;
+            }
+        }
+
+        if (high == start + len) {
+            return ~(start + len);
+        } else if (a[high] == key) {
+            return high;
+        } else {
+            return ~high;
+        }
+    }
+
     /**
      * Gets the Object mapped from the specified key, or <code>null</code> if no such mapping has
      * been made.
      */
-    public int get( int key )
-    {
+    public int get(int key) {
         return get(key, -1);
     }
 
@@ -67,14 +86,11 @@ public int get( int key )
      * Gets the Object mapped from the specified key, or the specified Object if no such mapping has
      * been made.
      */
-    private int get( int key, int valueIfKeyNotFound )
-    {
+    private int get(int key, int valueIfKeyNotFound) {
         int i = binarySearch(mKeys, 0, mSize, key);
-        if (i < 0 || mValues[i] == DELETED)
-        {
+        if (i < 0 || mValues[i] == DELETED) {
             return valueIfKeyNotFound;
-        } else
-        {
+        } else {
             return mValues[i];
         }
     }
@@ -82,30 +98,24 @@ private int get( int key, int valueIfKeyNotFound )
     /**
      * Removes the mapping from the specified key, if there was any.
      */
-    public void remove( int key )
-    {
+    public void remove(int key) {
         int i = binarySearch(mKeys, 0, mSize, key);
-        if (i >= 0 && mValues[i] != DELETED)
-        {
+        if (i >= 0 && mValues[i] != DELETED) {
             mValues[i] = DELETED;
             mGarbage = true;
         }
     }
 
-    private void gc()
-    {
+    private void gc() {
         int n = mSize;
         int o = 0;
         int[] keys = mKeys;
         int[] values = mValues;
 
-        for (int i = 0; i < n; i++)
-        {
+        for (int i = 0; i < n; i++) {
             int val = values[i];
-            if (val != DELETED)
-            {
-                if (i != o)
-                {
+            if (val != DELETED) {
+                if (i != o) {
                     keys[o] = keys[i];
                     values[o] = val;
                 }
@@ -122,34 +132,28 @@ private void gc()
      * Adds a mapping from the specified key to the specified value, replacing the previous mapping
      * from the specified key if there was one.
      */
-    public int put( int key, int value )
-    {
+    public int put(int key, int value) {
         int i = binarySearch(mKeys, 0, mSize, key);
 
-        if (i >= 0)
-        {
+        if (i >= 0) {
             mValues[i] = value;
-        } else
-        {
+        } else {
             i = ~i;
 
-            if (i < mSize && mValues[i] == DELETED)
-            {
+            if (i < mSize && mValues[i] == DELETED) {
                 mKeys[i] = key;
                 mValues[i] = value;
                 return i;
             }
 
-            if (mGarbage && mSize >= mKeys.length)
-            {
+            if (mGarbage && mSize >= mKeys.length) {
                 gc();
 
                 // Search again because indices may have changed.
                 i = ~binarySearch(mKeys, 0, mSize, key);
             }
 
-            if (mSize >= mKeys.length)
-            {
+            if (mSize >= mKeys.length) {
                 int n = Helper.idealIntArraySize(mSize + 1);
 
                 int[] nkeys = new int[n];
@@ -162,8 +166,7 @@ public int put( int key, int value )
                 mValues = nvalues;
             }
 
-            if (mSize - i != 0)
-            {
+            if (mSize - i != 0) {
                 System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
                 System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
             }
@@ -178,10 +181,8 @@ public int put( int key, int value )
     /**
      * Returns the number of key-value mappings that this SparseIntIntArray currently stores.
      */
-    public int getSize()
-    {
-        if (mGarbage)
-        {
+    public int getSize() {
+        if (mGarbage) {
             gc();
         }
 
@@ -192,10 +193,8 @@ public int getSize()
      * Given an index in the range <code>0...size()-1</code>, returns the key from the
      * <code>index</code>th key-value mapping that this SparseIntIntArray stores.
      */
-    public int keyAt( int index )
-    {
-        if (mGarbage)
-        {
+    public int keyAt(int index) {
+        if (mGarbage) {
             gc();
         }
 
@@ -206,10 +205,8 @@ public int keyAt( int index )
      * Given an index in the range <code>0...size()-1</code>, sets a new key for the
      * <code>index</code>th key-value mapping that this SparseIntIntArray stores.
      */
-    public void setKeyAt( int index, int key )
-    {
-        if (mGarbage)
-        {
+    public void setKeyAt(int index, int key) {
+        if (mGarbage) {
             gc();
         }
 
@@ -220,10 +217,8 @@ public void setKeyAt( int index, int key )
      * Given an index in the range <code>0...size()-1</code>, returns the value from the
      * <code>index</code>th key-value mapping that this SparseIntIntArray stores.
      */
-    public int valueAt( int index )
-    {
-        if (mGarbage)
-        {
+    public int valueAt(int index) {
+        if (mGarbage) {
             gc();
         }
 
@@ -234,10 +229,8 @@ public int valueAt( int index )
      * Given an index in the range <code>0...size()-1</code>, sets a new value for the
      * <code>index</code>th key-value mapping that this SparseIntIntArray stores.
      */
-    public void setValueAt( int index, int value )
-    {
-        if (mGarbage)
-        {
+    public void setValueAt(int index, int value) {
+        if (mGarbage) {
             gc();
         }
 
@@ -247,12 +240,10 @@ public void setValueAt( int index, int value )
     /**
      * Removes all key-value mappings from this SparseIntIntArray.
      */
-    public void clear()
-    {
+    public void clear() {
         int n = mSize;
         int[] values = mValues;
-        for (int i = 0; i < n; i++)
-        {
+        for (int i = 0; i < n; i++) {
             values[i] = -1;
         }
 
@@ -264,21 +255,17 @@ public void clear()
      * Puts a key/value pair into the array, optimizing for the case where the key is greater than
      * all existing keys in the array.
      */
-    public int append( int key, int value )
-    {
-        if (mSize != 0 && key <= mKeys[mSize - 1])
-        {
+    public int append(int key, int value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
             return put(key, value);
         }
 
-        if (mGarbage && mSize >= mKeys.length)
-        {
+        if (mGarbage && mSize >= mKeys.length) {
             gc();
         }
 
         int pos = mSize;
-        if (pos >= mKeys.length)
-        {
+        if (pos >= mKeys.length) {
             int n = Helper.idealIntArraySize(pos + 1);
 
             int[] nkeys = new int[n];
@@ -298,15 +285,12 @@ public int append( int key, int value )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < getSize(); i++)
-        {
+        for (int i = 0; i < getSize(); i++) {
             int k = mKeys[i];
             int v = mValues[i];
-            if (i > 0)
-            {
+            if (i > 0) {
                 sb.append(",");
             }
             sb.append(k);
@@ -319,41 +303,7 @@ public String toString()
     /**
      * Warning: returns ~index and not -(index+1) like trove and jdk do
      */
-    public int binarySearch( int key )
-    {
+    public int binarySearch(int key) {
         return binarySearch(mKeys, 0, mSize, key);
     }
-
-    static int binarySearch( int[] a, int start, int len, int key )
-    {
-        int high = start + len, low = start - 1, guess;
-        while (high - low > 1)
-        {
-            // use >>> for average or we could get an integer overflow. 
-            guess = (high + low) >>> 1;
-
-            if (a[guess] < key)
-            {
-                low = guess;
-            } else
-            {
-                high = guess;
-            }
-        }
-
-        if (high == start + len)
-        {
-            return ~(start + len);
-        } else if (a[high] == key)
-        {
-            return high;
-        } else
-        {
-            return ~high;
-        }
-    }
-
-    private int[] mKeys;
-    private int[] mValues;
-    private int mSize;
 }
diff --git a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
index a6d08116db..43ccc517d5 100755
--- a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
@@ -23,19 +23,19 @@
  * Defines the mapping between a one dimensional 'number' and a point (lat, lon) which is limited to
  * a defined bounds.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface KeyAlgo
-{
+public interface KeyAlgo {
 
     /**
      * Sets the bounds of the underlying key algorithm.
      */
-    KeyAlgo setBounds( double minLonInit, double maxLonInit, double minLatInit, double maxLatInit );
+    KeyAlgo setBounds(double minLonInit, double maxLonInit, double minLatInit, double maxLatInit);
 
-    long encode( GHPoint coord );
+    long encode(GHPoint coord);
 
-    long encode( double lat, double lon );
+    long encode(double lat, double lon);
 
-    void decode( long spatialKey, GHPoint latLon );
+    void decode(long spatialKey, GHPoint latLon);
 }
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 01b3248f8d..e2a1a9d067 100755
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -23,6 +23,7 @@
 /**
  * This class maps lat,lon to a (tile)number unlike SpatialKeyAlgo.
  * <p>
+ *
  * @author Peter Karich
  */
 // A 4*3 precision linear key will look like
@@ -36,54 +37,48 @@
 //     |----|----|----|----|
 //
 //              lon
-public class LinearKeyAlgo implements KeyAlgo
-{
+public class LinearKeyAlgo implements KeyAlgo {
+    private static final double C = 1 - 1e-15;
+    private final int latUnits, lonUnits;
     private BBox bounds;
     private double latDelta, lonDelta;
-    private final int latUnits, lonUnits;
-    private static final double C = 1 - 1e-15;
 
-    public LinearKeyAlgo( int latUnits, int lonUnits )
-    {
+    public LinearKeyAlgo(int latUnits, int lonUnits) {
         this.latUnits = latUnits;
         this.lonUnits = lonUnits;
         setWorldBounds();
     }
 
     @Override
-    public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double minLatInit, double maxLatInit )
-    {
+    public LinearKeyAlgo setBounds(double minLonInit, double maxLonInit, double minLatInit, double maxLatInit) {
         bounds = new BBox(minLonInit, maxLonInit, minLatInit, maxLatInit);
         latDelta = (bounds.maxLat - bounds.minLat) / latUnits;
         lonDelta = (bounds.maxLon - bounds.minLon) / lonUnits;
         return this;
     }
 
-    public LinearKeyAlgo setBounds( BBox bounds )
-    {
+    public LinearKeyAlgo setBounds(BBox bounds) {
         setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
-    protected void setWorldBounds()
-    {
+    protected void setWorldBounds() {
         setBounds(-180, 180, -90, 90);
     }
 
     @Override
-    public long encode( GHPoint coord )
-    {
+    public long encode(GHPoint coord) {
         return encode(coord.lat, coord.lon);
     }
 
     /**
      * Take latitude and longitude as input.
      * <p>
+     *
      * @return the linear key
      */
     @Override
-    public final long encode( double lat, double lon )
-    {
+    public final long encode(double lat, double lon) {
         lat = Math.min(Math.max(lat, bounds.minLat), bounds.maxLat);
         lon = Math.min(Math.max(lon, bounds.minLon), bounds.maxLon);
         // introduce a minor correction to round to lower grid entry!
@@ -95,24 +90,22 @@ public final long encode( double lat, double lon )
     /**
      * This method returns latitude and longitude via latLon - calculated from specified linearKey
      * <p>
+     *
      * @param linearKey is the input
      */
     @Override
-    public final void decode( long linearKey, GHPoint latLon )
-    {
+    public final void decode(long linearKey, GHPoint latLon) {
         double lat = linearKey / lonUnits * latDelta + bounds.minLat;
         double lon = linearKey % lonUnits * lonDelta + bounds.minLon;
         latLon.lat = lat + latDelta / 2;
         latLon.lon = lon + lonDelta / 2;
     }
 
-    public double getLatDelta()
-    {
+    public double getLatDelta() {
         return latDelta;
     }
 
-    public double getLonDelta()
-    {
+    public double getLonDelta() {
         return lonDelta;
     }
 
diff --git a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
index 32f213be2a..49b08fef9d 100755
--- a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
@@ -55,6 +55,7 @@
  * But when stored e.g. as int one would need to (left) shift several times if precision is only
  * 3bits.
  * <p>
+ *
  * @author Peter Karich
  */
 // A 2 bit precision spatial key could look like
@@ -70,8 +71,7 @@
 //  |----|----|----|----|
 //            |
 //  lon0 == 0 | lon0 == 1
-public class SpatialKeyAlgo implements KeyAlgo
-{
+public class SpatialKeyAlgo implements KeyAlgo {
     private BBox bbox;
     private int allBits;
     private long initialBits;
@@ -79,13 +79,11 @@
     /**
      * @param allBits how many bits should be used for the spatial key when encoding/decoding
      */
-    public SpatialKeyAlgo( int allBits )
-    {
+    public SpatialKeyAlgo(int allBits) {
         myinit(allBits);
     }
 
-    private void myinit( int allBits )
-    {
+    private void myinit(int allBits) {
         if (allBits > 64)
             throw new IllegalStateException("allBits is too big and does not fit into 8 bytes");
 
@@ -102,13 +100,11 @@ private void myinit( int allBits )
     /**
      * @return the number of involved bits
      */
-    public int getBits()
-    {
+    public int getBits() {
         return allBits;
     }
 
-    public int getExactPrecision()
-    {
+    public int getExactPrecision() {
         // 360 / 2^(allBits/2) = 1/precision
         int p = (int) (Math.pow(2, allBits) / 360);
         // no rounding error
@@ -116,38 +112,34 @@ public int getExactPrecision()
         return (int) Math.log10(p);
     }
 
-    public SpatialKeyAlgo bounds( BBox box )
-    {
+    public SpatialKeyAlgo bounds(BBox box) {
         bbox = box.clone();
         return this;
     }
 
     @Override
-    public SpatialKeyAlgo setBounds( double minLonInit, double maxLonInit, double minLatInit, double maxLatInit )
-    {
+    public SpatialKeyAlgo setBounds(double minLonInit, double maxLonInit, double minLatInit, double maxLatInit) {
         bounds(new BBox(minLonInit, maxLonInit, minLatInit, maxLatInit));
         return this;
     }
 
-    protected void setWorldBounds()
-    {
+    protected void setWorldBounds() {
         setBounds(-180, 180, -90, 90);
     }
 
     @Override
-    public long encode( GHPoint coord )
-    {
+    public long encode(GHPoint coord) {
         return encode(coord.lat, coord.lon);
     }
 
     /**
      * Take latitude and longitude as input.
      * <p>
+     *
      * @return the spatial key
      */
     @Override
-    public final long encode( double lat, double lon )
-    {
+    public final long encode(double lat, double lon) {
         // PERFORMANCE: int operations would be faster than double (for further comparison etc)
         // but we would need 'long' because 'int factorForPrecision' is not enough (problem: coord!=decode(encode(coord)) see testBijection)
         // and 'long'-ops are more expensive than double (at least on 32bit systems)
@@ -157,16 +149,12 @@ public final long encode( double lat, double lon )
         double minLonTmp = bbox.minLon;
         double maxLonTmp = bbox.maxLon;
         int i = 0;
-        while (true)
-        {
-            if (minLatTmp < maxLatTmp)
-            {
+        while (true) {
+            if (minLatTmp < maxLatTmp) {
                 double midLat = (minLatTmp + maxLatTmp) / 2;
-                if (lat < midLat)
-                {
+                if (lat < midLat) {
                     maxLatTmp = midLat;
-                } else
-                {
+                } else {
                     hash |= 1;
                     minLatTmp = midLat;
                 }
@@ -179,14 +167,11 @@ public final long encode( double lat, double lon )
                 // if allBits is an odd number
                 break;
 
-            if (minLonTmp < maxLonTmp)
-            {
+            if (minLonTmp < maxLonTmp) {
                 double midLon = (minLonTmp + maxLonTmp) / 2;
-                if (lon < midLon)
-                {
+                if (lon < midLon) {
                     maxLonTmp = midLon;
-                } else
-                {
+                } else {
                     hash |= 1;
                     minLonTmp = midLon;
                 }
@@ -203,11 +188,11 @@ public final long encode( double lat, double lon )
     /**
      * This method returns latitude and longitude via latLon - calculated from specified spatialKey
      * <p>
+     *
      * @param spatialKey is the input
      */
     @Override
-    public final void decode( long spatialKey, GHPoint latLon )
-    {
+    public final void decode(long spatialKey, GHPoint latLon) {
         // Performance: calculating 'midLon' and 'midLat' on the fly is not slower than using 
         // precalculated values from arrays and for 'bits' a precalculated array is even slightly slower!
 
@@ -217,26 +202,21 @@ public final void decode( long spatialKey, GHPoint latLon )
         double lat = bbox.minLat;
         double lon = bbox.minLon;
         long bits = initialBits;
-        while (true)
-        {
-            if ((spatialKey & bits) != 0)
-            {
+        while (true) {
+            if ((spatialKey & bits) != 0) {
                 lat += midLat;
             }
 
             midLat /= 2;
             bits >>>= 1;
-            if ((spatialKey & bits) != 0)
-            {
+            if ((spatialKey & bits) != 0) {
                 lon += midLon;
             }
 
             midLon /= 2;
-            if (bits > 1)
-            {
+            if (bits > 1) {
                 bits >>>= 1;
-            } else
-            {
+            } else {
                 break;
             }
         }
@@ -249,8 +229,7 @@ public final void decode( long spatialKey, GHPoint latLon )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "bits:" + allBits + ", bounds:" + bbox;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/ConditionalTagInspector.java b/core/src/main/java/com/graphhopper/reader/ConditionalTagInspector.java
index 121379184b..0eb450a05d 100755
--- a/core/src/main/java/com/graphhopper/reader/ConditionalTagInspector.java
+++ b/core/src/main/java/com/graphhopper/reader/ConditionalTagInspector.java
@@ -18,12 +18,10 @@
 package com.graphhopper.reader;
 
 /**
- *
  * @author Peter Karich
  */
-public interface ConditionalTagInspector
-{
-    boolean isRestrictedWayConditionallyPermitted( ReaderWay way );
+public interface ConditionalTagInspector {
+    boolean isRestrictedWayConditionallyPermitted(ReaderWay way);
 
-    boolean isPermittedWayConditionallyRestricted( ReaderWay way );
+    boolean isPermittedWayConditionallyRestricted(ReaderWay way);
 }
diff --git a/core/src/main/java/com/graphhopper/reader/DataReader.java b/core/src/main/java/com/graphhopper/reader/DataReader.java
index 9bcf1e4314..e1e71fea55 100755
--- a/core/src/main/java/com/graphhopper/reader/DataReader.java
+++ b/core/src/main/java/com/graphhopper/reader/DataReader.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.routing.util.EncodingManager;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Date;
@@ -26,17 +27,16 @@
 /**
  * @author Peter Karich
  */
-public interface DataReader
-{
-    DataReader setFile( File file );
+public interface DataReader {
+    DataReader setFile(File file);
 
-    DataReader setElevationProvider( ElevationProvider ep );
+    DataReader setElevationProvider(ElevationProvider ep);
 
-    DataReader setWorkerThreads( int workerThreads );
+    DataReader setWorkerThreads(int workerThreads);
 
-    DataReader setEncodingManager( EncodingManager em );
+    DataReader setEncodingManager(EncodingManager em);
 
-    DataReader setWayPointMaxDistance( double wayPointMaxDistance );
+    DataReader setWayPointMaxDistance(double wayPointMaxDistance);
 
     /**
      * This method triggers reading the underlying data to create a graph
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 4621113af2..4d9558a1d5 100755
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -25,18 +25,17 @@
 /**
  * This class helps to store lat,lon,ele for every node parsed in OSMReader
  * <p>
+ *
  * @author Peter Karich
  */
-public class PillarInfo implements PointAccess
-{
+public class PillarInfo implements PointAccess {
     private static final int LAT = 0 * 4, LON = 1 * 4, ELE = 2 * 4;
     private final boolean enabled3D;
     private final DataAccess da;
     private final int rowSizeInBytes;
     private final Directory dir;
 
-    public PillarInfo( boolean enabled3D, Directory dir )
-    {
+    public PillarInfo(boolean enabled3D, Directory dir) {
         this.enabled3D = enabled3D;
         this.dir = dir;
         this.da = dir.find("tmp_pillar_info").create(100);
@@ -44,38 +43,32 @@ public PillarInfo( boolean enabled3D, Directory dir )
     }
 
     @Override
-    public boolean is3D()
-    {
+    public boolean is3D() {
         return enabled3D;
     }
 
     @Override
-    public int getDimension()
-    {
+    public int getDimension() {
         return enabled3D ? 3 : 2;
     }
 
     @Override
-    public void ensureNode( int nodeId )
-    {
+    public void ensureNode(int nodeId) {
         long tmp = (long) nodeId * rowSizeInBytes;
         da.ensureCapacity(tmp + rowSizeInBytes);
     }
 
     @Override
-    public void setNode( int nodeId, double lat, double lon )
-    {
+    public void setNode(int nodeId, double lat, double lon) {
         _setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int nodeId, double lat, double lon, double ele )
-    {
+    public void setNode(int nodeId, double lat, double lon, double ele) {
         _setNode(nodeId, lat, lon, ele);
     }
 
-    private void _setNode( int nodeId, double lat, double lon, double ele )
-    {
+    private void _setNode(int nodeId, double lat, double lon, double ele) {
         ensureNode(nodeId);
         long tmp = (long) nodeId * rowSizeInBytes;
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
@@ -86,34 +79,29 @@ private void _setNode( int nodeId, double lat, double lon, double ele )
     }
 
     @Override
-    public double getLatitude( int id )
-    {
+    public double getLatitude(int id) {
         int intVal = da.getInt((long) id * rowSizeInBytes + LAT);
         return Helper.intToDegree(intVal);
     }
 
     @Override
-    public double getLat( int id )
-    {
+    public double getLat(int id) {
         return getLatitude(id);
     }
 
     @Override
-    public double getLongitude( int id )
-    {
+    public double getLongitude(int id) {
         int intVal = da.getInt((long) id * rowSizeInBytes + LON);
         return Helper.intToDegree(intVal);
     }
 
     @Override
-    public double getLon( int id )
-    {
+    public double getLon(int id) {
         return getLongitude(id);
     }
 
     @Override
-    public double getElevation( int id )
-    {
+    public double getElevation(int id) {
         if (!is3D())
             return Double.NaN;
 
@@ -122,13 +110,11 @@ public double getElevation( int id )
     }
 
     @Override
-    public double getEle( int id )
-    {
+    public double getEle(int id) {
         return getElevation(id);
     }
 
-    public void clear()
-    {
+    public void clear() {
         dir.remove(da);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderElement.java b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
index 418412e47d..2f7cd6b2e6 100755
--- a/core/src/main/java/com/graphhopper/reader/ReaderElement.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
@@ -26,11 +26,11 @@
 /**
  * Base class for all network objects
  * <p>
+ *
  * @author Nop
  * @author Peter
  */
-public abstract class ReaderElement
-{
+public abstract class ReaderElement {
     public static final int NODE = 0;
     public static final int WAY = 1;
     public static final int RELATION = 2;
@@ -39,25 +39,21 @@
     private final long id;
     private final Map<String, Object> properties = new HashMap<String, Object>(5);
 
-    protected ReaderElement( long id, int type )
-    {
+    protected ReaderElement(long id, int type) {
         this.id = id;
         this.type = type;
     }
 
-    public long getId()
-    {
+    public long getId() {
         return id;
     }
 
-    protected String tagsToString()
-    {
+    protected String tagsToString() {
         if (properties.isEmpty())
             return "<empty>";
 
         StringBuilder tagTxt = new StringBuilder();
-        for (Map.Entry<String, Object> entry : properties.entrySet())
-        {
+        for (Map.Entry<String, Object> entry : properties.entrySet()) {
             tagTxt.append(entry.getKey());
             tagTxt.append("=");
             tagTxt.append(entry.getValue());
@@ -66,50 +62,42 @@ protected String tagsToString()
         return tagTxt.toString();
     }
 
-    protected Map<String, Object> getTags()
-    {
+    protected Map<String, Object> getTags() {
         return properties;
     }
 
-    public void setTags( Map<String, String> newTags )
-    {
+    public void setTags(Map<String, String> newTags) {
         properties.clear();
         if (newTags != null)
-            for (Entry<String, String> e : newTags.entrySet())
-            {
+            for (Entry<String, String> e : newTags.entrySet()) {
                 setTag(e.getKey(), e.getValue());
             }
     }
 
-    public boolean hasTags()
-    {
+    public boolean hasTags() {
         return !properties.isEmpty();
     }
 
-    public String getTag( String name )
-    {
+    public String getTag(String name) {
         return (String) properties.get(name);
     }
 
     @SuppressWarnings("unchecked")
-    public <T> T getTag( String key, T defaultValue )
-    {
+    public <T> T getTag(String key, T defaultValue) {
         T val = (T) properties.get(key);
         if (val == null)
             return defaultValue;
         return val;
     }
 
-    public void setTag( String name, Object value )
-    {
+    public void setTag(String name, Object value) {
         properties.put(name, value);
     }
 
     /**
      * Check that the object has a given tag with a given value.
      */
-    public boolean hasTag( String key, Object value )
-    {
+    public boolean hasTag(String key, Object value) {
         return value.equals(getTag(key, ""));
     }
 
@@ -117,8 +105,7 @@ public boolean hasTag( String key, Object value )
      * Check that a given tag has one of the specified values. If no values are given, just checks
      * for presence of the tag
      */
-    public boolean hasTag( String key, String... values )
-    {
+    public boolean hasTag(String key, String... values) {
         Object value = properties.get(key);
         if (value == null)
             return false;
@@ -127,8 +114,7 @@ public boolean hasTag( String key, String... values )
         if (values.length == 0)
             return true;
 
-        for (String val : values)
-        {
+        for (String val : values) {
             if (val.equals(value))
                 return true;
         }
@@ -138,8 +124,7 @@ public boolean hasTag( String key, String... values )
     /**
      * Check that a given tag has one of the specified values.
      */
-    public final boolean hasTag( String key, Set<String> values )
-    {
+    public final boolean hasTag(String key, Set<String> values) {
         return values.contains(getTag(key, ""));
     }
 
@@ -147,10 +132,8 @@ public final boolean hasTag( String key, Set<String> values )
      * Check a number of tags in the given order for the any of the given values. Used to parse
      * hierarchical access restrictions
      */
-    public boolean hasTag( List<String> keyList, Set<String> values )
-    {
-        for (String key : keyList)
-        {
+    public boolean hasTag(List<String> keyList, Set<String> values) {
+        for (String key : keyList) {
             if (values.contains(getTag(key, "")))
                 return true;
         }
@@ -160,39 +143,32 @@ public boolean hasTag( List<String> keyList, Set<String> values )
     /**
      * Returns the first existing tag of the specified list where the order is important.
      */
-    public String getFirstPriorityTag( List<String> restrictions )
-    {
-        for (String str : restrictions)
-        {
+    public String getFirstPriorityTag(List<String> restrictions) {
+        for (String str : restrictions) {
             if (hasTag(str))
                 return getTag(str);
         }
         return "";
     }
 
-    public void removeTag( String name )
-    {
+    public void removeTag(String name) {
         properties.remove(name);
     }
 
-    public void clearTags()
-    {
+    public void clearTags() {
         properties.clear();
     }
 
-    public int getType()
-    {
+    public int getType() {
         return type;
     }
 
-    public boolean isType( int type )
-    {
+    public boolean isType(int type) {
         return this.type == type;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return properties.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderNode.java b/core/src/main/java/com/graphhopper/reader/ReaderNode.java
index 6660954e71..9f5a27eb51 100755
--- a/core/src/main/java/com/graphhopper/reader/ReaderNode.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderNode.java
@@ -22,15 +22,14 @@
 /**
  * Represents a node received from the reader.
  * <p>
+ *
  * @author Nop
  */
-public class ReaderNode extends ReaderElement
-{
+public class ReaderNode extends ReaderElement {
     private final double lat;
     private final double lon;
 
-    public ReaderNode( long id, PointAccess pointAccess, int accessId )
-    {
+    public ReaderNode(long id, PointAccess pointAccess, int accessId) {
         super(id, NODE);
 
         this.lat = pointAccess.getLatitude(accessId);
@@ -39,26 +38,22 @@ public ReaderNode( long id, PointAccess pointAccess, int accessId )
             setTag("ele", pointAccess.getElevation(accessId));
     }
 
-    public ReaderNode( long id, double lat, double lon )
-    {
+    public ReaderNode(long id, double lat, double lon) {
         super(id, NODE);
 
         this.lat = lat;
         this.lon = lon;
     }
 
-    public double getLat()
-    {
+    public double getLat() {
         return lat;
     }
 
-    public double getLon()
-    {
+    public double getLon() {
         return lon;
     }
 
-    public double getEle()
-    {
+    public double getEle() {
         Object ele = getTags().get("ele");
         if (ele == null)
             return Double.NaN;
@@ -66,24 +61,19 @@ public double getEle()
     }
 
     @Override
-    public void setTag( String name, Object value )
-    {
-        if ("ele".equals(name))
-        {
+    public void setTag(String name, Object value) {
+        if ("ele".equals(name)) {
             if (value == null)
                 value = null;
-            else if (value instanceof String)
-            {
+            else if (value instanceof String) {
                 String str = (String) value;
                 str = str.trim().replaceAll("\\,", ".");
                 if (str.isEmpty())
                     value = null;
                 else
-                    try
-                    {
+                    try {
                         value = Double.parseDouble(str);
-                    } catch (NumberFormatException ex)
-                    {
+                    } catch (NumberFormatException ex) {
                         return;
                     }
             } else
@@ -94,8 +84,7 @@ else if (value instanceof String)
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder txt = new StringBuilder();
         txt.append("Node: ");
         txt.append(getId());
@@ -103,8 +92,7 @@ public String toString()
         txt.append(getLat());
         txt.append(" lon=");
         txt.append(getLon());
-        if (!getTags().isEmpty())
-        {
+        if (!getTags().isEmpty()) {
             txt.append("\n");
             txt.append(tagsToString());
         }
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderRelation.java b/core/src/main/java/com/graphhopper/reader/ReaderRelation.java
index c9c1bab912..32f1a7e959 100755
--- a/core/src/main/java/com/graphhopper/reader/ReaderRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderRelation.java
@@ -23,47 +23,39 @@
 /**
  * Represents a relation received from the reader.
  * <p>
+ *
  * @author Nop
  */
-public class ReaderRelation extends ReaderElement
-{
+public class ReaderRelation extends ReaderElement {
     protected final List<Member> members = new ArrayList<Member>(5);
 
-    public ReaderRelation( long id )
-    {
+    public ReaderRelation(long id) {
         super(id, RELATION);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "Relation (" + getId() + ", " + members.size() + " members)";
     }
 
-    public List<Member> getMembers()
-    {
+    public List<Member> getMembers() {
         return members;
     }
 
-    public boolean isMetaRelation()
-    {
-        for (Member member : members)
-        {
-            if (member.getType() == RELATION)
-            {
+    public boolean isMetaRelation() {
+        for (Member member : members) {
+            if (member.getType() == RELATION) {
                 return true;
             }
         }
         return false;
     }
 
-    public boolean isMixedRelation()
-    {
+    public boolean isMixedRelation() {
         boolean hasRel = false;
         boolean hasOther = false;
 
-        for (Member member : members)
-        {
+        for (Member member : members) {
             if (member.getType() == RELATION)
                 hasRel = true;
             else
@@ -75,25 +67,21 @@ public boolean isMixedRelation()
         return false;
     }
 
-    public void removeRelations()
-    {
-        for (int i = members.size() - 1; i >= 0; i--)
-        {
+    public void removeRelations() {
+        for (int i = members.size() - 1; i >= 0; i--) {
             if (members.get(i).getType() == RELATION)
                 members.remove(i);
         }
     }
 
-    public void add( Member member )
-    {
+    public void add(Member member) {
         members.add(member);
     }
 
     /**
      * Container class for relation members
      */
-    public static class Member
-    {
+    public static class Member {
         public static final int NODE = 0;
         public static final int WAY = 1;
         public static final int RELATION = 2;
@@ -101,41 +89,35 @@ public void add( Member member )
         private final long ref;
         private final String role;
 
-        public Member( Member input )
-        {
+        public Member(Member input) {
             type = input.type;
             ref = input.ref;
             role = input.role;
         }
 
-        public Member( int type, long ref, String role )
-        {
+        public Member(int type, long ref, String role) {
             this.type = type;
             this.ref = ref;
             this.role = role;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return "Member " + type + ":" + ref;
         }
 
-        public int getType()
-        {
+        public int getType() {
             return type;
         }
 
         /**
          * member reference which is an OSM ID
          */
-        public long getRef()
-        {
+        public long getRef() {
             return ref;
         }
 
-        public String getRole()
-        {
+        public String getRole() {
             return role;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderWay.java b/core/src/main/java/com/graphhopper/reader/ReaderWay.java
index d7a7025910..4a40fe3126 100755
--- a/core/src/main/java/com/graphhopper/reader/ReaderWay.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderWay.java
@@ -23,25 +23,22 @@
 /**
  * Represents a way received from the reader.
  * <p>
+ *
  * @author Nop
  */
-public class ReaderWay extends ReaderElement
-{
+public class ReaderWay extends ReaderElement {
     protected final TLongList nodes = new TLongArrayList(5);
 
-    public ReaderWay( long id )
-    {
+    public ReaderWay(long id) {
         super(id, WAY);
     }
 
-    public TLongList getNodes()
-    {
+    public TLongList getNodes() {
         return nodes;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "Way id:" + getId() + ", nodes:" + nodes.size() + ", tags:" + super.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java
new file mode 100644
index 0000000000..1063ef3cef
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java
@@ -0,0 +1,159 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+
+import gnu.trove.set.TIntSet;
+import gnu.trove.set.hash.TIntHashSet;
+
+/**
+ * Abstract base class for tunnel/bridge edge elevation interpolators. This
+ * class estimates elevation of inner nodes of a tunnel/bridge based on
+ * elevations of entry nodes. See #713 for more information.
+ * 
+ * <p>
+ * Since inner nodes of tunnel or bridge do not lie on the Earth surface, we
+ * should not use elevations returned by the elevation provider for these
+ * points. Instead, we'll estimate elevations of these points based on
+ * elevations of entry/exit nodes of the tunnel/bridge.
+ * <p>
+ * To do this, we'll iterate over the graph looking for tunnel or bridge edges
+ * using {@link #isInterpolatableEdge(EdgeIteratorState)}. Once such an edge is
+ * found, we'll calculate a connected component of tunnel/bridge edges starting
+ * from the base node of this edge, using simple {@link BreadthFirstSearch}.
+ * Nodes which only have interpolatabe edges connected to them are inner nodes
+ * and are considered to not lie on the Earth surface. Nodes which also have
+ * non-interpolatable edges are outer nodes and are considered to lie on the
+ * Earth surface. Elevations of inner nodes are then interpolated from the outer
+ * nodes using {@link NodeElevationInterpolator}. Elevations of pillar nodes are
+ * calculated using linear interpolation on distances from tower nodes.
+ *
+ * @author Alexey Valikov
+ */
+public abstract class AbstractEdgeElevationInterpolator {
+
+    private final GraphHopperStorage storage;
+    protected final DataFlagEncoder dataFlagEncoder;
+    private final NodeElevationInterpolator nodeElevationInterpolator;
+    private final ElevationInterpolator elevationInterpolator = new ElevationInterpolator();
+
+    public AbstractEdgeElevationInterpolator(GraphHopperStorage storage,
+                    DataFlagEncoder dataFlagEncoder) {
+        this.storage = storage;
+        this.dataFlagEncoder = dataFlagEncoder;
+        this.nodeElevationInterpolator = new NodeElevationInterpolator(storage);
+    }
+
+    protected abstract boolean isInterpolatableEdge(EdgeIteratorState edge);
+
+    public GraphHopperStorage getStorage() {
+        return storage;
+    }
+
+    public void execute() {
+        interpolateElevationsOfTowerNodes();
+        interpolateElevationsOfPillarNodes();
+    }
+
+    private void interpolateElevationsOfTowerNodes() {
+        final AllEdgesIterator edge = storage.getAllEdges();
+        final GHBitSet visitedEdgeIds = new GHBitSetImpl(edge.getMaxId());
+        final EdgeExplorer edgeExplorer = storage.createEdgeExplorer();
+
+        while (edge.next()) {
+            final int edgeId = edge.getEdge();
+            if (isInterpolatableEdge(edge)) {
+                if (!visitedEdgeIds.contains(edgeId)) {
+                    interpolateEdge(edge, visitedEdgeIds, edgeExplorer, edgeId);
+                }
+            }
+            visitedEdgeIds.add(edgeId);
+        }
+    }
+
+    private void interpolateEdge(final EdgeIteratorState interpolatableEdge,
+                    final GHBitSet visitedEdgeIds, final EdgeExplorer edgeExplorer, int edgeId) {
+        final TIntSet outerNodeIds = new TIntHashSet();
+        final TIntSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIds(edgeExplorer, interpolatableEdge, visitedEdgeIds, outerNodeIds,
+                        innerNodeIds);
+        nodeElevationInterpolator.interpolateElevationsOfInnerNodes(outerNodeIds.toArray(),
+                        innerNodeIds.toArray());
+    }
+
+    public void gatherOuterAndInnerNodeIds(final EdgeExplorer edgeExplorer,
+                    final EdgeIteratorState interpolatableEdge, final GHBitSet visitedEdgesIds,
+                    final TIntSet outerNodeIds, final TIntSet innerNodeIds) {
+        final BreadthFirstSearch gatherOuterAndInnerNodeIdsSearch = new BreadthFirstSearch() {
+            protected boolean checkAdjacent(EdgeIteratorState edge) {
+                visitedEdgesIds.add(edge.getEdge());
+                final int baseNodeId = edge.getBaseNode();
+                boolean isInterpolatableEdge = isInterpolatableEdge(edge);
+                if (!isInterpolatableEdge) {
+                    innerNodeIds.remove(baseNodeId);
+                    outerNodeIds.add(baseNodeId);
+                } else if (!outerNodeIds.contains(baseNodeId)) {
+                    innerNodeIds.add(baseNodeId);
+                }
+                return isInterpolatableEdge;
+            }
+        };
+        gatherOuterAndInnerNodeIdsSearch.start(edgeExplorer, interpolatableEdge.getBaseNode());
+    }
+
+    private void interpolateElevationsOfPillarNodes() {
+        final EdgeIterator edge = storage.getAllEdges();
+        final NodeAccess nodeAccess = storage.getNodeAccess();
+        while (edge.next()) {
+            if (isInterpolatableEdge(edge)) {
+                int firstNodeId = edge.getBaseNode();
+                int secondNodeId = edge.getAdjNode();
+
+                double lat0 = nodeAccess.getLat(firstNodeId);
+                double lon0 = nodeAccess.getLon(firstNodeId);
+                double ele0 = nodeAccess.getEle(firstNodeId);
+
+                double lat1 = nodeAccess.getLat(secondNodeId);
+                double lon1 = nodeAccess.getLon(secondNodeId);
+                double ele1 = nodeAccess.getEle(secondNodeId);
+
+                final PointList pointList = edge.fetchWayGeometry(0);
+                final int count = pointList.size();
+                for (int index = 0; index < count; index++) {
+                    double lat = pointList.getLat(index);
+                    double lon = pointList.getLon(index);
+                    double ele = elevationInterpolator.calculateElevationBasedOnTwoPoints(lat, lon,
+                                    lat0, lon0, ele0, lat1, lon1, ele1);
+                    pointList.set(index, lat, lon, ele);
+                }
+                edge.setWayGeometry(pointList);
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java
new file mode 100644
index 0000000000..33885583a5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java
@@ -0,0 +1,41 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Elevation interpolator for bridges. Estimates elevations of inner nodes of
+ * the bridge based on elevations of entry/exit nodes of the bridge.
+ *
+ * @author Alexey Valikov
+ */
+public class BridgeElevationInterpolator extends AbstractEdgeElevationInterpolator {
+
+    public BridgeElevationInterpolator(GraphHopperStorage storage,
+                    DataFlagEncoder dataFlagEncoder) {
+        super(storage, dataFlagEncoder);
+    }
+
+    @Override
+    protected boolean isInterpolatableEdge(EdgeIteratorState edge) {
+        return dataFlagEncoder.isTransportModeBridge(edge);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index fc602d29b2..973a54bf03 100755
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -23,21 +23,23 @@
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
+import org.apache.xmlgraphics.image.codec.util.SeekableStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.awt.image.Raster;
-import java.io.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.SocketTimeoutException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
-import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
-import org.apache.xmlgraphics.image.codec.util.SeekableStream;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
  * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
@@ -50,35 +52,62 @@
  * </li>
  * </ol>
  * <p>
+ *
  * @author NopMap
  * @author Peter Karich
  */
-public class CGIARProvider implements ElevationProvider
-{
+public class CGIARProvider implements ElevationProvider {
     private static final int WIDTH = 6000;
-    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
+    final double precision = 1e7;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
+    private final double invPrecision = 1 / precision;
+    private final int degree = 5;
+    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
     private File cacheDir = new File("/tmp/cgiar");
     // for alternatives see #346
     private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
     private Directory dir;
     private DAType daType = DAType.MMAP;
-    final double precision = 1e7;
-    private final double invPrecision = 1 / precision;
-    private final int degree = 5;
     private boolean calcMean = false;
     private boolean autoRemoveTemporary = true;
     private long sleep = 2000;
 
+    public static void main(String[] args) {
+        CGIARProvider provider = new CGIARProvider();
+
+        System.out.println(provider.getEle(46, -20));
+
+        // 337.0
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 453.0
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 447.0
+        System.out.println(provider.getEle(49.968682, 11.574842));
+
+        // 3131
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+
+        // 123
+        System.out.println(provider.getEle(38.065392, -87.099609));
+
+        // 1615
+        System.out.println(provider.getEle(40, -105.2277023));
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        // 1617
+        System.out.println(provider.getEle(39.999999, -105.2277023));
+
+        // 0
+        System.out.println(provider.getEle(29.840644, -42.890625));
+    }
+
     @Override
-    public void setCalcMean( boolean eleCalcMean )
-    {
+    public void setCalcMean(boolean eleCalcMean) {
         calcMean = eleCalcMean;
     }
 
-    void setSleep( long sleep )
-    {
+    void setSleep(long sleep) {
         this.sleep = sleep;
     }
 
@@ -87,39 +116,32 @@ void setSleep( long sleep )
      * our DataAccess object, so this option can be used to disable the default clear mechanism via
      * specifying 'false'.
      */
-    public void setAutoRemoveTemporaryFiles( boolean autoRemoveTemporary )
-    {
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
         this.autoRemoveTemporary = autoRemoveTemporary;
     }
 
-    public void setDownloader( Downloader downloader )
-    {
+    public void setDownloader(Downloader downloader) {
         this.downloader = downloader;
     }
 
     @Override
-    public ElevationProvider setCacheDir( File cacheDir )
-    {
+    public ElevationProvider setCacheDir(File cacheDir) {
         if (cacheDir.exists() && !cacheDir.isDirectory())
             throw new IllegalArgumentException("Cache path has to be a directory");
-        try
-        {
+        try {
             this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException(ex);
         }
         return this;
     }
 
-    protected File getCacheDir()
-    {
+    protected File getCacheDir() {
         return cacheDir;
     }
 
     @Override
-    public ElevationProvider setBaseURL( String baseUrl )
-    {
+    public ElevationProvider setBaseURL(String baseUrl) {
         if (baseUrl == null || baseUrl.isEmpty())
             throw new IllegalArgumentException("baseUrl cannot be empty");
 
@@ -128,15 +150,13 @@ public ElevationProvider setBaseURL( String baseUrl )
     }
 
     @Override
-    public ElevationProvider setDAType( DAType daType )
-    {
+    public ElevationProvider setDAType(DAType daType) {
         this.daType = daType;
         return this;
     }
 
     @Override
-    public double getEle( double lat, double lon )
-    {
+    public double getEle(double lat, double lon) {
         // no data we can avoid the trouble
         if (lat > 60 || lat < -60)
             return 0;
@@ -145,8 +165,7 @@ public double getEle( double lat, double lon )
         lon = (int) (lon * precision) / precision;
         String name = getFileName(lat, lon);
         HeightTile demProvider = cacheData.get(name);
-        if (demProvider == null)
-        {
+        if (demProvider == null) {
             if (!cacheDir.exists())
                 cacheDir.mkdirs();
 
@@ -160,41 +179,32 @@ public double getEle( double lat, double lon )
             DataAccess heights = getDirectory().find(name + ".gh");
             demProvider.setHeights(heights);
             boolean loadExisting = false;
-            try
-            {
+            try {
                 loadExisting = heights.loadExisting();
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 logger.warn("cannot load " + name + ", error: " + ex.getMessage());
             }
 
-            if (!loadExisting)
-            {
+            if (!loadExisting) {
                 String tifName = name + ".tif";
                 String zippedURL = baseUrl + "/" + name + ".zip";
                 File file = new File(cacheDir, new File(zippedURL).getName());
 
                 // get zip file if not already in cacheDir - unzip later and in-memory only!
-                if (!file.exists())
-                {
-                    try
-                    {
+                if (!file.exists()) {
+                    try {
                         int max = 3;
-                        for (int trial = 0; trial < max; trial++)
-                        {
-                            try
-                            {
+                        for (int trial = 0; trial < max; trial++) {
+                            try {
                                 downloader.downloadFile(zippedURL, file.getAbsolutePath());
                                 break;
-                            } catch (SocketTimeoutException ex)
-                            {
+                            } catch (SocketTimeoutException ex) {
                                 // just try again after a little nap
                                 Thread.sleep(sleep);
                                 if (trial >= max - 1)
                                     throw ex;
                                 continue;
-                            } catch (IOException ex)
-                            {
+                            } catch (IOException ex) {
                                 demProvider.setSeaLevel(true);
                                 // use small size on disc and in-memory
                                 heights.setSegmentSize(100).create(10).
@@ -202,8 +212,7 @@ public double getEle( double lat, double lon )
                                 return 0;
                             }
                         }
-                    } catch (Exception ex)
-                    {
+                    } catch (Exception ex) {
                         throw new RuntimeException(ex);
                     }
                 }
@@ -215,39 +224,32 @@ public double getEle( double lat, double lon )
                 // decode tiff data
                 Raster raster;
                 SeekableStream ss = null;
-                try
-                {
+                try {
                     InputStream is = new FileInputStream(file);
                     ZipInputStream zis = new ZipInputStream(is);
                     // find tif file in zip
                     ZipEntry entry = zis.getNextEntry();
-                    while (entry != null && !entry.getName().equals(tifName))
-                    {
+                    while (entry != null && !entry.getName().equals(tifName)) {
                         entry = zis.getNextEntry();
                     }
 
                     ss = SeekableStream.wrapInputStream(zis, true);
                     TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
                     raster = imageDecoder.decodeAsRaster();
-                } catch (Exception e)
-                {
+                } catch (Exception e) {
                     throw new RuntimeException("Can't decode " + tifName, e);
-                } finally
-                {
+                } finally {
                     if (ss != null)
                         Helper.close(ss);
                 }
 
-                // logger.info("start converting to our format");           
+                // logger.info("start converting to our format");
                 final int height = raster.getHeight();
                 final int width = raster.getWidth();
                 int x = 0, y = 0;
-                try
-                {
-                    for (y = 0; y < height; y++)
-                    {
-                        for (x = 0; x < width; x++)
-                        {
+                try {
+                    for (y = 0; y < height; y++) {
+                        for (x = 0; x < width; x++) {
                             short val = (short) raster.getPixel(x, y, (int[]) null)[0];
                             if (val < -1000 || val > 12000)
                                 val = Short.MIN_VALUE;
@@ -258,8 +260,7 @@ public double getEle( double lat, double lon )
                     heights.flush();
 
                     // TODO remove tifName and zip?
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
                 }
             } // loadExisting
@@ -271,8 +272,7 @@ public double getEle( double lat, double lon )
         return demProvider.getHeight(lat, lon);
     }
 
-    int down( double val )
-    {
+    int down(double val) {
         // 'rounding' to closest 5
         int intVal = (int) (val / degree) * degree;
         if (!(val >= 0 || intVal - val < invPrecision))
@@ -281,8 +281,7 @@ int down( double val )
         return intVal;
     }
 
-    protected String getFileName( double lat, double lon )
-    {
+    protected String getFileName(double lat, double lon) {
         lon = 1 + (180 + lon) / degree;
         int lonInt = (int) lon;
         lat = 1 + (60 - lat) / degree;
@@ -303,8 +302,7 @@ protected String getFileName( double lat, double lon )
     }
 
     @Override
-    public void release()
-    {
+    public void release() {
         cacheData.clear();
 
         // for memory mapped type we create temporary unpacked files which should be removed
@@ -313,47 +311,15 @@ public void release()
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "CGIAR";
     }
 
-    private Directory getDirectory()
-    {
+    private Directory getDirectory() {
         if (dir != null)
             return dir;
 
         logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
         return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
     }
-
-    public static void main( String[] args )
-    {
-        CGIARProvider provider = new CGIARProvider();
-
-        System.out.println(provider.getEle(46, -20));
-
-        // 337.0
-        System.out.println(provider.getEle(49.949784, 11.57517));
-        // 453.0
-        System.out.println(provider.getEle(49.968668, 11.575127));
-        // 447.0
-        System.out.println(provider.getEle(49.968682, 11.574842));
-
-        // 3131
-        System.out.println(provider.getEle(-22.532854, -65.110474));
-
-        // 123               
-        System.out.println(provider.getEle(38.065392, -87.099609));
-
-        // 1615
-        System.out.println(provider.getEle(40, -105.2277023));
-        System.out.println(provider.getEle(39.99999999, -105.2277023));
-        System.out.println(provider.getEle(39.9999999, -105.2277023));
-        // 1617
-        System.out.println(provider.getEle(39.999999, -105.2277023));
-
-        // 0
-        System.out.println(provider.getEle(29.840644, -42.890625));
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java
new file mode 100644
index 0000000000..a92c71e652
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java
@@ -0,0 +1,152 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.PointList;
+import static com.graphhopper.util.Helper.round2;
+
+/**
+ * Elevation interpolator calculates elevation for the given lat/lon coordinates
+ * based on lat/lon/ele coordinates of the given points.
+ * 
+ * <p>
+ * In case of two points, elevation is calculated using linear interpolation
+ * (see
+ * {@link #calculateElevationBasedOnTwoPoints(double, double, double, double, double, double, double, double)}).
+ * <p>
+ * In case of three points, elevation is calculated using planar interpolation
+ * (see
+ * {@link #calculateElevationBasedOnThreePoints(double, double, double, double, double, double, double, double, double, double, double)}).
+ * <p>
+ * In case of more than three points, elevation is calculated using the
+ * interpolation method described in the
+ * <a href="http://math.stackexchange.com/a/1930758/140512">following post</a>
+ * (see {@link #calculateElevationBasedOnPointList(double, double, PointList)}.
+ *
+ * @author Alexey Valikov
+ */
+
+public class ElevationInterpolator {
+
+    public static final double EPSILON = 0.00001;
+    public static final double EPSILON2 = EPSILON * EPSILON;
+
+    public double calculateElevationBasedOnTwoPoints(double lat, double lon, double lat0,
+                    double lon0, double ele0, double lat1, double lon1, double ele1) {
+        double dlat0 = lat0 - lat;
+        double dlon0 = lon0 - lon;
+        double dlat1 = lat1 - lat;
+        double dlon1 = lon1 - lon;
+        double l0 = Math.sqrt(dlon0 * dlon0 + dlat0 * dlat0);
+        double l1 = Math.sqrt(dlon1 * dlon1 + dlat1 * dlat1);
+        double l = l0 + l1;
+        if (l < EPSILON) {
+            // If points are too close to each other, return elevation of the
+            // point which is closer;
+            return l0 <= l1 ? ele0 : ele1;
+        } else {
+            // Otherwise do linear interpolation
+            return round2(ele0 + (ele1 - ele0) * l0 / l);
+        }
+    }
+
+    public double calculateElevationBasedOnThreePoints(double lat, double lon, double lat0,
+                    double lon0, double ele0, double lat1, double lon1, double ele1, double lat2,
+                    double lon2, double ele2) {
+
+        double dlat10 = lat1 - lat0;
+        double dlon10 = lon1 - lon0;
+        double dele10 = ele1 - ele0;
+        double dlat20 = lat2 - lat0;
+        double dlon20 = lon2 - lon0;
+        double dele20 = ele2 - ele0;
+
+        double a = dlon10 * dele20 - dele10 * dlon20;
+        double b = dele10 * dlat20 - dlat10 * dele20;
+        double c = dlat10 * dlon20 - dlon10 * dlat20;
+
+        if (Math.abs(c) < EPSILON) {
+            double dlat21 = lat2 - lat1;
+            double dlon21 = lon2 - lon1;
+            double dele21 = ele2 - ele1;
+
+            double l10 = dlat10 * dlat10 + dlon10 * dlon10 + dele10 * dele10;
+            double l20 = dlat20 * dlat20 + dlon20 * dlon20 + dele20 * dele20;
+            double l21 = dlat21 * dlat21 + dlon21 * dlon21 + dele21 * dele21;
+
+            if (l21 > l10 && l21 > l20) {
+                return calculateElevationBasedOnTwoPoints(lat, lon, lat1, lon1, ele1, lat2, lon2,
+                                ele2);
+            } else if (l20 > l10 && l20 > l21) {
+                return calculateElevationBasedOnTwoPoints(lat, lon, lat0, lon0, ele0, lat2, lon2,
+                                ele2);
+            } else {
+                return calculateElevationBasedOnTwoPoints(lat, lon, lat0, lon0, ele0, lat1, lon1,
+                                ele1);
+            }
+
+        } else {
+            double d = a * lat0 + b * lon0 + c * ele0;
+            double ele = (d - a * lat - b * lon) / c;
+            return round2(ele);
+        }
+    }
+
+    public double calculateElevationBasedOnPointList(double lat, double lon, PointList pointList) {
+        // See http://math.stackexchange.com/a/1930758/140512 for the
+        // explanation
+        final int size = pointList.size();
+        if (size == 0) {
+            throw new IllegalArgumentException("At least one point is required in the pointList.");
+        } else if (size == 1) {
+            return pointList.getEle(0);
+        } else if (size == 2) {
+            return calculateElevationBasedOnTwoPoints(lat, lon, pointList.getLat(0),
+                            pointList.getLon(0), pointList.getEle(0), pointList.getLat(1),
+                            pointList.getLon(1), pointList.getEle(1));
+        } else if (size == 3) {
+            return calculateElevationBasedOnThreePoints(lat, lon, pointList.getLat(0),
+                            pointList.getLon(0), pointList.getEle(0), pointList.getLat(1),
+                            pointList.getLon(1), pointList.getEle(1), pointList.getLat(2),
+                            pointList.getLon(2), pointList.getEle(2));
+        } else {
+            double[] vs = new double[size];
+            double[] eles = new double[size];
+            double v = 0;
+            for (int index = 0; index < size; index++) {
+                double lati = pointList.getLat(index);
+                double loni = pointList.getLon(index);
+                double dlati = lati - lat;
+                double dloni = loni - lon;
+                double l2 = (dlati * dlati + dloni * dloni);
+                eles[index] = pointList.getEle(index);
+                if (l2 < EPSILON2) {
+                    return eles[index];
+                }
+                vs[index] = 1 / l2;
+                v += vs[index];
+            }
+
+            double ele = 0;
+            for (int index = 0; index < size; index++) {
+                ele += eles[index] * vs[index] / v;
+            }
+            return round2(ele);
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index 66f29103b4..5afa5794fa 100755
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -24,75 +24,67 @@
 /**
  * @author Peter Karich
  */
-public interface ElevationProvider
-{
+public interface ElevationProvider {
+    ElevationProvider NOOP = new ElevationProvider() {
+        @Override
+        public double getEle(double lat, double lon) {
+            return Double.NaN;
+        }
+
+        @Override
+        public ElevationProvider setCacheDir(File cacheDir) {
+            return this;
+        }
+
+        @Override
+        public ElevationProvider setBaseURL(String baseURL) {
+            return this;
+        }
+
+        @Override
+        public ElevationProvider setDAType(DAType daType) {
+            return this;
+        }
+
+        @Override
+        public void release() {
+        }
+
+        @Override
+        public void setCalcMean(boolean eleCalcMean) {
+        }
+    };
+
     /**
      * @return returns the hight in meter or Double.NaN if invalid
      */
-    double getEle( double lat, double lon );
+    double getEle(double lat, double lon);
 
     /**
      * Specifies the service URL where to download the elevation data. An empty string should set it
      * to the default URL. Default is a provider-dependent URL which should work out of the box.
      */
-    ElevationProvider setBaseURL( String baseURL );
+    ElevationProvider setBaseURL(String baseURL);
 
     /**
      * Specifies the directory where to temporarily store the elevation data after fetched from base
      * URL. Default is a custom provider-dependent subdirectory in '/tmp'
      */
-    ElevationProvider setCacheDir( File cacheDir );
+    ElevationProvider setCacheDir(File cacheDir);
 
     /**
      * Set to true if you have a small area and need high speed access. Default is DAType.MMAP
      */
-    ElevationProvider setDAType( DAType daType );
+    ElevationProvider setDAType(DAType daType);
 
     /**
      * Configuration option to include surrounding elevation points when fetching the elevation. Has
      * only an effect if called before the first getEle call. Turned off by default.
      */
-    void setCalcMean( boolean calcMean );
+    void setCalcMean(boolean calcMean);
 
     /**
      * Release resources.
      */
     void release();
-
-    ElevationProvider NOOP = new ElevationProvider()
-    {
-        @Override
-        public double getEle( double lat, double lon )
-        {
-            return Double.NaN;
-        }
-
-        @Override
-        public ElevationProvider setCacheDir( File cacheDir )
-        {
-            return this;
-        }
-
-        @Override
-        public ElevationProvider setBaseURL( String baseURL )
-        {
-            return this;
-        }
-
-        @Override
-        public ElevationProvider setDAType( DAType daType )
-        {
-            return this;
-        }
-
-        @Override
-        public void release()
-        {
-        }
-
-        @Override
-        public void setCalcMean( boolean eleCalcMean )
-        {
-        }
-    };
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index e665441697..7fb681172e 100755
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -19,32 +19,30 @@
 
 import com.graphhopper.storage.DataAccess;
 
-import java.awt.Color;
-import java.awt.Graphics;
+import javax.imageio.ImageIO;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
-import javax.imageio.ImageIO;
 
 /**
  * One rectangle of height data from Shuttle Radar Topography Mission.
  * <p>
+ *
  * @author Peter Karich
  */
-public class HeightTile
-{
-    private DataAccess heights;
+public class HeightTile {
     private final int minLat;
     private final int minLon;
     private final int width;
     private final int degree;
     private final double lowerBound;
     private final double higherBound;
+    private DataAccess heights;
     private boolean calcMean;
 
-    public HeightTile( int minLat, int minLon, int width, double precision, int degree )
-    {
+    public HeightTile(int minLat, int minLon, int width, double precision, int degree) {
         this.minLat = minLat;
         this.minLon = minLon;
         this.width = width;
@@ -55,30 +53,25 @@ public HeightTile( int minLat, int minLon, int width, double precision, int degr
         this.degree = degree;
     }
 
-    public HeightTile setCalcMean( boolean b )
-    {
+    public HeightTile setCalcMean(boolean b) {
         this.calcMean = b;
         return this;
     }
 
-    public HeightTile setSeaLevel( boolean b )
-    {
-        heights.setHeader(0, b ? 1 : 0);
-        return this;
+    public boolean isSeaLevel() {
+        return heights.getHeader(0) == 1;
     }
 
-    public boolean isSeaLevel()
-    {
-        return heights.getHeader(0) == 1;
+    public HeightTile setSeaLevel(boolean b) {
+        heights.setHeader(0, b ? 1 : 0);
+        return this;
     }
 
-    void setHeights( DataAccess da )
-    {
+    void setHeights(DataAccess da) {
         this.heights = da;
     }
 
-    public double getHeight( double lat, double lon )
-    {
+    public double getHeight(double lat, double lon) {
         double deltaLat = Math.abs(lat - minLat);
         double deltaLon = Math.abs(lon - minLon);
         if (deltaLat > higherBound || deltaLat < lowerBound)
@@ -103,8 +96,7 @@ public double getHeight( double lat, double lon )
         if (value == Short.MIN_VALUE)
             return Double.NaN;
 
-        if (calcMean)
-        {
+        if (calcMean) {
             if (lonSimilar > 0)
                 value += includePoint(daPointer - 2, counter);
 
@@ -121,8 +113,7 @@ public double getHeight( double lat, double lon )
         return (double) value / counter.get();
     }
 
-    private double includePoint( int pointer, AtomicInteger counter )
-    {
+    private double includePoint(int pointer, AtomicInteger counter) {
         short value = heights.getShort(pointer);
         if (value == Short.MIN_VALUE)
             return 0;
@@ -131,31 +122,25 @@ private double includePoint( int pointer, AtomicInteger counter )
         return value;
     }
 
-    public void toImage( String imageFile ) throws IOException
-    {
+    public void toImage(String imageFile) throws IOException {
         ImageIO.write(makeARGB(), "PNG", new File(imageFile));
     }
 
-    protected BufferedImage makeARGB()
-    {
+    protected BufferedImage makeARGB() {
         int height = width;
         BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
         Graphics g = argbImage.getGraphics();
         long len = width * width;
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             int lonSimilar = i % width;
             // no need for width - y as coordinate system for Graphics is already this way
             int latSimilar = i / width;
             int green = Math.abs(heights.getShort(i * 2));
-            if (green == 0)
-            {
+            if (green == 0) {
                 g.setColor(new Color(255, 0, 0, 255));
-            } else
-            {
+            } else {
                 int red = 0;
-                while (green > 255)
-                {
+                while (green > 255) {
                     green = green / 10;
                     red += 50;
                 }
@@ -169,8 +154,7 @@ protected BufferedImage makeARGB()
         return argbImage;
     }
 
-    public BufferedImage getImageFromArray( int[] pixels, int width )
-    {
+    public BufferedImage getImageFromArray(int[] pixels, int width) {
         int height = width;
         BufferedImage tmpImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
         tmpImage.setRGB(0, 0, width, height, pixels, 0, width);
@@ -178,8 +162,7 @@ public BufferedImage getImageFromArray( int[] pixels, int width )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return minLat + "," + minLon;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java
new file mode 100644
index 0000000000..a255137f03
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java
@@ -0,0 +1,126 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.PointList;
+
+/**
+ * Interpolates elevations of inner nodes based on elevations of outer nodes.
+ * 
+ * @author Alexey Valikov
+ */
+public class NodeElevationInterpolator {
+
+    private final GraphHopperStorage storage;
+    private final ElevationInterpolator elevationInterpolator = new ElevationInterpolator();
+
+    public NodeElevationInterpolator(GraphHopperStorage storage) {
+        this.storage = storage;
+    }
+
+    public void interpolateElevationsOfInnerNodes(int[] outerNodeIds, int[] innerNodeIds) {
+        final int numberOfOuterNodes = outerNodeIds.length;
+        if (numberOfOuterNodes == 0) {
+            // do nothing
+        } else if (numberOfOuterNodes == 1) {
+            interpolateElevationsOfInnerNodesForOneOuterNode(outerNodeIds[0], innerNodeIds);
+        } else if (numberOfOuterNodes == 2) {
+            interpolateElevationsOfInnerNodesForTwoOuterNodes(outerNodeIds[0], outerNodeIds[1],
+                            innerNodeIds);
+        } else if (numberOfOuterNodes == 3) {
+            interpolateElevationsOfInnerNodesForThreeOuterNodes(outerNodeIds[0], outerNodeIds[1],
+                            outerNodeIds[2], innerNodeIds);
+        } else if (numberOfOuterNodes > 3) {
+            interpolateElevationsOfInnerNodesForNOuterNodes(outerNodeIds, innerNodeIds);
+        }
+    }
+
+    private void interpolateElevationsOfInnerNodesForOneOuterNode(int outerNodeId,
+                    int[] innerNodeIds) {
+        NodeAccess nodeAccess = storage.getNodeAccess();
+        double ele = nodeAccess.getEle(outerNodeId);
+        for (int innerNodeId : innerNodeIds) {
+            double lat = nodeAccess.getLat(innerNodeId);
+            double lon = nodeAccess.getLon(innerNodeId);
+            nodeAccess.setNode(innerNodeId, lat, lon, ele);
+        }
+    }
+
+    private void interpolateElevationsOfInnerNodesForTwoOuterNodes(int firstOuterNodeId,
+                    int secondOuterNodeId, int[] innerNodeIds) {
+        final NodeAccess nodeAccess = storage.getNodeAccess();
+        double lat0 = nodeAccess.getLat(firstOuterNodeId);
+        double lon0 = nodeAccess.getLon(firstOuterNodeId);
+        double ele0 = nodeAccess.getEle(firstOuterNodeId);
+
+        double lat1 = nodeAccess.getLat(secondOuterNodeId);
+        double lon1 = nodeAccess.getLon(secondOuterNodeId);
+        double ele1 = nodeAccess.getEle(secondOuterNodeId);
+
+        for (int innerNodeId : innerNodeIds) {
+            double lat = nodeAccess.getLat(innerNodeId);
+            double lon = nodeAccess.getLon(innerNodeId);
+            double ele = elevationInterpolator.calculateElevationBasedOnTwoPoints(lat, lon, lat0,
+                            lon0, ele0, lat1, lon1, ele1);
+            nodeAccess.setNode(innerNodeId, lat, lon, ele);
+        }
+    }
+
+    private void interpolateElevationsOfInnerNodesForThreeOuterNodes(int firstOuterNodeId,
+                    int secondOuterNodeId, int thirdOuterNodeId, int[] innerNodeIds) {
+        NodeAccess nodeAccess = storage.getNodeAccess();
+        double lat0 = nodeAccess.getLat(firstOuterNodeId);
+        double lon0 = nodeAccess.getLon(firstOuterNodeId);
+        double ele0 = nodeAccess.getEle(firstOuterNodeId);
+
+        double lat1 = nodeAccess.getLat(secondOuterNodeId);
+        double lon1 = nodeAccess.getLon(secondOuterNodeId);
+        double ele1 = nodeAccess.getEle(secondOuterNodeId);
+
+        double lat2 = nodeAccess.getLat(thirdOuterNodeId);
+        double lon2 = nodeAccess.getLon(thirdOuterNodeId);
+        double ele2 = nodeAccess.getEle(thirdOuterNodeId);
+
+        for (int innerNodeId : innerNodeIds) {
+            double lat = nodeAccess.getLat(innerNodeId);
+            double lon = nodeAccess.getLon(innerNodeId);
+            double ele = elevationInterpolator.calculateElevationBasedOnThreePoints(lat, lon, lat0,
+                            lon0, ele0, lat1, lon1, ele1, lat2, lon2, ele2);
+            nodeAccess.setNode(innerNodeId, lat, lon, ele);
+        }
+    }
+
+    private void interpolateElevationsOfInnerNodesForNOuterNodes(int[] outerNodeIds,
+                    int[] innerNodeIds) {
+        NodeAccess nodeAccess = storage.getNodeAccess();
+        PointList pointList = new PointList(outerNodeIds.length, true);
+        for (int outerNodeId : outerNodeIds) {
+            pointList.add(nodeAccess.getLat(outerNodeId), nodeAccess.getLon(outerNodeId),
+                            nodeAccess.getEle(outerNodeId));
+        }
+        for (int innerNodeId : innerNodeIds) {
+            double lat = nodeAccess.getLat(innerNodeId);
+            double lon = nodeAccess.getLon(innerNodeId);
+            double ele = elevationInterpolator.calculateElevationBasedOnPointList(lat, lon,
+                            pointList);
+            nodeAccess.setNode(innerNodeId, lat, lon, ele);
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 8f56703ea7..88c67bc64d 100755
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -40,57 +40,54 @@
  * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
  * 90 meters in extent.
  * <p>
+ *
  * @author Peter Karich
  */
-public class SRTMProvider implements ElevationProvider
-{
-    public static void main( String[] args ) throws IOException
-    {
-        SRTMProvider provider = new SRTMProvider();
-        // 1046
-        System.out.println(provider.getEle(47.468668, 14.575127));
-        // 1113
-        System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 1946
-        System.out.println(provider.getEle(46.468835, 12.578777));
-
-        // 845
-        System.out.println(provider.getEle(48.469123, 9.576393));
-
-        // 1113 vs new: 
-        provider.setCalcMean(true);
-        System.out.println(provider.getEle(47.467753, 14.573911));
-    }
-
+public class SRTMProvider implements ElevationProvider {
     private static final BitUtil BIT_UTIL = BitUtil.BIG;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int DEFAULT_WIDTH = 1201;
     private final int WIDTH_BYTE_INDEX = 0;
-    private Directory dir;
-    private DAType daType = DAType.MMAP;
-    private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
-    private File cacheDir = new File("/tmp/srtm");
     // use a map as an array is not quite useful if we want to hold only parts of the world
     private final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
     private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
     private final double precision = 1e7;
     private final double invPrecision = 1 / precision;
+    private Directory dir;
+    private DAType daType = DAType.MMAP;
+    private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
+    private File cacheDir = new File("/tmp/srtm");
     // possible alternatives see #451
     // http://mirror.ufs.ac.za/datasets/SRTM3/
     //"http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/"
     private String baseUrl = "https://srtm.kurviger.de/SRTM3/";
     private boolean calcMean = false;
 
-    public SRTMProvider()
-    {
+    public SRTMProvider() {
         // move to explicit calls?
         init();
     }
 
+    public static void main(String[] args) throws IOException {
+        SRTMProvider provider = new SRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new:
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
     @Override
-    public void setCalcMean( boolean calcMean )
-    {
+    public void setCalcMean(boolean calcMean) {
         this.calcMean = calcMean;
     }
 
@@ -98,19 +95,12 @@ public void setCalcMean( boolean calcMean )
      * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
      * coordinate has.
      */
-    private SRTMProvider init()
-    {
-        try
-        {
-            String strs[] =
-            {
-                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-            };
-            for (String str : strs)
-            {
+    private SRTMProvider init() {
+        try {
+            String strs[] = {"Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"};
+            for (String str : strs) {
                 InputStream is = getClass().getResourceAsStream(str + "_names.txt");
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
-                {
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS))) {
                     int lat = Integer.parseInt(line.substring(1, 3));
                     if (line.substring(0, 1).charAt(0) == 'S')
                         lat = -lat;
@@ -126,43 +116,36 @@ private SRTMProvider init()
                 }
             }
             return this;
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new IllegalStateException("Cannot load area names from classpath", ex);
         }
     }
 
     // use int key instead of string for lower memory usage
-    private int calcIntKey( double lat, double lon )
-    {
+    private int calcIntKey(double lat, double lon) {
         // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
         return (down(lat) + 90) * 1000 + down(lon) + 180;
     }
 
-    public void setDownloader( Downloader downloader )
-    {
+    public void setDownloader(Downloader downloader) {
         this.downloader = downloader;
     }
 
     @Override
-    public ElevationProvider setCacheDir( File cacheDir )
-    {
+    public ElevationProvider setCacheDir(File cacheDir) {
         if (cacheDir.exists() && !cacheDir.isDirectory())
             throw new IllegalArgumentException("Cache path has to be a directory");
 
-        try
-        {
+        try {
             this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException(ex);
         }
         return this;
     }
 
     @Override
-    public ElevationProvider setBaseURL( String baseUrl )
-    {
+    public ElevationProvider setBaseURL(String baseUrl) {
         if (baseUrl == null || baseUrl.isEmpty())
             throw new IllegalArgumentException("baseUrl cannot be empty");
 
@@ -171,22 +154,19 @@ public ElevationProvider setBaseURL( String baseUrl )
     }
 
     @Override
-    public ElevationProvider setDAType( DAType daType )
-    {
+    public ElevationProvider setDAType(DAType daType) {
         this.daType = daType;
         return this;
     }
 
-    int down( double val )
-    {
+    int down(double val) {
         int intVal = (int) val;
         if (val >= 0 || intVal - val < invPrecision)
             return intVal;
         return intVal - 1;
     }
 
-    String getFileString( double lat, double lon )
-    {
+    String getFileString(double lat, double lon) {
         int intKey = calcIntKey(lat, lon);
         String str = areas.get(intKey);
         if (str == null)
@@ -218,8 +198,7 @@ String getFileString( double lat, double lon )
     }
 
     @Override
-    public double getEle( double lat, double lon )
-    {
+    public double getEle(double lat, double lon) {
         lat = (int) (lat * precision) / precision;
         lon = (int) (lon * precision) / precision;
         int intKey = calcIntKey(lat, lon);
@@ -236,11 +215,9 @@ public double getEle( double lat, double lon )
 
         DataAccess heights = getDirectory().find("dem" + intKey);
         boolean loadExisting = false;
-        try
-        {
+        try {
             loadExisting = heights.loadExisting();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
         }
 
@@ -258,14 +235,11 @@ public double getEle( double lat, double lon )
         return demProvider.getHeight(lat, lon);
     }
 
-    private void updateHeightsFromZipFile( String fileDetails, DataAccess heights ) throws RuntimeException
-    {
-        try
-        {
+    private void updateHeightsFromZipFile(String fileDetails, DataAccess heights) throws RuntimeException {
+        try {
             byte[] bytes = getByteArrayFromZipFile(fileDetails);
             heights.create(bytes.length);
-            for (int bytePos = 0; bytePos < bytes.length; bytePos += 2)
-            {
+            for (int bytePos = 0; bytePos < bytes.length; bytePos += 2) {
                 short val = BIT_UTIL.toShort(bytes, bytePos);
                 if (val < -1000 || val > 12000)
                     val = Short.MIN_VALUE;
@@ -275,27 +249,22 @@ private void updateHeightsFromZipFile( String fileDetails, DataAccess heights )
             heights.setHeader(WIDTH_BYTE_INDEX, bytes.length / 2);
             heights.flush();
 
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    private byte[] getByteArrayFromZipFile( String fileDetails ) throws InterruptedException, FileNotFoundException, IOException
-    {
+    private byte[] getByteArrayFromZipFile(String fileDetails) throws InterruptedException, FileNotFoundException, IOException {
         String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
         File file = new File(cacheDir, new File(zippedURL).getName());
         InputStream is;
         // get zip file if not already in cacheDir
         if (!file.exists())
-            for (int i = 0; i < 3; i++)
-            {
-                try
-                {
+            for (int i = 0; i < 3; i++) {
+                try {
                     downloader.downloadFile(zippedURL, file.getAbsolutePath());
                     break;
-                } catch (SocketTimeoutException ex)
-                {
+                } catch (SocketTimeoutException ex) {
                     // just try again after a little nap
                     Thread.sleep(2000);
                     continue;
@@ -309,8 +278,7 @@ private void updateHeightsFromZipFile( String fileDetails, DataAccess heights )
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         byte[] buffer = new byte[0xFFFF];
         int len;
-        while ((len = buff.read(buffer)) > 0)
-        {
+        while ((len = buff.read(buffer)) > 0) {
             os.write(buffer, 0, len);
         }
         os.flush();
@@ -319,8 +287,7 @@ private void updateHeightsFromZipFile( String fileDetails, DataAccess heights )
     }
 
     @Override
-    public void release()
-    {
+    public void release() {
         cacheData.clear();
 
         // for memory mapped type we create temporary unpacked files which should be removed
@@ -329,13 +296,11 @@ public void release()
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "SRTM";
     }
 
-    private Directory getDirectory()
-    {
+    private Directory getDirectory() {
         if (dir != null)
             return dir;
 
diff --git a/core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java
new file mode 100644
index 0000000000..645dce6e99
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java
@@ -0,0 +1,41 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Elevation interpolator for tunnels. Estimates elevations of inner nodes of
+ * the tunnel based on elevations of entry/exit nodes of the tunnel.
+ *
+ * @author Alexey Valikov
+ */
+public class TunnelElevationInterpolator extends AbstractEdgeElevationInterpolator {
+
+    public TunnelElevationInterpolator(GraphHopperStorage storage,
+                    DataFlagEncoder dataFlagEncoder) {
+        super(storage, dataFlagEncoder);
+    }
+
+    @Override
+    protected boolean isInterpolatableEdge(EdgeIteratorState edge) {
+        return dataFlagEncoder.isTransportModeTunnel(edge);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspector.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspector.java
index 58975322d1..db9d1dd2aa 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspector.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspector.java
@@ -19,37 +19,35 @@
 
 import com.graphhopper.reader.ConditionalTagInspector;
 import com.graphhopper.reader.ReaderWay;
-import java.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.*;
+
 /**
  * Inspects the conditional tags of an OSMWay according to the given conditional tags.
  * <p>
+ *
  * @author Robin Boldt
  */
-public class ConditionalOSMTagInspector implements ConditionalTagInspector
-{
+public class ConditionalOSMTagInspector implements ConditionalTagInspector {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    // enabling by default makes noise but could improve OSM data
-    private boolean enabledLogs = true;
     private final List<String> tagsToCheck;
     private final Map<String, Object> valueMap;
     private final ConditionalParser permitParser, restrictiveParser;
+    // enabling by default makes noise but could improve OSM data
+    private boolean enabledLogs = true;
 
-    public ConditionalOSMTagInspector( Object value, List<String> tagsToCheck,
-                                       Set<String> restrictiveValues, Set<String> permittedValues )
-    {
+    public ConditionalOSMTagInspector(Object value, List<String> tagsToCheck,
+                                      Set<String> restrictiveValues, Set<String> permittedValues) {
         this(tagsToCheck, createDefaultMapping(value), restrictiveValues, permittedValues, false);
     }
 
-    public ConditionalOSMTagInspector( List<String> tagsToCheck, Map<String, Object> valueMap,
-                                       Set<String> restrictiveValues, Set<String> permittedValues, boolean enabledLogs )
-    {
+    public ConditionalOSMTagInspector(List<String> tagsToCheck, Map<String, Object> valueMap,
+                                      Set<String> restrictiveValues, Set<String> permittedValues, boolean enabledLogs) {
         this.valueMap = valueMap;
         this.tagsToCheck = new ArrayList<>(tagsToCheck.size());
-        for (String tagToCheck : tagsToCheck)
-        {
+        for (String tagToCheck : tagsToCheck) {
             this.tagsToCheck.add(tagToCheck + ":conditional");
         }
 
@@ -61,8 +59,7 @@ public ConditionalOSMTagInspector( List<String> tagsToCheck, Map<String, Object>
         this.restrictiveParser = new ConditionalParser(restrictiveValues, logUnsupportedFeatures);
     }
 
-    static Map<String, Object> createDefaultMapping( Object value )
-    {
+    static Map<String, Object> createDefaultMapping(Object value) {
         // parse date range and value is the time
         Map<String, Object> map = new HashMap<String, Object>(1);
         map.put(DateRange.KEY, value);
@@ -70,44 +67,36 @@ public ConditionalOSMTagInspector( List<String> tagsToCheck, Map<String, Object>
     }
 
     @Override
-    public boolean isRestrictedWayConditionallyPermitted( ReaderWay way )
-    {
+    public boolean isRestrictedWayConditionallyPermitted(ReaderWay way) {
         return applies(way, true);
     }
 
     @Override
-    public boolean isPermittedWayConditionallyRestricted( ReaderWay way )
-    {
+    public boolean isPermittedWayConditionallyRestricted(ReaderWay way) {
         return applies(way, false);
     }
 
-    protected boolean applies( ReaderWay way, boolean checkPermissiveValues )
-    {
-        for (int index = 0; index < tagsToCheck.size(); index++)
-        {
+    protected boolean applies(ReaderWay way, boolean checkPermissiveValues) {
+        for (int index = 0; index < tagsToCheck.size(); index++) {
             String tagToCheck = tagsToCheck.get(index);
             String val = way.getTag(tagToCheck);
             if (val == null || val.isEmpty())
                 continue;
 
-            try
-            {
+            try {
                 ValueRange valueRange;
                 if (checkPermissiveValues)
                     valueRange = permitParser.getRange(val);
                 else
                     valueRange = restrictiveParser.getRange(val);
 
-                if (valueRange != null)
-                {
+                if (valueRange != null) {
                     Object value = valueMap.get(valueRange.getKey());
                     if (value != null && valueRange.isInRange(value))
                         return true;
                 }
-            } catch (Exception e)
-            {
-                if (enabledLogs)
-                {
+            } catch (Exception e) {
+                if (enabledLogs) {
                     // log only if no date ala 21:00 as currently date and numbers do not support time precise restrictions
                     if (!val.contains(":"))
                         logger.warn(way.getId() + " - could not parse the conditional value:" + val + " of tag:" + tagToCheck + ". Exception:" + e.getMessage());
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalParser.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalParser.java
index ae466ed5b3..b39009d4bc 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalParser.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/ConditionalParser.java
@@ -27,33 +27,29 @@
  * Parses a conditional tag according to
  * http://wiki.openstreetmap.org/wiki/Conditional_restrictions.
  * <p>
+ *
  * @author Robin Boldt
  */
-public class ConditionalParser
-{
+public class ConditionalParser {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final Set<String> restrictedTags;
     private final boolean enabledLogs;
 
-    public ConditionalParser( Set<String> restrictedTags )
-    {
+    public ConditionalParser(Set<String> restrictedTags) {
         this(restrictedTags, false);
     }
 
-    public ConditionalParser( Set<String> restrictedTags, boolean enabledLogs )
-    {
+    public ConditionalParser(Set<String> restrictedTags, boolean enabledLogs) {
         // use map => key & type (date vs. double)
         this.restrictedTags = restrictedTags;
         this.enabledLogs = enabledLogs;
     }
 
-    public ValueRange getRange( String conditionalTag ) throws ParseException
-    {
+    public ValueRange getRange(String conditionalTag) throws ParseException {
         if (conditionalTag == null || conditionalTag.isEmpty() || !conditionalTag.contains("@"))
             return null;
 
-        if (conditionalTag.contains(";"))
-        {
+        if (conditionalTag.contains(";")) {
             if (enabledLogs)
                 logger.warn("We do not support multiple conditions yet: " + conditionalTag);
             return null;
@@ -74,50 +70,42 @@ public ValueRange getRange( String conditionalTag ) throws ParseException
         conditional = conditional.trim();
 
         int index = conditional.indexOf(">");
-        if (index > 0 && conditional.length() > 2)
-        {
+        if (index > 0 && conditional.length() > 2) {
             final String key = conditional.substring(0, index).trim();
             // for now just ignore equals sign
             if (conditional.charAt(index + 1) == '=')
                 index++;
 
             final double value = parseNumber(conditional.substring(index + 1));
-            return new ValueRange<Number>()
-            {
+            return new ValueRange<Number>() {
                 @Override
-                public boolean isInRange( Number obj )
-                {
+                public boolean isInRange(Number obj) {
                     return obj.doubleValue() > value;
                 }
 
                 @Override
-                public String getKey()
-                {
+                public String getKey() {
                     return key;
                 }
             };
         }
 
         index = conditional.indexOf("<");
-        if (index > 0 && conditional.length() > 2)
-        {
+        if (index > 0 && conditional.length() > 2) {
             final String key = conditional.substring(0, index).trim();
             if (conditional.charAt(index + 1) == '=')
                 index++;
 
             final double value = parseNumber(conditional.substring(index + 1));
-            return new ValueRange<Number>()
-            {
+            return new ValueRange<Number>() {
 
                 @Override
-                public boolean isInRange( Number obj )
-                {
+                public boolean isInRange(Number obj) {
                     return obj.doubleValue() < value;
                 }
 
                 @Override
-                public String getKey()
-                {
+                public String getKey() {
                     return key;
                 }
             };
@@ -126,11 +114,9 @@ public String getKey()
         return DateRangeParser.parseDateRange(conditional);
     }
 
-    protected double parseNumber( String str )
-    {
+    protected double parseNumber(String str) {
         int untilIndex = str.length() - 1;
-        for (; untilIndex >= 0; untilIndex--)
-        {
+        for (; untilIndex >= 0; untilIndex--) {
             if (Character.isDigit(str.charAt(untilIndex)))
                 break;
         }
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRange.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRange.java
index be092e2111..c8e5aeb600 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRange.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRange.java
@@ -18,54 +18,46 @@
 package com.graphhopper.reader.osm.conditional;
 
 import com.graphhopper.util.Helper;
+
 import java.text.DateFormat;
 import java.util.Calendar;
 
 /**
  * This class represents a date range and is able to determine if a given date is in that range.
  * <p>
+ *
  * @author Robin Boldt
  */
-public class DateRange implements ValueRange<Calendar>
-{
+public class DateRange implements ValueRange<Calendar> {
+    public static final String KEY = "DateRange";
     private final Calendar from;
     private final Calendar to;
-
     // Do not compare years
     boolean yearless = false;
-
     boolean dayOnly = false;
-
     boolean reverse = false;
 
-    public DateRange( ParsedCalendar from, ParsedCalendar to )
-    {
+    public DateRange(ParsedCalendar from, ParsedCalendar to) {
         Calendar fromCal = from.parsedCalendar;
         Calendar toCal = to.parsedCalendar;
 
         // This should never happen
-        if (fromCal.get(Calendar.ERA) != toCal.get(Calendar.ERA))
-        {
+        if (fromCal.get(Calendar.ERA) != toCal.get(Calendar.ERA)) {
             throw new IllegalArgumentException("Different ERAs are not allowed. From:" + from + " To:" + to);
         }
 
-        if (from.isYearless() && to.isYearless())
-        {
+        if (from.isYearless() && to.isYearless()) {
             yearless = true;
         }
 
-        if (from.isDayOnly() && to.isDayOnly())
-        {
+        if (from.isDayOnly() && to.isDayOnly()) {
             dayOnly = true;
         }
 
-        if (fromCal.getTimeInMillis() > toCal.getTimeInMillis())
-        {
-            if (!yearless && !dayOnly)
-            {
+        if (fromCal.getTimeInMillis() > toCal.getTimeInMillis()) {
+            if (!yearless && !dayOnly) {
                 throw new IllegalArgumentException("From after to makes no sense, except for isYearless and isDayOnly DateRanges. From:" + from + " To:" + to);
-            } else
-            {
+            } else {
                 reverse = true;
             }
         }
@@ -74,28 +66,21 @@ public DateRange( ParsedCalendar from, ParsedCalendar to )
         this.to = to.getMax();
     }
 
-    public static final String KEY = "DateRange";
-
     @Override
-    public String getKey()
-    {
+    public String getKey() {
         return KEY;
     }
 
     @Override
-    public boolean isInRange( Calendar date )
-    {
+    public boolean isInRange(Calendar date) {
         if (!yearless && !dayOnly)
             return date.after(from) && date.before(to);
 
-        if (dayOnly)
-        {
+        if (dayOnly) {
             int currentDayOfWeek = date.get(Calendar.DAY_OF_WEEK);
-            if (reverse)
-            {
+            if (reverse) {
                 return from.get(Calendar.DAY_OF_WEEK) <= currentDayOfWeek || currentDayOfWeek <= to.get(Calendar.DAY_OF_WEEK);
-            } else
-            {
+            } else {
                 return from.get(Calendar.DAY_OF_WEEK) <= currentDayOfWeek && currentDayOfWeek <= to.get(Calendar.DAY_OF_WEEK);
             }
         }
@@ -106,26 +91,22 @@ public boolean isInRange( Calendar date )
             return isInRangeYearless(date);
     }
 
-    private boolean isInRangeYearless( Calendar date )
-    {
+    private boolean isInRangeYearless(Calendar date) {
         if (from.get(Calendar.MONTH) < date.get(Calendar.MONTH) && date.get(Calendar.MONTH) < to.get(Calendar.MONTH))
             return true;
-        if (from.get(Calendar.MONTH) == date.get(Calendar.MONTH) && to.get(Calendar.MONTH) == date.get(Calendar.MONTH))
-        {
+        if (from.get(Calendar.MONTH) == date.get(Calendar.MONTH) && to.get(Calendar.MONTH) == date.get(Calendar.MONTH)) {
             if (from.get(Calendar.DAY_OF_MONTH) <= date.get(Calendar.DAY_OF_MONTH) && date.get(Calendar.DAY_OF_MONTH) <= to.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
                 return false;
         }
-        if (from.get(Calendar.MONTH) == date.get(Calendar.MONTH))
-        {
+        if (from.get(Calendar.MONTH) == date.get(Calendar.MONTH)) {
             if (from.get(Calendar.DAY_OF_MONTH) <= date.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
                 return false;
         }
-        if (to.get(Calendar.MONTH) == date.get(Calendar.MONTH))
-        {
+        if (to.get(Calendar.MONTH) == date.get(Calendar.MONTH)) {
             if (date.get(Calendar.DAY_OF_MONTH) <= to.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
@@ -134,28 +115,24 @@ private boolean isInRangeYearless( Calendar date )
         return false;
     }
 
-    private boolean isInRangeYearlessReverse( Calendar date )
-    {
+    private boolean isInRangeYearlessReverse(Calendar date) {
         int currMonth = date.get(Calendar.MONTH);
         if (from.get(Calendar.MONTH) < currMonth || currMonth < to.get(Calendar.MONTH))
             return true;
-        if (from.get(Calendar.MONTH) == currMonth && to.get(Calendar.MONTH) == currMonth)
-        {
+        if (from.get(Calendar.MONTH) == currMonth && to.get(Calendar.MONTH) == currMonth) {
             if (from.get(Calendar.DAY_OF_MONTH) < date.get(Calendar.DAY_OF_MONTH)
                     || date.get(Calendar.DAY_OF_MONTH) < to.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
                 return false;
         }
-        if (from.get(Calendar.MONTH) == currMonth)
-        {
+        if (from.get(Calendar.MONTH) == currMonth) {
             if (from.get(Calendar.DAY_OF_MONTH) <= date.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
                 return false;
         }
-        if (to.get(Calendar.MONTH) == currMonth)
-        {
+        if (to.get(Calendar.MONTH) == currMonth) {
             if (date.get(Calendar.DAY_OF_MONTH) <= to.get(Calendar.DAY_OF_MONTH))
                 return true;
             else
@@ -165,8 +142,7 @@ private boolean isInRangeYearlessReverse( Calendar date )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         DateFormat f = Helper.createFormatter();
         return "yearless:" + yearless + ", dayOnly:" + dayOnly + ", reverse:" + reverse
                 + ", from:" + f.format(from.getTime()) + ", to:" + f.format(to.getTime());
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRangeParser.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRangeParser.java
index d86fdd422d..a496697e54 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRangeParser.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/DateRangeParser.java
@@ -18,74 +18,66 @@
 package com.graphhopper.reader.osm.conditional;
 
 import com.graphhopper.util.Helper;
-import static com.graphhopper.util.Helper.createFormatter;
+
 import java.text.DateFormat;
 import java.text.ParseException;
-import java.util.*;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.List;
+import java.util.Locale;
+
+import static com.graphhopper.util.Helper.createFormatter;
 
 /**
  * Parses a DateRange from OpenStreetMap. Currently only DateRanges that last at least one day are
  * supported. The Syntax is allowed inputs is described here:
  * http://wiki.openstreetmap.org/wiki/Key:opening_hours.
  * <p>
+ *
  * @author Robin Boldt
  */
-public class DateRangeParser
-{
+public class DateRangeParser {
     private static final DateFormat YEAR_MONTH_DAY_DF = createFormatter("yyyy MMM dd");
     private static final DateFormat MONTH_DAY_DF = createFormatter("MMM dd");
     private static final DateFormat MONTH_DAY2_DF = createFormatter("dd.MM");
     private static final DateFormat YEAR_MONTH_DF = createFormatter("yyyy MMM");
     private static final DateFormat MONTH_DF = createFormatter("MMM");
-    private static final List<String> DAY_NAMES = Arrays.asList(new String[]
-    {
+    private static final List<String> DAY_NAMES = Arrays.asList(new String[]{
         "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"
     });
 
-    public static Calendar createCalendar()
-    {
+    public static Calendar createCalendar() {
         // Use locale US as exception here (instead of UK) to match week order "Su-Sa" used in Calendar for day_of_week.
         // Inconsistent but we should not use US for other date handling stuff like strange default formatting, related to #647.
         return Calendar.getInstance(Helper.UTC, Locale.US);
     }
 
-    static ParsedCalendar parseDateString( String dateString ) throws ParseException
-    {
+    static ParsedCalendar parseDateString(String dateString) throws ParseException {
         // Replace occurences of public holidays
         dateString = dateString.replaceAll("(,( )*)?(PH|SH)", "");
         dateString = dateString.trim();
         Calendar calendar = createCalendar();
         ParsedCalendar parsedCalendar;
-        try
-        {
+        try {
             calendar.setTime(YEAR_MONTH_DAY_DF.parse(dateString));
             parsedCalendar = new ParsedCalendar(ParsedCalendar.ParseType.YEAR_MONTH_DAY, calendar);
-        } catch (ParseException e1)
-        {
-            try
-            {
+        } catch (ParseException e1) {
+            try {
                 calendar.setTime(MONTH_DAY_DF.parse(dateString));
                 parsedCalendar = new ParsedCalendar(ParsedCalendar.ParseType.MONTH_DAY, calendar);
-            } catch (ParseException e2)
-            {
-                try
-                {
+            } catch (ParseException e2) {
+                try {
                     calendar.setTime(MONTH_DAY2_DF.parse(dateString));
                     parsedCalendar = new ParsedCalendar(ParsedCalendar.ParseType.MONTH_DAY, calendar);
-                } catch (ParseException e3)
-                {
-                    try
-                    {
+                } catch (ParseException e3) {
+                    try {
                         calendar.setTime(YEAR_MONTH_DF.parse(dateString));
                         parsedCalendar = new ParsedCalendar(ParsedCalendar.ParseType.YEAR_MONTH, calendar);
-                    } catch (ParseException e4)
-                    {
-                        try
-                        {
+                    } catch (ParseException e4) {
+                        try {
                             calendar.setTime(MONTH_DF.parse(dateString));
                             parsedCalendar = new ParsedCalendar(ParsedCalendar.ParseType.MONTH, calendar);
-                        } catch (ParseException e5)
-                        {
+                        } catch (ParseException e5) {
                             int index = DAY_NAMES.indexOf(dateString);
                             if (index < 0)
                                 throw new ParseException("Unparseable date: \"" + dateString + "\"", 0);
@@ -102,8 +94,7 @@ static ParsedCalendar parseDateString( String dateString ) throws ParseException
         return parsedCalendar;
     }
 
-    public static DateRange parseDateRange( String dateRangeString ) throws ParseException
-    {
+    public static DateRange parseDateRange(String dateRangeString) throws ParseException {
         if (dateRangeString == null || dateRangeString.isEmpty())
             throw new IllegalArgumentException("Passing empty Strings is not allowed");
 
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/ParsedCalendar.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/ParsedCalendar.java
index 1748d02b14..1def0407da 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/ParsedCalendar.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/ParsedCalendar.java
@@ -18,43 +18,38 @@
 package com.graphhopper.reader.osm.conditional;
 
 import com.graphhopper.util.Helper;
+
 import java.util.Calendar;
 
 /**
  * This class represents a parsed Date and the parse type.
  * <p>
+ *
  * @author Robin Boldt
  */
-public class ParsedCalendar
-{
+public class ParsedCalendar {
     public final ParseType parseType;
     public final Calendar parsedCalendar;
 
-    public ParsedCalendar( ParseType parseType, Calendar parsedCalendar )
-    {
+    public ParsedCalendar(ParseType parseType, Calendar parsedCalendar) {
         this.parseType = parseType;
         this.parsedCalendar = parsedCalendar;
     }
 
-    public boolean isYearless()
-    {
+    public boolean isYearless() {
         return parseType == ParseType.MONTH || parseType == ParseType.MONTH_DAY;
     }
 
-    public boolean isDayless()
-    {
+    public boolean isDayless() {
         return parseType == ParseType.MONTH || parseType == ParseType.YEAR_MONTH;
     }
 
-    public boolean isDayOnly()
-    {
+    public boolean isDayOnly() {
         return parseType == ParseType.DAY;
     }
 
-    public Calendar getMax()
-    {
-        if (isDayless())
-        {
+    public Calendar getMax() {
+        if (isDayless()) {
             parsedCalendar.set(Calendar.DAY_OF_MONTH, parsedCalendar.getActualMaximum(Calendar.DAY_OF_MONTH));
         }
         parsedCalendar.set(Calendar.HOUR_OF_DAY, parsedCalendar.getActualMaximum(Calendar.HOUR_OF_DAY));
@@ -65,10 +60,8 @@ public Calendar getMax()
         return parsedCalendar;
     }
 
-    public Calendar getMin()
-    {
-        if (isDayless())
-        {
+    public Calendar getMin() {
+        if (isDayless()) {
             parsedCalendar.set(Calendar.DAY_OF_MONTH, parsedCalendar.getActualMinimum(Calendar.DAY_OF_MONTH));
         }
         parsedCalendar.set(Calendar.HOUR_OF_DAY, parsedCalendar.getActualMinimum(Calendar.HOUR_OF_DAY));
@@ -80,13 +73,11 @@ public Calendar getMin()
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return parseType + "; " + Helper.createFormatter().format(parsedCalendar.getTime());
     }
 
-    public enum ParseType
-    {
+    public enum ParseType {
         YEAR_MONTH_DAY,
         YEAR_MONTH,
         MONTH_DAY,
diff --git a/core/src/main/java/com/graphhopper/reader/osm/conditional/ValueRange.java b/core/src/main/java/com/graphhopper/reader/osm/conditional/ValueRange.java
index aa36053b27..5867d3e19d 100755
--- a/core/src/main/java/com/graphhopper/reader/osm/conditional/ValueRange.java
+++ b/core/src/main/java/com/graphhopper/reader/osm/conditional/ValueRange.java
@@ -18,15 +18,13 @@
 package com.graphhopper.reader.osm.conditional;
 
 /**
- *
  * @author Peter Karich
  */
-public interface ValueRange<T>
-{
+public interface ValueRange<T> {
     /**
      * Checks if the value is in range of this ValueRange check method.
      */
-    boolean isInRange( T value );
+    boolean isInRange(T value);
 
     String getKey();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 2ca46d31a6..055b62072b 100755
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,22 +17,21 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.util.DistancePlaneProjection;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-
-import java.util.PriorityQueue;
-
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.routing.util.WeightApproximator;
-import com.graphhopper.routing.util.BeelineWeightApproximator;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.BeelineWeightApproximator;
+import com.graphhopper.routing.weighting.WeightApproximator;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Parameters;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
 
 /**
  * This class implements the A* algorithm according to
@@ -40,10 +39,10 @@
  * <p>
  * Different distance calculations can be used via setApproximation.
  * <p>
+ *
  * @author Peter Karich
  */
-public class AStar extends AbstractRoutingAlgorithm
-{
+public class AStar extends AbstractRoutingAlgorithm {
     private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEntry> fromMap;
@@ -51,9 +50,8 @@
     private AStarEntry currEdge;
     private int to1 = -1;
 
-    public AStar( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
+    public AStar(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
         int size = Math.min(Math.max(200, graph.getNodes() / 10), 2000);
         initCollections(size);
         BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
@@ -64,40 +62,34 @@ public AStar( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMo
     /**
      * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( WeightApproximator approx )
-    {
+    public AStar setApproximation(WeightApproximator approx) {
         weightApprox = approx;
         return this;
     }
 
-    protected void initCollections( int size )
-    {
+    protected void initCollections(int size) {
         fromMap = new TIntObjectHashMap<AStarEntry>();
         prioQueueOpenSet = new PriorityQueue<AStarEntry>(size);
     }
 
     @Override
-    public Path calcPath( int from, int to )
-    {
+    public Path calcPath(int from, int to) {
         checkAlreadyRun();
         to1 = to;
 
         weightApprox.setGoalNode(to);
         double weightToGoal = weightApprox.approximate(from);
         currEdge = new AStarEntry(EdgeIterator.NO_EDGE, from, 0 + weightToGoal, 0);
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             fromMap.put(from, currEdge);
         }
         return runAlgo();
     }
 
-    private Path runAlgo()
-    {
+    private Path runAlgo() {
         double currWeightToGoal, estimationFullWeight;
         EdgeExplorer explorer = outEdgeExplorer;
-        while (true)
-        {
+        while (true) {
             int currVertex = currEdge.adjNode;
             visitedCount++;
             if (isMaxVisitedNodesExceeded())
@@ -107,8 +99,7 @@ private Path runAlgo()
                 break;
 
             EdgeIterator iter = explorer.setBaseNode(currVertex);
-            while (iter.next())
-            {
+            while (iter.next()) {
                 if (!accept(iter, currEdge.edge))
                     continue;
 
@@ -120,16 +111,13 @@ private Path runAlgo()
                     continue;
 
                 AStarEntry ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
-                {
+                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight) {
                     currWeightToGoal = weightApprox.approximate(neighborNode);
                     estimationFullWeight = alreadyVisitedWeight + currWeightToGoal;
-                    if (ase == null)
-                    {
+                    if (ase == null) {
                         ase = new AStarEntry(iter.getEdge(), neighborNode, estimationFullWeight, alreadyVisitedWeight);
                         fromMap.put(traversalId, ase);
-                    } else
-                    {
+                    } else {
                         assert (ase.weight > 0.9999999 * estimationFullWeight) : "Inconsistent distance estimate "
                                 + ase.weight + " vs " + estimationFullWeight + " (" + ase.weight / estimationFullWeight + "), and:"
                                 + ase.weightOfVisitedPath + " vs " + alreadyVisitedWeight + " (" + ase.weightOfVisitedPath / alreadyVisitedWeight + ")";
@@ -158,49 +146,42 @@ private Path runAlgo()
     }
 
     @Override
-    protected Path extractPath()
-    {
-        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
+    protected Path extractPath() {
+        return new Path(graph, weighting).
+                setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
     }
 
     @Override
-    protected SPTEntry createSPTEntry( int node, double weight )
-    {
+    protected SPTEntry createSPTEntry(int node, double weight) {
         throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
-    protected boolean finished()
-    {
+    protected boolean finished() {
         return currEdge.adjNode == to1;
     }
 
     @Override
-    public int getVisitedNodes()
-    {
+    public int getVisitedNodes() {
         return visitedCount;
     }
 
-    public static class AStarEntry extends SPTEntry
-    {
+    @Override
+    public String getName() {
+        return Parameters.Algorithms.ASTAR;
+    }
+
+    public static class AStarEntry extends SPTEntry {
         double weightOfVisitedPath;
 
-        public AStarEntry( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
-        {
+        public AStarEntry(int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath) {
             super(edgeId, adjNode, weightForHeap);
             this.weightOfVisitedPath = weightOfVisitedPath;
         }
 
         @Override
-        public final double getWeightOfVisitedPath()
-        {
+        public final double getWeightOfVisitedPath() {
             return weightOfVisitedPath;
         }
     }
-
-    @Override
-    public String getName()
-    {
-        return Parameters.Algorithms.ASTAR;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 9c08165397..1b3023c0c3 100755
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,17 +17,21 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.AStar.AStarEntry;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.BeelineWeightApproximator;
+import com.graphhopper.routing.weighting.ConsistentWeightApproximator;
+import com.graphhopper.routing.weighting.WeightApproximator;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
 
-import com.graphhopper.routing.AStar.AStarEntry;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.*;
-
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
@@ -50,24 +54,23 @@
  * or could we even use this three phase approach?
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p>
+ *
  * @author Peter Karich
  * @author jansoe
  */
-public class AStarBidirection extends AbstractBidirAlgo
-{
-    private ConsistentWeightApproximator weightApprox;
-    private PriorityQueue<AStarEntry> prioQueueOpenSetFrom;
+public class AStarBidirection extends AbstractBidirAlgo {
     protected TIntObjectMap<AStarEntry> bestWeightMapFrom;
-    private PriorityQueue<AStarEntry> prioQueueOpenSetTo;
     protected TIntObjectMap<AStarEntry> bestWeightMapTo;
-    private TIntObjectMap<AStarEntry> bestWeightMapOther;
     protected AStarEntry currFrom;
     protected AStarEntry currTo;
     protected PathBidirRef bestPath;
+    private ConsistentWeightApproximator weightApprox;
+    private PriorityQueue<AStarEntry> prioQueueOpenSetFrom;
+    private PriorityQueue<AStarEntry> prioQueueOpenSetTo;
+    private TIntObjectMap<AStarEntry> bestWeightMapOther;
 
-    public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
+    public AStarBidirection(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
         int size = Math.min(Math.max(200, graph.getNodes() / 10), 2000);
         initCollections(size);
         BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
@@ -75,8 +78,7 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         setApproximation(defaultApprox);
     }
 
-    protected void initCollections( int size )
-    {
+    protected void initCollections(int size) {
         prioQueueOpenSetFrom = new PriorityQueue<AStarEntry>(size);
         bestWeightMapFrom = new TIntObjectHashMap<AStarEntry>(size);
 
@@ -87,96 +89,76 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( WeightApproximator approx )
-    {
+    public AStarBidirection setApproximation(WeightApproximator approx) {
         weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
     @Override
-    protected SPTEntry createSPTEntry( int node, double weight )
-    {
+    protected SPTEntry createSPTEntry(int node, double weight) {
         throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
-    public void initFrom( int from, double weight )
-    {
+    public void initFrom(int from, double weight) {
         currFrom = new AStarEntry(EdgeIterator.NO_EDGE, from, weight, weight);
         weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
 
-        if (currTo != null)
-        {
+        if (currTo != null) {
             currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
             currTo.weight += weightApprox.approximate(currTo.adjNode, true);
         }
 
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             bestWeightMapFrom.put(from, currFrom);
-            if (currTo != null)
-            {
+            if (currTo != null) {
                 bestWeightMapOther = bestWeightMapTo;
                 updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
             }
-        } else
-        {
-            if (currTo != null && currTo.adjNode == from)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
+        } else if (currTo != null && currTo.adjNode == from) {
+            // special case of identical start and end
+            bestPath.sptEntry = currFrom;
+            bestPath.edgeTo = currTo;
+            finishedFrom = true;
+            finishedTo = true;
         }
     }
 
     @Override
-    public void initTo( int to, double weight )
-    {
+    public void initTo(int to, double weight) {
         currTo = new AStarEntry(EdgeIterator.NO_EDGE, to, weight, weight);
         weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
 
-        if (currFrom != null)
-        {
+        if (currFrom != null) {
             currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
             currTo.weight += weightApprox.approximate(currTo.adjNode, true);
         }
 
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             bestWeightMapTo.put(to, currTo);
-            if (currFrom != null)
-            {
+            if (currFrom != null) {
                 bestWeightMapOther = bestWeightMapFrom;
                 updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
             }
-        } else
-        {
-            if (currFrom != null && currFrom.adjNode == to)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
+        } else if (currFrom != null && currFrom.adjNode == to) {
+            // special case of identical start and end
+            bestPath.sptEntry = currFrom;
+            bestPath.edgeTo = currTo;
+            finishedFrom = true;
+            finishedTo = true;
         }
     }
 
     @Override
-    protected Path createAndInitPath()
-    {
-        bestPath = new PathBidirRef(graph, flagEncoder);
+    protected Path createAndInitPath() {
+        bestPath = new PathBidirRef(graph, weighting);
         return bestPath;
     }
 
     @Override
-    protected Path extractPath()
-    {
+    protected Path extractPath() {
         if (finished())
             return bestPath.extract();
 
@@ -184,20 +166,17 @@ protected Path extractPath()
     }
 
     @Override
-    protected double getCurrentFromWeight()
-    {
+    protected double getCurrentFromWeight() {
         return currFrom.weight;
     }
 
     @Override
-    protected double getCurrentToWeight()
-    {
+    protected double getCurrentToWeight() {
         return currTo.weight;
     }
 
     @Override
-    protected boolean finished()
-    {
+    protected boolean finished() {
         if (finishedFrom || finishedTo)
             return true;
 
@@ -206,8 +185,7 @@ protected boolean finished()
     }
 
     @Override
-    boolean fillEdgesFrom()
-    {
+    boolean fillEdgesFrom() {
         if (prioQueueOpenSetFrom.isEmpty())
             return false;
 
@@ -219,8 +197,7 @@ boolean fillEdgesFrom()
     }
 
     @Override
-    boolean fillEdgesTo()
-    {
+    boolean fillEdgesTo() {
         if (prioQueueOpenSetTo.isEmpty())
             return false;
 
@@ -231,14 +208,12 @@ boolean fillEdgesTo()
         return true;
     }
 
-    private void fillEdges( AStarEntry currEdge, PriorityQueue<AStarEntry> prioQueueOpenSet,
-                            TIntObjectMap<AStarEntry> bestWeightMap, EdgeExplorer explorer, boolean reverse )
-    {
+    private void fillEdges(AStarEntry currEdge, PriorityQueue<AStarEntry> prioQueueOpenSet,
+                           TIntObjectMap<AStarEntry> bestWeightMap, EdgeExplorer explorer, boolean reverse) {
 
         int currNode = currEdge.adjNode;
         EdgeIterator iter = explorer.setBaseNode(currNode);
-        while (iter.next())
-        {
+        while (iter.next()) {
             if (!accept(iter, currEdge.edge))
                 continue;
 
@@ -252,16 +227,13 @@ private void fillEdges( AStarEntry currEdge, PriorityQueue<AStarEntry> prioQueue
                 continue;
 
             AStarEntry ase = bestWeightMap.get(traversalId);
-            if (ase == null || ase.getWeightOfVisitedPath() > alreadyVisitedWeight)
-            {
+            if (ase == null || ase.getWeightOfVisitedPath() > alreadyVisitedWeight) {
                 double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullWeight = alreadyVisitedWeight + currWeightToGoal;
-                if (ase == null)
-                {
+                if (ase == null) {
                     ase = new AStarEntry(iter.getEdge(), neighborNode, estimationFullWeight, alreadyVisitedWeight);
                     bestWeightMap.put(traversalId, ase);
-                } else
-                {
+                } else {
                     assert (ase.weight > 0.999999 * estimationFullWeight) : "Inconsistent distance estimate "
                             + ase.weight + " vs " + estimationFullWeight + " (" + ase.weight / estimationFullWeight + "), and:"
                             + ase.getWeightOfVisitedPath() + " vs " + alreadyVisitedWeight + " (" + ase.getWeightOfVisitedPath() / alreadyVisitedWeight + ")";
@@ -278,8 +250,7 @@ private void fillEdges( AStarEntry currEdge, PriorityQueue<AStarEntry> prioQueue
         }
     }
 
-    public void updateBestPath( EdgeIteratorState edgeState, AStarEntry entryCurrent, int currLoc )
-    {
+    public void updateBestPath(EdgeIteratorState edgeState, AStarEntry entryCurrent, int currLoc) {
         AStarEntry entryOther = bestWeightMapOther.get(currLoc);
         if (entryOther == null)
             return;
@@ -287,26 +258,20 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEntry entryCurrent
         boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update μ
         double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
-        if (traversalMode.isEdgeBased())
-        {
+        if (traversalMode.isEdgeBased()) {
             if (entryOther.edge != entryCurrent.edge)
                 throw new IllegalStateException("cannot happen for edge based execution of " + getName());
 
             // see DijkstraBidirectionRef
-            if (entryOther.adjNode != entryCurrent.adjNode)
-            {
+            if (entryOther.adjNode != entryCurrent.adjNode) {
                 entryCurrent = (AStar.AStarEntry) entryCurrent.parent;
                 newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
-            } else
-            {
+            } else if (!traversalMode.hasUTurnSupport())
                 // we detected a u-turn at meeting point, skip if not supported
-                if (!traversalMode.hasUTurnSupport())
-                    return;
-            }
+                return;
         }
 
-        if (newWeight < bestPath.getWeight())
-        {
+        if (newWeight < bestPath.getWeight()) {
             bestPath.setSwitchToFrom(reverse);
             bestPath.sptEntry = entryCurrent;
             bestPath.edgeTo = entryOther;
@@ -315,8 +280,7 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEntry entryCurrent
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return Parameters.Algorithms.ASTAR_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 755dba4e25..edece875d8 100755
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -19,24 +19,28 @@
 
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
  * Common subclass for bidirectional algorithms.
  * <p>
+ *
  * @author Peter Karich
  */
-public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm
-{
-    int visitedCountFrom;
-    int visitedCountTo;
+public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm {
     protected boolean finishedFrom;
     protected boolean finishedTo;
+    int visitedCountFrom;
+    int visitedCountTo;
 
-    abstract void initFrom( int from, double dist );
+    public AbstractBidirAlgo(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
+    }
+
+    abstract void initFrom(int from, double dist);
 
-    abstract void initTo( int to, double dist );
+    abstract void initTo(int to, double dist);
 
     protected abstract Path createAndInitPath();
 
@@ -48,14 +52,8 @@
 
     abstract boolean fillEdgesTo();
 
-    public AbstractBidirAlgo( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
-    }
-
     @Override
-    public Path calcPath( int from, int to )
-    {
+    public Path calcPath(int from, int to) {
         checkAlreadyRun();
         createAndInitPath();
         initFrom(from, 0);
@@ -64,10 +62,8 @@ public Path calcPath( int from, int to )
         return extractPath();
     }
 
-    protected void runAlgo()
-    {
-        while (!finished() && !isMaxVisitedNodesExceeded())
-        {
+    protected void runAlgo() {
+        while (!finished() && !isMaxVisitedNodesExceeded()) {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
 
@@ -77,8 +73,7 @@ protected void runAlgo()
     }
 
     @Override
-    public int getVisitedNodes()
-    {
+    public int getVisitedNodes() {
         return visitedCountFrom + visitedCountTo;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index c72a624760..490b8812c9 100755
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -31,29 +35,26 @@
 /**
  * @author Peter Karich
  */
-public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm
-{
-    private EdgeFilter additionalEdgeFilter;
+public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm {
     protected final Graph graph;
-    protected NodeAccess nodeAccess;
-    protected EdgeExplorer inEdgeExplorer;
-    protected EdgeExplorer outEdgeExplorer;
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
     protected final TraversalMode traversalMode;
+    protected NodeAccess nodeAccess;
+    protected EdgeExplorer inEdgeExplorer;
+    protected EdgeExplorer outEdgeExplorer;
     protected int maxVisitedNodes = Integer.MAX_VALUE;
+    private EdgeFilter additionalEdgeFilter;
     private boolean alreadyRun;
 
     /**
-     * @param graph specifies the graph where this algorithm will run on
-     * @param encoder sets the used vehicle (bike, car, foot)
-     * @param weighting set the used weight calculation (e.g. fastest, shortest).
+     * @param graph         specifies the graph where this algorithm will run on
+     * @param weighting     set the used weight calculation (e.g. fastest, shortest).
      * @param traversalMode how the graph is traversed e.g. if via nodes or edges.
      */
-    public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
-    {
+    public AbstractRoutingAlgorithm(Graph graph, Weighting weighting, TraversalMode traversalMode) {
         this.weighting = weighting;
-        this.flagEncoder = encoder;
+        this.flagEncoder = weighting.getFlagEncoder();
         this.traversalMode = traversalMode;
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
@@ -62,39 +63,33 @@ public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting wei
     }
 
     @Override
-    public void setMaxVisitedNodes( int numberOfNodes )
-    {
+    public void setMaxVisitedNodes(int numberOfNodes) {
         this.maxVisitedNodes = numberOfNodes;
     }
 
-    public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
-    {
+    public RoutingAlgorithm setEdgeFilter(EdgeFilter additionalEdgeFilter) {
         this.additionalEdgeFilter = additionalEdgeFilter;
         return this;
     }
 
-    protected boolean accept( EdgeIterator iter, int prevOrNextEdgeId )
-    {
+    protected boolean accept(EdgeIterator iter, int prevOrNextEdgeId) {
         if (!traversalMode.hasUTurnSupport() && iter.getEdge() == prevOrNextEdgeId)
             return false;
 
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);
     }
 
-    protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry bestSPTEntry, int traversalId )
-    {
+    protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry bestSPTEntry, int traversalId) {
     }
 
-    protected void checkAlreadyRun()
-    {
+    protected void checkAlreadyRun() {
         if (alreadyRun)
             throw new IllegalStateException("Create a new instance per call");
 
         alreadyRun = true;
     }
 
-    protected SPTEntry createSPTEntry( int node, double weight )
-    {
+    protected SPTEntry createSPTEntry(int node, double weight) {
         return new SPTEntry(EdgeIterator.NO_EDGE, node, weight);
     }
 
@@ -102,6 +97,7 @@ protected SPTEntry createSPTEntry( int node, double weight )
      * To be overwritten from extending class. Should we make this available in RoutingAlgorithm
      * interface?
      * <p>
+     *
      * @return true if finished.
      */
     protected abstract boolean finished();
@@ -110,35 +106,31 @@ protected SPTEntry createSPTEntry( int node, double weight )
      * To be overwritten from extending class. Should we make this available in RoutingAlgorithm
      * interface?
      * <p>
+     *
      * @return true if finished.
      */
     protected abstract Path extractPath();
 
     @Override
-    public List<Path> calcPaths( int from, int to )
-    {
+    public List<Path> calcPaths(int from, int to) {
         return Collections.singletonList(calcPath(from, to));
     }
 
-    protected Path createEmptyPath()
-    {
-        return new Path(graph, flagEncoder);
+    protected Path createEmptyPath() {
+        return new Path(graph, weighting);
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return getClass().getSimpleName();
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getName() + "|" + weighting;
     }
 
-    protected boolean isMaxVisitedNodesExceeded()
-    {
+    protected boolean isMaxVisitedNodesExceeded() {
         return maxVisitedNodes < getVisitedNodes();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
index af83e31737..a15de5c33b 100755
--- a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -17,9 +17,8 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
 
@@ -32,121 +31,103 @@
  *        build();
  * </pre>
  * <p>
+ *
  * @author Peter Karich
  */
-public class AlgorithmOptions
-{
+public class AlgorithmOptions {
+    private final PMap hints = new PMap(5);
     private String algorithm = Parameters.Algorithms.DIJKSTRA_BI;
     private Weighting weighting;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private FlagEncoder flagEncoder;
     private int maxVisitedNodes = Integer.MAX_VALUE;
-    private final PMap hints = new PMap(5);
 
-    private AlgorithmOptions()
-    {
+    private AlgorithmOptions() {
     }
 
     /**
      * Default traversal mode NODE_BASED is used.
      */
-    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting )
-    {
+    public AlgorithmOptions(String algorithm, Weighting weighting) {
         this.algorithm = algorithm;
         this.weighting = weighting;
-        this.flagEncoder = flagEncoder;
     }
 
-    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting, TraversalMode tMode )
-    {
+    public AlgorithmOptions(String algorithm, Weighting weighting, TraversalMode tMode) {
         this.algorithm = algorithm;
         this.weighting = weighting;
-        this.flagEncoder = flagEncoder;
         this.traversalMode = tMode;
     }
 
+    /**
+     * This method starts the building process for AlgorithmOptions.
+     */
+    public static Builder start() {
+        return new Builder();
+    }
+
+    /**
+     * This method clones the specified AlgorithmOption object with the possibility for further
+     * changes.
+     */
+    public static Builder start(AlgorithmOptions opts) {
+        Builder b = new Builder();
+        if (opts.algorithm != null)
+            b.algorithm(opts.getAlgorithm());
+        if (opts.traversalMode != null)
+            b.traversalMode(opts.getTraversalMode());
+        if (opts.weighting != null)
+            b.weighting(opts.getWeighting());
+        if (opts.maxVisitedNodes >= 0)
+            b.maxVisitedNodes(opts.maxVisitedNodes);
+        if (!opts.hints.isEmpty())
+            b.hints(opts.hints);
+
+        return b;
+    }
+
     /**
      * @return the traversal mode, where node-based is the default.
      */
-    public TraversalMode getTraversalMode()
-    {
+    public TraversalMode getTraversalMode() {
         return traversalMode;
     }
 
-    public Weighting getWeighting()
-    {
+    public boolean hasWeighting() {
+        return weighting != null;
+    }
+
+    public Weighting getWeighting() {
         assertNotNull(weighting, "weighting");
         return weighting;
     }
 
-    public String getAlgorithm()
-    {
+    public String getAlgorithm() {
         assertNotNull(algorithm, "algorithm");
         return algorithm;
     }
 
-    public FlagEncoder getFlagEncoder()
-    {
-        assertNotNull(flagEncoder, "flagEncoder");
-        return flagEncoder;
-    }
-
-    public int getMaxVisitedNodes()
-    {
+    public int getMaxVisitedNodes() {
         return maxVisitedNodes;
     }
 
-    public PMap getHints()
-    {
+    public PMap getHints() {
         return hints;
     }
 
-    private void assertNotNull( Object optionValue, String optionName )
-    {
+    private void assertNotNull(Object optionValue, String optionName) {
         if (optionValue == null)
             throw new NullPointerException("Option '" + optionName + "' must NOT be null");
     }
 
     @Override
-    public String toString()
-    {
-        return algorithm + ", " + weighting + ", " + flagEncoder + ", " + traversalMode;
-    }
-
-    /**
-     * This method starts the building process for AlgorithmOptions.
-     */
-    public static Builder start()
-    {
-        return new Builder();
+    public String toString() {
+        return algorithm + ", " + weighting + ", " + traversalMode;
     }
 
-    /**
-     * This method clones the specified AlgorithmOption object with the possibility for further
-     * changes.
-     */
-    public static Builder start( AlgorithmOptions opts )
-    {
-        Builder b = new Builder();
-        if (opts.algorithm != null)
-            b.algorithm(opts.getAlgorithm());
-        if (opts.flagEncoder != null)
-            b.flagEncoder(opts.getFlagEncoder());
-        if (opts.traversalMode != null)
-            b.traversalMode(opts.getTraversalMode());
-        if (opts.weighting != null)
-            b.weighting(opts.getWeighting());
-        if (opts.maxVisitedNodes >= 0)
-            b.maxVisitedNodes(opts.maxVisitedNodes);
-        return b;
-    }
-
-    public static class Builder
-    {
+    public static class Builder {
         private final AlgorithmOptions opts = new AlgorithmOptions();
 
-        public Builder traversalMode( TraversalMode traversalMode )
-        {
+        public Builder traversalMode(TraversalMode traversalMode) {
             if (traversalMode == null)
                 throw new IllegalArgumentException("null as traversal mode is not allowed");
 
@@ -154,8 +135,7 @@ public Builder traversalMode( TraversalMode traversalMode )
             return this;
         }
 
-        public Builder weighting( Weighting weighting )
-        {
+        public Builder weighting(Weighting weighting) {
             this.opts.weighting = weighting;
             return this;
         }
@@ -163,32 +143,22 @@ public Builder weighting( Weighting weighting )
         /**
          * For possible values see AlgorithmOptions.*
          */
-        public Builder algorithm( String algorithm )
-        {
+        public Builder algorithm(String algorithm) {
             this.opts.algorithm = algorithm;
             return this;
         }
 
-        public Builder flagEncoder( FlagEncoder flagEncoder )
-        {
-            this.opts.flagEncoder = flagEncoder;
-            return this;
-        }
-
-        public Builder maxVisitedNodes( int maxVisitedNodes )
-        {
+        public Builder maxVisitedNodes(int maxVisitedNodes) {
             this.opts.maxVisitedNodes = maxVisitedNodes;
             return this;
         }
 
-        public Builder hints( PMap hints )
-        {
+        public Builder hints(PMap hints) {
             this.opts.hints.put(hints);
             return this;
         }
 
-        public AlgorithmOptions build()
-        {
+        public AlgorithmOptions build() {
             return opts;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 6a4914e164..de2ebfe722 100755
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -20,25 +20,24 @@
 import com.graphhopper.routing.AStar.AStarEntry;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Parameters;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
+import gnu.trove.procedure.TIntObjectProcedure;
+import gnu.trove.procedure.TObjectProcedure;
+import gnu.trove.set.TIntSet;
+import gnu.trove.set.hash.TIntHashSet;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
-
-import gnu.trove.procedure.TIntObjectProcedure;
-import gnu.trove.procedure.TObjectProcedure;
-import gnu.trove.set.TIntSet;
-import gnu.trove.set.hash.TIntHashSet;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -61,8 +60,13 @@
  *
  * @author Peter Karich
  */
-public class AlternativeRoute implements RoutingAlgorithm
-{
+public class AlternativeRoute implements RoutingAlgorithm {
+    private static final Comparator<AlternativeInfo> ALT_COMPARATOR = new Comparator<AlternativeInfo>() {
+        @Override
+        public int compare(AlternativeInfo o1, AlternativeInfo o2) {
+            return Double.compare(o1.sortBy, o2.sortBy);
+        }
+    };
     private final Graph graph;
     private final FlagEncoder flagEncoder;
     private final Weighting weighting;
@@ -73,22 +77,40 @@
     // the higher the maxWeightFactor the higher the explorationFactor needs to be
     // 1 is default for bidir Dijkstra, 0.8 seems to be a very similar value for bidir A* but roughly 1/2 of the nodes explored
     private double maxExplorationFactor = 0.8;
-
     private double maxShareFactor = 0.6;
     private double minPlateauFactor = 0.2;
     private int maxPaths = 2;
 
-    public AlternativeRoute( Graph graph, FlagEncoder flagEncoder, Weighting weighting, TraversalMode traversalMode )
-    {
+    public AlternativeRoute(Graph graph, Weighting weighting, TraversalMode traversalMode) {
         this.graph = graph;
-        this.flagEncoder = flagEncoder;
+        this.flagEncoder = weighting.getFlagEncoder();
         this.weighting = weighting;
         this.traversalMode = traversalMode;
     }
 
+    static List<String> getAltNames(Graph graph, SPTEntry ee) {
+        if (ee == null || !EdgeIterator.Edge.isValid(ee.edge))
+            return Collections.emptyList();
+
+        EdgeIteratorState iter = graph.getEdgeIteratorState(ee.edge, Integer.MIN_VALUE);
+        if (iter == null)
+            return Collections.emptyList();
+
+        String str = iter.getName();
+        if (str.isEmpty())
+            return Collections.emptyList();
+
+        return Collections.singletonList(str);
+    }
+
+    static double calcSortBy(double weightInfluence, double weight,
+                             double shareInfluence, double shareWeight,
+                             double plateauInfluence, double plateauWeight) {
+        return weightInfluence * weight + shareInfluence * shareWeight + plateauInfluence * plateauWeight;
+    }
+
     @Override
-    public void setMaxVisitedNodes( int numberOfNodes )
-    {
+    public void setMaxVisitedNodes(int numberOfNodes) {
         this.maxVisitedNodes = numberOfNodes;
     }
 
@@ -97,8 +119,7 @@ public void setMaxVisitedNodes( int numberOfNodes )
      * all alternatives with a weight 2 times longer than the optimal weight are return. (default is
      * 1)
      */
-    public void setMaxWeightFactor( double maxWeightFactor )
-    {
+    public void setMaxWeightFactor(double maxWeightFactor) {
         this.maxWeightFactor = maxWeightFactor;
     }
 
@@ -106,16 +127,14 @@ public void setMaxWeightFactor( double maxWeightFactor )
      * This parameter is used to avoid alternatives too similar to the best path. Specify 0.5 to
      * force a same paths of maximum 50%. The unit is the 'weight' returned in the Weighting.
      */
-    public void setMaxShareFactor( double maxShareFactor )
-    {
+    public void setMaxShareFactor(double maxShareFactor) {
         this.maxShareFactor = maxShareFactor;
     }
 
     /**
      * This method sets the minimum plateau portion of every alternative path that is required.
      */
-    public void setMinPlateauFactor( double minPlateauFactor )
-    {
+    public void setMinPlateauFactor(double minPlateauFactor) {
         this.minPlateauFactor = minPlateauFactor;
     }
 
@@ -125,16 +144,14 @@ public void setMinPlateauFactor( double minPlateauFactor )
      * 1.5) and a lower value to improve query time but reduces the possibility to find
      * alternatives.
      */
-    public void setMaxExplorationFactor( double explorationFactor )
-    {
+    public void setMaxExplorationFactor(double explorationFactor) {
         this.maxExplorationFactor = explorationFactor;
     }
 
     /**
      * Specifies how many paths (including the optimal) are returned. (default is 2)
      */
-    public void setMaxPaths( int maxPaths )
-    {
+    public void setMaxPaths(int maxPaths) {
         this.maxPaths = maxPaths;
         if (this.maxPaths < 2)
             throw new IllegalStateException("Use normal algorithm with less overhead instead if no alternatives are required");
@@ -145,10 +162,9 @@ public void setMaxPaths( int maxPaths )
      * alternatives are searched and they are only accepted if they are not too similar but close to
      * the best path.
      */
-    public List<AlternativeInfo> calcAlternatives( int from, int to )
-    {
+    public List<AlternativeInfo> calcAlternatives(int from, int to) {
         AlternativeBidirSearch altBidirDijktra = new AlternativeBidirSearch(
-                graph, flagEncoder, weighting, traversalMode, maxExplorationFactor * 2);
+                graph, weighting, traversalMode, maxExplorationFactor * 2);
         altBidirDijktra.setMaxVisitedNodes(maxVisitedNodes);
         altBidirDijktra.searchBest(from, to);
         visitedNodes = altBidirDijktra.getVisitedNodes();
@@ -159,46 +175,31 @@ public void setMaxPaths( int maxPaths )
     }
 
     @Override
-    public Path calcPath( int from, int to )
-    {
+    public Path calcPath(int from, int to) {
         return calcPaths(from, to).get(0);
     }
 
     @Override
-    public List<Path> calcPaths( int from, int to )
-    {
+    public List<Path> calcPaths(int from, int to) {
         List<AlternativeInfo> alts = calcAlternatives(from, to);
         List<Path> paths = new ArrayList<Path>(alts.size());
-        for (AlternativeInfo a : alts)
-        {
+        for (AlternativeInfo a : alts) {
             paths.add(a.getPath());
         }
         return paths;
     }
 
-    private static final Comparator<AlternativeInfo> ALT_COMPARATOR = new Comparator<AlternativeInfo>()
-    {
-        @Override
-        public int compare( AlternativeInfo o1, AlternativeInfo o2 )
-        {
-            return Double.compare(o1.sortBy, o2.sortBy);
-        }
-    };
-
     @Override
-    public String getName()
-    {
+    public String getName() {
         return Parameters.Algorithms.ALT_ROUTE;
     }
 
     @Override
-    public int getVisitedNodes()
-    {
+    public int getVisitedNodes() {
         return visitedNodes;
     }
 
-    public static class AlternativeInfo
-    {
+    public static class AlternativeInfo {
         private final double sortBy;
         private final Path path;
         private final SPTEntry shareStart;
@@ -206,9 +207,8 @@ public int getVisitedNodes()
         private final double shareWeight;
         private final List<String> names;
 
-        public AlternativeInfo( double sortBy, Path path, SPTEntry shareStart, SPTEntry shareEnd,
-                                double shareWeight, List<String> altNames )
-        {
+        public AlternativeInfo(double sortBy, Path path, SPTEntry shareStart, SPTEntry shareEnd,
+                               double shareWeight, List<String> altNames) {
             this.names = altNames;
             this.sortBy = sortBy;
             this.path = path;
@@ -218,34 +218,28 @@ public AlternativeInfo( double sortBy, Path path, SPTEntry shareStart, SPTEntry
             this.shareWeight = shareWeight;
         }
 
-        public Path getPath()
-        {
+        public Path getPath() {
             return path;
         }
 
-        public SPTEntry getShareStart()
-        {
+        public SPTEntry getShareStart() {
             return shareStart;
         }
 
-        public SPTEntry getShareEnd()
-        {
+        public SPTEntry getShareEnd() {
             return shareEnd;
         }
 
-        public double getShareWeight()
-        {
+        public double getShareWeight() {
             return shareWeight;
         }
 
-        public double getSortBy()
-        {
+        public double getSortBy() {
             return sortBy;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return names + ", sortBy:" + sortBy + ", shareWeight:" + shareWeight + ", " + path;
         }
     }
@@ -253,30 +247,25 @@ public String toString()
     /**
      * Helper class to find alternatives and alternatives for round trip.
      */
-    public static class AlternativeBidirSearch extends AStarBidirection
-    {
+    public static class AlternativeBidirSearch extends AStarBidirection {
         private final double explorationFactor;
 
-        public AlternativeBidirSearch( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode,
-                                       double explorationFactor )
-        {
-            super(graph, encoder, weighting, tMode);
+        public AlternativeBidirSearch(Graph graph, Weighting weighting, TraversalMode tMode,
+                                      double explorationFactor) {
+            super(graph, weighting, tMode);
             this.explorationFactor = explorationFactor;
         }
 
-        public TIntObjectMap<AStarEntry> getBestWeightMapFrom()
-        {
+        public TIntObjectMap<AStarEntry> getBestWeightMapFrom() {
             return bestWeightMapFrom;
         }
 
-        public TIntObjectMap<AStarEntry> getBestWeightMapTo()
-        {
+        public TIntObjectMap<AStarEntry> getBestWeightMapTo() {
             return bestWeightMapTo;
         }
 
         @Override
-        public boolean finished()
-        {
+        public boolean finished() {
             // we need to finish BOTH searches identical to CH
             if (finishedFrom && finishedTo)
                 return true;
@@ -295,8 +284,7 @@ public boolean finished()
             // For bidir A* and AStarEdge.getWeightOfVisitedPath see comment in AStarBidirection.finished
         }
 
-        public Path searchBest( int to, int from )
-        {
+        public Path searchBest(int to, int from) {
             createAndInitPath();
             initFrom(to, 0);
             initTo(from, 0);
@@ -309,11 +297,10 @@ public Path searchBest( int to, int from )
          * @return the information necessary to handle alternative paths. Note that the paths are
          * not yet extracted.
          */
-        public List<AlternativeInfo> calcAlternatives( final int maxPaths,
-                                                       double maxWeightFactor, final double weightInfluence,
-                                                       final double maxShareFactor, final double shareInfluence,
-                                                       final double minPlateauFactor, final double plateauInfluence )
-        {
+        public List<AlternativeInfo> calcAlternatives(final int maxPaths,
+                                                      double maxWeightFactor, final double weightInfluence,
+                                                      final double maxShareFactor, final double shareInfluence,
+                                                      final double minPlateauFactor, final double plateauInfluence) {
             final double maxWeight = maxWeightFactor * bestPath.getWeight();
             final TIntObjectHashMap<TIntSet> traversalIDMap = new TIntObjectHashMap<TIntSet>();
             final AtomicInteger startTID = addToMap(traversalIDMap, bestPath);
@@ -334,19 +321,16 @@ public Path searchBest( int to, int from )
             alternatives.add(bestAlt);
             final List<SPTEntry> bestPathEntries = new ArrayList<SPTEntry>(2);
 
-            bestWeightMapFrom.forEachEntry(new TIntObjectProcedure<SPTEntry>()
-            {
+            bestWeightMapFrom.forEachEntry(new TIntObjectProcedure<SPTEntry>() {
                 @Override
-                public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
-                {
+                public boolean execute(final int traversalId, final SPTEntry fromSPTEntry) {
                     SPTEntry toSPTEntry = bestWeightMapTo.get(traversalId);
                     if (toSPTEntry == null)
                         return true;
 
-                    if (traversalMode.isEdgeBased())
-                    {
+                    if (traversalMode.isEdgeBased()) {
                         if (toSPTEntry.parent != null)
-                            // move to parent for two reasons: 
+                            // move to parent for two reasons:
                             // 1. make only turn costs missing in 'weight' and not duplicating current edge.weight
                             // 2. to avoid duplicate edge in Path
                             toSPTEntry = toSPTEntry.parent;
@@ -362,21 +346,19 @@ public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                         return true;
 
                     // (2) Use the start traversal ID of a plateau as ID for the alternative path.
-                    // Accept from-EdgeEntries only if such a start of a plateau 
-                    // i.e. discard if its parent has the same edgeId as the next to-SPTEntry.                                        
+                    // Accept from-EdgeEntries only if such a start of a plateau
+                    // i.e. discard if its parent has the same edgeId as the next to-SPTEntry.
                     // Ignore already added best path
                     if (isBestPath(fromSPTEntry, bestPath))
                         return true;
 
                     // For edge based traversal we need the next entry to find out the plateau start
                     SPTEntry tmpFromEntry = traversalMode.isEdgeBased() ? fromSPTEntry.parent : fromSPTEntry;
-                    if (tmpFromEntry == null || tmpFromEntry.parent == null)
-                    {
-                        // we can be here only if edge based and only if entry is not part of the best path 
+                    if (tmpFromEntry == null || tmpFromEntry.parent == null) {
+                        // we can be here only if edge based and only if entry is not part of the best path
                         // e.g. when starting point has two edges and one is part of the best path the other edge is path of an alternative
                         assert traversalMode.isEdgeBased();
-                    } else
-                    {
+                    } else {
                         int nextToTraversalId = traversalMode.createTraversalId(tmpFromEntry.adjNode,
                                 tmpFromEntry.parent.adjNode, tmpFromEntry.edge, true);
                         SPTEntry tmpNextToSPTEntry = bestWeightMapTo.get(nextToTraversalId);
@@ -390,7 +372,7 @@ public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                             return true;
                     }
 
-                    // (3a) calculate plateau, we know we are at the beginning of the 'from'-side of 
+                    // (3a) calculate plateau, we know we are at the beginning of the 'from'-side of
                     // the plateau A-B-C and go further to B
                     // where B is the next-'from' of A and B is also the previous-'to' of A.
                     //
@@ -404,8 +386,7 @@ public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                     double plateauWeight = 0;
                     SPTEntry prevToSPTEntry = toSPTEntry;
                     // List<Integer> plateauEdges = new ArrayList<Integer>();
-                    while (prevToSPTEntry.parent != null)
-                    {
+                    while (prevToSPTEntry.parent != null) {
                         int nextFromTraversalId = traversalMode.createTraversalId(prevToSPTEntry.adjNode, prevToSPTEntry.parent.adjNode,
                                 prevToSPTEntry.edge, false);
 
@@ -429,22 +410,20 @@ public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                     if (fromSPTEntry.parent == null)
                         throw new IllegalStateException("not implemented yet. in case of an edge based traversal the parent of fromSPTEntry could be null");
 
-                    // (3b) calculate share                    
+                    // (3b) calculate share
                     SPTEntry fromEE = getFirstShareEE(fromSPTEntry.parent, true);
                     SPTEntry toEE = getFirstShareEE(toSPTEntry.parent, false);
                     double shareWeight = fromEE.getWeightOfVisitedPath() + toEE.getWeightOfVisitedPath();
                     boolean smallShare = shareWeight / bestPath.getWeight() < maxShareFactor;
-                    if (smallShare)
-                    {
+                    if (smallShare) {
                         List<String> altNames = getAltNames(graph, fromSPTEntry);
 
                         double sortBy = calcSortBy(weightInfluence, weight, shareInfluence, shareWeight, plateauInfluence, plateauWeight);
                         double worstSortBy = getWorstSortBy();
 
                         // plateaus.add(new PlateauInfo(altName, plateauEdges));
-                        if (sortBy < worstSortBy || alternatives.size() < maxPaths)
-                        {
-                            Path path = new PathBidirRef(graph, flagEncoder).
+                        if (sortBy < worstSortBy || alternatives.size() < maxPaths) {
+                            Path path = new PathBidirRef(graph, weighting).
                                     setSPTEntryTo(toSPTEntry).setSPTEntry(fromSPTEntry).
                                     setWeight(weight);
                             path.extract();
@@ -469,10 +448,8 @@ public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                 /**
                  * Extract path until we stumble over an existing traversal id
                  */
-                SPTEntry getFirstShareEE( SPTEntry startEE, boolean reverse )
-                {
-                    while (startEE.parent != null)
-                    {
+                SPTEntry getFirstShareEE(SPTEntry startEE, boolean reverse) {
+                    while (startEE.parent != null) {
                         // TODO we could make use of traversal ID directly if stored in SPTEntry
                         int tid = traversalMode.createTraversalId(startEE.adjNode, startEE.parent.adjNode, startEE.edge, reverse);
                         if (isAlreadyExisting(tid))
@@ -488,13 +465,10 @@ SPTEntry getFirstShareEE( SPTEntry startEE, boolean reverse )
                  * This method returns true if the specified tid is already existent in the
                  * traversalIDMap
                  */
-                boolean isAlreadyExisting( final int tid )
-                {
-                    return !traversalIDMap.forEachValue(new TObjectProcedure<TIntSet>()
-                    {
+                boolean isAlreadyExisting(final int tid) {
+                    return !traversalIDMap.forEachValue(new TObjectProcedure<TIntSet>() {
                         @Override
-                        public boolean execute( TIntSet set )
-                        {
+                        public boolean execute(TIntSet set) {
                             return !set.contains(tid);
                         }
                     });
@@ -503,28 +477,23 @@ public boolean execute( TIntSet set )
                 /**
                  * Return the current worst weight for all alternatives
                  */
-                double getWorstSortBy()
-                {
+                double getWorstSortBy() {
                     if (alternatives.isEmpty())
                         throw new IllegalStateException("Empty alternative list cannot happen");
                     return alternatives.get(alternatives.size() - 1).sortBy;
                 }
 
                 // returns true if fromSPTEntry is identical to the specified best path
-                boolean isBestPath( SPTEntry fromSPTEntry, Path bestPath )
-                {
-                    if (traversalMode.isEdgeBased())
-                    {
-                        if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromSPTEntry.edge)
-                        {
+                boolean isBestPath(SPTEntry fromSPTEntry, Path bestPath) {
+                    if (traversalMode.isEdgeBased()) {
+                        if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromSPTEntry.edge) {
                             if (fromSPTEntry.parent == null)
                                 throw new IllegalStateException("best path must have no parent but was non-null: " + fromSPTEntry);
 
                             return true;
                         }
 
-                    } else if (fromSPTEntry.parent == null)
-                    {
+                    } else if (fromSPTEntry.parent == null) {
                         bestPathEntries.add(fromSPTEntry);
                         if (bestPathEntries.size() > 1)
                             throw new IllegalStateException("There is only one best path but was: " + bestPathEntries);
@@ -546,19 +515,15 @@ boolean isBestPath( SPTEntry fromSPTEntry, Path bestPath )
         /**
          * This method adds the traversal IDs of the specified path as set to the specified map.
          */
-        AtomicInteger addToMap( TIntObjectHashMap<TIntSet> map, Path path )
-        {
+        AtomicInteger addToMap(TIntObjectHashMap<TIntSet> map, Path path) {
             TIntSet set = new TIntHashSet();
             final AtomicInteger startTID = new AtomicInteger(-1);
-            for (EdgeIteratorState iterState : path.calcEdges())
-            {
+            for (EdgeIteratorState iterState : path.calcEdges()) {
                 int tid = traversalMode.createTraversalId(iterState, false);
                 set.add(tid);
-                if (startTID.get() < 0)
-                {
+                if (startTID.get() < 0) {
                     // for node based traversal we need to explicitely add base node as starting node and to list
-                    if (!traversalMode.isEdgeBased())
-                    {
+                    if (!traversalMode.isEdgeBased()) {
                         tid = iterState.getBaseNode();
                         set.add(tid);
                     }
@@ -571,53 +536,25 @@ AtomicInteger addToMap( TIntObjectHashMap<TIntSet> map, Path path )
         }
     }
 
-    static List<String> getAltNames( Graph graph, SPTEntry ee )
-    {
-        if (ee == null || !EdgeIterator.Edge.isValid(ee.edge))
-            return Collections.emptyList();
-
-        EdgeIteratorState iter = graph.getEdgeIteratorState(ee.edge, Integer.MIN_VALUE);
-        if (iter == null)
-            return Collections.emptyList();
-
-        String str = iter.getName();
-        if (str.isEmpty())
-            return Collections.emptyList();
-
-        return Collections.singletonList(str);
-    }
-
-    static double calcSortBy( double weightInfluence, double weight,
-                              double shareInfluence, double shareWeight,
-                              double plateauInfluence, double plateauWeight )
-    {
-        return weightInfluence * weight + shareInfluence * shareWeight + plateauInfluence * plateauWeight;
-    }
-
-    public static class PlateauInfo
-    {
+    public static class PlateauInfo {
         String name;
         List<Integer> edges;
 
-        public PlateauInfo( String name, List<Integer> edges )
-        {
+        public PlateauInfo(String name, List<Integer> edges) {
             this.name = name;
             this.edges = edges;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return name;
         }
 
-        public List<Integer> getEdges()
-        {
+        public List<Integer> getEdges() {
             return edges;
         }
 
-        public String getName()
-        {
+        public String getName() {
             return name;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 8f0eec50e1..56e0f8f3c1 100755
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -17,74 +17,66 @@
  */
 package com.graphhopper.routing;
 
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-
-import java.util.PriorityQueue;
-
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Parameters;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
 
 /**
  * Implements a single source shortest path algorithm
  * http://en.wikipedia.org/wiki/Dijkstra's_algorithm
  * <p>
+ *
  * @author Peter Karich
  */
-public class Dijkstra extends AbstractRoutingAlgorithm
-{
+public class Dijkstra extends AbstractRoutingAlgorithm {
     protected TIntObjectMap<SPTEntry> fromMap;
     protected PriorityQueue<SPTEntry> fromHeap;
     protected SPTEntry currEdge;
     private int visitedNodes;
     private int to = -1;
 
-    public Dijkstra( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
+    public Dijkstra(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
         int size = Math.min(Math.max(200, graph.getNodes() / 10), 2000);
         initCollections(size);
     }
 
-    protected void initCollections( int size )
-    {
+    protected void initCollections(int size) {
         fromHeap = new PriorityQueue<SPTEntry>(size);
         fromMap = new TIntObjectHashMap<SPTEntry>(size);
     }
 
     @Override
-    public Path calcPath( int from, int to )
-    {
+    public Path calcPath(int from, int to) {
         checkAlreadyRun();
         this.to = to;
         currEdge = createSPTEntry(from, 0);
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             fromMap.put(from, currEdge);
         }
         runAlgo();
         return extractPath();
     }
 
-    protected void runAlgo()
-    {
+    protected void runAlgo() {
         EdgeExplorer explorer = outEdgeExplorer;
-        while (true)
-        {
+        while (true) {
             visitedNodes++;
             if (isMaxVisitedNodesExceeded() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
             EdgeIterator iter = explorer.setBaseNode(startNode);
-            while (iter.next())
-            {
+            while (iter.next()) {
                 if (!accept(iter, currEdge.edge))
                     continue;
 
@@ -94,14 +86,12 @@ protected void runAlgo()
                     continue;
 
                 SPTEntry nEdge = fromMap.get(traversalId);
-                if (nEdge == null)
-                {
+                if (nEdge == null) {
                     nEdge = new SPTEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
                     nEdge.parent = currEdge;
                     fromMap.put(traversalId, nEdge);
                     fromHeap.add(nEdge);
-                } else if (nEdge.weight > tmpWeight)
-                {
+                } else if (nEdge.weight > tmpWeight) {
                     fromHeap.remove(nEdge);
                     nEdge.edge = iter.getEdge();
                     nEdge.weight = tmpWeight;
@@ -123,29 +113,26 @@ protected void runAlgo()
     }
 
     @Override
-    protected boolean finished()
-    {
+    protected boolean finished() {
         return currEdge.adjNode == to;
     }
 
     @Override
-    protected Path extractPath()
-    {
+    protected Path extractPath() {
         if (currEdge == null || !finished())
             return createEmptyPath();
 
-        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
+        return new Path(graph, weighting).
+                setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
     }
 
     @Override
-    public int getVisitedNodes()
-    {
+    public int getVisitedNodes() {
         return visitedNodes;
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return Parameters.Algorithms.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index d365eebe66..58a5f95e07 100755
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -17,46 +17,42 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.*;
-
 /**
  * Calculates best path in bidirectional way.
  * <p>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DijkstraBidirectionRef extends AbstractBidirAlgo
-{
-    private PriorityQueue<SPTEntry> openSetFrom;
-    private PriorityQueue<SPTEntry> openSetTo;
+public class DijkstraBidirectionRef extends AbstractBidirAlgo {
     protected TIntObjectMap<SPTEntry> bestWeightMapFrom;
     protected TIntObjectMap<SPTEntry> bestWeightMapTo;
     protected TIntObjectMap<SPTEntry> bestWeightMapOther;
     protected SPTEntry currFrom;
     protected SPTEntry currTo;
     protected PathBidirRef bestPath;
+    private PriorityQueue<SPTEntry> openSetFrom;
+    private PriorityQueue<SPTEntry> openSetTo;
     private boolean updateBestPath = true;
 
-    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
+    public DijkstraBidirectionRef(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
         int size = Math.min(Math.max(200, graph.getNodes() / 10), 2000);
         initCollections(size);
     }
 
-    protected void initCollections( int size )
-    {
+    protected void initCollections(int size) {
         openSetFrom = new PriorityQueue<SPTEntry>(size);
         bestWeightMapFrom = new TIntObjectHashMap<SPTEntry>(size);
 
@@ -65,67 +61,51 @@ protected void initCollections( int size )
     }
 
     @Override
-    public void initFrom( int from, double weight )
-    {
+    public void initFrom(int from, double weight) {
         currFrom = createSPTEntry(from, weight);
         openSetFrom.add(currFrom);
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             bestWeightMapFrom.put(from, currFrom);
-            if (currTo != null)
-            {
+            if (currTo != null) {
                 bestWeightMapOther = bestWeightMapTo;
                 updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
             }
-        } else
-        {
-            if (currTo != null && currTo.adjNode == from)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
+        } else if (currTo != null && currTo.adjNode == from) {
+            // special case of identical start and end
+            bestPath.sptEntry = currFrom;
+            bestPath.edgeTo = currTo;
+            finishedFrom = true;
+            finishedTo = true;
         }
     }
 
     @Override
-    public void initTo( int to, double weight )
-    {
+    public void initTo(int to, double weight) {
         currTo = createSPTEntry(to, weight);
         openSetTo.add(currTo);
-        if (!traversalMode.isEdgeBased())
-        {
+        if (!traversalMode.isEdgeBased()) {
             bestWeightMapTo.put(to, currTo);
-            if (currFrom != null)
-            {
+            if (currFrom != null) {
                 bestWeightMapOther = bestWeightMapFrom;
                 updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
             }
-        } else
-        {
-            if (currFrom != null && currFrom.adjNode == to)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
+        } else if (currFrom != null && currFrom.adjNode == to) {
+            // special case of identical start and end
+            bestPath.sptEntry = currFrom;
+            bestPath.edgeTo = currTo;
+            finishedFrom = true;
+            finishedTo = true;
         }
     }
 
     @Override
-    protected Path createAndInitPath()
-    {
-        bestPath = new PathBidirRef(graph, flagEncoder);
+    protected Path createAndInitPath() {
+        bestPath = new PathBidirRef(graph, weighting);
         return bestPath;
     }
 
     @Override
-    protected Path extractPath()
-    {
+    protected Path extractPath() {
         if (finished())
             return bestPath.extract();
 
@@ -133,20 +113,17 @@ protected Path extractPath()
     }
 
     @Override
-    protected double getCurrentFromWeight()
-    {
+    protected double getCurrentFromWeight() {
         return currFrom.weight;
     }
 
     @Override
-    protected double getCurrentToWeight()
-    {
+    protected double getCurrentToWeight() {
         return currTo.weight;
     }
 
     @Override
-    public boolean fillEdgesFrom()
-    {
+    public boolean fillEdgesFrom() {
         if (openSetFrom.isEmpty())
             return false;
 
@@ -158,8 +135,7 @@ public boolean fillEdgesFrom()
     }
 
     @Override
-    public boolean fillEdgesTo()
-    {
+    public boolean fillEdgesTo() {
         if (openSetTo.isEmpty())
             return false;
         currTo = openSetTo.poll();
@@ -174,20 +150,17 @@ public boolean fillEdgesTo()
     // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
     //    search, update extractPath = μ if df (v) + (v, w) + dr (w) < μ            
     @Override
-    public boolean finished()
-    {
+    public boolean finished() {
         if (finishedFrom || finishedTo)
             return true;
 
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
-    void fillEdges( SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
-                    TIntObjectMap<SPTEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
-    {
+    void fillEdges(SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
+                   TIntObjectMap<SPTEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse) {
         EdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);
-        while (iter.next())
-        {
+        while (iter.next()) {
             if (!accept(iter, currEdge.edge))
                 continue;
 
@@ -197,14 +170,12 @@ void fillEdges( SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
                 continue;
 
             SPTEntry ee = shortestWeightMap.get(traversalId);
-            if (ee == null)
-            {
+            if (ee == null) {
                 ee = new SPTEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
                 ee.parent = currEdge;
                 shortestWeightMap.put(traversalId, ee);
                 prioQueue.add(ee);
-            } else if (ee.weight > tmpWeight)
-            {
+            } else if (ee.weight > tmpWeight) {
                 prioQueue.remove(ee);
                 ee.edge = iter.getEdge();
                 ee.weight = tmpWeight;
@@ -219,8 +190,7 @@ void fillEdges( SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
     }
 
     @Override
-    protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry entryCurrent, int traversalId )
-    {
+    protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entryCurrent, int traversalId) {
         SPTEntry entryOther = bestWeightMapOther.get(traversalId);
         if (entryOther == null)
             return;
@@ -229,26 +199,20 @@ protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry entryCurren
 
         // update μ
         double newWeight = entryCurrent.weight + entryOther.weight;
-        if (traversalMode.isEdgeBased())
-        {
+        if (traversalMode.isEdgeBased()) {
             if (entryOther.edge != entryCurrent.edge)
                 throw new IllegalStateException("cannot happen for edge based execution of " + getName());
 
-            if (entryOther.adjNode != entryCurrent.adjNode)
-            {
+            if (entryOther.adjNode != entryCurrent.adjNode) {
                 // prevents the path to contain the edge at the meeting point twice and subtract the weight (excluding turn weight => no previous edge)
                 entryCurrent = entryCurrent.parent;
                 newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
-            } else
-            {
+            } else if (!traversalMode.hasUTurnSupport())
                 // we detected a u-turn at meeting point, skip if not supported
-                if (!traversalMode.hasUTurnSupport())
-                    return;
-            }
+                return;
         }
 
-        if (newWeight < bestPath.getWeight())
-        {
+        if (newWeight < bestPath.getWeight()) {
             bestPath.setSwitchToFrom(reverse);
             bestPath.setSPTEntry(entryCurrent);
             bestPath.setWeight(newWeight);
@@ -256,23 +220,19 @@ protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry entryCurren
         }
     }
 
-    TIntObjectMap<SPTEntry> getBestFromMap()
-    {
+    TIntObjectMap<SPTEntry> getBestFromMap() {
         return bestWeightMapFrom;
     }
 
-    TIntObjectMap<SPTEntry> getBestToMap()
-    {
+    TIntObjectMap<SPTEntry> getBestToMap() {
         return bestWeightMapTo;
     }
 
-    void setBestOtherMap( TIntObjectMap<SPTEntry> other )
-    {
+    void setBestOtherMap(TIntObjectMap<SPTEntry> other) {
         bestWeightMapOther = other;
     }
 
-    void setFromDataStructures( DijkstraBidirectionRef dijkstra )
-    {
+    void setFromDataStructures(DijkstraBidirectionRef dijkstra) {
         openSetFrom = dijkstra.openSetFrom;
         bestWeightMapFrom = dijkstra.bestWeightMapFrom;
         finishedFrom = dijkstra.finishedFrom;
@@ -281,8 +241,7 @@ void setFromDataStructures( DijkstraBidirectionRef dijkstra )
         // outEdgeExplorer
     }
 
-    void setToDataStructures( DijkstraBidirectionRef dijkstra )
-    {
+    void setToDataStructures(DijkstraBidirectionRef dijkstra) {
         openSetTo = dijkstra.openSetTo;
         bestWeightMapTo = dijkstra.bestWeightMapTo;
         finishedTo = dijkstra.finishedTo;
@@ -291,19 +250,16 @@ void setToDataStructures( DijkstraBidirectionRef dijkstra )
         // inEdgeExplorer
     }
 
-    void setUpdateBestPath( boolean b )
-    {
+    void setUpdateBestPath(boolean b) {
         updateBestPath = b;
     }
 
-    void setBestPath( PathBidirRef bestPath )
-    {
+    void setBestPath(PathBidirRef bestPath) {
         this.bestPath = bestPath;
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return Parameters.Algorithms.DIJKSTRA_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 2d70da481f..5ba2fa8c83 100755
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -20,7 +20,7 @@
 import com.graphhopper.coll.IntDoubleBinHeap;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
@@ -33,14 +33,14 @@
  * A simple dijkstra tuned to perform one to many queries more efficient than Dijkstra. Old data
  * structures are cached between requests and potentially reused. Useful for CH preparation.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DijkstraOneToMany extends AbstractRoutingAlgorithm
-{
+public class DijkstraOneToMany extends AbstractRoutingAlgorithm {
     private static final int EMPTY_PARENT = -1;
     private static final int NOT_FOUND = -1;
-    protected double[] weights;
     private final TIntArrayListWithCap changedNodes;
+    protected double[] weights;
     private int[] parents;
     private int[] edgeIds;
     private IntDoubleBinHeap heap;
@@ -50,9 +50,8 @@
     private int currNode, fromNode, to;
     private double weightLimit = Double.MAX_VALUE;
 
-    public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
+    public DijkstraOneToMany(Graph graph, Weighting weighting, TraversalMode tMode) {
+        super(graph, weighting, tMode);
 
         parents = new int[graph.getNodes()];
         Arrays.fill(parents, EMPTY_PARENT);
@@ -69,17 +68,15 @@ public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting,
     }
 
     @Override
-    public Path calcPath( int from, int to )
-    {
+    public Path calcPath(int from, int to) {
         fromNode = from;
         endNode = findEndNode(from, to);
         return extractPath();
     }
 
     @Override
-    public Path extractPath()
-    {
-        PathNative p = new PathNative(graph, flagEncoder, parents, edgeIds);
+    public Path extractPath() {
+        PathNative p = new PathNative(graph, weighting, parents, edgeIds);
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
@@ -93,29 +90,24 @@ public Path extractPath()
     /**
      * Call clear if you have a different start node and need to clear the cache.
      */
-    public DijkstraOneToMany clear()
-    {
+    public DijkstraOneToMany clear() {
         doClear = true;
         return this;
     }
 
-    public double getWeight( int endNode )
-    {
+    public double getWeight(int endNode) {
         return weights[endNode];
     }
 
-    public int findEndNode( int from, int to )
-    {
+    public int findEndNode(int from, int to) {
         if (weights.length < 2)
             return NOT_FOUND;
 
         this.to = to;
-        if (doClear)
-        {
+        if (doClear) {
             doClear = false;
             int vn = changedNodes.size();
-            for (int i = 0; i < vn; i++)
-            {
+            for (int i = 0; i < vn; i++) {
                 int n = changedNodes.get(i);
                 weights[n] = Double.MAX_VALUE;
                 parents[n] = EMPTY_PARENT;
@@ -126,13 +118,11 @@ public int findEndNode( int from, int to )
             changedNodes.reset();
 
             currNode = from;
-            if (!traversalMode.isEdgeBased())
-            {
+            if (!traversalMode.isEdgeBased()) {
                 weights[currNode] = 0;
                 changedNodes.add(currNode);
             }
-        } else
-        {
+        } else {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
             if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
@@ -147,20 +137,17 @@ public int findEndNode( int from, int to )
         visitedNodes = 0;
 
         // we call 'finished' before heap.peek_element but this would add unnecessary overhead for this special case so we do it outside of the loop
-        if (finished())
-        {
+        if (finished()) {
             // then we need a small workaround for special cases see #707
             if (heap.isEmpty())
                 doClear = true;
             return currNode;
         }
 
-        while (true)
-        {
+        while (true) {
             visitedNodes++;
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int adjNode = iter.getAdjNode();
                 int prevEdgeId = edgeIds[adjNode];
                 if (!accept(iter, prevEdgeId))
@@ -171,16 +158,14 @@ public int findEndNode( int from, int to )
                     continue;
 
                 double w = weights[adjNode];
-                if (w == Double.MAX_VALUE)
-                {
+                if (w == Double.MAX_VALUE) {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
                     heap.insert_(tmpWeight, adjNode);
                     changedNodes.add(adjNode);
                     edgeIds[adjNode] = iter.getEdge();
 
-                } else if (w > tmpWeight)
-                {
+                } else if (w > tmpWeight) {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
                     heap.update_(tmpWeight, adjNode);
@@ -202,23 +187,19 @@ public int findEndNode( int from, int to )
     }
 
     @Override
-    public boolean finished()
-    {
+    public boolean finished() {
         return currNode == to;
     }
 
-    public void setWeightLimit( double weightLimit )
-    {
+    public void setWeightLimit(double weightLimit) {
         this.weightLimit = weightLimit;
     }
 
-    protected boolean isWeightLimitExceeded()
-    {
+    protected boolean isWeightLimitExceeded() {
         return weights[currNode] > weightLimit;
     }
 
-    public void close()
-    {
+    public void close() {
         weights = null;
         parents = null;
         edgeIds = null;
@@ -226,22 +207,19 @@ public void close()
     }
 
     @Override
-    public int getVisitedNodes()
-    {
+    public int getVisitedNodes() {
         return visitedNodes;
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return Parameters.Algorithms.DIJKSTRA_ONE_TO_MANY;
     }
 
     /**
      * List currently used memory in MB (approximately)
      */
-    public String getMemoryUsageAsString()
-    {
+    public String getMemoryUsageAsString() {
         long len = weights.length;
         return ((8L + 4L + 4L) * len
                 + changedNodes.getCapacity() * 4L
@@ -249,14 +227,11 @@ public String getMemoryUsageAsString()
                 + "MB";
     }
 
-    private static class TIntArrayListWithCap extends TIntArrayList
-    {
-        public TIntArrayListWithCap()
-        {
+    private static class TIntArrayListWithCap extends TIntArrayList {
+        public TIntArrayListWithCap() {
         }
 
-        public int getCapacity()
-        {
+        public int getCapacity() {
             return _data.length;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 972d87bb4f..52332845ae 100755
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -19,9 +19,10 @@
 
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
@@ -35,47 +36,47 @@
  * edge determination faster and less complex as there could be several edges (u,v) especially for
  * graphs with shortcuts.
  * <p>
+ *
  * @author Peter Karich
  * @author Ottavio Campana
  * @author jan soe
  */
-public class Path
-{
+public class Path {
     private static final AngleCalc AC = Helper.ANGLE_CALC;
-    private List<String> description;
+    final StopWatch extractSW = new StopWatch("extract");
     protected Graph graph;
-    private FlagEncoder encoder;
     protected double distance;
     // we go upwards (via SPTEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
     protected long time;
-    private boolean found;
     /**
      * Shortest path tree entry
      */
     protected SPTEntry sptEntry;
-    final StopWatch extractSW = new StopWatch("extract");
-    private int fromNode = -1;
     protected int endNode = -1;
+    private List<String> description;
+    protected Weighting weighting;
+    private FlagEncoder encoder;
+    private boolean found;
+    private int fromNode = -1;
     private TIntList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
 
-    public Path( Graph graph, FlagEncoder encoder )
-    {
+    public Path(Graph graph, Weighting weighting) {
         this.weight = Double.MAX_VALUE;
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.encoder = encoder;
+        this.weighting = weighting;
+        this.encoder = weighting.getFlagEncoder();
         this.edgeIds = new TIntArrayList();
     }
 
     /**
      * Populates an unextracted path instances from the specified path p.
      */
-    Path( Path p )
-    {
-        this(p.graph, p.encoder);
+    Path(Path p) {
+        this(p.graph, p.weighting);
         weight = p.weight;
         edgeIds = new TIntArrayList(p.edgeIds);
         sptEntry = p.sptEntry;
@@ -85,69 +86,63 @@ public Path( Graph graph, FlagEncoder encoder )
      * @return the description of this route alternative to make it meaningful for the user e.g. it
      * displays one or two main roads of the route.
      */
-    public List<String> getDescription()
-    {
+    public List<String> getDescription() {
         if (description == null)
             return Collections.emptyList();
         return description;
     }
 
-    public Path setDescription( List<String> description )
-    {
+    public Path setDescription(List<String> description) {
         this.description = description;
         return this;
     }
 
-    public Path setSPTEntry( SPTEntry sptEntry )
-    {
+    public Path setSPTEntry(SPTEntry sptEntry) {
         this.sptEntry = sptEntry;
         return this;
     }
 
-    protected void addEdge( int edge )
-    {
+    protected void addEdge(int edge) {
         edgeIds.add(edge);
     }
 
-    protected Path setEndNode( int end )
-    {
+    protected Path setEndNode(int end) {
         endNode = end;
         return this;
     }
 
-    /**
-     * We need to remember fromNode explicitly as its not saved in one edgeId of edgeIds.
-     */
-    protected Path setFromNode( int from )
-    {
-        fromNode = from;
-        return this;
-    }
-
     /**
      * @return the first node of this Path.
      */
-    private int getFromNode()
-    {
+    private int getFromNode() {
         if (fromNode < 0)
             throw new IllegalStateException("Call extract() before retrieving fromNode");
 
         return fromNode;
     }
 
-    public boolean isFound()
-    {
+    /**
+     * We need to remember fromNode explicitly as its not saved in one edgeId of edgeIds.
+     */
+    protected Path setFromNode(int from) {
+        fromNode = from;
+        return this;
+    }
+
+    public int getEdgeCount() {
+        return edgeIds.size();
+    }
+
+    public boolean isFound() {
         return found;
     }
 
-    public Path setFound( boolean found )
-    {
+    public Path setFound(boolean found) {
         this.found = found;
         return this;
     }
 
-    void reverseOrder()
-    {
+    void reverseOrder() {
         if (!reverseOrder)
             throw new IllegalStateException("Switching order multiple times is not supported");
 
@@ -155,32 +150,33 @@ void reverseOrder()
         edgeIds.reverse();
     }
 
+    public Path setDistance(double distance) {
+        this.distance = distance;
+        return this;
+    }
+
     /**
      * @return distance in meter
      */
-    public double getDistance()
-    {
+    public double getDistance() {
         return distance;
     }
 
     /**
      * @return time in millis
      */
-    public long getTime()
-    {
+    public long getTime() {
         return time;
     }
 
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
-    public double getWeight()
-    {
+    public double getWeight() {
         return weight;
     }
 
-    public Path setWeight( double w )
-    {
+    public Path setWeight(double w) {
         this.weight = w;
         return this;
     }
@@ -188,17 +184,17 @@ public Path setWeight( double w )
     /**
      * Extracts the Path from the shortest-path-tree determined by sptEntry.
      */
-    public Path extract()
-    {
+    public Path extract() {
         if (isFound())
             throw new IllegalStateException("Extract can only be called once");
 
         extractSW.start();
         SPTEntry goalEdge = sptEntry;
+        int prevEdge = EdgeIterator.NO_EDGE;
         setEndNode(goalEdge.adjNode);
-        while (EdgeIterator.Edge.isValid(goalEdge.edge))
-        {
-            processEdge(goalEdge.edge, goalEdge.adjNode);
+        while (EdgeIterator.Edge.isValid(goalEdge.edge)) {
+            processEdge(goalEdge.edge, goalEdge.adjNode, prevEdge);
+            prevEdge = goalEdge.edge;
             goalEdge = goalEdge.parent;
         }
 
@@ -211,78 +207,53 @@ public Path extract()
     /**
      * Yields the final edge of the path
      */
-    public EdgeIteratorState getFinalEdge()
-    {
+    public EdgeIteratorState getFinalEdge() {
         return graph.getEdgeIteratorState(edgeIds.get(edgeIds.size() - 1), endNode);
     }
 
     /**
      * @return the time it took to extract the path in nano (!) seconds
      */
-    public long getExtractTime()
-    {
+    public long getExtractTime() {
         return extractSW.getNanos();
     }
 
-    public String getDebugInfo()
-    {
+    public String getDebugInfo() {
         return extractSW.toString();
     }
 
     /**
      * Calls getDistance and adds the edgeId.
      */
-    protected void processEdge( int edgeId, int adjNode )
-    {
+    protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
-        double dist = iter.getDistance();
-        distance += dist;
-        time += calcMillis(dist, iter.getFlags(), false);
+        distance += iter.getDistance();
+        time += weighting.calcMillis(iter, false, prevEdgeId);
         addEdge(edgeId);
     }
 
     /**
      * Calculates the time in millis for the specified distance in meter and speed (in km/h) via
      * flags.
+     *
+     * @deprecated use Weighting
      */
-    protected long calcMillis( double distance, long flags, boolean revert )
-    {
-        if (revert && !encoder.isBackward(flags)
-                || !revert && !encoder.isForward(flags))
-            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
-                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
-
-        double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
-        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
-            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
-
-        if (speed == 0)
-            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
-
-        return (long) (distance * 3600 / speed);
-    }
-
-    /**
-     * The callback used in forEveryEdge.
-     */
-    private static interface EdgeVisitor
-    {
-        void next( EdgeIteratorState edgeBase, int index );
+    protected long calcMillis(EdgeIteratorState edge, boolean reverse) {
+        return weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
     }
 
     /**
      * Iterates over all edges in this path sorted from start to end and calls the visitor callback
      * for every edge.
      * <p>
+     *
      * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
-     * be stored.
+     *                be stored.
      */
-    private void forEveryEdge( EdgeVisitor visitor )
-    {
+    private void forEveryEdge(EdgeVisitor visitor) {
         int tmpNode = getFromNode();
         int len = edgeIds.size();
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             EdgeIteratorState edgeBase = graph.getEdgeIteratorState(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
                 throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode
@@ -298,17 +269,14 @@ private void forEveryEdge( EdgeVisitor visitor )
     /**
      * Returns the list of all edges.
      */
-    public List<EdgeIteratorState> calcEdges()
-    {
+    public List<EdgeIteratorState> calcEdges() {
         final List<EdgeIteratorState> edges = new ArrayList<EdgeIteratorState>(edgeIds.size());
         if (edgeIds.isEmpty())
             return edges;
 
-        forEveryEdge(new EdgeVisitor()
-        {
+        forEveryEdge(new EdgeVisitor() {
             @Override
-            public void next( EdgeIteratorState eb, int i )
-            {
+            public void next(EdgeIteratorState eb, int i) {
                 edges.add(eb);
             }
         });
@@ -318,13 +286,10 @@ public void next( EdgeIteratorState eb, int i )
     /**
      * @return the uncached node indices of the tower nodes in this path.
      */
-    public TIntList calcNodes()
-    {
+    public TIntList calcNodes() {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
-        if (edgeIds.isEmpty())
-        {
-            if (isFound())
-            {
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
                 nodes.add(endNode);
             }
             return nodes;
@@ -332,11 +297,9 @@ public TIntList calcNodes()
 
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
-        forEveryEdge(new EdgeVisitor()
-        {
+        forEveryEdge(new EdgeVisitor() {
             @Override
-            public void next( EdgeIteratorState eb, int i )
-            {
+            public void next(EdgeIteratorState eb, int i) {
                 nodes.add(eb.getAdjNode());
             }
         });
@@ -346,15 +309,13 @@ public void next( EdgeIteratorState eb, int i )
     /**
      * This method calculated a list of points for this path
      * <p>
+     *
      * @return this path its geometry
      */
-    public PointList calcPoints()
-    {
+    public PointList calcPoints() {
         final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
-        if (edgeIds.isEmpty())
-        {
-            if (isFound())
-            {
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
                 points.add(graph.getNodeAccess(), endNode);
             }
             return points;
@@ -362,14 +323,11 @@ public PointList calcPoints()
 
         int tmpNode = getFromNode();
         points.add(nodeAccess, tmpNode);
-        forEveryEdge(new EdgeVisitor()
-        {
+        forEveryEdge(new EdgeVisitor() {
             @Override
-            public void next( EdgeIteratorState eb, int index )
-            {
+            public void next(EdgeIteratorState eb, int index) {
                 PointList pl = eb.fetchWayGeometry(2);
-                for (int j = 0; j < pl.getSize(); j++)
-                {
+                for (int j = 0; j < pl.getSize(); j++) {
                     points.add(pl, j);
                 }
             }
@@ -380,21 +338,17 @@ public void next( EdgeIteratorState eb, int index )
     /**
      * @return the list of instructions for this path.
      */
-    public InstructionList calcInstructions( final Translation tr )
-    {
+    public InstructionList calcInstructions(final Translation tr) {
         final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
-        if (edgeIds.isEmpty())
-        {
-            if (isFound())
-            {
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
                 ways.add(new FinishInstruction(nodeAccess, endNode));
             }
             return ways;
         }
 
         final int tmpNode = getFromNode();
-        forEveryEdge(new EdgeVisitor()
-        {
+        forEveryEdge(new EdgeVisitor() {
             /*
              * We need three points to make directions
              *
@@ -427,8 +381,7 @@ public InstructionList calcInstructions( final Translation tr )
             private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
-            public void next( EdgeIteratorState edge, int index )
-            {
+            public void next(EdgeIteratorState edge, int index) {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
                 int baseNode = edge.getBaseNode();
@@ -440,12 +393,10 @@ public void next( EdgeIteratorState edge, int index )
                 PointList wayGeo = edge.fetchWayGeometry(3);
                 boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
 
-                if (wayGeo.getSize() <= 2)
-                {
+                if (wayGeo.getSize() <= 2) {
                     latitude = adjLat;
                     longitude = adjLon;
-                } else
-                {
+                } else {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
                     assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
@@ -463,23 +414,19 @@ public void next( EdgeIteratorState edge, int index )
                     prevName = name;
                     prevAnnotation = annotation;
 
-                } else if (isRoundabout)
-                // remark: names and annotations within roundabout are ignored
-                {
+                } else if (isRoundabout) {
+                    // remark: names and annotations within roundabout are ignored
                     if (!prevInRoundabout) //just entered roundabout
                     {
                         int sign = Instruction.USE_ROUNDABOUT;
                         RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
                                 annotation, new PointList(10, nodeAccess.is3D()));
-                        if (prevName != null)
-                        {
+                        if (prevName != null) {
                             // check if there is an exit at the same node the roundabout was entered
                             EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
-                            while (edgeIter.next())
-                            {
+                            while (edgeIter.next()) {
                                 if ((edgeIter.getAdjNode() != prevNode)
-                                        && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
-                                {
+                                        && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
                                     roundaboutInstruction.increaseExitNumber();
                                     break;
                                 }
@@ -508,10 +455,8 @@ public void next( EdgeIteratorState edge, int index )
                     // Add passed exits to instruction. A node is counted if there is at least one outgoing edge
                     // out of the roundabout
                     EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
-                    while (edgeIter.next())
-                    {
-                        if (!encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
-                        {
+                    while (edgeIter.next()) {
+                        if (!encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
                             ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
                             break;
                         }
@@ -541,8 +486,7 @@ public void next( EdgeIteratorState edge, int index )
                     prevName = name;
                     prevAnnotation = annotation;
 
-                } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
-                {
+                } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation))) {
                     prevOrientation = AC.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                     double orientation = AC.calcOrientation(prevLat, prevLon, latitude, longitude);
                     orientation = AC.alignOrientation(prevOrientation, orientation);
@@ -550,21 +494,18 @@ public void next( EdgeIteratorState edge, int index )
                     double absDelta = Math.abs(delta);
                     int sign;
 
-                    if (absDelta < 0.2)
-                    {
+                    if (absDelta < 0.2) {
                         // 0.2 ~= 11°
                         sign = Instruction.CONTINUE_ON_STREET;
 
-                    } else if (absDelta < 0.8)
-                    {
+                    } else if (absDelta < 0.8) {
                         // 0.8 ~= 40°
                         if (delta > 0)
                             sign = Instruction.TURN_SLIGHT_LEFT;
                         else
                             sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                    } else if (absDelta < 1.8)
-                    {
+                    } else if (absDelta < 1.8) {
                         // 1.8 ~= 103°
                         if (delta > 0)
                             sign = Instruction.TURN_LEFT;
@@ -583,12 +524,10 @@ public void next( EdgeIteratorState edge, int index )
 
                 updatePointsAndInstruction(edge, wayGeo);
 
-                if (wayGeo.getSize() <= 2)
-                {
+                if (wayGeo.getSize() <= 2) {
                     doublePrevLat = prevLat;
                     doublePrevLong = prevLon;
-                } else
-                {
+                } else {
                     int beforeLast = wayGeo.getSize() - 2;
                     doublePrevLat = wayGeo.getLatitude(beforeLast);
                     doublePrevLong = wayGeo.getLongitude(beforeLast);
@@ -600,10 +539,8 @@ public void next( EdgeIteratorState edge, int index )
                 prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
-                if (lastEdge)
-                {
-                    if (isRoundabout)
-                    {
+                if (lastEdge) {
+                    if (isRoundabout) {
                         // calc angle between roundabout entrance and finish
                         double orientation = AC.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                         orientation = AC.alignOrientation(prevOrientation, orientation);
@@ -615,18 +552,16 @@ public void next( EdgeIteratorState edge, int index )
                 }
             }
 
-            private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
-            {
+            private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
                 // skip adjNode
                 int len = pl.size() - 1;
-                for (int i = 0; i < len; i++)
-                {
+                for (int i = 0; i < len; i++) {
                     prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
-                long flags = edge.getFlags();
-                prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
+                prevInstruction.setTime(weighting.calcMillis(edge, false, EdgeIterator.NO_EDGE)
+                        + prevInstruction.getTime());
             }
         });
 
@@ -634,16 +569,13 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "distance:" + getDistance() + ", edges:" + edgeIds.size();
     }
 
-    public String toDetailsString()
-    {
+    public String toDetailsString() {
         String str = "";
-        for (int i = 0; i < edgeIds.size(); i++)
-        {
+        for (int i = 0; i < edgeIds.size(); i++) {
             if (i > 0)
                 str += "->";
 
@@ -651,4 +583,11 @@ public String toDetailsString()
         }
         return toString() + ", found:" + isFound() + ", " + str;
     }
+
+    /**
+     * The callback used in forEveryEdge.
+     */
+    private static interface EdgeVisitor {
+        void next(EdgeIteratorState edgeBase, int index);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 5bfb551c5b..4f7c162dbb 100755
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -18,40 +18,37 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIterator;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
  * <p>
+ *
  * @author Peter Karich
  */
-public class PathBidirRef extends Path
-{
+public class PathBidirRef extends Path {
     protected SPTEntry edgeTo;
     private boolean switchWrapper = false;
 
-    public PathBidirRef( Graph g, FlagEncoder encoder )
-    {
-        super(g, encoder);
+    public PathBidirRef(Graph g, Weighting weighting) {
+        super(g, weighting);
     }
 
-    PathBidirRef( PathBidirRef p )
-    {
+    PathBidirRef(PathBidirRef p) {
         super(p);
         edgeTo = p.edgeTo;
         switchWrapper = p.switchWrapper;
     }
 
-    public PathBidirRef setSwitchToFrom( boolean b )
-    {
+    public PathBidirRef setSwitchToFrom(boolean b) {
         switchWrapper = b;
         return this;
     }
 
-    public PathBidirRef setSPTEntryTo( SPTEntry edgeTo )
-    {
+    public PathBidirRef setSPTEntryTo(SPTEntry edgeTo) {
         this.edgeTo = edgeTo;
         return this;
     }
@@ -60,8 +57,7 @@ public PathBidirRef setSPTEntryTo( SPTEntry edgeTo )
      * Extracts path from two shortest-path-tree
      */
     @Override
-    public Path extract()
-    {
+    public Path extract() {
         if (sptEntry == null || edgeTo == null)
             return this;
 
@@ -69,27 +65,26 @@ public Path extract()
             throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + sptEntry + ", toEntry:" + edgeTo);
 
         extractSW.start();
-        if (switchWrapper)
-        {
+        if (switchWrapper) {
             SPTEntry ee = sptEntry;
             sptEntry = edgeTo;
             edgeTo = ee;
         }
 
+        int prevEdge = EdgeIterator.NO_EDGE;
         SPTEntry currEdge = sptEntry;
-        while (EdgeIterator.Edge.isValid(currEdge.edge))
-        {
-            processEdge(currEdge.edge, currEdge.adjNode);
+        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
+            processEdge(currEdge.edge, currEdge.adjNode, prevEdge);
+            prevEdge = currEdge.edge;
             currEdge = currEdge.parent;
         }
         setFromNode(currEdge.adjNode);
         reverseOrder();
         currEdge = edgeTo;
         int tmpEdge = currEdge.edge;
-        while (EdgeIterator.Edge.isValid(tmpEdge))
-        {
+        while (EdgeIterator.Edge.isValid(tmpEdge)) {
             currEdge = currEdge.parent;
-            processEdge(tmpEdge, currEdge.adjNode);
+            processEdge(tmpEdge, currEdge.adjNode, currEdge.edge);
             tmpEdge = currEdge.edge;
         }
         setEndNode(currEdge.adjNode);
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
index 6fbe9e1613..9df6a3c8ed 100755
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ b/core/src/main/java/com/graphhopper/routing/PathNative.java
@@ -18,22 +18,22 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
 
 /**
  * This class creates a Path from a DijkstraOneToMany node
  * <p>
+ *
  * @author Peter Karich
  */
-public class PathNative extends Path
-{
+public class PathNative extends Path {
     private final int[] parentNodes;
     private final int[] parentEdges;
 
-    public PathNative( Graph g, FlagEncoder encoder, int[] parentNodes, int[] parentEdges )
-    {
-        super(g, encoder);
+    public PathNative(Graph g, Weighting weighting, int[] parentNodes, int[] parentEdges) {
+        super(g, weighting);
         this.parentNodes = parentNodes;
         this.parentEdges = parentEdges;
     }
@@ -42,18 +42,18 @@ public PathNative( Graph g, FlagEncoder encoder, int[] parentNodes, int[] parent
      * Extracts path from two shortest-path-tree
      */
     @Override
-    public Path extract()
-    {
+    public Path extract() {
         if (endNode < 0)
             return this;
-
-        while (true)
-        {
+        
+        int prevEdge = EdgeIterator.NO_EDGE;        
+        while (true) {
             int edgeId = parentEdges[endNode];
             if (!EdgeIterator.Edge.isValid(edgeId))
                 break;
 
-            processEdge(edgeId, endNode);
+            processEdge(edgeId, endNode, prevEdge);
+            prevEdge = edgeId;
             endNode = parentNodes[endNode];
         }
         reverseOrder();
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ebb8f61c53..4acb3453f8 100755
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -20,7 +20,10 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -43,35 +46,105 @@
  *
  * @author Peter Karich
  */
-public class QueryGraph implements Graph
-{
+public class QueryGraph implements Graph {
+    final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
+    private static final AngleCalc AC = Helper.ANGLE_CALC;
     private final Graph mainGraph;
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
     private final QueryGraph baseGraph;
     private final GraphExtension wrappedExtension;
-    private List<QueryResult> queryResults;
+    // TODO when spreading it on different threads we need multiple independent explorers
+    private final Map<Integer, EdgeExplorer> cacheMap = new HashMap<Integer, EdgeExplorer>(4);
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
      * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
     List<VirtualEdgeIteratorState> virtualEdges;
-    final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
-
+    private List<QueryResult> queryResults;
     /**
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private static final AngleCalc AC = Helper.ANGLE_CALC;
-    private List<VirtualEdgeIteratorState> modifiedEdges = new ArrayList<VirtualEdgeIteratorState>(5);
+    private final NodeAccess nodeAccess = new NodeAccess() {
+        @Override
+        public void ensureNode(int nodeId) {
+            mainNodeAccess.ensureNode(nodeId);
+        }
 
-    // TODO when spreading it on different threads we need multiple independent explorers
-    private final Map<Integer, EdgeExplorer> cacheMap = new HashMap<Integer, EdgeExplorer>(4);
+        @Override
+        public boolean is3D() {
+            return mainNodeAccess.is3D();
+        }
+
+        @Override
+        public int getDimension() {
+            return mainNodeAccess.getDimension();
+        }
+
+        @Override
+        public double getLatitude(int nodeId) {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getLatitude(nodeId - mainNodes);
+            return mainNodeAccess.getLatitude(nodeId);
+        }
+
+        @Override
+        public double getLongitude(int nodeId) {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getLongitude(nodeId - mainNodes);
+            return mainNodeAccess.getLongitude(nodeId);
+        }
+
+        @Override
+        public double getElevation(int nodeId) {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getElevation(nodeId - mainNodes);
+            return mainNodeAccess.getElevation(nodeId);
+        }
+
+        @Override
+        public int getAdditionalNodeField(int nodeId) {
+            if (isVirtualNode(nodeId))
+                return 0;
+            return mainNodeAccess.getAdditionalNodeField(nodeId);
+        }
+
+        @Override
+        public void setNode(int nodeId, double lat, double lon) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public void setNode(int nodeId, double lat, double lon, double ele) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public void setAdditionalNodeField(int nodeId, int additionalValue) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public double getLat(int nodeId) {
+            return getLatitude(nodeId);
+        }
+
+        @Override
+        public double getLon(int nodeId) {
+            return getLongitude(nodeId);
+        }
+
+        @Override
+        public double getEle(int nodeId) {
+            return getElevation(nodeId);
+        }
+    };
+    private List<VirtualEdgeIteratorState> modifiedEdges = new ArrayList<VirtualEdgeIteratorState>(5);
     private boolean useEdgeExplorerCache = false;
 
-    public QueryGraph( Graph graph )
-    {
+    public QueryGraph(Graph graph) {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
@@ -83,12 +156,10 @@ public QueryGraph( Graph graph )
             wrappedExtension = mainGraph.getExtension();
 
         // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
-        baseGraph = new QueryGraph(graph.getBaseGraph(), this)
-        {
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this) {
             // override method to avoid stackoverflow
             @Override
-            public QueryGraph setUseEdgeExplorerCache( boolean useEECache )
-            {
+            public QueryGraph setUseEdgeExplorerCache(boolean useEECache) {
                 baseGraph.useEdgeExplorerCache = useEECache;
                 return baseGraph;
             }
@@ -98,8 +169,7 @@ public QueryGraph setUseEdgeExplorerCache( boolean useEECache )
     /**
      * See 'lookup' for further variables that are initialized
      */
-    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
-    {
+    private QueryGraph(Graph graph, QueryGraph superQueryGraph) {
         mainGraph = graph;
         baseGraph = this;
         wrappedExtension = superQueryGraph.wrappedExtension;
@@ -111,8 +181,7 @@ private QueryGraph( Graph graph, QueryGraph superQueryGraph )
     /**
      * Convenient method to initialize this QueryGraph with the two specified query results.
      */
-    public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
-    {
+    public QueryGraph lookup(QueryResult fromRes, QueryResult toRes) {
         List<QueryResult> results = new ArrayList<QueryResult>(2);
         results.add(fromRes);
         results.add(toRes);
@@ -124,8 +193,7 @@ public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
      * For all specified query results calculate snapped point and set closest node and edge to a
      * virtual one if necessary. Additionally the wayIndex can change if an edge is swapped.
      */
-    public void lookup( List<QueryResult> resList )
-    {
+    public void lookup(List<QueryResult> resList) {
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
@@ -141,8 +209,7 @@ public void lookup( List<QueryResult> resList )
 
         // Phase 1
         // calculate snapped point and swap direction of closest edge if necessary
-        for (QueryResult res : resList)
-        {
+        for (QueryResult res : resList) {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
             if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
@@ -153,24 +220,22 @@ public void lookup( List<QueryResult> resList )
 
             int base = closestEdge.getBaseNode();
 
-            // Force the identical direction for all closest edges. 
+            // Force the identical direction for all closest edges.
             // It is important to sort multiple results for the same edge by its wayIndex
             boolean doReverse = base > closestEdge.getAdjNode();
-            if (base == closestEdge.getAdjNode())
-            {
+            if (base == closestEdge.getAdjNode()) {
                 // check for special case #162 where adj == base and force direction via latitude comparison
                 PointList pl = closestEdge.fetchWayGeometry(0);
                 if (pl.size() > 1)
                     doReverse = pl.getLatitude(0) > pl.getLatitude(pl.size() - 1);
             }
 
-            if (doReverse)
-            {
+            if (doReverse) {
                 closestEdge = closestEdge.detach(true);
                 PointList fullPL = closestEdge.fetchWayGeometry(3);
                 res.setClosestEdge(closestEdge);
                 if (res.getSnappedPosition() == QueryResult.Position.PILLAR)
-                    // ON pillar node                
+                    // ON pillar node
                     res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 1);
                 else
                     // for case "OFF pillar node"
@@ -183,8 +248,7 @@ public void lookup( List<QueryResult> resList )
             // find multiple results on same edge
             int edgeId = closestEdge.getEdge();
             List<QueryResult> list = edge2res.get(edgeId);
-            if (list == null)
-            {
+            if (list == null) {
                 list = new ArrayList<QueryResult>(5);
                 edge2res.put(edgeId, list);
             }
@@ -194,24 +258,19 @@ public void lookup( List<QueryResult> resList )
         // Phase 2 - now it is clear which points cut one edge
         // 1. create point lists
         // 2. create virtual edges between virtual nodes and its neighbor (virtual or normal nodes)
-        edge2res.forEachValue(new TObjectProcedure<List<QueryResult>>()
-        {
+        edge2res.forEachValue(new TObjectProcedure<List<QueryResult>>() {
             @Override
-            public boolean execute( List<QueryResult> results )
-            {
+            public boolean execute(List<QueryResult> results) {
                 // we can expect at least one entry in the results
                 EdgeIteratorState closestEdge = results.get(0).getClosestEdge();
                 final PointList fullPL = closestEdge.fetchWayGeometry(3);
                 int baseNode = closestEdge.getBaseNode();
                 // sort results on the same edge by the wayIndex and if equal by distance to pillar node
-                Collections.sort(results, new Comparator<QueryResult>()
-                {
+                Collections.sort(results, new Comparator<QueryResult>() {
                     @Override
-                    public int compare( QueryResult o1, QueryResult o2 )
-                    {
+                    public int compare(QueryResult o1, QueryResult o2) {
                         int diff = o1.getWayIndex() - o2.getWayIndex();
-                        if (diff == 0)
-                        {
+                        if (diff == 0) {
                             // sort by distance from snappedPoint to fullPL.get(wayIndex) if wayIndex is identical
                             GHPoint p1 = o1.getSnappedPoint();
                             GHPoint p2 = o2.getSnappedPoint();
@@ -240,10 +299,9 @@ public int compare( QueryResult o1, QueryResult o2 )
                 boolean addedEdges = false;
 
                 // Create base and adjacent PointLists for all none-equal virtual nodes.
-                // We do so via inserting them at the correct position of fullPL and cutting the                
+                // We do so via inserting them at the correct position of fullPL and cutting the
                 // fullPL into the right pieces.
-                for (int counter = 0; counter < results.size(); counter++)
-                {
+                for (int counter = 0; counter < results.size(); counter++) {
                     QueryResult res = results.get(counter);
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
@@ -251,8 +309,7 @@ public int compare( QueryResult o1, QueryResult o2 )
                     GHPoint3D currSnapped = res.getSnappedPoint();
 
                     // no new virtual nodes if exactly the same snapped point
-                    if (prevPoint.equals(currSnapped))
-                    {
+                    if (prevPoint.equals(currSnapped)) {
                         res.setClosestNode(prevNodeId);
                         continue;
                     }
@@ -266,8 +323,7 @@ public int compare( QueryResult o1, QueryResult o2 )
                     virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
                     // add edges again to set adjacent edges for newVirtNodeId
-                    if (addedEdges)
-                    {
+                    if (addedEdges) {
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                     }
@@ -293,21 +349,18 @@ public int compare( QueryResult o1, QueryResult o2 )
     }
 
     @Override
-    public Graph getBaseGraph()
-    {
-        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a 
+    public Graph getBaseGraph() {
+        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a
         // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
-        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.
         return baseGraph;
     }
 
-    public boolean isVirtualEdge( int edgeId )
-    {
+    public boolean isVirtualEdge(int edgeId) {
         return edgeId >= mainEdges;
     }
 
-    public boolean isVirtualNode( int nodeId )
-    {
+    public boolean isVirtualNode(int nodeId) {
         return nodeId >= mainNodes;
     }
 
@@ -319,58 +372,21 @@ public boolean isVirtualNode( int nodeId )
      * Currently we can cache only the ALL_EDGES filter or instances of the DefaultEdgeFilter where
      * three edge explorers will be created: forward OR backward OR both.
      */
-    public QueryGraph setUseEdgeExplorerCache( boolean useEECache )
-    {
+    public QueryGraph setUseEdgeExplorerCache(boolean useEECache) {
         this.useEdgeExplorerCache = useEECache;
         this.baseGraph.setUseEdgeExplorerCache(useEECache);
         return this;
     }
 
-    class QueryGraphTurnExt extends TurnCostExtension
-    {
-        private final TurnCostExtension mainTurnExtension;
-
-        public QueryGraphTurnExt()
-        {
-            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
-        }
-
-        @Override
-        public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
-        {
-            if (isVirtualNode(nodeVia))
-            {
-                return 0;
-            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo))
-            {
-                if (isVirtualEdge(edgeFrom))
-                {
-                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
-                }
-                if (isVirtualEdge(edgeTo))
-                {
-                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
-                }
-                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
-
-            } else
-            {
-                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
-            }
-        }
-    }
-
-    private void createEdges( int origTraversalKey, int origRevTraversalKey,
-                              GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
-                              PointList fullPL, EdgeIteratorState closestEdge,
-                              int prevNodeId, int nodeId, long reverseFlags )
-    {
+    private void createEdges(int origTraversalKey, int origRevTraversalKey,
+                             GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+                             PointList fullPL, EdgeIteratorState closestEdge,
+                             int prevNodeId, int nodeId, long reverseFlags) {
         int max = wayIndex + 1;
         // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
         PointList basePoints = new PointList(max - prevWayIndex + 1, mainNodeAccess.is3D());
         basePoints.add(prevSnapped.lat, prevSnapped.lon, prevSnapped.ele);
-        for (int i = prevWayIndex; i < max; i++)
-        {
+        for (int i = prevWayIndex; i < max; i++) {
             basePoints.add(fullPL, i);
         }
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
@@ -390,15 +406,16 @@ private void createEdges( int origTraversalKey, int origRevTraversalKey,
     }
 
     /**
-     * set edges at virtual node unfavored which require at least a turn of 100° from favoredHeading
+     * Set those edges at the virtual node (nodeId) to 'unfavored' that require at least a turn of
+     * 100° from favoredHeading
      * <p>
-     * @param nodeId VirtualNode at which edges get unfavored
+     *
+     * @param nodeId         VirtualNode at which edges get unfavored
      * @param favoredHeading north based azimuth of favored heading between 0 and 360
-     * @param incoming if true, incoming edges are unfavored, else outgoing edges
+     * @param incoming       if true, incoming edges are unfavored, else outgoing edges
      * @return boolean indicating if enforcement took place
      */
-    public boolean enforceHeading( int nodeId, double favoredHeading, boolean incoming )
-    {
+    public boolean enforceHeading(int nodeId, double favoredHeading, boolean incoming) {
         if (!isInitialized())
             throw new IllegalStateException("QueryGraph.lookup has to be called in before heading enforcement");
 
@@ -414,19 +431,16 @@ public boolean enforceHeading( int nodeId, double favoredHeading, boolean incomi
         // either penalize incoming or outgoing edges
         List<Integer> edgePositions = incoming ? Arrays.asList(VE_BASE, VE_ADJ_REV) : Arrays.asList(VE_BASE_REV, VE_ADJ);
         boolean enforcementOccurred = false;
-        for (int edgePos : edgePositions)
-        {
+        for (int edgePos : edgePositions) {
             VirtualEdgeIteratorState edge = virtualEdges.get(virtNodeIDintern * 4 + edgePos);
 
             PointList wayGeo = edge.fetchWayGeometry(3);
             double edgeOrientation;
-            if (incoming)
-            {
+            if (incoming) {
                 int numWayPoints = wayGeo.getSize();
                 edgeOrientation = AC.calcOrientation(wayGeo.getLat(numWayPoints - 2), wayGeo.getLon(numWayPoints - 2),
                         wayGeo.getLat(numWayPoints - 1), wayGeo.getLon(numWayPoints - 1));
-            } else
-            {
+            } else {
                 edgeOrientation = AC.calcOrientation(wayGeo.getLat(0), wayGeo.getLon(0),
                         wayGeo.getLat(1), wayGeo.getLon(1));
             }
@@ -436,11 +450,11 @@ public boolean enforceHeading( int nodeId, double favoredHeading, boolean incomi
 
             if (Math.abs(delta) > 1.74) // penalize if a turn of more than 100°
             {
-                edge.setVirtualEdgePreference(true);
+                edge.setUnfavored(true);
                 modifiedEdges.add(edge);
                 //also apply to opposite edge for reverse routing
                 VirtualEdgeIteratorState reverseEdge = virtualEdges.get(virtNodeIDintern * 4 + getPosOfReverseEdge(edgePos));
-                reverseEdge.setVirtualEdgePreference(true);
+                reverseEdge.setUnfavored(true);
                 modifiedEdges.add(reverseEdge);
                 enforcementOccurred = true;
             }
@@ -450,148 +464,54 @@ public boolean enforceHeading( int nodeId, double favoredHeading, boolean incomi
     }
 
     /**
-     * set specific edge at virtual node unfavored, to enforce routing along other edges
+     * Set one specific edge at the virtual node with nodeId to 'unfavored' to enforce routing along
+     * other edges
      * <p>
-     * @param nodeId VirtualNode at which edges get unfavored
-     * @param edgeId edge to become unfavored
+     *
+     * @param nodeId   VirtualNode at which edges get unfavored
+     * @param edgeId   edge to become unfavored
      * @param incoming if true, incoming edge is unfavored, else outgoing edge
      * @return boolean indicating if enforcement took place
      */
-    public boolean enforceHeadingByEdgeId( int nodeId, int edgeId, boolean incoming )
-    {
+    public boolean enforceHeadingByEdgeId(int nodeId, int edgeId, boolean incoming) {
         if (!isVirtualNode(nodeId))
             return false;
 
         VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, nodeId);
         VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, incomingEdge.getBaseNode());
-        incomingEdge.setVirtualEdgePreference(true);
+        incomingEdge.setUnfavored(true);
         modifiedEdges.add(incomingEdge);
-        reverseEdge.setVirtualEdgePreference(true);
+        reverseEdge.setUnfavored(true);
         modifiedEdges.add(reverseEdge);
         return true;
     }
 
     /**
-     * removes the unfavored status of all virtual edges
+     * Removes the 'unfavored' status of all virtual edges.
      */
-    public void clearUnfavoredStatus()
-    {
-        for (VirtualEdgeIteratorState edge : modifiedEdges)
-        {
-            edge.setVirtualEdgePreference(false);
+    public void clearUnfavoredStatus() {
+        for (VirtualEdgeIteratorState edge : modifiedEdges) {
+            edge.setUnfavored(false);
         }
     }
 
     @Override
-    public int getNodes()
-    {
+    public int getNodes() {
         return virtualNodes.getSize() + mainNodes;
     }
 
     @Override
-    public NodeAccess getNodeAccess()
-    {
+    public NodeAccess getNodeAccess() {
         return nodeAccess;
     }
 
-    private final NodeAccess nodeAccess = new NodeAccess()
-    {
-        @Override
-        public void ensureNode( int nodeId )
-        {
-            mainNodeAccess.ensureNode(nodeId);
-        }
-
-        @Override
-        public boolean is3D()
-        {
-            return mainNodeAccess.is3D();
-        }
-
-        @Override
-        public int getDimension()
-        {
-            return mainNodeAccess.getDimension();
-        }
-
-        @Override
-        public double getLatitude( int nodeId )
-        {
-            if (isVirtualNode(nodeId))
-                return virtualNodes.getLatitude(nodeId - mainNodes);
-            return mainNodeAccess.getLatitude(nodeId);
-        }
-
-        @Override
-        public double getLongitude( int nodeId )
-        {
-            if (isVirtualNode(nodeId))
-                return virtualNodes.getLongitude(nodeId - mainNodes);
-            return mainNodeAccess.getLongitude(nodeId);
-        }
-
-        @Override
-        public double getElevation( int nodeId )
-        {
-            if (isVirtualNode(nodeId))
-                return virtualNodes.getElevation(nodeId - mainNodes);
-            return mainNodeAccess.getElevation(nodeId);
-        }
-
-        @Override
-        public int getAdditionalNodeField( int nodeId )
-        {
-            if (isVirtualNode(nodeId))
-                return 0;
-            return mainNodeAccess.getAdditionalNodeField(nodeId);
-        }
-
-        @Override
-        public void setNode( int nodeId, double lat, double lon )
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        @Override
-        public void setNode( int nodeId, double lat, double lon, double ele )
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        @Override
-        public void setAdditionalNodeField( int nodeId, int additionalValue )
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        @Override
-        public double getLat( int nodeId )
-        {
-            return getLatitude(nodeId);
-        }
-
-        @Override
-        public double getLon( int nodeId )
-        {
-            return getLongitude(nodeId);
-        }
-
-        @Override
-        public double getEle( int nodeId )
-        {
-            return getElevation(nodeId);
-        }
-    };
-
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return mainGraph.getBounds();
     }
 
     @Override
-    public EdgeIteratorState getEdgeIteratorState( int origEdgeId, int adjNode )
-    {
+    public EdgeIteratorState getEdgeIteratorState(int origEdgeId, int adjNode) {
         if (!isVirtualEdge(origEdgeId))
             return mainGraph.getEdgeIteratorState(origEdgeId, adjNode);
 
@@ -608,8 +528,7 @@ public EdgeIteratorState getEdgeIteratorState( int origEdgeId, int adjNode )
                 + ". found edges were:" + eis + ", " + eis2);
     }
 
-    private int getPosOfReverseEdge( int edgeId )
-    {
+    private int getPosOfReverseEdge(int edgeId) {
         // find reverse edge via convention. see virtualEdges comment above
         if (edgeId % 2 == 0)
             edgeId++;
@@ -620,16 +539,13 @@ private int getPosOfReverseEdge( int edgeId )
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
-    {
+    public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
         if (!isInitialized())
             throw new IllegalStateException("Call lookup before using this graph");
 
-        if (useEdgeExplorerCache)
-        {
+        if (useEdgeExplorerCache) {
             int counter = -1;
-            if (edgeFilter instanceof DefaultEdgeFilter)
-            {
+            if (edgeFilter instanceof DefaultEdgeFilter) {
                 DefaultEdgeFilter dee = (DefaultEdgeFilter) edgeFilter;
                 counter = 0;
                 if (dee.acceptsBackward())
@@ -640,16 +556,13 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
                 if (counter == 0)
                     throw new IllegalStateException("You tried to use an edge filter blocking every access");
 
-            } else if (edgeFilter == EdgeFilter.ALL_EDGES)
-            {
+            } else if (edgeFilter == EdgeFilter.ALL_EDGES) {
                 counter = 4;
             }
 
-            if (counter >= 0)
-            {
+            if (counter >= 0) {
                 EdgeExplorer cached = cacheMap.get(counter);
-                if (cached == null)
-                {
+                if (cached == null) {
                     cached = createUncachedEdgeExplorer(edgeFilter);
                     cacheMap.put(counter, cached);
                 }
@@ -659,8 +572,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
         return createUncachedEdgeExplorer(edgeFilter);
     }
 
-    private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
-    {
+    private EdgeExplorer createUncachedEdgeExplorer(EdgeFilter edgeFilter) {
         // Iteration over virtual nodes needs to be thread safe if done from different explorer
         // so we need to create the mapping on EVERY call!
         // This needs to be a HashMap (and cannot be an array) as we also need to tweak edges for some mainNodes!
@@ -671,9 +583,8 @@ private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
         final EdgeExplorer mainExplorer = mainGraph.createEdgeExplorer(edgeFilter);
         final TIntHashSet towerNodesToChange = new TIntHashSet(queryResults.size());
 
-        // 1. virtualEdges should also get fresh EdgeIterators on every createEdgeExplorer call!        
-        for (int i = 0; i < queryResults.size(); i++)
-        {
+        // 1. virtualEdges should also get fresh EdgeIterators on every createEdgeExplorer call!
+        for (int i = 0; i < queryResults.size(); i++) {
             // create outgoing edges
             VirtualEdgeIterator virtEdgeIter = new VirtualEdgeIterator(2);
             EdgeIteratorState baseRevEdge = virtualEdges.get(i * 4 + VE_BASE_REV);
@@ -686,21 +597,19 @@ private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
             int virtNode = mainNodes + i;
             node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: 
+            // replace edge list of neighboring tower nodes:
             // add virtual edges only and collect tower nodes where real edges will be added in step 2.
             //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (!isVirtualNode(towerNode))
-            {
+            if (!isVirtualNode(towerNode)) {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
             }
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (!isVirtualNode(towerNode))
-            {
+            if (!isVirtualNode(towerNode)) {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
             }
@@ -709,21 +618,17 @@ private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
         // 2. the connected tower nodes from mainGraph need fresh EdgeIterators with possible fakes
         // where 'fresh' means independent of previous call and respecting the edgeFilter
         // -> setup fake iterators of detected tower nodes (virtual edges are already added)
-        towerNodesToChange.forEach(new TIntProcedure()
-        {
+        towerNodesToChange.forEach(new TIntProcedure() {
             @Override
-            public boolean execute( int value )
-            {
+            public boolean execute(int value) {
                 fillVirtualEdges(node2EdgeMap, value, mainExplorer);
                 return true;
             }
         });
 
-        return new EdgeExplorer()
-        {
+        return new EdgeExplorer() {
             @Override
-            public EdgeIterator setBaseNode( int baseNode )
-            {
+            public EdgeIterator setBaseNode(int baseNode) {
                 VirtualEdgeIterator iter = node2EdgeMap.get(baseNode);
                 if (iter != null)
                     return iter.reset();
@@ -736,12 +641,10 @@ public EdgeIterator setBaseNode( int baseNode )
     /**
      * Creates a fake edge iterator pointing to multiple edge states.
      */
-    private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
-                                  int node, int virtNode )
-    {
+    private void addVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
+                                 int node, int virtNode) {
         VirtualEdgeIterator existingIter = node2EdgeMap.get(node);
-        if (existingIter == null)
-        {
+        if (existingIter == null) {
             existingIter = new VirtualEdgeIterator(10);
             node2EdgeMap.put(node, existingIter);
         }
@@ -752,75 +655,89 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
             existingIter.add(edge);
     }
 
-    void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
-    {
+    void fillVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl) {
         if (isVirtualNode(towerNode))
             throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
         TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
-        while (vIter.next())
-        {
+        while (vIter.next()) {
             EdgeIteratorState edge = queryResults.get(vIter.getAdjNode() - mainNodes).getClosestEdge();
             ignoreEdges.add(edge.getEdge());
         }
         vIter.reset();
         EdgeIterator iter = mainExpl.setBaseNode(towerNode);
-        while (iter.next())
-        {
+        while (iter.next()) {
             if (!ignoreEdges.contains(iter.getEdge()))
                 vIter.add(iter.detach(false));
         }
     }
 
-    private boolean isInitialized()
-    {
+    private boolean isInitialized() {
         return queryResults != null;
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer()
-    {
+    public EdgeExplorer createEdgeExplorer() {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
-    public AllEdgesIterator getAllEdges()
-    {
+    public AllEdgesIterator getAllEdges() {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b )
-    {
+    public EdgeIteratorState edge(int a, int b) {
         throw exc();
     }
 
-    public EdgeIteratorState edge( int a, int b, double distance, int flags )
-    {
+    public EdgeIteratorState edge(int a, int b, double distance, int flags) {
         throw exc();
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
-    {
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
         throw exc();
     }
 
     @Override
-    public Graph copyTo( Graph g )
-    {
+    public Graph copyTo(Graph g) {
         throw exc();
     }
 
     @Override
-    public GraphExtension getExtension()
-    {
+    public GraphExtension getExtension() {
         return wrappedExtension;
     }
 
-    private UnsupportedOperationException exc()
-    {
+    private UnsupportedOperationException exc() {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
+
+    class QueryGraphTurnExt extends TurnCostExtension {
+        private final TurnCostExtension mainTurnExtension;
+
+        public QueryGraphTurnExt() {
+            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
+        }
+
+        @Override
+        public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
+            if (isVirtualNode(nodeVia)) {
+                return 0;
+            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo)) {
+                if (isVirtualEdge(edgeFrom)) {
+                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                if (isVirtualEdge(edgeTo)) {
+                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+
+            } else {
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+            }
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index 33fa2e9777..26f863a4ea 100755
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -18,34 +18,35 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.util.NotThreadSafe;
+
 import java.util.List;
 
 /**
  * Calculates the shortest path from the specified node ids. Can be used only once.
  * <p>
+ *
  * @author Peter Karich
  */
 @NotThreadSafe
-public interface RoutingAlgorithm
-{
+public interface RoutingAlgorithm {
     /**
      * Calculates the best path between the specified nodes.
      *
      * @return the path. Call the method found() to make sure that the path is valid.
      */
-    Path calcPath( int from, int to );
+    Path calcPath(int from, int to);
 
     /**
      * Calculates multiple possibilities for a path.
      *
      * @see #calcPath(int, int)
      */
-    List<Path> calcPaths( int from, int to );
+    List<Path> calcPaths(int from, int to);
 
     /**
      * Limit the search to numberOfNodes. See #681
      */
-    void setMaxVisitedNodes( int numberOfNodes );
+    void setMaxVisitedNodes(int numberOfNodes);
 
     /**
      * @return name of this algorithm
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index e01b55ad50..8468fbc028 100755
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -24,7 +24,6 @@
  *
  * @author Peter Karich
  */
-public interface RoutingAlgorithmFactory
-{
-    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );
+public interface RoutingAlgorithmFactory {
+    RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactoryDecorator.java
index 78a30979db..0ee3ebd3ee 100755
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactoryDecorator.java
@@ -20,16 +20,14 @@
 import com.graphhopper.routing.util.HintsMap;
 
 /**
- *
  * @author Peter Karich
  */
-public interface RoutingAlgorithmFactoryDecorator
-{
+public interface RoutingAlgorithmFactoryDecorator {
     boolean isEnabled();
 
     /**
      * This method returns the specified algoFactory unchanged, decorates it or completely replaces
      * it depending on the specified optionsMap.
      */
-    RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFactory algoFactory, HintsMap optionsMap );
+    RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory algoFactory, HintsMap optionsMap);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index 06644e2419..19a111a1cf 100755
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -17,53 +17,47 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.BeelineWeightApproximator;
-import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.weighting.BeelineWeightApproximator;
+import com.graphhopper.routing.weighting.WeightApproximator;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.Helper;
+
 import static com.graphhopper.util.Parameters.Algorithms.*;
 import static com.graphhopper.util.Parameters.Algorithms.AltRoute.*;
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
  * <p>
+ *
  * @author Peter Karich
  */
-public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
-{
+public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory {
     @Override
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {
+    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
         RoutingAlgorithm ra;
         String algoStr = opts.getAlgorithm();
-        if (DIJKSTRA_BI.equalsIgnoreCase(algoStr))
-        {
-            ra = new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
-        } else if (DIJKSTRA.equalsIgnoreCase(algoStr))
-        {
-            ra = new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        if (DIJKSTRA_BI.equalsIgnoreCase(algoStr)) {
+            ra = new DijkstraBidirectionRef(g, opts.getWeighting(), opts.getTraversalMode());
+        } else if (DIJKSTRA.equalsIgnoreCase(algoStr)) {
+            ra = new Dijkstra(g, opts.getWeighting(), opts.getTraversalMode());
 
-        } else if (ASTAR_BI.equalsIgnoreCase(algoStr))
-        {
-            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+        } else if (ASTAR_BI.equalsIgnoreCase(algoStr)) {
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getWeighting(),
                     opts.getTraversalMode());
             aStarBi.setApproximation(getApproximation(ASTAR_BI, opts, g.getNodeAccess()));
             ra = aStarBi;
 
-        } else if (DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
-        {
-            ra = new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr)) {
+            ra = new DijkstraOneToMany(g, opts.getWeighting(), opts.getTraversalMode());
 
-        } else if (ASTAR.equalsIgnoreCase(algoStr))
-        {
-            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (ASTAR.equalsIgnoreCase(algoStr)) {
+            AStar aStar = new AStar(g, opts.getWeighting(), opts.getTraversalMode());
             aStar.setApproximation(getApproximation(ASTAR, opts, g.getNodeAccess()));
             ra = aStar;
 
-        } else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
-        {
-            AlternativeRoute altRouteAlgo = new AlternativeRoute(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
+            AlternativeRoute altRouteAlgo = new AlternativeRoute(g, opts.getWeighting(), opts.getTraversalMode());
             altRouteAlgo.setMaxPaths(opts.getHints().getInt(MAX_PATHS, 2));
             altRouteAlgo.setMaxWeightFactor(opts.getHints().getDouble(MAX_WEIGHT, 1.4));
             altRouteAlgo.setMaxShareFactor(opts.getHints().getDouble(MAX_SHARE, 0.6));
@@ -71,8 +65,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             altRouteAlgo.setMaxExplorationFactor(opts.getHints().getDouble("alternative_route.max_exploration_factor", 1));
             ra = altRouteAlgo;
 
-        } else
-        {
+        } else {
             throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
         }
 
@@ -80,8 +73,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
         return ra;
     }
 
-    private WeightApproximator getApproximation( String prop, AlgorithmOptions opts, NodeAccess na )
-    {
+    private WeightApproximator getApproximation(String prop, AlgorithmOptions opts, NodeAccess na) {
         String approxAsStr = opts.getHints().get(prop + ".approximation", "BeelineSimplification");
         double epsilon = opts.getHints().getDouble(prop + ".epsilon", 1);
 
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index e17d331bc7..c940072dfd 100755
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -18,7 +18,10 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.util.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -26,197 +29,165 @@
 /**
  * @author Peter Karich
  */
-class VirtualEdgeIterator implements EdgeIterator, CHEdgeIteratorState
-{
+class VirtualEdgeIterator implements EdgeIterator, CHEdgeIteratorState {
     private final List<EdgeIteratorState> edges;
     private int current;
 
-    public VirtualEdgeIterator( int edgeCount )
-    {
+    public VirtualEdgeIterator(int edgeCount) {
         edges = new ArrayList<EdgeIteratorState>(edgeCount);
         reset();
     }
 
-    void add( EdgeIteratorState edge )
-    {
+    void add(EdgeIteratorState edge) {
         edges.add(edge);
     }
 
-    EdgeIterator reset()
-    {
+    EdgeIterator reset() {
         current = -1;
         return this;
     }
 
-    int count()
-    {
+    int count() {
         return edges.size();
     }
 
     @Override
-    public boolean next()
-    {
+    public boolean next() {
         current++;
         return current < edges.size();
     }
 
     @Override
-    public EdgeIteratorState detach( boolean reverse )
-    {
+    public EdgeIteratorState detach(boolean reverse) {
         if (reverse)
             throw new IllegalStateException("Not yet supported");
         return edges.get(current);
     }
 
     @Override
-    public int getEdge()
-    {
+    public int getEdge() {
         return edges.get(current).getEdge();
     }
 
     @Override
-    public int getBaseNode()
-    {
+    public int getBaseNode() {
         return edges.get(current).getBaseNode();
     }
 
     @Override
-    public int getAdjNode()
-    {
+    public int getAdjNode() {
         return edges.get(current).getAdjNode();
     }
 
     @Override
-    public PointList fetchWayGeometry( int mode )
-    {
+    public PointList fetchWayGeometry(int mode) {
         return edges.get(current).fetchWayGeometry(mode);
     }
 
     @Override
-    public EdgeIteratorState setWayGeometry( PointList list )
-    {
+    public EdgeIteratorState setWayGeometry(PointList list) {
         return edges.get(current).setWayGeometry(list);
     }
 
     @Override
-    public double getDistance()
-    {
+    public double getDistance() {
         return edges.get(current).getDistance();
     }
 
     @Override
-    public EdgeIteratorState setDistance( double dist )
-    {
+    public EdgeIteratorState setDistance(double dist) {
         return edges.get(current).setDistance(dist);
     }
 
     @Override
-    public long getFlags()
-    {
+    public long getFlags() {
         return edges.get(current).getFlags();
     }
 
     @Override
-    public EdgeIteratorState setFlags( long flags )
-    {
+    public EdgeIteratorState setFlags(long flags) {
         return edges.get(current).setFlags(flags);
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return edges.get(current).getName();
     }
 
     @Override
-    public EdgeIteratorState setName( String name )
-    {
+    public EdgeIteratorState setName(String name) {
         return edges.get(current).setName(name);
     }
 
     @Override
-    public boolean getBoolean( int key, boolean reverse, boolean _default )
-    {
-        return edges.get(current).getBoolean(key, reverse, _default);
+    public boolean getBool(int key, boolean _default) {
+        return edges.get(current).getBool(key, _default);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return edges.toString();
     }
 
     @Override
-    public int getAdditionalField()
-    {
+    public int getAdditionalField() {
         return edges.get(current).getAdditionalField();
     }
 
     @Override
-    public EdgeIteratorState setAdditionalField( int value )
-    {
+    public EdgeIteratorState setAdditionalField(int value) {
         return edges.get(current).setAdditionalField(value);
     }
 
     @Override
-    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-    {
+    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
         return edges.get(current).copyPropertiesTo(edge);
     }
 
     @Override
-    public boolean isBackward( FlagEncoder encoder )
-    {
+    public boolean isBackward(FlagEncoder encoder) {
         return edges.get(current).isBackward(encoder);
     }
 
     @Override
-    public boolean isForward( FlagEncoder encoder )
-    {
+    public boolean isForward(FlagEncoder encoder) {
         return edges.get(current).isForward(encoder);
     }
 
     @Override
-    public boolean isShortcut()
-    {
+    public boolean isShortcut() {
         EdgeIteratorState edge = edges.get(current);
         return edge instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) edge).isShortcut();
     }
 
     @Override
-    public double getWeight()
-    {
+    public double getWeight() {
         // will be called only from PreparationWeighting and if isShortcut is true
         return ((CHEdgeIteratorState) edges.get(current)).getWeight();
     }
 
     @Override
-    public CHEdgeIteratorState setWeight( double weight )
-    {
+    public CHEdgeIteratorState setWeight(double weight) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge1()
-    {
+    public int getSkippedEdge1() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge2()
-    {
+    public int getSkippedEdge2() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public void setSkippedEdges( int edge1, int edge2 )
-    {
+    public void setSkippedEdges(int edge1, int edge2) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public boolean canBeOverwritten( long flags )
-    {
+    public boolean canBeOverwritten(long flags) {
         throw new UnsupportedOperationException("Not supported.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index 8bceeabbab..f443f4b703 100755
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -18,7 +18,10 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.util.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.PointList;
 
 /**
  * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
@@ -26,21 +29,19 @@
  * Note, this class is not suited for public use and can change with minor releases unexpectedly or
  * even gets removed.
  */
-public class VirtualEdgeIteratorState implements EdgeIteratorState, CHEdgeIteratorState
-{
+public class VirtualEdgeIteratorState implements EdgeIteratorState, CHEdgeIteratorState {
     private final PointList pointList;
     private final int edgeId;
-    private double distance;
-    private long flags;
-    private String name;
     private final int baseNode;
     private final int adjNode;
     private final int originalTraversalKey;
+    private double distance;
+    private long flags;
+    private String name;
     // indication if edges are dispreferred as start/stop edge 
     private boolean unfavored;
 
-    public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
-    {
+    public VirtualEdgeIteratorState(int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList) {
         this.originalTraversalKey = originalTraversalKey;
         this.edgeId = edgeId;
         this.baseNode = baseNode;
@@ -55,34 +56,30 @@ public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseN
      * This method returns the original edge via its traversal key. I.e. also the direction is
      * already correctly encoded.
      * <p>
+     *
      * @see GHUtility#createEdgeKey(int, int, int, boolean)
      */
-    public int getOriginalTraversalKey()
-    {
+    public int getOriginalTraversalKey() {
         return originalTraversalKey;
     }
 
     @Override
-    public int getEdge()
-    {
+    public int getEdge() {
         return edgeId;
     }
 
     @Override
-    public int getBaseNode()
-    {
+    public int getBaseNode() {
         return baseNode;
     }
 
     @Override
-    public int getAdjNode()
-    {
+    public int getAdjNode() {
         return adjNode;
     }
 
     @Override
-    public PointList fetchWayGeometry( int mode )
-    {
+    public PointList fetchWayGeometry(int mode) {
         if (pointList.getSize() == 0)
             return PointList.EMPTY;
         // due to API we need to create a new instance per call!
@@ -92,8 +89,7 @@ else if (mode == 1)
             return pointList.copy(0, pointList.getSize() - 1);
         else if (mode == 2)
             return pointList.copy(1, pointList.getSize());
-        else if (mode == 0)
-        {
+        else if (mode == 0) {
             if (pointList.getSize() == 1)
                 return PointList.EMPTY;
             return pointList.copy(1, pointList.getSize() - 1);
@@ -102,53 +98,45 @@ else if (mode == 0)
     }
 
     @Override
-    public EdgeIteratorState setWayGeometry( PointList list )
-    {
+    public EdgeIteratorState setWayGeometry(PointList list) {
         throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
     }
 
     @Override
-    public double getDistance()
-    {
+    public double getDistance() {
         return distance;
     }
 
     @Override
-    public EdgeIteratorState setDistance( double dist )
-    {
+    public EdgeIteratorState setDistance(double dist) {
         this.distance = dist;
         return this;
     }
 
     @Override
-    public long getFlags()
-    {
+    public long getFlags() {
         return flags;
     }
 
     @Override
-    public EdgeIteratorState setFlags( long flags )
-    {
+    public EdgeIteratorState setFlags(long flags) {
         this.flags = flags;
         return this;
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return name;
     }
 
     @Override
-    public EdgeIteratorState setName( String name )
-    {
+    public EdgeIteratorState setName(String name) {
         this.name = name;
         return this;
     }
 
     @Override
-    public boolean getBoolean( int key, boolean reverse, boolean _default )
-    {
+    public boolean getBool(int key, boolean _default) {
         if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
             return unfavored;
 
@@ -159,92 +147,77 @@ public boolean getBoolean( int key, boolean reverse, boolean _default )
     /**
      * This method sets edge to unfavored status for routing from or to the start/stop points.
      */
-    public void setVirtualEdgePreference( boolean unfavored )
-    {
+    public void setUnfavored(boolean unfavored) {
         this.unfavored = unfavored;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return baseNode + "->" + adjNode;
     }
 
     @Override
-    public boolean isShortcut()
-    {
+    public boolean isShortcut() {
         return false;
     }
 
     @Override
-    public boolean isForward( FlagEncoder encoder )
-    {
+    public boolean isForward(FlagEncoder encoder) {
         return encoder.isForward(getFlags());
     }
 
     @Override
-    public boolean isBackward( FlagEncoder encoder )
-    {
+    public boolean isBackward(FlagEncoder encoder) {
         return encoder.isBackward(getFlags());
     }
 
     @Override
-    public int getAdditionalField()
-    {
+    public int getAdditionalField() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public boolean canBeOverwritten( long flags )
-    {
+    public boolean canBeOverwritten(long flags) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge1()
-    {
+    public int getSkippedEdge1() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge2()
-    {
+    public int getSkippedEdge2() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public void setSkippedEdges( int edge1, int edge2 )
-    {
+    public void setSkippedEdges(int edge1, int edge2) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public EdgeIteratorState detach( boolean reverse )
-    {
+    public EdgeIteratorState detach(boolean reverse) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public EdgeIteratorState setAdditionalField( int value )
-    {
+    public EdgeIteratorState setAdditionalField(int value) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-    {
+    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public CHEdgeIteratorState setWeight( double weight )
-    {
+    public CHEdgeIteratorState setWeight(double weight) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public double getWeight()
-    {
+    public double getWeight() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index da7baa19da..a5465a5448 100755
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -19,15 +19,16 @@
 
 import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.RoutingAlgorithmFactoryDecorator;
-import com.graphhopper.routing.util.AbstractWeighting;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters.CH;
-import static com.graphhopper.util.Parameters.CH.DISABLE;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -35,8 +36,8 @@
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+
+import static com.graphhopper.util.Parameters.CH.DISABLE;
 
 /**
  * This class implements the CH decorator for the routing algorithm factory and provides several
@@ -44,8 +45,7 @@
  *
  * @author Peter Karich
  */
-public class CHAlgoFactoryDecorator implements RoutingAlgorithmFactoryDecorator
-{
+public class CHAlgoFactoryDecorator implements RoutingAlgorithmFactoryDecorator {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final List<PrepareContractionHierarchies> preparations = new ArrayList<>();
     // we need to decouple weighting objects from the weighting list of strings 
@@ -63,14 +63,12 @@
     private int preparationContractedNodes = -1;
     private double preparationLogMessages = -1;
 
-    public CHAlgoFactoryDecorator()
-    {
+    public CHAlgoFactoryDecorator() {
         setPreparationThreads(1);
         setWeightingsAsStrings(Arrays.asList(getDefaultWeighting()));
     }
 
-    public void init( CmdArgs args )
-    {
+    public void init(CmdArgs args) {
         setPreparationThreads(args.getInt("prepare.threads", getPreparationThreads()));
 
         String deprecatedWeightingConfig = args.get("prepare.chWeighting", "");
@@ -84,12 +82,10 @@ public void init( CmdArgs args )
         if (chWeightingsStr.isEmpty())
             chWeightingsStr = args.get("prepare.chWeightings", "");
 
-        if ("no".equals(chWeightingsStr))
-        {
+        if ("no".equals(chWeightingsStr)) {
             // default is fastest and we need to clear this explicitely
             weightingsAsStrings.clear();
-        } else if (!chWeightingsStr.isEmpty())
-        {
+        } else if (!chWeightingsStr.isEmpty()) {
             List<String> tmpCHWeightingList = Arrays.asList(chWeightingsStr.split(","));
             setWeightingsAsStrings(tmpCHWeightingList);
         }
@@ -106,107 +102,90 @@ public void init( CmdArgs args )
         setPreparationLogMessages(args.getDouble("prepare.log_messages", getPreparationLogMessages()));
     }
 
-    public CHAlgoFactoryDecorator setPreparationPeriodicUpdates( int preparePeriodicUpdates )
-    {
+    public int getPreparationPeriodicUpdates() {
+        return preparationPeriodicUpdates;
+    }
+
+    public CHAlgoFactoryDecorator setPreparationPeriodicUpdates(int preparePeriodicUpdates) {
         this.preparationPeriodicUpdates = preparePeriodicUpdates;
         return this;
     }
 
-    public int getPreparationPeriodicUpdates()
-    {
-        return preparationPeriodicUpdates;
+    public int getPreparationContractedNodes() {
+        return preparationContractedNodes;
     }
 
-    public CHAlgoFactoryDecorator setPreparationContractedNodes( int prepareContractedNodes )
-    {
+    public CHAlgoFactoryDecorator setPreparationContractedNodes(int prepareContractedNodes) {
         this.preparationContractedNodes = prepareContractedNodes;
         return this;
     }
 
-    public int getPreparationContractedNodes()
-    {
-        return preparationContractedNodes;
+    public int getPreparationLazyUpdates() {
+        return preparationLazyUpdates;
     }
 
-    public CHAlgoFactoryDecorator setPreparationLazyUpdates( int prepareLazyUpdates )
-    {
+    public CHAlgoFactoryDecorator setPreparationLazyUpdates(int prepareLazyUpdates) {
         this.preparationLazyUpdates = prepareLazyUpdates;
         return this;
     }
 
-    public int getPreparationLazyUpdates()
-    {
-        return preparationLazyUpdates;
+    public double getPreparationLogMessages() {
+        return preparationLogMessages;
     }
 
-    public CHAlgoFactoryDecorator setPreparationLogMessages( double prepareLogMessages )
-    {
+    public CHAlgoFactoryDecorator setPreparationLogMessages(double prepareLogMessages) {
         this.preparationLogMessages = prepareLogMessages;
         return this;
     }
 
-    public double getPreparationLogMessages()
-    {
-        return preparationLogMessages;
+    public int getPreparationNeighborUpdates() {
+        return preparationNeighborUpdates;
     }
 
-    public CHAlgoFactoryDecorator setPreparationNeighborUpdates( int prepareNeighborUpdates )
-    {
+    public CHAlgoFactoryDecorator setPreparationNeighborUpdates(int prepareNeighborUpdates) {
         this.preparationNeighborUpdates = prepareNeighborUpdates;
         return this;
     }
 
-    public int getPreparationNeighborUpdates()
-    {
-        return preparationNeighborUpdates;
+    @Override
+    public final boolean isEnabled() {
+        return enabled;
     }
 
     /**
      * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
      */
-    public final void setEnabled( boolean enabled )
-    {
+    public final void setEnabled(boolean enabled) {
         this.enabled = enabled;
     }
 
-    @Override
-    public final boolean isEnabled()
-    {
-        return enabled;
+    public final boolean isDisablingAllowed() {
+        return disablingAllowed || !isEnabled();
     }
 
     /**
      * This method specifies if it is allowed to disable CH routing at runtime via routing hints.
      */
-    public final CHAlgoFactoryDecorator setDisablingAllowed( boolean disablingAllowed )
-    {
+    public final CHAlgoFactoryDecorator setDisablingAllowed(boolean disablingAllowed) {
         this.disablingAllowed = disablingAllowed;
         return this;
     }
 
-    public final boolean isDisablingAllowed()
-    {
-        return disablingAllowed || !isEnabled();
-    }
-
     /**
      * Decouple weightings from PrepareContractionHierarchies as we need weightings for the
      * graphstorage and the graphstorage for the preparation.
      */
-    public CHAlgoFactoryDecorator addWeighting( Weighting weighting )
-    {
+    public CHAlgoFactoryDecorator addWeighting(Weighting weighting) {
         weightings.add(weighting);
         return this;
     }
 
-    public CHAlgoFactoryDecorator addWeighting( String weighting )
-    {
+    public CHAlgoFactoryDecorator addWeighting(String weighting) {
         weightingsAsStrings.add(weighting);
         return this;
     }
 
-    public CHAlgoFactoryDecorator addPreparation( PrepareContractionHierarchies pch )
-    {
+    public CHAlgoFactoryDecorator addPreparation(PrepareContractionHierarchies pch) {
         preparations.add(pch);
         int lastIndex = preparations.size() - 1;
         if (lastIndex >= weightings.size())
@@ -219,35 +198,37 @@ public CHAlgoFactoryDecorator addPreparation( PrepareContractionHierarchies pch
         return this;
     }
 
-    public final boolean hasWeightings()
-    {
+    public final boolean hasWeightings() {
         return !weightings.isEmpty();
     }
 
-    public final List<Weighting> getWeightings()
-    {
+    public final List<Weighting> getWeightings() {
         return weightings;
     }
 
-    public CHAlgoFactoryDecorator setWeightingsAsStrings( String... weightingNames )
-    {
+    public CHAlgoFactoryDecorator setWeightingsAsStrings(String... weightingNames) {
         return setWeightingsAsStrings(Arrays.asList(weightingNames));
     }
 
+    public List<String> getWeightingsAsStrings() {
+        if (this.weightingsAsStrings.isEmpty())
+            throw new IllegalStateException("Potential bug: chWeightingList is empty");
+
+        return this.weightingsAsStrings;
+    }
+
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      *
      * @param weightingList A list containing multiple weightings like: "fastest", "shortest" or
-     * your own weight-calculation type.
+     *                      your own weight-calculation type.
      */
-    public CHAlgoFactoryDecorator setWeightingsAsStrings( List<String> weightingList )
-    {
+    public CHAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList) {
         if (weightingList.isEmpty())
             throw new IllegalArgumentException("It is not allowed to pass an emtpy weightingList");
 
         weightingsAsStrings.clear();
-        for (String strWeighting : weightingList)
-        {
+        for (String strWeighting : weightingList) {
             strWeighting = strWeighting.toLowerCase();
             strWeighting = strWeighting.trim();
             addWeighting(strWeighting);
@@ -255,27 +236,16 @@ public CHAlgoFactoryDecorator setWeightingsAsStrings( List<String> weightingList
         return this;
     }
 
-    public List<String> getWeightingsAsStrings()
-    {
-        if (this.weightingsAsStrings.isEmpty())
-            throw new IllegalStateException("Potential bug: chWeightingList is empty");
-
-        return this.weightingsAsStrings;
-    }
-
-    private String getDefaultWeighting()
-    {
+    private String getDefaultWeighting() {
         return weightingsAsStrings.isEmpty() ? "fastest" : weightingsAsStrings.get(0);
     }
 
-    public List<PrepareContractionHierarchies> getPreparations()
-    {
+    public List<PrepareContractionHierarchies> getPreparations() {
         return preparations;
     }
 
     @Override
-    public RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFactory defaultAlgoFactory, HintsMap map )
-    {
+    public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory defaultAlgoFactory, HintsMap map) {
         boolean forceFlexMode = map.getBool(DISABLE, false);
         if (!isEnabled() || forceFlexMode)
             return defaultAlgoFactory;
@@ -286,8 +256,7 @@ public RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFac
         if (map.getWeighting().isEmpty())
             map.setWeighting(getDefaultWeighting());
 
-        for (PrepareContractionHierarchies p : preparations)
-        {
+        for (PrepareContractionHierarchies p : preparations) {
             if (p.getWeighting().matches(map))
                 return p;
         }
@@ -295,36 +264,29 @@ public RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFac
         throw new IllegalArgumentException("Cannot find RoutingAlgorithmFactory for weighting map " + map);
     }
 
+    public int getPreparationThreads() {
+        return preparationThreads;
+    }
+
     /**
      * This method changes the number of threads used for preparation on import. Default is 1. Make
      * sure that you have enough memory to increase this number!
      */
-    public void setPreparationThreads( int preparationThreads )
-    {
+    public void setPreparationThreads(int preparationThreads) {
         this.preparationThreads = preparationThreads;
         this.chPreparePool = java.util.concurrent.Executors.newFixedThreadPool(preparationThreads);
     }
 
-    public int getPreparationThreads()
-    {
-        return preparationThreads;
-    }
-
-    public void prepare( final StorableProperties properties )
-    {
+    public void prepare(final StorableProperties properties) {
         int counter = 0;
-        for (final PrepareContractionHierarchies prepare : getPreparations())
-        {
+        for (final PrepareContractionHierarchies prepare : getPreparations()) {
             logger.info((++counter) + "/" + getPreparations().size() + " calling prepare.doWork for " + prepare.getWeighting() + " ... (" + Helper.getMemInfo() + ")");
             final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting());
-            chPreparePool.execute(new Runnable()
-            {
+            chPreparePool.execute(new Runnable() {
                 @Override
-                public void run()
-                {
+                public void run() {
                     String errorKey = "prepare.error." + name;
-                    try
-                    {
+                    try {
                         properties.put(errorKey, "CH preparation incomplete");
                         // toString is not taken into account so we need to cheat, see http://stackoverflow.com/q/6113746/194609 for other options                        
 
@@ -332,8 +294,7 @@ public void run()
                         prepare.doWork();
                         properties.remove(errorKey);
                         properties.put("prepare.date." + name, Helper.createFormatter().format(new Date()));
-                    } catch (Exception ex)
-                    {
+                    } catch (Exception ex) {
                         logger.error("Problem while CH preparation " + name, ex);
                         properties.put(errorKey, ex.getMessage());
                     }
@@ -342,20 +303,17 @@ public void run()
         }
 
         chPreparePool.shutdown();
-        try
-        {
+        try {
             if (!chPreparePool.awaitTermination(Integer.MAX_VALUE, TimeUnit.DAYS))
                 chPreparePool.shutdownNow();
 
-        } catch (InterruptedException ie)
-        {
+        } catch (InterruptedException ie) {
             chPreparePool.shutdownNow();
             throw new RuntimeException(ie);
         }
     }
 
-    public void createPreparations( GraphHopperStorage ghStorage, TraversalMode traversalMode )
-    {
+    public void createPreparations(GraphHopperStorage ghStorage, TraversalMode traversalMode) {
         if (!isEnabled() || !preparations.isEmpty())
             return;
         if (weightings.isEmpty())
@@ -363,11 +321,10 @@ public void createPreparations( GraphHopperStorage ghStorage, TraversalMode trav
 
         traversalMode = getNodeBase();
 
-        for (Weighting weighting : getWeightings())
-        {
+        for (Weighting weighting : getWeightings()) {
             PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
                     new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class, weighting),
-                    weighting.getFlagEncoder(), weighting, traversalMode);
+                    weighting, traversalMode);
             tmpPrepareCH.setPeriodicUpdates(preparationPeriodicUpdates).
                     setLazyUpdates(preparationLazyUpdates).
                     setNeighborUpdates(preparationNeighborUpdates).
@@ -381,8 +338,7 @@ public void createPreparations( GraphHopperStorage ghStorage, TraversalMode trav
      * For now only node based will work, later on we can easily find usage of this method to remove
      * it.
      */
-    public TraversalMode getNodeBase()
-    {
+    public TraversalMode getNodeBase() {
         return TraversalMode.NODE_BASED;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 3033596c6e..675df3a7ca 100755
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -19,41 +19,37 @@
 
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
 
 /**
  * Recursivly unpack shortcuts.
  * <p>
+ *
  * @author Peter Karich
  * @see PrepareContractionHierarchies
  */
-public class Path4CH extends PathBidirRef
-{
+public class Path4CH extends PathBidirRef {
     private final Graph routingGraph;
 
-    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
-    {
-        super(baseGraph, encoder);
+    public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
+        super(baseGraph, weighting);
         this.routingGraph = routingGraph;
     }
 
     @Override
-    protected final void processEdge( int tmpEdge, int endNode )
-    {
+    protected final void processEdge(int tmpEdge, int endNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
         expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
     }
 
-    private void expandEdge( CHEdgeIteratorState mainEdgeState, boolean reverse )
-    {
-        if (!mainEdgeState.isShortcut())
-        {
-            double dist = mainEdgeState.getDistance();
-            distance += dist;
-            long flags = mainEdgeState.getFlags();
-            time += calcMillis(dist, flags, reverse);
+    private void expandEdge(CHEdgeIteratorState mainEdgeState, boolean reverse) {
+        if (!mainEdgeState.isShortcut()) {
+            distance += mainEdgeState.getDistance();
+            time += weighting.calcMillis(mainEdgeState, reverse, EdgeIterator.NO_EDGE);
             addEdge(mainEdgeState.getEdge());
             return;
         }
@@ -63,16 +59,14 @@ private void expandEdge( CHEdgeIteratorState mainEdgeState, boolean reverse )
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
 
         // get properties like speed of the edge in the correct direction
-        if (reverse)
-        {
+        if (reverse) {
             int tmp = from;
             from = to;
             to = tmp;
         }
 
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
-        if (reverseOrder)
-        {
+        if (reverseOrder) {
             CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
@@ -86,8 +80,7 @@ private void expandEdge( CHEdgeIteratorState mainEdgeState, boolean reverse )
                 edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
 
             expandEdge(edgeState, true);
-        } else
-        {
+        } else {
             CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 7da1a9c93b..e937edeb49 100755
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -18,35 +18,32 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Used in CH preparation and therefor assumed that all edges are of type CHEdgeIteratorState
  * <p>
+ *
  * @author Peter Karich
  * @see PrepareContractionHierarchies
  */
-public class PreparationWeighting implements Weighting
-{
+public class PreparationWeighting implements Weighting {
     private final Weighting userWeighting;
 
-    public PreparationWeighting( Weighting userWeighting )
-    {
+    public PreparationWeighting(Weighting userWeighting) {
         this.userWeighting = userWeighting;
     }
 
     @Override
-    public final double getMinWeight( double distance )
-    {
+    public final double getMinWeight(double distance) {
         return userWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         CHEdgeIteratorState tmp = (CHEdgeIteratorState) edgeState;
         if (tmp.isShortcut())
             // if a shortcut is in both directions the weight is identical => no need for 'reverse'
@@ -56,26 +53,27 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
     }
 
     @Override
-    public FlagEncoder getFlagEncoder()
-    {
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        return userWeighting.calcMillis(edgeState, reverse, prevOrNextEdgeId);
+    }
+
+    @Override
+    public FlagEncoder getFlagEncoder() {
         return userWeighting.getFlagEncoder();
     }
 
     @Override
-    public boolean matches( HintsMap map )
-    {
+    public boolean matches(HintsMap map) {
         return getName().equals(map.getWeighting()) && userWeighting.getFlagEncoder().toString().equals(map.getVehicle());
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return "prepare|" + userWeighting.getName();
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getName();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 65f4e4b7d9..541c9d7f82 100755
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -20,15 +20,21 @@
 import com.graphhopper.coll.GHTreeMapComposed;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Parameters.Algorithms.*;
-
-import java.util.*;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+
+import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+
 /**
  * This class prepares the graph for a bidirectional algorithm supporting contraction hierarchies
  * ie. an algorithm returned by createAlgo.
@@ -39,38 +45,38 @@
  * The only difference is that we use two skipped edges instead of one skipped node for faster
  * unpacking.
  * <p>
+ *
  * @author Peter Karich
  */
-public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
-{
+public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final PreparationWeighting prepareWeighting;
-    private final FlagEncoder prepareFlagEncoder;
     private final TraversalMode traversalMode;
+    private final LevelEdgeFilter levelFilter;
+    private final GraphHopperStorage ghStorage;
+    private final CHGraphImpl prepareGraph;
+    private final DataAccess originalEdges;
+    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
+    private final Random rand = new Random(123);
+    private final StopWatch allSW = new StopWatch();
+    AddShortcutHandler addScHandler = new AddShortcutHandler();
+    CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
     private CHEdgeExplorer vehicleInExplorer;
     private CHEdgeExplorer vehicleOutExplorer;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
     private CHEdgeExplorer calcPrioAllExplorer;
-    private final LevelEdgeFilter levelFilter;
     private int maxLevel;
-    private final GraphHopperStorage ghStorage;
-    private final CHGraphImpl prepareGraph;
-
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
-    private final DataAccess originalEdges;
-    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
     private DijkstraOneToMany prepareAlgo;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
     private double meanDegree;
-    private final Random rand = new Random(123);
     private StopWatch dijkstraSW = new StopWatch();
-    private final StopWatch allSW = new StopWatch();
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
     private int neighborUpdatePercentage = 20;
@@ -83,13 +89,11 @@
     private double neighborTime;
     private int maxEdgesCount;
 
-    public PrepareContractionHierarchies( Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
-                                          FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
-    {
+    public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
+                                         Weighting weighting, TraversalMode traversalMode) {
         this.ghStorage = ghStorage;
         this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
-        this.prepareFlagEncoder = encoder;
         levelFilter = new LevelEdgeFilter(prepareGraph);
 
         prepareWeighting = new PreparationWeighting(weighting);
@@ -101,11 +105,11 @@ public PrepareContractionHierarchies( Directory dir, GraphHopperStorage ghStorag
      * The higher the values are the longer the preparation takes but the less shortcuts are
      * produced.
      * <p>
+     *
      * @param periodicUpdates specifies how often periodic updates will happen. Use something less
-     * than 10.
+     *                        than 10.
      */
-    public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
-    {
+    public PrepareContractionHierarchies setPeriodicUpdates(int periodicUpdates) {
         if (periodicUpdates < 0)
             return this;
         if (periodicUpdates > 100)
@@ -117,10 +121,9 @@ public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
 
     /**
      * @param lazyUpdates specifies when lazy updates will happen, measured relative to all existing
-     * nodes. 100 means always.
+     *                    nodes. 100 means always.
      */
-    public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
-    {
+    public PrepareContractionHierarchies setLazyUpdates(int lazyUpdates) {
         if (lazyUpdates < 0)
             return this;
 
@@ -134,8 +137,7 @@ public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
     /**
      * @param neighborUpdates specifies how often neighbor updates will happen. 100 means always.
      */
-    public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
-    {
+    public PrepareContractionHierarchies setNeighborUpdates(int neighborUpdates) {
         if (neighborUpdates < 0)
             return this;
 
@@ -150,8 +152,7 @@ public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
      * Specifies how often a log message should be printed. Specify something around 20 (20% of the
      * start nodes).
      */
-    public PrepareContractionHierarchies setLogMessages( double logMessages )
-    {
+    public PrepareContractionHierarchies setLogMessages(double logMessages) {
         if (logMessages >= 0)
             this.logMessagesPercentage = logMessages;
         return this;
@@ -161,8 +162,7 @@ public PrepareContractionHierarchies setLogMessages( double logMessages )
      * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
      * faster contraction duration.
      */
-    public PrepareContractionHierarchies setContractedNodes( double nodesContracted )
-    {
+    public PrepareContractionHierarchies setContractedNodes(double nodesContracted) {
         if (nodesContracted < 0)
             return this;
 
@@ -178,17 +178,12 @@ public PrepareContractionHierarchies setContractedNodes( double nodesContracted
      * be too high for your mobile application. E.g. A 500km query only traverses roughly 2000
      * nodes.
      */
-    public void setInitialCollectionSize( int initialCollectionSize )
-    {
+    public void setInitialCollectionSize(int initialCollectionSize) {
         this.initialCollectionSize = initialCollectionSize;
     }
 
     @Override
-    public void doWork()
-    {
-        if (prepareFlagEncoder == null)
-            throw new IllegalStateException("No vehicle encoder set.");
-
+    public void doWork() {
         if (prepareWeighting == null)
             throw new IllegalStateException("No weight calculation set.");
 
@@ -202,16 +197,13 @@ public void doWork()
         contractNodes();
     }
 
-    boolean prepareNodes()
-    {
+    boolean prepareNodes() {
         int nodes = prepareGraph.getNodes();
-        for (int node = 0; node < nodes; node++)
-        {
+        for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
         }
 
-        for (int node = 0; node < nodes; node++)
-        {
+        for (int node = 0; node < nodes; node++) {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
         }
@@ -222,8 +214,7 @@ boolean prepareNodes()
         return true;
     }
 
-    void contractNodes()
-    {
+    void contractNodes() {
         meanDegree = prepareGraph.getAllEdges().getMaxId() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
@@ -258,16 +249,13 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        while (!sortedNodes.isEmpty())
-        {
-            // periodically update priorities of ALL nodes            
-            if (periodicUpdate && counter > 0 && counter % periodicUpdatesCount == 0)
-            {
+        while (!sortedNodes.isEmpty()) {
+            // periodically update priorities of ALL nodes
+            if (periodicUpdate && counter > 0 && counter % periodicUpdatesCount == 0) {
                 periodSW.start();
                 sortedNodes.clear();
                 int len = prepareGraph.getNodes();
-                for (int node = 0; node < len; node++)
-                {
+                for (int node = 0; node < len; node++) {
                     if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
@@ -280,8 +268,7 @@ void contractNodes()
                     throw new IllegalStateException("Cannot prepare as no unprepared nodes where found. Called preparation twice?");
             }
 
-            if (counter % logSize == 0)
-            {
+            if (counter % logSize == 0) {
                 dijkstraTime += dijkstraSW.getSeconds();
                 periodTime += periodSW.getSeconds();
                 lazyTime += lazySW.getSeconds();
@@ -304,12 +291,10 @@ void contractNodes()
 
             counter++;
             int polledNode = sortedNodes.pollKey();
-            if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates)
-            {
+            if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates) {
                 lazySW.start();
                 int priority = oldPriorities[polledNode] = calculatePriority(polledNode);
-                if (priority > sortedNodes.peekValue())
-                {
+                if (priority > sortedNodes.peekValue()) {
                     // current node got more important => insert as new value and contract it later
                     sortedNodes.insert(polledNode, priority);
                     lazySW.stop();
@@ -318,7 +303,7 @@ void contractNodes()
                 lazySW.stop();
             }
 
-            // contract!            
+            // contract!
             newShortcuts += addShortcuts(polledNode);
             prepareGraph.setLevel(polledNode, level);
             level++;
@@ -328,14 +313,12 @@ void contractNodes()
                 break;
 
             CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int nn = iter.getAdjNode();
                 if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
-                if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
-                {
+                if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage) {
                     neighborSW.start();
                     int oldPrio = oldPriorities[nn];
                     int priority = oldPriorities[nn] = calculatePriority(nn);
@@ -360,7 +343,6 @@ void contractNodes()
         logger.info("took:" + (int) allSW.stop().getSeconds()
                 + ", new shortcuts: " + Helper.nf(newShortcuts)
                 + ", " + prepareWeighting
-                + ", " + prepareFlagEncoder
                 + ", dijkstras:" + dijkstraCount
                 + ", " + getTimesAsString()
                 + ", meanDegree:" + (long) meanDegree
@@ -371,153 +353,45 @@ void contractNodes()
                 + ", " + Helper.getMemInfo());
     }
 
-    public long getDijkstraCount()
-    {
+    public long getDijkstraCount() {
         return dijkstraCount;
     }
 
-    public double getLazyTime()
-    {
+    public double getLazyTime() {
         return lazyTime;
     }
 
-    public double getPeriodTime()
-    {
+    public double getPeriodTime() {
         return periodTime;
     }
 
-    public double getDijkstraTime()
-    {
+    public double getDijkstraTime() {
         return dijkstraTime;
     }
 
-    public double getNeighborTime()
-    {
+    public double getNeighborTime() {
         return neighborTime;
     }
 
-    public Weighting getWeighting()
-    {
+    public Weighting getWeighting() {
         return prepareGraph.getWeighting();
     }
 
-    public void close()
-    {
+    public void close() {
         prepareAlgo.close();
         originalEdges.close();
         sortedNodes = null;
         oldPriorities = null;
     }
 
-    AddShortcutHandler addScHandler = new AddShortcutHandler();
-    CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
-
-    private String getTimesAsString()
-    {
+    private String getTimesAsString() {
         return "t(dijk):" + Helper.round2(dijkstraTime)
                 + ", t(period):" + Helper.round2(periodTime)
                 + ", t(lazy):" + Helper.round2(lazyTime)
                 + ", t(neighbor):" + Helper.round2(neighborTime);
     }
 
-    interface ShortcutHandler
-    {
-        void foundShortcut( int u_fromNode, int w_toNode,
-                            double existingDirectWeight, double distance,
-                            EdgeIterator outgoingEdges,
-                            int skippedEdge1, int incomingEdgeOrigCount );
-
-        int getNode();
-    }
-
-    class CalcShortcutHandler implements ShortcutHandler
-    {
-        int node;
-        int originalEdgesCount;
-        int shortcuts;
-
-        public CalcShortcutHandler setNode( int n )
-        {
-            node = n;
-            originalEdgesCount = 0;
-            shortcuts = 0;
-            return this;
-        }
-
-        @Override
-        public int getNode()
-        {
-            return node;
-        }
-
-        @Override
-        public void foundShortcut( int u_fromNode, int w_toNode,
-                                   double existingDirectWeight, double distance,
-                                   EdgeIterator outgoingEdges,
-                                   int skippedEdge1, int incomingEdgeOrigCount )
-        {
-            shortcuts++;
-            originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
-
-    class AddShortcutHandler implements ShortcutHandler
-    {
-        int node;
-
-        public AddShortcutHandler()
-        {
-        }
-
-        @Override
-        public int getNode()
-        {
-            return node;
-        }
-
-        public AddShortcutHandler setNode( int n )
-        {
-            shortcuts.clear();
-            node = n;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut( int u_fromNode, int w_toNode,
-                                   double existingDirectWeight, double existingDistSum,
-                                   EdgeIterator outgoingEdges,
-                                   int skippedEdge1, int incomingEdgeOrigCount )
-        {
-            // FOUND shortcut 
-            // but be sure that it is the only shortcut in the collection 
-            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
-            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
-            // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
-            if (shortcuts.containsKey(sc))
-                return;
-
-            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
-            Shortcut tmpRetSc = shortcuts.get(tmpSc);
-            if (tmpRetSc != null)
-            {
-                // overwrite flags only if skipped edges are identical
-                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge())
-                {
-                    tmpRetSc.flags = PrepareEncoder.getScDirMask();
-                    return;
-                }
-            }
-
-            shortcuts.put(sc, sc);
-            sc.skippedEdge1 = skippedEdge1;
-            sc.skippedEdge2 = outgoingEdges.getEdge();
-            sc.originalEdges = incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
-
-    Set<Shortcut> testFindShortcuts( int node )
-    {
+    Set<Shortcut> testFindShortcuts(int node) {
         findShortcuts(addScHandler.setNode(node));
         return shortcuts.keySet();
     }
@@ -528,8 +402,7 @@ public void foundShortcut( int u_fromNode, int w_toNode,
      * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
      * lead to a slowish or even endless loop.
      */
-    int calculatePriority( int v )
-    {
+    int calculatePriority(int v) {
         // set of shortcuts that would be added if adjNode v would be contracted next.
         findShortcuts(calcScHandler.setNode(v));
 
@@ -545,15 +418,14 @@ int calculatePriority( int v )
 //            originalEdgesCount += sc.originalEdges;
 //        }
 
-        // # lowest influence on preparation speed or shortcut creation count 
+        // # lowest influence on preparation speed or shortcut creation count
         // (but according to paper should speed up queries)
         //
         // number of already contracted neighbors of v
         int contractedNeighbors = 0;
         int degree = 0;
         CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(v);
-        while (iter.next())
-        {
+        while (iter.next()) {
             degree++;
             if (iter.isShortcut())
                 contractedNeighbors++;
@@ -562,7 +434,7 @@ int calculatePriority( int v )
         // from shortcuts we can compute the edgeDifference
         // # low influence: with it the shortcut creation is slightly faster
         //
-        // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|        
+        // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|
         // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
         // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
         int edgeDifference = calcScHandler.shortcuts - degree;
@@ -575,13 +447,11 @@ int calculatePriority( int v )
     /**
      * Finds shortcuts, does not change the underlying graph.
      */
-    void findShortcuts( ShortcutHandler sch )
-    {
+    void findShortcuts(ShortcutHandler sch) {
         long tmpDegreeCounter = 0;
         EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
         // collect outgoing nodes (goal-nodes) only once
-        while (incomingEdges.next())
-        {
+        while (incomingEdges.next()) {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
             if (prepareGraph.getLevel(u_fromNode) != maxLevel)
@@ -596,8 +466,7 @@ void findShortcuts( ShortcutHandler sch )
             // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
             prepareAlgo.clear();
             tmpDegreeCounter++;
-            while (outgoingEdges.next())
-            {
+            while (outgoingEdges.next()) {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
                 if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
@@ -627,7 +496,7 @@ void findShortcuts( ShortcutHandler sch )
 
                 // compare end node as the limit could force dijkstra to finish earlier
                 if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
-                    // FOUND witness path, so do not add shortcut                
+                    // FOUND witness path, so do not add shortcut
                     continue;
 
                 sch.foundShortcut(u_fromNode, w_toNode,
@@ -636,8 +505,7 @@ void findShortcuts( ShortcutHandler sch )
                         skippedEdge1, incomingEdgeOrigCount);
             }
         }
-        if (sch instanceof AddShortcutHandler)
-        {
+        if (sch instanceof AddShortcutHandler) {
             // sliding mean value when using "*2" => slower changes
             meanDegree = (meanDegree * 2 + tmpDegreeCounter) / 3;
             // meanDegree = (meanDegree + tmpDegreeCounter) / 2;
@@ -647,26 +515,21 @@ void findShortcuts( ShortcutHandler sch )
     /**
      * Introduces the necessary shortcuts for adjNode v in the graph.
      */
-    int addShortcuts( int v )
-    {
+    int addShortcuts(int v) {
         shortcuts.clear();
         findShortcuts(addScHandler.setNode(v));
         int tmpNewShortcuts = 0;
         NEXT_SC:
-        for (Shortcut sc : shortcuts.keySet())
-        {
+        for (Shortcut sc : shortcuts.keySet()) {
             boolean updatedInGraph = false;
             // check if we need to update some existing shortcut in the graph
             CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
-            while (iter.next())
-            {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to && iter.canBeOverwritten(sc.flags))
-                {
+            while (iter.next()) {
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to && iter.canBeOverwritten(sc.flags)) {
                     if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE))
                         continue NEXT_SC;
 
-                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2)
-                    {
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
                         throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
                                 + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
@@ -687,8 +550,7 @@ int addShortcuts( int v )
                 }
             }
 
-            if (!updatedInGraph)
-            {
+            if (!updatedInGraph) {
                 CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
@@ -702,8 +564,7 @@ int addShortcuts( int v )
         return tmpNewShortcuts;
     }
 
-    String getCoords( EdgeIteratorState e, Graph g )
-    {
+    String getCoords(EdgeIteratorState e, Graph g) {
         NodeAccess na = g.getNodeAccess();
         int base = e.getBaseNode();
         int adj = e.getAdjNode();
@@ -711,20 +572,18 @@ String getCoords( EdgeIteratorState e, Graph g )
                 + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
     }
 
-    PrepareContractionHierarchies initFromGraph()
-    {
+    PrepareContractionHierarchies initFromGraph() {
         ghStorage.freeze();
         maxEdgesCount = ghStorage.getAllEdges().getMaxId();
+        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
         vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
         vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
         final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
 
         // filter by vehicle and level number
-        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
-        {
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
             @Override
-            public final boolean accept( EdgeIteratorState edgeState )
-            {
+            public final boolean accept(EdgeIteratorState edgeState) {
                 if (!super.accept(edgeState))
                     return false;
 
@@ -738,55 +597,25 @@ public final boolean accept( EdgeIteratorState edgeState )
         vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
         calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
 
-        // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        // Use an alternative to PriorityQueue as it has some advantages:
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used.
         //      Important because Graph is increasing until the end.
         //   2. is slightly faster
         //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
         oldPriorities = new int[prepareGraph.getNodes()];
-        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
         return this;
     }
 
-    public int getShortcuts()
-    {
+    public int getShortcuts() {
         return newShortcuts;
     }
 
-    static class IgnoreNodeFilter implements EdgeFilter
-    {
-        int avoidNode;
-        int maxLevel;
-        CHGraph graph;
-
-        public IgnoreNodeFilter( CHGraph g, int maxLevel )
-        {
-            this.graph = g;
-            this.maxLevel = maxLevel;
-        }
-
-        public IgnoreNodeFilter setAvoidNode( int node )
-        {
-            this.avoidNode = node;
-            return this;
-        }
-
-        @Override
-        public final boolean accept( EdgeIteratorState iter )
-        {
-            // ignore if it is skipNode or adjNode is already contracted
-            int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == maxLevel;
-        }
-    }
-
-    private void setOrigEdgeCount( int edgeId, int value )
-    {
+    private void setOrigEdgeCount(int edgeId, int value) {
         edgeId -= maxEdgesCount;
-        if (edgeId < 0)
-        {
-            // ignore setting as every normal edge has original edge count of 1            
+        if (edgeId < 0) {
+            // ignore setting as every normal edge has original edge count of 1
             if (value != 1)
                 throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
                         + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" + ghStorage.getAllEdges().getMaxId());
@@ -798,8 +627,7 @@ private void setOrigEdgeCount( int edgeId, int value )
         originalEdges.setInt(tmp, value);
     }
 
-    private int getOrigEdgeCount( int edgeId )
-    {
+    private int getOrigEdgeCount(int edgeId) {
         edgeId -= maxEdgesCount;
         if (edgeId < 0)
             return 1;
@@ -810,17 +638,13 @@ private int getOrigEdgeCount( int edgeId )
     }
 
     @Override
-    public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
-    {
+    public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
         AbstractBidirAlgo algo;
-        if (ASTAR_BI.equals(opts.getAlgorithm()))
-        {
+        if (ASTAR_BI.equals(opts.getAlgorithm())) {
             algo = createAStarBidirection(graph);
-        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm()))
-        {
+        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
             algo = createDijkstraBidirection(graph);
-        } else
-        {
+        } else {
             throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
         }
 
@@ -830,61 +654,52 @@ public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
     }
 
     private AStarBidirection createAStarBidirection(final Graph graph) {
-        return new AStarBidirection(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
-                {
-                    @Override
-                    protected void initCollections( int nodes )
-                    {
-                        // algorithm with CH does not need that much memory pre allocated
-                        super.initCollections(Math.min(initialCollectionSize, nodes));
-                    }
+        return new AStarBidirection(graph, prepareWeighting, traversalMode) {
+            @Override
+            protected void initCollections(int nodes) {
+                // algorithm with CH does not need that much memory pre allocated
+                super.initCollections(Math.min(initialCollectionSize, nodes));
+            }
 
-                    @Override
-                    protected boolean finished()
-                    {
-                        // we need to finish BOTH searches for CH!
-                        if (finishedFrom && finishedTo)
-                            return true;
+            @Override
+            protected boolean finished() {
+                // we need to finish BOTH searches for CH!
+                if (finishedFrom && finishedTo)
+                    return true;
 
-                        // changed finish condition for CH
-                        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-                    }
+                // changed finish condition for CH
+                return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+            }
 
-                    @Override
-                    protected Path createAndInitPath()
-                    {
-                        bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
-                        return bestPath;
-                    }
+            @Override
+            protected Path createAndInitPath() {
+                bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
+                return bestPath;
+            }
 
-                    @Override
-                    public String getName()
-                    {
-                        return "astarbiCH";
-                    }
+            @Override
+            public String getName() {
+                return "astarbiCH";
+            }
 
-                    @Override
+            @Override
 
-                    public String toString()
-                    {
-                        return getName() + "|" + prepareWeighting;
-                    }
-                };
+            public String toString() {
+                return getName() + "|" + prepareWeighting;
+            }
+        };
     }
 
     private AbstractBidirAlgo createDijkstraBidirection(final Graph graph) {
-        return new DijkstraBidirectionRef(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
-        {
+        return new DijkstraBidirectionRef(graph, prepareWeighting, traversalMode) {
             @Override
-            protected void initCollections( int nodes )
-            {
+            protected void initCollections(int nodes) {
                 // algorithm with CH does not need that much memory pre allocated
                 super.initCollections(Math.min(initialCollectionSize, nodes));
             }
 
             @Override
-            public boolean finished()
-            {
+            public boolean finished() {
                 // we need to finish BOTH searches for CH!
                 if (finishedFrom && finishedTo)
                     return true;
@@ -894,28 +709,61 @@ public boolean finished()
             }
 
             @Override
-            protected Path createAndInitPath()
-            {
-                bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+            protected Path createAndInitPath() {
+                bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
                 return bestPath;
             }
 
             @Override
-            public String getName()
-            {
+            public String getName() {
                 return "dijkstrabiCH";
             }
 
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return getName() + "|" + prepareWeighting;
             }
         };
     }
 
-    static class Shortcut
-    {
+    @Override
+    public String toString() {
+        return "prepare|CH|dijkstrabi";
+    }
+
+    interface ShortcutHandler {
+        void foundShortcut(int u_fromNode, int w_toNode,
+                           double existingDirectWeight, double distance,
+                           EdgeIterator outgoingEdges,
+                           int skippedEdge1, int incomingEdgeOrigCount);
+
+        int getNode();
+    }
+
+    static class IgnoreNodeFilter implements EdgeFilter {
+        int avoidNode;
+        int maxLevel;
+        CHGraph graph;
+
+        public IgnoreNodeFilter(CHGraph g, int maxLevel) {
+            this.graph = g;
+            this.maxLevel = maxLevel;
+        }
+
+        public IgnoreNodeFilter setAvoidNode(int node) {
+            this.avoidNode = node;
+            return this;
+        }
+
+        @Override
+        public final boolean accept(EdgeIteratorState iter) {
+            // ignore if it is skipNode or adjNode is already contracted
+            int node = iter.getAdjNode();
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
+        }
+    }
+
+    static class Shortcut {
         int from;
         int to;
         int skippedEdge1;
@@ -925,8 +773,7 @@ public String toString()
         int originalEdges;
         long flags = PrepareEncoder.getScFwdDir();
 
-        public Shortcut( int from, int to, double weight, double dist )
-        {
+        public Shortcut(int from, int to, double weight, double dist) {
             this.from = from;
             this.to = to;
             this.weight = weight;
@@ -934,8 +781,7 @@ public Shortcut( int from, int to, double weight, double dist )
         }
 
         @Override
-        public int hashCode()
-        {
+        public int hashCode() {
             int hash = 5;
             hash = 23 * hash + from;
             hash = 23 * hash + to;
@@ -944,8 +790,7 @@ public int hashCode()
         }
 
         @Override
-        public boolean equals( Object obj )
-        {
+        public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass())
                 return false;
 
@@ -957,8 +802,7 @@ public boolean equals( Object obj )
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             String str;
             if (flags == PrepareEncoder.getScDirMask())
                 str = from + "<->";
@@ -969,9 +813,78 @@ public String toString()
         }
     }
 
-    @Override
-    public String toString()
-    {
-        return "prepare|CH|dijkstrabi";
+    class CalcShortcutHandler implements ShortcutHandler {
+        int node;
+        int originalEdgesCount;
+        int shortcuts;
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public CalcShortcutHandler setNode(int n) {
+            node = n;
+            originalEdgesCount = 0;
+            shortcuts = 0;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int u_fromNode, int w_toNode,
+                                  double existingDirectWeight, double distance,
+                                  EdgeIterator outgoingEdges,
+                                  int skippedEdge1, int incomingEdgeOrigCount) {
+            shortcuts++;
+            originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
+        }
+    }
+
+    class AddShortcutHandler implements ShortcutHandler {
+        int node;
+
+        public AddShortcutHandler() {
+        }
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public AddShortcutHandler setNode(int n) {
+            shortcuts.clear();
+            node = n;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int u_fromNode, int w_toNode,
+                                  double existingDirectWeight, double existingDistSum,
+                                  EdgeIterator outgoingEdges,
+                                  int skippedEdge1, int incomingEdgeOrigCount) {
+            // FOUND shortcut
+            // but be sure that it is the only shortcut in the collection
+            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
+            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
+            // know yet the levels so we need to determine the correct direction or if both directions
+            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
+            if (shortcuts.containsKey(sc))
+                return;
+
+            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            if (tmpRetSc != null) {
+                // overwrite flags only if skipped edges are identical
+                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge()) {
+                    tmpRetSc.flags = PrepareEncoder.getScDirMask();
+                    return;
+                }
+            }
+
+            shortcuts.put(sc, sc);
+            sc.skippedEdge1 = skippedEdge1;
+            sc.skippedEdge2 = outgoingEdges.getEdge();
+            sc.originalEdges = incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index dbded61e28..6129ed5321 100755
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -20,27 +20,24 @@
 /**
  * The flags are stored differently for shortcuts: just one weight and the direction flags.
  * <p>
+ *
  * @author Peter Karich
  */
-public class PrepareEncoder
-{
+public class PrepareEncoder {
     // shortcut goes in one or both directions is also possible if weight is identical    
     private static final long scFwdDir = 0x1;
     private static final long scBwdDir = 0x2;
     private static final long scDirMask = 0x3;
 
-    public static final long getScDirMask()
-    {
+    public static final long getScDirMask() {
         return scDirMask;
     }
 
-    public static final long getScFwdDir()
-    {
+    public static final long getScFwdDir() {
         return scFwdDir;
     }
 
-    public static final long getScBwdDir()
-    {
+    public static final long getScBwdDir() {
         return scBwdDir;
     }
 
@@ -48,6 +45,7 @@ public static final long getScBwdDir()
      * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
      * changing the directions of flags1.
      * <p>
+     *
      * @return true if flags2 is enabled in both directions or if both flags are pointing into the
      * same direction.
      */
@@ -56,8 +54,7 @@ public static final long getScBwdDir()
     // ->         t | f  | t
     // <-         f | t  | t
     // <->        f | f  | t
-    public static final boolean canBeOverwritten( long flags1, long flags2 )
-    {
+    public static final boolean canBeOverwritten(long flags1, long flags2) {
         return (flags2 & scDirMask) == scDirMask
                 || (flags1 & scDirMask) == (flags2 & scDirMask);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
similarity index 80%
rename from core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
rename to core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
index de56202906..3ac78fc2c2 100755
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
@@ -15,65 +15,62 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.subnetwork;
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
-
-import java.util.*;
-import java.util.concurrent.atomic.AtomicInteger;
-
+import gnu.trove.list.array.TIntArrayList;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import gnu.trove.list.array.TIntArrayList;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Removes nodes which are not part of the large networks. Ie. mostly nodes with no edges at all but
  * also small subnetworks which could be bugs in OSM data or indicate otherwise disconnected areas
  * e.g. via barriers or one way problems - see #86.
  * <p>
+ *
  * @author Peter Karich
  */
-public class PrepareRoutingSubnetworks
-{
+public class PrepareRoutingSubnetworks {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final GraphHopperStorage ghStorage;
+    private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
+    private final List<FlagEncoder> encoders;
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
     private int subnetworks = -1;
-    private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final List<FlagEncoder> encoders;
 
-    public PrepareRoutingSubnetworks( GraphHopperStorage ghStorage, List<FlagEncoder> encoders )
-    {
+    public PrepareRoutingSubnetworks(GraphHopperStorage ghStorage, List<FlagEncoder> encoders) {
         this.ghStorage = ghStorage;
         this.encoders = encoders;
     }
 
-    public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
-    {
+    public PrepareRoutingSubnetworks setMinNetworkSize(int minNetworkSize) {
         this.minNetworkSize = minNetworkSize;
         return this;
     }
 
-    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
-    {
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize(int minOnewayNetworkSize) {
         this.minOneWayNetworkSize = minOnewayNetworkSize;
         return this;
     }
 
-    public void doWork()
-    {
+    public void doWork() {
         if (minNetworkSize <= 0 && minOneWayNetworkSize <= 0)
             return;
 
         int unvisitedDeadEnds = 0;
-        for (FlagEncoder encoder : encoders)
-        {
+        for (FlagEncoder encoder : encoders) {
             // mark edges for one vehicle as inaccessible
             PrepEdgeFilter filter = new PrepEdgeFilter(encoder);
             if (minOneWayNetworkSize > 0)
@@ -93,41 +90,35 @@ public void doWork()
         ghStorage.optimize();
     }
 
-    public int getMaxSubnetworks()
-    {
+    public int getMaxSubnetworks() {
         return subnetworks;
     }
 
     /**
      * This method finds the double linked components according to the specified filter.
      */
-    List<TIntArrayList> findSubnetworks( PrepEdgeFilter filter )
-    {
+    List<TIntArrayList> findSubnetworks(PrepEdgeFilter filter) {
         final FlagEncoder encoder = filter.getEncoder();
         final EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
         int locs = ghStorage.getNodes();
         List<TIntArrayList> list = new ArrayList<TIntArrayList>(100);
         final GHBitSet bs = new GHBitSetImpl(locs);
-        for (int start = 0; start < locs; start++)
-        {
+        for (int start = 0; start < locs; start++) {
             if (bs.contains(start))
                 continue;
 
             final TIntArrayList intList = new TIntArrayList(20);
             list.add(intList);
-            new BreadthFirstSearch()
-            {
+            new BreadthFirstSearch() {
                 int tmpCounter = 0;
 
                 @Override
-                protected GHBitSet createBitSet()
-                {
+                protected GHBitSet createBitSet() {
                     return bs;
                 }
 
                 @Override
-                protected final boolean goFurther( int nodeId )
-                {
+                protected final boolean goFurther(int nodeId) {
                     if (tmpCounter > maxEdgesPerNode.get())
                         maxEdgesPerNode.set(tmpCounter);
 
@@ -137,10 +128,8 @@ protected final boolean goFurther( int nodeId )
                 }
 
                 @Override
-                protected final boolean checkAdjacent( EdgeIteratorState edge )
-                {
-                    if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags()))
-                    {
+                protected final boolean checkAdjacent(EdgeIteratorState edge) {
+                    if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags())) {
                         tmpCounter++;
                         return true;
                     }
@@ -156,8 +145,7 @@ protected final boolean checkAdjacent( EdgeIteratorState edge )
     /**
      * Deletes all but the largest subnetworks.
      */
-    int keepLargeNetworks( PrepEdgeFilter filter, List<TIntArrayList> components )
-    {
+    int keepLargeNetworks(PrepEdgeFilter filter, List<TIntArrayList> components) {
         if (components.size() <= 1)
             return 0;
 
@@ -166,25 +154,21 @@ int keepLargeNetworks( PrepEdgeFilter filter, List<TIntArrayList> components )
         int allRemoved = 0;
         FlagEncoder encoder = filter.getEncoder();
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
-        for (TIntArrayList component : components)
-        {
-            if (maxCount < 0)
-            {
+        for (TIntArrayList component : components) {
+            if (maxCount < 0) {
                 maxCount = component.size();
                 oldComponent = component;
                 continue;
             }
 
             int removedEdges;
-            if (maxCount < component.size())
-            {
+            if (maxCount < component.size()) {
                 // new biggest area found. remove old
                 removedEdges = removeEdges(explorer, encoder, oldComponent, minNetworkSize);
 
                 maxCount = component.size();
                 oldComponent = component;
-            } else
-            {
+            } else {
                 removedEdges = removeEdges(explorer, encoder, component, minNetworkSize);
             }
 
@@ -196,11 +180,9 @@ int keepLargeNetworks( PrepEdgeFilter filter, List<TIntArrayList> components )
         return allRemoved;
     }
 
-    String toString( FlagEncoder encoder, EdgeIterator iter )
-    {
+    String toString(FlagEncoder encoder, EdgeIterator iter) {
         String str = "";
-        while (iter.next())
-        {
+        while (iter.next()) {
             int adjNode = iter.getAdjNode();
             str += adjNode + " (" + ghStorage.getNodeAccess().getLat(adjNode) + "," + ghStorage.getNodeAccess().getLon(adjNode) + "), ";
             str += "speed  (fwd:" + encoder.getSpeed(iter.getFlags()) + ", rev:" + encoder.getReverseSpeed(iter.getFlags()) + "), ";
@@ -217,10 +199,10 @@ String toString( FlagEncoder encoder, EdgeIterator iter )
      * one-way road. This is clearly an error - but is causes the routing to fail when a point gets
      * connected to this small area. This routine removes all these networks from the graph.
      * <p>
+     *
      * @return number of removed edges
      */
-    int removeDeadEndUnvisitedNetworks( final PrepEdgeFilter bothFilter )
-    {
+    int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
         StopWatch sw = new StopWatch(bothFilter.getEncoder() + " findComponents").start();
         final EdgeFilter outFilter = new DefaultEdgeFilter(bothFilter.getEncoder(), false, true);
 
@@ -230,10 +212,8 @@ int removeDeadEndUnvisitedNetworks( final PrepEdgeFilter bothFilter )
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(outFilter);
         int nodes = ghStorage.getNodes();
         GHBitSet ignoreSet = new GHBitSetImpl(ghStorage.getNodes());
-        for (int start = 0; start < nodes; start++)
-        {
-            if (!ghStorage.isNodeRemoved(start))
-            {
+        for (int start = 0; start < nodes; start++) {
+            if (!ghStorage.isNodeRemoved(start)) {
                 EdgeIterator iter = explorer.setBaseNode(start);
                 if (!iter.next())
                     ignoreSet.add(start);
@@ -252,30 +232,26 @@ int removeDeadEndUnvisitedNetworks( final PrepEdgeFilter bothFilter )
      * This method removes the access to edges available from the nodes contained in the components.
      * But only if a components' size is smaller then the specified min value.
      * <p>
+     *
      * @return number of removed edges
      */
-    int removeEdges( final PrepEdgeFilter bothFilter, List<TIntArrayList> components, int min )
-    {
+    int removeEdges(final PrepEdgeFilter bothFilter, List<TIntArrayList> components, int min) {
         // remove edges determined from nodes but only if less than minimum size
         FlagEncoder encoder = bothFilter.getEncoder();
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(bothFilter);
         int removedEdges = 0;
-        for (TIntArrayList component : components)
-        {
+        for (TIntArrayList component : components) {
             removedEdges += removeEdges(explorer, encoder, component, min);
         }
         return removedEdges;
     }
 
-    int removeEdges( EdgeExplorer explorer, FlagEncoder encoder, TIntList component, int min )
-    {
+    int removeEdges(EdgeExplorer explorer, FlagEncoder encoder, TIntList component, int min) {
         int removedEdges = 0;
         if (component.size() < min)
-            for (int i = 0; i < component.size(); i++)
-            {
+            for (int i = 0; i < component.size(); i++) {
                 EdgeIterator edge = explorer.setBaseNode(component.get(i));
-                while (edge.next())
-                {
+                while (edge.next()) {
                     edge.setFlags(encoder.setAccess(edge.getFlags(), false, false));
                     removedEdges++;
                 }
@@ -287,11 +263,9 @@ int removeEdges( EdgeExplorer explorer, FlagEncoder encoder, TIntList component,
     /**
      * Removes nodes if all edges are not accessible. I.e. removes zero degree nodes.
      */
-    void markNodesRemovedIfUnreachable()
-    {
+    void markNodesRemovedIfUnreachable() {
         EdgeExplorer edgeExplorer = ghStorage.createEdgeExplorer();
-        for (int nodeIndex = 0; nodeIndex < ghStorage.getNodes(); nodeIndex++)
-        {
+        for (int nodeIndex = 0; nodeIndex < ghStorage.getNodes(); nodeIndex++) {
             if (detectNodeRemovedForAllEncoders(edgeExplorer, nodeIndex))
                 ghStorage.markNodeRemoved(nodeIndex);
         }
@@ -300,20 +274,18 @@ void markNodesRemovedIfUnreachable()
     /**
      * This method checks if the node is removed or inaccessible for ALL encoders.
      * <p>
+     *
      * @return true if no edges are reachable from the specified nodeIndex for any flag encoder.
      */
-    boolean detectNodeRemovedForAllEncoders( EdgeExplorer edgeExplorerAllEdges, int nodeIndex )
-    {
+    boolean detectNodeRemovedForAllEncoders(EdgeExplorer edgeExplorerAllEdges, int nodeIndex) {
         // we could implement a 'fast check' for several previously marked removed nodes via GHBitSet 
         // removedNodesPerVehicle. The problem is that we would need long-indices but BitSet only supports int (due to nodeIndex*numberOfEncoders)
 
         // if no edges are reachable return true
         EdgeIterator iter = edgeExplorerAllEdges.setBaseNode(nodeIndex);
-        while (iter.next())
-        {
+        while (iter.next()) {
             // if at least on encoder allows one direction return false
-            for (FlagEncoder encoder : encoders)
-            {
+            for (FlagEncoder encoder : encoders) {
                 if (encoder.isBackward(iter.getFlags())
                         || encoder.isForward(iter.getFlags()))
                     return false;
@@ -323,19 +295,16 @@ boolean detectNodeRemovedForAllEncoders( EdgeExplorer edgeExplorerAllEdges, int
         return true;
     }
 
-    static class PrepEdgeFilter extends DefaultEdgeFilter
-    {
+    static class PrepEdgeFilter extends DefaultEdgeFilter {
 
         FlagEncoder encoder;
 
-        public PrepEdgeFilter( FlagEncoder encoder )
-        {
+        public PrepEdgeFilter(FlagEncoder encoder) {
             super(encoder);
             this.encoder = encoder;
         }
 
-        public FlagEncoder getEncoder()
-        {
+        public FlagEncoder getEncoder() {
             return encoder;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansSCCAlgorithm.java b/core/src/main/java/com/graphhopper/routing/subnetwork/TarjansSCCAlgorithm.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/routing/util/TarjansSCCAlgorithm.java
rename to core/src/main/java/com/graphhopper/routing/subnetwork/TarjansSCCAlgorithm.java
index 1977c78851..959e77ba06 100755
--- a/core/src/main/java/com/graphhopper/routing/util/TarjansSCCAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/subnetwork/TarjansSCCAlgorithm.java
@@ -15,10 +15,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.subnetwork;
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIterator;
 import gnu.trove.list.array.TIntArrayList;
@@ -36,8 +37,7 @@
  * See http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm. See
  * http://www.timl.id.au/?p=327 and http://homepages.ecs.vuw.ac.nz/~djp/files/P05.pdf
  */
-public class TarjansSCCAlgorithm
-{
+public class TarjansSCCAlgorithm {
     private final ArrayList<TIntArrayList> components = new ArrayList<TIntArrayList>();
     private final GraphHopperStorage graph;
     private final TIntArrayStack nodeStack;
@@ -45,12 +45,11 @@
     private final GHBitSet ignoreSet;
     private final int[] nodeIndex;
     private final int[] nodeLowLink;
-    private int index = 1;
     private final EdgeFilter edgeFilter;
+    private int index = 1;
 
-    public TarjansSCCAlgorithm( GraphHopperStorage graph, GHBitSet ignoreSet,
-                                final EdgeFilter edgeFilter )
-    {
+    public TarjansSCCAlgorithm(GraphHopperStorage graph, GHBitSet ignoreSet,
+                               final EdgeFilter edgeFilter) {
         this.graph = graph;
         this.nodeStack = new TIntArrayStack();
         this.onStack = new GHBitSetImpl(graph.getNodes());
@@ -63,11 +62,9 @@ public TarjansSCCAlgorithm( GraphHopperStorage graph, GHBitSet ignoreSet,
     /**
      * Find and return list of all strongly connected components in g.
      */
-    public List<TIntArrayList> findComponents()
-    {
+    public List<TIntArrayList> findComponents() {
         int nodes = graph.getNodes();
-        for (int start = 0; start < nodes; start++)
-        {
+        for (int start = 0; start < nodes; start++) {
             if (nodeIndex[start] == 0
                     && !ignoreSet.contains(start)
                     && !graph.isNodeRemoved(start))
@@ -80,24 +77,22 @@ public TarjansSCCAlgorithm( GraphHopperStorage graph, GHBitSet ignoreSet,
     /**
      * Find all components reachable from firstNode, add them to 'components'
      * <p>
+     *
      * @param firstNode start search of SCC at this node
      */
-    private void strongConnect( int firstNode )
-    {
+    private void strongConnect(int firstNode) {
         final Stack<TarjanState> stateStack = new Stack<TarjanState>();
         stateStack.push(TarjanState.startState(firstNode));
 
         // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
         nextState:
 
-        while (!stateStack.empty())
-        {
+        while (!stateStack.empty()) {
             TarjanState state = stateStack.pop();
             final int start = state.start;
             final EdgeIterator iter;
 
-            if (state.isStart())
-            {
+            if (state.isStart()) {
                 // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
                 nodeIndex[start] = index;
                 nodeLowLink[start] = index;
@@ -107,8 +102,7 @@ private void strongConnect( int firstNode )
 
                 iter = graph.createEdgeExplorer(edgeFilter).setBaseNode(start);
 
-            } else
-            {
+            } else {
                 // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
                 iter = state.iter;
 
@@ -118,33 +112,28 @@ private void strongConnect( int firstNode )
 
             // Each element (excluding the first) in the current component should be able to find
             // a successor with a lower nodeLowLink.
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int connectedId = iter.getAdjNode();
                 if (ignoreSet.contains(start))
                     continue;
 
-                if (nodeIndex[connectedId] == 0)
-                {
+                if (nodeIndex[connectedId] == 0) {
                     // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
                     // Ideally we'd just call strongConnectIterative(connectedId);
                     stateStack.push(TarjanState.resumeState(start, iter));
                     stateStack.push(TarjanState.startState(connectedId));
                     continue nextState;
-                } else if (onStack.contains(connectedId))
-                {
+                } else if (onStack.contains(connectedId)) {
                     nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
                 }
             }
 
             // If nodeLowLink == nodeIndex, then we are the first element in a component.
             // Add all nodes higher up on nodeStack to this component.
-            if (nodeIndex[start] == nodeLowLink[start])
-            {
+            if (nodeIndex[start] == nodeLowLink[start]) {
                 TIntArrayList component = new TIntArrayList();
                 int node;
-                while ((node = nodeStack.pop()) != start)
-                {
+                while ((node = nodeStack.pop()) != start) {
                     component.add(node);
                     onStack.remove(node);
                 }
@@ -161,31 +150,26 @@ private void strongConnect( int firstNode )
      * overflow exceptions. State is either 'start' for new nodes or 'resume' for partially
      * traversed nodes.
      */
-    private static class TarjanState
-    {
+    private static class TarjanState {
         final int start;
         final EdgeIterator iter;
 
-        // Iterator only present in 'resume' state.
-        boolean isStart()
-        {
-            return iter == null;
-        }
-
-        private TarjanState( final int start, final EdgeIterator iter )
-        {
+        private TarjanState(final int start, final EdgeIterator iter) {
             this.start = start;
             this.iter = iter;
         }
 
-        public static TarjanState startState( int start )
-        {
+        public static TarjanState startState(int start) {
             return new TarjanState(start, null);
         }
 
-        public static TarjanState resumeState( int start, EdgeIterator iter )
-        {
+        public static TarjanState resumeState(int start, EdgeIterator iter) {
             return new TarjanState(start, iter);
         }
+
+        // Iterator only present in 'resume' state.
+        boolean isStart() {
+            return iter == null;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
index 2ae5ac1c97..d2c2fae262 100755
--- a/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
@@ -2,22 +2,19 @@
 
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.PointList;
+
 import java.util.List;
 
 /**
- *
  * @author Peter Karich
  */
-public class AbstractRoutingTemplate
-{
+public class AbstractRoutingTemplate {
     // result from lookup
     protected List<QueryResult> queryResults;
 
-    protected PointList getWaypoints()
-    {
+    protected PointList getWaypoints() {
         PointList pointList = new PointList(queryResults.size(), true);
-        for (QueryResult qr : queryResults)
-        {
+        for (QueryResult qr : queryResults) {
             pointList.add(qr.getSnappedPoint());
         }
         return pointList;
diff --git a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
index f927d627d3..64f7246b14 100755
--- a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
@@ -24,39 +24,49 @@
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.Parameters.Routing;
 import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.Translation;
+
 import java.util.Collections;
 import java.util.List;
 
+import static com.graphhopper.util.Parameters.Routing.PASS_THROUGH;
+import com.graphhopper.util.shapes.GHPoint;
+
 /**
  * Implementation of a route with no via points but multiple path lists ('alternatives').
  *
  * @author Peter Karich
  */
-final public class AlternativeRoutingTemplate extends ViaRoutingTemplate
-{
-    public AlternativeRoutingTemplate( GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex )
-    {
+final public class AlternativeRoutingTemplate extends ViaRoutingTemplate {
+    public AlternativeRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
         super(ghRequest, ghRsp, locationIndex);
     }
 
     @Override
-    public List<Path> calcPaths( QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts )
-    {
+    public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
+        if (points.size() > 2)
+            throw new IllegalArgumentException("Currently alternative routes work only with start and end point. You tried to use: " + points.size() + " points");
+        
+        return super.lookup(points, encoder);
+    }
+
+    @Override
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         boolean withViaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
         if (withViaTurnPenalty)
-            throw new IllegalStateException("Alternative paths and a viaTurnPenalty at the same time is currently not supported");
+            throw new IllegalArgumentException("Alternative paths and " + PASS_THROUGH + " at the same time is currently not supported");
 
         return super.calcPaths(queryGraph, algoFactory, algoOpts);
     }
 
     @Override
-    public boolean isReady( PathMerger pathMerger, Translation tr )
-    {
+    public boolean isReady(PathMerger pathMerger, Translation tr) {
         if (pathList.isEmpty())
             throw new RuntimeException("Empty paths for alternative route calculation not expected");
 
@@ -65,8 +75,7 @@ public boolean isReady( PathMerger pathMerger, Translation tr )
         altResponse.setWaypoints(wpList);
         ghResponse.add(altResponse);
         pathMerger.doWork(altResponse, Collections.singletonList(pathList.get(0)), tr);
-        for (int index = 1; index < pathList.size(); index++)
-        {
+        for (int index = 1; index < pathList.size(); index++) {
             PathWrapper tmpAltRsp = new PathWrapper();
             tmpAltRsp.setWaypoints(wpList);
             ghResponse.add(tmpAltRsp);
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index 8c8e328fdb..3c0958af8d 100755
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -21,12 +21,12 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.AvoidEdgesWeighting;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.tour.MultiPointTour;
 import com.graphhopper.routing.util.tour.TourStrategy;
+import com.graphhopper.routing.weighting.AvoidEdgesWeighting;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.Helper;
@@ -35,7 +35,9 @@
 import com.graphhopper.util.Parameters.Algorithms.RoundTrip;
 import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.Translation;
+import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -47,18 +49,16 @@
  *
  * @author Peter Karich
  */
-public class RoundTripRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate
-{
+public class RoundTripRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate {
     private final int maxRetries;
     private final GHRequest ghRequest;
     private final GHResponse ghResponse;
-    private PathWrapper altResponse;
     private final LocationIndex locationIndex;
+    private PathWrapper altResponse;
     // result from route
     private List<Path> pathList;
 
-    public RoundTripRoutingTemplate( GHRequest request, GHResponse ghRsp, LocationIndex locationIndex, int maxRetries )
-    {
+    public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationIndex locationIndex, int maxRetries) {
         this.ghRequest = request;
         this.ghResponse = ghRsp;
         this.locationIndex = locationIndex;
@@ -66,8 +66,7 @@ public RoundTripRoutingTemplate( GHRequest request, GHResponse ghRsp, LocationIn
     }
 
     @Override
-    public List<QueryResult> lookup( List<GHPoint> points, FlagEncoder encoder )
-    {
+    public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
         if (points.isEmpty())
             throw new IllegalStateException("For round trip calculation one point is required");
         final double distanceInMeter = ghRequest.getHints().getDouble(RoundTrip.DISTANCE, 10000);
@@ -81,17 +80,15 @@ public RoundTripRoutingTemplate( GHRequest request, GHResponse ghRsp, LocationIn
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
         QueryResult startQR = locationIndex.findClosest(start.lat, start.lon, edgeFilter);
         if (!startQR.isValid())
-            throw new IllegalArgumentException("Cannot find point 0: " + start);
+            throw new PointNotFoundException("Cannot find point 0: " + start, 0);
 
         queryResults.add(startQR);
 
         GHPoint last = points.get(0);
-        for (int i = 0; i < strategy.getNumberOfGeneratedPoints(); i++)
-        {
+        for (int i = 0; i < strategy.getNumberOfGeneratedPoints(); i++) {
             double heading = strategy.getHeadingForIteration(i);
             QueryResult result = generateValidPoint(last, strategy.getDistanceForIteration(i), heading, edgeFilter);
-            if (result == null)
-            {
+            if (result == null) {
                 ghResponse.addError(new IllegalStateException("Could not find a valid point after " + maxRetries + " tries, for the point:" + last));
                 return Collections.emptyList();
             }
@@ -103,14 +100,12 @@ public RoundTripRoutingTemplate( GHRequest request, GHResponse ghRsp, LocationIn
         return queryResults;
     }
 
-    void setQueryResults( List<QueryResult> queryResults )
-    {
+    void setQueryResults(List<QueryResult> queryResults) {
         this.queryResults = queryResults;
     }
 
     @Override
-    public List<Path> calcPaths( QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts )
-    {
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         pathList = new ArrayList<>(queryResults.size() - 1);
 
         AvoidEdgesWeighting avoidPathWeighting = new AvoidEdgesWeighting(algoOpts.getWeighting());
@@ -122,8 +117,7 @@ void setQueryResults( List<QueryResult> queryResults )
 
         long visitedNodesSum = 0L;
         QueryResult start = queryResults.get(0);
-        for (int qrIndex = 1; qrIndex < queryResults.size(); qrIndex++)
-        {
+        for (int qrIndex = 1; qrIndex < queryResults.size(); qrIndex++) {
             RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);
             // instead getClosestNode (which might be a virtual one and introducing unnecessary tails of the route)
             // use next tower node -> getBaseNode or getAdjNode
@@ -148,14 +142,12 @@ void setQueryResults( List<QueryResult> queryResults )
         return pathList;
     }
 
-    public void setPaths( List<Path> pathList )
-    {
+    public void setPaths(List<Path> pathList) {
         this.pathList = pathList;
     }
 
     @Override
-    public boolean isReady( PathMerger pathMerger, Translation tr )
-    {
+    public boolean isReady(PathMerger pathMerger, Translation tr) {
         altResponse = new PathWrapper();
         altResponse.setWaypoints(getWaypoints());
         ghResponse.add(altResponse);
@@ -164,12 +156,10 @@ public boolean isReady( PathMerger pathMerger, Translation tr )
         return true;
     }
 
-    private QueryResult generateValidPoint( GHPoint from, double distanceInMeters, double heading,
-                                            EdgeFilter edgeFilter )
-    {
+    private QueryResult generateValidPoint(GHPoint from, double distanceInMeters, double heading,
+                                           EdgeFilter edgeFilter) {
         int tryCount = 0;
-        while (true)
-        {
+        while (true) {
             GHPoint generatedPoint = Helper.DIST_EARTH.projectCoordinate(from.getLat(), from.getLon(), distanceInMeters, heading);
             QueryResult qr = locationIndex.findClosest(generatedPoint.getLat(), generatedPoint.getLon(), edgeFilter);
             if (qr.isValid())
@@ -184,8 +174,7 @@ private QueryResult generateValidPoint( GHPoint from, double distanceInMeters, d
     }
 
     @Override
-    public int getMaxRetries()
-    {
+    public int getMaxRetries() {
         // with potentially retrying, including generating new route points, for now disabled
         return 1;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
index 1ff1169ad1..d36445fb65 100755
--- a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
@@ -26,6 +26,7 @@
 import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.Translation;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.List;
 
 /**
@@ -34,24 +35,23 @@
  *
  * @author Peter Karich
  */
-public interface RoutingTemplate
-{
+public interface RoutingTemplate {
     /**
      * This method takes the query points and returns the looked up QueryResults.
      */
-    List<QueryResult> lookup( List<GHPoint> points, FlagEncoder encoder );
+    List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder);
 
     /**
      * This method returns a list of Path objects which then can be merged to serve one route with
      * via points or multiple alternative paths.
      */
-    List<Path> calcPaths( QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts );
+    List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts);
 
     /**
      * This method merges the returned paths appropriately e.g. all paths from the list into one
      * PathWrapper of GHResponse or multiple (via / round trip).
      */
-    boolean isReady( PathMerger pathMerger, Translation tr );
+    boolean isReady(PathMerger pathMerger, Translation tr);
 
     /**
      * This method returns the maximum number of full retries of these 3 steps
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index 02d6b3a916..cab5eae5b1 100755
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -26,9 +26,14 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.*;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Parameters.Routing;
+import com.graphhopper.util.PathMerger;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.Translation;
+import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -37,64 +42,58 @@
  *
  * @author Peter Karich
  */
-public class ViaRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate
-{
+public class ViaRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate {
     protected final GHRequest ghRequest;
     protected final GHResponse ghResponse;
     protected final PathWrapper altResponse = new PathWrapper();
-    private final LocationIndex locationIndex;    
+    private final LocationIndex locationIndex;
     // result from route
     protected List<Path> pathList;
 
-    public ViaRoutingTemplate( GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex )
-    {
+    public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
         this.locationIndex = locationIndex;
         this.ghRequest = ghRequest;
         this.ghResponse = ghRsp;
     }
 
     @Override
-    public List<QueryResult> lookup( List<GHPoint> points, FlagEncoder encoder )
-    {
+    public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
         if (points.size() < 2)
             throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
 
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
         queryResults = new ArrayList<>(points.size());
-        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
-        {
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
             GHPoint point = points.get(placeIndex);
             QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
             if (!res.isValid())
-                ghResponse.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+                ghResponse.addError(new PointNotFoundException("Cannot find point " + placeIndex + ": " + point, placeIndex));
 
             queryResults.add(res);
         }
-       
+
         return queryResults;
     }
 
     @Override
-    public List<Path> calcPaths( QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts )
-    {
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         long visitedNodesSum = 0L;
         boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
         int pointCounts = ghRequest.getPoints().size();
         pathList = new ArrayList<>(pointCounts - 1);
         QueryResult fromQResult = queryResults.get(0);
         StopWatch sw;
-        for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++)
-        {
-            if (placeIndex == 1)
-            {
+        for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
+            if (placeIndex == 1) {
                 // enforce start direction
                 queryGraph.enforceHeading(fromQResult.getClosestNode(), ghRequest.getFavoredHeading(0), false);
-            } else if (viaTurnPenalty)
-            {
+            } else if (viaTurnPenalty) {
                 // enforce straight start after via stop
                 Path prevRoute = pathList.get(placeIndex - 2);
-                EdgeIteratorState incomingVirtualEdge = prevRoute.getFinalEdge();
-                queryGraph.enforceHeadingByEdgeId(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge(), false);
+                if (prevRoute.getEdgeCount() > 0) {
+                    EdgeIteratorState incomingVirtualEdge = prevRoute.getFinalEdge();
+                    queryGraph.enforceHeadingByEdgeId(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge(), false);
+                }
             }
 
             QueryResult toQResult = queryResults.get(placeIndex);
@@ -112,8 +111,7 @@ public ViaRoutingTemplate( GHRequest ghRequest, GHResponse ghRsp, LocationIndex
             if (tmpPathList.isEmpty())
                 throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
 
-            for (Path path : tmpPathList)
-            {
+            for (Path path : tmpPathList) {
                 if (path.getTime() < 0)
                     throw new RuntimeException("Time was negative. Please report as bug and include:" + ghRequest);
 
@@ -140,8 +138,7 @@ public ViaRoutingTemplate( GHRequest ghRequest, GHResponse ghRsp, LocationIndex
     }
 
     @Override
-    public boolean isReady( PathMerger pathMerger, Translation tr )
-    {
+    public boolean isReady(PathMerger pathMerger, Translation tr) {
         if (ghRequest.getPoints().size() - 1 != pathList.size())
             throw new RuntimeException("There should be exactly one more points than paths. points:" + ghRequest.getPoints().size() + ", paths:" + pathList.size());
 
@@ -152,8 +149,7 @@ public boolean isReady( PathMerger pathMerger, Translation tr )
     }
 
     @Override
-    public int getMaxRetries()
-    {
+    public int getMaxRetries() {
         return 1;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
index 48190ae277..7d2715e111 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
@@ -20,20 +20,17 @@
 /**
  * @author Peter Karich
  */
-public abstract class AbstractAlgoPreparation
-{
+public abstract class AbstractAlgoPreparation {
     private boolean prepared = false;
 
-    public void doWork()
-    {
+    public void doWork() {
         if (prepared)
             throw new IllegalStateException("Call doWork only once!");
 
         prepared = true;
     }
 
-    public boolean isPrepared()
-    {
+    public boolean isPrepared() {
         return prepared;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 3311925107..ad5cab49ee 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -17,36 +17,47 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.ConditionalTagInspector;
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
+import com.graphhopper.reader.osm.conditional.DateRangeParser;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.util.*;
-
-import java.util.*;
-import com.graphhopper.reader.ConditionalTagInspector;
-import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
-import com.graphhopper.reader.osm.conditional.DateRangeParser;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 /**
  * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
  * EncodingManager to be usable. If you want the full long to be stored you need to enable this in
  * the GraphHopperStorage.
  * <p>
+ *
  * @author Peter Karich
  * @author Nop
  * @see EncodingManager
  */
-public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
-{
-    private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
+public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder {
     protected final static int K_FORWARD = 0, K_BACKWARD = 1;
-    /* Edge Flag Encoder fields */
-    private long nodeBitMask;
-    private long wayBitMask;
-    private long relBitMask;
+    private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
+    /* restriction definitions where order is important */
+    protected final List<String> restrictions = new ArrayList<String>(5);
+    protected final Set<String> intendedValues = new HashSet<String>(5);
+    protected final Set<String> restrictedValues = new HashSet<String>(5);
+    protected final Set<String> ferries = new HashSet<String>(5);
+    protected final Set<String> oneways = new HashSet<String>(5);
+    // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
+    protected final Set<String> absoluteBarriers = new HashSet<String>(5);
+    protected final Set<String> potentialBarriers = new HashSet<String>(5);
+    protected final int speedBits;
+    protected final double speedFactor;
+    private final int maxTurnCosts;
     protected long forwardBit;
     protected long backwardBit;
     protected long directionBitMask;
@@ -55,57 +66,41 @@
     // bit to signal that way is accepted
     protected long acceptBit;
     protected long ferryBit;
-
     protected PMap properties;
-
     // This value determines the maximal possible speed of any road regardless the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
-
-    private EncodedValue turnCostEncoder;
-    private long turnRestrictionBit;
-    private final int maxTurnCosts;
-
     /* processing properties (to be initialized lazy when needed) */
     protected EdgeExplorer edgeOutExplorer;
     protected EdgeExplorer edgeInExplorer;
-
-    /* restriction definitions where order is important */
-    protected final List<String> restrictions = new ArrayList<String>(5);
-    protected final Set<String> intendedValues = new HashSet<String>(5);
-    protected final Set<String> restrictedValues = new HashSet<String>(5);
-    protected final Set<String> ferries = new HashSet<String>(5);
-    protected final Set<String> oneways = new HashSet<String>(5);
-    // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
-    protected final Set<String> absoluteBarriers = new HashSet<String>(5);
-    protected final Set<String> potentialBarriers = new HashSet<String>(5);
+    /* Edge Flag Encoder fields */
+    private long nodeBitMask;
+    private long wayBitMask;
+    private long relBitMask;
+    private EncodedValue turnCostEncoder;
+    private long turnRestrictionBit;
     private boolean blockByDefault = true;
     private boolean blockFords = true;
-    protected final int speedBits;
-    protected final double speedFactor;
     private boolean registered;
 
     private ConditionalTagInspector conditionalTagInspector;
 
-    public AbstractFlagEncoder( PMap properties )
-    {
+    public AbstractFlagEncoder(PMap properties) {
         throw new RuntimeException("This method must be overridden in derived classes");
     }
 
-    public AbstractFlagEncoder( String propertiesStr )
-    {
+    public AbstractFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
     /**
-     * @param speedBits specify the number of bits used for speed
-     * @param speedFactor specify the factor to multiple the stored value (can be used to increase
-     * or decrease accuracy of speed value)
+     * @param speedBits    specify the number of bits used for speed
+     * @param speedFactor  specify the factor to multiple the stored value (can be used to increase
+     *                     or decrease accuracy of speed value)
      * @param maxTurnCosts specify the maximum value used for turn costs, if this value is reached a
-     * turn is forbidden and results in costs of positive infinity.
+     *                     turn is forbidden and results in costs of positive infinity.
      */
-    protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    protected AbstractFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
         this.speedBits = speedBits;
         this.speedFactor = speedFactor;
@@ -119,69 +114,61 @@ protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
     }
 
     // should be called as last method in constructor, move out of the flag encoder somehow
-    protected void init()
-    {
+    protected void init() {
         // we should move 'OSM to object' logic into the DataReader like OSMReader, but this is a major task as we need to convert OSM format into kind of a standard/generic format
         conditionalTagInspector = new ConditionalOSMTagInspector(DateRangeParser.createCalendar(), restrictions, restrictedValues, intendedValues);
     }
 
-    protected void setConditionalTagInspector( ConditionalTagInspector conditionalTagInspector )
-    {
-        this.conditionalTagInspector = conditionalTagInspector;
+    @Override
+    public boolean isRegistered() {
+        return registered;
     }
 
-    public void setRegistered( boolean registered )
-    {
+    public void setRegistered(boolean registered) {
         this.registered = registered;
     }
 
-    @Override
-    public boolean isRegistered()
-    {
-        return registered;
-    }
-
     /**
      * Should potential barriers block when no access limits are given?
      */
-    public void setBlockByDefault( boolean blockByDefault )
-    {
+    public void setBlockByDefault(boolean blockByDefault) {
         this.blockByDefault = blockByDefault;
     }
 
-    public void setBlockFords( boolean blockFords )
-    {
-        this.blockFords = blockFords;
+    public boolean isBlockFords() {
+        return blockFords;
     }
 
-    public boolean isBlockFords()
-    {
-        return blockFords;
+    public void setBlockFords(boolean blockFords) {
+        this.blockFords = blockFords;
     }
 
-    public ConditionalTagInspector getConditionalTagInspector()
-    {
+    public ConditionalTagInspector getConditionalTagInspector() {
         return conditionalTagInspector;
     }
 
+    protected void setConditionalTagInspector(ConditionalTagInspector conditionalTagInspector) {
+        this.conditionalTagInspector = conditionalTagInspector;
+    }
+
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
      * <p>
+     *
      * @return incremented shift value pointing behind the last used bit
      */
-    public int defineNodeBits( int index, int shift )
-    {
+    public int defineNodeBits(int index, int shift) {
         return shift;
     }
 
     /**
      * Defines bits used for edge flags used for access, speed etc.
      * <p>
+     *
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         // define the first 2 speedBits in flags for routing
         forwardBit = 1L << shift;
         backwardBit = 2L << shift;
@@ -201,10 +188,10 @@ public int defineWayBits( int index, int shift )
     /**
      * Defines the bits which are used for relation flags.
      * <p>
+     *
      * @return incremented shift value pointing behind the last used bit
      */
-    public int defineRelationBits( int index, int shift )
-    {
+    public int defineRelationBits(int index, int shift) {
         return shift;
     }
 
@@ -213,42 +200,40 @@ public int defineRelationBits( int index, int shift )
      * In the pre-parsing step this method will be called to determine the useful relation tags.
      * <p>
      */
-    public abstract long handleRelationTags( ReaderRelation relation, long oldRelationFlags );
+    public abstract long handleRelationTags(ReaderRelation relation, long oldRelationFlags);
 
     /**
      * Decide whether a way is routable for a given mode of travel. This skips some ways before
      * handleWayTags is called.
      * <p>
+     *
      * @return the encoded value to indicate if this encoder allows travel or not.
      */
-    public abstract long acceptWay( ReaderWay way );
+    public abstract long acceptWay(ReaderWay way);
 
     /**
      * Analyze properties of a way and create the routing flags. This method is called in the second
      * parsing step.
      */
-    public abstract long handleWayTags( ReaderWay way, long allowed, long relationFlags );
+    public abstract long handleWayTags(ReaderWay way, long allowed, long relationFlags);
 
     /**
      * Parse tags on nodes. Node tags can add to speed (like traffic_signals) where the value is
      * strict negative or blocks access (like a barrier), then the value is strict positive.This
      * method is called in the second parsing step.
      */
-    public long handleNodeTags( ReaderNode node )
-    {
+    public long handleNodeTags(ReaderNode node) {
         // absolute barriers always block
         if (node.hasTag("barrier", absoluteBarriers))
             return directionBitMask;
 
         // movable barriers block if they are not marked as passable
-        if (node.hasTag("barrier", potentialBarriers))
-        {
+        if (node.hasTag("barrier", potentialBarriers)) {
             boolean locked = false;
             if (node.hasTag("locked", "yes"))
                 locked = true;
 
-            for (String res : restrictions)
-            {
+            for (String res : restrictions) {
                 if (!locked && node.hasTag(res, intendedValues))
                     return 0;
 
@@ -264,8 +249,7 @@ public long handleNodeTags( ReaderNode node )
         if (blockFords
                 && (node.hasTag("highway", "ford") || node.hasTag("ford"))
                 && !node.hasTag(restrictions, intendedValues)
-                && !node.hasTag("ford", "no"))
-        {
+                && !node.hasTag("ford", "no")) {
             return directionBitMask;
 
         }
@@ -274,8 +258,7 @@ public long handleNodeTags( ReaderNode node )
     }
 
     @Override
-    public InstructionAnnotation getAnnotation( long flags, Translation tr )
-    {
+    public InstructionAnnotation getAnnotation(long flags, Translation tr) {
         return InstructionAnnotation.EMPTY;
     }
 
@@ -284,8 +267,7 @@ public InstructionAnnotation getAnnotation( long flags, Translation tr )
      * the access bits. But also direction dependent speed values should be swapped too. Keep in
      * mind that this method is performance critical!
      */
-    public long reverseFlags( long flags )
-    {
+    public long reverseFlags(long flags) {
         long dir = flags & directionBitMask;
         if (dir == directionBitMask || dir == 0)
             return flags;
@@ -296,21 +278,18 @@ public long reverseFlags( long flags )
     /**
      * Sets default flags with specified access.
      */
-    public long flagsDefault( boolean forward, boolean backward )
-    {
+    public long flagsDefault(boolean forward, boolean backward) {
         long flags = speedEncoder.setDefaultValue(0);
         return setAccess(flags, forward, backward);
     }
 
     @Override
-    public long setAccess( long flags, boolean forward, boolean backward )
-    {
+    public long setAccess(long flags, boolean forward, boolean backward) {       
         return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
     }
 
     @Override
-    public long setSpeed( long flags, double speed )
-    {
+    public long setSpeed(long flags, double speed) {
         if (speed < 0 || Double.isNaN(speed))
             throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed
                     + ", flags:" + BitUtil.LITTLE.toBitString(flags));
@@ -324,14 +303,12 @@ public long setSpeed( long flags, double speed )
         return speedEncoder.setDoubleValue(flags, speed);
     }
 
-    protected long setLowSpeed( long flags, double speed, boolean reverse )
-    {
+    protected long setLowSpeed(long flags, double speed, boolean reverse) {
         return setAccess(speedEncoder.setDoubleValue(flags, 0), false, false);
     }
 
     @Override
-    public double getSpeed( long flags )
-    {
+    public double getSpeed(long flags) {
         double speedVal = speedEncoder.getDoubleValue(flags);
         if (speedVal < 0)
             throw new IllegalStateException("Speed was negative!? " + speedVal);
@@ -340,34 +317,29 @@ public double getSpeed( long flags )
     }
 
     @Override
-    public long setReverseSpeed( long flags, double speed )
-    {
+    public long setReverseSpeed(long flags, double speed) {
         return setSpeed(flags, speed);
     }
 
     @Override
-    public double getReverseSpeed( long flags )
-    {
+    public double getReverseSpeed(long flags) {
         return getSpeed(flags);
     }
 
     @Override
-    public long setProperties( double speed, boolean forward, boolean backward )
-    {
+    public long setProperties(double speed, boolean forward, boolean backward) {
         return setAccess(setSpeed(0, speed), forward, backward);
     }
 
     @Override
-    public double getMaxSpeed()
-    {
+    public double getMaxSpeed() {
         return speedEncoder.getMaxValue();
     }
 
     /**
      * @return -1 if no maxspeed found
      */
-    protected double getMaxSpeed( ReaderWay way )
-    {
+    protected double getMaxSpeed(ReaderWay way) {
         double maxSpeed = parseSpeed(way.getTag("maxspeed"));
         double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
         if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed))
@@ -381,8 +353,7 @@ protected double getMaxSpeed( ReaderWay way )
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 7;
         hash = 61 * hash + (int) this.directionBitMask;
         hash = 61 * hash + this.toString().hashCode();
@@ -390,8 +361,7 @@ public int hashCode()
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -408,8 +378,7 @@ public boolean equals( Object obj )
     /**
      * @return the speed in km/h
      */
-    protected double parseSpeed( String str )
-    {
+    protected double parseSpeed(String str) {
         if (Helper.isEmpty(str))
             return -1;
 
@@ -426,42 +395,35 @@ protected double parseSpeed( String str )
         if (str.equals("walk") || str.endsWith(":living_street"))
             return 6;
 
-        try
-        {
+        try {
             int val;
             // see https://en.wikipedia.org/wiki/Knot_%28unit%29#Definitions
             int mpInteger = str.indexOf("mp");
-            if (mpInteger > 0)
-            {
+            if (mpInteger > 0) {
                 str = str.substring(0, mpInteger).trim();
                 val = Integer.parseInt(str);
                 return val * DistanceCalcEarth.KM_MILE;
             }
 
             int knotInteger = str.indexOf("knots");
-            if (knotInteger > 0)
-            {
+            if (knotInteger > 0) {
                 str = str.substring(0, knotInteger).trim();
                 val = Integer.parseInt(str);
                 return val * 1.852;
             }
 
             int kmInteger = str.indexOf("km");
-            if (kmInteger > 0)
-            {
+            if (kmInteger > 0) {
                 str = str.substring(0, kmInteger).trim();
-            } else
-            {
+            } else {
                 kmInteger = str.indexOf("kph");
-                if (kmInteger > 0)
-                {
+                if (kmInteger > 0) {
                     str = str.substring(0, kmInteger).trim();
                 }
             }
 
             return Integer.parseInt(str);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return -1;
         }
     }
@@ -470,32 +432,26 @@ protected double parseSpeed( String str )
      * Second parsing step. Invoked after splitting the edges. Currently used to offer a hook to
      * calculate precise speed values based on elevation data stored in the specified edge.
      */
-    public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
-    {
+    public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
     }
 
     /**
      * Special handling for ferry ways.
      */
-    protected double getFerrySpeed( ReaderWay way, double unknownSpeed, double shortTripsSpeed, double longTripsSpeed )
-    {
+    protected double getFerrySpeed(ReaderWay way, double unknownSpeed, double shortTripsSpeed, double longTripsSpeed) {
         long duration = 0;
-        try
-        {
+        try {
             // During the reader process we have converted the duration value into a artificial tag called "duration:seconds".
             duration = Long.parseLong(way.getTag("duration:seconds"));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         // seconds to hours
         double durationInHours = duration / 60d / 60d;
         if (durationInHours > 0)
-            try
-            {
+            try {
                 // Check if our graphhopper specific artificially created estimated_distance way tag is present
                 Number estimatedLength = way.getTag("estimated_distance", null);
-                if (estimatedLength != null)
-                {
+                if (estimatedLength != null) {
                     // to km
                     double val = estimatedLength.doubleValue() / 1000;
                     // If duration AND distance is available we can calculate the speed more precisely
@@ -503,104 +459,87 @@ protected double getFerrySpeed( ReaderWay way, double unknownSpeed, double short
                     double calculatedTripSpeed = val / durationInHours / 1.4;
                     // Plausibility check especially for the case of wrongly used PxM format with the intention to
                     // specify the duration in minutes, but actually using months
-                    if (calculatedTripSpeed > 0.01d)
-                    {
+                    if (calculatedTripSpeed > 0.01d) {
                         // If we have a very short ferry with an average lower compared to what we can encode 
                         // then we need to avoid setting it as otherwise the edge would not be found at all any more.
-                        if (Math.round(calculatedTripSpeed) > speedEncoder.factor / 2)
-                        {
+                        if (Math.round(calculatedTripSpeed) > speedEncoder.factor / 2) {
                             shortTripsSpeed = Math.round(calculatedTripSpeed);
                             if (shortTripsSpeed > getMaxSpeed())
                                 shortTripsSpeed = getMaxSpeed();
                             longTripsSpeed = shortTripsSpeed;
-                        } else
-                        {
+                        } else {
                             // Now we set to the lowest possible still accessible speed. 
                             shortTripsSpeed = speedEncoder.factor / 2;
                         }
-                    } else
-                    {
+                    } else {
                         logger.warn("Unrealistic long duration ignored in way with way ID=" + way.getId() + " : Duration tag value="
                                 + way.getTag("duration") + " (=" + Math.round(duration / 60d) + " minutes)");
                         durationInHours = 0;
                     }
                 }
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
 
-        if (durationInHours == 0)
-        {
+        if (durationInHours == 0) {
             // unknown speed -> put penalty on ferry transport
             return unknownSpeed;
-        } else if (durationInHours > 1)
-        {
+        } else if (durationInHours > 1) {
             // lengthy ferries should be faster than short trip ferry
             return longTripsSpeed;
-        } else
-        {
+        } else {
             return shortTripsSpeed;
         }
     }
 
-    void setWayBitMask( int usedBits, int shift )
-    {
+    void setWayBitMask(int usedBits, int shift) {
         wayBitMask = (1L << usedBits) - 1;
         wayBitMask <<= shift;
     }
 
-    long getWayBitMask()
-    {
+    long getWayBitMask() {
         return wayBitMask;
     }
 
-    void setRelBitMask( int usedBits, int shift )
-    {
+    void setRelBitMask(int usedBits, int shift) {
         relBitMask = (1L << usedBits) - 1;
         relBitMask <<= shift;
     }
 
-    long getRelBitMask()
-    {
+    long getRelBitMask() {
         return relBitMask;
     }
 
-    void setNodeBitMask( int usedBits, int shift )
-    {
+    void setNodeBitMask(int usedBits, int shift) {
         nodeBitMask = (1L << usedBits) - 1;
         nodeBitMask <<= shift;
     }
 
-    long getNodeBitMask()
-    {
+    long getNodeBitMask() {
         return nodeBitMask;
     }
 
     /**
      * Defines the bits reserved for storing turn restriction and turn cost
      * <p>
+     *
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
-    public int defineTurnBits( int index, int shift )
-    {
+    public int defineTurnBits(int index, int shift) {
         if (maxTurnCosts == 0)
             return shift;
 
         // optimization for turn restrictions only
-        else if (maxTurnCosts == 1)
-        {
+        else if (maxTurnCosts == 1) {
             turnRestrictionBit = 1L << shift;
             return shift + 1;
         }
 
         int turnBits = Helper.countBitValue(maxTurnCosts);
-        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts)
-        {
+        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts) {
             // override to avoid expensive Math.round
             @Override
-            public final long getValue( long flags )
-            {
+            public final long getValue(long flags) {
                 // find value
                 flags &= mask;
                 flags >>>= shift;
@@ -611,8 +550,7 @@ public final long getValue( long flags )
     }
 
     @Override
-    public boolean isTurnRestricted( long flags )
-    {
+    public boolean isTurnRestricted(long flags) {
         if (maxTurnCosts == 0)
             return false;
 
@@ -623,8 +561,7 @@ else if (maxTurnCosts == 1)
     }
 
     @Override
-    public double getTurnCost( long flags )
-    {
+    public double getTurnCost(long flags) {
         if (maxTurnCosts == 0)
             return 0;
 
@@ -639,21 +576,18 @@ else if (maxTurnCosts == 1)
     }
 
     @Override
-    public long getTurnFlags( boolean restricted, double costs )
-    {
+    public long getTurnFlags(boolean restricted, double costs) {
         if (maxTurnCosts == 0)
             return 0;
 
-        else if (maxTurnCosts == 1)
-        {
+        else if (maxTurnCosts == 1) {
             if (costs != 0)
                 throw new IllegalArgumentException("Only restrictions are supported");
 
             return restricted ? turnRestrictionBit : 0;
         }
 
-        if (restricted)
-        {
+        if (restricted) {
             if (costs != 0 || Double.isInfinite(costs))
                 throw new IllegalArgumentException("Restricted turn can only have infinite costs (or use 0)");
         } else if (costs >= maxTurnCosts)
@@ -667,33 +601,27 @@ else if (maxTurnCosts == 1)
         return turnCostEncoder.setValue(0L, (int) costs);
     }
 
-    protected boolean isFerry( long internalFlags )
-    {
+    protected boolean isFerry(long internalFlags) {
         return (internalFlags & ferryBit) != 0;
     }
 
-    protected boolean isAccept( long internalFlags )
-    {
+    protected boolean isAccept(long internalFlags) {
         return (internalFlags & acceptBit) != 0;
     }
 
     @Override
-    public boolean isBackward( long flags )
-    {
+    public boolean isBackward(long flags) {
         return (flags & backwardBit) != 0;
     }
 
     @Override
-    public boolean isForward( long flags )
-    {
+    public boolean isForward(long flags) {
         return (flags & forwardBit) != 0;
     }
 
     @Override
-    public long setBool( long flags, int key, boolean value )
-    {
-        switch (key)
-        {
+    public long setBool(long flags, int key, boolean value) {
+        switch (key) {
             case K_FORWARD:
                 return value ? flags | forwardBit : flags & ~forwardBit;
             case K_BACKWARD:
@@ -706,10 +634,8 @@ public long setBool( long flags, int key, boolean value )
     }
 
     @Override
-    public boolean isBool( long flags, int key )
-    {
-        switch (key)
-        {
+    public boolean isBool(long flags, int key) {
+        switch (key) {
             case K_FORWARD:
                 return isForward(flags);
             case K_BACKWARD:
@@ -722,54 +648,46 @@ public boolean isBool( long flags, int key )
     }
 
     @Override
-    public long setLong( long flags, int key, long value )
-    {
+    public long setLong(long flags, int key, long value) {
         throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
     }
 
     @Override
-    public long getLong( long flags, int key )
-    {
+    public long getLong(long flags, int key) {
         throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
     }
 
     @Override
-    public long setDouble( long flags, int key, double value )
-    {
+    public long setDouble(long flags, int key, double value) {
         throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
     }
 
     @Override
-    public double getDouble( long flags, int key )
-    {
+    public double getDouble(long flags, int key) {
         throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
     }
 
     /**
-     * @param way: needed to retrieve tags
+     * @param way:   needed to retrieve tags
      * @param speed: speed guessed e.g. from the road type or other tags
      * @return The assumed speed.
      */
-    protected double applyMaxSpeed( ReaderWay way, double speed )
-    {
+    protected double applyMaxSpeed(ReaderWay way, double speed) {
         double maxSpeed = getMaxSpeed(way);
         // We obay speed limits
-        if (maxSpeed >= 0)
-        {
+        if (maxSpeed >= 0) {
             // We assume that the average speed is 90% of the allowed maximum
             return maxSpeed * 0.9;
         }
         return speed;
     }
 
-    protected String getPropertiesString()
-    {
+    protected String getPropertiesString() {
         return "speed_factor=" + speedFactor + "|speed_bits=" + speedBits + "|turn_costs=" + (maxTurnCosts > 0);
     }
 
     @Override
-    public boolean supports( Class<?> feature )
-    {
+    public boolean supports(Class<?> feature) {
         if (TurnWeighting.class.isAssignableFrom(feature))
             return maxTurnCosts > 0;
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
index 92f6a9468e..d0716d5d77 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
@@ -22,6 +22,5 @@
 /**
  * @author Peter Karich
  */
-public interface AllCHEdgesIterator extends AllEdgesIterator, CHEdgeIterator
-{
+public interface AllCHEdgesIterator extends AllEdgesIterator, CHEdgeIterator {
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index a34bc60d44..3a3e519e83 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -22,8 +22,7 @@
 /**
  * @author Peter Karich
  */
-public interface AllEdgesIterator extends EdgeIterator
-{
+public interface AllEdgesIterator extends EdgeIterator {
     /**
      * @return the maximum edgeId in the graph which is roughly the number of edges.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index ef14776495..6e743fd623 100755
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -23,46 +23,40 @@
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
 
-import static com.graphhopper.util.Helper.*;
+import static com.graphhopper.util.Helper.keepIn;
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
  * <p>
+ *
  * @author Peter Karich
  */
-public class Bike2WeightFlagEncoder extends BikeFlagEncoder
-{
+public class Bike2WeightFlagEncoder extends BikeFlagEncoder {
     private EncodedDoubleValue reverseSpeedEncoder;
 
-    public Bike2WeightFlagEncoder()
-    {
+    public Bike2WeightFlagEncoder() {
         super();
     }
 
-    public Bike2WeightFlagEncoder( String propertiesStr )
-    {
+    public Bike2WeightFlagEncoder(String propertiesStr) {
         super(new PMap(propertiesStr));
     }
 
-    public Bike2WeightFlagEncoder( PMap properties )
-    {
+    public Bike2WeightFlagEncoder(PMap properties) {
         super(properties);
     }
 
-    public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public Bike2WeightFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         shift = super.defineWayBits(index, shift);
         reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
                 getHighwaySpeed("cycleway"), maxPossibleSpeed);
@@ -71,14 +65,12 @@ public int defineWayBits( int index, int shift )
     }
 
     @Override
-    public double getReverseSpeed( long flags )
-    {
+    public double getReverseSpeed(long flags) {
         return reverseSpeedEncoder.getDoubleValue(flags);
     }
 
     @Override
-    public long setReverseSpeed( long flags, double speed )
-    {
+    public long setReverseSpeed(long flags, double speed) {
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
@@ -92,8 +84,7 @@ public long setReverseSpeed( long flags, double speed )
     }
 
     @Override
-    public long handleSpeed( ReaderWay way, double speed, long flags )
-    {
+    public long handleSpeed(ReaderWay way, double speed, long flags) {
         // handle oneways
         flags = super.handleSpeed(way, speed, flags);
         if (isBackward(flags))
@@ -106,8 +97,7 @@ public long handleSpeed( ReaderWay way, double speed, long flags )
     }
 
     @Override
-    protected long setLowSpeed( long flags, double speed, boolean reverse )
-    {
+    protected long setLowSpeed(long flags, double speed, boolean reverse) {
         if (reverse)
             return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
 
@@ -115,8 +105,7 @@ protected long setLowSpeed( long flags, double speed, boolean reverse )
     }
 
     @Override
-    public long flagsDefault( boolean forward, boolean backward )
-    {
+    public long flagsDefault(boolean forward, boolean backward) {
         long flags = super.flagsDefault(forward, backward);
         if (backward)
             return reverseSpeedEncoder.setDefaultValue(flags);
@@ -125,8 +114,7 @@ public long flagsDefault( boolean forward, boolean backward )
     }
 
     @Override
-    public long setProperties( double speed, boolean forward, boolean backward )
-    {
+    public long setProperties(double speed, boolean forward, boolean backward) {
         long flags = super.setProperties(speed, forward, backward);
         if (backward)
             return setReverseSpeed(flags, speed);
@@ -135,8 +123,7 @@ public long setProperties( double speed, boolean forward, boolean backward )
     }
 
     @Override
-    public long reverseFlags( long flags )
-    {
+    public long reverseFlags(long flags) {
         // swap access
         flags = super.reverseFlags(flags);
 
@@ -147,20 +134,17 @@ public long reverseFlags( long flags )
     }
 
     @Override
-    public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
-    {
+    public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         PointList pl = edge.fetchWayGeometry(3);
         if (!pl.is3D())
             throw new IllegalStateException("To support speed calculation based on elevation data it is necessary to enable import of it.");
 
         long flags = edge.getFlags();
 
-        if (way.hasTag("tunnel", "yes") || way.hasTag("bridge", "yes") || way.hasTag("highway", "steps"))
-        {
+        if (way.hasTag("tunnel", "yes") || way.hasTag("bridge", "yes") || way.hasTag("highway", "steps")) {
             // do not change speed
             // note: although tunnel can have a difference in elevation it is very unlikely that the elevation data is correct for a tunnel
-        } else
-        {
+        } else {
             // Decrease the speed for ele increase (incline), and decrease the speed for ele decrease (decline). The speed-decrease 
             // has to be bigger (compared to the speed-increase) for the same elevation difference to simulate loosing energy and avoiding hills.
             // For the reverse speed this has to be the opposite but again keeping in mind that up+down difference.
@@ -178,12 +162,10 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
                 return;
 
             double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
-            if (eleDelta > 0.1)
-            {
+            if (eleDelta > 0.1) {
                 incEleSum = eleDelta;
                 incDist2DSum = fullDist2D;
-            } else if (eleDelta < -0.1)
-            {
+            } else if (eleDelta < -0.1) {
                 decEleSum = -eleDelta;
                 decDist2DSum = fullDist2D;
             }
@@ -217,8 +199,7 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
             double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
             double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
             double maxSpeed = getHighwaySpeed("cycleway");
-            if (isForward(flags))
-            {
+            if (isForward(flags)) {
                 // use weighted mean so that longer incline influences speed more than shorter
                 double speed = getSpeed(flags);
                 double fwdFaster = 1 + 2 * keepIn(fwdDecline, 0, 0.2);
@@ -229,8 +210,7 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
                 flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
 
-            if (isBackward(flags))
-            {
+            if (isBackward(flags)) {
                 double speedReverse = getReverseSpeed(flags);
                 double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
                 bwFaster = bwFaster * bwFaster;
@@ -244,8 +224,7 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "bike2";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 9c7cb40c75..58df1248af 100755
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -19,8 +19,7 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
-import com.graphhopper.reader.osm.conditional.DateRangeParser;
+import com.graphhopper.routing.weighting.PriorityWeighting;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
@@ -32,18 +31,17 @@
 /**
  * Defines bit layout of bicycles (not motorcycles) for speed, access and relations (network).
  * <p>
+ *
  * @author Peter Karich
  * @author Nop
  * @author ratrun
  */
-public class BikeCommonFlagEncoder extends AbstractFlagEncoder
-{
+public class BikeCommonFlagEncoder extends AbstractFlagEncoder {
     /**
      * Reports whether this edge is unpaved.
      */
     public static final int K_UNPAVED = 100;
     protected static final int PUSHING_SECTION_SPEED = 4;
-    private long unpavedBit = 0;
     // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
     protected final HashSet<String> pushingSectionsHighways = new HashSet<String>();
     protected final HashSet<String> oppositeLanes = new HashSet<String>();
@@ -57,17 +55,16 @@
     // convert network tag of bicycle routes into a way route code
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
     protected EncodedValue relationCodeEncoder;
-    private EncodedValue wayTypeEncoder;
     EncodedValue priorityWayEncoder;
-
+    private long unpavedBit = 0;
+    private EncodedValue wayTypeEncoder;
     // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
     private int avoidSpeedLimit;
 
     // This is the specific bicycle class
     private String classBicycleKey;
 
-    protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         // strict set, usually vehicle and agricultural/forestry are ignored by cyclists
         restrictions.addAll(Arrays.asList("bicycle", "vehicle", "access"));
@@ -197,18 +194,16 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
 
         setCyclingNetworkPreference("deprecated", AVOID_AT_ALL_COSTS.getValue());
 
-        setAvoidSpeedLimit(71);       
+        setAvoidSpeedLimit(71);
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeeds.get("cycleway"),
@@ -227,20 +222,16 @@ public int defineWayBits( int index, int shift )
     }
 
     @Override
-    public int defineRelationBits( int index, int shift )
-    {
+    public int defineRelationBits(int index, int shift) {
         relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
         return shift + relationCodeEncoder.getBits();
     }
 
     @Override
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
                 // if bike is NOT explicitly tagged allow bike but only if foot is not specified
                 String bikeTag = way.getTag("bicycle");
                 if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
@@ -277,8 +268,7 @@ public long acceptWay( ReaderWay way )
             return 0;
 
         String sacScale = way.getTag("sac_scale");
-        if (sacScale != null)
-        {
+        if (sacScale != null) {
             if ((way.hasTag("highway", "cycleway"))
                     && (way.hasTag("sac_scale", "hiking")))
                 return acceptBit;
@@ -292,23 +282,21 @@ public long acceptWay( ReaderWay way )
             return acceptBit;
     }
 
-    boolean isSacScaleAllowed( String sacScale )
-    {
+    boolean isSacScaleAllowed(String sacScale) {
         // other scales are nearly impossible by an ordinary bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
         return "hiking".equals(sacScale);
     }
 
     @Override
-    public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-    {
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         int code = 0;
-        if (relation.hasTag("route", "bicycle"))
-        {
+        if (relation.hasTag("route", "bicycle")) {
             Integer val = bikeNetworkToCode.get(relation.getTag("network"));
             if (val != null)
                 code = val;
-        } else if (relation.hasTag("route", "ferry"))
-        {
+            else
+                code = PriorityCode.PREFER.getValue();  // Assume priority of network "lcn" as bicycle route default
+        } else if (relation.hasTag("route", "ferry")) {
             code = AVOID_IF_POSSIBLE.getValue();
         }
 
@@ -323,19 +311,17 @@ public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
      * we can reach the maxspeed for bicycles in case that the road type speed is higher and not
      * just only 90%.
      * <p>
-     * @param way: needed to retrieve tags
+     *
+     * @param way:   needed to retrieve tags
      * @param speed: speed guessed e.g. from the road type or other tags
      * @return The assumed avererage speed.
      */
     @Override
-    protected double applyMaxSpeed( ReaderWay way, double speed )
-    {
+    protected double applyMaxSpeed(ReaderWay way, double speed) {
         double maxSpeed = getMaxSpeed(way);
-        if (maxSpeed >= 0)
-        {
+        if (maxSpeed >= 0) {
             // We strictly obay speed limits, see #600
-            if (maxSpeed < speed)
-            {
+            if (maxSpeed < speed) {
                 return maxSpeed;
             }
         }
@@ -343,27 +329,23 @@ protected double applyMaxSpeed( ReaderWay way, double speed )
     }
 
     @Override
-    public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
-    {
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         if (!isAccept(allowed))
             return 0;
 
         long flags = 0;
         double wayTypeSpeed = getSpeed(way);
-        if (!isFerry(allowed))
-        {
+        if (!isFerry(allowed)) {
             wayTypeSpeed = applyMaxSpeed(way, wayTypeSpeed);
             flags = handleSpeed(way, wayTypeSpeed, flags);
             flags = handleBikeRelated(way, flags, relationFlags > UNCHANGED.getValue());
 
             boolean isRoundabout = way.hasTag("junction", "roundabout");
-            if (isRoundabout)
-            {
+            if (isRoundabout) {
                 flags = setBool(flags, K_ROUNDABOUT, true);
             }
 
-        } else
-        {
+        } else {
             double ferrySpeed = getFerrySpeed(way,
                     highwaySpeeds.get("living_street"),
                     highwaySpeeds.get("track"),
@@ -379,39 +361,37 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
         return flags;
     }
 
-    int getSpeed( ReaderWay way )
-    {
+    int getSpeed(ReaderWay way) {
         int speed = PUSHING_SECTION_SPEED;
         String highwayTag = way.getTag("highway");
         Integer highwaySpeed = highwaySpeeds.get(highwayTag);
 
+        // Under certain conditions we need to increase the speed of pushing sections to the speed of a "highway=cycleway"
+        if (way.hasTag("highway", pushingSectionsHighways)
+                && ((way.hasTag("foot", "yes") && way.hasTag("segregated", "yes"))
+                || way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official")))
+            highwaySpeed = getHighwaySpeed("cycleway");
+
         String s = way.getTag("surface");
-        if (!Helper.isEmpty(s))
-        {
+        if (!Helper.isEmpty(s)) {
             Integer surfaceSpeed = surfaceSpeeds.get(s);
-            if (surfaceSpeed != null)
-            {
+            if (surfaceSpeed != null) {
                 speed = surfaceSpeed;
-                // Boost handling for good surfaces
-                if (highwaySpeed != null && surfaceSpeed > highwaySpeed)
-                {
-                    // Avoid boosting if pushing section
+                // boost handling for good surfaces but avoid boosting if pushing section
+                if (highwaySpeed != null && surfaceSpeed > highwaySpeed) {
                     if (pushingSectionsHighways.contains(highwayTag))
                         speed = highwaySpeed;
                     else
                         speed = surfaceSpeed;
                 }
             }
-        } else
-        {
+        } else {
             String tt = way.getTag("tracktype");
-            if (!Helper.isEmpty(tt))
-            {
+            if (!Helper.isEmpty(tt)) {
                 Integer tInt = trackTypeSpeeds.get(tt);
                 if (tInt != null)
                     speed = tInt;
-            } else if (highwaySpeed != null)
-            {
+            } else if (highwaySpeed != null) {
                 if (!way.hasTag("service"))
                     speed = highwaySpeed;
                 else
@@ -422,17 +402,21 @@ int getSpeed( ReaderWay way )
         // Until now we assumed that the way is no pushing section
         // Now we check that, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
         if (speed > PUSHING_SECTION_SPEED
-                && (way.hasTag("highway", pushingSectionsHighways) || way.hasTag("bicycle", "dismount")))
-        {
-            if (!way.hasTag("bicycle", intendedValues))
-            {
+                && (way.hasTag("highway", pushingSectionsHighways) || way.hasTag("bicycle", "dismount"))) {
+            if (!way.hasTag("bicycle", intendedValues)) {
+                // Here we set the speed for pushing sections and set speed for steps as even lower:
                 if (way.hasTag("highway", "steps"))
                     speed = PUSHING_SECTION_SPEED / 2;
                 else
                     speed = PUSHING_SECTION_SPEED;
-            } else if (way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official"))
-                speed = getHighwaySpeed("cycleway");
-            else
+            } else if (way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official")) {
+                // Here we handle the cases where the OSM tagging results in something similar to "highway=cycleway"
+                speed = highwaySpeeds.get("cycleway");
+            } else {
+                speed = PUSHING_SECTION_SPEED;
+            }
+            // Increase speed in case of segregated
+            if (speed <= PUSHING_SECTION_SPEED && way.hasTag("segregated", "yes"))
                 speed = PUSHING_SECTION_SPEED * 2;
         }
 
@@ -440,8 +424,7 @@ int getSpeed( ReaderWay way )
     }
 
     @Override
-    public InstructionAnnotation getAnnotation( long flags, Translation tr )
-    {
+    public InstructionAnnotation getAnnotation(long flags, Translation tr) {
         int paveType = 0; // paved
         if (isBool(flags, K_UNPAVED))
             paveType = 1; // unpaved        
@@ -451,15 +434,13 @@ public InstructionAnnotation getAnnotation( long flags, Translation tr )
         return new InstructionAnnotation(0, wayName);
     }
 
-    String getWayName( int pavementType, int wayType, Translation tr )
-    {
+    String getWayName(int pavementType, int wayType, Translation tr) {
         String pavementName = "";
         if (pavementType == 1)
             pavementName = tr.tr("unpaved");
 
         String wayTypeName = "";
-        switch (wayType)
-        {
+        switch (wayType) {
             case 0:
                 wayTypeName = "";
                 break;
@@ -474,8 +455,7 @@ String getWayName( int pavementType, int wayType, Translation tr )
                 break;
         }
 
-        if (pavementName.isEmpty())
-        {
+        if (pavementName.isEmpty()) {
             if (wayType == 0 || wayType == 3)
                 return "";
             return wayTypeName;
@@ -489,10 +469,10 @@ String getWayName( int pavementType, int wayType, Translation tr )
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
      * <p>
+     *
      * @return new priority based on priorityFromRelation and on the tags in ReaderWay.
      */
-    protected int handlePriority( ReaderWay way, double wayTypeSpeed, int priorityFromRelation )
-    {
+    protected int handlePriority(ReaderWay way, double wayTypeSpeed, int priorityFromRelation) {
         TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
         if (priorityFromRelation == 0)
             weightToPrioMap.put(0d, UNCHANGED.getValue());
@@ -506,19 +486,15 @@ protected int handlePriority( ReaderWay way, double wayTypeSpeed, int priorityFr
     }
 
     // Conversion of class value to priority. See http://wiki.openstreetmap.org/wiki/Class:bicycle
-    private PriorityCode convertClassValueToPriority( String tagvalue )
-    {
+    private PriorityCode convertClassValueToPriority(String tagvalue) {
         int classvalue;
-        try
-        {
+        try {
             classvalue = Integer.parseInt(tagvalue);
-        } catch (NumberFormatException e)
-        {
+        } catch (NumberFormatException e) {
             return UNCHANGED;
         }
 
-        switch (classvalue)
-        {
+        switch (classvalue) {
             case 3:
                 return BEST;
             case 2:
@@ -540,35 +516,34 @@ private PriorityCode convertClassValueToPriority( String tagvalue )
 
     /**
      * @param weightToPrioMap associate a weight with every priority. This sorted map allows
-     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     *                        subclasses to 'insert' more important priorities as well as overwrite determined priorities.
      */
-    void collect( ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap )
-    {
+    void collect(ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap) {
         String service = way.getTag("service");
         String highway = way.getTag("highway");
-        if (way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official"))
-        {
+        if (way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official")) {
             if ("path".equals(highway))
                 weightToPrioMap.put(100d, VERY_NICE.getValue());
             else
                 weightToPrioMap.put(100d, PREFER.getValue());
         }
 
-        if ("cycleway".equals(highway))
-            weightToPrioMap.put(100d, VERY_NICE.getValue());
+        if ("cycleway".equals(highway)) {
+            if (way.hasTag("foot", intendedValues) && !way.hasTag("segregated", "yes"))
+                weightToPrioMap.put(100d, PREFER.getValue());
+            else
+                weightToPrioMap.put(100d, VERY_NICE.getValue());
+        }
 
         double maxSpeed = getMaxSpeed(way);
-        if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
-        {
-            if (maxSpeed < avoidSpeedLimit)
-            {
+        if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30) {
+            if (maxSpeed < avoidSpeedLimit) {
                 weightToPrioMap.put(40d, PREFER.getValue());
                 if (way.hasTag("tunnel", intendedValues))
                     weightToPrioMap.put(40d, UNCHANGED.getValue());
             }
         } else if (avoidHighwayTags.contains(highway)
-                || maxSpeed >= avoidSpeedLimit && !"track".equals(highway))
-        {
+                || maxSpeed >= avoidSpeedLimit && !"track".equals(highway)) {
             weightToPrioMap.put(50d, REACH_DEST.getValue());
             if (way.hasTag("tunnel", intendedValues))
                 weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
@@ -576,32 +551,35 @@ void collect( ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weigh
 
         if (pushingSectionsHighways.contains(highway)
                 || way.hasTag("bicycle", "use_sidepath")
-                || "parking_aisle".equals(service))
-        {
-            if (way.hasTag("bicycle", "yes"))
-                weightToPrioMap.put(100d, UNCHANGED.getValue());
-            else
-                weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+                || "parking_aisle".equals(service)) {
+            int pushingSectionPrio = AVOID_IF_POSSIBLE.getValue();
+            if (way.hasTag("bicycle", "yes") || way.hasTag("bicycle", "permissive"))
+                pushingSectionPrio = PREFER.getValue();
+            if (way.hasTag("bicycle", "designated") || way.hasTag("bicycle", "official"))
+                pushingSectionPrio = VERY_NICE.getValue();
+            if (way.hasTag("foot", "yes")) {
+                pushingSectionPrio = Math.max(pushingSectionPrio - 1, WORST.getValue());
+                if (way.hasTag("segregated", "yes"))
+                    pushingSectionPrio = Math.min(pushingSectionPrio + 1, BEST.getValue());
+            }
+            weightToPrioMap.put(100d, pushingSectionPrio);
         }
 
         if (way.hasTag("railway", "tram"))
             weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
 
         String classBicycleValue = way.getTag(classBicycleKey);
-        if (classBicycleValue != null)
-        {
+        if (classBicycleValue != null) {
             // We assume that humans are better in classifying preferences compared to our algorithm above -> weight = 100
             weightToPrioMap.put(100d, convertClassValueToPriority(classBicycleValue).getValue());
-        } else
-        {
+        } else {
             String classBicycle = way.getTag("class:bicycle");
             if (classBicycle != null)
                 weightToPrioMap.put(100d, convertClassValueToPriority(classBicycle).getValue());
         }
 
         // Increase the priority for scenic routes or in case that maxspeed limits our average speed as compensation. See #630
-        if (way.hasTag("scenic", "yes") || ((maxSpeed > 0) && (maxSpeed < wayTypeSpeed)))
-        {
+        if (way.hasTag("scenic", "yes") || maxSpeed > 0 && maxSpeed < wayTypeSpeed) {
             if (weightToPrioMap.lastEntry().getValue() < BEST.getValue())
                 // Increase the prio by one step
                 weightToPrioMap.put(110d, weightToPrioMap.lastEntry().getValue() + 1);
@@ -611,8 +589,7 @@ void collect( ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weigh
     /**
      * Handle surface and wayType encoding
      */
-    long handleBikeRelated( ReaderWay way, long encoded, boolean partOfCycleRelation )
-    {
+    long handleBikeRelated(ReaderWay way, long encoded, boolean partOfCycleRelation) {
         String surfaceTag = way.getTag("surface");
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
@@ -620,8 +597,7 @@ long handleBikeRelated( ReaderWay way, long encoded, boolean partOfCycleRelation
         // Populate unpavedBit
         if ("track".equals(highway) && (trackType == null || !"grade1".equals(trackType))
                 || "path".equals(highway) && surfaceTag == null
-                || unpavedSurfaceTags.contains(surfaceTag))
-        {
+                || unpavedSurfaceTags.contains(surfaceTag)) {
             encoded = setBool(encoded, K_UNPAVED, true);
         }
 
@@ -635,8 +611,7 @@ long handleBikeRelated( ReaderWay way, long encoded, boolean partOfCycleRelation
         if (isPushingSection && !partOfCycleRelation || "steps".equals(highway))
             wayType = WayType.PUSHING_SECTION;
 
-        if (way.hasTag("bicycle", intendedValues))
-        {
+        if (way.hasTag("bicycle", intendedValues)) {
             if (isPushingSection && !way.hasTag("bicycle", "designated"))
                 wayType = WayType.OTHER_SMALL_WAY;
             else if (wayType == WayType.OTHER_SMALL_WAY || wayType == WayType.PUSHING_SECTION)
@@ -648,10 +623,8 @@ else if (wayType == WayType.OTHER_SMALL_WAY || wayType == WayType.PUSHING_SECTIO
     }
 
     @Override
-    public long setBool( long flags, int key, boolean value )
-    {
-        switch (key)
-        {
+    public long setBool(long flags, int key, boolean value) {
+        switch (key) {
             case K_UNPAVED:
                 return value ? flags | unpavedBit : flags & ~unpavedBit;
             default:
@@ -660,10 +633,8 @@ public long setBool( long flags, int key, boolean value )
     }
 
     @Override
-    public boolean isBool( long flags, int key )
-    {
-        switch (key)
-        {
+    public boolean isBool(long flags, int key) {
+        switch (key) {
             case K_UNPAVED:
                 return (flags & unpavedBit) != 0;
             default:
@@ -672,10 +643,8 @@ public boolean isBool( long flags, int key )
     }
 
     @Override
-    public double getDouble( long flags, int key )
-    {
-        switch (key)
-        {
+    public double getDouble(long flags, int key) {
+        switch (key) {
             case PriorityWeighting.KEY:
                 return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             default:
@@ -683,13 +652,11 @@ public double getDouble( long flags, int key )
         }
     }
 
-    boolean isPushingSection( ReaderWay way )
-    {
+    boolean isPushingSection(ReaderWay way) {
         return way.hasTag("highway", pushingSectionsHighways) || way.hasTag("railway", "platform") || way.hasTag("bicycle", "dismount");
     }
 
-    protected long handleSpeed( ReaderWay way, double speed, long encoded )
-    {
+    protected long handleSpeed(ReaderWay way, double speed, long encoded) {
         encoded = setSpeed(encoded, speed);
 
         // handle oneways        
@@ -702,8 +669,7 @@ protected long handleSpeed( ReaderWay way, double speed, long encoded )
         if ((isOneway || way.hasTag("junction", "roundabout"))
                 && !way.hasTag("oneway:bicycle", "no")
                 && !way.hasTag("bicycle:backward")
-                && !way.hasTag("cycleway", oppositeLanes))
-        {
+                && !way.hasTag("cycleway", oppositeLanes)) {
             boolean isBackward = way.hasTag("oneway", "-1")
                     || way.hasTag("oneway:bicycle", "-1")
                     || way.hasTag("vehicle:forward", "no")
@@ -713,79 +679,66 @@ protected long handleSpeed( ReaderWay way, double speed, long encoded )
             else
                 encoded |= forwardBit;
 
-        } else
-        {
+        } else {
             encoded |= directionBitMask;
         }
         return encoded;
     }
 
-    private enum WayType
-    {
-        ROAD(0),
-        PUSHING_SECTION(1),
-        CYCLEWAY(2),
-        OTHER_SMALL_WAY(3);
-
-        private final int value;
-
-        private WayType( int value )
-        {
-            this.value = value;
-        }
-
-        public int getValue()
-        {
-            return value;
-        }
-    }
-
-    protected void setHighwaySpeed( String highway, int speed )
-    {
+    protected void setHighwaySpeed(String highway, int speed) {
         highwaySpeeds.put(highway, speed);
     }
 
-    protected int getHighwaySpeed( String key )
-    {
+    protected int getHighwaySpeed(String key) {
         return highwaySpeeds.get(key);
     }
 
-    void setTrackTypeSpeed( String tracktype, int speed )
-    {
+    void setTrackTypeSpeed(String tracktype, int speed) {
         trackTypeSpeeds.put(tracktype, speed);
     }
 
-    void setSurfaceSpeed( String surface, int speed )
-    {
+    void setSurfaceSpeed(String surface, int speed) {
         surfaceSpeeds.put(surface, speed);
     }
 
-    void setCyclingNetworkPreference( String network, int code )
-    {
+    void setCyclingNetworkPreference(String network, int code) {
         bikeNetworkToCode.put(network, code);
     }
 
-    void addPushingSection( String highway )
-    {
+    void addPushingSection(String highway) {
         pushingSectionsHighways.add(highway);
     }
 
     @Override
-    public boolean supports( Class<?> feature )
-    {
+    public boolean supports(Class<?> feature) {
         if (super.supports(feature))
             return true;
 
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
 
-    public void setAvoidSpeedLimit( int limit )
-    {
+    public void setAvoidSpeedLimit(int limit) {
         avoidSpeedLimit = limit;
     }
 
-    protected void setSpecificClassBicycle( String subkey )
-    {
+    protected void setSpecificClassBicycle(String subkey) {
         classBicycleKey = "class:bicycle:" + subkey;
     }
+
+    private enum WayType {
+        ROAD(0),
+        PUSHING_SECTION(1),
+        CYCLEWAY(2),
+        OTHER_SMALL_WAY(3);
+
+        private final int value;
+
+        private WayType(int value) {
+            this.value = value;
+        }
+
+        public int getValue() {
+            return value;
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index f3e2ad8133..34debf8364 100755
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -23,23 +23,20 @@
 /**
  * Specifies the settings for cycletouring/trekking
  * <p>
+ *
  * @author ratrun
  * @author Peter Karich
  */
-public class BikeFlagEncoder extends BikeCommonFlagEncoder
-{
-    public BikeFlagEncoder()
-    {
+public class BikeFlagEncoder extends BikeCommonFlagEncoder {
+    public BikeFlagEncoder() {
         this(4, 2, 0);
     }
 
-    public BikeFlagEncoder( String propertiesString )
-    {
+    public BikeFlagEncoder(String propertiesString) {
         this(new PMap(propertiesString));
     }
 
-    public BikeFlagEncoder( PMap properties )
-    {
+    public BikeFlagEncoder(PMap properties) {
         this((int) properties.getLong("speed_bits", 4),
                 properties.getLong("speed_factor", 2),
                 properties.getBool("turn_costs", false) ? 1 : 0);
@@ -47,8 +44,7 @@ public BikeFlagEncoder( PMap properties )
         this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public BikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         addPushingSection("path");
         addPushingSection("footway");
@@ -71,27 +67,24 @@ public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
 
         absoluteBarriers.add("kissing_gate");
         setSpecificClassBicycle("touring");
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    boolean isPushingSection( ReaderWay way )
-    {
+    boolean isPushingSection(ReaderWay way) {
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return super.isPushingSection(way) || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "bike";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java
new file mode 100644
index 0000000000..5a0a678be2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java
@@ -0,0 +1,101 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.util.PMap;
+
+/**
+ * Defines bit layout for cars with four wheel drive
+ *
+ * @author zstadler
+ */
+public class Car4WDFlagEncoder extends CarFlagEncoder {
+
+    public Car4WDFlagEncoder() {
+        this(5, 5, 0);
+    }
+
+    public Car4WDFlagEncoder(PMap properties) {
+        super(properties);
+    }
+
+    public Car4WDFlagEncoder(String propertiesStr) {
+        this(new PMap(propertiesStr));
+    }
+
+    public Car4WDFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
+        super(speedBits, speedFactor, maxTurnCosts);
+
+        init();
+
+        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+    }
+
+    @Override
+    public int getVersion() {
+        return 1;
+    }
+
+    @Override
+    public long acceptWay(ReaderWay way) {
+        // TODO: Ferries have conditionals, like opening hours or are closed during some time in the year
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
+                String motorcarTag = way.getTag("motorcar");
+                if (motorcarTag == null)
+                    motorcarTag = way.getTag("motor_vehicle");
+
+                if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle") || "yes".equals(motorcarTag))
+                    return acceptBit | ferryBit;
+            }
+            return 0;
+        }
+
+        if (!defaultSpeedMap.containsKey(highwayValue))
+            return 0;
+
+        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+            return 0;
+
+        // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty()) {
+            if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
+
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
+            return 0;
+
+        if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
+            return 0;
+        else
+            return acceptBit;
+    }
+
+    @Override
+    public String toString() {
+        return "car4wd";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index d3319bfcae..d7ee15b59e 100755
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -27,13 +27,16 @@
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
  * <p>
+ *
  * @author Peter Karich
  * @author Nop
  */
-public class CarFlagEncoder extends AbstractFlagEncoder
-{
+public class CarFlagEncoder extends AbstractFlagEncoder {
     protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<String, Integer>();
     protected final Set<String> badSurfaceSpeedMap = new HashSet<String>();
+
+    // This value determines the maximal possible on roads with bad surfaces
+    protected int badSurfaceSpeed;
     /**
      * A map which associates string to speed. Get some impression:
      * http://www.itoworld.com/map/124#fullscreen
@@ -41,27 +44,24 @@
      */
     protected final Map<String, Integer> defaultSpeedMap = new HashMap<String, Integer>();
 
-    public CarFlagEncoder()
-    {
+    public CarFlagEncoder() {
         this(5, 5, 0);
     }
 
-    public CarFlagEncoder( PMap properties )
-    {
+    public CarFlagEncoder(PMap properties) {
         this((int) properties.getLong("speed_bits", 5),
                 properties.getDouble("speed_factor", 5),
                 properties.getBool("turn_costs", false) ? 1 : 0);
         this.properties = properties;
         this.setBlockFords(properties.getBool("block_fords", true));
+        this.setBlockByDefault(properties.getBool("block_barriers", true));        
     }
 
-    public CarFlagEncoder( String propertiesStr )
-    {
+    public CarFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public CarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
         restrictedValues.add("private");
@@ -92,9 +92,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
 
         trackTypeSpeedMap.put("grade1", 20); // paved
         trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
-        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
-        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
-        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials        
 
         badSurfaceSpeedMap.add("cobblestone");
         badSurfaceSpeedMap.add("grass_paver");
@@ -104,6 +102,11 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         badSurfaceSpeedMap.add("dirt");
         badSurfaceSpeedMap.add("ground");
         badSurfaceSpeedMap.add("grass");
+        badSurfaceSpeedMap.add("unpaved");
+        badSurfaceSpeedMap.add("compacted");
+
+        // limit speed on bad surfaces to 30 km/h
+        badSurfaceSpeed = 30;
 
         maxPossibleSpeed = 140;
 
@@ -132,13 +135,12 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         defaultSpeedMap.put("road", 20);
         // forestry stuff
         defaultSpeedMap.put("track", 15);
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
@@ -146,8 +148,7 @@ public int getVersion()
      * Define the place of the speedBits in the edge flags for car.
      */
     @Override
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"),
@@ -155,18 +156,15 @@ public int defineWayBits( int index, int shift )
         return shift + speedEncoder.getBits();
     }
 
-    protected double getSpeed( ReaderWay way )
-    {
+    protected double getSpeed(ReaderWay way) {
         String highwayValue = way.getTag("highway");
         Integer speed = defaultSpeedMap.get(highwayValue);
         if (speed == null)
             throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
 
-        if (highwayValue.equals("track"))
-        {
+        if (highwayValue.equals("track")) {
             String tt = way.getTag("tracktype");
-            if (!Helper.isEmpty(tt))
-            {
+            if (!Helper.isEmpty(tt)) {
                 Integer tInt = trackTypeSpeedMap.get(tt);
                 if (tInt != null)
                     speed = tInt;
@@ -177,14 +175,11 @@ protected double getSpeed( ReaderWay way )
     }
 
     @Override
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         // TODO: Ferries have conditionals, like opening hours or are closed during some time in the year
         String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
                 String motorcarTag = way.getTag("motorcar");
                 if (motorcarTag == null)
                     motorcarTag = way.getTag("motor_vehicle");
@@ -195,8 +190,7 @@ public long acceptWay( ReaderWay way )
             return 0;
         }
 
-        if ("track".equals(highwayValue))
-        {
+        if ("track".equals(highwayValue)) {
             String tt = way.getTag("tracktype");
             if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
                 return 0;
@@ -210,8 +204,7 @@ public long acceptWay( ReaderWay way )
 
         // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
         String firstValue = way.getFirstPriorityTag(restrictions);
-        if (!firstValue.isEmpty())
-        {
+        if (!firstValue.isEmpty()) {
             if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
                 return 0;
             if (intendedValues.contains(firstValue))
@@ -229,27 +222,22 @@ public long acceptWay( ReaderWay way )
     }
 
     @Override
-    public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-    {
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         return oldRelationFlags;
     }
 
     @Override
-    public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
-    {
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         if (!isAccept(allowed))
             return 0;
 
         long flags = 0;
-        if (!isFerry(allowed))
-        {
+        if (!isFerry(allowed)) {
             // get assumed speed from highway type
             double speed = getSpeed(way);
             speed = applyMaxSpeed(way, speed);
 
-            // limit speed to max 30 km/h if bad surface
-            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
-                speed = 30;
+            speed = applyBadSurfaceSpeed(way, speed);
 
             flags = setSpeed(flags, speed);
 
@@ -257,8 +245,7 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
             if (isRoundabout)
                 flags = setBool(flags, K_ROUNDABOUT, true);
 
-            if (isOneway(way) || isRoundabout)
-            {
+            if (isOneway(way) || isRoundabout) {
                 if (isBackwardOneway(way))
                     flags |= backwardBit;
 
@@ -267,8 +254,7 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
             } else
                 flags |= directionBitMask;
 
-        } else
-        {
+        } else {
             double ferrySpeed = getFerrySpeed(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
             flags = setSpeed(flags, ferrySpeed);
             flags |= directionBitMask;
@@ -280,8 +266,7 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
     /**
      * make sure that isOneway is called before
      */
-    protected boolean isBackwardOneway( ReaderWay way )
-    {
+    protected boolean isBackwardOneway(ReaderWay way) {
         return way.hasTag("oneway", "-1")
                 || way.hasTag("vehicle:forward", "no")
                 || way.hasTag("motor_vehicle:forward", "no");
@@ -290,15 +275,13 @@ protected boolean isBackwardOneway( ReaderWay way )
     /**
      * make sure that isOneway is called before
      */
-    protected boolean isForwardOneway( ReaderWay way )
-    {
+    protected boolean isForwardOneway(ReaderWay way) {
         return !way.hasTag("oneway", "-1")
                 && !way.hasTag("vehicle:forward", "no")
                 && !way.hasTag("motor_vehicle:forward", "no");
     }
 
-    protected boolean isOneway( ReaderWay way )
-    {
+    protected boolean isOneway(ReaderWay way) {
         return way.hasTag("oneway", oneways)
                 || way.hasTag("vehicle:backward")
                 || way.hasTag("vehicle:forward")
@@ -306,19 +289,15 @@ protected boolean isOneway( ReaderWay way )
                 || way.hasTag("motor_vehicle:forward");
     }
 
-    public String getWayInfo( ReaderWay way )
-    {
+    public String getWayInfo(ReaderWay way) {
         String str = "";
         String highwayValue = way.getTag("highway");
         // for now only motorway links
-        if ("motorway_link".equals(highwayValue))
-        {
+        if ("motorway_link".equals(highwayValue)) {
             String destination = way.getTag("destination");
-            if (!Helper.isEmpty(destination))
-            {
+            if (!Helper.isEmpty(destination)) {
                 int counter = 0;
-                for (String d : destination.split(";"))
-                {
+                for (String d : destination.split(";")) {
                     if (d.trim().isEmpty())
                         continue;
 
@@ -338,10 +317,20 @@ public String getWayInfo( ReaderWay way )
         else
             return "destination: " + str;
     }
+    /**
+     * @param way:   needed to retrieve tags
+     * @param speed: speed guessed e.g. from the road type or other tags
+     * @return The assumed speed
+     */
+    protected double applyBadSurfaceSpeed(ReaderWay way, double speed) {
+        // limit speed if bad surface
+        if (badSurfaceSpeed > 0 && speed > badSurfaceSpeed && way.hasTag("surface", badSurfaceSpeedMap))
+            speed = badSurfaceSpeed;
+        return speed;
+    }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "car";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
new file mode 100644
index 0000000000..83d5170055
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -0,0 +1,516 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.ReaderRelation;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.GenericWeighting;
+import com.graphhopper.util.ConfigMap;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * This encoder tries to store all way information into a 32 or 64bit value. Later extendable to
+ * multiple ints or bytes. The assumption is that edge.getFlags is cheap and can be later replaced
+ * by e.g. one or more (cheap) calls of edge.getData(index).
+ * <p>
+ * Currently limited to motor vehicle but later could handle different modes like foot or bike too.
+ *
+ * @author Peter Karich
+ */
+public class DataFlagEncoder extends AbstractFlagEncoder {
+    private static final Map<String, Double> DEFAULT_SPEEDS = new LinkedHashMap<String, Double>() {
+        {
+            put("motorway", 100d);
+            put("motorway_link", 70d);
+            put("motorroad", 90d);
+            put("trunk", 70d);
+            put("trunk_link", 65d);
+            put("primary", 65d);
+            put("primary_link", 60d);
+            put("secondary", 60d);
+            put("secondary_link", 50d);
+            put("tertiary", 50d);
+            put("tertiary_link", 40d);
+            put("unclassified", 30d);
+            put("residential", 30d);
+            put("living_street", 5d);
+            put("service", 20d);
+            put("road", 20d);
+            put("forestry", 15d);
+            put("track", 15d);
+        }
+    };
+    private final Map<String, Integer> surfaceMap = new HashMap<>();
+    private final Map<String, Integer> highwayMap = new HashMap<>();
+    private final List<String> transportModeList = new ArrayList<>();
+    private final Map<String, Integer> transportModeMap = new HashMap<>();
+    private final int transportModeTunnelValue;
+    private final int transportModeBridgeValue;
+    private long bit0;
+    private EncodedDoubleValue carFwdMaxspeedEncoder;
+    private EncodedDoubleValue carBwdMaxspeedEncoder;
+    private EncodedValue surfaceEncoder;
+    private EncodedValue highwayEncoder;
+    private EncodedValue transportModeEncoder;
+
+    public DataFlagEncoder() {
+        // TODO include turn information
+        super(5, 5, 0);
+
+        maxPossibleSpeed = 140;
+        //
+        // TODO restrictions (agricultural, emergency, destination, private, delivery, customers)
+        //
+
+        // highway and certain tags like ferry and shuttle_train which can be used here (no logical overlap)
+        List<String> highwayList = Arrays.asList(
+                /* reserve index=0 for unset roads (not accessible) */
+                "_default",
+                "motorway", "motorway_link", "motorroad",
+                "trunk", "trunk_link",
+                "primary", "primary_link", "secondary", "secondary_link", "tertiary", "tertiary_link",
+                "unclassified", "residential", "living_street", "service", "road", "track",
+                "forestry", "cycleway", "steps", "path", "footway", "pedestrian",
+                "ferry", "shuttle_train");
+        int counter = 0;
+        for (String hw : highwayList) {
+            highwayMap.put(hw, counter++);
+        }
+
+        // We need transport mode additionally to highway e.g. a secondary highway can be a tunnel.
+        // Also 'roundabout' needs a separate bit as a tunnel or a bridge can be a roundabout at the same time.
+        transportModeList.addAll(Arrays.asList("_default", "bridge", "tunnel", "ford", "aerialway"));
+        counter = 0;
+        for (String tm : transportModeList) {
+            transportModeMap.put(tm, counter++);
+        }
+        transportModeTunnelValue = transportModeMap.get("tunnel");
+        transportModeBridgeValue = transportModeMap.get("bridge");
+
+        List<String> surfaceList = Arrays.asList("_default", "asphalt", "unpaved", "paved", "gravel",
+                "ground", "dirt", "grass", "concrete", "paving_stones", "sand", "compacted", "cobblestone", "mud", "ice");
+        counter = 0;
+        for (String s : surfaceList) {
+            surfaceMap.put(s, counter++);
+        }
+
+        // hiking or biking or bus routes
+        // detect border crossing -> barrier:border_control
+    }
+
+    @Override
+    public int defineWayBits(int index, int shift) {
+        // TODO use this approach in other flag encoders too then we can do a global swap for all and bit0 can be at position 0!
+        bit0 = 1L << shift;
+        shift++;
+
+        // TODO support different vehicle types, currently just roundabout and fwd&bwd for one vehicle type
+        shift = super.defineWayBits(index, shift);
+
+        carFwdMaxspeedEncoder = new EncodedDoubleValue("car fwd maxspeed", shift, speedBits, speedFactor, 0, maxPossibleSpeed, true);
+        shift += carFwdMaxspeedEncoder.getBits();
+
+        carBwdMaxspeedEncoder = new EncodedDoubleValue("car bwd maxspeed", shift, speedBits, speedFactor, 0, maxPossibleSpeed, true);
+        shift += carBwdMaxspeedEncoder.getBits();
+
+        highwayEncoder = new EncodedValue("highway", shift, 5, 1, 0, highwayMap.size(), true);
+        shift += highwayEncoder.getBits();
+
+        surfaceEncoder = new EncodedValue("surface", shift, 4, 1, 0, surfaceMap.size(), true);
+        shift += surfaceEncoder.getBits();
+
+        transportModeEncoder = new EncodedValue("transport mode", shift, 3, 1, 0, transportModeMap.size(), true);
+        shift += transportModeEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+        return 0;
+    }
+
+    @Override
+    public long acceptWay(ReaderWay way) {
+        // important to skip unsupported highways, otherwise too many have to be removed after graph creation
+        // and node removal is not yet designed for that
+        if (getHighwayValue(way) == 0)
+            return 0;
+
+        return acceptBit;
+    }
+
+    int getHighwayValue(ReaderWay way) {
+        String highwayValue = way.getTag("highway");
+        Integer hwValue = highwayMap.get(highwayValue);
+        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+            hwValue = 0;
+
+        if (hwValue == null) {
+            hwValue = 0;
+            if (way.hasTag("route", ferries)) {
+                String motorcarTag = way.getTag("motorcar");
+                if (motorcarTag == null)
+                    motorcarTag = way.getTag("motor_vehicle");
+
+                if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle")
+                        || "yes".equals(motorcarTag))
+                    hwValue = highwayMap.get("ferry");
+            }
+        }
+        return hwValue;
+    }
+
+    @Override
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
+        if (!isAccept(allowed))
+            return 0;
+
+        try {
+            // HIGHWAY
+            int hwValue = getHighwayValue(way);
+            // exclude any routing like if you have car and need to exclude all rails or ships
+            if (hwValue == 0)
+                return 0;
+
+            long flags = 0;
+            if (isFerry(allowed)) {
+                hwValue = highwayMap.get("ferry");
+            }
+
+            flags = highwayEncoder.setValue(0, hwValue);
+
+            // MAXSPEED
+            double maxSpeed = parseSpeed(way.getTag("maxspeed"));
+            double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
+            if (fwdSpeed < 0 || maxSpeed > 0 && maxSpeed < fwdSpeed)
+                fwdSpeed = maxSpeed;
+
+            double bwdSpeed = parseSpeed(way.getTag("maxspeed:backward"));
+            if (bwdSpeed < 0 || maxSpeed > 0 && maxSpeed < bwdSpeed)
+                bwdSpeed = maxSpeed;
+
+            // 0 is reserved for default i.e. no maxspeed sign (does not imply no speed limit)
+            // TODO and 140 should be used for "none" speed limit on German Autobahn
+            if (fwdSpeed > 0)
+                flags = carFwdMaxspeedEncoder.setDoubleValue(flags, fwdSpeed);
+
+            if (bwdSpeed > 0)
+                flags = carBwdMaxspeedEncoder.setDoubleValue(flags, bwdSpeed);
+
+            // SURFACE
+            String surfaceValue = way.getTag("surface");
+            Integer sValue = surfaceMap.get(surfaceValue);
+            if (sValue == null)
+                sValue = 0;
+            flags = surfaceEncoder.setValue(flags, sValue);
+
+            // TRANSPORT MODE
+            int tmValue = 0;
+            for (String tm : transportModeList) {
+                if (way.hasTag(tm)) {
+                    tmValue = transportModeMap.get(tm);
+                    break;
+                }
+            }
+            flags = transportModeEncoder.setValue(flags, tmValue);
+
+            // ROUNDABOUT
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+                flags = setBool(flags, K_ROUNDABOUT, true);
+
+            // ONEWAY (currently car only)
+            boolean isOneway = way.hasTag("oneway", oneways)
+                    || way.hasTag("vehicle:backward")
+                    || way.hasTag("vehicle:forward")
+                    || way.hasTag("motor_vehicle:backward")
+                    || way.hasTag("motor_vehicle:forward");
+
+            if (isOneway || isRoundabout) {
+                boolean isBackward = way.hasTag("oneway", "-1")
+                        || way.hasTag("vehicle:forward", "no")
+                        || way.hasTag("motor_vehicle:forward", "no");
+                if (isBackward)
+                    flags |= backwardBit;
+                else
+                    flags |= forwardBit;
+            } else
+                flags |= directionBitMask;
+
+            if (!isBit0Empty(flags))
+                throw new IllegalStateException("bit0 has to be empty on creation");
+
+            return flags;
+        } catch (Exception ex) {
+            throw new RuntimeException("Error while parsing way " + way.toString(), ex);
+        }
+    }
+
+    @Override
+    public long reverseFlags(long flags) {
+        // see #728 for an explanation
+        return flags ^ bit0;
+    }
+
+    /**
+     * Interpret flags in forward direction if bit0 is empty. This method is used when accessing
+     * direction dependent values and avoid reverse flags, see #728.
+     */
+    private boolean isBit0Empty(long flags) {
+        return (flags & bit0) == 0;
+    }
+
+    public int getHighway(EdgeIteratorState edge) {
+        return (int) highwayEncoder.getValue(edge.getFlags());
+    }
+
+    public String getHighwayAsString(EdgeIteratorState edge) {
+        int val = getHighway(edge);
+        for (Entry<String, Integer> e : highwayMap.entrySet()) {
+            if (e.getValue() == val)
+                return e.getKey();
+        }
+        return null;
+    }
+
+    public double[] getHighwaySpeedMap(Map<String, Double> map) {
+        double[] res = new double[highwayMap.size()];
+        for (Entry<String, Double> e : map.entrySet()) {
+            Integer integ = highwayMap.get(e.getKey());
+            if (integ == null)
+                throw new IllegalArgumentException("Graph not prepared for highway=" + e.getKey());
+
+            if (e.getValue() < 0)
+                throw new IllegalArgumentException("Negative speed " + e.getValue() + " not allowed. highway=" + e.getKey());
+
+            res[integ] = e.getValue();
+        }
+        return res;
+    }
+
+    public int getSurface(EdgeIteratorState edge) {
+        return (int) surfaceEncoder.getValue(edge.getFlags());
+    }
+
+    public String getSurfaceAsString(EdgeIteratorState edge) {
+        int val = getSurface(edge);
+        for (Entry<String, Integer> e : surfaceMap.entrySet()) {
+            if (e.getValue() == val)
+                return e.getKey();
+        }
+        return null;
+    }
+
+    public int getTransportMode(EdgeIteratorState edge) {
+        return (int) transportModeEncoder.getValue(edge.getFlags());
+    }
+
+    public boolean isTransportModeTunnel(EdgeIteratorState edge) {
+        return transportModeEncoder.getValue(edge.getFlags()) == this.transportModeTunnelValue;
+    }
+
+    public boolean isTransportModeBridge(EdgeIteratorState edge) {
+        return transportModeEncoder.getValue(edge.getFlags()) == this.transportModeBridgeValue;
+    }
+
+    public String getTransportModeAsString(EdgeIteratorState edge) {
+        int val = getTransportMode(edge);
+        for (Entry<String, Integer> e : transportModeMap.entrySet()) {
+            if (e.getValue() == val)
+                return e.getKey();
+        }
+        return null;
+    }
+
+    public double[] getTransportModeMap(Map<String, Double> map) {
+        double[] res = new double[transportModeMap.size()];
+        for (Entry<String, Double> e : map.entrySet()) {
+            Integer integ = transportModeMap.get(e.getKey());
+            if (integ == null)
+                throw new IllegalArgumentException("Graph not prepared for transport_mode=" + e.getKey());
+
+            if (e.getValue() < 0)
+                throw new IllegalArgumentException("Negative speed " + e.getValue() + " not allowed. transport_mode=" + e.getKey());
+
+            res[integ] = e.getValue();
+        }
+        return res;
+    }
+
+    public boolean isRoundabout(EdgeIteratorState edge) {
+        // use direct call instead of isBool
+        return (edge.getFlags() & roundaboutBit) != 0;
+    }
+
+    public int getAccessType(String accessStr) {
+        // access, motor_vehicle, bike, foot, hgv, bus
+        return 0;
+    }
+
+    public final boolean isForward(EdgeIteratorState edge, int accessType) {
+        // TODO shift dependent on the accessType
+        // use only one bit for foot?
+        long flags = edge.getFlags();
+        return (flags & (isBit0Empty(flags) ? forwardBit : backwardBit)) != 0;
+    }
+
+    @Override
+    public final boolean isForward(long flags) {
+        // TODO remove old method
+        return (flags & (isBit0Empty(flags) ? forwardBit : backwardBit)) != 0;
+    }
+
+    public final boolean isBackward(EdgeIteratorState edge, int accessType) {
+        long flags = edge.getFlags();
+        return (flags & (isBit0Empty(flags) ? backwardBit : forwardBit)) != 0;
+    }
+
+    @Override
+    public final boolean isBackward(long flags) {
+        // TODO remove old method
+        return (flags & (isBit0Empty(flags) ? backwardBit : forwardBit)) != 0;
+    }
+
+    public double getMaxspeed(EdgeIteratorState edge, int accessType, boolean reverse) {
+        long flags = edge.getFlags();
+        if (!isBit0Empty(flags))
+            reverse = !reverse;
+
+        double val;
+        if (reverse)
+            val = carBwdMaxspeedEncoder.getDoubleValue(flags);
+        else
+            val = carFwdMaxspeedEncoder.getDoubleValue(flags);
+
+        if (val < 0)
+            throw new IllegalStateException("maxspeed cannot be negative, edge:" + edge.getEdge() + ", access type" + accessType + ", reverse:" + reverse);
+
+        // default is 0 but return invalid speed explicitely (TODO can we do this at the value encoder level?)
+        if (val == 0)
+            return -1;
+        return val;
+    }
+
+    @Override
+    public long flagsDefault(boolean forward, boolean backward) {
+        // just pick car mode to set access values?
+        // throw new RuntimeException("do not call flagsDefault");
+        // TODO This is called on each of the encoders so I had to replace the runtime 
+        // exception with something, but I'm not sure this is correct.        
+        return setAccess(0, forward, backward);
+    }
+
+    @Override
+    public long setAccess(long flags, boolean forward, boolean backward) {
+        // TODO we should interpret access for *any* vehicle
+        // TODO in subnetwork we need to remove access for certain weighting profiles (or set of roads?)
+        boolean isForward = isBit0Empty(flags);
+        if (!isForward) {
+            boolean tmp = forward;
+            forward = backward;
+            backward = tmp;
+        }
+
+        flags = forward ? flags | forwardBit : flags & ~forwardBit;
+        flags = backward ? flags | backwardBit : flags & ~backwardBit;
+        return flags;
+    }
+
+    @Override
+    public long setSpeed(long flags, double speed) {
+        throw new RuntimeException("do not call setSpeed");
+    }
+
+    @Override
+    protected long setLowSpeed(long flags, double speed, boolean reverse) {
+        throw new RuntimeException("do not call setLowSpeed");
+    }
+
+    @Override
+    public double getSpeed(long flags) {
+        throw new UnsupportedOperationException("Calculate speed via more customizable Weighting.calcMillis method");
+    }
+
+    @Override
+    public long setReverseSpeed(long flags, double speed) {
+        throw new RuntimeException("do not call setReverseSpeed");
+    }
+
+    @Override
+    public double getReverseSpeed(long flags) {
+        throw new RuntimeException("do not call getReverseSpeed");
+    }
+
+    @Override
+    public long setProperties(double speed, boolean forward, boolean backward) {
+        throw new RuntimeException("do not call setProperties");
+    }
+
+    @Override
+    protected double getMaxSpeed(ReaderWay way) {
+        throw new RuntimeException("do not call getMaxSpeed(ReaderWay)");
+    }
+
+    @Override
+    public double getMaxSpeed() {
+        throw new RuntimeException("do not call getMaxSpeed");
+    }
+
+    public double getMaxPossibleSpeed() {
+        return maxPossibleSpeed;
+    }
+
+    @Override
+    public boolean supports(Class<?> feature) {
+        boolean ret = super.supports(feature);
+        if (ret)
+            return true;
+
+        return GenericWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public int getVersion() {
+        return 1;
+    }
+
+    @Override
+    public String toString() {
+        return "generic";
+    }
+
+    /**
+     * This method creates a Config map out of the PMap. Later on this conversion should not be
+     * necessary when we read JSON.
+     */
+    public ConfigMap readStringMap(PMap weightingMap) {
+        Map<String, Double> map = new HashMap<>();
+        for (Entry<String, Double> e : DEFAULT_SPEEDS.entrySet()) {
+            map.put(e.getKey(), weightingMap.getDouble("highways." + e.getKey(), e.getValue()));
+        }
+
+        ConfigMap cMap = new ConfigMap();
+        cMap.put("highways", map);
+        return cMap;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index e93c563a46..5cf1c5fbd4 100755
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -22,8 +22,7 @@
 /**
  * @author Peter Karich
  */
-public class DefaultEdgeFilter implements EdgeFilter
-{
+public class DefaultEdgeFilter implements EdgeFilter {
     private final boolean bwd;
     private final boolean fwd;
     private FlagEncoder encoder;
@@ -31,37 +30,31 @@
     /**
      * Creates an edges filter which accepts both direction of the specified vehicle.
      */
-    public DefaultEdgeFilter( FlagEncoder encoder )
-    {
+    public DefaultEdgeFilter(FlagEncoder encoder) {
         this(encoder, true, true);
     }
 
-    public DefaultEdgeFilter( FlagEncoder encoder, boolean bwd, boolean fwd )
-    {
+    public DefaultEdgeFilter(FlagEncoder encoder, boolean bwd, boolean fwd) {
         this.encoder = encoder;
         this.bwd = bwd;
         this.fwd = fwd;
     }
 
     @Override
-    public final boolean accept( EdgeIteratorState iter )
-    {
+    public final boolean accept(EdgeIteratorState iter) {
         return fwd && iter.isForward(encoder) || bwd && iter.isBackward(encoder);
     }
 
-    public boolean acceptsBackward()
-    {
+    public boolean acceptsBackward() {
         return bwd;
     }
 
-    public boolean acceptsForward()
-    {
+    public boolean acceptsForward() {
         return fwd;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return encoder.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
index 736375311d..4a8dc89a7a 100755
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
@@ -24,14 +24,18 @@
  *
  * @author Peter Karich
  */
-public class DefaultFlagEncoderFactory implements FlagEncoderFactory
-{
+public class DefaultFlagEncoderFactory implements FlagEncoderFactory {
     @Override
-    public FlagEncoder createFlagEncoder( String name, PMap configuration )
-    {
-        if (name.equals(CAR))
+    public FlagEncoder createFlagEncoder(String name, PMap configuration) {
+        if (name.equals(GENERIC))
+            return new DataFlagEncoder();
+
+        else if (name.equals(CAR))
             return new CarFlagEncoder(configuration);
 
+        else if (name.equals(CAR4WD))
+            return new Car4WDFlagEncoder(configuration);
+
         if (name.equals(BIKE))
             return new BikeFlagEncoder(configuration);
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 9dc221b43b..e06c4ac108 100755
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -22,21 +22,19 @@
 /**
  * Class used to traverse a graph.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface EdgeFilter
-{
-    /**
-     * @return true if the current edge should be processed and false otherwise.
-     */
-    boolean accept( EdgeIteratorState edgeState );
-
-    static final EdgeFilter ALL_EDGES = new EdgeFilter()
-    {
+public interface EdgeFilter {
+    static final EdgeFilter ALL_EDGES = new EdgeFilter() {
         @Override
-        public final boolean accept( EdgeIteratorState edgeState )
-        {
+        public final boolean accept(EdgeIteratorState edgeState) {
             return true;
         }
     };
+
+    /**
+     * @return true if the current edge should be processed and false otherwise.
+     */
+    boolean accept(EdgeIteratorState edgeState);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index dedf7cf057..2773a961b9 100755
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -20,41 +20,35 @@
 /**
  * Encapsulates a bit-encoded value.
  * <p>
+ *
  * @author Nop
  */
-public class EncodedDoubleValue extends EncodedValue
-{
+public class EncodedDoubleValue extends EncodedValue {
 
-    public EncodedDoubleValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue )
-    {
+    public EncodedDoubleValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue) {
         this(name, shift, bits, factor, defaultValue, maxValue, true);
     }
 
-    public EncodedDoubleValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero )
-    {
+    public EncodedDoubleValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero) {
         super(name, shift, bits, factor, defaultValue, maxValue, allowZero);
     }
 
     @Override
-    public long setValue( long flags, long value )
-    {
+    public long setValue(long flags, long value) {
         throw new IllegalStateException("Use setDoubleValue instead");
     }
 
     @Override
-    public long getValue( long flags )
-    {
+    public long getValue(long flags) {
         throw new IllegalStateException("Use setDoubleValue instead");
     }
 
     @Override
-    public long setDefaultValue( long flags )
-    {
+    public long setDefaultValue(long flags) {
         return setDoubleValue(flags, defaultValue);
     }
 
-    public long setDoubleValue( long flags, double value )
-    {
+    public long setDoubleValue(long flags, double value) {
         if (Double.isNaN(value))
             throw new IllegalStateException("Value cannot be NaN");
 
@@ -70,23 +64,10 @@ public long setDoubleValue( long flags, double value )
         return flags | tmpValue;
     }
 
-    public double getDoubleValue( long flags )
-    {
+    public double getDoubleValue(long flags) {
         // find value
         flags &= mask;
         flags >>>= shift;
         return flags * factor;
     }
-
-    /**
-     * Swap the contents controlled by this value encoder with the given value.
-     * <p>
-     * @return the new flags
-     */
-    public long swap( long flags, EncodedDoubleValue otherEncoder )
-    {
-        double otherValue = otherEncoder.getDoubleValue(flags);
-        flags = otherEncoder.setDoubleValue(flags, getDoubleValue(flags));
-        return setDoubleValue(flags, otherValue);
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index c036be5a33..f6d9074ad0 100755
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -20,15 +20,15 @@
 /**
  * Encapsulates a bit-encoded value.
  * <p>
+ *
  * @author Nop
  */
-public class EncodedValue
-{
-    private final String name;
+public class EncodedValue {
     protected final long shift;
     protected final long mask;
     protected final double factor;
     protected final long defaultValue;
+    private final String name;
     private final long maxValue;
     private final boolean allowZero;
     private final int bits;
@@ -36,20 +36,19 @@
     /**
      * Define a bit-encoded value
      * <p>
-     * @param name Description for debugging
-     * @param shift bit index of this value
-     * @param bits number of bits reserved
-     * @param factor scaling factor for stored values
+     *
+     * @param name         Description for debugging
+     * @param shift        bit index of this value
+     * @param bits         number of bits reserved
+     * @param factor       scaling factor for stored values
      * @param defaultValue default value
-     * @param maxValue default maximum value
+     * @param maxValue     default maximum value
      */
-    public EncodedValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue )
-    {
+    public EncodedValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue) {
         this(name, shift, bits, factor, defaultValue, maxValue, true);
     }
 
-    public EncodedValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero )
-    {
+    public EncodedValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero) {
         this.name = name;
         this.shift = shift;
         this.factor = factor;
@@ -64,8 +63,7 @@ public EncodedValue( String name, int shift, int bits, double factor, long defau
         this.allowZero = allowZero;
     }
 
-    protected void checkValue( long value )
-    {
+    protected void checkValue(long value) {
         if (value > maxValue)
             throw new IllegalArgumentException(name + " value too large for encoding: " + value + ", maxValue:" + maxValue);
         if (value < 0)
@@ -74,8 +72,7 @@ protected void checkValue( long value )
             throw new IllegalArgumentException("zero " + name + " value not allowed! " + value);
     }
 
-    public long setValue( long flags, long value )
-    {
+    public long setValue(long flags, long value) {
         checkValue(value);
         // scale value
         value /= factor;
@@ -88,36 +85,32 @@ public long setValue( long flags, long value )
         return flags | value;
     }
 
-    public long getValue( long flags )
-    {
+    public long getValue(long flags) {
         // find value
         flags &= mask;
         flags >>>= shift;
         return Math.round(flags * factor);
     }
 
-    public int getBits()
-    {
+    public int getBits() {
         return bits;
     }
 
-    public long setDefaultValue( long flags )
-    {
+    public long setDefaultValue(long flags) {
         return setValue(flags, defaultValue);
     }
 
-    public long getMaxValue()
-    {
+    public long getMaxValue() {
         return maxValue;
     }
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
      * <p>
+     *
      * @return the new flags
      */
-    public long swap( long flags, EncodedValue otherEncoder )
-    {
+    public long swap(long flags, EncodedValue otherEncoder) {
         long otherValue = otherEncoder.getValue(flags);
         flags = otherEncoder.setValue(flags, getValue(flags));
         return setValue(flags, otherValue);
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 9e0bb3cf8b..682eb585c4 100755
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,36 +17,38 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
  * during parsing.
  * <p>
+ *
  * @author Peter Karich
  * @author Nop
  */
-public class EncodingManager
-{
+public class EncodingManager {
+    private static final String ERR = "Encoders are requesting %s bits, more than %s bits of %s flags. ";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags=8";
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<AbstractFlagEncoder>();
-
+    private final int bitsForEdgeFlags;
+    private final int bitsForTurnFlags = 8 * 4;
     private int nextWayBit = 0;
     private int nextNodeBit = 0;
     private int nextRelBit = 0;
     private int nextTurnBit = 0;
-    private final int bitsForEdgeFlags;
-    private final int bitsForTurnFlags = 8 * 4;
     private boolean enableInstructions = true;
     private String preferredLanguage = "";
 
@@ -54,46 +56,47 @@
      * Instantiate manager with the given list of encoders. The manager knows several default
      * encoders ignoring case.
      * <p>
+     *
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager( String flagEncodersStr )
-    {
-        this(FlagEncoderFactory.DEFAULT, flagEncodersStr, 4);
+    public EncodingManager(String flagEncodersStr) {
+        this(flagEncodersStr, 4);
+    }
+
+    public EncodingManager(String flagEncodersStr, int bytesForEdgeFlags) {
+        this(FlagEncoderFactory.DEFAULT, flagEncodersStr, bytesForEdgeFlags);
     }
 
-    public EncodingManager( FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags )
-    {
+    public EncodingManager(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
         this(parseEncoderString(factory, flagEncodersStr), bytesForEdgeFlags);
     }
 
     /**
      * Instantiate manager with the given list of encoders.
      * <p>
+     *
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager( FlagEncoder... flagEncoders )
-    {
+    public EncodingManager(FlagEncoder... flagEncoders) {
         this(Arrays.asList(flagEncoders));
     }
 
     /**
      * Instantiate manager with the given list of encoders.
      * <p>
+     *
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager( List<? extends FlagEncoder> flagEncoders )
-    {
+    public EncodingManager(List<? extends FlagEncoder> flagEncoders) {
         this(flagEncoders, 4);
     }
 
-    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
-    {
+    public EncodingManager(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
         if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
             throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
         this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
-        for (FlagEncoder flagEncoder : flagEncoders)
-        {
+        for (FlagEncoder flagEncoder : flagEncoders) {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
 
@@ -101,13 +104,7 @@ public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEd
             throw new IllegalStateException("No vehicles found");
     }
 
-    public int getBytesForFlags()
-    {
-        return bitsForEdgeFlags / 8;
-    }
-
-    static List<FlagEncoder> parseEncoderString( FlagEncoderFactory factory, String encoderList )
-    {
+    static List<FlagEncoder> parseEncoderString(FlagEncoderFactory factory, String encoderList) {
         if (encoderList.contains(":"))
             throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
 
@@ -117,15 +114,13 @@ public int getBytesForFlags()
         String[] entries = encoderList.split(",");
         List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
-        for (String entry : entries)
-        {
+        for (String entry : entries) {
             entry = entry.trim().toLowerCase();
             if (entry.isEmpty())
                 continue;
 
             String entryVal = "";
-            if (entry.contains("|"))
-            {
+            if (entry.contains("|")) {
                 entryVal = entry;
                 entry = entry.split("\\|")[0];
             }
@@ -142,16 +137,46 @@ public int getBytesForFlags()
         return resultEncoders;
     }
 
-    private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags=8";
+    static String fixWayName(String str) {
+        if (str == null)
+            return "";
+        return str.replaceAll(";[ ]*", ", ");
+    }
+
+    /**
+     * Create the EncodingManager from the provided GraphHopper location. Throws an
+     * IllegalStateException if it fails. Used if no EncodingManager specified on load.
+     */
+    public static EncodingManager create(FlagEncoderFactory factory, String ghLoc) {
+        Directory dir = new RAMDirectory(ghLoc, true);
+        StorableProperties properties = new StorableProperties(dir);
+        if (!properties.loadExisting())
+            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
+                    + dir.getLocation());
+
+        // check encoding for compatibility
+        properties.checkVersions(false);
+        String acceptStr = properties.get("graph.flag_encoders");
+
+        if (acceptStr.isEmpty())
+            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
+                    + dir.getLocation());
+
+        int bytesForFlags = 4;
+        if ("8".equals(properties.get("graph.bytes_for_flags")))
+            bytesForFlags = 8;
+        return new EncodingManager(factory, acceptStr, bytesForFlags);
+    }
+
+    public int getBytesForFlags() {
+        return bitsForEdgeFlags / 8;
+    }
 
-    private void registerEncoder( AbstractFlagEncoder encoder )
-    {
+    private void registerEncoder(AbstractFlagEncoder encoder) {
         if (encoder.isRegistered())
             throw new IllegalStateException("You must not register a FlagEncoder (" + encoder.toString() + ") twice!");
 
-        for (FlagEncoder fe : edgeEncoders)
-        {
+        for (FlagEncoder fe : edgeEncoders) {
             if (fe.toString().equals(encoder.toString()))
                 throw new IllegalArgumentException("Cannot register edge encoder. Name already exists: " + fe.toString());
         }
@@ -161,26 +186,26 @@ private void registerEncoder( AbstractFlagEncoder encoder )
         int encoderCount = edgeEncoders.size();
         int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "node"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "way") + WAY_ERR);
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "relation"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
         // turn flag bits are independent from edge encoder bits
         usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
         if (usedBits > bitsForTurnFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForTurnFlags, "turn"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForTurnFlags, "turn"));
         nextTurnBit = usedBits;
 
         edgeEncoders.add(encoder);
@@ -189,20 +214,16 @@ private void registerEncoder( AbstractFlagEncoder encoder )
     /**
      * @return true if the specified encoder is found
      */
-    public boolean supports( String encoder )
-    {
+    public boolean supports(String encoder) {
         return getEncoder(encoder, false) != null;
     }
 
-    public FlagEncoder getEncoder( String name )
-    {
+    public FlagEncoder getEncoder(String name) {
         return getEncoder(name, true);
     }
 
-    private FlagEncoder getEncoder( String name, boolean throwExc )
-    {
-        for (FlagEncoder encoder : edgeEncoders)
-        {
+    private FlagEncoder getEncoder(String name, boolean throwExc) {
+        for (FlagEncoder encoder : edgeEncoders) {
             if (name.equalsIgnoreCase(encoder.toString()))
                 return encoder;
         }
@@ -214,22 +235,18 @@ private FlagEncoder getEncoder( String name, boolean throwExc )
     /**
      * Determine whether a way is routable for one of the added encoders.
      */
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         long includeWay = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             includeWay |= encoder.acceptWay(way);
         }
 
         return includeWay;
     }
 
-    public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-    {
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             flags |= encoder.handleRelationTags(relation, oldRelationFlags);
         }
 
@@ -240,14 +257,13 @@ public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
      * Processes way properties of different kind to determine speed and direction. Properties are
      * directly encoded in 8 bytes.
      * <p>
+     *
      * @param relationFlags The preprocessed relation flags is used to influence the way properties.
      * @return the encoded flags
      */
-    public long handleWayTags( ReaderWay way, long includeWay, long relationFlags )
-    {
+    public long handleWayTags(ReaderWay way, long includeWay, long relationFlags) {
         long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             flags |= encoder.handleWayTags(way, includeWay, relationFlags & encoder.getRelBitMask());
         }
 
@@ -255,11 +271,9 @@ public long handleWayTags( ReaderWay way, long includeWay, long relationFlags )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder str = new StringBuilder();
-        for (FlagEncoder encoder : edgeEncoders)
-        {
+        for (FlagEncoder encoder : edgeEncoders) {
             if (str.length() > 0)
                 str.append(",");
 
@@ -269,11 +283,9 @@ public String toString()
         return str.toString();
     }
 
-    public String toDetailsString()
-    {
+    public String toDetailsString() {
         StringBuilder str = new StringBuilder();
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             if (str.length() > 0)
                 str.append(",");
 
@@ -287,11 +299,9 @@ public String toDetailsString()
         return str.toString();
     }
 
-    public long flagsDefault( boolean forward, boolean backward )
-    {
+    public long flagsDefault(boolean forward, boolean backward) {
         long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             flags |= encoder.flagsDefault(forward, backward);
         }
         return flags;
@@ -300,28 +310,24 @@ public long flagsDefault( boolean forward, boolean backward )
     /**
      * Reverse flags, to do so all encoders are called.
      */
-    public long reverseFlags( long flags )
-    {
+    public long reverseFlags(long flags) {
         // performance critical
         int len = edgeEncoders.size();
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             flags = edgeEncoders.get(i).reverseFlags(flags);
         }
         return flags;
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 5;
         hash = 53 * hash + (this.edgeEncoders != null ? this.edgeEncoders.hashCode() : 0);
         return hash;
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -330,8 +336,7 @@ public boolean equals( Object obj )
 
         final EncodingManager other = (EncodingManager) obj;
         if (this.edgeEncoders != other.edgeEncoders
-                && (this.edgeEncoders == null || !this.edgeEncoders.equals(other.edgeEncoders)))
-        {
+                && (this.edgeEncoders == null || !this.edgeEncoders.equals(other.edgeEncoders))) {
             return false;
         }
         return true;
@@ -340,25 +345,21 @@ public boolean equals( Object obj )
     /**
      * Analyze tags on osm node. Store node tags (barriers etc) for later usage while parsing way.
      */
-    public long handleNodeTags( ReaderNode node )
-    {
+    public long handleNodeTags(ReaderNode node) {
         long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             flags |= encoder.handleNodeTags(node);
         }
 
         return flags;
     }
 
-    public EncodingManager setEnableInstructions( boolean enableInstructions )
-    {
+    public EncodingManager setEnableInstructions(boolean enableInstructions) {
         this.enableInstructions = enableInstructions;
         return this;
     }
 
-    public EncodingManager setPreferredLanguage( String preferredLanguage )
-    {
+    public EncodingManager setPreferredLanguage(String preferredLanguage) {
         if (preferredLanguage == null)
             throw new IllegalArgumentException("preferred language cannot be null");
 
@@ -366,11 +367,9 @@ public EncodingManager setPreferredLanguage( String preferredLanguage )
         return this;
     }
 
-    public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
-    {
+    public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         // storing the road name does not yet depend on the flagEncoder so manage it directly
-        if (enableInstructions)
-        {
+        if (enableInstructions) {
             // String wayInfo = carFlagEncoder.getWayInfo(way);
             // http://wiki.openstreetmap.org/wiki/Key:name
             String name = "";
@@ -380,8 +379,7 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
                 name = fixWayName(way.getTag("name"));
             // http://wiki.openstreetmap.org/wiki/Key:ref
             String refName = fixWayName(way.getTag("ref"));
-            if (!refName.isEmpty())
-            {
+            if (!refName.isEmpty()) {
                 if (name.isEmpty())
                     name = refName;
                 else
@@ -391,8 +389,7 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
             edge.setName(name);
         }
 
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
             encoder.applyWayTags(way, edge);
         }
     }
@@ -400,53 +397,17 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
     /**
      * The returned list is never empty.
      */
-    public List<FlagEncoder> fetchEdgeEncoders()
-    {
+    public List<FlagEncoder> fetchEdgeEncoders() {
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
         list.addAll(edgeEncoders);
         return list;
     }
 
-    static String fixWayName( String str )
-    {
-        if (str == null)
-            return "";
-        return str.replaceAll(";[ ]*", ", ");
-    }
-
-    public boolean needsTurnCostsSupport()
-    {
-        for (FlagEncoder encoder : edgeEncoders)
-        {
+    public boolean needsTurnCostsSupport() {
+        for (FlagEncoder encoder : edgeEncoders) {
             if (encoder.supports(TurnWeighting.class))
                 return true;
         }
         return false;
     }
-
-    /**
-     * Create the EncodingManager from the provided GraphHopper location. Throws an
-     * IllegalStateException if it fails. Used if no EncodingManager specified on load.
-     */
-    public static EncodingManager create( FlagEncoderFactory factory, String ghLoc )
-    {
-        Directory dir = new RAMDirectory(ghLoc, true);
-        StorableProperties properties = new StorableProperties(dir);
-        if (!properties.loadExisting())
-            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
-                    + dir.getLocation());
-
-        // check encoding for compatibility
-        properties.checkVersions(false);
-        String acceptStr = properties.get("graph.flag_encoders");
-
-        if (acceptStr.isEmpty())
-            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
-                    + dir.getLocation());
-
-        int bytesForFlags = 4;
-        if ("8".equals(properties.get("graph.bytes_for_flags")))
-            bytesForFlags = 8;
-        return new EncodingManager(factory, acceptStr, bytesForFlags);
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 5caa3a1da2..a9d8ac1a06 100755
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -24,10 +24,15 @@
  * This class provides methods to define how a value (like speed or direction) converts to a flag
  * (currently an integer value), which is stored in an edge .
  * <p>
+ *
  * @author Peter Karich
  */
-public interface FlagEncoder extends TurnCostEncoder
-{
+public interface FlagEncoder extends TurnCostEncoder {
+    /**
+     * Reports whether this edge is part of a roundabout.
+     */
+    static final int K_ROUNDABOUT = 2;
+
     /**
      * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are
      * introduced
@@ -42,48 +47,46 @@
     /**
      * @return the speed in km/h for this direction, for backward direction use getReverseSpeed
      */
-    double getSpeed( long flags );
+    double getSpeed(long flags);
 
     /**
      * Sets the speed in km/h.
      * <p>
+     *
      * @return modified setProperties
      */
-    long setSpeed( long flags, double speed );
+    long setSpeed(long flags, double speed);
 
     /**
      * @return the speed of the reverse direction in km/h
      */
-    double getReverseSpeed( long flags );
+    double getReverseSpeed(long flags);
 
     /**
      * Sets the reverse speed in the flags.
      */
-    long setReverseSpeed( long flags, double speed );
+    long setReverseSpeed(long flags, double speed);
 
     /**
      * Sets the access of the edge.
      * <p>
+     *
      * @return modified flags
      */
-    long setAccess( long flags, boolean forward, boolean backward );
+    long setAccess(long flags, boolean forward, boolean backward);
 
     /**
      * Sets speed and access properties.
      * <p>
+     *
      * @return created flags
      */
-    long setProperties( double speed, boolean forward, boolean backward );
+    long setProperties(double speed, boolean forward, boolean backward);
 
     /**
      * Reports whether the edge is available in forward direction for a certain vehicle
      */
-    boolean isForward( long flags );
-
-    /**
-     * Reports whether the edge is available in backward direction for a certain vehicle
-     */
-    boolean isBackward( long flags );
+    boolean isForward(long flags);
 
     /*
      * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
@@ -91,42 +94,42 @@
      * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
      */
     /**
-     * Reports whether this edge is part of a roundabout.
+     * Reports whether the edge is available in backward direction for a certain vehicle
      */
-    static final int K_ROUNDABOUT = 2;
+    boolean isBackward(long flags);
 
     /**
      * Returns arbitrary boolean value identified by the specified key.
      */
-    boolean isBool( long flags, int key );
+    boolean isBool(long flags, int key);
 
-    long setBool( long flags, int key, boolean value );
+    long setBool(long flags, int key, boolean value);
 
     /**
      * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
      * way or surface type of an edge
      */
-    long getLong( long flags, int key );
+    long getLong(long flags, int key);
 
-    long setLong( long flags, int key, long value );
+    long setLong(long flags, int key, long value);
 
     /**
      * Returns arbitrary double value identified by the specified key. E.g. can be used to return
      * the maximum width or height allowed for an edge.
      */
-    double getDouble( long flags, int key );
+    double getDouble(long flags, int key);
 
-    long setDouble( long flags, int key, double value );
+    long setDouble(long flags, int key, double value);
 
     /**
      * Returns true if the feature class is supported like TurnWeighting or PriorityWeighting.
      */
-    boolean supports( Class<?> feature );
+    boolean supports(Class<?> feature);
 
     /**
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
-    InstructionAnnotation getAnnotation( long flags, Translation tr );
+    InstructionAnnotation getAnnotation(long flags, Translation tr);
 
     /**
      * @return true if already registered in an EncodingManager
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
index 134e1cf52a..82e8b45d71 100755
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
@@ -20,12 +20,11 @@
 import com.graphhopper.util.PMap;
 
 /**
- *
  * @author Peter Karich
  */
-public interface FlagEncoderFactory
-{
+public interface FlagEncoderFactory {
     final String CAR = "car";
+    final String CAR4WD = "car4wd";
     final String BIKE = "bike";
     final String BIKE2 = "bike2";
     final String RACINGBIKE = "racingbike";
@@ -33,7 +32,8 @@
     final String FOOT = "foot";
     final String HIKE = "hike";
     final String MOTORCYCLE = "motorcycle";
+    final String GENERIC = "generic";
     final FlagEncoderFactory DEFAULT = new DefaultFlagEncoderFactory();
 
-    FlagEncoder createFlagEncoder( String name, PMap configuration );
+    FlagEncoder createFlagEncoder(String name, PMap configuration);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index d8ccfdb37f..ae346ae670 100755
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -19,8 +19,7 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
-import com.graphhopper.reader.osm.conditional.DateRangeParser;
+import com.graphhopper.routing.weighting.PriorityWeighting;
 import com.graphhopper.util.PMap;
 
 import java.util.*;
@@ -32,48 +31,44 @@
  * roads only. If you wish to also prefer routes due to beauty like hiking routes use the
  * HikeFlagEncoder instead.
  * <p>
+ *
  * @author Peter Karich
  * @author Nop
  * @author Karl Hübner
  */
-public class FootFlagEncoder extends AbstractFlagEncoder
-{
+public class FootFlagEncoder extends AbstractFlagEncoder {
     static final int SLOW_SPEED = 2;
     static final int MEAN_SPEED = 5;
     static final int FERRY_SPEED = 10;
-    private EncodedValue priorityWayEncoder;
-    private EncodedValue relationCodeEncoder;
-    protected HashSet<String> sidewalkValues = new HashSet<String>(5);
-    protected HashSet<String> sidewalksNoValues = new HashSet<String>(5);
     final Set<String> safeHighwayTags = new HashSet<String>();
     final Set<String> allowedHighwayTags = new HashSet<String>();
     final Set<String> avoidHighwayTags = new HashSet<String>();
     // convert network tag of hiking routes into a way route code
     final Map<String, Integer> hikingNetworkToCode = new HashMap<String, Integer>();
+    protected HashSet<String> sidewalkValues = new HashSet<String>(5);
+    protected HashSet<String> sidewalksNoValues = new HashSet<String>(5);
+    private EncodedValue priorityWayEncoder;
+    private EncodedValue relationCodeEncoder;
 
     /**
      * Should be only instantiated via EncodingManager
      */
-    public FootFlagEncoder()
-    {
+    public FootFlagEncoder() {
         this(4, 1);
     }
 
-    public FootFlagEncoder( PMap properties )
-    {
+    public FootFlagEncoder(PMap properties) {
         this((int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 1));
         this.properties = properties;
-        this.setBlockFords(properties.getBool("blockFords", true));
+        this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public FootFlagEncoder( String propertiesStr )
-    {
+    public FootFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public FootFlagEncoder( int speedBits, double speedFactor )
-    {
+    public FootFlagEncoder(int speedBits, double speedFactor) {
         super(speedBits, speedFactor, 0);
         restrictions.addAll(Arrays.asList("foot", "access"));
         restrictedValues.add("private");
@@ -139,14 +134,12 @@ public FootFlagEncoder( int speedBits, double speedFactor )
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 2;
     }
 
     @Override
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         // larger value required - ferries are faster than pedestrians
@@ -159,8 +152,7 @@ public int defineWayBits( int index, int shift )
     }
 
     @Override
-    public int defineRelationBits( int index, int shift )
-    {
+    public int defineRelationBits(int index, int shift) {
         relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
         return shift + relationCodeEncoder.getBits();
     }
@@ -169,36 +161,34 @@ public int defineRelationBits( int index, int shift )
      * Foot flag encoder does not provide any turn cost / restrictions
      */
     @Override
-    public int defineTurnBits( int index, int shift )
-    {
+    public int defineTurnBits(int index, int shift) {
         return shift;
     }
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
      * <p>
+     *
      * @return <code>false</code>
      */
     @Override
-    public boolean isTurnRestricted( long flag )
-    {
+    public boolean isTurnRestricted(long flag) {
         return false;
     }
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
      * <p>
+     *
      * @return 0
      */
     @Override
-    public double getTurnCost( long flag )
-    {
+    public double getTurnCost(long flag) {
         return 0;
     }
 
     @Override
-    public long getTurnFlags( boolean restricted, double costs )
-    {
+    public long getTurnFlags(boolean restricted, double costs) {
         return 0;
     }
 
@@ -207,13 +197,10 @@ public long getTurnFlags( boolean restricted, double costs )
      * <p>
      */
     @Override
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
                 String footTag = way.getTag("foot");
                 if (footTag == null || "yes".equals(footTag))
                     return acceptBit | ferryBit;
@@ -227,8 +214,7 @@ public long acceptWay( ReaderWay way )
         }
 
         String sacScale = way.getTag("sac_scale");
-        if (sacScale != null)
-        {
+        if (sacScale != null) {
             if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
                     && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
                 // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
@@ -263,18 +249,15 @@ public long acceptWay( ReaderWay way )
     }
 
     @Override
-    public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-    {
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         int code = 0;
-        if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot"))
-        {
+        if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot")) {
             Integer val = hikingNetworkToCode.get(relation.getTag("network"));
             if (val != null)
                 code = val;
             else
                 code = hikingNetworkToCode.get("lwn");
-        } else if (relation.hasTag("route", "ferry"))
-        {
+        } else if (relation.hasTag("route", "ferry")) {
             code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
         }
 
@@ -285,23 +268,19 @@ public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
     }
 
     @Override
-    public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
-    {
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         if (!isAccept(allowed))
             return 0;
 
         long flags = 0;
-        if (!isFerry(allowed))
-        {
+        if (!isFerry(allowed)) {
             String sacScale = way.getTag("sac_scale");
-            if (sacScale != null)
-            {
+            if (sacScale != null) {
                 if ("hiking".equals(sacScale))
                     flags = speedEncoder.setDoubleValue(flags, MEAN_SPEED);
                 else
                     flags = speedEncoder.setDoubleValue(flags, SLOW_SPEED);
-            } else
-            {
+            } else {
                 flags = speedEncoder.setDoubleValue(flags, MEAN_SPEED);
             }
             flags |= directionBitMask;
@@ -310,8 +289,7 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
             if (isRoundabout)
                 flags = setBool(flags, K_ROUNDABOUT, true);
 
-        } else
-        {
+        } else {
             double ferrySpeed = getFerrySpeed(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             flags = setSpeed(flags, ferrySpeed);
             flags |= directionBitMask;
@@ -326,10 +304,8 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
     }
 
     @Override
-    public double getDouble( long flags, int key )
-    {
-        switch (key)
-        {
+    public double getDouble(long flags, int key) {
+        switch (key) {
             case PriorityWeighting.KEY:
                 return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             default:
@@ -337,8 +313,7 @@ public double getDouble( long flags, int key )
         }
     }
 
-    protected int handlePriority( ReaderWay way, int priorityFromRelation )
-    {
+    protected int handlePriority(ReaderWay way, int priorityFromRelation) {
         TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
         if (priorityFromRelation == 0)
             weightToPrioMap.put(0d, UNCHANGED.getValue());
@@ -353,27 +328,23 @@ protected int handlePriority( ReaderWay way, int priorityFromRelation )
 
     /**
      * @param weightToPrioMap associate a weight with every priority. This sorted map allows
-     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     *                        subclasses to 'insert' more important priorities as well as overwrite determined priorities.
      */
-    void collect( ReaderWay way, TreeMap<Double, Integer> weightToPrioMap )
-    {
+    void collect(ReaderWay way, TreeMap<Double, Integer> weightToPrioMap) {
         String highway = way.getTag("highway");
         if (way.hasTag("foot", "designated"))
             weightToPrioMap.put(100d, PREFER.getValue());
 
         double maxSpeed = getMaxSpeed(way);
-        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20)
-        {
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20) {
             weightToPrioMap.put(40d, PREFER.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-            {
+            if (way.hasTag("tunnel", intendedValues)) {
                 if (way.hasTag("sidewalk", sidewalksNoValues))
                     weightToPrioMap.put(40d, AVOID_IF_POSSIBLE.getValue());
                 else
                     weightToPrioMap.put(40d, UNCHANGED.getValue());
             }
-        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway))
-        {
+        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway)) {
             if (!way.hasTag("sidewalk", sidewalkValues))
                 weightToPrioMap.put(45d, AVOID_IF_POSSIBLE.getValue());
         }
@@ -383,8 +354,7 @@ void collect( ReaderWay way, TreeMap<Double, Integer> weightToPrioMap )
     }
 
     @Override
-    public boolean supports( Class<?> feature )
-    {
+    public boolean supports(Class<?> feature) {
         if (super.supports(feature))
             return true;
 
@@ -392,8 +362,7 @@ public boolean supports( Class<?> feature )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "foot";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
index 57344f5aa4..1b499de038 100755
--- a/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
@@ -18,9 +18,10 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.PriorityWeighting;
 import com.graphhopper.util.PMap;
 
-import java.util.*;
+import java.util.TreeMap;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
 
@@ -29,55 +30,46 @@
  *
  * @author Peter Karich
  */
-public class HikeFlagEncoder extends FootFlagEncoder
-{
+public class HikeFlagEncoder extends FootFlagEncoder {
     /**
      * Should be only instantiated via EncodingManager
      */
-    public HikeFlagEncoder()
-    {
+    public HikeFlagEncoder() {
         this(4, 1);
     }
 
-    public HikeFlagEncoder( PMap properties )
-    {
+    public HikeFlagEncoder(PMap properties) {
         this((int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 1));
         this.properties = properties;
-        this.setBlockFords(properties.getBool("blockFords", true));
+        this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public HikeFlagEncoder( String propertiesStr )
-    {
+    public HikeFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public HikeFlagEncoder( int speedBits, double speedFactor )
-    {
+    public HikeFlagEncoder(int speedBits, double speedFactor) {
         super(speedBits, speedFactor);
 
         hikingNetworkToCode.put("iwn", BEST.getValue());
         hikingNetworkToCode.put("nwn", BEST.getValue());
         hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
         hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
                 String footTag = way.getTag("foot");
                 if (footTag == null || "yes".equals(footTag))
                     return acceptBit | ferryBit;
@@ -120,25 +112,21 @@ public long acceptWay( ReaderWay way )
     }
 
     @Override
-    void collect( ReaderWay way, TreeMap<Double, Integer> weightToPrioMap )
-    {
+    void collect(ReaderWay way, TreeMap<Double, Integer> weightToPrioMap) {
         String highway = way.getTag("highway");
         if (way.hasTag("foot", "designated"))
             weightToPrioMap.put(100d, PREFER.getValue());
 
         double maxSpeed = getMaxSpeed(way);
-        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20)
-        {
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20) {
             weightToPrioMap.put(40d, PREFER.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-            {
+            if (way.hasTag("tunnel", intendedValues)) {
                 if (way.hasTag("sidewalk", sidewalksNoValues))
                     weightToPrioMap.put(40d, REACH_DEST.getValue());
                 else
                     weightToPrioMap.put(40d, UNCHANGED.getValue());
             }
-        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway))
-        {
+        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway)) {
             if (way.hasTag("sidewalk", sidewalksNoValues))
                 weightToPrioMap.put(45d, WORST.getValue());
             else
@@ -150,8 +138,7 @@ void collect( ReaderWay way, TreeMap<Double, Integer> weightToPrioMap )
     }
 
     @Override
-    public boolean supports( Class<?> feature )
-    {
+    public boolean supports(Class<?> feature) {
         if (super.supports(feature))
             return true;
 
@@ -159,8 +146,7 @@ public boolean supports( Class<?> feature )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "hike";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
index 507ba6b75f..cf107b074e 100755
--- a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
@@ -22,50 +22,42 @@
 /**
  * @author Peter Karich
  */
-public class HintsMap extends PMap
-{
-    public HintsMap()
-    {
+public class HintsMap extends PMap {
+    public HintsMap() {
     }
 
     /**
      * Convenient constructor if only one parameter is provided
      * <p>
      */
-    public HintsMap( String weighting )
-    {
+    public HintsMap(String weighting) {
         super(5);
         setWeighting(weighting);
     }
 
     @Override
-    public HintsMap put( String key, Object str )
-    {
+    public HintsMap put(String key, Object str) {
         super.put(key, str);
         return this;
     }
 
-    public HintsMap setWeighting( String w )
-    {
+    public String getWeighting() {
+        return super.get("weighting", "").toLowerCase();
+    }
+
+    public HintsMap setWeighting(String w) {
         if (w != null)
             super.put("weighting", w);
         return this;
     }
 
-    public String getWeighting()
-    {
-        return super.get("weighting", "").toLowerCase();
+    public String getVehicle() {
+        return super.get("vehicle", "").toLowerCase();
     }
 
-    public HintsMap setVehicle( String v )
-    {
+    public HintsMap setVehicle(String v) {
         if (v != null)
             super.put("vehicle", v);
         return this;
     }
-
-    public String getVehicle()
-    {
-        return super.get("vehicle", "").toLowerCase();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 1a69e4a197..d3bbdaf569 100755
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -18,28 +18,26 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.storage.CHGraph;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
  * <p>
+ *
  * @author Peter Karich
  */
-public class LevelEdgeFilter implements EdgeFilter
-{
+public class LevelEdgeFilter implements EdgeFilter {
     private final CHGraph graph;
     private final int maxNodes;
 
-    public LevelEdgeFilter( CHGraph g )
-    {
+    public LevelEdgeFilter(CHGraph g) {
         graph = g;
         maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIterState )
-    {
+    public boolean accept(EdgeIteratorState edgeIterState) {
         int base = edgeIterState.getBaseNode();
         int adj = edgeIterState.getAdjNode();
         // always accept virtual edges, see #288
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index e3359bb105..8bbbf2d4d9 100755
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -18,6 +18,8 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.CurvatureWeighting;
+import com.graphhopper.routing.weighting.PriorityWeighting;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
@@ -33,23 +35,19 @@
  * @author Peter Karich
  * @author boldtrn
  */
-public class MotorcycleFlagEncoder extends CarFlagEncoder
-{
+public class MotorcycleFlagEncoder extends CarFlagEncoder {
     public static final int CURVATURE_KEY = 112;
-
+    private final HashSet<String> avoidSet = new HashSet<String>();
+    private final HashSet<String> preferSet = new HashSet<String>();
     private EncodedDoubleValue reverseSpeedEncoder;
     private EncodedValue priorityWayEncoder;
     private EncodedValue curvatureEncoder;
-    private final HashSet<String> avoidSet = new HashSet<String>();
-    private final HashSet<String> preferSet = new HashSet<String>();
 
-    public MotorcycleFlagEncoder()
-    {
+    public MotorcycleFlagEncoder() {
         this(5, 5, 0);
     }
 
-    public MotorcycleFlagEncoder( PMap properties )
-    {
+    public MotorcycleFlagEncoder(PMap properties) {
         this(
                 (int) properties.getLong("speed_bits", 5),
                 properties.getDouble("speed_factor", 5),
@@ -59,13 +57,11 @@ public MotorcycleFlagEncoder( PMap properties )
         this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public MotorcycleFlagEncoder( String propertiesStr )
-    {
+    public MotorcycleFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public MotorcycleFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         restrictions.remove("motorcar");
         //  moped, mofa
@@ -119,13 +115,12 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         defaultSpeedMap.put("road", 20);
         // forestry stuff
         defaultSpeedMap.put("track", 15);
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
@@ -133,8 +128,7 @@ public int getVersion()
      * Define the place of the speedBits in the edge flags for car.
      */
     @Override
-    public int defineWayBits( int index, int shift )
-    {
+    public int defineWayBits(int index, int shift) {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
@@ -151,13 +145,10 @@ public int defineWayBits( int index, int shift )
     }
 
     @Override
-    public long acceptWay( ReaderWay way )
-    {
+    public long acceptWay(ReaderWay way) {
         String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
+        if (highwayValue == null) {
+            if (way.hasTag("route", ferries)) {
                 String motorcycleTag = way.getTag("motorcycle");
                 if (motorcycleTag == null)
                     motorcycleTag = way.getTag("motor_vehicle");
@@ -168,8 +159,7 @@ public long acceptWay( ReaderWay way )
             return 0;
         }
 
-        if ("track".equals(highwayValue))
-        {
+        if ("track".equals(highwayValue)) {
             String tt = way.getTag("tracktype");
             if (tt != null && !tt.equals("grade1"))
                 return 0;
@@ -182,8 +172,7 @@ public long acceptWay( ReaderWay way )
             return 0;
 
         String firstValue = way.getFirstPriorityTag(restrictions);
-        if (!firstValue.isEmpty())
-        {
+        if (!firstValue.isEmpty()) {
             if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
                 return 0;
             if (intendedValues.contains(firstValue))
@@ -201,14 +190,12 @@ public long acceptWay( ReaderWay way )
     }
 
     @Override
-    public long handleWayTags( ReaderWay way, long allowed, long priorityFromRelation )
-    {
+    public long handleWayTags(ReaderWay way, long allowed, long priorityFromRelation) {
         if (!isAccept(allowed))
             return 0;
 
         long flags = 0;
-        if (!isFerry(allowed))
-        {
+        if (!isFerry(allowed)) {
             // get assumed speed from highway type
             double speed = getSpeed(way);
             speed = applyMaxSpeed(way, speed);
@@ -225,26 +212,21 @@ public long handleWayTags( ReaderWay way, long allowed, long priorityFromRelatio
             if (isRoundabout)
                 flags = setBool(0, K_ROUNDABOUT, true);
 
-            if (way.hasTag("oneway", oneways) || isRoundabout)
-            {
-                if (way.hasTag("oneway", "-1"))
-                {
+            if (way.hasTag("oneway", oneways) || isRoundabout) {
+                if (way.hasTag("oneway", "-1")) {
                     flags = setReverseSpeed(flags, speed);
                     flags |= backwardBit;
-                } else
-                {
+                } else {
                     flags = setSpeed(flags, speed);
                     flags |= forwardBit;
                 }
-            } else
-            {
+            } else {
                 flags = setSpeed(flags, speed);
                 flags = setReverseSpeed(flags, speed);
                 flags |= directionBitMask;
             }
 
-        } else
-        {
+        } else {
             double ferrySpeed = getFerrySpeed(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
             flags = setSpeed(flags, ferrySpeed);
             flags = setReverseSpeed(flags, ferrySpeed);
@@ -261,14 +243,12 @@ public long handleWayTags( ReaderWay way, long allowed, long priorityFromRelatio
     }
 
     @Override
-    public double getReverseSpeed( long flags )
-    {
+    public double getReverseSpeed(long flags) {
         return reverseSpeedEncoder.getDoubleValue(flags);
     }
 
     @Override
-    public long setReverseSpeed( long flags, double speed )
-    {
+    public long setReverseSpeed(long flags, double speed) {
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
@@ -282,8 +262,7 @@ public long setReverseSpeed( long flags, double speed )
     }
 
     @Override
-    protected long setLowSpeed( long flags, double speed, boolean reverse )
-    {
+    protected long setLowSpeed(long flags, double speed, boolean reverse) {
         if (reverse)
             return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
 
@@ -291,8 +270,7 @@ protected long setLowSpeed( long flags, double speed, boolean reverse )
     }
 
     @Override
-    public long flagsDefault( boolean forward, boolean backward )
-    {
+    public long flagsDefault(boolean forward, boolean backward) {
         long flags = super.flagsDefault(forward, backward);
         if (backward)
             return reverseSpeedEncoder.setDefaultValue(flags);
@@ -301,8 +279,7 @@ public long flagsDefault( boolean forward, boolean backward )
     }
 
     @Override
-    public long setProperties( double speed, boolean forward, boolean backward )
-    {
+    public long setProperties(double speed, boolean forward, boolean backward) {
         long flags = super.setProperties(speed, forward, backward);
         if (backward)
             return setReverseSpeed(flags, speed);
@@ -311,8 +288,7 @@ public long setProperties( double speed, boolean forward, boolean backward )
     }
 
     @Override
-    public long reverseFlags( long flags )
-    {
+    public long reverseFlags(long flags) {
         // swap access
         flags = super.reverseFlags(flags);
 
@@ -323,10 +299,8 @@ public long reverseFlags( long flags )
     }
 
     @Override
-    public double getDouble( long flags, int key )
-    {
-        switch (key)
-        {
+    public double getDouble(long flags, int key) {
+        switch (key) {
             case PriorityWeighting.KEY:
                 return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             case MotorcycleFlagEncoder.CURVATURE_KEY:
@@ -336,14 +310,11 @@ public double getDouble( long flags, int key )
         }
     }
 
-    private int handlePriority( ReaderWay way, long relationFlags )
-    {
+    private int handlePriority(ReaderWay way, long relationFlags) {
         String highway = way.getTag("highway", "");
-        if (avoidSet.contains(highway))
-        {
+        if (avoidSet.contains(highway)) {
             return PriorityCode.WORST.getValue();
-        } else if (preferSet.contains(highway))
-        {
+        } else if (preferSet.contains(highway)) {
             return PriorityCode.BEST.getValue();
         }
 
@@ -351,8 +322,7 @@ private int handlePriority( ReaderWay way, long relationFlags )
     }
 
     @Override
-    public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
-    {
+    public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         double speed = this.getSpeed(edge.getFlags());
         double roadDistance = edge.getDistance();
         double beelineDistance = getBeelineDistance(way);
@@ -365,18 +335,15 @@ public void applyWayTags( ReaderWay way, EdgeIteratorState edge )
         edge.setFlags(this.curvatureEncoder.setValue(edge.getFlags(), convertToInt(bendiness)));
     }
 
-    private double getBeelineDistance( ReaderWay way )
-    {
+    private double getBeelineDistance(ReaderWay way) {
         return way.getTag("estimated_distance", Double.POSITIVE_INFINITY);
     }
 
     /**
      * Streets that slow are not fun and probably in a town.
      */
-    protected double discriminateSlowStreets( double bendiness, double speed )
-    {
-        if (speed < 51)
-        {
+    protected double discriminateSlowStreets(double bendiness, double speed) {
+        if (speed < 51) {
             return 1;
         }
         return bendiness;
@@ -388,10 +355,8 @@ protected double discriminateSlowStreets( double bendiness, double speed )
      * approximated, therefore it can happen on straight roads, that the beeline is longer than the
      * road.
      */
-    protected double correctErrors( double bendiness )
-    {
-        if (bendiness < 0.01 || bendiness > 1)
-        {
+    protected double correctErrors(double bendiness) {
+        if (bendiness < 0.01 || bendiness > 1) {
             return 1;
         }
         return bendiness;
@@ -401,34 +366,29 @@ protected double correctErrors( double bendiness )
      * A good bendiness should become a greater impact. A bendiness close to 1 should not be
      * changed.
      */
-    protected double increaseBendinessImpact( double bendiness )
-    {
+    protected double increaseBendinessImpact(double bendiness) {
         return (Math.pow(bendiness, 2));
     }
 
     @Override
-    public boolean supports( Class<?> feature )
-    {
+    public boolean supports(Class<?> feature) {
         if (super.supports(feature))
             return true;
 
-        if (CurvatureWeighting.class.isAssignableFrom(feature))
-        {
+        if (CurvatureWeighting.class.isAssignableFrom(feature)) {
             return true;
         }
 
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
 
-    protected int convertToInt( double bendiness )
-    {
+    protected int convertToInt(double bendiness) {
         bendiness = bendiness * 10;
         return (int) bendiness;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "motorcycle";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index e32930cebb..697d198d15 100755
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -17,32 +17,27 @@
  */
 package com.graphhopper.routing.util;
 
-import static com.graphhopper.routing.util.PriorityCode.BEST;
-import static com.graphhopper.routing.util.PriorityCode.PREFER;
-import static com.graphhopper.routing.util.PriorityCode.UNCHANGED;
-import static com.graphhopper.routing.util.PriorityCode.VERY_NICE;
-
-import java.util.TreeMap;
-
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.util.PMap;
 
+import java.util.TreeMap;
+
+import static com.graphhopper.routing.util.PriorityCode.*;
+
 /**
  * Specifies the settings for mountain biking
  * <p>
+ *
  * @author ratrun
  * @author Peter Karich
  */
-public class MountainBikeFlagEncoder extends BikeCommonFlagEncoder
-{
-    public MountainBikeFlagEncoder()
-    {
+public class MountainBikeFlagEncoder extends BikeCommonFlagEncoder {
+    public MountainBikeFlagEncoder() {
         this(4, 2, 0);
     }
 
-    public MountainBikeFlagEncoder( PMap properties )
-    {
+    public MountainBikeFlagEncoder(PMap properties) {
         this(
                 (int) properties.getLong("speed_bits", 4),
                 properties.getDouble("speed_factor", 2),
@@ -52,13 +47,11 @@ public MountainBikeFlagEncoder( PMap properties )
         this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public MountainBikeFlagEncoder( String propertiesStr )
-    {
+    public MountainBikeFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public MountainBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         setTrackTypeSpeed("grade1", 18); // paved
         setTrackTypeSpeed("grade2", 16); // now unpaved ...
@@ -141,24 +134,21 @@ public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCo
 
         potentialBarriers.add("kissing_gate");
         setSpecificClassBicycle("mtb");
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    void collect( ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap )
-    {
+    void collect(ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap) {
         super.collect(way, wayTypeSpeed, weightToPrioMap);
 
         String highway = way.getTag("highway");
-        if ("track".equals(highway))
-        {
+        if ("track".equals(highway)) {
             String trackType = way.getTag("tracktype");
             if ("grade1".equals(trackType))
                 weightToPrioMap.put(50d, UNCHANGED.getValue());
@@ -170,8 +160,7 @@ else if (trackType.startsWith("grade"))
     }
 
     @Override
-    public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-    {
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         oldRelationFlags = super.handleRelationTags(relation, oldRelationFlags);
         int code = 0;
         if (relation.hasTag("route", "mtb"))
@@ -184,16 +173,14 @@ public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
     }
 
     @Override
-    boolean isSacScaleAllowed( String sacScale )
-    {
+    boolean isSacScaleAllowed(String sacScale) {
         // other scales are too dangerous even for MTB, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
         return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale)
                 || "demanding_mountain_hiking".equals(sacScale) || "alpine_hiking".equals(sacScale);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index 7f380b8623..e286be16e6 100755
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -21,10 +21,10 @@
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
  * <p>
+ *
  * @author Peter Karich
  */
-public enum PriorityCode
-{
+public enum PriorityCode {
     WORST(0),
     AVOID_AT_ALL_COSTS(1),
     REACH_DEST(2),
@@ -35,13 +35,11 @@
     BEST(7);
     private final int value;
 
-    private PriorityCode( int value )
-    {
+    private PriorityCode(int value) {
         this.value = value;
     }
 
-    public int getValue()
-    {
+    public int getValue() {
         return value;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index d4ed20418b..bc36886c31 100755
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -20,25 +20,23 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.util.PMap;
 
-import static com.graphhopper.routing.util.PriorityCode.*;
-
 import java.util.TreeMap;
 
+import static com.graphhopper.routing.util.PriorityCode.*;
+
 /**
  * Specifies the settings for race biking
  * <p>
+ *
  * @author ratrun
  * @author Peter Karich
  */
-public class RacingBikeFlagEncoder extends BikeCommonFlagEncoder
-{
-    public RacingBikeFlagEncoder()
-    {
+public class RacingBikeFlagEncoder extends BikeCommonFlagEncoder {
+    public RacingBikeFlagEncoder() {
         this(4, 2, 0);
     }
 
-    public RacingBikeFlagEncoder( PMap properties )
-    {
+    public RacingBikeFlagEncoder(PMap properties) {
         this(
                 (int) properties.getLong("speed_bits", 4),
                 properties.getDouble("speed_factor", 2),
@@ -48,13 +46,11 @@ public RacingBikeFlagEncoder( PMap properties )
         this.setBlockFords(properties.getBool("block_fords", true));
     }
 
-    public RacingBikeFlagEncoder( String propertiesStr )
-    {
+    public RacingBikeFlagEncoder(String propertiesStr) {
         this(new PMap(propertiesStr));
     }
 
-    public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
+    public RacingBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
         preferHighwayTags.add("road");
         preferHighwayTags.add("secondary");
@@ -130,27 +126,23 @@ public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
 
         setAvoidSpeedLimit(81);
         setSpecificClassBicycle("roadcycling");
-        
+
         init();
     }
 
     @Override
-    public int getVersion()
-    {
+    public int getVersion() {
         return 1;
     }
 
     @Override
-    void collect( ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap )
-    {
+    void collect(ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weightToPrioMap) {
         super.collect(way, wayTypeSpeed, weightToPrioMap);
 
         String highway = way.getTag("highway");
-        if ("service".equals(highway))
-        {
+        if ("service".equals(highway)) {
             weightToPrioMap.put(40d, UNCHANGED.getValue());
-        } else if ("track".equals(highway))
-        {
+        } else if ("track".equals(highway)) {
             String trackType = way.getTag("tracktype");
             if ("grade1".equals(trackType))
                 weightToPrioMap.put(110d, PREFER.getValue());
@@ -160,8 +152,7 @@ else if (trackType == null || trackType.startsWith("grade"))
     }
 
     @Override
-    boolean isPushingSection( ReaderWay way )
-    {
+    boolean isPushingSection(ReaderWay way) {
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return way.hasTag("highway", pushingSectionsHighways)
@@ -171,15 +162,13 @@ boolean isPushingSection( ReaderWay way )
     }
 
     @Override
-    boolean isSacScaleAllowed( String sacScale )
-    {
+    boolean isSacScaleAllowed(String sacScale) {
         // for racing bike it is only allowed if empty
         return false;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "racingbike";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index fb7d9965d5..3ac4bba023 100755
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -19,8 +19,9 @@
 
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.*;
-import com.graphhopper.storage.Graph;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -34,31 +35,27 @@
 /**
  * @author Peter Karich
  */
-public class TestAlgoCollector
-{
+public class TestAlgoCollector {
+    public final List<String> errors = new ArrayList<String>();
     private final String name;
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private final TranslationMap trMap = new TranslationMap().doImport();
-    public final List<String> errors = new ArrayList<String>();
 
-    public TestAlgoCollector( String name )
-    {
+    public TestAlgoCollector(String name) {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
-                                             OneRun oneRun )
-    {
+    public TestAlgoCollector assertDistance(AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+                                            OneRun oneRun) {
         List<Path> altPaths = new ArrayList<Path>();
         QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
         queryGraph.lookup(queryList);
         AlgorithmOptions opts = algoEntry.opts;
-        FlagEncoder encoder = opts.getFlagEncoder();
+        FlagEncoder encoder = opts.getWeighting().getFlagEncoder();
         if (encoder.supports(TurnWeighting.class))
-            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), opts.getFlagEncoder(), (TurnCostExtension) queryGraph.getExtension())).build());
+            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), (TurnCostExtension) queryGraph.getExtension())).build());
 
-        for (int i = 0; i < queryList.size() - 1; i++)
-        {
+        for (int i = 0; i < queryList.size() - 1; i++) {
             RoutingAlgorithm algo = algoEntry.createAlgo(queryGraph);
             Path path = algo.calcPath(queryList.get(i).getClosestNode(), queryList.get(i + 1).getClosestNode());
             // System.out.println(path.calcInstructions().createGPX("temp", 0, "GMT"));
@@ -72,8 +69,7 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
         PathWrapper rsp = new PathWrapper();
         pathMerger.doWork(rsp, altPaths, trMap.getWithFallBack(Locale.US));
 
-        if (rsp.hasErrors())
-        {
+        if (rsp.hasErrors()) {
             errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
                     + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
@@ -81,23 +77,20 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
 
         PointList pointList = rsp.getPoints();
         double tmpDist = pointList.calcDistance(distCalc);
-        if (Math.abs(rsp.getDistance() - tmpDist) > 2)
-        {
+        if (Math.abs(rsp.getDistance() - tmpDist) > 2) {
             errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
 
-        if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2)
-        {
+        if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2) {
             errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
                     + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
                     + ", was " + pointList.getSize() + ") " + queryList);
         }
 
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
-        if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1)
-        {
+        if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1) {
             errors.add(algoEntry + " returns path not matching the expected points of " + oneRun.getLocs()
                     + "\t Returned was " + pointList.getSize() + "\t (expected distance " + oneRun.getDistance()
                     + ", was " + rsp.getDistance() + ") " + queryList);
@@ -105,19 +98,16 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
         return this;
     }
 
-    void queryIndex( Graph g, LocationIndex idx, double lat, double lon, double expectedDist )
-    {
+    void queryIndex(Graph g, LocationIndex idx, double lat, double lon, double expectedDist) {
         QueryResult res = idx.findClosest(lat, lon, EdgeFilter.ALL_EDGES);
-        if (!res.isValid())
-        {
+        if (!res.isValid()) {
             errors.add("node not found for " + lat + "," + lon);
             return;
         }
 
         GHPoint found = res.getSnappedPoint();
         double dist = distCalc.calcDist(lat, lon, found.lat, found.lon);
-        if (Math.abs(dist - expectedDist) > .1)
-        {
+        if (Math.abs(dist - expectedDist) > .1) {
             errors.add("queried lat,lon=" + (float) lat + "," + (float) lon
                     + " (found: " + (float) found.lat + "," + (float) found.lon + ")"
                     + "\n   expected distance:" + expectedDist + ", but was:" + dist);
@@ -125,156 +115,127 @@ void queryIndex( Graph g, LocationIndex idx, double lat, double lon, double expe
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = "";
         str += "FOUND " + errors.size() + " ERRORS.\n";
-        for (String s : errors)
-        {
+        for (String s : errors) {
             str += s + ".\n";
         }
         return str;
     }
 
-    void printSummary()
-    {
-        if (errors.size() > 0)
-        {
+    void printSummary() {
+        if (errors.size() > 0) {
             System.out.println("\n-------------------------------\n");
             System.out.println(toString());
-        } else
-        {
+        } else {
             System.out.println("SUCCESS for " + name + "!");
         }
     }
 
-    public static class AlgoHelperEntry
-    {
-        private Graph queryGraph;
+    public static class AlgoHelperEntry {
         private final Graph baseGraph;
         private final LocationIndex idx;
+        private Graph queryGraph;
         private AlgorithmOptions opts;
 
-        public AlgoHelperEntry( Graph g, Graph baseGraph, AlgorithmOptions opts, LocationIndex idx )
-        {
+        public AlgoHelperEntry(Graph g, Graph baseGraph, AlgorithmOptions opts, LocationIndex idx) {
             this.queryGraph = g;
             this.baseGraph = baseGraph;
             this.opts = opts;
             this.idx = idx;
         }
 
-        public Graph getQueryGraph()
-        {
+        public Graph getQueryGraph() {
             return queryGraph;
         }
 
-        public void setQueryGraph( Graph queryGraph )
-        {
+        public void setQueryGraph(Graph queryGraph) {
             this.queryGraph = queryGraph;
         }
 
-        public Graph getBaseGraph()
-        {
+        public Graph getBaseGraph() {
             return baseGraph;
         }
 
-        public void setAlgorithmOptions( AlgorithmOptions opts )
-        {
+        public void setAlgorithmOptions(AlgorithmOptions opts) {
             this.opts = opts;
         }
 
-        public LocationIndex getIdx()
-        {
+        public LocationIndex getIdx() {
             return idx;
         }
 
-        public RoutingAlgorithm createAlgo( Graph qGraph )
-        {
+        public RoutingAlgorithm createAlgo(Graph qGraph) {
             return new RoutingAlgorithmFactorySimple().createAlgo(qGraph, opts);
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return opts.getAlgorithm() + (queryGraph instanceof CHGraph ? "CH" : "");
         }
     }
 
-    public static class OneRun
-    {
+    public static class OneRun {
         private final List<AssumptionPerPath> assumptions = new ArrayList<AssumptionPerPath>();
 
-        public OneRun()
-        {
+        public OneRun() {
         }
 
-        public OneRun( double fromLat, double fromLon, double toLat, double toLon, double dist, int locs )
-        {
+        public OneRun(double fromLat, double fromLon, double toLat, double toLon, double dist, int locs) {
             add(fromLat, fromLon, 0, 0);
             add(toLat, toLon, dist, locs);
         }
 
-        public OneRun add( double lat, double lon, double dist, int locs )
-        {
+        public OneRun add(double lat, double lon, double dist, int locs) {
             assumptions.add(new AssumptionPerPath(lat, lon, dist, locs));
             return this;
         }
 
-        public int getLocs()
-        {
+        public int getLocs() {
             int sum = 0;
-            for (AssumptionPerPath as : assumptions)
-            {
+            for (AssumptionPerPath as : assumptions) {
                 sum += as.locs;
             }
             return sum;
         }
 
-        public void setLocs( int index, int locs )
-        {
+        public void setLocs(int index, int locs) {
             assumptions.get(index).locs = locs;
         }
 
-        public double getDistance()
-        {
+        public double getDistance() {
             double sum = 0;
-            for (AssumptionPerPath as : assumptions)
-            {
+            for (AssumptionPerPath as : assumptions) {
                 sum += as.distance;
             }
             return sum;
         }
 
-        public void setDistance( int index, double dist )
-        {
+        public void setDistance(int index, double dist) {
             assumptions.get(index).distance = dist;
         }
 
-        public List<QueryResult> getList( LocationIndex idx, EdgeFilter edgeFilter )
-        {
+        public List<QueryResult> getList(LocationIndex idx, EdgeFilter edgeFilter) {
             List<QueryResult> qr = new ArrayList<QueryResult>();
-            for (AssumptionPerPath p : assumptions)
-            {
+            for (AssumptionPerPath p : assumptions) {
                 qr.add(idx.findClosest(p.lat, p.lon, edgeFilter));
             }
             return qr;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return assumptions.toString();
         }
     }
 
-    static class AssumptionPerPath
-    {
+    static class AssumptionPerPath {
         double lat, lon;
         int locs;
         double distance;
 
-        public AssumptionPerPath( double lat, double lon, double distance, int locs )
-        {
+        public AssumptionPerPath(double lat, double lon, double distance, int locs) {
             this.lat = lat;
             this.lon = lon;
             this.locs = locs;
@@ -282,8 +243,7 @@ public AssumptionPerPath( double lat, double lon, double distance, int locs )
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return lat + ", " + lon + ", locs:" + locs + ", dist:" + distance;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index d7d4798e0e..e54ad8532b 100755
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -28,10 +28,10 @@
  * still all are without via-way support. BTW: this would not be done at runtime, this would be a
  * pre-processing step to avoid performance penalties.
  * <p>
+ *
  * @author Peter Karich
  */
-public enum TraversalMode
-{
+public enum TraversalMode {
     /**
      * The simplest traversal mode but without turn restrictions or cost support.
      */
@@ -59,8 +59,7 @@
     private final int noOfStates;
     private final boolean uTurnSupport;
 
-    TraversalMode( boolean edgeBased, int noOfStates, boolean uTurnSupport )
-    {
+    TraversalMode(boolean edgeBased, int noOfStates, boolean uTurnSupport) {
         this.edgeBased = edgeBased;
         this.noOfStates = noOfStates;
         this.uTurnSupport = uTurnSupport;
@@ -69,20 +68,28 @@
             throw new IllegalArgumentException("Currently only 1 or 2 states allowed");
     }
 
+    public static TraversalMode fromString(String name) {
+        try {
+            return valueOf(name.toUpperCase());
+        } catch (Exception ex) {
+            throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
+                    + "Supported are: " + Arrays.asList(TraversalMode.values()));
+        }
+    }
+
     /**
      * Returns the identifier to access the map of the shortest path tree according to the traversal
      * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
      * in edge-based behavior
      * <p>
+     *
      * @param iterState the current {@link EdgeIteratorState}
-     * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
-     * backward searches in bidirectional algorithms.
+     * @param reverse   <code>true</code>, if traversal in backward direction. Will be true only for
+     *                  backward searches in bidirectional algorithms.
      * @return the identifier to access the shortest path tree
      */
-    public final int createTraversalId( EdgeIteratorState iterState, boolean reverse )
-    {
-        if (edgeBased)
-        {
+    public final int createTraversalId(EdgeIteratorState iterState, boolean reverse) {
+        if (edgeBased) {
             if (noOfStates == 1)
                 return iterState.getEdge();
 
@@ -95,10 +102,8 @@ public final int createTraversalId( EdgeIteratorState iterState, boolean reverse
     /**
      * If you have an EdgeIteratorState the other createTraversalId is preferred!
      */
-    public final int createTraversalId( int baseNode, int adjNode, int edgeId, boolean reverse )
-    {
-        if (edgeBased)
-        {
+    public final int createTraversalId(int baseNode, int adjNode, int edgeId, boolean reverse) {
+        if (edgeBased) {
             if (noOfStates == 1)
                 return edgeId;
 
@@ -108,37 +113,21 @@ public final int createTraversalId( int baseNode, int adjNode, int edgeId, boole
         return adjNode;
     }
 
-    public int reverseEdgeKey( int edgeKey )
-    {
+    public int reverseEdgeKey(int edgeKey) {
         if (edgeBased && noOfStates > 1)
             return GHUtility.reverseEdgeKey(edgeKey);
         return edgeKey;
     }
 
-    public int getNoOfStates()
-    {
+    public int getNoOfStates() {
         return noOfStates;
     }
 
-    public boolean isEdgeBased()
-    {
+    public boolean isEdgeBased() {
         return edgeBased;
     }
 
-    public final boolean hasUTurnSupport()
-    {
+    public final boolean hasUTurnSupport() {
         return uTurnSupport;
     }
-
-    public static TraversalMode fromString( String name )
-    {
-        try
-        {
-            return valueOf(name.toUpperCase());
-        } catch (Exception ex)
-        {
-            throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
-                    + "Supported are: " + Arrays.asList(TraversalMode.values()));
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index c3686b9db8..d0d05d8f0b 100755
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -20,52 +20,47 @@
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
  * <p>
+ *
  * @author Karl Hübner
  */
-public interface TurnCostEncoder
-{
+public interface TurnCostEncoder {
     /**
      * @return true, if the turn restriction is encoded in the specified flags
      */
-    boolean isTurnRestricted( long flags );
+    boolean isTurnRestricted(long flags);
 
     /**
      * @return the costs encoded in the specified flag, if restricted it will be
      * Double.POSITIVE_INFINITY
      */
-    double getTurnCost( long flags );
+    double getTurnCost(long flags);
 
     /**
      * @param restricted true if restricted turn, equivalent to specifying of costs
-     * Double.POSITIVE_INFINITY
-     * @param costs the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
-     * Only used if restricted == false.
+     *                   Double.POSITIVE_INFINITY
+     * @param costs      the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
+     *                   Only used if restricted == false.
      * @return the encoded flags
      */
-    long getTurnFlags( boolean restricted, double costs );
+    long getTurnFlags(boolean restricted, double costs);
 
     /**
-     * whether turn costs nor turn restrictions will be encoded by this encoder, should be used for
-     * pedestrians
+     * No turn costs will be enabled by this encoder, should be used for pedestrians
      */
-    class NoTurnCostsEncoder implements TurnCostEncoder
-    {
+    class NoTurnCostsEncoder implements TurnCostEncoder {
 
         @Override
-        public boolean isTurnRestricted( long flags )
-        {
+        public boolean isTurnRestricted(long flags) {
             return false;
         }
 
         @Override
-        public double getTurnCost( long flags )
-        {
+        public double getTurnCost(long flags) {
             return 0;
         }
 
         @Override
-        public long getTurnFlags( boolean restriction, double costs )
-        {
+        public long getTurnFlags(boolean restriction, double costs) {
             return 0;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/tour/MultiPointTour.java b/core/src/main/java/com/graphhopper/routing/util/tour/MultiPointTour.java
index 96858905b0..db68185c41 100755
--- a/core/src/main/java/com/graphhopper/routing/util/tour/MultiPointTour.java
+++ b/core/src/main/java/com/graphhopper/routing/util/tour/MultiPointTour.java
@@ -24,18 +24,15 @@
  *
  * @author Robin Boldt
  */
-public class MultiPointTour extends TourStrategy
-{
+public class MultiPointTour extends TourStrategy {
     private final int allPoints;
     private final double initialHeading;
 
-    public MultiPointTour( Random random, double distanceInMeter, int allPoints )
-    {
+    public MultiPointTour(Random random, double distanceInMeter, int allPoints) {
         this(random, distanceInMeter, allPoints, Double.NaN);
     }
 
-    public MultiPointTour( Random random, double distanceInMeter, int allPoints, double initialHeading )
-    {
+    public MultiPointTour(Random random, double distanceInMeter, int allPoints, double initialHeading) {
         super(random, distanceInMeter);
         this.allPoints = allPoints;
         if (Double.isNaN(initialHeading))
@@ -45,20 +42,17 @@ public MultiPointTour( Random random, double distanceInMeter, int allPoints, dou
     }
 
     @Override
-    public int getNumberOfGeneratedPoints()
-    {
+    public int getNumberOfGeneratedPoints() {
         return allPoints - 1;
     }
 
     @Override
-    public double getDistanceForIteration( int iteration )
-    {
+    public double getDistanceForIteration(int iteration) {
         return slightlyModifyDistance(overallDistance / (allPoints + 1));
     }
 
     @Override
-    public double getHeadingForIteration( int iteration )
-    {
+    public double getHeadingForIteration(int iteration) {
         if (iteration == 0)
             return initialHeading;
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/tour/SinglePointTour.java b/core/src/main/java/com/graphhopper/routing/util/tour/SinglePointTour.java
index 84efd6c7ef..e01ab9675f 100755
--- a/core/src/main/java/com/graphhopper/routing/util/tour/SinglePointTour.java
+++ b/core/src/main/java/com/graphhopper/routing/util/tour/SinglePointTour.java
@@ -24,28 +24,23 @@
  *
  * @author Robin Boldt
  */
-public class SinglePointTour extends TourStrategy
-{
-    public SinglePointTour( Random random, double distanceInMeter )
-    {
+public class SinglePointTour extends TourStrategy {
+    public SinglePointTour(Random random, double distanceInMeter) {
         super(random, distanceInMeter);
     }
 
     @Override
-    public int getNumberOfGeneratedPoints()
-    {
+    public int getNumberOfGeneratedPoints() {
         return 1;
     }
 
     @Override
-    public double getDistanceForIteration( int iteration )
-    {
+    public double getDistanceForIteration(int iteration) {
         return slightlyModifyDistance(overallDistance / 3);
     }
 
     @Override
-    public double getHeadingForIteration( int iteration )
-    {
+    public double getHeadingForIteration(int iteration) {
         return random.nextInt(360);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/tour/TourStrategy.java b/core/src/main/java/com/graphhopper/routing/util/tour/TourStrategy.java
index ea0b101647..e7663997a8 100755
--- a/core/src/main/java/com/graphhopper/routing/util/tour/TourStrategy.java
+++ b/core/src/main/java/com/graphhopper/routing/util/tour/TourStrategy.java
@@ -24,13 +24,11 @@
  *
  * @author Robin Boldt
  */
-public abstract class TourStrategy
-{
+public abstract class TourStrategy {
     protected final Random random;
     protected final double overallDistance;
 
-    public TourStrategy( Random random, double distanceInMeter )
-    {
+    public TourStrategy(Random random, double distanceInMeter) {
         this.random = random;
         this.overallDistance = distanceInMeter;
     }
@@ -43,18 +41,17 @@ public TourStrategy( Random random, double distanceInMeter )
     /**
      * Returns the distance in meter that is used for the generated point of a certain iteration
      */
-    public abstract double getDistanceForIteration( int iteration );
+    public abstract double getDistanceForIteration(int iteration);
 
     /**
      * Returns the north based heading between 0 and 360 for a certain iteration.
      */
-    public abstract double getHeadingForIteration( int iteration );
+    public abstract double getHeadingForIteration(int iteration);
 
     /**
      * Modifies the Distance up to +-10%
      */
-    protected double slightlyModifyDistance( double distance )
-    {
+    protected double slightlyModifyDistance(double distance) {
         double distanceModification = random.nextDouble() * .1 * distance;
         if (random.nextBoolean())
             distanceModification = -distanceModification;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAdjustedWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractAdjustedWeighting.java
similarity index 73%
rename from core/src/main/java/com/graphhopper/routing/util/AbstractAdjustedWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/AbstractAdjustedWeighting.java
index e26876891e..c712fb9da3 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAdjustedWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractAdjustedWeighting.java
@@ -15,43 +15,47 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * The AdjustedWeighting wraps another Weighting.
  *
  * @author Robin Boldt
  */
-public abstract class AbstractAdjustedWeighting implements Weighting
-{
+public abstract class AbstractAdjustedWeighting implements Weighting {
     protected final Weighting superWeighting;
 
-    public AbstractAdjustedWeighting( Weighting superWeighting )
-    {
+    public AbstractAdjustedWeighting(Weighting superWeighting) {
         if (superWeighting == null)
             throw new IllegalArgumentException("No super weighting set");
         this.superWeighting = superWeighting;
     }
 
+    @Override
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        return superWeighting.calcMillis(edgeState, reverse, prevOrNextEdgeId);
+    }
+
     /**
      * Returns the flagEncoder of the superWeighting. Usually we do not have a Flagencoder here.
      */
     @Override
-    public FlagEncoder getFlagEncoder()
-    {
+    public FlagEncoder getFlagEncoder() {
         return superWeighting.getFlagEncoder();
     }
 
     @Override
-    public boolean matches( HintsMap reqMap )
-    {
+    public boolean matches(HintsMap reqMap) {
         return getName().equals(reqMap.getWeighting())
                 && superWeighting.getFlagEncoder().toString().equals(reqMap.getVehicle());
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getName() + "|" + superWeighting.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
similarity index 56%
rename from core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index ccd782b8f2..55ddc7dd27 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -15,18 +15,19 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
- *
  * @author Peter Karich
  */
-public abstract class AbstractWeighting implements Weighting
-{
+public abstract class AbstractWeighting implements Weighting {
     protected final FlagEncoder flagEncoder;
 
-    public AbstractWeighting( FlagEncoder encoder )
-    {
+    public AbstractWeighting(FlagEncoder encoder) {
         this.flagEncoder = encoder;
         if (!flagEncoder.isRegistered())
             throw new IllegalStateException("Make sure you add the FlagEncoder " + flagEncoder + " to an EncodingManager before using it elsewhere");
@@ -35,29 +36,42 @@ public AbstractWeighting( FlagEncoder encoder )
     }
 
     @Override
-    public boolean matches( HintsMap reqMap )
-    {
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        long flags = edgeState.getFlags();
+        if (reverse && !flagEncoder.isBackward(flags)
+                || !reverse && !flagEncoder.isForward(flags))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + reverse + ", fwd:" + flagEncoder.isForward(flags) + ", bwd:" + flagEncoder.isBackward(flags));
+
+        double speed = reverse ? flagEncoder.getReverseSpeed(flags) : flagEncoder.getSpeed(flags);
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");        
+
+        return (long) (edgeState.getDistance() * 3600 / speed);
+    }
+
+    @Override
+    public boolean matches(HintsMap reqMap) {
         return getName().equals(reqMap.getWeighting())
                 && flagEncoder.toString().equals(reqMap.getVehicle());
     }
 
     @Override
-    public FlagEncoder getFlagEncoder()
-    {
+    public FlagEncoder getFlagEncoder() {
         return flagEncoder;
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 7;
         hash = 71 * hash + toString().hashCode();
         return hash;
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
         if (getClass() != obj.getClass())
@@ -66,8 +80,7 @@ public boolean equals( Object obj )
         return toString().equals(other.toString());
     }
 
-    static final boolean isValidName( String name )
-    {
+    static final boolean isValidName(String name) {
         if (name == null || name.isEmpty())
             return false;
 
@@ -77,14 +90,12 @@ static final boolean isValidName( String name )
     /**
      * Replaces all characters which are not numbers, characters or underscores with underscores
      */
-    public static String weightingToFileName( Weighting w )
-    {
+    public static String weightingToFileName(Weighting w) {
         return w.toString().toLowerCase().replaceAll("\\|", "_");
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getName() + "|" + flagEncoder;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AvoidEdgesWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AvoidEdgesWeighting.java
similarity index 79%
rename from core/src/main/java/com/graphhopper/routing/util/AvoidEdgesWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/AvoidEdgesWeighting.java
index 0894992208..74e8032f7f 100755
--- a/core/src/main/java/com/graphhopper/routing/util/AvoidEdgesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AvoidEdgesWeighting.java
@@ -15,11 +15,12 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 import com.graphhopper.util.EdgeIteratorState;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Collection;
 
 /**
@@ -27,20 +28,17 @@
  *
  * @author RobinBoldt
  */
-public class AvoidEdgesWeighting extends AbstractAdjustedWeighting
-{
+public class AvoidEdgesWeighting extends AbstractAdjustedWeighting {
     // contains the edge IDs of the already visited edges
     protected final TIntSet visitedEdges = new TIntHashSet();
 
     private double edgePenaltyFactor = 5.0;
 
-    public AvoidEdgesWeighting( Weighting superWeighting )
-    {
+    public AvoidEdgesWeighting(Weighting superWeighting) {
         super(superWeighting);
     }
 
-    public AvoidEdgesWeighting setEdgePenaltyFactor( double edgePenaltyFactor )
-    {
+    public AvoidEdgesWeighting setEdgePenaltyFactor(double edgePenaltyFactor) {
         this.edgePenaltyFactor = edgePenaltyFactor;
         return this;
     }
@@ -49,23 +47,19 @@ public AvoidEdgesWeighting setEdgePenaltyFactor( double edgePenaltyFactor )
      * This method adds the specified path to this weighting which should be penalized in the
      * calcWeight method.
      */
-    public void addEdges( Collection<EdgeIteratorState> edges )
-    {
-        for (EdgeIteratorState edge : edges)
-        {
+    public void addEdges(Collection<EdgeIteratorState> edges) {
+        for (EdgeIteratorState edge : edges) {
             visitedEdges.add(edge.getEdge());
         }
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return superWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
         if (visitedEdges.contains(edgeState.getEdge()))
             return weight * edgePenaltyFactor;
@@ -74,8 +68,7 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return "avoid_edges";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/weighting/BeelineWeightApproximator.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
rename to core/src/main/java/com/graphhopper/routing/weighting/BeelineWeightApproximator.java
index 035c50525a..d0238466a1 100755
--- a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/BeelineWeightApproximator.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
@@ -25,44 +25,39 @@
  * Approximates the distance to the goal node by weighting the beeline distance according to the
  * distance weighting
  * <p>
+ *
  * @author jansoe
  */
-public class BeelineWeightApproximator implements WeightApproximator
-{
+public class BeelineWeightApproximator implements WeightApproximator {
     private final NodeAccess nodeAccess;
     private final Weighting weighting;
     private DistanceCalc distanceCalc = Helper.DIST_EARTH;
     private double toLat, toLon;
     private double epsilon = 1;
 
-    public BeelineWeightApproximator( NodeAccess nodeAccess, Weighting weighting )
-    {
+    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
         this.nodeAccess = nodeAccess;
         this.weighting = weighting;
     }
 
     @Override
-    public void setGoalNode( int toNode )
-    {
+    public void setGoalNode(int toNode) {
         toLat = nodeAccess.getLatitude(toNode);
         toLon = nodeAccess.getLongitude(toNode);
     }
 
-    public WeightApproximator setEpsilon( double epsilon )
-    {
+    public WeightApproximator setEpsilon(double epsilon) {
         this.epsilon = epsilon;
         return this;
     }
 
     @Override
-    public WeightApproximator duplicate()
-    {
+    public WeightApproximator duplicate() {
         return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc).setEpsilon(epsilon);
     }
 
     @Override
-    public double approximate( int fromNode )
-    {
+    public double approximate(int fromNode) {
         double fromLat = nodeAccess.getLatitude(fromNode);
         double fromLon = nodeAccess.getLongitude(fromNode);
         double dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
@@ -70,8 +65,7 @@ public double approximate( int fromNode )
         return weight2goal * epsilon;
     }
 
-    public BeelineWeightApproximator setDistanceCalc( DistanceCalc distanceCalc )
-    {
+    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
         this.distanceCalc = distanceCalc;
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/weighting/ConsistentWeightApproximator.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
rename to core/src/main/java/com/graphhopper/routing/weighting/ConsistentWeightApproximator.java
index 31c3c99c9e..5160e1bf1b 100755
--- a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/ConsistentWeightApproximator.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 /**
  * Turns an unidirectional weight Approximation into a bidirectional consistent one.
@@ -24,30 +24,26 @@
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
  * pages 291–296.
  * <p>
+ *
  * @author jansoe
  */
-public class ConsistentWeightApproximator
-{
+public class ConsistentWeightApproximator {
     private final WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
 
-    public ConsistentWeightApproximator( WeightApproximator weightApprox )
-    {
+    public ConsistentWeightApproximator(WeightApproximator weightApprox) {
         uniDirApproximatorForward = weightApprox;
         uniDirApproximatorReverse = weightApprox.duplicate();
     }
 
-    public void setSourceNode( int sourceNode )
-    {
+    public void setSourceNode(int sourceNode) {
         uniDirApproximatorReverse.setGoalNode(sourceNode);
     }
 
-    public void setGoalNode( int goalNode )
-    {
+    public void setGoalNode(int goalNode) {
         uniDirApproximatorForward.setGoalNode(goalNode);
     }
 
-    public double approximate( int fromNode, boolean reverse )
-    {
+    public double approximate(int fromNode, boolean reverse) {
         double weightApproximation = 0.5
                 * (uniDirApproximatorForward.approximate(fromNode) - uniDirApproximatorReverse.approximate(fromNode));
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
similarity index 79%
rename from core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
index e8f8ab4135..2e1f27a65a 100755
--- a/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
@@ -15,20 +15,20 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
 /**
  * This Class uses bendiness parameter to prefer curvy routes.
  */
-public class CurvatureWeighting extends PriorityWeighting
-{
+public class CurvatureWeighting extends PriorityWeighting {
     private final double minFactor;
 
-    public CurvatureWeighting( FlagEncoder flagEncoder, PMap pMap )
-    {
+    public CurvatureWeighting(FlagEncoder flagEncoder, PMap pMap) {
         super(flagEncoder, pMap);
 
         double minBendiness = 1; // see correctErrors
@@ -37,14 +37,12 @@ public CurvatureWeighting( FlagEncoder flagEncoder, PMap pMap )
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return minFactor * distance;
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
         double priority = flagEncoder.getDouble(edge.getFlags(), KEY);
         double bendiness = flagEncoder.getDouble(edge.getFlags(), MotorcycleFlagEncoder.CURVATURE_KEY);
         double speed = getRoadSpeed(edge, reverse);
@@ -56,14 +54,12 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         return (bendiness * regularWeight) / (0.5 + priority);
     }
 
-    protected double getRoadSpeed( EdgeIteratorState edge, boolean reverse )
-    {
+    protected double getRoadSpeed(EdgeIteratorState edge, boolean reverse) {
         return reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return "curvature";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
index 4a13da7eec..98d4a7183b 100755
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
@@ -15,8 +15,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters.Routing;
@@ -28,37 +29,34 @@
  *
  * @author Peter Karich
  */
-public class FastestWeighting extends AbstractWeighting
-{
+public class FastestWeighting extends AbstractWeighting {
     /**
      * Converting to seconds is not necessary but makes adding other penalties easier (e.g. turn
      * costs or traffic light costs etc)
      */
-    protected final static double SPEED_CONV = 3.6;    
+    protected final static double SPEED_CONV = 3.6;
     private final double headingPenalty;
+    private final long headingPenaltyMillis;
     private final double maxSpeed;
 
-    public FastestWeighting( FlagEncoder encoder, PMap pMap )
-    {
+    public FastestWeighting(FlagEncoder encoder, PMap pMap) {
         super(encoder);
         headingPenalty = pMap.getDouble(Routing.HEADING_PENALTY, Routing.DEFAULT_HEADING_PENALTY);
+        headingPenaltyMillis = Math.round(headingPenalty * 1000);
         maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
-    public FastestWeighting( FlagEncoder encoder )
-    {
+    public FastestWeighting(FlagEncoder encoder) {
         this(encoder, new PMap(0));
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return distance / maxSpeed;
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
         double speed = reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
@@ -66,16 +64,26 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         double time = edge.getDistance() / speed * SPEED_CONV;
 
         // add direction penalties at start/stop/via points
-        boolean penalizeEdge = edge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, reverse, false);
-        if (penalizeEdge)
+        boolean unfavoredEdge = edge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge)
             time += headingPenalty;
 
         return time;
     }
 
     @Override
-    public String getName()
-    {
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        // TODO move this to AbstractWeighting?
+        long time = 0;
+        boolean unfavoredEdge = edgeState.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge)
+            time += headingPenaltyMillis;
+
+        return time + super.calcMillis(edgeState, reverse, prevOrNextEdgeId);
+    }
+
+    @Override
+    public String getName() {
         return "fastest";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java
new file mode 100644
index 0000000000..03bf29c499
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java
@@ -0,0 +1,126 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.util.ConfigMap;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Parameters.Routing;
+
+/**
+ * Calculates the best route according to a configurable weighting.
+ * <p>
+ *
+ * @author Peter Karich
+ */
+public class GenericWeighting extends AbstractWeighting {
+    /**
+     * Converting to seconds is not necessary but makes adding other penalties easier (e.g. turn
+     * costs or traffic light costs etc)
+     */
+    protected final static double SPEED_CONV = 3.6;
+    private final double headingPenalty;
+    private final long headingPenaltyMillis;
+    private final double maxSpeed;
+    private final DataFlagEncoder gEncoder;
+    private final double[] speedArray;
+    private final int accessType;
+
+    public GenericWeighting(DataFlagEncoder encoder, ConfigMap cMap) {
+        super(encoder);
+        gEncoder = encoder;
+        headingPenalty = cMap.getDouble(Routing.HEADING_PENALTY, Routing.DEFAULT_HEADING_PENALTY);
+        headingPenaltyMillis = Math.round(headingPenalty * 1000);
+
+        speedArray = gEncoder.getHighwaySpeedMap(cMap.getMap("highways", Double.class));
+        double tmpSpeed = 0;
+        for (double speed : speedArray) {
+            if (speed > tmpSpeed)
+                tmpSpeed = speed;
+        }
+        if (tmpSpeed > encoder.getMaxPossibleSpeed())
+            throw new IllegalArgumentException("Speed bigger than maximum speed: " + tmpSpeed + " > " + encoder.getMaxPossibleSpeed());
+
+        maxSpeed = tmpSpeed / SPEED_CONV;
+        accessType = gEncoder.getAccessType("motor_vehicle");
+    }
+
+    @Override
+    public double getMinWeight(double distance) {
+        return distance / maxSpeed;
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        // handle oneways and removed edges via subnetwork removal (existing and allowed highway tags but 'island' edges)
+        if (reverse) {
+            if (!gEncoder.isBackward(edgeState, accessType))
+                return Double.POSITIVE_INFINITY;
+        } else if (!gEncoder.isForward(edgeState, accessType))
+            return Double.POSITIVE_INFINITY;
+
+        long time = calcMillis(edgeState, reverse, prevOrNextEdgeId);
+        if (time == Long.MAX_VALUE)
+            return Double.POSITIVE_INFINITY;
+        return time;
+    }
+
+    @Override
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        // TODO to avoid expensive reverse flags include oneway accessibility
+        // but how to include e.g. maxspeed as it depends on direction? Does highway depend on direction?
+        // reverse = edge.isReverse()? !reverse : reverse;
+        int highwayVal = gEncoder.getHighway(edgeState);
+        double speed = speedArray[highwayVal];
+        if (speed < 0)
+            throw new IllegalStateException("speed was negative? " + edgeState.getEdge()
+                    + ", highway:" + highwayVal + ", reverse:" + reverse);
+        if (speed == 0)
+            return Long.MAX_VALUE;
+
+        // TODO inner city guessing -> lit, maxspeed <= 50, residential etc => create new encoder.isInnerCity(edge)
+        // See #472 use edge.getDouble((encoder), K_MAXSPEED_MOTORVEHICLE_FORWARD, _default) or edge.getMaxSpeed(...) instead?
+        // encoder could be made optional via passing to EdgeExplorer
+        double maxspeed = gEncoder.getMaxspeed(edgeState, accessType, reverse);
+        if (maxspeed > 0 && speed > maxspeed)
+            speed = maxspeed;
+
+        // TODO test performance difference for rounding
+        long timeInMillis = (long) (edgeState.getDistance() / speed * SPEED_CONV);
+
+        // add direction penalties at start/stop/via points
+        boolean unfavoredEdge = edgeState.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge)
+            timeInMillis += headingPenaltyMillis;
+
+        // TODO avoid a certain (or multiple) bounding boxes (less efficient for just a few edges) or a list of edgeIDs (not good for large areas)
+        // bbox.contains(nodeAccess.getLatitude(edge.getBaseNode()), nodeAccess.getLongitude(edge.getBaseNode())) time+=avoidPenalty;
+        // TODO surfaces can reduce average speed
+        // TODO prefer or avoid bike and hike routes
+        if (timeInMillis < 0)
+            throw new IllegalStateException("Some problem with weight calculation: time:"
+                    + timeInMillis + ", speed:" + speed);
+
+        return timeInMillis;
+    }
+
+    @Override
+    public String getName() {
+        return "generic";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
similarity index 80%
rename from core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
index 68aa142296..91fe0183ed 100755
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
@@ -15,45 +15,42 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
 /**
  * Special weighting for (motor)bike
  * <p>
+ *
  * @author Peter Karich
  */
-public class PriorityWeighting extends FastestWeighting
-{
+public class PriorityWeighting extends FastestWeighting {
     /**
      * For now used only in BikeCommonFlagEncoder, FootEncoder and MotorcycleFlagEncoder
      */
     public static final int KEY = 101;
     private final double minFactor;
 
-    public PriorityWeighting( FlagEncoder encoder )
-    {
+    public PriorityWeighting(FlagEncoder encoder) {
         this(encoder, new PMap(0));
     }
 
-    public PriorityWeighting( FlagEncoder encoder, PMap pMap )
-    {
+    public PriorityWeighting(FlagEncoder encoder, PMap pMap) {
         super(encoder, pMap);
         double maxPriority = 1; // BEST / BEST
         minFactor = 1 / (0.5 + maxPriority);
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return minFactor * super.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
         if (Double.isInfinite(weight))
             return Double.POSITIVE_INFINITY;
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortFastestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/routing/util/ShortFastestWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
index b2e80b9b8d..f70852e5ed 100755
--- a/core/src/main/java/com/graphhopper/routing/util/ShortFastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
@@ -15,8 +15,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
@@ -26,8 +27,7 @@
  *
  * @author Peter Karich
  */
-public class ShortFastestWeighting extends FastestWeighting
-{
+public class ShortFastestWeighting extends FastestWeighting {
     // For now keep parameters local within class
     private static final String NAME = "short_fastest";
     private static final String TIME_FACTOR = "short_fastest.time_factor";
@@ -35,8 +35,7 @@
     private final double distanceFactor;
     private final double timeFactor;
 
-    public ShortFastestWeighting( FlagEncoder encoder, PMap pMap )
-    {
+    public ShortFastestWeighting(FlagEncoder encoder, PMap pMap) {
         super(encoder);
         timeFactor = checkBounds(TIME_FACTOR, pMap.getDouble(TIME_FACTOR, 1));
 
@@ -48,34 +47,29 @@ public ShortFastestWeighting( FlagEncoder encoder, PMap pMap )
             throw new IllegalArgumentException("[" + NAME + "] one of distance_factor or time_factor has to be non-zero");
     }
 
-    public ShortFastestWeighting( FlagEncoder encoder, double distanceFactor )
-    {
+    public ShortFastestWeighting(FlagEncoder encoder, double distanceFactor) {
         super(encoder);
         this.distanceFactor = checkBounds(DISTANCE_FACTOR, distanceFactor);
         this.timeFactor = 1;
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return super.getMinWeight(distance * distanceFactor);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
         double time = super.calcWeight(edge, reverse, prevOrNextEdgeId);
         return time * timeFactor + edge.getDistance() * distanceFactor;
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return NAME;
     }
 
-    private double checkBounds( String key, double val )
-    {
+    private double checkBounds(String key, double val) {
         if (val < 0 || val > 10)
             throw new IllegalArgumentException(key + " has invalid range should be within [0, 10]");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/ShortestWeighting.java
similarity index 75%
rename from core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/ShortestWeighting.java
index 3ae63032a7..f45caea13c 100755
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/ShortestWeighting.java
@@ -15,38 +15,35 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Calculates the shortest route - independent of a vehicle as the calculation is based on the
  * distance only.
  * <p>
+ *
  * @author Peter Karich
  */
-public class ShortestWeighting extends AbstractWeighting
-{
-    public ShortestWeighting( FlagEncoder flagEncoder )
-    {
+public class ShortestWeighting extends AbstractWeighting {
+    public ShortestWeighting(FlagEncoder flagEncoder) {
         super(flagEncoder);
     }
 
     @Override
-    public double getMinWeight( double currDistToGoal )
-    {
+    public double getMinWeight(double currDistToGoal) {
         return currDistToGoal;
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         return edgeState.getDistance();
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return "shortest";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
similarity index 63%
rename from core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
index 6553aa5134..2b3dba098b 100755
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
@@ -15,8 +15,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -24,11 +27,11 @@
 /**
  * Provides methods to retrieve turn costs for a specific turn.
  * <p>
+ *
  * @author Karl Hübner
  * @author Peter Karich
  */
-public class TurnWeighting implements Weighting
-{
+public class TurnWeighting implements Weighting {
     /**
      * Encoder, which decodes the turn flags
      */
@@ -40,13 +43,11 @@
     /**
      * @param turnCostExt the turn cost storage to be used
      */
-    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostExtension turnCostExt )
-    {
-        this.turnCostEncoder = encoder;
+    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
+        this.turnCostEncoder = (TurnCostEncoder) superWeighting.getFlagEncoder();
         this.superWeighting = superWeighting;
         this.turnCostExt = turnCostExt;
-        if (encoder == null)
-            throw new IllegalArgumentException("No encoder set to calculate turn weight");
+        
         if (turnCostExt == null)
             throw new RuntimeException("No storage set to calculate turn weight");
     }
@@ -55,21 +56,18 @@ public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCos
      * Set the default cost for an u-turn in seconds. Default is 40s. Should be that high to avoid
      * 'tricking' other turn costs or restrictions.
      */
-    public TurnWeighting setDefaultUTurnCost( double costInSeconds )
-    {
+    public TurnWeighting setDefaultUTurnCost(double costInSeconds) {
         this.defaultUTurnCost = costInSeconds;
         return this;
     }
 
     @Override
-    public double getMinWeight( double distance )
-    {
+    public double getMinWeight(double distance) {
         return superWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-    {
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
         if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
             return weight;
@@ -87,8 +85,27 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
         return weight + turnCosts;
     }
 
-    public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
-    {
+    @Override
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        long millis = superWeighting.calcMillis(edgeState, reverse, prevOrNextEdgeId);
+        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+            return millis;
+
+        // TODO for now assume turn costs are returned in milliseconds?
+        // should we also separate weighting vs. time for turn? E.g. a fast but dangerous turn - is this common?
+        long turnCostsInMillis;
+        if (reverse)
+            turnCostsInMillis = (long) calcTurnWeight(edgeState.getEdge(), edgeState.getBaseNode(), prevOrNextEdgeId);
+        else
+            turnCostsInMillis = (long) calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeState.getEdge());
+
+        return millis + turnCostsInMillis;
+    }
+
+    /**
+     * This method calculates the turn weight separately.
+     */
+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
         long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
         if (turnCostEncoder.isTurnRestricted(turnFlags))
             return Double.POSITIVE_INFINITY;
@@ -97,21 +114,18 @@ public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
     }
 
     @Override
-    public FlagEncoder getFlagEncoder()
-    {
+    public FlagEncoder getFlagEncoder() {
         return superWeighting.getFlagEncoder();
     }
 
     @Override
-    public boolean matches( HintsMap weightingMap )
-    {
+    public boolean matches(HintsMap weightingMap) {
         // TODO without 'turn' in comparison
         return superWeighting.matches(weightingMap);
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return "turn|" + superWeighting.getName();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/weighting/WeightApproximator.java
similarity index 84%
rename from core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
rename to core/src/main/java/com/graphhopper/routing/weighting/WeightApproximator.java
index b82b90b152..f0fd194824 100755
--- a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/WeightApproximator.java
@@ -15,22 +15,22 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 /**
- * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * Specifies a weight approximation between an node and the goalNode according to the specified
+ * weighting.
  * <p>
+ *
  * @author jansoe
  */
-public interface WeightApproximator
-{
-
+public interface WeightApproximator {
     /**
      * @return minimal weight fromNode to the goalNode
      */
-    double approximate( int fromNode );
+    double approximate(int fromNode);
 
-    void setGoalNode( int to );
+    void setGoalNode(int to);
 
     /**
      * makes a deep copy of itself
diff --git a/core/src/main/java/com/graphhopper/routing/util/Weighting.java b/core/src/main/java/com/graphhopper/routing/weighting/Weighting.java
similarity index 53%
rename from core/src/main/java/com/graphhopper/routing/util/Weighting.java
rename to core/src/main/java/com/graphhopper/routing/weighting/Weighting.java
index 0857f2f528..b77e29cc16 100755
--- a/core/src/main/java/com/graphhopper/routing/util/Weighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/Weighting.java
@@ -15,34 +15,49 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Specifies how the best route is calculated. E.g. the fastest or shortest route.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Weighting
-{
+public interface Weighting {
     /**
      * Used only for the heuristic estimation in A
      * <p>
+     *
      * @return minimal weight. E.g. if you calculate the fastest way it is distance/maxVelocity
      */
-    double getMinWeight( double distance );
+    double getMinWeight(double distance);
 
     /**
-     * @param edgeState the edge for which the weight should be calculated
-     * @param reverse if the specified edge is specified in reverse direction e.g. from the reverse
-     * case of a bidirectional search.
+     * This method calculates the weighting a certain edgeState should be associated. E.g. a high
+     * value indicates that the edge should be avoided. Make sure that this method is very fast and
+     * optimized as this is called potentially millions of times for one route or a lot more for
+     * nearly any preprocessing phase.
+     *
+     * @param edgeState        the edge for which the weight should be calculated
+     * @param reverse          if the specified edge is specified in reverse direction e.g. from the reverse
+     *                         case of a bidirectional search.
      * @param prevOrNextEdgeId if reverse is false this has to be the previous edgeId, if true it
-     * has to be the next edgeId in the direction from start to end.
+     *                         has to be the next edgeId in the direction from start to end.
      * @return the calculated weight with the specified velocity has to be in the range of 0 and
      * +Infinity. Make sure your method does not return NaN which can e.g. occur for 0/0.
      */
-    double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId );
+    double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId);
+
+    /**
+     * This method calculates the time taken (in milli seconds) for the specified edgeState and
+     * optionally include the turn costs (in seconds) of the previous (or next) edgeId via
+     * prevOrNextEdgeId. Typically used for post-processing and on only a few thausend edges.
+     */
+    long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId);
 
     FlagEncoder getFlagEncoder();
 
@@ -51,5 +66,5 @@
     /**
      * Returns true if the specified weighting and encoder matches to this Weighting.
      */
-    boolean matches( HintsMap map );
+    boolean matches(HintsMap map);
 }
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index 3f94137553..b8eb605d44 100755
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -24,12 +24,12 @@
 /**
  * Interface to convert from place names to points.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Geocoding
-{
+public interface Geocoding {
     /**
      * Returns a list of matching points for the specified place query string.
      */
-    List<GHPlace> names2places( GHPlace... place );
+    List<GHPlace> names2places(GHPlace... place);
 }
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index d63dc36e2f..cbd4dc11a2 100755
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -29,8 +29,7 @@
  * @author Ottavio Campana
  * @author Peter Karich
  */
-public class NameIndex implements Storable<NameIndex>
-{
+public class NameIndex implements Storable<NameIndex> {
     private static final Logger logger = LoggerFactory.getLogger(NameIndex.class);
     private static final long START_POINTER = 1;
     private final DataAccess names;
@@ -39,23 +38,19 @@
     private String lastName;
     private long lastIndex;
 
-    public NameIndex( Directory dir )
-    {
+    public NameIndex(Directory dir) {
         names = dir.find("names");
     }
 
     @Override
-    public NameIndex create( long cap )
-    {
+    public NameIndex create(long cap) {
         names.create(cap);
         return this;
     }
 
     @Override
-    public boolean loadExisting()
-    {
-        if (names.loadExisting())
-        {
+    public boolean loadExisting() {
+        if (names.loadExisting()) {
             bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(4));
             return true;
         }
@@ -66,21 +61,17 @@ public boolean loadExisting()
     /**
      * @return the byte pointer to the name
      */
-    public long put( String name )
-    {
-        if (name == null || name.isEmpty())
-        {
+    public long put(String name) {
+        if (name == null || name.isEmpty()) {
             return 0;
         }
-        if (name.equals(lastName))
-        {
+        if (name.equals(lastName)) {
             return lastIndex;
         }
         byte[] bytes = getBytes(name);
         long oldPointer = bytePointer;
         names.ensureCapacity(bytePointer + 1 + bytes.length);
-        byte[] sizeBytes = new byte[]
-        {
+        byte[] sizeBytes = new byte[]{
             (byte) bytes.length
         };
         names.setBytes(bytePointer, sizeBytes, sizeBytes.length);
@@ -92,15 +83,12 @@ public long put( String name )
         return oldPointer;
     }
 
-    private byte[] getBytes( String name )
-    {
+    private byte[] getBytes(String name) {
         byte[] bytes = null;
-        for (int i = 0; i < 2; i++)
-        {
+        for (int i = 0; i < 2; i++) {
             bytes = name.getBytes(Helper.UTF_CS);
             // we have to store the size of the array into *one* byte
-            if (bytes.length > 255)
-            {
+            if (bytes.length > 255) {
                 String newName = name.substring(0, 256 / 4);
                 logger.info("Way name is too long: " + name + " truncated to " + newName);
                 name = newName;
@@ -108,16 +96,14 @@ public long put( String name )
             }
             break;
         }
-        if (bytes.length > 255)
-        {
+        if (bytes.length > 255) {
             // really make sure no such problem exists
             throw new IllegalStateException("Way name is too long: " + name);
         }
         return bytes;
     }
 
-    public String get( long pointer )
-    {
+    public String get(long pointer) {
         if (pointer < 0)
             throw new IllegalStateException("Pointer to access NameIndex cannot be negative:" + pointer);
 
@@ -134,38 +120,32 @@ public String get( long pointer )
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         names.setHeader(0, BitUtil.LITTLE.getIntLow(bytePointer));
         names.setHeader(4, BitUtil.LITTLE.getIntHigh(bytePointer));
         names.flush();
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         names.close();
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return names.isClosed();
     }
 
-    public void setSegmentSize( int segments )
-    {
+    public void setSegmentSize(int segments) {
         names.setSegmentSize(segments);
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return names.getCapacity();
     }
 
-    public void copyTo( NameIndex nameIndex )
-    {
+    public void copyTo(NameIndex nameIndex) {
         names.copyTo(nameIndex.names);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index b32f1e1f5e..a0770791ec 100755
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -24,12 +24,12 @@
 /**
  * Interface to convert from points to place names or node ids.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface ReverseGeocoding
-{
+public interface ReverseGeocoding {
     /**
      * Tries to retrieve a locational string from the specified points (list of lat,lon).
      */
-    List<GHPlace> places2names( GHPlace... points );
+    List<GHPlace> places2names(GHPlace... points);
 }
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index e8dea943ba..0f895b4b1a 100755
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -28,25 +28,23 @@
 /**
  * @author Peter Karich
  */
-public abstract class AbstractDataAccess implements DataAccess
-{
+public abstract class AbstractDataAccess implements DataAccess {
     protected static final int SEGMENT_SIZE_MIN = 1 << 7;
-    private static final int SEGMENT_SIZE_DEFAULT = 1 << 20;
     // reserve some space for downstream usage (in classes using/extending this)
     protected static final int HEADER_OFFSET = 20 * 4 + 20;
     protected static final byte[] EMPTY = new byte[1024];
-    protected int header[] = new int[(HEADER_OFFSET - 20) / 4];
+    private static final int SEGMENT_SIZE_DEFAULT = 1 << 20;
+    protected final ByteOrder byteOrder;
+    protected final BitUtil bitUtil;
     private final String location;
+    protected int header[] = new int[(HEADER_OFFSET - 20) / 4];
     protected String name;
     protected int segmentSizeInBytes = SEGMENT_SIZE_DEFAULT;
     protected transient int segmentSizePower;
     protected transient int indexDivisor;
-    protected final ByteOrder byteOrder;
-    protected final BitUtil bitUtil;
     protected transient boolean closed = false;
 
-    public AbstractDataAccess( String name, String location, ByteOrder order )
-    {
+    public AbstractDataAccess(String name, String location, ByteOrder order) {
         byteOrder = order;
         bitUtil = BitUtil.get(order);
         this.name = name;
@@ -57,38 +55,32 @@ public AbstractDataAccess( String name, String location, ByteOrder order )
     }
 
     @Override
-    public String getName()
-    {
+    public String getName() {
         return name;
     }
 
-    protected String getFullName()
-    {
+    protected String getFullName() {
         return location + name;
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         closed = true;
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return closed;
     }
 
     @Override
-    public void setHeader( int bytePos, int value )
-    {
+    public void setHeader(int bytePos, int value) {
         bytePos >>= 2;
         header[bytePos] = value;
     }
 
     @Override
-    public int getHeader( int bytePos )
-    {
+    public int getHeader(int bytePos) {
         bytePos >>= 2;
         return header[bytePos];
     }
@@ -96,20 +88,17 @@ public int getHeader( int bytePos )
     /**
      * Writes some internal data into the beginning of the specified file.
      */
-    protected void writeHeader( RandomAccessFile file, long length, int segmentSize ) throws IOException
-    {
+    protected void writeHeader(RandomAccessFile file, long length, int segmentSize) throws IOException {
         file.seek(0);
         file.writeUTF("GH");
         file.writeLong(length);
         file.writeInt(segmentSize);
-        for (int i = 0; i < header.length; i++)
-        {
+        for (int i = 0; i < header.length; i++) {
             file.writeInt(header[i]);
         }
     }
 
-    protected long readHeader( RandomAccessFile raFile ) throws IOException
-    {
+    protected long readHeader(RandomAccessFile raFile) throws IOException {
         raFile.seek(0);
         if (raFile.length() == 0)
             return -1;
@@ -120,24 +109,20 @@ protected long readHeader( RandomAccessFile raFile ) throws IOException
 
         long bytes = raFile.readLong();
         setSegmentSize(raFile.readInt());
-        for (int i = 0; i < header.length; i++)
-        {
+        for (int i = 0; i < header.length; i++) {
             header[i] = raFile.readInt();
         }
         return bytes;
     }
 
-    protected void copyHeader( DataAccess da )
-    {
-        for (int h = 0; h < header.length * 4; h += 4)
-        {
+    protected void copyHeader(DataAccess da) {
+        for (int h = 0; h < header.length * 4; h += 4) {
             da.setHeader(h, getHeader(h));
         }
     }
 
     @Override
-    public DataAccess copyTo( DataAccess da )
-    {
+    public DataAccess copyTo(DataAccess da) {
         copyHeader(da);
         da.ensureCapacity(getCapacity());
         long cap = getCapacity();
@@ -145,29 +130,22 @@ public DataAccess copyTo( DataAccess da )
         int segSize = Math.min(da.getSegmentSize(), getSegmentSize());
         byte[] bytes = new byte[segSize];
         boolean externalIntBased = ((AbstractDataAccess) da).isIntBased();
-        for (long bytePos = 0; bytePos < cap; bytePos += segSize)
-        {
+        for (long bytePos = 0; bytePos < cap; bytePos += segSize) {
             // read
-            if (isIntBased())
-            {
-                for (int offset = 0; offset < segSize; offset += 4)
-                {
+            if (isIntBased()) {
+                for (int offset = 0; offset < segSize; offset += 4) {
                     bitUtil.fromInt(bytes, getInt(bytePos + offset), offset);
                 }
-            } else
-            {
+            } else {
                 getBytes(bytePos, bytes, segSize);
             }
 
             // write
-            if (externalIntBased)
-            {
-                for (int offset = 0; offset < segSize; offset += 4)
-                {
+            if (externalIntBased) {
+                for (int offset = 0; offset < segSize; offset += 4) {
                     da.setInt(bytePos + offset, bitUtil.toInt(bytes, offset));
                 }
-            } else
-            {
+            } else {
                 da.setBytes(bytePos, bytes, segSize);
             }
         }
@@ -175,10 +153,8 @@ public DataAccess copyTo( DataAccess da )
     }
 
     @Override
-    public DataAccess setSegmentSize( int bytes )
-    {
-        if (bytes > 0)
-        {
+    public DataAccess setSegmentSize(int bytes) {
+        if (bytes > 0) {
             // segment size should be a power of 2
             int tmp = (int) (Math.log(bytes) / Math.log(2));
             segmentSizeInBytes = Math.max((int) Math.pow(2, tmp), SEGMENT_SIZE_MIN);
@@ -189,44 +165,35 @@ public DataAccess setSegmentSize( int bytes )
     }
 
     @Override
-    public int getSegmentSize()
-    {
+    public int getSegmentSize() {
         return segmentSizeInBytes;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getFullName();
     }
 
     @Override
-    public void rename( String newName )
-    {
+    public void rename(String newName) {
         File file = new File(location + name);
-        if (file.exists())
-        {
-            try
-            {
-                if (!file.renameTo(new File(location + newName)))
-                {
+        if (file.exists()) {
+            try {
+                if (!file.renameTo(new File(location + newName))) {
                     throw new IllegalStateException("Couldn't rename this " + getType() + " object to " + newName);
                 }
                 name = newName;
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 throw new IllegalStateException("Couldn't rename this " + getType() + " object!", ex);
             }
-        } else
-        {
+        } else {
             throw new IllegalStateException("File does not exist!? " + getFullName()
                     + " Make sure that you flushed before renaming. Otherwise it could make problems"
                     + " for memory mapped DataAccess objects");
         }
     }
 
-    protected boolean checkBeforeRename( String newName )
-    {
+    protected boolean checkBeforeRename(String newName) {
         if (Helper.isEmpty(newName))
             throw new IllegalArgumentException("newName mustn't be empty!");
 
@@ -239,13 +206,11 @@ protected boolean checkBeforeRename( String newName )
         return true;
     }
 
-    public boolean isStoring()
-    {
+    public boolean isStoring() {
         return true;
     }
 
-    protected boolean isIntBased()
-    {
+    protected boolean isIntBased() {
         return false;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 34ab18fe8e..b947532718 100755
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -26,9 +26,12 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.search.NameIndex;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Helper.nf;
 import com.graphhopper.util.shapes.BBox;
 
+import static com.graphhopper.util.Helper.nf;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * The base graph handles nodes and edges file format. It can be used with different Directory
  * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
@@ -40,52 +43,50 @@
  * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
  * loadExisting, (4) usage, (5) flush, (6) close
  */
-class BaseGraph implements Graph
-{
-    // edge memory layout not found in EdgeAccess:
-    int E_GEO, E_NAME, E_ADDITIONAL;
-    /**
-     * Specifies how many entries (integers) are used per edge.
-     */
-    int edgeEntryBytes;
-    private boolean initialized = false;
+class BaseGraph implements Graph {
     final DataAccess edges;
+    final DataAccess nodes;
+    final BBox bounds;
+    final NodeAccess nodeAccess;
+    final GraphExtension extStorage;
+    final NameIndex nameIndex;
+    final BitUtil bitUtil;
+    final EncodingManager encodingManager;
+    final EdgeAccess edgeAccess;
+    // length | nodeA | nextNode | ... | nodeB
+    // as we use integer index in 'egdes' area => 'geometry' area is limited to 4GB (we use pos&neg values!)
+    private final DataAccess wayGeometry;
+    private final Directory dir;
+    private final InternalGraphEventListener listener;
     /**
      * interval [0,n)
      */
     protected int edgeCount;
     // node memory layout:
     protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
+    // edge memory layout not found in EdgeAccess:
+    int E_GEO, E_NAME, E_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per edge.
+     */
+    int edgeEntryBytes;
     /**
      * Specifies how many entries (integers) are used per node
      */
     int nodeEntryBytes;
-    final DataAccess nodes;
+    private boolean initialized = false;
     /**
      * interval [0,n)
      */
     private int nodeCount;
-    final BBox bounds;
     // remove markers are not yet persistent!
     private GHBitSet removedNodes;
     private int edgeEntryIndex, nodeEntryIndex;
-    final NodeAccess nodeAccess;
-    final GraphExtension extStorage;
-    // length | nodeA | nextNode | ... | nodeB
-    // as we use integer index in 'egdes' area => 'geometry' area is limited to 4GB (we use pos&neg values!)
-    private final DataAccess wayGeometry;
     private long maxGeoRef;
-    final NameIndex nameIndex;
-    final BitUtil bitUtil;
-    private final Directory dir;
-    final EncodingManager encodingManager;
-    private final InternalGraphEventListener listener;
     private boolean frozen = false;
-    final EdgeAccess edgeAccess;
 
-    public BaseGraph( Directory dir, final EncodingManager encodingManager, boolean withElevation,
-                      InternalGraphEventListener listener, GraphExtension extendedStorage )
-    {
+    public BaseGraph(Directory dir, final EncodingManager encodingManager, boolean withElevation,
+                     InternalGraphEventListener listener, GraphExtension extendedStorage) {
         this.dir = dir;
         this.encodingManager = encodingManager;
         this.bitUtil = BitUtil.get(dir.getByteOrder());
@@ -94,54 +95,45 @@ public BaseGraph( Directory dir, final EncodingManager encodingManager, boolean
         this.nodes = dir.find("nodes");
         this.edges = dir.find("edges");
         this.listener = listener;
-        this.edgeAccess = new EdgeAccess(edges, bitUtil)
-        {
+        this.edgeAccess = new EdgeAccess(edges, bitUtil) {
             @Override
-            final EdgeIterable createSingleEdge( EdgeFilter filter )
-            {
+            final EdgeIterable createSingleEdge(EdgeFilter filter) {
                 return new EdgeIterable(BaseGraph.this, this, filter);
             }
 
             @Override
-            final int getEdgeRef( int nodeId )
-            {
+            final int getEdgeRef(int nodeId) {
                 return nodes.getInt((long) nodeId * nodeEntryBytes + N_EDGE_REF);
             }
 
             @Override
-            final void setEdgeRef( int nodeId, int edgeId )
-            {
+            final void setEdgeRef(int nodeId, int edgeId) {
                 nodes.setInt((long) nodeId * nodeEntryBytes + N_EDGE_REF, edgeId);
             }
 
             @Override
-            final int getEntryBytes()
-            {
+            final int getEntryBytes() {
                 return edgeEntryBytes;
             }
 
             @Override
-            final long toPointer( int edgeId )
-            {
+            final long toPointer(int edgeId) {
                 assert isInBounds(edgeId) : "edgeId " + edgeId + " not in bounds [0," + edgeCount + ")";
                 return (long) edgeId * edgeEntryBytes;
             }
 
             @Override
-            final boolean isInBounds( int edgeId )
-            {
+            final boolean isInBounds(int edgeId) {
                 return edgeId < edgeCount && edgeId >= 0;
             }
 
             @Override
-            final long reverseFlags( long edgePointer, long flags )
-            {
+            final long reverseFlags(long edgePointer, long flags) {
                 return encodingManager.reverseFlags(flags);
             }
 
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return "base edge access";
             }
         };
@@ -151,21 +143,24 @@ public String toString()
         this.extStorage.init(this, dir);
     }
 
+    private static boolean isTestingEnabled() {
+        boolean enableIfAssert = false;
+        assert (enableIfAssert = true) : true;
+        return enableIfAssert;
+    }
+
     @Override
-    public Graph getBaseGraph()
-    {
+    public Graph getBaseGraph() {
         return this;
     }
 
-    void checkInit()
-    {
+    void checkInit() {
         if (initialized)
             throw new IllegalStateException("You cannot configure this GraphStorage "
                     + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
     }
 
-    protected int loadNodesHeader()
-    {
+    protected int loadNodesHeader() {
         nodeEntryBytes = nodes.getHeader(1 * 4);
         nodeCount = nodes.getHeader(2 * 4);
         bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
@@ -173,8 +168,7 @@ protected int loadNodesHeader()
         bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
         bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
 
-        if (bounds.hasElevation())
-        {
+        if (bounds.hasElevation()) {
             bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
             bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
         }
@@ -183,16 +177,14 @@ protected int loadNodesHeader()
         return 10;
     }
 
-    protected int setNodesHeader()
-    {
+    protected int setNodesHeader() {
         nodes.setHeader(1 * 4, nodeEntryBytes);
         nodes.setHeader(2 * 4, nodeCount);
         nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
-        if (bounds.hasElevation())
-        {
+        if (bounds.hasElevation()) {
             nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
             nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
         }
@@ -201,15 +193,13 @@ protected int setNodesHeader()
         return 10;
     }
 
-    protected int loadEdgesHeader()
-    {
+    protected int loadEdgesHeader() {
         edgeEntryBytes = edges.getHeader(0 * 4);
         edgeCount = edges.getHeader(1 * 4);
         return 5;
     }
 
-    protected int setEdgesHeader()
-    {
+    protected int setEdgesHeader() {
         edges.setHeader(0, edgeEntryBytes);
         edges.setHeader(1 * 4, edgeCount);
         edges.setHeader(2 * 4, encodingManager.hashCode());
@@ -217,21 +207,18 @@ protected int setEdgesHeader()
         return 5;
     }
 
-    protected int loadWayGeometryHeader()
-    {
+    protected int loadWayGeometryHeader() {
         maxGeoRef = bitUtil.combineIntsToLong(wayGeometry.getHeader(0), wayGeometry.getHeader(4));
         return 1;
     }
 
-    protected int setWayGeometryHeader()
-    {
+    protected int setWayGeometryHeader() {
         wayGeometry.setHeader(0, bitUtil.getIntLow(maxGeoRef));
         wayGeometry.setHeader(4, bitUtil.getIntHigh(maxGeoRef));
         return 1;
     }
 
-    void initStorage()
-    {
+    void initStorage() {
         edgeEntryIndex = 0;
         nodeEntryIndex = 0;
         boolean flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
@@ -271,37 +258,30 @@ void initStorage()
     /**
      * Initializes the node area with the empty edge value and default additional value.
      */
-    void initNodeRefs( long oldCapacity, long newCapacity )
-    {
-        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes)
-        {
+    void initNodeRefs(long oldCapacity, long newCapacity) {
+        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes) {
             nodes.setInt(pointer, EdgeIterator.NO_EDGE);
         }
-        if (extStorage.isRequireNodeField())
-        {
-            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes)
-            {
+        if (extStorage.isRequireNodeField()) {
+            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes) {
                 nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());
             }
         }
     }
 
-    protected final int nextEdgeEntryIndex( int sizeInBytes )
-    {
+    protected final int nextEdgeEntryIndex(int sizeInBytes) {
         int tmp = edgeEntryIndex;
         edgeEntryIndex += sizeInBytes;
         return tmp;
     }
 
-    protected final int nextNodeEntryIndex( int sizeInBytes )
-    {
+    protected final int nextNodeEntryIndex(int sizeInBytes) {
         int tmp = nodeEntryIndex;
         nodeEntryIndex += sizeInBytes;
         return tmp;
     }
 
-    protected final void initNodeAndEdgeEntrySize()
-    {
+    protected final void initNodeAndEdgeEntrySize() {
         nodeEntryBytes = nodeEntryIndex;
         edgeEntryBytes = edgeEntryIndex;
     }
@@ -310,8 +290,7 @@ protected final void initNodeAndEdgeEntrySize()
      * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
      * extend byte capacity
      */
-    final void ensureNodeIndex( int nodeIndex )
-    {
+    final void ensureNodeIndex(int nodeIndex) {
         if (!initialized)
             throw new AssertionError("The graph has not yet been initialized.");
 
@@ -321,39 +300,33 @@ final void ensureNodeIndex( int nodeIndex )
         long oldNodes = nodeCount;
         nodeCount = nodeIndex + 1;
         boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
-        if (capacityIncreased)
-        {
+        if (capacityIncreased) {
             long newBytesCapacity = nodes.getCapacity();
             initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
         }
     }
 
     @Override
-    public int getNodes()
-    {
+    public int getNodes() {
         return nodeCount;
     }
 
     @Override
-    public NodeAccess getNodeAccess()
-    {
+    public NodeAccess getNodeAccess() {
         return nodeAccess;
     }
 
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return bounds;
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirection )
-    {
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirection) {
         return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
     }
 
-    void setSegmentSize( int bytes )
-    {
+    void setSegmentSize(int bytes) {
         checkInit();
         nodes.setSegmentSize(bytes);
         edges.setSegmentSize(bytes);
@@ -362,8 +335,7 @@ void setSegmentSize( int bytes )
         extStorage.setSegmentSize(bytes);
     }
 
-    synchronized void freeze()
-    {
+    synchronized void freeze() {
         if (isFrozen())
             throw new IllegalStateException("base graph already frozen");
 
@@ -371,19 +343,16 @@ synchronized void freeze()
         listener.freeze();
     }
 
-    synchronized boolean isFrozen()
-    {
+    synchronized boolean isFrozen() {
         return frozen;
     }
 
-    public void checkFreeze()
-    {
+    public void checkFreeze() {
         if (isFrozen())
             throw new IllegalStateException("Cannot add edge or node after baseGraph.freeze was called");
     }
 
-    void create( long initSize )
-    {
+    void create(long initSize) {
         nodes.create(initSize);
         edges.create(initSize);
         wayGeometry.create(initSize);
@@ -396,8 +365,7 @@ void create( long initSize )
         initNodeRefs(0, nodes.getCapacity());
     }
 
-    String toDetailsString()
-    {
+    String toDetailsString() {
         return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "MB), "
                 + "nodes:" + nf(getNodes()) + "(" + nodes.getCapacity() / Helper.MB + "MB), "
                 + "name:(" + nameIndex.getCapacity() / Helper.MB + "MB), "
@@ -405,8 +373,7 @@ String toDetailsString()
                 + "bounds:" + bounds;
     }
 
-    void flush()
-    {
+    void flush() {
         setNodesHeader();
         setEdgesHeader();
         setWayGeometryHeader();
@@ -418,8 +385,7 @@ void flush()
         extStorage.flush();
     }
 
-    void close()
-    {
+    void close() {
         wayGeometry.close();
         nameIndex.close();
         edges.close();
@@ -427,14 +393,16 @@ void close()
         extStorage.close();
     }
 
-    long getCapacity()
-    {
+    long getCapacity() {
         return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity()
                 + wayGeometry.getCapacity() + extStorage.getCapacity();
     }
 
-    void loadExisting( String dim )
-    {
+    long getMaxGeoRef() {
+        return maxGeoRef;
+    }
+
+    void loadExisting(String dim) {
         if (!nodes.loadExisting())
             throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
 
@@ -466,8 +434,7 @@ void loadExisting( String dim )
     /**
      * @return to
      */
-    EdgeIteratorState copyProperties( CommonEdgeIterator from, EdgeIteratorState to )
-    {
+    EdgeIteratorState copyProperties(CommonEdgeIterator from, EdgeIteratorState to) {
         to.setDistance(from.getDistance()).
                 setName(from.getName()).
                 setFlags(from.getDirectFlags()).
@@ -481,11 +448,11 @@ EdgeIteratorState copyProperties( CommonEdgeIterator from, EdgeIteratorState to
     /**
      * Create edge between nodes a and b
      * <p>
+     *
      * @return EdgeIteratorState of newly created edge
      */
     @Override
-    public EdgeIteratorState edge( int nodeA, int nodeB )
-    {
+    public EdgeIteratorState edge(int nodeA, int nodeB) {
         if (isFrozen())
             throw new IllegalStateException("Cannot create edge if graph is already frozen");
 
@@ -501,18 +468,17 @@ public EdgeIteratorState edge( int nodeA, int nodeB )
     }
 
     // for test only
-    void setEdgeCount( int cnt )
-    {
+    void setEdgeCount(int cnt) {
         edgeCount = cnt;
     }
 
     /**
      * Determine next free edgeId and ensure byte capacity to store edge
      * <p>
+     *
      * @return next free edgeId
      */
-    protected int nextEdgeId()
-    {
+    protected int nextEdgeId() {
         int nextEdge = edgeCount;
         edgeCount++;
         if (edgeCount < 0)
@@ -523,54 +489,45 @@ protected int nextEdgeId()
     }
 
     @Override
-    public EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
-    {
+    public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
         if (!edgeAccess.isInBounds(edgeId))
             throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
         checkAdjNodeBounds(adjNode);
         return edgeAccess.getEdgeProps(edgeId, adjNode);
     }
 
-    final void checkAdjNodeBounds( int adjNode )
-    {
+    final void checkAdjNodeBounds(int adjNode) {
         if (adjNode < 0 && adjNode != Integer.MIN_VALUE || adjNode >= nodeCount)
             throw new IllegalStateException("adjNode " + adjNode + " out of bounds [0," + nf(nodeCount) + ")");
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
-    {
+    public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
         return new EdgeIterable(this, edgeAccess, filter);
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer()
-    {
+    public EdgeExplorer createEdgeExplorer() {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
-    public AllEdgesIterator getAllEdges()
-    {
+    public AllEdgesIterator getAllEdges() {
         return new AllEdgeIterator(this, edgeAccess);
     }
 
     @Override
-    public Graph copyTo( Graph g )
-    {
+    public Graph copyTo(Graph g) {
         initialized = true;
-        if (g.getClass().equals(getClass()))
-        {
+        if (g.getClass().equals(getClass())) {
             _copyTo((BaseGraph) g);
             return g;
-        } else
-        {
+        } else {
             return GHUtility.copyTo(this, g);
         }
     }
 
-    void _copyTo( BaseGraph clonedG )
-    {
+    void _copyTo(BaseGraph clonedG) {
         if (clonedG.edgeEntryBytes != edgeEntryBytes)
             throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
                     + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
@@ -610,8 +567,7 @@ void _copyTo( BaseGraph clonedG )
             clonedG.removedNodes = removedNodes.copyTo(new GHBitSetImpl());
     }
 
-    protected void trimToSize()
-    {
+    protected void trimToSize() {
         long nodeCap = (long) nodeCount * nodeEntryBytes;
         nodes.trimTo(nodeCap);
 //        long edgeCap = (long) (edgeCount + 1) * edgeEntrySize;
@@ -623,9 +579,8 @@ protected void trimToSize()
      * moves the last nodes into the deleted nodes, where it needs to update the node ids in every
      * edge.
      */
-    void inPlaceNodeRemove( int removeNodeCount )
-    {
-        // Prepare edge-update of nodes which are connected to deleted nodes        
+    void inPlaceNodeRemove(int removeNodeCount) {
+        // Prepare edge-update of nodes which are connected to deleted nodes
         int toMoveNodes = getNodes();
         int itemsToMove = 0;
 
@@ -634,21 +589,23 @@ void inPlaceNodeRemove( int removeNodeCount )
         GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
         removedNodes.copyTo(toRemoveSet);
 
-        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
-        // create map of old node ids pointing to new ids        
+        Logger logger = LoggerFactory.getLogger(getClass());
+        if (removeNodeCount > getNodes() / 2.0)
+            logger.warn("More than a half of the network should be removed!? "
+                    + "Nodes:" + getNodes() + ", remove:" + removeNodeCount);
+
+        EdgeExplorer delExplorer = createEdgeExplorer();
+        // create map of old node ids pointing to new ids
         for (int removeNode = removedNodes.next(0);
-                removeNode >= 0;
-                removeNode = removedNodes.next(removeNode + 1))
-        {
+             removeNode >= 0;
+             removeNode = removedNodes.next(removeNode + 1)) {
             EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);
-            while (delEdgesIter.next())
-            {
+            while (delEdgesIter.next()) {
                 toRemoveSet.add(delEdgesIter.getAdjNode());
             }
 
             toMoveNodes--;
-            for (; toMoveNodes >= 0; toMoveNodes--)
-            {
+            for (; toMoveNodes >= 0; toMoveNodes--) {
                 if (!removedNodes.contains(toMoveNodes))
                     break;
             }
@@ -663,24 +620,20 @@ void inPlaceNodeRemove( int removeNodeCount )
         // now similar process to disconnectEdges but only for specific nodes
         // all deleted nodes could be connected to existing. remove the connections
         for (int removeNode = toRemoveSet.next(0);
-                removeNode >= 0;
-                removeNode = toRemoveSet.next(removeNode + 1))
-        {
+             removeNode >= 0;
+             removeNode = toRemoveSet.next(removeNode + 1)) {
             // remove all edges connected to the deleted nodes
             adjNodesToDelIter.setBaseNode(removeNode);
             long prev = EdgeIterator.NO_EDGE;
-            while (adjNodesToDelIter.next())
-            {
+            while (adjNodesToDelIter.next()) {
                 int nodeId = adjNodesToDelIter.getAdjNode();
                 // already invalidated
-                if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId))
-                {
+                if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId)) {
                     int edgeToRemove = adjNodesToDelIter.getEdge();
                     long edgeToRemovePointer = edgeAccess.toPointer(edgeToRemove);
                     edgeAccess.internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
                     edgeAccess.invalidateEdge(edgeToRemovePointer);
-                } else
-                {
+                } else {
                     prev = adjNodesToDelIter.edgePointer;
                 }
             }
@@ -689,12 +642,10 @@ void inPlaceNodeRemove( int removeNodeCount )
         GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);
         EdgeExplorer movedEdgeExplorer = createEdgeExplorer();
         // marks connected nodes to rewrite the edges
-        for (int i = 0; i < itemsToMove; i++)
-        {
+        for (int i = 0; i < itemsToMove; i++) {
             int oldI = oldToNewMap.keyAt(i);
             EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
-            while (movedEdgeIter.next())
-            {
+            while (movedEdgeIter.next()) {
                 int nodeId = movedEdgeIter.getAdjNode();
                 if (nodeId == EdgeAccess.NO_NODE)
                     continue;
@@ -708,14 +659,12 @@ void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // move nodes into deleted nodes
-        for (int i = 0; i < itemsToMove; i++)
-        {
+        for (int i = 0; i < itemsToMove; i++) {
             int oldI = oldToNewMap.keyAt(i);
             int newI = oldToNewMap.valueAt(i);
             long newOffset = (long) newI * nodeEntryBytes;
             long oldOffset = (long) oldI * nodeEntryBytes;
-            for (long j = 0; j < nodeEntryBytes; j += 4)
-            {
+            for (long j = 0; j < nodeEntryBytes; j += 4) {
                 nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));
             }
         }
@@ -724,14 +673,13 @@ void inPlaceNodeRemove( int removeNodeCount )
         // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
-        while (iter.next())
-        {
+        while (iter.next()) {
             int nodeA = iter.getBaseNode();
             int nodeB = iter.getAdjNode();
             if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
                 continue;
 
-            // now overwrite exiting edge with new node ids 
+            // now overwrite exiting edge with new node ids
             // also flags and links could have changed due to different node order
             int updatedA = oldToNewMap.get(nodeA);
             if (updatedA < 0)
@@ -758,13 +706,11 @@ void inPlaceNodeRemove( int removeNodeCount )
         // we do not remove the invalid edges => edgeCount stays the same!
         nodeCount -= removeNodeCount;
 
-        EdgeExplorer explorer = createEdgeExplorer();
         // health check
-        if (isTestingEnabled())
-        {
+        if (isTestingEnabled()) {
+            EdgeExplorer explorer = createEdgeExplorer();
             iter = getAllEdges();
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int base = iter.getBaseNode();
                 int adj = iter.getAdjNode();
                 String str = iter.getEdge()
@@ -779,18 +725,14 @@ void inPlaceNodeRemove( int removeNodeCount )
                 if (base >= nodeCount)
                     throw new RuntimeException("Base node problem with edge " + str);
 
-                try
-                {
+                try {
                     explorer.setBaseNode(adj).toString();
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     org.slf4j.LoggerFactory.getLogger(getClass()).error("adj:" + adj);
                 }
-                try
-                {
+                try {
                     explorer.setBaseNode(base).toString();
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     org.slf4j.LoggerFactory.getLogger(getClass()).error("base:" + base);
                 }
             }
@@ -801,69 +743,84 @@ void inPlaceNodeRemove( int removeNodeCount )
     }
 
     @Override
-    public GraphExtension getExtension()
-    {
+    public GraphExtension getExtension() {
         return extStorage;
     }
 
-    public void setAdditionalEdgeField( long edgePointer, int value )
-    {
+    public void setAdditionalEdgeField(long edgePointer, int value) {
         if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
             edges.setInt(edgePointer + E_ADDITIONAL, value);
         else
             throw new AssertionError("This graph does not support an additional edge field.");
     }
 
-    private void setWayGeometry_( PointList pillarNodes, long edgePointer, boolean reverse )
-    {
-        if (pillarNodes != null && !pillarNodes.isEmpty())
-        {
+    private void setWayGeometry_(PointList pillarNodes, long edgePointer, boolean reverse) {
+        if (pillarNodes != null && !pillarNodes.isEmpty()) {
             if (pillarNodes.getDimension() != nodeAccess.getDimension())
                 throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
                         + "D for graph which is " + nodeAccess.getDimension() + "D");
 
+            long existingGeoRef = Helper.toUnsignedLong(edges.getInt(edgePointer + E_GEO));
+
             int len = pillarNodes.getSize();
             int dim = nodeAccess.getDimension();
-            long tmpRef = nextGeoRef(len * dim);
-            edges.setInt(edgePointer + E_GEO, Helper.toSignedInt(tmpRef));
-            long geoRef = (long) tmpRef * 4;
-            byte[] bytes = new byte[len * dim * 4 + 4];
-            ensureGeometry(geoRef, bytes.length);
-            bitUtil.fromInt(bytes, len, 0);
-            if (reverse)
-                pillarNodes.reverse();
-
-            int tmpOffset = 4;
-            boolean is3D = nodeAccess.is3D();
-            for (int i = 0; i < len; i++)
-            {
-                double lat = pillarNodes.getLatitude(i);
-                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
-                tmpOffset += 4;
-                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
-                tmpOffset += 4;
-
-                if (is3D)
-                {
-                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
-                    tmpOffset += 4;
+            if (existingGeoRef > 0) {
+                final int count = wayGeometry.getInt(existingGeoRef * 4L);
+                if (len <= count) {
+                    setWayGeometryAtGeoRef(pillarNodes, edgePointer, reverse, existingGeoRef);
+                    return;
                 }
             }
 
-            wayGeometry.setBytes(geoRef, bytes, bytes.length);
-        } else
-        {
+            long nextGeoRef = nextGeoRef(len * dim);
+            setWayGeometryAtGeoRef(pillarNodes, edgePointer, reverse, nextGeoRef);
+        } else {
             edges.setInt(edgePointer + E_GEO, 0);
         }
     }
 
-    private PointList fetchWayGeometry_( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
-    {
+    private void setWayGeometryAtGeoRef(PointList pillarNodes, long edgePointer, boolean reverse, long geoRef) {
+        int len = pillarNodes.getSize();
+        int dim = nodeAccess.getDimension();
+        long geoRefPosition = (long) geoRef * 4;
+        int totalLen = len * dim * 4 + 4;
+        ensureGeometry(geoRefPosition, totalLen);
+        byte[] wayGeometryBytes = createWayGeometryBytes(pillarNodes, reverse);
+        wayGeometry.setBytes(geoRefPosition, wayGeometryBytes, wayGeometryBytes.length);
+        edges.setInt(edgePointer + E_GEO, Helper.toSignedInt(geoRef));
+    }
+
+    private byte[] createWayGeometryBytes(PointList pillarNodes, boolean reverse) {
+        int len = pillarNodes.getSize();
+        int dim = nodeAccess.getDimension();
+        int totalLen = len * dim * 4 + 4;
+        byte[] bytes = new byte[totalLen];
+        bitUtil.fromInt(bytes, len, 0);
+        if (reverse)
+            pillarNodes.reverse();
+
+        int tmpOffset = 4;
+        boolean is3D = nodeAccess.is3D();
+        for (int i = 0; i < len; i++) {
+            double lat = pillarNodes.getLatitude(i);
+            bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
+            tmpOffset += 4;
+            bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
+            tmpOffset += 4;
+
+            if (is3D) {
+                bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
+                tmpOffset += 4;
+            }
+        }
+        return bytes;
+    }
+
+    private PointList fetchWayGeometry_(long edgePointer, boolean reverse, int mode, int baseNode, int adjNode) {
         long geoRef = Helper.toUnsignedLong(edges.getInt(edgePointer + E_GEO));
         int count = 0;
         byte[] bytes = null;
-        if (geoRef > 0)
-        {
+        if (geoRef > 0) {
             geoRef *= 4L;
             count = wayGeometry.getInt(geoRef);
 
@@ -874,49 +831,38 @@ private PointList fetchWayGeometry_( long edgePointer, boolean reverse, int mode
             return PointList.EMPTY;
 
         PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
-        if (reverse)
-        {
+        if (reverse) {
             if ((mode & 2) != 0)
                 pillarNodes.add(nodeAccess, adjNode);
-        } else
-        {
-            if ((mode & 1) != 0)
-                pillarNodes.add(nodeAccess, baseNode);
-        }
+        } else if ((mode & 1) != 0)
+            pillarNodes.add(nodeAccess, baseNode);
 
         int index = 0;
-        for (int i = 0; i < count; i++)
-        {
+        for (int i = 0; i < count; i++) {
             double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));
             index += 4;
             double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
             index += 4;
-            if (nodeAccess.is3D())
-            {
+            if (nodeAccess.is3D()) {
                 pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
                 index += 4;
-            } else
-            {
+            } else {
                 pillarNodes.add(lat, lon);
             }
         }
 
-        if (reverse)
-        {
+        if (reverse) {
             if ((mode & 1) != 0)
                 pillarNodes.add(nodeAccess, baseNode);
+
             pillarNodes.reverse();
-        } else
-        {
-            if ((mode & 2) != 0)
-                pillarNodes.add(nodeAccess, adjNode);
-        }
+        } else if ((mode & 2) != 0)
+            pillarNodes.add(nodeAccess, adjNode);
 
         return pillarNodes;
     }
 
-    private void setName( long edgePointer, String name )
-    {
+    private void setName(long edgePointer, String name) {
         int nameIndexRef = (int) nameIndex.put(name);
         if (nameIndexRef < 0)
             throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
@@ -924,28 +870,18 @@ private void setName( long edgePointer, String name )
         edges.setInt(edgePointer + E_NAME, nameIndexRef);
     }
 
-    GHBitSet getRemovedNodes()
-    {
+    GHBitSet getRemovedNodes() {
         if (removedNodes == null)
             removedNodes = new GHBitSetImpl(getNodes());
 
         return removedNodes;
     }
 
-    private static boolean isTestingEnabled()
-    {
-        boolean enableIfAssert = false;
-        assert (enableIfAssert = true) : true;
-        return enableIfAssert;
-    }
-
-    private void ensureGeometry( long bytePos, int byteLength )
-    {
+    private void ensureGeometry(long bytePos, int byteLength) {
         wayGeometry.ensureCapacity(bytePos + byteLength);
     }
 
-    private long nextGeoRef( int arrayLength )
-    {
+    private long nextGeoRef(int arrayLength) {
         long tmp = maxGeoRef;
         maxGeoRef += arrayLength + 1L;
         if (maxGeoRef >= 0xFFFFffffL)
@@ -954,13 +890,11 @@ private long nextGeoRef( int arrayLength )
         return tmp;
     }
 
-    protected static class EdgeIterable extends CommonEdgeIterator implements EdgeExplorer, EdgeIterator
-    {
+    protected static class EdgeIterable extends CommonEdgeIterator implements EdgeExplorer, EdgeIterator {
         final EdgeFilter filter;
         int nextEdgeId;
 
-        public EdgeIterable( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
-        {
+        public EdgeIterable(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter) {
             super(-1, edgeAccess, baseGraph);
 
             if (filter == null)
@@ -968,16 +902,13 @@ public EdgeIterable( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filt
             this.filter = filter;
         }
 
-        final void setEdgeId( int edgeId )
-        {
+        final void setEdgeId(int edgeId) {
             this.nextEdgeId = this.edgeId = edgeId;
         }
 
-        final boolean init( int tmpEdgeId, int expectedAdjNode )
-        {
+        final boolean init(int tmpEdgeId, int expectedAdjNode) {
             setEdgeId(tmpEdgeId);
-            if (tmpEdgeId != EdgeIterator.NO_EDGE)
-            {
+            if (tmpEdgeId != EdgeIterator.NO_EDGE) {
                 selectEdgeAccess();
                 this.edgePointer = edgeAccess.toPointer(tmpEdgeId);
             }
@@ -990,12 +921,10 @@ final boolean init( int tmpEdgeId, int expectedAdjNode )
             adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
             // a next() call should return false
             nextEdgeId = EdgeIterator.NO_EDGE;
-            if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE)
-            {
+            if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE) {
                 reverse = false;
                 return true;
-            } else if (expectedAdjNode == baseNode)
-            {
+            } else if (expectedAdjNode == baseNode) {
                 reverse = true;
                 baseNode = adjNode;
                 adjNode = expectedAdjNode;
@@ -1004,29 +933,24 @@ final boolean init( int tmpEdgeId, int expectedAdjNode )
             return false;
         }
 
-        final void _setBaseNode( int baseNode )
-        {
+        final void _setBaseNode(int baseNode) {
             this.baseNode = baseNode;
         }
 
         @Override
-        public EdgeIterator setBaseNode( int baseNode )
-        {
+        public EdgeIterator setBaseNode(int baseNode) {
             // always use base graph edge access
             setEdgeId(baseGraph.edgeAccess.getEdgeRef(baseNode));
             _setBaseNode(baseNode);
             return this;
         }
 
-        protected void selectEdgeAccess()
-        {
+        protected void selectEdgeAccess() {
         }
 
         @Override
-        public final boolean next()
-        {
-            while (true)
-            {
+        public final boolean next() {
+            while (true) {
                 if (nextEdgeId == EdgeIterator.NO_EDGE)
                     return false;
 
@@ -1048,15 +972,13 @@ public final boolean next()
         }
 
         @Override
-        public EdgeIteratorState detach( boolean reverseArg )
-        {
+        public EdgeIteratorState detach(boolean reverseArg) {
             if (edgeId == nextEdgeId || edgeId == EdgeIterator.NO_EDGE)
                 throw new IllegalStateException("call next before detaching or setEdgeId (edgeId:" + edgeId + " vs. next " + nextEdgeId + ")");
 
             EdgeIterable iter = edgeAccess.createSingleEdge(filter);
             boolean ret;
-            if (reverseArg)
-            {
+            if (reverseArg) {
                 ret = iter.init(edgeId, baseNode);
                 // for #162
                 iter.reverse = !reverse;
@@ -1070,29 +992,23 @@ public EdgeIteratorState detach( boolean reverseArg )
     /**
      * Include all edges of this storage in the iterator.
      */
-    protected static class AllEdgeIterator extends CommonEdgeIterator implements AllEdgesIterator
-    {
-        public AllEdgeIterator( BaseGraph baseGraph )
-        {
+    protected static class AllEdgeIterator extends CommonEdgeIterator implements AllEdgesIterator {
+        public AllEdgeIterator(BaseGraph baseGraph) {
             this(baseGraph, baseGraph.edgeAccess);
         }
 
-        private AllEdgeIterator( BaseGraph baseGraph, EdgeAccess edgeAccess )
-        {
+        private AllEdgeIterator(BaseGraph baseGraph, EdgeAccess edgeAccess) {
             super(-1, edgeAccess, baseGraph);
         }
 
         @Override
-        public int getMaxId()
-        {
+        public int getMaxId() {
             return baseGraph.edgeCount;
         }
 
         @Override
-        public boolean next()
-        {
-            while (true)
-            {
+        public boolean next() {
+            while (true) {
                 edgeId++;
                 edgePointer = (long) edgeId * edgeAccess.getEntryBytes();
                 if (!checkRange())
@@ -1111,27 +1027,23 @@ public boolean next()
             }
         }
 
-        protected boolean checkRange()
-        {
+        protected boolean checkRange() {
             return edgeId < baseGraph.edgeCount;
         }
 
         @Override
-        public final EdgeIteratorState detach( boolean reverseArg )
-        {
+        public final EdgeIteratorState detach(boolean reverseArg) {
             if (edgePointer < 0)
                 throw new IllegalStateException("call next before detaching");
 
             AllEdgeIterator iter = new AllEdgeIterator(baseGraph, edgeAccess);
             iter.edgeId = edgeId;
             iter.edgePointer = edgePointer;
-            if (reverseArg)
-            {
+            if (reverseArg) {
                 iter.reverse = !this.reverse;
                 iter.baseNode = adjNode;
                 iter.adjNode = baseNode;
-            } else
-            {
+            } else {
                 iter.reverse = this.reverse;
                 iter.baseNode = baseNode;
                 iter.adjNode = adjNode;
@@ -1143,55 +1055,47 @@ public final EdgeIteratorState detach( boolean reverseArg )
     /**
      * Common private super class for AllEdgesIteratorImpl and EdgeIterable
      */
-    static abstract class CommonEdgeIterator implements EdgeIteratorState
-    {
+    static abstract class CommonEdgeIterator implements EdgeIteratorState {
+        final BaseGraph baseGraph;
         protected long edgePointer;
         protected int baseNode;
         protected int adjNode;
-        // we need reverse if detach is called 
-        boolean reverse = false;
         protected EdgeAccess edgeAccess;
-        final BaseGraph baseGraph;
+        // we need reverse if detach is called
+        boolean reverse = false;
         boolean freshFlags;
-        private long cachedFlags;
         int edgeId = -1;
+        private long cachedFlags;
 
-        public CommonEdgeIterator( long edgePointer, EdgeAccess edgeAccess, BaseGraph baseGraph )
-        {
+        public CommonEdgeIterator(long edgePointer, EdgeAccess edgeAccess, BaseGraph baseGraph) {
             this.edgePointer = edgePointer;
             this.edgeAccess = edgeAccess;
             this.baseGraph = baseGraph;
         }
 
         @Override
-        public final int getBaseNode()
-        {
+        public final int getBaseNode() {
             return baseNode;
         }
 
         @Override
-        public final int getAdjNode()
-        {
+        public final int getAdjNode() {
             return adjNode;
         }
 
         @Override
-        public final double getDistance()
-        {
+        public final double getDistance() {
             return edgeAccess.getDist(edgePointer);
         }
 
         @Override
-        public final EdgeIteratorState setDistance( double dist )
-        {
+        public final EdgeIteratorState setDistance(double dist) {
             edgeAccess.setDist(edgePointer, dist);
             return this;
         }
 
-        final long getDirectFlags()
-        {
-            if (!freshFlags)
-            {
+        final long getDirectFlags() {
+            if (!freshFlags) {
                 cachedFlags = edgeAccess.getFlags_(edgePointer, reverse);
                 freshFlags = true;
             }
@@ -1199,14 +1103,12 @@ final long getDirectFlags()
         }
 
         @Override
-        public long getFlags()
-        {
+        public long getFlags() {
             return getDirectFlags();
         }
 
         @Override
-        public final EdgeIteratorState setFlags( long fl )
-        {
+        public final EdgeIteratorState setFlags(long fl) {
             edgeAccess.setFlags_(edgePointer, reverse, fl);
             cachedFlags = fl;
             freshFlags = true;
@@ -1214,21 +1116,18 @@ public final EdgeIteratorState setFlags( long fl )
         }
 
         @Override
-        public final int getAdditionalField()
-        {
+        public final int getAdditionalField() {
             return baseGraph.edges.getInt(edgePointer + baseGraph.E_ADDITIONAL);
         }
 
         @Override
-        public final EdgeIteratorState setAdditionalField( int value )
-        {
+        public final EdgeIteratorState setAdditionalField(int value) {
             baseGraph.setAdditionalEdgeField(edgePointer, value);
             return this;
         }
 
         @Override
-        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
+        public final EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
             return baseGraph.copyProperties(this, edge);
         }
 
@@ -1236,8 +1135,7 @@ public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
          * Reports whether the edge is available in forward direction for the specified encoder.
          */
         @Override
-        public boolean isForward( FlagEncoder encoder )
-        {
+        public boolean isForward(FlagEncoder encoder) {
             return encoder.isForward(getDirectFlags());
         }
 
@@ -1245,54 +1143,46 @@ public boolean isForward( FlagEncoder encoder )
          * Reports whether the edge is available in backward direction for the specified encoder.
          */
         @Override
-        public boolean isBackward( FlagEncoder encoder )
-        {
+        public boolean isBackward(FlagEncoder encoder) {
             return encoder.isBackward(getDirectFlags());
         }
 
         @Override
-        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
-        {
+        public EdgeIteratorState setWayGeometry(PointList pillarNodes) {
             baseGraph.setWayGeometry_(pillarNodes, edgePointer, reverse);
             return this;
         }
 
         @Override
-        public PointList fetchWayGeometry( int mode )
-        {
+        public PointList fetchWayGeometry(int mode) {
             return baseGraph.fetchWayGeometry_(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
         }
 
         @Override
-        public int getEdge()
-        {
+        public int getEdge() {
             return edgeId;
         }
 
         @Override
-        public String getName()
-        {
+        public String getName() {
             int nameIndexRef = baseGraph.edges.getInt(edgePointer + baseGraph.E_NAME);
             return baseGraph.nameIndex.get(nameIndexRef);
         }
 
         @Override
-        public EdgeIteratorState setName( String name )
-        {
+        public EdgeIteratorState setName(String name) {
             baseGraph.setName(edgePointer, name);
             return this;
         }
 
         @Override
-        public final boolean getBoolean( int key, boolean reverse, boolean _default )
-        {
+        public final boolean getBool(int key, boolean _default) {
             // for non-existent keys return default
             return _default;
         }
 
         @Override
-        public final String toString()
-        {
+        public final String toString() {
             return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
         }
     }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
index e146878545..b1cad63628 100755
--- a/core/src/main/java/com/graphhopper/storage/CHGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -27,36 +27,36 @@
  * levels for a node and creating shortcuts, which are additional 'artificial' edges to speedup
  * traversal in certain cases.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface CHGraph extends Graph
-{
+public interface CHGraph extends Graph {
     /**
      * This methods sets the level of the specified node.
      */
-    void setLevel( int nodeId, int level );
+    void setLevel(int nodeId, int level);
 
     /**
      * @return the level of the specified node.
      */
-    int getLevel( int nodeId );
+    int getLevel(int nodeId);
 
-    boolean isShortcut( int edgeId );
+    boolean isShortcut(int edgeId);
 
     /**
      * This method creates a shortcut between a to b which is nearly identical to creating an edge
      * except that it can be excluded or included for certain traversals or algorithms.
      */
-    CHEdgeIteratorState shortcut( int a, int b );
+    CHEdgeIteratorState shortcut(int a, int b);
 
     @Override
-    CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode );
+    CHEdgeIteratorState getEdgeIteratorState(int edgeId, int endNode);
 
     @Override
     CHEdgeExplorer createEdgeExplorer();
 
     @Override
-    CHEdgeExplorer createEdgeExplorer( EdgeFilter filter );
+    CHEdgeExplorer createEdgeExplorer(EdgeFilter filter);
 
     @Override
     AllCHEdgesIterator getAllEdges();
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index c0410953c8..b153604ff1 100755
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -18,44 +18,47 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.BaseGraph.AllEdgeIterator;
 import com.graphhopper.storage.BaseGraph.CommonEdgeIterator;
 import com.graphhopper.storage.BaseGraph.EdgeIterable;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Helper.nf;
 import com.graphhopper.util.shapes.BBox;
 
+import static com.graphhopper.util.Helper.nf;
+
 /**
  * A Graph implementation necessary for Contraction Hierarchies. This class enables the storage to
  * hold the level of a node and shortcut edges per edge.
  * <p>
+ *
  * @author Peter Karich
  */
-public class CHGraphImpl implements CHGraph, Storable<CHGraph>
-{
+public class CHGraphImpl implements CHGraph, Storable<CHGraph> {
     private static final double WEIGHT_FACTOR = 1000f;
     // 2 bits for access, for now only 32bit => not Long.MAX
     private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
     private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
-    private int N_LEVEL;
-    int N_CH_REF;
-    // shortcut memory layout is synced with edges indices until E_FLAGS, then:
-    private int S_SKIP_EDGE1, S_SKIP_EDGE2;
-
-    int shortcutEntryBytes;
-    private int shortcutCount = 0;
     final DataAccess shortcuts;
-    // the nodesCH storage is limited via baseGraph.nodeCount too
-    int nodeCHEntryBytes;
     final DataAccess nodesCH;
     final long scDirMask = PrepareEncoder.getScDirMask();
     private final BaseGraph baseGraph;
     private final EdgeAccess chEdgeAccess;
     private final Weighting weighting;
+    int N_CH_REF;
+    int shortcutEntryBytes;
+    // the nodesCH storage is limited via baseGraph.nodeCount too
+    int nodeCHEntryBytes;
+    private int N_LEVEL;
+    // shortcut memory layout is synced with edges indices until E_FLAGS, then:
+    private int S_SKIP_EDGE1, S_SKIP_EDGE2;
+    private int shortcutCount = 0;
 
-    CHGraphImpl( Weighting w, Directory dir, final BaseGraph baseGraph )
-    {
+    CHGraphImpl(Weighting w, Directory dir, final BaseGraph baseGraph) {
         if (w == null)
             throw new IllegalStateException("Weighting for CHGraph cannot be null");
 
@@ -64,54 +67,46 @@
         final String name = AbstractWeighting.weightingToFileName(w);
         this.nodesCH = dir.find("nodes_ch_" + name);
         this.shortcuts = dir.find("shortcuts_" + name);
-        this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil)
-        {
+        this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil) {
             @Override
-            final EdgeIterable createSingleEdge( EdgeFilter edgeFilter )
-            {
+            final EdgeIterable createSingleEdge(EdgeFilter edgeFilter) {
                 return new CHEdgeIteratorImpl(baseGraph, this, edgeFilter);
             }
 
             @Override
-            final int getEdgeRef( int nodeId )
-            {
+            final int getEdgeRef(int nodeId) {
                 return nodesCH.getInt((long) nodeId * nodeCHEntryBytes + N_CH_REF);
             }
 
             @Override
-            final void setEdgeRef( int nodeId, int edgeId )
-            {
+            final void setEdgeRef(int nodeId, int edgeId) {
                 nodesCH.setInt((long) nodeId * nodeCHEntryBytes + N_CH_REF, edgeId);
             }
 
             @Override
-            final int getEntryBytes()
-            {
+            final int getEntryBytes() {
                 return shortcutEntryBytes;
             }
 
             @Override
-            final long toPointer( int shortcutId )
-            {
+            final long toPointer(int shortcutId) {
                 assert isInBounds(shortcutId) : "shortcutId " + shortcutId + " not in bounds [" + baseGraph.edgeCount + ", " + (baseGraph.edgeCount + shortcutCount) + ")";
                 return (long) (shortcutId - baseGraph.edgeCount) * shortcutEntryBytes;
             }
 
             @Override
-            final boolean isInBounds( int shortcutId )
-            {
+            final boolean isInBounds(int shortcutId) {
                 int tmp = shortcutId - baseGraph.edgeCount;
                 return tmp < shortcutCount && tmp >= 0;
             }
 
             @Override
-            final long reverseFlags( long edgePointer, long flags )
-            {
+            final long reverseFlags(long edgePointer, long flags) {
                 boolean isShortcut = edgePointer >= toPointer(baseGraph.edgeCount);
                 if (!isShortcut)
                     return baseGraph.edgeAccess.reverseFlags(edgePointer, flags);
 
-                // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
+                // we need a special swapping for CHGraph if it is a shortcut as we only store the weight and access flags then
                 long dir = flags & scDirMask;
                 if (dir == scDirMask || dir == 0)
                     return flags;
@@ -121,47 +116,40 @@ final long reverseFlags( long edgePointer, long flags )
             }
 
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return "ch edge access " + name;
             }
         };
     }
 
-    public final Weighting getWeighting()
-    {
+    public final Weighting getWeighting() {
         return weighting;
     }
 
     @Override
-    public boolean isShortcut( int edgeId )
-    {
+    public boolean isShortcut(int edgeId) {
         assert baseGraph.isFrozen() : "level graph not yet frozen";
         return edgeId >= baseGraph.edgeCount;
     }
 
     @Override
-    public final void setLevel( int nodeIndex, int level )
-    {
+    public final void setLevel(int nodeIndex, int level) {
         checkNodeId(nodeIndex);
         nodesCH.setInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int nodeIndex )
-    {
+    public final int getLevel(int nodeIndex) {
         checkNodeId(nodeIndex);
         return nodesCH.getInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL);
     }
 
-    final void checkNodeId( int nodeId )
-    {
+    final void checkNodeId(int nodeId) {
         assert nodeId < baseGraph.getNodes() : "node " + nodeId + " is invalid. Not in [0," + baseGraph.getNodes() + ")";
     }
 
     @Override
-    public CHEdgeIteratorState shortcut( int a, int b )
-    {
+    public CHEdgeIteratorState shortcut(int a, int b) {
         if (!baseGraph.isFrozen())
             throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
 
@@ -176,8 +164,7 @@ public CHEdgeIteratorState shortcut( int a, int b )
         return iter;
     }
 
-    protected int nextShortcutId()
-    {
+    protected int nextShortcutId() {
         int nextSC = shortcutCount;
         shortcutCount++;
         if (shortcutCount < 0)
@@ -188,14 +175,12 @@ protected int nextShortcutId()
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
-    {
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
         return edge(a, b).setDistance(distance).setFlags(baseGraph.encodingManager.flagsDefault(true, bothDirections));
     }
 
     @Override
-    public CHEdgeIteratorState edge( int a, int b )
-    {
+    public CHEdgeIteratorState edge(int a, int b) {
         // increase edge array not for shortcuts
         baseGraph.ensureNodeIndex(Math.max(a, b));
         int edgeId = baseGraph.edgeAccess.internalEdgeAdd(baseGraph.nextEdgeId(), a, b);
@@ -206,62 +191,50 @@ public CHEdgeIteratorState edge( int a, int b )
     }
 
     @Override
-    public CHEdgeExplorer createEdgeExplorer()
-    {
+    public CHEdgeExplorer createEdgeExplorer() {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
-    public CHEdgeExplorer createEdgeExplorer( EdgeFilter filter )
-    {
+    public CHEdgeExplorer createEdgeExplorer(EdgeFilter filter) {
         return new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, filter);
     }
 
     @Override
-    public final CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode )
-    {
-        if (isShortcut(edgeId))
-        {
+    public final CHEdgeIteratorState getEdgeIteratorState(int edgeId, int endNode) {
+        if (isShortcut(edgeId)) {
             if (!chEdgeAccess.isInBounds(edgeId))
                 throw new IllegalStateException("shortcutId " + edgeId + " out of bounds");
-        } else
-        {
-            if (!baseGraph.edgeAccess.isInBounds(edgeId))
-                throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
-        }
+        } else if (!baseGraph.edgeAccess.isInBounds(edgeId))
+            throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
 
         return (CHEdgeIteratorState) chEdgeAccess.getEdgeProps(edgeId, endNode);
     }
 
     @Override
-    public int getNodes()
-    {
+    public int getNodes() {
         return baseGraph.getNodes();
     }
 
     @Override
-    public NodeAccess getNodeAccess()
-    {
+    public NodeAccess getNodeAccess() {
         return baseGraph.getNodeAccess();
     }
 
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return baseGraph.getBounds();
     }
 
-    void _freeze()
-    {
+    void _freeze() {
         long maxCapacity = ((long) getNodes()) * nodeCHEntryBytes;
         nodesCH.ensureCapacity(maxCapacity);
         long baseCapacity = baseGraph.nodes.getCapacity();
 
         // copy normal edge refs into ch edge refs
         for (long pointer = N_CH_REF, basePointer = baseGraph.N_EDGE_REF;
-                pointer < maxCapacity;
-                pointer += nodeCHEntryBytes, basePointer += baseGraph.nodeEntryBytes)
-        {
+             pointer < maxCapacity;
+             pointer += nodeCHEntryBytes, basePointer += baseGraph.nodeEntryBytes) {
             if (basePointer >= baseCapacity)
                 throw new IllegalStateException("Cannot copy edge refs into ch graph. "
                         + "pointer:" + pointer + ", cap:" + maxCapacity + ", basePtr:" + basePointer + ", baseCap:" + baseCapacity);
@@ -270,28 +243,175 @@ void _freeze()
         }
     }
 
-    String toDetailsString()
-    {
+    String toDetailsString() {
         return toString() + ", shortcuts:" + nf(shortcutCount) + ", nodesCH:(" + nodesCH.getCapacity() / Helper.MB + "MB)";
     }
 
-    class CHEdgeIteratorImpl extends EdgeIterable implements CHEdgeExplorer, CHEdgeIterator
-    {
-        public CHEdgeIteratorImpl( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
-        {
+    /**
+     * Disconnects the edges (higher to lower node) via the specified edgeState pointing from lower to
+     * higher node.
+     * <p>
+     *
+     * @param edgeState the edge from lower to higher
+     */
+    public void disconnect(CHEdgeExplorer explorer, EdgeIteratorState edgeState) {
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
+        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
+        CHEdgeIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
+        int tmpPrevEdge = EdgeIterator.NO_EDGE;
+        while (tmpIter.next()) {
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge()) {
+                // TODO this is ugly, move this somehow into the underlying iteration logic
+                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
+                        : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
+                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer,
+                        edgeState.getAdjNode(), edgeState.getBaseNode());
+                break;
+            }
+
+            tmpPrevEdge = tmpIter.getEdge();
+        }
+    }
+
+    @Override
+    public AllCHEdgesIterator getAllEdges() {
+        return new AllCHEdgesIteratorImpl(baseGraph);
+    }
+
+    final void setWeight(CommonEdgeIterator edge, double weight) {
+        if (weight < 0)
+            throw new IllegalArgumentException("weight cannot be negative but was " + weight);
+
+        long weightLong;
+        if (weight > MAX_WEIGHT)
+            weightLong = MAX_WEIGHT_LONG;
+        else
+            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
+
+        long accessFlags = edge.getDirectFlags() & scDirMask;
+        edge.setFlags(weightLong | accessFlags);
+    }
+
+    final double getWeight(CommonEdgeIterator edge) {
+        // no need for reverseFlags call (shortcut has identical weight if both dies) and also no need for 64bit
+        long flags32bit = edge.getDirectFlags();
+        double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
+        if (weight >= MAX_WEIGHT)
+            return Double.POSITIVE_INFINITY;
+
+        return weight;
+    }
+
+    protected int loadEdgesHeader() {
+        shortcutCount = shortcuts.getHeader(0 * 4);
+        shortcutEntryBytes = shortcuts.getHeader(1 * 4);
+        return 3;
+    }
+
+    protected int setEdgesHeader() {
+        shortcuts.setHeader(0 * 4, shortcutCount);
+        shortcuts.setHeader(1 * 4, shortcutEntryBytes);
+        return 3;
+    }
+
+    @Override
+    public GraphExtension getExtension() {
+        return baseGraph.getExtension();
+    }
+
+    @Override
+    public Graph getBaseGraph() {
+        return baseGraph;
+    }
+
+    @Override
+    public Graph copyTo(Graph g) {
+        CHGraphImpl tmpG = ((CHGraphImpl) g);
+
+        nodesCH.copyTo(tmpG.nodesCH);
+        shortcuts.copyTo(tmpG.shortcuts);
+
+        tmpG.N_LEVEL = N_LEVEL;
+        tmpG.N_CH_REF = N_CH_REF;
+        tmpG.nodeCHEntryBytes = nodeCHEntryBytes;
+        return g;
+    }
+
+    void initStorage() {
+        EdgeAccess ea = baseGraph.edgeAccess;
+        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS, false);
+        // shortcuts
+        S_SKIP_EDGE1 = ea.E_FLAGS + 4;
+        S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
+        shortcutEntryBytes = S_SKIP_EDGE2 + 4;
+
+        // node based data:
+        N_LEVEL = 0;
+        N_CH_REF = N_LEVEL + 4;
+        nodeCHEntryBytes = N_CH_REF + 4;
+    }
+
+    void setSegmentSize(int bytes) {
+        nodesCH.setSegmentSize(bytes);
+        shortcuts.setSegmentSize(bytes);
+    }
+
+    @Override
+    public CHGraph create(long bytes) {
+        nodesCH.create(bytes);
+        shortcuts.create(bytes);
+        return this;
+    }
+
+    @Override
+    public boolean loadExisting() {
+        if (!nodesCH.loadExisting() || !shortcuts.loadExisting())
+            return false;
+
+        loadEdgesHeader();
+        return true;
+    }
+
+    @Override
+    public void flush() {
+        nodesCH.flush();
+        shortcuts.flush();
+    }
+
+    @Override
+    public void close() {
+        nodesCH.close();
+        shortcuts.close();
+    }
+
+    @Override
+    public boolean isClosed() {
+        return nodesCH.isClosed();
+    }
+
+    @Override
+    public long getCapacity() {
+        return nodesCH.getCapacity() + shortcuts.getCapacity();
+    }
+
+    @Override
+    public String toString() {
+        return "CHGraph|" + getWeighting().toString();
+    }
+
+    class CHEdgeIteratorImpl extends EdgeIterable implements CHEdgeExplorer, CHEdgeIterator {
+        public CHEdgeIteratorImpl(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter) {
             super(baseGraph, edgeAccess, filter);
         }
 
         @Override
-        public final long getFlags()
-        {
+        public final long getFlags() {
             checkShortcut(false, "getFlags");
             return super.getDirectFlags();
         }
 
         @Override
-        public final CHEdgeIterator setBaseNode( int baseNode )
-        {
+        public final CHEdgeIterator setBaseNode(int baseNode) {
             assert baseGraph.isFrozen() : "Traversal CHGraph is only possible if BaseGraph is frozen";
 
             // always use ch edge access
@@ -301,11 +421,9 @@ public final CHEdgeIterator setBaseNode( int baseNode )
         }
 
         @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
+        public final void setSkippedEdges(int edge1, int edge2) {
             checkShortcut(true, "setSkippedEdges");
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2))
-            {
+            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
                 throw new IllegalStateException("Skipped edges of a shortcut needs "
                         + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
             }
@@ -314,29 +432,25 @@ public final void setSkippedEdges( int edge1, int edge2 )
         }
 
         @Override
-        public final int getSkippedEdge1()
-        {
+        public final int getSkippedEdge1() {
             checkShortcut(true, "getSkippedEdge1");
             return shortcuts.getInt(edgePointer + S_SKIP_EDGE1);
         }
 
         @Override
-        public final int getSkippedEdge2()
-        {
+        public final int getSkippedEdge2() {
             checkShortcut(true, "getSkippedEdge2");
             return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
         @Override
-        public final boolean isShortcut()
-        {
+        public final boolean isShortcut() {
             // assert baseGraph.isFrozen() : "chgraph not yet frozen";
             return edgeId >= baseGraph.edgeCount;
         }
 
         @Override
-        public boolean isBackward( FlagEncoder encoder )
-        {
+        public boolean isBackward(FlagEncoder encoder) {
             assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
             if (isShortcut())
                 return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
@@ -345,8 +459,7 @@ public boolean isBackward( FlagEncoder encoder )
         }
 
         @Override
-        public boolean isForward( FlagEncoder encoder )
-        {
+        public boolean isForward(FlagEncoder encoder) {
             assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
             if (isShortcut())
                 return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
@@ -355,23 +468,20 @@ public boolean isForward( FlagEncoder encoder )
         }
 
         @Override
-        public final CHEdgeIteratorState setWeight( double weight )
-        {
+        public final CHEdgeIteratorState setWeight(double weight) {
             checkShortcut(true, "setWeight");
             CHGraphImpl.this.setWeight(this, weight);
             return this;
         }
 
         @Override
-        public final double getWeight()
-        {
+        public final double getWeight() {
             checkShortcut(true, "getWeight");
             return CHGraphImpl.this.getWeight(this);
         }
 
         @Override
-        protected final void selectEdgeAccess()
-        {
+        protected final void selectEdgeAccess() {
             if (nextEdgeId < baseGraph.edgeCount)
                 // iterate over edges
                 edgeAccess = baseGraph.edgeAccess;
@@ -380,98 +490,51 @@ protected final void selectEdgeAccess()
                 edgeAccess = chEdgeAccess;
         }
 
-        public void checkShortcut( boolean shouldBeShortcut, String methodName )
-        {
-            if (isShortcut())
-            {
+        public void checkShortcut(boolean shouldBeShortcut, String methodName) {
+            if (isShortcut()) {
                 if (!shouldBeShortcut)
                     throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
-            } else
-            {
-                if (shouldBeShortcut)
-                    throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
-            }
+            } else if (shouldBeShortcut)
+                throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
         }
 
         @Override
-        public final String getName()
-        {
+        public final String getName() {
             checkShortcut(false, "getName");
             return super.getName();
         }
 
         @Override
-        public final EdgeIteratorState setName( String name )
-        {
+        public final EdgeIteratorState setName(String name) {
             checkShortcut(false, "setName");
             return super.setName(name);
         }
 
         @Override
-        public final PointList fetchWayGeometry( int mode )
-        {
+        public final PointList fetchWayGeometry(int mode) {
             checkShortcut(false, "fetchWayGeometry");
             return super.fetchWayGeometry(mode);
         }
 
         @Override
-        public final EdgeIteratorState setWayGeometry( PointList list )
-        {
+        public final EdgeIteratorState setWayGeometry(PointList list) {
             checkShortcut(false, "setWayGeometry");
             return super.setWayGeometry(list);
         }
 
         @Override
-        public boolean canBeOverwritten( long flags )
-        {
+        public boolean canBeOverwritten(long flags) {
             return PrepareEncoder.canBeOverwritten(getDirectFlags(), flags);
         }
     }
 
-    /**
-     * Disconnects the edges (higher to lower node) via the specified edgeState pointing from lower to
-     * higher node.
-     * <p>
-     * @param edgeState the edge from lower to higher
-     */
-    public void disconnect( CHEdgeExplorer explorer, EdgeIteratorState edgeState )
-    {
-        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
-        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
-        CHEdgeIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
-        int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        while (tmpIter.next())
-        {
-            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
-            {
-                // TODO this is ugly, move this somehow into the underlying iteration logic
-                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
-                        : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
-                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer,
-                        edgeState.getAdjNode(), edgeState.getBaseNode());
-                break;
-            }
-
-            tmpPrevEdge = tmpIter.getEdge();
-        }
-    }
-
-    @Override
-    public AllCHEdgesIterator getAllEdges()
-    {
-        return new AllCHEdgesIteratorImpl(baseGraph);
-    }
-
-    class AllCHEdgesIteratorImpl extends AllEdgeIterator implements AllCHEdgesIterator
-    {
-        public AllCHEdgesIteratorImpl( BaseGraph baseGraph )
-        {
+    class AllCHEdgesIteratorImpl extends AllEdgeIterator implements AllCHEdgesIterator {
+        public AllCHEdgesIteratorImpl(BaseGraph baseGraph) {
             super(baseGraph);
         }
 
         @Override
-        protected final boolean checkRange()
-        {
+        protected final boolean checkRange() {
             if (isShortcut())
                 return edgeId < shortcutCount;
 
@@ -486,16 +549,14 @@ protected final boolean checkRange()
         }
 
         @Override
-        public int getEdge()
-        {
+        public int getEdge() {
             if (isShortcut())
                 return baseGraph.edgeCount + edgeId;
             return super.getEdge();
         }
 
         @Override
-        public boolean isBackward( FlagEncoder encoder )
-        {
+        public boolean isBackward(FlagEncoder encoder) {
             assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
             if (isShortcut())
                 return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
@@ -504,8 +565,7 @@ public boolean isBackward( FlagEncoder encoder )
         }
 
         @Override
-        public boolean isForward( FlagEncoder encoder )
-        {
+        public boolean isForward(FlagEncoder encoder) {
             assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
             if (isShortcut())
                 return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
@@ -514,199 +574,53 @@ public boolean isForward( FlagEncoder encoder )
         }
 
         @Override
-        public final long getFlags()
-        {
+        public final long getFlags() {
             if (isShortcut())
                 throw new IllegalStateException("Shortcut should not need to return raw flags!");
             return getDirectFlags();
         }
 
         @Override
-        public int getMaxId()
-        {
+        public int getMaxId() {
             return super.getMaxId() + shortcutCount;
         }
 
         @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
+        public final void setSkippedEdges(int edge1, int edge2) {
             baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE1, edge1);
             baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE2, edge2);
         }
 
         @Override
-        public final int getSkippedEdge1()
-        {
+        public final int getSkippedEdge1() {
             return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE1);
         }
 
         @Override
-        public final int getSkippedEdge2()
-        {
+        public final int getSkippedEdge2() {
             return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
         @Override
-        public final boolean isShortcut()
-        {
+        public final boolean isShortcut() {
             assert baseGraph.isFrozen() : "level graph not yet frozen";
             return edgeAccess == chEdgeAccess;
         }
 
         @Override
-        public final CHEdgeIteratorState setWeight( double weight )
-        {
+        public final CHEdgeIteratorState setWeight(double weight) {
             CHGraphImpl.this.setWeight(this, weight);
             return this;
         }
 
         @Override
-        public final double getWeight()
-        {
+        public final double getWeight() {
             return CHGraphImpl.this.getWeight(this);
         }
 
         @Override
-        public boolean canBeOverwritten( long flags )
-        {
+        public boolean canBeOverwritten(long flags) {
             return PrepareEncoder.canBeOverwritten(getDirectFlags(), flags);
         }
     }
-
-    final void setWeight( CommonEdgeIterator edge, double weight )
-    {
-        if (weight < 0)
-            throw new IllegalArgumentException("weight cannot be negative but was " + weight);
-
-        long weightLong;
-        if (weight > MAX_WEIGHT)
-            weightLong = MAX_WEIGHT_LONG;
-        else
-            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
-
-        long accessFlags = edge.getDirectFlags() & scDirMask;
-        edge.setFlags(weightLong | accessFlags);
-    }
-
-    final double getWeight( CommonEdgeIterator edge )
-    {
-        // no need for reverseFlags call (shortcut has identical weight if both dies) and also no need for 64bit        
-        long flags32bit = edge.getDirectFlags();
-        double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
-        if (weight >= MAX_WEIGHT)
-            return Double.POSITIVE_INFINITY;
-
-        return weight;
-    }
-
-    protected int loadEdgesHeader()
-    {
-        shortcutCount = shortcuts.getHeader(0 * 4);
-        shortcutEntryBytes = shortcuts.getHeader(1 * 4);
-        return 3;
-    }
-
-    protected int setEdgesHeader()
-    {
-        shortcuts.setHeader(0 * 4, shortcutCount);
-        shortcuts.setHeader(1 * 4, shortcutEntryBytes);
-        return 3;
-    }
-
-    @Override
-    public GraphExtension getExtension()
-    {
-        return baseGraph.getExtension();
-    }
-
-    @Override
-    public Graph getBaseGraph()
-    {
-        return baseGraph;
-    }
-
-    @Override
-    public Graph copyTo( Graph g )
-    {
-        CHGraphImpl tmpG = ((CHGraphImpl) g);
-
-        nodesCH.copyTo(tmpG.nodesCH);
-        shortcuts.copyTo(tmpG.shortcuts);
-
-        tmpG.N_LEVEL = N_LEVEL;
-        tmpG.N_CH_REF = N_CH_REF;
-        tmpG.nodeCHEntryBytes = nodeCHEntryBytes;
-        return g;
-    }
-
-    void initStorage()
-    {
-        EdgeAccess ea = baseGraph.edgeAccess;
-        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS, false);
-        // shortcuts
-        S_SKIP_EDGE1 = ea.E_FLAGS + 4;
-        S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
-        shortcutEntryBytes = S_SKIP_EDGE2 + 4;
-
-        // node based data:
-        N_LEVEL = 0;
-        N_CH_REF = N_LEVEL + 4;
-        nodeCHEntryBytes = N_CH_REF + 4;
-    }
-
-    void setSegmentSize( int bytes )
-    {
-        nodesCH.setSegmentSize(bytes);
-        shortcuts.setSegmentSize(bytes);
-    }
-
-    @Override
-    public CHGraph create( long bytes )
-    {
-        nodesCH.create(bytes);
-        shortcuts.create(bytes);
-        return this;
-    }
-
-    @Override
-    public boolean loadExisting()
-    {
-        if (!nodesCH.loadExisting() || !shortcuts.loadExisting())
-            return false;
-
-        loadEdgesHeader();
-        return true;
-    }
-
-    @Override
-    public void flush()
-    {
-        nodesCH.flush();
-        shortcuts.flush();
-    }
-
-    @Override
-    public void close()
-    {
-        nodesCH.close();
-        shortcuts.close();
-    }
-
-    @Override
-    public boolean isClosed()
-    {
-        return nodesCH.isClosed();
-    }
-
-    @Override
-    public long getCapacity()
-    {
-        return nodesCH.getCapacity() + shortcuts.getCapacity();
-    }
-
-    @Override
-    public String toString()
-    {
-        return "CHGraph|" + getWeighting().toString();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index c2ba4fb48d..3d95dd37ec 100755
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -20,10 +20,10 @@
 /**
  * Defines how a DataAccess object is created.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DAType
-{
+public class DAType {
     /**
      * The DA object is hold entirely in-memory. Loading and flushing is a no-op. See RAMDataAccess.
      */
@@ -56,21 +56,13 @@
      * Experimental API. Do not use yet.
      */
     public static final DAType UNSAFE_STORE = new DAType(MemRef.UNSAFE, true, false, true, false);
-
-    public enum MemRef
-    {
-        HEAP, MMAP, UNSAFE /*, DIRECT */
-
-    }
-
     private final MemRef memRef;
     private final boolean storing;
     private final boolean integ;
     private final boolean synched;
     private final boolean allowWrites;
 
-    public DAType( DAType type, boolean synched )
-    {
+    public DAType(DAType type, boolean synched) {
         this(type.getMemRef(), type.isStoring(), type.isInteg(), type.isAllowWrites(), synched);
         if (!synched)
             throw new IllegalStateException("constructor can only be used with synched=true");
@@ -78,8 +70,7 @@ public DAType( DAType type, boolean synched )
             throw new IllegalStateException("something went wrong as DataAccess object is already synched!?");
     }
 
-    public DAType( MemRef memRef, boolean storing, boolean integ, boolean allowWrites, boolean synched )
-    {
+    public DAType(MemRef memRef, boolean storing, boolean integ, boolean allowWrites, boolean synched) {
         this.memRef = memRef;
         this.storing = storing;
         this.integ = integ;
@@ -87,45 +78,56 @@ public DAType( MemRef memRef, boolean storing, boolean integ, boolean allowWrite
         this.synched = synched;
     }
 
+    public static DAType fromString(String dataAccess) {
+        dataAccess = dataAccess.toUpperCase();
+        DAType type;
+        if (dataAccess.contains("MMAP"))
+            type = DAType.MMAP;
+        else if (dataAccess.contains("UNSAFE"))
+            type = DAType.UNSAFE_STORE;
+        else if (dataAccess.contains("RAM_STORE"))
+            type = DAType.RAM_STORE;
+        else
+            type = DAType.RAM;
+
+        if (dataAccess.contains("SYNC"))
+            type = new DAType(type, true);
+        return type;
+    }
+
     /**
      * Memory mapped or purely in memory? default is HEAP
      */
-    MemRef getMemRef()
-    {
+    MemRef getMemRef() {
         return memRef;
     }
 
-    public boolean isAllowWrites()
-    {
+    public boolean isAllowWrites() {
         return allowWrites;
     }
 
     /**
      * @return true if data resides in the JVM heap.
      */
-    public boolean isInMemory()
-    {
+    public boolean isInMemory() {
         return memRef == MemRef.HEAP;
     }
 
-    public boolean isMMap()
-    {
+    public boolean isMMap() {
         return memRef == MemRef.MMAP;
     }
 
     /**
      * Temporary data or store (with loading and storing)? default is false
      */
-    public boolean isStoring()
-    {
+    public boolean isStoring() {
         return storing;
     }
 
     /**
      * Optimized for integer values? default is false
      */
-    public boolean isInteg()
-    {
+    public boolean isInteg() {
         return integ;
     }
 
@@ -134,14 +136,12 @@ public boolean isInteg()
      * DataAccess object is only read-thread safe where a memory mapped one is not even
      * read-threadsafe!
      */
-    public boolean isSynched()
-    {
+    public boolean isSynched() {
         return synched;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str;
         if (getMemRef() == MemRef.MMAP)
             str = "MMAP";
@@ -159,30 +159,8 @@ else if (getMemRef() == MemRef.HEAP)
         return str;
     }
 
-    public static DAType fromString( String dataAccess )
-    {
-        dataAccess = dataAccess.toUpperCase();
-        DAType type;
-        if (dataAccess.contains("MMAP"))
-            type = DAType.MMAP;
-        else if (dataAccess.contains("UNSAFE"))
-            type = DAType.UNSAFE_STORE;
-        else
-        {
-            if (dataAccess.contains("RAM_STORE"))
-                type = DAType.RAM_STORE;
-            else
-                type = DAType.RAM;
-        }
-
-        if (dataAccess.contains("SYNC"))
-            type = new DAType(type, true);
-        return type;
-    }
-
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 7;
         hash = 59 * hash + 37 * this.memRef.hashCode();
         hash = 59 * hash + (this.storing ? 1 : 0);
@@ -192,8 +170,7 @@ public int hashCode()
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
         if (getClass() != obj.getClass())
@@ -209,4 +186,10 @@ public boolean equals( Object obj )
             return false;
         return true;
     }
+
+    public enum MemRef {
+        HEAP, MMAP, UNSAFE
+        /*, DIRECT */
+
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index b79ec19702..1acc1b978e 100755
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -25,10 +25,10 @@
  * Life cycle: (1) object creation, (2) configuration (e.g. segment size), (3) create or
  * loadExisting, (4) usage and calling ensureCapacity if necessary, (5) close
  * <p>
+ *
  * @author Peter Karich
  */
-public interface DataAccess extends Storable<DataAccess>
-{
+public interface DataAccess extends Storable<DataAccess> {
     /**
      * The logical identification of this object.
      */
@@ -38,89 +38,92 @@
      * Renames the underlying DataAccess object. (Flushing shouldn't be necessary before or
      * afterwards)
      * <p>
+     *
      * @throws IllegalStateException if a rename is not possible
      */
-    void rename( String newName );
+    void rename(String newName);
 
     /**
      * Set 4 bytes at position 'bytePos' to the specified value
      */
-    void setInt( long bytePos, int value );
+    void setInt(long bytePos, int value);
 
     /**
      * Get 4 bytes from position 'bytePos'
      */
-    int getInt( long bytePos );
+    int getInt(long bytePos);
 
     /**
      * Set 2 bytes at position 'index' to the specified value
      */
-    void setShort( long bytePos, short value );
+    void setShort(long bytePos, short value);
 
     /**
      * Get 2 bytes from position 'index'
      */
-    short getShort( long bytePos );
+    short getShort(long bytePos);
 
     /**
      * Set bytes from position 'index' to the specified values
      */
-    void setBytes( long bytePos, byte[] values, int length );
+    void setBytes(long bytePos, byte[] values, int length);
 
     /**
      * Get bytes from position 'index'
      * <p>
+     *
      * @param values acts as output
      */
-    void getBytes( long bytePos, byte[] values, int length );
+    void getBytes(long bytePos, byte[] values, int length);
 
     /**
      * Set 4 bytes at the header space index to the specified value
      */
-    void setHeader( int bytePos, int value );
+    void setHeader(int bytePos, int value);
 
     /**
      * Get 4 bytes from the header at 'index'
      */
-    int getHeader( int bytePos );
+    int getHeader(int bytePos);
 
     /**
      * The first time you use a DataAccess object after configuring it you need to call this. After
      * that first call you have to use ensureCapacity to ensure that enough space is reserved.
      */
     @Override
-    DataAccess create( long bytes );
+    DataAccess create(long bytes);
 
     /**
      * Ensures that the capacity of this object is at least the specified bytes. The first time you
      * have to call 'create' instead.
      * <p>
+     *
      * @return true if size was increased
      * @see #create(long)
      */
-    boolean ensureCapacity( long bytes );
+    boolean ensureCapacity(long bytes);
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
      * is in use!
      */
-    void trimTo( long bytes );
+    void trimTo(long bytes);
 
     /**
      * Copies the content from this object into the specified one.
      */
-    DataAccess copyTo( DataAccess da );
+    DataAccess copyTo(DataAccess da);
 
     /**
-     * In order to increase allocated space one needs to layout the underlying storage in segments.
-     * This is how you can customize the size.
+     * @return the size of one segment in bytes
      */
-    DataAccess setSegmentSize( int bytes );
+    int getSegmentSize();
 
     /**
-     * @return the size of one segment in bytes
+     * In order to increase allocated space one needs to layout the underlying storage in segments.
+     * This is how you can customize the size.
      */
-    int getSegmentSize();
+    DataAccess setSegmentSize(int bytes);
 
     /**
      * @return the number of segments.
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 6659b04b30..9bce148091 100755
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -25,10 +25,10 @@
  * Directory as we need one to maintain one DataAccess object for nodes, edges and location2id
  * index.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Directory
-{
+public interface Directory {
     /**
      * @return an id or location in the local filesystem.
      */
@@ -43,9 +43,9 @@
      * Tries to find the object with that name if not existent it creates one and associates the
      * location with it. A name is unique in one Directory.
      */
-    DataAccess find( String name );
+    DataAccess find(String name);
 
-    DataAccess find( String name, DAType type );
+    DataAccess find(String name, DAType type);
 
     /**
      * Renames the specified DataAccess object into one.
@@ -54,7 +54,7 @@
     /**
      * Removes the specified object from the directory.
      */
-    void remove( DataAccess da );
+    void remove(DataAccess da);
 
     /**
      * @return the default type of a newly created DataAccess object
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 627d2f0ea8..747e1951d2 100755
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -25,25 +25,22 @@
 /**
  * @author Peter Karich
  */
-abstract class EdgeAccess
-{
+abstract class EdgeAccess {
+    static final int NO_NODE = -1;
     // distance of around +-1000 000 meter are ok
     private static final double INT_DIST_FACTOR = 1000d;
     static double MAX_DIST = (Integer.MAX_VALUE - 1) / INT_DIST_FACTOR;
-    static final int NO_NODE = -1;
-    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
     final DataAccess edges;
     private final BitUtil bitUtil;
+    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
     private boolean flagsSizeIsLong;
 
-    EdgeAccess( DataAccess edges, BitUtil bitUtil )
-    {
+    EdgeAccess(DataAccess edges, BitUtil bitUtil) {
         this.edges = edges;
         this.bitUtil = bitUtil;
     }
 
-    final void init( int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS, boolean flagsSizeIsLong )
-    {
+    final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS, boolean flagsSizeIsLong) {
         this.E_NODEA = E_NODEA;
         this.E_NODEB = E_NODEB;
         this.E_LINKA = E_LINKA;
@@ -53,60 +50,54 @@ final void init( int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST,
         this.flagsSizeIsLong = flagsSizeIsLong;
     }
 
-    abstract BaseGraph.EdgeIterable createSingleEdge( EdgeFilter edgeFilter );
+    abstract BaseGraph.EdgeIterable createSingleEdge(EdgeFilter edgeFilter);
 
-    abstract long toPointer( int edgeOrShortcutId );
+    abstract long toPointer(int edgeOrShortcutId);
 
-    abstract boolean isInBounds( int edgeOrShortcutId );
+    abstract boolean isInBounds(int edgeOrShortcutId);
 
-    abstract long reverseFlags( long edgePointer, long flags );
+    abstract long reverseFlags(long edgePointer, long flags);
 
-    abstract int getEdgeRef( int nodeId );
+    abstract int getEdgeRef(int nodeId);
 
-    abstract void setEdgeRef( int nodeId, int edgeId );
+    abstract void setEdgeRef(int nodeId, int edgeId);
 
     abstract int getEntryBytes();
 
-    final void invalidateEdge( long edgePointer )
-    {
+    final void invalidateEdge(long edgePointer) {
         edges.setInt(edgePointer + E_NODEA, NO_NODE);
     }
 
-    final void setDist( long edgePointer, double distance )
-    {
+    final void setDist(long edgePointer, double distance) {
         edges.setInt(edgePointer + E_DIST, distToInt(distance));
     }
 
     /**
      * Translates double distance to integer in order to save it in a DataAccess object
      */
-    private int distToInt( double distance )
-    {
+    private int distToInt(double distance) {
         int integ = (int) (distance * INT_DIST_FACTOR);
         if (integ < 0)
             throw new IllegalArgumentException("Distance cannot be negative: " + distance);
         if (integ >= Integer.MAX_VALUE)
             return Integer.MAX_VALUE;
-            // throw new IllegalArgumentException("Distance too large leading to overflowed integer (#435): " + distance + " ");
+        // throw new IllegalArgumentException("Distance too large leading to overflowed integer (#435): " + distance + " ");
         return integ;
     }
 
     /**
      * returns distance (already translated from integer to double)
      */
-    final double getDist( long pointer )
-    {
+    final double getDist(long pointer) {
         int val = edges.getInt(pointer + E_DIST);
         // do never return infinity even if INT MAX, see #435
         return val / INT_DIST_FACTOR;
     }
 
-    final long getFlags_( long edgePointer, boolean reverse )
-    {
+    final long getFlags_(long edgePointer, boolean reverse) {
         int low = edges.getInt(edgePointer + E_FLAGS);
         long resFlags = low;
-        if (flagsSizeIsLong)
-        {
+        if (flagsSizeIsLong) {
             int high = edges.getInt(edgePointer + E_FLAGS + 4);
             resFlags = bitUtil.combineIntsToLong(low, high);
         }
@@ -116,8 +107,7 @@ final long getFlags_( long edgePointer, boolean reverse )
         return resFlags;
     }
 
-    final long setFlags_( long edgePointer, boolean reverse, long flags )
-    {
+    final long setFlags_(long edgePointer, boolean reverse, long flags) {
         if (reverse)
             flags = reverseFlags(edgePointer, flags);
 
@@ -132,8 +122,7 @@ final long setFlags_( long edgePointer, boolean reverse, long flags )
     /**
      * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
      */
-    final int internalEdgeAdd( int newEdgeId, int fromNodeId, int toNodeId )
-    {
+    final int internalEdgeAdd(int newEdgeId, int fromNodeId, int toNodeId) {
         writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
         connectNewEdge(fromNodeId, newEdgeId);
         if (fromNodeId != toNodeId)
@@ -141,8 +130,7 @@ final int internalEdgeAdd( int newEdgeId, int fromNodeId, int toNodeId )
         return newEdgeId;
     }
 
-    final int getOtherNode( int nodeThis, long edgePointer )
-    {
+    final int getOtherNode(int nodeThis, long edgePointer) {
         int nodeA = edges.getInt(edgePointer + E_NODEA);
         if (nodeA == nodeThis)
             // return b
@@ -151,21 +139,17 @@ final int getOtherNode( int nodeThis, long edgePointer )
         return nodeA;
     }
 
-    private long _getLinkPosInEdgeArea( int nodeThis, int nodeOther, long edgePointer )
-    {
+    private long _getLinkPosInEdgeArea(int nodeThis, int nodeOther, long edgePointer) {
         return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
     }
 
-    final int getEdgeRef( int nodeThis, int nodeOther, long edgePointer )
-    {
+    final int getEdgeRef(int nodeThis, int nodeOther, long edgePointer) {
         return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
     }
 
-    final void connectNewEdge( int fromNode, int newOrExistingEdge )
-    {
+    final void connectNewEdge(int fromNode, int newOrExistingEdge) {
         int edge = getEdgeRef(fromNode);
-        if (edge > EdgeIterator.NO_EDGE)
-        {
+        if (edge > EdgeIterator.NO_EDGE) {
             long edgePointer = toPointer(newOrExistingEdge);
             int otherNode = getOtherNode(fromNode, edgePointer);
             long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
@@ -174,10 +158,8 @@ final void connectNewEdge( int fromNode, int newOrExistingEdge )
         setEdgeRef(fromNode, newOrExistingEdge);
     }
 
-    final long writeEdge( int edgeId, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther )
-    {
-        if (nodeThis > nodeOther)
-        {
+    final long writeEdge(int edgeId, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther) {
+        if (nodeThis > nodeOther) {
             int tmp = nodeThis;
             nodeThis = nodeOther;
             nodeOther = tmp;
@@ -200,20 +182,18 @@ final long writeEdge( int edgeId, int nodeThis, int nodeOther, int nextEdge, int
      * This method disconnects the specified edge from the list of edges of the specified node. It
      * does not release the freed space to be reused.
      * <p>
+     *
      * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
-     * of nodes
+     *                            of nodes
      */
-    final long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode )
-    {
+    final long internalEdgeDisconnect(int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode) {
         long edgeToRemovePointer = toPointer(edgeToRemove);
         // an edge is shared across the two nodes even if the edge is not in both directions
         // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
         int nextEdgeId = getEdgeRef(baseNode, adjNode, edgeToRemovePointer);
-        if (edgeToUpdatePointer < 0)
-        {
+        if (edgeToUpdatePointer < 0) {
             setEdgeRef(baseNode, nextEdgeId);
-        } else
-        {
+        } else {
             // adjNode is different for the edge we want to update with the new link
             long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
                     ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
@@ -222,8 +202,7 @@ final long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, i
         return edgeToRemovePointer;
     }
 
-    final EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
-    {
+    final EdgeIteratorState getEdgeProps(int edgeId, int adjNode) {
         if (edgeId <= EdgeIterator.NO_EDGE)
             throw new IllegalStateException("edgeId invalid " + edgeId + ", " + this);
 
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index d6e0ea8d5d..5d289bd544 100755
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -28,18 +28,17 @@
 /**
  * Implements some common methods for the subclasses.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHDirectory implements Directory
-{
-    protected Map<String, DataAccess> map = new HashMap<String, DataAccess>();
-    protected Map<String, DAType> types = new HashMap<String, DAType>();
+public class GHDirectory implements Directory {
     protected final String location;
     private final DAType defaultType;
     private final ByteOrder byteOrder = ByteOrder.LITTLE_ENDIAN;
+    protected Map<String, DataAccess> map = new HashMap<String, DataAccess>();
+    protected Map<String, DAType> types = new HashMap<String, DAType>();
 
-    public GHDirectory( String _location, DAType defaultType )
-    {
+    public GHDirectory(String _location, DAType defaultType) {
         this.defaultType = defaultType;
         if (Helper.isEmpty(_location))
             _location = new File("").getAbsolutePath();
@@ -54,15 +53,12 @@ public GHDirectory( String _location, DAType defaultType )
 
         // set default access to integer based
         // improves performance on server side, 10% faster for queries and preparation
-        if (this.defaultType.isInMemory())
-        {
-            if (isStoring())
-            {
+        if (this.defaultType.isInMemory()) {
+            if (isStoring()) {
                 put("location_index", DAType.RAM_INT_STORE);
                 put("edges", DAType.RAM_INT_STORE);
                 put("nodes", DAType.RAM_INT_STORE);
-            } else
-            {
+            } else {
                 put("location_index", DAType.RAM_INT);
                 put("edges", DAType.RAM_INT);
                 put("nodes", DAType.RAM_INT);
@@ -71,13 +67,11 @@ public GHDirectory( String _location, DAType defaultType )
     }
 
     @Override
-    public ByteOrder getByteOrder()
-    {
+    public ByteOrder getByteOrder() {
         return byteOrder;
     }
 
-    public Directory put( String name, DAType type )
-    {
+    public Directory put(String name, DAType type) {
         if (!name.equals(name.toLowerCase()))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
@@ -86,8 +80,7 @@ public Directory put( String name, DAType type )
     }
 
     @Override
-    public DataAccess find( String name )
-    {
+    public DataAccess find(String name) {
         DAType type = types.get(name);
         if (type == null)
             type = defaultType;
@@ -96,24 +89,20 @@ public DataAccess find( String name )
     }
 
     @Override
-    public DataAccess find( String name, DAType type )
-    {
+    public DataAccess find(String name, DAType type) {
         if (!name.equals(name.toLowerCase()))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
         DataAccess da = map.get(name);
-        if (da != null)
-        {
+        if (da != null) {
             if (!type.equals(da.getType()))
                 throw new IllegalStateException("Found existing DataAccess object '" + name
                         + "' but types did not match. Requested:" + type + ", was:" + da.getType());
             return da;
         }
 
-        if (type.isInMemory())
-        {
-            if (type.isInteg())
-            {
+        if (type.isInMemory()) {
+            if (type.isInteg()) {
                 if (type.isStoring())
                     da = new RAMIntDataAccess(name, location, true, byteOrder);
                 else
@@ -122,11 +111,9 @@ public DataAccess find( String name, DAType type )
                 da = new RAMDataAccess(name, location, true, byteOrder);
             else
                 da = new RAMDataAccess(name, location, false, byteOrder);
-        } else if (type.isMMap())
-        {
+        } else if (type.isMMap()) {
             da = new MMapDataAccess(name, location, byteOrder, type.isAllowWrites());
-        } else
-        {
+        } else {
             da = new UnsafeDataAccess(name, location, byteOrder);
         }
 
@@ -138,15 +125,13 @@ public DataAccess find( String name, DAType type )
     }
 
     @Override
-    public void clear()
-    {
+    public void clear() {
         // If there is at least one MMap DA then do not apply the cleanHack 
         // for every single mmap DA as this is very slow if lots of DataAccess objects were collected 
         // => forceClean == false
 
         MMapDataAccess mmapDA = null;
-        for (DataAccess da : map.values())
-        {
+        for (DataAccess da : map.values()) {
             if (da instanceof MMapDataAccess)
                 mmapDA = (MMapDataAccess) da;
 
@@ -158,14 +143,12 @@ public void clear()
     }
 
     @Override
-    public void remove( DataAccess da )
-    {
+    public void remove(DataAccess da) {
         removeFromMap(da.getName());
         removeDA(da, da.getName(), true);
     }
 
-    void removeDA( DataAccess da, String name, boolean forceClean )
-    {
+    void removeDA(DataAccess da, String name, boolean forceClean) {
         if (da instanceof MMapDataAccess)
             ((MMapDataAccess) da).close(forceClean);
         else
@@ -175,47 +158,40 @@ void removeDA( DataAccess da, String name, boolean forceClean )
             Helper.removeDir(new File(location + name));
     }
 
-    void removeFromMap( String name )
-    {
+    void removeFromMap(String name) {
         DataAccess da = map.remove(name);
         if (da == null)
             throw new IllegalStateException("Couldn't remove dataAccess object:" + name);
     }
 
     @Override
-    public DAType getDefaultType()
-    {
+    public DAType getDefaultType() {
         return defaultType;
     }
 
-    public boolean isStoring()
-    {
+    public boolean isStoring() {
         return defaultType.isStoring();
     }
 
     @Override
-    public Directory create()
-    {
+    public Directory create() {
         if (isStoring())
             new File(location).mkdirs();
         return this;
     }
 
     @Override
-    public Collection<DataAccess> getAll()
-    {
+    public Collection<DataAccess> getAll() {
         return map.values();
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getLocation();
     }
 
     @Override
-    public String getLocation()
-    {
+    public String getLocation() {
         return location;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index e3eabb896e..19c4615d39 100755
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -22,47 +22,41 @@
 /**
  * A helper class for GraphHopperStorage for its node access.
  * <p>
+ *
  * @author Peter Karich
  */
-class GHNodeAccess implements NodeAccess
-{
+class GHNodeAccess implements NodeAccess {
     private final BaseGraph that;
     private final boolean elevation;
 
-    public GHNodeAccess( BaseGraph that, boolean withElevation )
-    {
+    public GHNodeAccess(BaseGraph that, boolean withElevation) {
         this.that = that;
         this.elevation = withElevation;
     }
 
     @Override
-    public void ensureNode( int nodeId )
-    {
+    public void ensureNode(int nodeId) {
         that.ensureNodeIndex(nodeId);
     }
 
     @Override
-    public final void setNode( int nodeId, double lat, double lon )
-    {
+    public final void setNode(int nodeId, double lat, double lon) {
         setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public final void setNode( int nodeId, double lat, double lon, double ele )
-    {
+    public final void setNode(int nodeId, double lat, double lon, double ele) {
         that.ensureNodeIndex(nodeId);
         long tmp = (long) nodeId * that.nodeEntryBytes;
         that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
         that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
 
-        if (is3D())
-        {
+        if (is3D()) {
             // meter precision is sufficient for now
             that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
             that.bounds.update(lat, lon, ele);
 
-        } else
-        {
+        } else {
             that.bounds.update(lat, lon);
         }
 
@@ -72,20 +66,17 @@ public final void setNode( int nodeId, double lat, double lon, double ele )
     }
 
     @Override
-    public final double getLatitude( int nodeId )
-    {
+    public final double getLatitude(int nodeId) {
         return Helper.intToDegree(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_LAT));
     }
 
     @Override
-    public final double getLongitude( int nodeId )
-    {
+    public final double getLongitude(int nodeId) {
         return Helper.intToDegree(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_LON));
     }
 
     @Override
-    public final double getElevation( int nodeId )
-    {
+    public final double getElevation(int nodeId) {
         if (!elevation)
             throw new IllegalStateException("Cannot access elevation - 3D is not enabled");
 
@@ -93,40 +84,33 @@ public final double getElevation( int nodeId )
     }
 
     @Override
-    public final double getEle( int nodeId )
-    {
+    public final double getEle(int nodeId) {
         return getElevation(nodeId);
     }
 
     @Override
-    public final double getLat( int nodeId )
-    {
+    public final double getLat(int nodeId) {
         return getLatitude(nodeId);
     }
 
     @Override
-    public final double getLon( int nodeId )
-    {
+    public final double getLon(int nodeId) {
         return getLongitude(nodeId);
     }
 
     @Override
-    public final void setAdditionalNodeField( int index, int additionalValue )
-    {
-        if (that.extStorage.isRequireNodeField() && that.N_ADDITIONAL >= 0)
-        {
+    public final void setAdditionalNodeField(int index, int additionalValue) {
+        if (that.extStorage.isRequireNodeField() && that.N_ADDITIONAL >= 0) {
             that.ensureNodeIndex(index);
             long tmp = (long) index * that.nodeEntryBytes;
             that.nodes.setInt(tmp + that.N_ADDITIONAL, additionalValue);
-        } else
-        {
+        } else {
             throw new AssertionError("This graph does not provide an additional node field");
         }
     }
 
     @Override
-    public final int getAdditionalNodeField( int index )
-    {
+    public final int getAdditionalNodeField(int index) {
         if (that.extStorage.isRequireNodeField() && that.N_ADDITIONAL >= 0)
             return that.nodes.getInt((long) index * that.nodeEntryBytes + that.N_ADDITIONAL);
         else
@@ -134,14 +118,12 @@ public final int getAdditionalNodeField( int index )
     }
 
     @Override
-    public final boolean is3D()
-    {
+    public final boolean is3D() {
         return elevation;
     }
 
     @Override
-    public int getDimension()
-    {
+    public int getDimension() {
         if (elevation)
             return 3;
         return 2;
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 60ce33fb19..36f25f837c 100755
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -17,8 +17,8 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.shapes.BBox;
@@ -27,10 +27,10 @@
  * An interface to represent a (geo) graph - suited for efficient storage as it can be requested via
  * indices called node IDs. To get the lat,lon point you need to set up a LocationIndex instance.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Graph
-{
+public interface Graph {
     /**
      * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
      * Dijkstra or any graph traversal algorithm can be executed.
@@ -56,27 +56,29 @@
      * Creates an edge between the nodes a and b. To set distance or access use the returned edge
      * and e.g. edgeState.setDistance
      * <p>
+     *
      * @param a the index of the starting (tower) node of the edge
      * @param b the index of the ending (tower) node of the edge
      * @return the newly created edge
      */
-    EdgeIteratorState edge( int a, int b );
+    EdgeIteratorState edge(int a, int b);
 
     /**
      * Use edge(a,b).setDistance().setFlags instead
      */
-    EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections );
+    EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections);
 
     /**
      * Returns a wrapper over the specified edgeId.
      * <p>
+     *
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
-     * Integer.MIN_VALUE then the edge with uncertain values for adjNode and baseNode (two
-     * possibilities) will be returned.
+     *                Integer.MIN_VALUE then the edge with uncertain values for adjNode and baseNode (two
+     *                possibilities) will be returned.
      * @return an edge iterator state or potentially null if adjNode does not match
      * @throws IllegalStateException if edgeId is not valid
      */
-    EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode );
+    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode);
 
     /**
      * @return all edges in this graph, where baseNode will be the smaller node.
@@ -88,10 +90,11 @@
      * node. Reduce calling this method as much as possible, e.g. create an explorer before a for
      * loop!
      * <p>
+     *
      * @see EdgeExplorer
      * @see Graph#createEdgeExplorer()
      */
-    EdgeExplorer createEdgeExplorer( EdgeFilter filter );
+    EdgeExplorer createEdgeExplorer(EdgeFilter filter);
 
     /**
      * @see Graph#createEdgeExplorer(com.graphhopper.routing.util.EdgeFilter)
@@ -101,9 +104,10 @@
     /**
      * Copy this Graph into the specified Graph g.
      * <p>
+     *
      * @return the specified Graph g
      */
-    Graph copyTo( Graph g );
+    Graph copyTo(Graph g);
 
     /**
      * @return the graph extension like a TurnCostExtension
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index fa7e96ec95..00693d2dca 100755
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -18,16 +18,17 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.Weighting;
+
 import java.util.Arrays;
 
 /**
  * For now this is just a helper class to quickly create a GraphStorage.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GraphBuilder
-{
+public class GraphBuilder {
     private final EncodingManager encodingManager;
     private String location;
     private boolean mmap;
@@ -36,60 +37,51 @@
     private long byteCapacity = 100;
     private Weighting singleCHWeighting;
 
-    public GraphBuilder( EncodingManager encodingManager )
-    {
+    public GraphBuilder(EncodingManager encodingManager) {
         this.encodingManager = encodingManager;
     }
 
     /**
      * This method enables creating a CHGraph with the specified weighting.
      */
-    public GraphBuilder setCHGraph( Weighting singleCHWeighting )
-    {
+    public GraphBuilder setCHGraph(Weighting singleCHWeighting) {
         this.singleCHWeighting = singleCHWeighting;
         return this;
     }
 
-    public GraphBuilder setLocation( String location )
-    {
+    public GraphBuilder setLocation(String location) {
         this.location = location;
         return this;
     }
 
-    public GraphBuilder setStore( boolean store )
-    {
+    public GraphBuilder setStore(boolean store) {
         this.store = store;
         return this;
     }
 
-    public GraphBuilder setMmap( boolean mmap )
-    {
+    public GraphBuilder setMmap(boolean mmap) {
         this.mmap = mmap;
         return this;
     }
 
-    public GraphBuilder setExpectedSize( byte cap )
-    {
+    public GraphBuilder setExpectedSize(byte cap) {
         this.byteCapacity = cap;
         return this;
     }
 
-    public GraphBuilder set3D( boolean withElevation )
-    {
+    public GraphBuilder set3D(boolean withElevation) {
         this.elevation = withElevation;
         return this;
     }
 
-    public boolean hasElevation()
-    {
+    public boolean hasElevation() {
         return elevation;
     }
 
     /**
      * Creates a CHGraph
      */
-    public CHGraph chGraphCreate( Weighting singleCHWeighting )
-    {
+    public CHGraph chGraphCreate(Weighting singleCHWeighting) {
         return setCHGraph(singleCHWeighting).create().getGraph(CHGraph.class, singleCHWeighting);
     }
 
@@ -98,8 +90,7 @@ public CHGraph chGraphCreate( Weighting singleCHWeighting )
      * Afterwards you'll need to call GraphStorage. Create to have a usable object. Better use
      * create.
      */
-    public GraphHopperStorage build()
-    {
+    public GraphHopperStorage build() {
         Directory dir;
         if (mmap)
             dir = new MMapDirectory(location);
@@ -118,19 +109,16 @@ public GraphHopperStorage build()
     /**
      * Default graph is a GraphStorage with an in memory directory and disabled storing on flush.
      */
-    public GraphHopperStorage create()
-    {
+    public GraphHopperStorage create() {
         return build().create(byteCapacity);
     }
 
     /**
      * @throws IllegalStateException if not loadable.
      */
-    public GraphHopperStorage load()
-    {
+    public GraphHopperStorage load() {
         GraphHopperStorage gs = build();
-        if (!gs.loadExisting())
-        {
+        if (!gs.loadExisting()) {
             throw new IllegalStateException("Cannot load graph " + location);
         }
         return gs;
diff --git a/core/src/main/java/com/graphhopper/storage/GraphExtension.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
index a8dec4bba5..08aacbf05a 100755
--- a/core/src/main/java/com/graphhopper/storage/GraphExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,8 +21,7 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface GraphExtension extends Storable<GraphExtension>
-{
+public interface GraphExtension extends Storable<GraphExtension> {
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
      */
@@ -46,109 +45,94 @@
     /**
      * initializes the extended storage by giving the base graph
      */
-    void init( Graph graph, Directory dir );
+    void init(Graph graph, Directory dir);
 
     /**
      * sets the segment size in all additional data storages
      */
-    void setSegmentSize( int bytes );
+    void setSegmentSize(int bytes);
 
     /**
      * creates a copy of this extended storage
      */
-    GraphExtension copyTo( GraphExtension extStorage );
+    GraphExtension copyTo(GraphExtension extStorage);
 
     /**
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    class NoOpExtension implements GraphExtension
-    {
+    class NoOpExtension implements GraphExtension {
 
         @Override
-        public boolean isRequireNodeField()
-        {
+        public boolean isRequireNodeField() {
             return false;
         }
 
         @Override
-        public boolean isRequireEdgeField()
-        {
+        public boolean isRequireEdgeField() {
             return false;
         }
 
         @Override
-        public int getDefaultNodeFieldValue()
-        {
+        public int getDefaultNodeFieldValue() {
             return 0;
         }
 
         @Override
-        public int getDefaultEdgeFieldValue()
-        {
+        public int getDefaultEdgeFieldValue() {
             return 0;
         }
 
         @Override
-        public void init( Graph graph, Directory dir )
-        {
+        public void init(Graph graph, Directory dir) {
             // noop
         }
 
         @Override
-        public GraphExtension create( long byteCount )
-        {
+        public GraphExtension create(long byteCount) {
             // noop
             return this;
         }
 
         @Override
-        public boolean loadExisting()
-        {
+        public boolean loadExisting() {
             // noop
             return true;
         }
 
         @Override
-        public void setSegmentSize( int bytes )
-        {
+        public void setSegmentSize(int bytes) {
             // noop
         }
 
         @Override
-        public void flush()
-        {
+        public void flush() {
             // noop
         }
 
         @Override
-        public void close()
-        {
+        public void close() {
             // noop
         }
 
         @Override
-        public long getCapacity()
-        {
+        public long getCapacity() {
             return 0;
         }
 
         @Override
-        public GraphExtension copyTo( GraphExtension extStorage )
-        {
+        public GraphExtension copyTo(GraphExtension extStorage) {
             // noop
             return extStorage;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return "NoExt";
         }
 
         @Override
-        public boolean isClosed()
-        {
+        public boolean isClosed() {
             return false;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 60f848a7d5..e472d92716 100755
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -32,12 +36,12 @@
  * different traversal methods. By default this class implements the graph interface and results in
  * identical behavior as the Graph instance from getGraph(Graph.class)
  * <p>
+ *
  * @author Peter Karich
  * @see GraphBuilder to create a (CH)Graph easier
  * @see #getGraph(java.lang.Class)
  */
-public final class GraphHopperStorage implements GraphStorage, Graph
-{
+public final class GraphHopperStorage implements GraphStorage, Graph {
     private final Directory dir;
     private final EncodingManager encodingManager;
     private final StorableProperties properties;
@@ -45,14 +49,12 @@
     // same flush order etc
     private final Collection<CHGraphImpl> chGraphs = new ArrayList<CHGraphImpl>(5);
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage )
-    {
+    public GraphHopperStorage(Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
         this(Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
     }
 
-    public GraphHopperStorage( List<? extends Weighting> chWeightings, Directory dir, final EncodingManager encodingManager,
-                               boolean withElevation, GraphExtension extendedStorage )
-    {
+    public GraphHopperStorage(List<? extends Weighting> chWeightings, Directory dir, final EncodingManager encodingManager,
+                              boolean withElevation, GraphExtension extendedStorage) {
         if (extendedStorage == null)
             throw new IllegalArgumentException("GraphExtension cannot be null, use NoOpExtension");
 
@@ -62,30 +64,24 @@ public GraphHopperStorage( List<? extends Weighting> chWeightings, Directory dir
         this.encodingManager = encodingManager;
         this.dir = dir;
         this.properties = new StorableProperties(dir);
-        InternalGraphEventListener listener = new InternalGraphEventListener()
-        {
+        InternalGraphEventListener listener = new InternalGraphEventListener() {
             @Override
-            public void initStorage()
-            {
-                for (CHGraphImpl cg : chGraphs)
-                {
+            public void initStorage() {
+                for (CHGraphImpl cg : chGraphs) {
                     cg.initStorage();
                 }
             }
 
             @Override
-            public void freeze()
-            {
-                for (CHGraphImpl cg : chGraphs)
-                {
+            public void freeze() {
+                for (CHGraphImpl cg : chGraphs) {
                     cg._freeze();
                 }
             }
         };
 
         this.baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
-        for (Weighting w : chWeightings)
-        {
+        for (Weighting w : chWeightings) {
             chGraphs.add(new CHGraphImpl(w, dir, this.baseGraph));
         }
     }
@@ -94,8 +90,7 @@ public void freeze()
      * This method returns the routing graph for the specified weighting, could be potentially
      * filled with shortcuts.
      */
-    public <T extends Graph> T getGraph( Class<T> clazz, Weighting weighting )
-    {
+    public <T extends Graph> T getGraph(Class<T> clazz, Weighting weighting) {
         if (clazz.equals(Graph.class))
             return (T) baseGraph;
 
@@ -106,8 +101,7 @@ public void freeze()
             throw new IllegalStateException("Cannot find CHGraph with null weighting");
 
         List<Weighting> existing = new ArrayList<Weighting>();
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             if (cg.getWeighting() == weighting)
                 return (T) cg;
 
@@ -117,8 +111,7 @@ public void freeze()
         throw new IllegalStateException("Cannot find CHGraph for specified weighting: " + weighting + ", existing:" + existing);
     }
 
-    public <T extends Graph> T getGraph( Class<T> clazz )
-    {
+    public <T extends Graph> T getGraph(Class<T> clazz) {
         if (clazz.equals(Graph.class))
             return (T) baseGraph;
 
@@ -129,16 +122,13 @@ public void freeze()
         return (T) cg;
     }
 
-    public boolean isCHPossible()
-    {
+    public boolean isCHPossible() {
         return !chGraphs.isEmpty();
     }
 
-    public List<Weighting> getCHWeightings()
-    {
+    public List<Weighting> getCHWeightings() {
         List<Weighting> list = new ArrayList<Weighting>(chGraphs.size());
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             list.add(cg.getWeighting());
         }
         return list;
@@ -148,18 +138,15 @@ public boolean isCHPossible()
      * @return the directory where this graph is stored.
      */
     @Override
-    public Directory getDirectory()
-    {
+    public Directory getDirectory() {
         return dir;
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
         baseGraph.setSegmentSize(bytes);
 
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             cg.setSegmentSize(bytes);
         }
     }
@@ -168,8 +155,7 @@ public void setSegmentSize( int bytes )
      * After configuring this storage you need to create it explicitly.
      */
     @Override
-    public GraphHopperStorage create( long byteCount )
-    {
+    public GraphHopperStorage create(long byteCount) {
         baseGraph.checkInit();
         if (encodingManager == null)
             throw new IllegalStateException("EncodingManager can only be null if you call loadExisting");
@@ -187,8 +173,7 @@ public GraphHopperStorage create( long byteCount )
 
         baseGraph.create(initSize);
 
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             cg.create(byteCount);
         }
 
@@ -197,37 +182,31 @@ public GraphHopperStorage create( long byteCount )
     }
 
     @Override
-    public EncodingManager getEncodingManager()
-    {
+    public EncodingManager getEncodingManager() {
         return encodingManager;
     }
 
     @Override
-    public StorableProperties getProperties()
-    {
+    public StorableProperties getProperties() {
         return properties;
     }
 
-    public void setAdditionalEdgeField( long edgePointer, int value )
-    {
+    public void setAdditionalEdgeField(long edgePointer, int value) {
         baseGraph.setAdditionalEdgeField(edgePointer, value);
     }
 
     @Override
-    public void markNodeRemoved( int index )
-    {
+    public void markNodeRemoved(int index) {
         baseGraph.getRemovedNodes().add(index);
     }
 
     @Override
-    public boolean isNodeRemoved( int index )
-    {
+    public boolean isNodeRemoved(int index) {
         return baseGraph.getRemovedNodes().contains(index);
     }
 
     @Override
-    public void optimize()
-    {
+    public void optimize() {
         if (isFrozen())
             throw new IllegalStateException("do not optimize after graph was frozen");
 
@@ -244,17 +223,14 @@ public void optimize()
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         baseGraph.checkInit();
-        if (properties.loadExisting())
-        {
+        if (properties.loadExisting()) {
             properties.checkVersions(false);
             // check encoding for compatiblity
             String flagEncodersStr = properties.get("graph.flag_encoders");
 
-            if (!flagEncodersStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(flagEncodersStr))
-            {
+            if (!flagEncodersStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(flagEncodersStr)) {
                 throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
                         + "\nGraph: " + flagEncodersStr + ", dir:" + dir.getLocation());
             }
@@ -275,8 +251,7 @@ public boolean loadExisting()
             if (!loadedCHWeightings.equals(configuredCHWeightings))
                 throw new IllegalStateException("Configured graph.ch.weightings: " + configuredCHWeightings + " is not equal to loaded " + loadedCHWeightings);
 
-            for (CHGraphImpl cg : chGraphs)
-            {
+            for (CHGraphImpl cg : chGraphs) {
                 if (!cg.loadExisting())
                     throw new IllegalStateException("Cannot load " + cg);
             }
@@ -287,10 +262,8 @@ public boolean loadExisting()
     }
 
     @Override
-    public void flush()
-    {
-        for (CHGraphImpl cg : chGraphs)
-        {
+    public void flush() {
+        for (CHGraphImpl cg : chGraphs) {
             cg.setEdgesHeader();
             cg.flush();
         }
@@ -300,30 +273,25 @@ public void flush()
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         properties.close();
         baseGraph.close();
 
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             cg.close();
         }
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return baseGraph.nodes.isClosed();
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         long cnt = baseGraph.getCapacity() + properties.getCapacity();
 
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             cnt += cg.getCapacity();
         }
         return cnt;
@@ -333,23 +301,19 @@ public long getCapacity()
      * Avoid that edges and nodes of the base graph are further modified. Necessary as hook for e.g.
      * ch graphs on top to initilize themself
      */
-    public synchronized void freeze()
-    {
+    public synchronized void freeze() {
         if (!baseGraph.isFrozen())
             baseGraph.freeze();
     }
 
-    boolean isFrozen()
-    {
+    boolean isFrozen() {
         return baseGraph.isFrozen();
     }
 
     @Override
-    public String toDetailsString()
-    {
+    public String toDetailsString() {
         String str = baseGraph.toDetailsString();
-        for (CHGraphImpl cg : chGraphs)
-        {
+        for (CHGraphImpl cg : chGraphs) {
             str += ", " + cg.toDetailsString();
         }
 
@@ -357,8 +321,7 @@ public String toDetailsString()
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return (isCHPossible() ? "CH|" : "")
                 + encodingManager
                 + "|" + getDirectory().getDefaultType()
@@ -372,74 +335,62 @@ public String toString()
     // Graph g = storage.getGraph(Graph.class);
     // instead directly the storage can be used to traverse the base graph
     @Override
-    public Graph getBaseGraph()
-    {
+    public Graph getBaseGraph() {
         return baseGraph;
     }
 
     @Override
-    public int getNodes()
-    {
+    public int getNodes() {
         return baseGraph.getNodes();
     }
 
     @Override
-    public NodeAccess getNodeAccess()
-    {
+    public NodeAccess getNodeAccess() {
         return baseGraph.getNodeAccess();
     }
 
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return baseGraph.getBounds();
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b )
-    {
+    public EdgeIteratorState edge(int a, int b) {
         return baseGraph.edge(a, b);
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
-    {
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
         return baseGraph.edge(a, b, distance, bothDirections);
     }
 
     @Override
-    public EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
-    {
+    public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
         return baseGraph.getEdgeIteratorState(edgeId, adjNode);
     }
 
     @Override
-    public AllEdgesIterator getAllEdges()
-    {
+    public AllEdgesIterator getAllEdges() {
         return baseGraph.getAllEdges();
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
-    {
+    public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
         return baseGraph.createEdgeExplorer(filter);
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer()
-    {
+    public EdgeExplorer createEdgeExplorer() {
         return baseGraph.createEdgeExplorer();
     }
 
     @Override
-    public Graph copyTo( Graph g )
-    {
+    public Graph copyTo(Graph g) {
         return baseGraph.copyTo(g);
     }
 
     @Override
-    public GraphExtension getExtension()
-    {
+    public GraphExtension getExtension() {
         return baseGraph.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage.java b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
index 6ce014f5c2..0a7b947ae4 100755
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
@@ -19,13 +19,12 @@
 
 import com.graphhopper.routing.util.EncodingManager;
 
-public interface GraphStorage extends Storable<GraphStorage>
-{
+public interface GraphStorage extends Storable<GraphStorage> {
     Directory getDirectory();
 
     EncodingManager getEncodingManager();
 
-    void setSegmentSize( int bytes );
+    void setSegmentSize(int bytes);
 
     String toDetailsString();
 
@@ -34,12 +33,12 @@
     /**
      * Schedule the deletion of the specified node until an optimize() call happens
      */
-    void markNodeRemoved( int index );
+    void markNodeRemoved(int index);
 
     /**
      * Checks if the specified node is marked as removed.
      */
-    boolean isNodeRemoved( int index );
+    boolean isNodeRemoved(int index);
 
     /**
      * Performs optimization routines like deletion or node rearrangements.
diff --git a/core/src/main/java/com/graphhopper/storage/IntIterator.java b/core/src/main/java/com/graphhopper/storage/IntIterator.java
index 87883f44de..a5f260d771 100755
--- a/core/src/main/java/com/graphhopper/storage/IntIterator.java
+++ b/core/src/main/java/com/graphhopper/storage/IntIterator.java
@@ -20,21 +20,17 @@
 /**
  * @author Peter Karich
  */
-public interface IntIterator
-{
+public interface IntIterator {
     boolean next();
 
     int getValue();
 
     void remove();
 
-    class Helper
-    {
-        public static int count( IntIterator iter )
-        {
+    class Helper {
+        public static int count(IntIterator iter) {
             int counter = 0;
-            while (iter.next())
-            {
+            while (iter.next()) {
                 ++counter;
             }
             return counter;
diff --git a/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
index ce1c2aefed..b8fc904992 100755
--- a/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
+++ b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
@@ -20,8 +20,7 @@
 /**
  * @author Peter Karich
  */
-public interface InternalGraphEventListener
-{
+public interface InternalGraphEventListener {
     void freeze();
 
     void initStorage();
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
index 9c95c71e38..85bfab65fc 100755
--- a/core/src/main/java/com/graphhopper/storage/Lock.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -20,10 +20,10 @@
 /**
  * A write lock. Influenced by Lucene code
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Lock
-{
+public interface Lock {
     String getName();
 
     boolean tryLock();
diff --git a/core/src/main/java/com/graphhopper/storage/LockFactory.java b/core/src/main/java/com/graphhopper/storage/LockFactory.java
index f114c5c8a8..b3fbe856f5 100755
--- a/core/src/main/java/com/graphhopper/storage/LockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/LockFactory.java
@@ -22,20 +22,19 @@
 /**
  * @author Peter Karich
  */
-public interface LockFactory
-{
-    void setLockDir( File lockDir );
+public interface LockFactory {
+    void setLockDir(File lockDir);
 
     /**
      * This creates a file for write or read locks depending on the specified writeAccess property.
      * Important note: even for read locks we need write access to the underlying filesystem in
      * order to avoid writes from other processes.
      */
-    Lock create( String fileName, boolean writeAccess );
+    Lock create(String fileName, boolean writeAccess);
 
     /**
      * Removes the specified lock. Note: on windows we cannot forcefully remove an unreleased native
      * lock
      */
-    void forceRemove( String fileName, boolean writeAccess );
+    void forceRemove(String fileName, boolean writeAccess);
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 9febc102e0..b4fb668aa9 100755
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -35,50 +35,42 @@
  * This is a data structure which uses the operating system to synchronize between disc and memory.
  * Use {@link SynchedDAWrapper} if you intent to use this from multiple threads!
  * <p>
+ *
  * @author Peter Karich
  */
 @NotThreadSafe
-public class MMapDataAccess extends AbstractDataAccess
-{
+public class MMapDataAccess extends AbstractDataAccess {
+    private final boolean allowWrites;
     private RandomAccessFile raFile;
     private List<ByteBuffer> segments = new ArrayList<ByteBuffer>();
     private boolean cleanAndRemap = false;
-    private final boolean allowWrites;
 
-    MMapDataAccess( String name, String location, ByteOrder order, boolean allowWrites )
-    {
+    MMapDataAccess(String name, String location, ByteOrder order, boolean allowWrites) {
         super(name, location, order);
         this.allowWrites = allowWrites;
     }
 
-    MMapDataAccess cleanAndRemap( boolean cleanAndRemap )
-    {
+    MMapDataAccess cleanAndRemap(boolean cleanAndRemap) {
         this.cleanAndRemap = cleanAndRemap;
         return this;
     }
 
-    private void initRandomAccessFile()
-    {
-        if (raFile != null)
-        {
+    private void initRandomAccessFile() {
+        if (raFile != null) {
             return;
         }
 
-        try
-        {
+        try {
             // raFile necessary for loadExisting and create
             raFile = new RandomAccessFile(getFullName(), allowWrites ? "rw" : "r");
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException(ex);
         }
     }
 
     @Override
-    public MMapDataAccess create( long bytes )
-    {
-        if (!segments.isEmpty())
-        {
+    public MMapDataAccess create(long bytes) {
+        if (!segments.isEmpty()) {
             throw new IllegalThreadStateException("already created");
         }
         initRandomAccessFile();
@@ -89,8 +81,7 @@ public MMapDataAccess create( long bytes )
     }
 
     @Override
-    public DataAccess copyTo( DataAccess da )
-    {
+    public DataAccess copyTo(DataAccess da) {
         // if(da instanceof MMapDataAccess) {
         // TODO PERFORMANCE make copying into mmap a lot faster via bytebuffer
         // also copying into RAMDataAccess could be faster via bytebuffer
@@ -100,13 +91,11 @@ public DataAccess copyTo( DataAccess da )
     }
 
     @Override
-    public boolean ensureCapacity( long bytes )
-    {
+    public boolean ensureCapacity(long bytes) {
         return mapIt(HEADER_OFFSET, bytes, true);
     }
 
-    protected boolean mapIt( long offset, long byteCount, boolean clearNew )
-    {
+    protected boolean mapIt(long offset, long byteCount, boolean clearNew) {
         if (byteCount < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
 
@@ -128,18 +117,15 @@ protected boolean mapIt( long offset, long byteCount, boolean clearNew )
         int newSegments;
         int i = 0;
         long newFileLength = offset + segmentsToMap * longSegmentSize;
-        try
-        {
+        try {
             // ugly remapping
             // http://stackoverflow.com/q/14011919/194609
-            if (cleanAndRemap)
-            {
+            if (cleanAndRemap) {
                 newSegments = segmentsToMap;
                 clean(0, segments.size());
                 Helper.cleanHack();
                 segments.clear();
-            } else
-            {
+            } else {
                 // This approach is probably problematic but a bit faster if done often.
                 // Here we rely on the OS+file system that increasing the file 
                 // size has no effect on the old mappings!
@@ -148,14 +134,12 @@ protected boolean mapIt( long offset, long byteCount, boolean clearNew )
             }
             // rely on automatically increasing when mapping
 //            raFile.setLength(newFileLength);
-            for (; i < newSegments; i++)
-            {
+            for (; i < newSegments; i++) {
                 segments.add(newByteBuffer(bufferStart, longSegmentSize));
                 bufferStart += longSegmentSize;
             }
             return true;
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             // we could get an exception here if buffer is too small and area too large
             // e.g. I got an exception for the 65421th buffer (probably around 2**16 == 65536)
             throw new RuntimeException("Couldn't map buffer " + i + " of " + segmentsToMap
@@ -164,40 +148,33 @@ protected boolean mapIt( long offset, long byteCount, boolean clearNew )
         }
     }
 
-    private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOException
-    {
+    private ByteBuffer newByteBuffer(long offset, long byteCount) throws IOException {
         // If we request a buffer larger than the file length, it will automatically increase the file length!
         // Will this cause problems? http://stackoverflow.com/q/14011919/194609
         // For trimTo we need to reset the file length later to reduce that size
         ByteBuffer buf = null;
         IOException ioex = null;
         // One retry if it fails. It could fail e.g. if previously buffer wasn't yet unmapped from the jvm
-        for (int trial = 0; trial < 1;)
-        {
-            try
-            {
+        for (int trial = 0; trial < 1;) {
+            try {
                 buf = raFile.getChannel().map(
                         allowWrites ? FileChannel.MapMode.READ_WRITE : FileChannel.MapMode.READ_ONLY,
                         offset, byteCount);
                 break;
-            } catch (IOException tmpex)
-            {
+            } catch (IOException tmpex) {
                 ioex = tmpex;
                 trial++;
                 Helper.cleanHack();
-                try
-                {
+                try {
                     // mini sleep to let JVM do unmapping
                     Thread.sleep(5);
-                } catch (InterruptedException iex)
-                {
+                } catch (InterruptedException iex) {
+                    throw new IOException(iex);
                 }
             }
         }
-        if (buf == null)
-        {
-            if (ioex == null)
-            {
+        if (buf == null) {
+            if (ioex == null) {
                 throw new AssertionError("internal problem as the exception 'ioex' shouldn't be null");
             }
             throw ioex;
@@ -206,16 +183,13 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         buf.order(byteOrder);
 
         boolean tmp = false;
-        if (tmp)
-        {
+        if (tmp) {
             int count = (int) (byteCount / EMPTY.length);
-            for (int i = 0; i < count; i++)
-            {
+            for (int i = 0; i < count; i++) {
                 buf.put(EMPTY);
             }
             int len = (int) (byteCount % EMPTY.length);
-            if (len > 0)
-            {
+            if (len > 0) {
                 buf.put(EMPTY, count * EMPTY.length, len);
             }
         }
@@ -223,8 +197,7 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (segments.size() > 0)
             throw new IllegalStateException("already initialized");
 
@@ -236,32 +209,26 @@ public boolean loadExisting()
             return false;
 
         initRandomAccessFile();
-        try
-        {
+        try {
             long byteCount = readHeader(raFile);
             if (byteCount < 0)
                 return false;
 
             mapIt(HEADER_OFFSET, byteCount - HEADER_OFFSET, false);
             return true;
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException("Problem while loading " + getFullName(), ex);
         }
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         if (isClosed())
             throw new IllegalStateException("already closed");
 
-        try
-        {
-            if (!segments.isEmpty() && segments.get(0) instanceof MappedByteBuffer)
-            {
-                for (ByteBuffer bb : segments)
-                {
+        try {
+            if (!segments.isEmpty() && segments.get(0) instanceof MappedByteBuffer) {
+                for (ByteBuffer bb : segments) {
                     ((MappedByteBuffer) bb).force();
                 }
             }
@@ -271,25 +238,22 @@ public void flush()
             // http://stackoverflow.com/q/14011398/194609
             raFile.getFD().sync();
             // equivalent to raFile.getChannel().force(true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         super.close();
         close(true);
     }
 
     /**
      * @param forceClean if true the clean hack (system.gc) will be executed and forces the system
-     * to cleanup the mmap resources. Set false if you need to close many MMapDataAccess objects.
+     *                   to cleanup the mmap resources. Set false if you need to close many MMapDataAccess objects.
      */
-    void close( boolean forceClean )
-    {
+    void close(boolean forceClean) {
         clean(0, segments.size());
         segments.clear();
         Helper.close(raFile);
@@ -298,40 +262,35 @@ void close( boolean forceClean )
     }
 
     @Override
-    public final void setInt( long bytePos, int value )
-    {
+    public final void setInt(long bytePos, int value) {
         int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         segments.get(bufferIndex).putInt(index, value);
     }
 
     @Override
-    public final int getInt( long bytePos )
-    {
+    public final int getInt(long bytePos) {
         int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         return segments.get(bufferIndex).getInt(index);
     }
 
     @Override
-    public final void setShort( long bytePos, short value )
-    {
+    public final void setShort(long bytePos, short value) {
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         segments.get(bufferIndex).putShort(index, value);
     }
 
     @Override
-    public final short getShort( long bytePos )
-    {
+    public final short getShort(long bytePos) {
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         return segments.get(bufferIndex).getShort(index);
     }
 
     @Override
-    public void setBytes( long bytePos, byte[] values, int length )
-    {
+    public void setBytes(long bytePos, byte[] values, int length) {
         assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
@@ -339,55 +298,47 @@ public void setBytes( long bytePos, byte[] values, int length )
         bb.position(index);
 
         int delta = index + length - segmentSizeInBytes;
-        if (delta > 0)
-        {
+        if (delta > 0) {
             length -= delta;
             bb.put(values, 0, length);
             bb = segments.get(bufferIndex + 1);
             bb.position(0);
             bb.put(values, length, delta);
-        } else
-        {
+        } else {
             bb.put(values, 0, length);
         }
     }
 
     @Override
-    public void getBytes( long bytePos, byte[] values, int length )
-    {
+    public void getBytes(long bytePos, byte[] values, int length) {
         assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         ByteBuffer bb = segments.get(bufferIndex);
         bb.position(index);
         int delta = index + length - segmentSizeInBytes;
-        if (delta > 0)
-        {
+        if (delta > 0) {
             length -= delta;
             bb.get(values, 0, length);
             bb = segments.get(bufferIndex + 1);
             bb.position(0);
             bb.get(values, length, delta);
-        } else
-        {
+        } else {
             bb.get(values, 0, length);
         }
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         long cap = 0;
-        for (ByteBuffer bb : segments)
-        {
+        for (ByteBuffer bb : segments) {
             cap += bb.capacity();
         }
         return cap;
     }
 
     @Override
-    public int getSegments()
-    {
+    public int getSegments() {
         return segments.size();
     }
 
@@ -395,13 +346,12 @@ public int getSegments()
      * Cleans up MappedByteBuffers. Be sure you bring the segments list in a consistent state
      * afterwards.
      * <p>
+     *
      * @param from inclusive
-     * @param to exclusive
+     * @param to   exclusive
      */
-    private void clean( int from, int to )
-    {
-        for (int i = from; i < to; i++)
-        {
+    private void clean(int from, int to) {
+        for (int i = from; i < to; i++) {
             ByteBuffer bb = segments.get(i);
             Helper.cleanMappedByteBuffer(bb);
             segments.set(i, null);
@@ -409,15 +359,12 @@ private void clean( int from, int to )
     }
 
     @Override
-    public void trimTo( long capacity )
-    {
-        if (capacity < segmentSizeInBytes)
-        {
+    public void trimTo(long capacity) {
+        if (capacity < segmentSizeInBytes) {
             capacity = segmentSizeInBytes;
         }
         int remainingSegNo = (int) (capacity / segmentSizeInBytes);
-        if (capacity % segmentSizeInBytes != 0)
-        {
+        if (capacity % segmentSizeInBytes != 0) {
             remainingSegNo++;
         }
 
@@ -425,25 +372,20 @@ public void trimTo( long capacity )
         Helper.cleanHack();
         segments = new ArrayList<ByteBuffer>(segments.subList(0, remainingSegNo));
 
-        try
-        {
+        try {
             // windows does not allow changing the length of an open files
-            if (!Constants.WINDOWS)
-            // reduce file size
-            {
+            if (!Constants.WINDOWS) {
+                // reduce file size
                 raFile.setLength(HEADER_OFFSET + remainingSegNo * segmentSizeInBytes);
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    boolean releaseSegment( int segNumber )
-    {
+    boolean releaseSegment(int segNumber) {
         ByteBuffer segment = segments.get(segNumber);
-        if (segment instanceof MappedByteBuffer)
-        {
+        if (segment instanceof MappedByteBuffer) {
             ((MappedByteBuffer) segment).force();
         }
 
@@ -454,10 +396,8 @@ boolean releaseSegment( int segNumber )
     }
 
     @Override
-    public void rename( String newName )
-    {
-        if (!checkBeforeRename(newName))
-        {
+    public void rename(String newName) {
+        if (!checkBeforeRename(newName)) {
             return;
         }
         close();
@@ -470,8 +410,7 @@ public void rename( String newName )
     }
 
     @Override
-    public DAType getType()
-    {
+    public DAType getType() {
         return DAType.MMAP;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
index aa4bb3995e..c50f11e830 100755
--- a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
@@ -20,20 +20,18 @@
 /**
  * Manages memory mapped DataAccess objects.
  * <p>
+ *
  * @author Peter Karich
  * @see MMapDataAccess
  */
-public class MMapDirectory extends GHDirectory
-{
+public class MMapDirectory extends GHDirectory {
     // reserve the empty constructor for direct mapped memory
-    private MMapDirectory()
-    {
+    private MMapDirectory() {
         this("");
         throw new IllegalStateException("reserved for direct mapped memory");
     }
 
-    public MMapDirectory( String _location )
-    {
+    public MMapDirectory(String _location) {
         super(_location, DAType.MMAP);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index dd7b61ebdd..5e7cc8ddd7 100755
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -28,30 +28,43 @@
 /**
  * Creates a write lock file. Influenced by Lucene code
  * <p>
+ *
  * @author Peter Karich
  */
-public class NativeFSLockFactory implements LockFactory
-{
+public class NativeFSLockFactory implements LockFactory {
     private File lockDir;
 
-    public NativeFSLockFactory()
-    {
+    public NativeFSLockFactory() {
     }
 
-    public NativeFSLockFactory( File dir )
-    {
+    public NativeFSLockFactory(File dir) {
         this.lockDir = dir;
     }
 
+    public static void main(String[] args) throws IOException {
+        // trying FileLock mechanics in different processes
+        File file = new File("tmp.lock");
+
+        file.createNewFile();
+        FileChannel channel = new RandomAccessFile(file, "r").getChannel();
+
+        boolean shared = true;
+        FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
+
+        System.out.println("locked " + lock1);
+        System.in.read();
+
+        System.out.println("release " + lock1);
+        lock1.release();
+    }
+
     @Override
-    public void setLockDir( File lockDir )
-    {
+    public void setLockDir(File lockDir) {
         this.lockDir = lockDir;
     }
 
     @Override
-    public synchronized Lock create( String fileName, boolean writeAccess )
-    {
+    public synchronized Lock create(String fileName, boolean writeAccess) {
         if (lockDir == null)
             throw new RuntimeException("Set lockDir before creating " + (writeAccess ? "write" : "read") + " locks");
 
@@ -59,10 +72,8 @@ public synchronized Lock create( String fileName, boolean writeAccess )
     }
 
     @Override
-    public synchronized void forceRemove( String fileName, boolean writeAccess )
-    {
-        if (lockDir.exists())
-        {
+    public synchronized void forceRemove(String fileName, boolean writeAccess) {
+        if (lockDir.exists()) {
             create(fileName, writeAccess).release();
             File lockFile = new File(lockDir, fileName);
             if (lockFile.exists() && !lockFile.delete())
@@ -70,21 +81,17 @@ public synchronized void forceRemove( String fileName, boolean writeAccess )
         }
     }
 
-    static class NativeLock implements Lock
-    {
-        private RandomAccessFile tmpRaFile;
-        private FileChannel tmpChannel;
-        private FileLock tmpLock;
-
+    static class NativeLock implements Lock {
         private final String name;
         private final File lockDir;
         private final File lockFile;
         private final boolean writeLock;
-
+        private RandomAccessFile tmpRaFile;
+        private FileChannel tmpChannel;
+        private FileLock tmpLock;
         private Exception failedReason;
 
-        public NativeLock( File lockDir, String fileName, boolean writeLock )
-        {
+        public NativeLock(File lockDir, String fileName, boolean writeLock) {
             this.name = fileName;
             this.lockDir = lockDir;
             this.lockFile = new File(lockDir, fileName);
@@ -92,15 +99,13 @@ public NativeLock( File lockDir, String fileName, boolean writeLock )
         }
 
         @Override
-        public synchronized boolean tryLock()
-        {
+        public synchronized boolean tryLock() {
             // already locked
             if (lockExists())
                 return false;
 
             // on-the-fly: make sure directory exists
-            if (!lockDir.exists())
-            {
+            if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
                     throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
             }
@@ -108,39 +113,30 @@ public synchronized boolean tryLock()
             if (!lockDir.isDirectory())
                 throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
 
-            try
-            {
+            try {
                 failedReason = null;
                 // we need write access even for read locks - in order to create the lock file!
                 tmpRaFile = new RandomAccessFile(lockFile, "rw");
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 failedReason = ex;
                 return false;
             }
 
-            try
-            {
+            try {
                 tmpChannel = tmpRaFile.getChannel();
-                try
-                {
+                try {
                     tmpLock = tmpChannel.tryLock(0, Long.MAX_VALUE, !writeLock);
                     // OverlappingFileLockException is not an IOException!
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     failedReason = ex;
-                } finally
-                {
-                    if (tmpLock == null)
-                    {
+                } finally {
+                    if (tmpLock == null) {
                         Helper.close(tmpChannel);
                         tmpChannel = null;
                     }
                 }
-            } finally
-            {
-                if (tmpChannel == null)
-                {
+            } finally {
+                if (tmpChannel == null) {
                     Helper.close(tmpRaFile);
                     tmpRaFile = null;
                 }
@@ -148,64 +144,49 @@ public synchronized boolean tryLock()
             return lockExists();
         }
 
-        private synchronized boolean lockExists()
-        {
+        private synchronized boolean lockExists() {
             return tmpLock != null;
         }
 
         @Override
-        public synchronized boolean isLocked()
-        {
+        public synchronized boolean isLocked() {
             if (!lockFile.exists())
                 return false;
 
             if (lockExists())
                 return true;
 
-            try
-            {
+            try {
                 boolean obtained = tryLock();
                 if (obtained)
                     release();
                 return !obtained;
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 return false;
             }
         }
 
         @Override
-        public synchronized void release()
-        {
-            if (lockExists())
-            {
-                try
-                {
+        public synchronized void release() {
+            if (lockExists()) {
+                try {
                     failedReason = null;
                     tmpLock.release();
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     throw new RuntimeException(ex);
-                } finally
-                {
+                } finally {
                     tmpLock = null;
-                    try
-                    {
+                    try {
                         tmpChannel.close();
-                    } catch (Exception ex)
-                    {
+                    } catch (Exception ex) {
                         throw new RuntimeException(ex);
-                    } finally
-                    {
+                    } finally {
                         tmpChannel = null;
-                        try
-                        {
+                        try {
                             tmpRaFile.close();
-                        } catch (Exception ex)
-                        {
+                        } catch (Exception ex) {
                             throw new RuntimeException(ex);
-                        } finally
-                        {
+                        } finally {
                             tmpRaFile = null;
                         }
                     }
@@ -215,39 +196,18 @@ public synchronized void release()
         }
 
         @Override
-        public String getName()
-        {
+        public String getName() {
             return name;
         }
 
         @Override
-        public Exception getObtainFailedReason()
-        {
+        public Exception getObtainFailedReason() {
             return failedReason;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return lockFile.toString();
         }
     }
-
-    public static void main( String[] args ) throws IOException
-    {
-        // trying FileLock mechanics in different processes
-        File file = new File("tmp.lock");
-
-        file.createNewFile();
-        FileChannel channel = new RandomAccessFile(file, "r").getChannel();
-
-        boolean shared = true;
-        FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
-
-        System.out.println("locked " + lock1);
-        System.in.read();
-
-        System.out.println("release " + lock1);
-        lock1.release();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
index d5996f3c79..83d632544b 100755
--- a/core/src/main/java/com/graphhopper/storage/NodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -24,22 +24,23 @@
  * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
  * for an additional iterator.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface NodeAccess extends PointAccess
-{
+public interface NodeAccess extends PointAccess {
     /**
      * @return the additional value at the specified node index
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
-     * node field
+     *                        node field
      */
-    int getAdditionalNodeField( int nodeId );
+    int getAdditionalNodeField(int nodeId);
 
     /**
      * Sets the additional value at the specified node index
      * <p>
+     *
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
-     * node field
+     *                        node field
      */
-    void setAdditionalNodeField( int nodeId, int additionalValue );
+    void setAdditionalNodeField(int nodeId, int additionalValue);
 }
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index e877ed0960..9c312104ee 100755
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -17,27 +17,26 @@
  */
 package com.graphhopper.storage;
 
+import org.slf4j.LoggerFactory;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteOrder;
 import java.util.Arrays;
 
-import org.slf4j.LoggerFactory;
-
 /**
  * This is an in-memory byte-based data structure with the possibility to be stored on flush().
  * Thread safe.
  * <p>
+ *
  * @author Peter Karich
  */
-public class RAMDataAccess extends AbstractDataAccess
-{
+public class RAMDataAccess extends AbstractDataAccess {
     private byte[][] segments = new byte[0][];
     private boolean store;
 
-    RAMDataAccess( String name, String location, boolean store, ByteOrder order )
-    {
+    RAMDataAccess(String name, String location, boolean store, ByteOrder order) {
         super(name, location, order);
         this.store = store;
     }
@@ -45,44 +44,37 @@
     /**
      * @param store true if in-memory data should be saved when calling flush
      */
-    public RAMDataAccess store( boolean store )
-    {
+    public RAMDataAccess store(boolean store) {
         this.store = store;
         return this;
     }
 
     @Override
-    public boolean isStoring()
-    {
+    public boolean isStoring() {
         return store;
     }
 
     @Override
-    public DataAccess copyTo( DataAccess da )
-    {
-        if (da instanceof RAMDataAccess)
-        {
+    public DataAccess copyTo(DataAccess da) {
+        if (da instanceof RAMDataAccess) {
             copyHeader(da);
             RAMDataAccess rda = (RAMDataAccess) da;
             // TODO PERFORMANCE we could reuse rda segments!
             rda.segments = new byte[segments.length][];
-            for (int i = 0; i < segments.length; i++)
-            {
+            for (int i = 0; i < segments.length; i++) {
                 byte[] area = segments[i];
                 rda.segments[i] = Arrays.copyOf(area, area.length);
             }
             rda.setSegmentSize(segmentSizeInBytes);
             // leave id, store and close unchanged
             return da;
-        } else
-        {
+        } else {
             return super.copyTo(da);
         }
     }
 
     @Override
-    public RAMDataAccess create( long bytes )
-    {
+    public RAMDataAccess create(long bytes) {
         if (segments.length > 0)
             throw new IllegalThreadStateException("already created");
 
@@ -93,8 +85,7 @@ public RAMDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity( long bytes )
-    {
+    public boolean ensureCapacity(long bytes) {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
 
@@ -107,16 +98,13 @@ public boolean ensureCapacity( long bytes )
         if (newBytes % segmentSizeInBytes != 0)
             segmentsToCreate++;
 
-        try
-        {
+        try {
             byte[][] newSegs = Arrays.copyOf(segments, segments.length + segmentsToCreate);
-            for (int i = segments.length; i < newSegs.length; i++)
-            {
+            for (int i = segments.length; i < newSegs.length; i++) {
                 newSegs[i] = new byte[1 << segmentSizePower];
             }
             segments = newSegs;
-        } catch (OutOfMemoryError err)
-        {
+        } catch (OutOfMemoryError err) {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
                     + cap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizePower
                     + ", new segments:" + segmentsToCreate + ", existing:" + segments.length);
@@ -125,8 +113,7 @@ public boolean ensureCapacity( long bytes )
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (segments.length > 0)
             throw new IllegalStateException("already initialized");
 
@@ -140,11 +127,9 @@ public boolean loadExisting()
         if (!file.exists() || file.length() == 0)
             return false;
 
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "r");
-            try
-            {
+            try {
                 long byteCount = readHeader(raFile) - HEADER_OFFSET;
                 if (byteCount < 0)
                     return false;
@@ -156,8 +141,7 @@ public boolean loadExisting()
                     segmentCount++;
 
                 segments = new byte[segmentCount][];
-                for (int s = 0; s < segmentCount; s++)
-                {
+                for (int s = 0; s < segmentCount; s++) {
                     byte[] bytes = new byte[segmentSizeInBytes];
                     int read = raFile.read(bytes);
                     if (read <= 0)
@@ -166,52 +150,43 @@ public boolean loadExisting()
                     segments[s] = bytes;
                 }
                 return true;
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException("Problem while loading " + getFullName(), ex);
         }
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         if (closed)
             throw new IllegalStateException("already closed");
 
         if (!store)
             return;
 
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "rw");
-            try
-            {
+            try {
                 long len = getCapacity();
                 writeHeader(raFile, len, segmentSizeInBytes);
                 raFile.seek(HEADER_OFFSET);
                 // raFile.writeInt() <- too slow, so copy into byte array
-                for (int s = 0; s < segments.length; s++)
-                {
+                for (int s = 0; s < segments.length; s++) {
                     byte area[] = segments[s];
                     raFile.write(area);
                 }
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Couldn't store bytes to " + toString(), ex);
         }
     }
 
     @Override
-    public final void setInt( long bytePos, int value )
-    {
+    public final void setInt(long bytePos, int value) {
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
@@ -220,14 +195,12 @@ public final void setInt( long bytePos, int value )
     }
 
     @Override
-    public final int getInt( long bytePos )
-    {
+    public final int getInt(long bytePos) {
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         assert index + 4 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
-        if (bufferIndex > segments.length)
-        {
+        if (bufferIndex > segments.length) {
             LoggerFactory.getLogger(getClass()).error(getName() + ", segments:" + segments.length
                     + ", bufIndex:" + bufferIndex + ", bytePos:" + bytePos
                     + ", segPower:" + segmentSizePower);
@@ -236,8 +209,7 @@ public final int getInt( long bytePos )
     }
 
     @Override
-    public final void setShort( long bytePos, short value )
-    {
+    public final void setShort(long bytePos, short value) {
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
@@ -246,8 +218,7 @@ public final void setShort( long bytePos, short value )
     }
 
     @Override
-    public final short getShort( long bytePos )
-    {
+    public final short getShort(long bytePos) {
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
@@ -256,72 +227,61 @@ public final short getShort( long bytePos )
     }
 
     @Override
-    public void setBytes( long bytePos, byte[] values, int length )
-    {
+    public void setBytes(long bytePos, byte[] values, int length) {
         assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         byte[] seg = segments[bufferIndex];
         int delta = index + length - segmentSizeInBytes;
-        if (delta > 0)
-        {
+        if (delta > 0) {
             length -= delta;
             System.arraycopy(values, 0, seg, index, length);
             seg = segments[bufferIndex + 1];
             System.arraycopy(values, length, seg, 0, delta);
-        } else
-        {
+        } else {
             System.arraycopy(values, 0, seg, index, length);
         }
     }
 
     @Override
-    public void getBytes( long bytePos, byte[] values, int length )
-    {
+    public void getBytes(long bytePos, byte[] values, int length) {
         assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
         assert segmentSizePower > 0 : "call create or loadExisting before usage!";
         int bufferIndex = (int) (bytePos >>> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         byte[] seg = segments[bufferIndex];
         int delta = index + length - segmentSizeInBytes;
-        if (delta > 0)
-        {
+        if (delta > 0) {
             length -= delta;
             System.arraycopy(seg, index, values, 0, length);
             seg = segments[bufferIndex + 1];
             System.arraycopy(seg, 0, values, length, delta);
-        } else
-        {
+        } else {
             System.arraycopy(seg, index, values, 0, length);
         }
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         super.close();
         segments = new byte[0][];
         closed = true;
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return (long) getSegments() * segmentSizeInBytes;
     }
 
     @Override
-    public int getSegments()
-    {
+    public int getSegments() {
         return segments.length;
     }
 
     @Override
-    public void trimTo( long capacity )
-    {
-        if (capacity > getCapacity())
-        {
+    public void trimTo(long capacity) {
+        if (capacity > getCapacity()) {
             throw new IllegalStateException("Cannot increase capacity (" + getCapacity() + ") to " + capacity
                     + " via trimTo. Use ensureCapacity instead. ");
         }
@@ -330,8 +290,7 @@ public void trimTo( long capacity )
             capacity = segmentSizeInBytes;
 
         int remainingSegments = (int) (capacity / segmentSizeInBytes);
-        if (capacity % segmentSizeInBytes != 0)
-        {
+        if (capacity % segmentSizeInBytes != 0) {
             remainingSegments++;
         }
 
@@ -339,14 +298,11 @@ public void trimTo( long capacity )
     }
 
     @Override
-    public void rename( String newName )
-    {
-        if (!checkBeforeRename(newName))
-        {
+    public void rename(String newName) {
+        if (!checkBeforeRename(newName)) {
             return;
         }
-        if (store)
-        {
+        if (store) {
             super.rename(newName);
         }
 
@@ -355,8 +311,7 @@ public void rename( String newName )
     }
 
     @Override
-    public DAType getType()
-    {
+    public DAType getType() {
         if (isStoring())
             return DAType.RAM_STORE;
         return DAType.RAM;
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
index 2daac01da6..c41e2c7e33 100755
--- a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
@@ -20,28 +20,25 @@
 /**
  * Manages in-memory DataAccess objects.
  * <p>
+ *
  * @author Peter Karich
  * @see RAMDataAccess
  * @see RAMIntDataAccess
  */
-public class RAMDirectory extends GHDirectory
-{
-    public RAMDirectory()
-    {
+public class RAMDirectory extends GHDirectory {
+    public RAMDirectory() {
         this("", false);
     }
 
-    public RAMDirectory( String location )
-    {
+    public RAMDirectory(String location) {
         this(location, false);
     }
 
     /**
      * @param store true if you want that the RAMDirectory can be loaded or saved on demand, false
-     * if it should be entirely in RAM
+     *              if it should be entirely in RAM
      */
-    public RAMDirectory( String _location, boolean store )
-    {
+    public RAMDirectory(String _location, boolean store) {
         super(_location, store ? DAType.RAM_STORE : DAType.RAM);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index 43c7bf9dda..bacca7eb4c 100755
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -27,17 +27,16 @@
  * This is an in-memory data structure based on an integer array. With the possibility to be stored
  * on flush().
  * <p>
+ *
  * @author Peter Karich
  */
-class RAMIntDataAccess extends AbstractDataAccess
-{
+class RAMIntDataAccess extends AbstractDataAccess {
     private int[][] segments = new int[0][];
     private boolean closed = false;
     private boolean store;
     private transient int segmentSizeIntsPower;
 
-    RAMIntDataAccess( String name, String location, boolean store, ByteOrder order )
-    {
+    RAMIntDataAccess(String name, String location, boolean store, ByteOrder order) {
         super(name, location, order);
         this.store = store;
     }
@@ -45,46 +44,38 @@
     /**
      * @param store true if in-memory data should be saved when calling flush
      */
-    public RAMIntDataAccess setStore( boolean store )
-    {
+    public RAMIntDataAccess setStore(boolean store) {
         this.store = store;
         return this;
     }
 
     @Override
-    public boolean isStoring()
-    {
+    public boolean isStoring() {
         return store;
     }
 
     @Override
-    public DataAccess copyTo( DataAccess da )
-    {
-        if (da instanceof RAMIntDataAccess)
-        {
+    public DataAccess copyTo(DataAccess da) {
+        if (da instanceof RAMIntDataAccess) {
             copyHeader(da);
             RAMIntDataAccess rda = (RAMIntDataAccess) da;
             // TODO PERFORMANCE we could reuse rda segments!
             rda.segments = new int[segments.length][];
-            for (int i = 0; i < segments.length; i++)
-            {
+            for (int i = 0; i < segments.length; i++) {
                 int[] area = segments[i];
                 rda.segments[i] = Arrays.copyOf(area, area.length);
             }
             rda.setSegmentSize(segmentSizeInBytes);
             // leave id, store and close unchanged
             return da;
-        } else
-        {
+        } else {
             return super.copyTo(da);
         }
     }
 
     @Override
-    public RAMIntDataAccess create( long bytes )
-    {
-        if (segments.length > 0)
-        {
+    public RAMIntDataAccess create(long bytes) {
+        if (segments.length > 0) {
             throw new IllegalThreadStateException("already created");
         }
 
@@ -95,8 +86,7 @@ public RAMIntDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity( long bytes )
-    {
+    public boolean ensureCapacity(long bytes) {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
 
@@ -109,17 +99,14 @@ public boolean ensureCapacity( long bytes )
         if (newBytes % segmentSizeInBytes != 0)
             segmentsToCreate++;
 
-        try
-        {
+        try {
             int[][] newSegs = Arrays.copyOf(segments, segments.length + segmentsToCreate);
-            for (int i = segments.length; i < newSegs.length; i++)
-            {
+            for (int i = segments.length; i < newSegs.length; i++) {
                 newSegs[i] = new int[1 << segmentSizeIntsPower];
             }
             segments = newSegs;
             return true;
-        } catch (OutOfMemoryError err)
-        {
+        } catch (OutOfMemoryError err) {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
                     + cap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizeIntsPower
                     + ", new segments:" + segmentsToCreate + ", existing:" + segments.length);
@@ -127,8 +114,7 @@ public boolean ensureCapacity( long bytes )
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (segments.length > 0)
             throw new IllegalStateException("already initialized");
 
@@ -139,18 +125,14 @@ public boolean loadExisting()
             return false;
 
         File file = new File(getFullName());
-        if (!file.exists() || file.length() == 0)
-        {
+        if (!file.exists() || file.length() == 0) {
             return false;
         }
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "r");
-            try
-            {
+            try {
                 long byteCount = readHeader(raFile) - HEADER_OFFSET;
-                if (byteCount < 0)
-                {
+                if (byteCount < 0) {
                     return false;
                 }
                 byte[] bytes = new byte[segmentSizeInBytes];
@@ -161,71 +143,57 @@ public boolean loadExisting()
                     segmentCount++;
 
                 segments = new int[segmentCount][];
-                for (int s = 0; s < segmentCount; s++)
-                {
+                for (int s = 0; s < segmentCount; s++) {
                     int read = raFile.read(bytes) / 4;
                     int area[] = new int[read];
-                    for (int j = 0; j < read; j++)
-                    {
+                    for (int j = 0; j < read; j++) {
                         area[j] = bitUtil.toInt(bytes, j * 4);
                     }
                     segments[s] = area;
                 }
                 return true;
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException("Problem while loading " + getFullName(), ex);
         }
     }
 
     @Override
-    public void flush()
-    {
-        if (closed)
-        {
+    public void flush() {
+        if (closed) {
             throw new IllegalStateException("already closed");
         }
-        if (!store)
-        {
+        if (!store) {
             return;
         }
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "rw");
-            try
-            {
+            try {
                 long len = getCapacity();
                 writeHeader(raFile, len, segmentSizeInBytes);
                 raFile.seek(HEADER_OFFSET);
                 // raFile.writeInt() <- too slow, so copy into byte array
-                for (int s = 0; s < segments.length; s++)
-                {
+                for (int s = 0; s < segments.length; s++) {
                     int area[] = segments[s];
                     int intLen = area.length;
                     byte[] byteArea = new byte[intLen * 4];
-                    for (int i = 0; i < intLen; i++)
-                    {
+                    for (int i = 0; i < intLen; i++) {
                         bitUtil.fromInt(byteArea, area[i], i * 4);
                     }
                     raFile.write(byteArea);
                 }
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Couldn't store integers to " + toString(), ex);
         }
     }
 
     @Override
-    public final void setInt( long bytePos, int value )
-    {
+    public final void setInt(long bytePos, int value) {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
         bytePos >>>= 2;
         int bufferIndex = (int) (bytePos >>> segmentSizeIntsPower);
@@ -234,8 +202,7 @@ public final void setInt( long bytePos, int value )
     }
 
     @Override
-    public final int getInt( long bytePos )
-    {
+    public final int getInt(long bytePos) {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
         bytePos >>>= 2;
         int bufferIndex = (int) (bytePos >>> segmentSizeIntsPower);
@@ -244,8 +211,7 @@ public final int getInt( long bytePos )
     }
 
     @Override
-    public final void setShort( long bytePos, short value )
-    {
+    public final void setShort(long bytePos, short value) {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
         if (bytePos % 4 != 0 && bytePos % 4 != 2)
             throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
@@ -260,8 +226,7 @@ public final void setShort( long bytePos, short value )
     }
 
     @Override
-    public final short getShort( long bytePos )
-    {
+    public final short getShort(long bytePos) {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
         if (bytePos % 4 != 0 && bytePos % 4 != 2)
             throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
@@ -276,40 +241,34 @@ public final short getShort( long bytePos )
     }
 
     @Override
-    public void getBytes( long bytePos, byte[] values, int length )
-    {
+    public void getBytes(long bytePos, byte[] values, int length) {
         throw new UnsupportedOperationException(toString() + " does not support byte based acccess. Use RAMDataAccess instead");
     }
 
     @Override
-    public void setBytes( long bytePos, byte[] values, int length )
-    {
+    public void setBytes(long bytePos, byte[] values, int length) {
         throw new UnsupportedOperationException(toString() + " does not support byte based acccess. Use RAMDataAccess instead");
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         super.close();
         segments = new int[0][];
         closed = true;
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return (long) getSegments() * segmentSizeInBytes;
     }
 
     @Override
-    public int getSegments()
-    {
+    public int getSegments() {
         return segments.length;
     }
 
     @Override
-    public DataAccess setSegmentSize( int bytes )
-    {
+    public DataAccess setSegmentSize(int bytes) {
         super.setSegmentSize(bytes);
         segmentSizeIntsPower = (int) (Math.log(segmentSizeInBytes / 4) / Math.log(2));
         indexDivisor = segmentSizeInBytes / 4 - 1;
@@ -317,36 +276,29 @@ public DataAccess setSegmentSize( int bytes )
     }
 
     @Override
-    public void trimTo( long capacity )
-    {
-        if (capacity < segmentSizeInBytes)
-        {
+    public void trimTo(long capacity) {
+        if (capacity < segmentSizeInBytes) {
             capacity = segmentSizeInBytes;
         }
         int remainingSegments = (int) (capacity / segmentSizeInBytes);
-        if (capacity % segmentSizeInBytes != 0)
-        {
+        if (capacity % segmentSizeInBytes != 0) {
             remainingSegments++;
         }
 
         segments = Arrays.copyOf(segments, remainingSegments);
     }
 
-    boolean releaseSegment( int segNumber )
-    {
+    boolean releaseSegment(int segNumber) {
         segments[segNumber] = null;
         return true;
     }
 
     @Override
-    public void rename( String newName )
-    {
-        if (!checkBeforeRename(newName))
-        {
+    public void rename(String newName) {
+        if (!checkBeforeRename(newName)) {
             return;
         }
-        if (store)
-        {
+        if (store) {
             super.rename(newName);
         }
 
@@ -355,14 +307,12 @@ public void rename( String newName )
     }
 
     @Override
-    protected boolean isIntBased()
-    {
+    protected boolean isIntBased() {
         return true;
     }
 
     @Override
-    public DAType getType()
-    {
+    public DAType getType() {
         if (isStoring())
             return DAType.RAM_INT_STORE;
         return DAType.RAM_INT;
diff --git a/core/src/main/java/com/graphhopper/storage/SPTEntry.java b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
index db055bb75a..daaac4bcf8 100755
--- a/core/src/main/java/com/graphhopper/storage/SPTEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
@@ -20,17 +20,16 @@
 /**
  * This class is used to create the shortest-path-tree from linked entities.
  * <p>
+ *
  * @author Peter Karich
  */
-public class SPTEntry implements Cloneable, Comparable<SPTEntry>
-{
+public class SPTEntry implements Cloneable, Comparable<SPTEntry> {
     public int edge;
     public int adjNode;
     public double weight;
     public SPTEntry parent;
 
-    public SPTEntry( int edgeId, int adjNode, double weight )
-    {
+    public SPTEntry(int edgeId, int adjNode, double weight) {
         this.edge = edgeId;
         this.adjNode = adjNode;
         this.weight = weight;
@@ -41,24 +40,20 @@ public SPTEntry( int edgeId, int adjNode, double weight )
      * destination for the backward SPT. Where the variable 'weight' is used to let heap select
      * smallest *full* weight (from start to destination).
      */
-    public double getWeightOfVisitedPath()
-    {
+    public double getWeightOfVisitedPath() {
         return weight;
     }
 
     @Override
-    public SPTEntry clone()
-    {
+    public SPTEntry clone() {
         return new SPTEntry(edge, adjNode, weight);
     }
 
-    public SPTEntry cloneFull()
-    {
+    public SPTEntry cloneFull() {
         SPTEntry de = clone();
         SPTEntry tmpPrev = parent;
         SPTEntry cl = de;
-        while (tmpPrev != null)
-        {
+        while (tmpPrev != null) {
             cl.parent = tmpPrev.clone();
             cl = cl.parent;
             tmpPrev = tmpPrev.parent;
@@ -67,8 +62,7 @@ public SPTEntry cloneFull()
     }
 
     @Override
-    public int compareTo( SPTEntry o )
-    {
+    public int compareTo(SPTEntry o) {
         if (weight < o.weight)
             return -1;
 
@@ -77,8 +71,7 @@ public int compareTo( SPTEntry o )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return adjNode + " (" + edge + ") weight: " + weight;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 616ff29175..82f1491f29 100755
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -23,30 +23,26 @@
 /**
  * Creates a write lock file. Influenced by Lucene code
  * <p>
+ *
  * @author Peter Karich
  */
-public class SimpleFSLockFactory implements LockFactory
-{
+public class SimpleFSLockFactory implements LockFactory {
     private File lockDir;
 
-    public SimpleFSLockFactory()
-    {
+    public SimpleFSLockFactory() {
     }
 
-    public SimpleFSLockFactory( File dir )
-    {
+    public SimpleFSLockFactory(File dir) {
         this.lockDir = dir;
     }
 
     @Override
-    public void setLockDir( File lockDir )
-    {
+    public void setLockDir(File lockDir) {
         this.lockDir = lockDir;
     }
 
     @Override
-    public synchronized Lock create( String fileName, boolean writeAccess )
-    {
+    public synchronized Lock create(String fileName, boolean writeAccess) {
         // TODO no read access-only support
         if (lockDir == null)
             throw new RuntimeException("Set lockDir before creating locks");
@@ -55,36 +51,30 @@ public synchronized Lock create( String fileName, boolean writeAccess )
     }
 
     @Override
-    public synchronized void forceRemove( String fileName, boolean writeAccess )
-    {
-        if (lockDir.exists())
-        {
+    public synchronized void forceRemove(String fileName, boolean writeAccess) {
+        if (lockDir.exists()) {
             File lockFile = new File(lockDir, fileName);
             if (lockFile.exists() && !lockFile.delete())
                 throw new RuntimeException("Cannot delete " + lockFile);
         }
     }
 
-    static class SimpleLock implements Lock
-    {
+    static class SimpleLock implements Lock {
         private final File lockDir;
         private final File lockFile;
         private final String name;
         private IOException failedReason;
 
-        public SimpleLock( File lockDir, String fileName )
-        {
+        public SimpleLock(File lockDir, String fileName) {
             this.name = fileName;
             this.lockDir = lockDir;
             this.lockFile = new File(lockDir, fileName);
         }
 
         @Override
-        public synchronized boolean tryLock()
-        {
+        public synchronized boolean tryLock() {
             // make sure directory exists, do it on-the-fly (not possible when setLockDir is called)
-            if (!lockDir.exists())
-            {
+            if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
                     throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
             }
@@ -93,44 +83,37 @@ public synchronized boolean tryLock()
             if (!lockDir.isDirectory())
                 throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
 
-            try
-            {
+            try {
                 return lockFile.createNewFile();
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 failedReason = ex;
                 return false;
             }
         }
 
         @Override
-        public synchronized boolean isLocked()
-        {
+        public synchronized boolean isLocked() {
             return lockFile.exists();
         }
 
         @Override
-        public synchronized void release()
-        {
+        public synchronized void release() {
             if (isLocked() && lockFile.exists() && !lockFile.delete())
                 throw new RuntimeException("Cannot release lock file: " + lockFile);
         }
 
         @Override
-        public String getName()
-        {
+        public String getName() {
             return name;
         }
 
         @Override
-        public synchronized Exception getObtainFailedReason()
-        {
+        public synchronized Exception getObtainFailedReason() {
             return failedReason;
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return lockFile.toString();
         }
     }
diff --git a/core/src/main/java/com/graphhopper/storage/Storable.java b/core/src/main/java/com/graphhopper/storage/Storable.java
index eff623ad8c..ae1014cd8d 100755
--- a/core/src/main/java/com/graphhopper/storage/Storable.java
+++ b/core/src/main/java/com/graphhopper/storage/Storable.java
@@ -34,10 +34,10 @@
  * <li>Finally do close() which does no flush()</li>
  * </ol>
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Storable<T> extends Closeable
-{
+public interface Storable<T> extends Closeable {
     /**
      * @return true if successfully loaded from persistent storage.
      */
@@ -46,7 +46,7 @@
     /**
      * Creates the underlying storage. First operation if it cannot be loaded.
      */
-    T create( long byteCount );
+    T create(long byteCount);
 
     /**
      * This method makes sure that the underlying data is written to the storage. Keep in mind that
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index a05b4f8136..71597910a1 100755
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -27,66 +27,61 @@
 import java.util.Map;
 
 /**
- * Writes an in-memory HashMap into a file on flush.
- * <p>
+ * Writes an in-memory HashMap into a file on flush. Thread safe, see #743.
+ *
  * @author Peter Karich
  */
-public class StorableProperties implements Storable<StorableProperties>
-{
-    private final Map<String, String> map = new LinkedHashMap<String, String>();
+public class StorableProperties implements Storable<StorableProperties> {
+    private final Map<String, String> map = new LinkedHashMap<>();
     private final DataAccess da;
 
-    public StorableProperties( Directory dir )
-    {
+    public StorableProperties(Directory dir) {
         this.da = dir.find("properties");
         // reduce size
         da.setSegmentSize(1 << 15);
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public synchronized boolean loadExisting() {
         if (!da.loadExisting())
             return false;
 
         int len = (int) da.getCapacity();
         byte[] bytes = new byte[len];
         da.getBytes(0, bytes, len);
-        try
-        {
+        try {
             Helper.loadProperties(map, new StringReader(new String(bytes, Helper.UTF_CS)));
             return true;
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new IllegalStateException(ex);
         }
     }
 
     @Override
-    public void flush()
-    {
-        try
-        {
+    public synchronized void flush() {
+        try {
             StringWriter sw = new StringWriter();
             Helper.saveProperties(map, sw);
             // TODO at the moment the size is limited to da.segmentSize() !
             byte[] bytes = sw.toString().getBytes(Helper.UTF_CS);
             da.setBytes(0, bytes, bytes.length);
             da.flush();
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    public StorableProperties remove( String key )
-    {
+    public synchronized StorableProperties remove(String key) {
         map.remove(key);
         return this;
     }
 
-    public StorableProperties put( String key, String val )
-    {
+    public synchronized StorableProperties putAll(Map<String, String> externMap) {
+        map.putAll(externMap);
+        return this;
+    }
+
+    public synchronized StorableProperties put(String key, String val) {
         map.put(key, val);
         return this;
     }
@@ -94,8 +89,7 @@ public StorableProperties put( String key, String val )
     /**
      * Before it saves this value it creates a string out of it.
      */
-    public StorableProperties put( String key, Object val )
-    {
+    public synchronized StorableProperties put(String key, Object val) {
         if (!key.equals(key.toLowerCase()))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
@@ -103,8 +97,7 @@ public StorableProperties put( String key, Object val )
         return this;
     }
 
-    public String get( String key )
-    {
+    public synchronized String get(String key) {
         if (!key.equals(key.toLowerCase()))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
@@ -116,32 +109,27 @@ public String get( String key )
     }
 
     @Override
-    public void close()
-    {
+    public synchronized void close() {
         da.close();
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public synchronized boolean isClosed() {
         return da.isClosed();
     }
 
     @Override
-    public StorableProperties create( long size )
-    {
+    public synchronized StorableProperties create(long size) {
         da.create(size);
         return this;
     }
 
     @Override
-    public long getCapacity()
-    {
+    public synchronized long getCapacity() {
         return da.getCapacity();
     }
 
-    public void putCurrentVersions()
-    {
+    public synchronized void putCurrentVersions() {
         put("nodes.version", Constants.VERSION_NODE);
         put("edges.version", Constants.VERSION_EDGE);
         put("geometry.version", Constants.VERSION_GEOMETRY);
@@ -150,8 +138,7 @@ public void putCurrentVersions()
         put("shortcuts.version", Constants.VERSION_SHORTCUT);
     }
 
-    public String versionsToString()
-    {
+    public synchronized String versionsToString() {
         return get("nodes.version") + ","
                 + get("edges.version") + ","
                 + get("geometry.version") + ","
@@ -159,8 +146,7 @@ public String versionsToString()
                 + get("name_index.version");
     }
 
-    public boolean checkVersions( boolean silent )
-    {
+    public synchronized boolean checkVersions(boolean silent) {
         if (!check("nodes", Constants.VERSION_NODE, silent))
             return false;
 
@@ -184,11 +170,9 @@ public boolean checkVersions( boolean silent )
         return true;
     }
 
-    boolean check( String key, int vers, boolean silent )
-    {
+    boolean check(String key, int vers, boolean silent) {
         String str = get(key + ".version");
-        if (!str.equals(vers + ""))
-        {
+        if (!str.equals(vers + "")) {
             if (silent)
                 return false;
 
@@ -199,16 +183,8 @@ boolean check( String key, int vers, boolean silent )
         return true;
     }
 
-    public void copyTo( StorableProperties properties )
-    {
-        properties.map.clear();
-        properties.map.putAll(map);
-        da.copyTo(properties.da);
-    }
-
     @Override
-    public String toString()
-    {
+    public synchronized String toString() {
         return da.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 7bc31d42be..0c257ce221 100755
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -20,154 +20,130 @@
 /**
  * A simple wrapper to synchronize every DataAccess object.
  * <p>
+ *
  * @author Peter Karich
  */
-class SynchedDAWrapper implements DataAccess
-{
+class SynchedDAWrapper implements DataAccess {
     private final DataAccess inner;
     private final DAType type;
 
-    public SynchedDAWrapper( DataAccess inner )
-    {
+    public SynchedDAWrapper(DataAccess inner) {
         this.inner = inner;
         this.type = new DAType(inner.getType(), true);
     }
 
     @Override
-    public synchronized String getName()
-    {
+    public synchronized String getName() {
         return inner.getName();
     }
 
     @Override
-    public synchronized void rename( String newName )
-    {
+    public synchronized void rename(String newName) {
         inner.rename(newName);
     }
 
     @Override
-    public synchronized void setInt( long bytePos, int value )
-    {
+    public synchronized void setInt(long bytePos, int value) {
         inner.setInt(bytePos, value);
     }
 
     @Override
-    public synchronized int getInt( long bytePos )
-    {
+    public synchronized int getInt(long bytePos) {
         return inner.getInt(bytePos);
     }
 
     @Override
-    public synchronized void setShort( long bytePos, short value )
-    {
+    public synchronized void setShort(long bytePos, short value) {
         inner.setShort(bytePos, value);
     }
 
     @Override
-    public synchronized short getShort( long bytePos )
-    {
+    public synchronized short getShort(long bytePos) {
         return inner.getShort(bytePos);
     }
 
     @Override
-    public synchronized void setBytes( long bytePos, byte[] values, int length )
-    {
+    public synchronized void setBytes(long bytePos, byte[] values, int length) {
         inner.setBytes(bytePos, values, length);
     }
 
     @Override
-    public synchronized void getBytes( long bytePos, byte[] values, int length )
-    {
+    public synchronized void getBytes(long bytePos, byte[] values, int length) {
         inner.getBytes(bytePos, values, length);
     }
 
     @Override
-    public synchronized void setHeader( int bytePos, int value )
-    {
+    public synchronized void setHeader(int bytePos, int value) {
         inner.setHeader(bytePos, value);
     }
 
     @Override
-    public synchronized int getHeader( int bytePos )
-    {
+    public synchronized int getHeader(int bytePos) {
         return inner.getHeader(bytePos);
     }
 
     @Override
-    public synchronized DataAccess create( long bytes )
-    {
+    public synchronized DataAccess create(long bytes) {
         return inner.create(bytes);
     }
 
     @Override
-    public synchronized boolean ensureCapacity( long bytes )
-    {
+    public synchronized boolean ensureCapacity(long bytes) {
         return inner.ensureCapacity(bytes);
     }
 
     @Override
-    public synchronized void trimTo( long bytes )
-    {
+    public synchronized void trimTo(long bytes) {
         inner.trimTo(bytes);
     }
 
     @Override
-    public synchronized DataAccess copyTo( DataAccess da )
-    {
+    public synchronized DataAccess copyTo(DataAccess da) {
         return inner.copyTo(da);
     }
 
     @Override
-    public synchronized DataAccess setSegmentSize( int bytes )
-    {
+    public synchronized DataAccess setSegmentSize(int bytes) {
         return inner.setSegmentSize(bytes);
     }
 
     @Override
-    public synchronized int getSegmentSize()
-    {
+    public synchronized int getSegmentSize() {
         return inner.getSegmentSize();
     }
 
     @Override
-    public synchronized int getSegments()
-    {
+    public synchronized int getSegments() {
         return inner.getSegments();
     }
 
     @Override
-    public synchronized boolean loadExisting()
-    {
+    public synchronized boolean loadExisting() {
         return inner.loadExisting();
     }
 
     @Override
-    public synchronized void flush()
-    {
+    public synchronized void flush() {
         inner.flush();
     }
 
     @Override
-    public synchronized void close()
-    {
+    public synchronized void close() {
         inner.close();
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return inner.isClosed();
     }
 
     @Override
-    public synchronized long getCapacity()
-    {
+    public synchronized long getCapacity() {
         return inner.getCapacity();
     }
 
     @Override
-    public DAType getType()
-    {
+    public DAType getType() {
         return type;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index a0cef3b3bd..6d66721be1 100755
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -24,11 +24,11 @@
  * towards the first entry within a node cost table to identify turn restrictions, or later, turn
  * getCosts.
  * <p>
+ *
  * @author Karl Hübner
  * @author Peter Karich
  */
-public class TurnCostExtension implements GraphExtension
-{
+public class TurnCostExtension implements GraphExtension {
     /* pointer for no cost entry */
     private static final int NO_TURN_ENTRY = -1;
     private static final long EMPTY_FLAGS = 0L;
@@ -45,8 +45,7 @@
     private int turnCostsCount;
     private NodeAccess nodeAccess;
 
-    public TurnCostExtension()
-    {
+    public TurnCostExtension() {
         TC_FROM = nextTurnCostEntryIndex();
         TC_TO = nextTurnCostEntryIndex();
         TC_FLAGS = nextTurnCostEntryIndex();
@@ -56,8 +55,7 @@ public TurnCostExtension()
     }
 
     @Override
-    public void init( Graph graph, Directory dir )
-    {
+    public void init(Graph graph, Directory dir) {
         if (turnCostsCount > 0)
             throw new AssertionError("The turn cost storage must be initialized only once.");
 
@@ -65,48 +63,41 @@ public void init( Graph graph, Directory dir )
         this.turnCosts = dir.find("turn_costs");
     }
 
-    private int nextTurnCostEntryIndex()
-    {
+    private int nextTurnCostEntryIndex() {
         turnCostsEntryIndex += 4;
         return turnCostsEntryIndex;
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
         turnCosts.setSegmentSize(bytes);
     }
 
     @Override
-    public TurnCostExtension create( long initBytes )
-    {
+    public TurnCostExtension create(long initBytes) {
         turnCosts.create((long) initBytes * turnCostsEntryBytes);
         return this;
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         turnCosts.setHeader(0, turnCostsEntryBytes);
         turnCosts.setHeader(1 * 4, turnCostsCount);
         turnCosts.flush();
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         turnCosts.close();
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return turnCosts.getCapacity();
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (!turnCosts.loadExisting())
             return false;
 
@@ -119,12 +110,11 @@ public boolean loadExisting()
      * This method adds a new entry which is a turn restriction or cost information via the
      * turnFlags.
      */
-    public void addTurnInfo( int fromEdge, int viaNode, int toEdge, long turnFlags )
-    {
+    public void addTurnInfo(int fromEdge, int viaNode, int toEdge, long turnFlags) {
         // no need to store turn information
         if (turnFlags == EMPTY_FLAGS)
             return;
-        
+
         // append
         int newEntryIndex = turnCostsCount;
         turnCostsCount++;
@@ -132,20 +122,16 @@ public void addTurnInfo( int fromEdge, int viaNode, int toEdge, long turnFlags )
 
         // determine if we already have an cost entry for this node
         int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
-        if (previousEntryIndex == NO_TURN_ENTRY)
-        {
+        if (previousEntryIndex == NO_TURN_ENTRY) {
             // set cost-pointer to this new cost entry
             nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);
-        } else
-        {
+        } else {
             int i = 0;
             int tmp = previousEntryIndex;
-            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_TURN_ENTRY)
-            {
+            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_TURN_ENTRY) {
                 previousEntryIndex = tmp;
                 // search for the last added cost entry
-                if (i++ > 1000)
-                {
+                if (i++ > 1000) {
                     throw new IllegalStateException("Something unexpected happened. A node probably will not have 1000+ relations.");
                 }
             }
@@ -164,8 +150,7 @@ public void addTurnInfo( int fromEdge, int viaNode, int toEdge, long turnFlags )
     /**
      * @return turn flags of the specified node and edge properties.
      */
-    public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
-    {
+    public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
             throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
         if (nodeVia < 0)
@@ -174,17 +159,14 @@ public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
         return nextCostFlags(edgeFrom, nodeVia, edgeTo);
     }
 
-    private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
-    {
+    private long nextCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
-        for (; i < 1000; i++)
-        {
+        for (; i < 1000; i++) {
             if (turnCostIndex == NO_TURN_ENTRY)
                 break;
             long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
-            if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM))
-            {
+            if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM)) {
                 if (edgeTo == turnCosts.getInt(turnCostPtr + TC_TO))
                     return turnCosts.getInt(turnCostPtr + TC_FLAGS);
             }
@@ -201,41 +183,34 @@ private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
         return EMPTY_FLAGS;
     }
 
-    private void ensureTurnCostIndex( int nodeIndex )
-    {
+    private void ensureTurnCostIndex(int nodeIndex) {
         turnCosts.ensureCapacity(((long) nodeIndex + 4) * turnCostsEntryBytes);
     }
 
     @Override
-    public boolean isRequireNodeField()
-    {
+    public boolean isRequireNodeField() {
         //we require the additional field in the graph to point to the first entry in the node table
         return true;
     }
 
     @Override
-    public boolean isRequireEdgeField()
-    {
+    public boolean isRequireEdgeField() {
         return false;
     }
 
     @Override
-    public int getDefaultNodeFieldValue()
-    {
+    public int getDefaultNodeFieldValue() {
         return NO_TURN_ENTRY;
     }
 
     @Override
-    public int getDefaultEdgeFieldValue()
-    {
+    public int getDefaultEdgeFieldValue() {
         throw new UnsupportedOperationException("Not supported by this storage");
     }
 
     @Override
-    public GraphExtension copyTo( GraphExtension clonedStorage )
-    {
-        if (!(clonedStorage instanceof TurnCostExtension))
-        {
+    public GraphExtension copyTo(GraphExtension clonedStorage) {
+        if (!(clonedStorage instanceof TurnCostExtension)) {
             throw new IllegalStateException("the extended storage to clone must be the same");
         }
 
@@ -248,14 +223,12 @@ public GraphExtension copyTo( GraphExtension clonedStorage )
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return turnCosts.isClosed();
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "turn_cost";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index 915ffa996f..9383362247 100755
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -36,26 +36,23 @@
  * <p>
  * 3. Cannot be used on Android as no memory allocation methods are available there
  * <p>
+ *
  * @author Peter Karich
  */
 @NotThreadSafe
-public class UnsafeDataAccess extends AbstractDataAccess
-{
+public class UnsafeDataAccess extends AbstractDataAccess {
     @SuppressWarnings("all")
     static final sun.misc.Unsafe UNSAFE;
 
-    static
-    {
-        try
-        {
+    static {
+        try {
             // On Android getting Unsafe fails as the field is named THE_ONE but Android has no memory allocation methods so it won't work nevertheless.
             // On Android we need JNI+malloc https://github.com/libgdx/libgdx/blob/5945211a88570ced7eafce95c68f6f1f7124cd23/gdx/src/com/badlogic/gdx/utils/BufferUtils.java#L287
             @SuppressWarnings("all")
             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
             field.setAccessible(true);
             UNSAFE = (sun.misc.Unsafe) field.get(null);
-        } catch (Exception e)
-        {
+        } catch (Exception e) {
             throw new AssertionError(e);
         }
     }
@@ -63,14 +60,12 @@
     private long address;
     private long capacity;
 
-    UnsafeDataAccess( String name, String location, ByteOrder order )
-    {
+    UnsafeDataAccess(String name, String location, ByteOrder order) {
         super(name, location, order);
     }
 
     @Override
-    public UnsafeDataAccess create( long bytes )
-    {
+    public UnsafeDataAccess create(long bytes) {
         // TODO use unsafe.pageSize() instead segmentSizeInBytes?
         // e.g. on my system pageSize is only 4096
         setSegmentSize(segmentSizeInBytes);
@@ -79,13 +74,11 @@ public UnsafeDataAccess create( long bytes )
     }
 
     @Override
-    public final boolean ensureCapacity( long bytes )
-    {
+    public final boolean ensureCapacity(long bytes) {
         return ensureCapacity(bytes, true);
     }
 
-    final boolean ensureCapacity( long bytes, boolean clearNewMem )
-    {
+    final boolean ensureCapacity(long bytes, boolean clearNewMem) {
         long oldCap = getCapacity();
         long newBytes = bytes - oldCap;
         if (newBytes <= 0)
@@ -97,11 +90,9 @@ final boolean ensureCapacity( long bytes, boolean clearNewMem )
             allSegments++;
         capacity = allSegments * segmentSizeInBytes;
 
-        try
-        {
+        try {
             address = UNSAFE.reallocateMemory(address, capacity);
-        } catch (OutOfMemoryError err)
-        {
+        } catch (OutOfMemoryError err) {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
                     + oldCap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizePower);
         }
@@ -112,10 +103,8 @@ final boolean ensureCapacity( long bytes, boolean clearNewMem )
     }
 
     @Override
-    public DataAccess copyTo( DataAccess da )
-    {
-        if (da instanceof UnsafeDataAccess)
-        {
+    public DataAccess copyTo(DataAccess da) {
+        if (da instanceof UnsafeDataAccess) {
             // TODO unsafe.copyMemory(address, da.address, capacity);
             // return this;
         }
@@ -123,8 +112,7 @@ public DataAccess copyTo( DataAccess da )
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (isClosed())
             throw new IllegalStateException("already closed");
 
@@ -132,11 +120,9 @@ public boolean loadExisting()
         if (!file.exists() || file.length() == 0)
             return false;
 
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "r");
-            try
-            {
+            try {
                 long byteCount = readHeader(raFile) - HEADER_OFFSET;
                 if (byteCount < 0)
                     return false;
@@ -148,8 +134,7 @@ public boolean loadExisting()
 
                 ensureCapacity(byteCount, false);
                 byte[] bytes = new byte[segmentSizeInBytes];
-                for (int s = 0; s < segmentCount; s++)
-                {
+                for (int s = 0; s < segmentCount; s++) {
                     int read = raFile.read(bytes);
                     if (read <= 0)
                         throw new IllegalStateException("segment " + s + " is empty? " + toString());
@@ -158,112 +143,92 @@ public boolean loadExisting()
                     setBytes(s * segmentSizeInBytes, bytes, segmentSizeInBytes);
                 }
                 return true;
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException("Problem while loading " + getFullName(), ex);
         }
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         if (isClosed())
             throw new IllegalStateException("already closed");
 
-        try
-        {
+        try {
             RandomAccessFile raFile = new RandomAccessFile(getFullName(), "rw");
-            try
-            {
+            try {
                 long len = getCapacity();
                 writeHeader(raFile, len, segmentSizeInBytes);
                 raFile.seek(HEADER_OFFSET);
                 byte bytes[] = new byte[segmentSizeInBytes];
                 int segs = getSegments();
-                for (int s = 0; s < segs; s++)
-                {
+                for (int s = 0; s < segs; s++) {
                     getBytes(s * segmentSizeInBytes, bytes, segmentSizeInBytes);
                     raFile.write(bytes);
                 }
-            } finally
-            {
+            } finally {
                 raFile.close();
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Couldn't store bytes to " + toString(), ex);
         }
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         super.close();
         UNSAFE.freeMemory(address);
     }
 
     @Override
-    public final void setInt( long bytePos, int value )
-    {
+    public final void setInt(long bytePos, int value) {
         UNSAFE.putInt(address + bytePos, value);
     }
 
     @Override
-    public final int getInt( long bytePos )
-    {
+    public final int getInt(long bytePos) {
         return UNSAFE.getInt(address + bytePos);
     }
 
     @Override
-    public short getShort( long bytePos )
-    {
+    public short getShort(long bytePos) {
         return UNSAFE.getShort(address + bytePos);
     }
 
     @Override
-    public void setShort( long bytePos, short value )
-    {
+    public void setShort(long bytePos, short value) {
         UNSAFE.putShort(address + bytePos, value);
     }
 
     @Override
-    public final void setBytes( long bytePos, byte[] values, int length )
-    {
-        for (int offset = 0; offset < length; offset++)
-        {
+    public final void setBytes(long bytePos, byte[] values, int length) {
+        for (int offset = 0; offset < length; offset++) {
             UNSAFE.putByte(address + bytePos + offset, values[offset]);
         }
     }
 
     @Override
-    public final void getBytes( long bytePos, byte[] values, int length )
-    {
+    public final void getBytes(long bytePos, byte[] values, int length) {
         assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
-        for (int offset = 0; offset < length; offset++)
-        {
+        for (int offset = 0; offset < length; offset++) {
             values[offset] = UNSAFE.getByte(address + bytePos + offset);
         }
     }
 
     @Override
-    public final long getCapacity()
-    {
+    public final long getCapacity() {
         return capacity;
     }
 
     @Override
-    public final int getSegments()
-    {
+    public final int getSegments() {
         return (int) (capacity / segmentSizeInBytes);
     }
 
     @Override
-    public final void trimTo( long bytes )
-    {
+    public final void trimTo(long bytes) {
         if (bytes > this.capacity)
             throw new IllegalStateException("Use ensureCapacity to increase capacity!");
 
@@ -276,8 +241,7 @@ public final void trimTo( long bytes )
     }
 
     @Override
-    public DAType getType()
-    {
+    public DAType getType() {
         return DAType.UNSAFE_STORE;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 9b15d1d057..bdf7402efd 100755
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -19,53 +19,43 @@
  * Taken from lucene DataOutput. VLong's are longs which have variable length depending on the size.
  * When used together with 'delta compression' it is likely that you'll use only 1 byte per value.
  */
-public class VLongStorage
-{
+public class VLongStorage {
     private byte[] bytes;
     private int pointer = 0;
 
-    public VLongStorage()
-    {
+    public VLongStorage() {
         this(10);
     }
 
-    public VLongStorage( int cap )
-    {
+    public VLongStorage(int cap) {
         this(new byte[cap]);
     }
 
-    public VLongStorage( byte[] bytes )
-    {
+    public VLongStorage(byte[] bytes) {
         this.bytes = bytes;
     }
 
-    public void seek( long pos )
-    {
+    public void seek(long pos) {
         // TODO long vs. int
         pointer = (int) pos;
     }
 
-    public long getPosition()
-    {
+    public long getPosition() {
         return pointer;
     }
 
-    public long getLength()
-    {
+    public long getLength() {
         return bytes.length;
     }
 
-    byte readByte()
-    {
+    byte readByte() {
         byte b = bytes[pointer];
         pointer++;
         return b;
     }
 
-    void writeByte( byte b )
-    {
-        if (pointer >= bytes.length)
-        {
+    void writeByte(byte b) {
+        if (pointer >= bytes.length) {
             int cap = Math.max(10, (int) (pointer * 1.5f));
             bytes = Arrays.copyOf(bytes, cap);
         }
@@ -81,11 +71,9 @@ void writeByte( byte b )
      * <p>
      * See DataInput readVLong of Lucene
      */
-    public final void writeVLong( long i )
-    {
+    public final void writeVLong(long i) {
         assert i >= 0L;
-        while ((i & ~0x7FL) != 0L)
-        {
+        while ((i & ~0x7FL) != 0L) {
             writeByte((byte) ((i & 0x7FL) | 0x80L));
             i >>>= 7;
         }
@@ -98,8 +86,7 @@ public final void writeVLong( long i )
      * <p>
      * The format is described further in DataOutput writeVInt(int) from Lucene.
      */
-    public long readVLong()
-    {
+    public long readVLong() {
         /* This is the original code of this method,
          * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if
          * readByte() is inlined. So the loop was unwinded!
@@ -112,74 +99,62 @@ public long readVLong()
          return i;
          */
         byte b = readByte();
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return b;
         }
         long i = b & 0x7FL;
         b = readByte();
         i |= (b & 0x7FL) << 7;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 14;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 21;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 28;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 35;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 42;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 49;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         b = readByte();
         i |= (b & 0x7FL) << 56;
-        if (b >= 0)
-        {
+        if (b >= 0) {
             return i;
         }
         throw new RuntimeException("Invalid vLong detected (negative values disallowed)");
     }
 
-    public void trimToSize()
-    {
-        if (bytes.length > pointer)
-        {
+    public void trimToSize() {
+        if (bytes.length > pointer) {
             byte[] tmp = new byte[pointer];
             System.arraycopy(bytes, 0, tmp, 0, pointer);
             bytes = tmp;
         }
     }
 
-    public byte[] getBytes()
-    {
+    public byte[] getBytes() {
         return bytes;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index 7a40f6b382..316f0d6af4 100755
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -26,38 +26,33 @@
  * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
  * http://stackoverflow.com/q/24679963/194609
  * <p>
+ *
  * @author Peter Karich
  */
-public class BresenhamLine
-{
-    public static void calcPoints( int y1, int x1, int y2, int x2, PointEmitter emitter )
-    {
+public class BresenhamLine {
+    public static void calcPoints(int y1, int x1, int y2, int x2, PointEmitter emitter) {
         bresenham(y1, x1, y2, x2, emitter);
     }
 
-    public static void bresenham( int y1, int x1, int y2, int x2, PointEmitter emitter )
-    {
+    public static void bresenham(int y1, int x1, int y2, int x2, PointEmitter emitter) {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
         int dLat = Math.abs(y2 - y1), sLat = latIncreasing ? 1 : -1;
         int dLon = Math.abs(x2 - x1), sLon = lonIncreasing ? 1 : -1;
         int err = dLon - dLat;
 
-        while (true)
-        {
+        while (true) {
             emitter.set(y1, x1);
             if (y1 == y2 && x1 == x2)
                 break;
 
             int tmpErr = 2 * err;
-            if (tmpErr > -dLat)
-            {
+            if (tmpErr > -dLat) {
                 err -= dLat;
                 x1 += sLon;
             }
 
-            if (tmpErr < dLon)
-            {
+            if (tmpErr < dLon) {
                 err += dLon;
                 y1 += sLat;
             }
@@ -67,22 +62,19 @@ public static void bresenham( int y1, int x1, int y2, int x2, PointEmitter emitt
     /**
      * Calls the Bresenham algorithm but make it working for double values
      */
-    public static void calcPoints( final double lat1, final double lon1,
-                                   final double lat2, final double lon2,
-                                   final PointEmitter emitter,
-                                   final double offsetLat, final double offsetLon,
-                                   final double deltaLat, final double deltaLon )
-    {
+    public static void calcPoints(final double lat1, final double lon1,
+                                  final double lat2, final double lon2,
+                                  final PointEmitter emitter,
+                                  final double offsetLat, final double offsetLon,
+                                  final double deltaLat, final double deltaLon) {
         // round to make results of bresenham closer to correct solution
         int y1 = (int) ((lat1 - offsetLat) / deltaLat);
         int x1 = (int) ((lon1 - offsetLon) / deltaLon);
         int y2 = (int) ((lat2 - offsetLat) / deltaLat);
         int x2 = (int) ((lon2 - offsetLon) / deltaLon);
-        bresenham(y1, x1, y2, x2, new PointEmitter()
-        {
+        bresenham(y1, x1, y2, x2, new PointEmitter() {
             @Override
-            public void set( double lat, double lon )
-            {
+            public void set(double lat, double lon) {
                 // +.1 to move more near the center of the tile
                 emitter.set((lat + .1) * deltaLat + offsetLat, (lon + .1) * deltaLon + offsetLon);
             }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 7190394a9e..58aa139d31 100755
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -28,30 +28,27 @@
 /**
  * Very slow O(n) LocationIndex but no RAM/disc required.
  * <p>
+ *
  * @author Peter Karich
  */
-public class Location2IDFullIndex implements LocationIndex
-{
-    private DistanceCalc calc = Helper.DIST_PLANE;
+public class Location2IDFullIndex implements LocationIndex {
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    private DistanceCalc calc = Helper.DIST_PLANE;
     private boolean closed = false;
 
-    public Location2IDFullIndex( Graph g )
-    {
+    public Location2IDFullIndex(Graph g) {
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         return true;
     }
 
     @Override
-    public LocationIndex setApproximation( boolean approxDist )
-    {
+    public LocationIndex setApproximation(boolean approxDist) {
         if (approxDist)
             calc = Helper.DIST_PLANE;
         else
@@ -61,45 +58,37 @@ public LocationIndex setApproximation( boolean approxDist )
     }
 
     @Override
-    public LocationIndex setResolution( int resolution )
-    {
+    public LocationIndex setResolution(int resolution) {
         return this;
     }
 
     @Override
-    public LocationIndex prepareIndex()
-    {
+    public LocationIndex prepareIndex() {
         return this;
     }
 
     @Override
-    public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter edgeFilter )
-    {
+    public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter edgeFilter) {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
 
         QueryResult res = new QueryResult(queryLat, queryLon);
         Circle circle = null;
         AllEdgesIterator iter = graph.getAllEdges();
-        while (iter.next())
-        {
+        while (iter.next()) {
             if (!edgeFilter.accept(iter))
                 continue;
 
-            for (int node, i = 0; i < 2; i++)
-            {
-                if (i == 0)
-                {
+            for (int node, i = 0; i < 2; i++) {
+                if (i == 0) {
                     node = iter.getBaseNode();
-                } else
-                {
+                } else {
                     node = iter.getAdjNode();
                 }
                 double tmpLat = nodeAccess.getLatitude(node);
                 double tmpLon = nodeAccess.getLongitude(node);
                 double dist = calc.calcDist(tmpLat, tmpLon, queryLat, queryLon);
-                if (circle == null || dist < calc.calcDist(circle.getLat(), circle.getLon(), queryLat, queryLon))
-                {
+                if (circle == null || dist < calc.calcDist(circle.getLat(), circle.getLon(), queryLat, queryLon)) {
                     res.setClosestEdge(iter.detach(false));
                     res.setClosestNode(node);
                     res.setQueryDistance(dist);
@@ -114,42 +103,35 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter edg
     }
 
     @Override
-    public int findID( double lat, double lon )
-    {
+    public int findID(double lat, double lon) {
         return findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
     }
 
     @Override
-    public LocationIndex create( long size )
-    {
+    public LocationIndex create(long size) {
         return this;
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         closed = true;
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return closed;
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return 0;
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index cc01e4964b..880af5d4e6 100755
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -27,80 +27,66 @@
 /**
  * Same as full index but calculates distance to all edges too
  * <p>
+ *
  * @author Peter Karich
  */
-public class Location2IDFullWithEdgesIndex implements LocationIndex
-{
-    private DistanceCalc calc = Helper.DIST_EARTH;
+public class Location2IDFullWithEdgesIndex implements LocationIndex {
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private boolean closed = false;
 
-    public Location2IDFullWithEdgesIndex( Graph g )
-    {
+    public Location2IDFullWithEdgesIndex(Graph g) {
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         return true;
     }
 
     @Override
-    public LocationIndex setResolution( int resolution )
-    {
+    public LocationIndex setResolution(int resolution) {
         return this;
     }
 
     @Override
-    public LocationIndex setApproximation( boolean approxDist )
-    {
-        if (approxDist)
-        {
+    public LocationIndex setApproximation(boolean approxDist) {
+        if (approxDist) {
             calc = Helper.DIST_PLANE;
-        } else
-        {
+        } else {
             calc = Helper.DIST_EARTH;
         }
         return this;
     }
 
     @Override
-    public LocationIndex prepareIndex()
-    {
+    public LocationIndex prepareIndex() {
         return this;
     }
 
     @Override
-    public int findID( double lat, double lon )
-    {
+    public int findID(double lat, double lon) {
         return findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
     }
 
     @Override
-    public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter filter )
-    {
+    public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter filter) {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
 
         QueryResult res = new QueryResult(queryLat, queryLon);
         double foundDist = Double.MAX_VALUE;
         AllEdgesIterator iter = graph.getAllEdges();
-        while (iter.next())
-        {
-            if (!filter.accept(iter))
-            {
+        while (iter.next()) {
+            if (!filter.accept(iter)) {
                 continue;
             }
-            for (int i = 0, node; i < 2; i++)
-            {
-                if (i == 0)
-                {
+            for (int i = 0, node; i < 2; i++) {
+                if (i == 0) {
                     node = iter.getBaseNode();
-                } else
-                {
+                } else {
                     node = iter.getAdjNode();
                 }
 
@@ -110,8 +96,7 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
                 if (fromDist < 0)
                     continue;
 
-                if (fromDist < foundDist)
-                {
+                if (fromDist < foundDist) {
                     res.setQueryDistance(fromDist);
                     res.setClosestEdge(iter.detach(false));
                     res.setClosestNode(node);
@@ -127,12 +112,10 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
                 double toLon = nodeAccess.getLongitude(toNode);
 
                 if (calc.validEdgeDistance(queryLat, queryLon,
-                        fromLat, fromLon, toLat, toLon))
-                {
+                        fromLat, fromLon, toLat, toLon)) {
                     double distEdge = calc.calcDenormalizedDist(calc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             fromLat, fromLon, toLat, toLon));
-                    if (distEdge < foundDist)
-                    {
+                    if (distEdge < foundDist) {
                         res.setQueryDistance(distEdge);
                         res.setClosestNode(node);
                         res.setClosestEdge(iter);
@@ -148,36 +131,30 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
     }
 
     @Override
-    public LocationIndex create( long size )
-    {
+    public LocationIndex create(long size) {
         return this;
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         closed = true;
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return closed;
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return 0;
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 5a03ef0742..61573c55f3 100755
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -24,39 +24,40 @@
 import com.graphhopper.geohash.LinearKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
+import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
-
-import java.util.Arrays;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Arrays;
+
 /**
  * This class implements map matching and returns a node index from lat,lon coordinate. This
  * implementation is the a very memory efficient representation for areas with lots of node and
  * edges, but lacks precision. No edge distances are measured.
  * <p>
+ *
  * @author Peter Karich
  * @see LocationIndexTree which is more precise but more complicated and also slightly slower
  * implementation of LocationIndex.
  * <p>
  */
-class Location2IDQuadtree implements LocationIndex
-{
+class Location2IDQuadtree implements LocationIndex {
     private final static int MAGIC_INT = Integer.MAX_VALUE / 12306;
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private KeyAlgo keyAlgo;
-    protected DistanceCalc distCalc = Helper.DIST_PLANE;
     private final DataAccess index;
-    private double maxRasterWidth2InMeterNormed;
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    private KeyAlgo keyAlgo;
+    private double maxRasterWidth2InMeterNormed;
     private int lonSize, latSize;
 
-    public Location2IDQuadtree( Graph g, Directory dir )
-    {
+    public Location2IDQuadtree(Graph g, Directory dir) {
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
         index = dir.find("loc2id_index");
@@ -64,8 +65,7 @@ public Location2IDQuadtree( Graph g, Directory dir )
     }
 
     @Override
-    public LocationIndex setApproximation( boolean approxDist )
-    {
+    public LocationIndex setApproximation(boolean approxDist) {
         if (approxDist)
             distCalc = Helper.DIST_PLANE;
         else
@@ -75,8 +75,7 @@ public LocationIndex setApproximation( boolean approxDist )
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return index.getCapacity() / 4;
     }
 
@@ -84,11 +83,11 @@ public long getCapacity()
      * Loads the index from disc if exists. Make sure you are using the identical graph which was
      * used while flushing this index.
      * <p>
+     *
      * @return if loading from file was successfully.
      */
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (!index.loadExisting())
             return false;
 
@@ -107,14 +106,12 @@ public boolean loadExisting()
     }
 
     @Override
-    public LocationIndex create( long size )
-    {
+    public LocationIndex create(long size) {
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
     @Override
-    public LocationIndex setResolution( int resolution )
-    {
+    public LocationIndex setResolution(int resolution) {
         initLatLonSize(resolution);
         return this;
     }
@@ -126,8 +123,7 @@ public LocationIndex setResolution( int resolution )
      * boundaries every 1.3km - IMO enough for EU or US networks.
      */
     @Override
-    public LocationIndex prepareIndex()
-    {
+    public LocationIndex prepareIndex() {
         initBuffer();
         initAlgo(latSize, lonSize);
         StopWatch sw = new StopWatch().start();
@@ -143,22 +139,19 @@ public LocationIndex prepareIndex()
         return this;
     }
 
-    private void initLatLonSize( int size )
-    {
+    private void initLatLonSize(int size) {
         latSize = lonSize = (int) Math.sqrt(size);
         if (latSize * lonSize < size)
             lonSize++;
     }
 
-    private void initBuffer()
-    {
+    private void initBuffer() {
         // avoid default big segment size and use one segment only:
         index.setSegmentSize(latSize * lonSize * 4);
         index.create(latSize * lonSize * 4);
     }
 
-    void initAlgo( int lat, int lon )
-    {
+    void initAlgo(int lat, int lon) {
         this.latSize = lat;
         this.lonSize = lon;
         BBox b = graph.getBounds();
@@ -171,29 +164,24 @@ void initAlgo( int lat, int lon )
         // distances. because sin(x) is only monotonic increasing for x <= PI/2 (and positive for x >= 0)
     }
 
-    protected double getMaxRasterWidthMeter()
-    {
+    protected double getMaxRasterWidthMeter() {
         return distCalc.calcDenormalizedDist(maxRasterWidth2InMeterNormed) / 2;
     }
 
-    private GHBitSet fillQuadtree( int size )
-    {
+    private GHBitSet fillQuadtree(int size) {
         int locs = graph.getNodes();
-        if (locs <= 0)
-        {
+        if (locs <= 0) {
             throw new IllegalStateException("check your graph - it is empty!");
         }
 
         GHBitSet filledIndices = new GHBitSetImpl(size);
         GHPoint coord = new GHPoint();
-        for (int nodeId = 0; nodeId < locs; nodeId++)
-        {
+        for (int nodeId = 0; nodeId < locs; nodeId++) {
             double lat = nodeAccess.getLatitude(nodeId);
             double lon = nodeAccess.getLongitude(nodeId);
             int key = (int) keyAlgo.encode(lat, lon);
             long bytePos = (long) key * 4;
-            if (filledIndices.contains(key))
-            {
+            if (filledIndices.contains(key)) {
                 int oldNodeId = index.getInt(bytePos);
                 keyAlgo.decode(key, coord);
                 // decide which one is closer to 'key'
@@ -202,12 +190,10 @@ private GHBitSet fillQuadtree( int size )
                 double oldLon = nodeAccess.getLongitude(oldNodeId);
                 double distOld = distCalc.calcNormalizedDist(coord.lat, coord.lon, oldLat, oldLon);
                 // new point is closer to quad tree point (key) so overwrite old
-                if (distNew < distOld)
-                {
+                if (distNew < distOld) {
                     index.setInt(bytePos, nodeId);
                 }
-            } else
-            {
+            } else {
                 index.setInt(bytePos, nodeId);
                 filledIndices.add(key);
             }
@@ -215,8 +201,7 @@ private GHBitSet fillQuadtree( int size )
         return filledIndices;
     }
 
-    private int fillEmptyIndices( GHBitSet filledIndices )
-    {
+    private int fillEmptyIndices(GHBitSet filledIndices) {
         int len = latSize * lonSize;
         DataAccess indexCopy = new RAMDirectory().find("temp_index_copy");
         indexCopy.setSegmentSize(index.getSegmentSize()).create(index.getCapacity());
@@ -227,60 +212,45 @@ private int fillEmptyIndices( GHBitSet filledIndices )
         // and 2. use a taken-from array to decide which of the colliding should be preferred
         int[] takenFrom = new int[len];
         Arrays.fill(takenFrom, -1);
-        for (int i = filledIndices.next(0); i >= 0; i = filledIndices.next(i + 1))
-        {
+        for (int i = filledIndices.next(0); i >= 0; i = filledIndices.next(i + 1)) {
             takenFrom[i] = i;
         }
-        if (initializedCounter == 0)
-        {
+        if (initializedCounter == 0) {
             throw new IllegalStateException("at least one entry has to be != null, which should have happened in initIndex");
         }
         int tmp = initializedCounter;
-        while (initializedCounter < len)
-        {
+        while (initializedCounter < len) {
             index.copyTo(indexCopy);
             filledIndices.copyTo(indicesCopy);
             initializedCounter = filledIndices.getCardinality();
-            for (int i = 0; i < len; i++)
-            {
+            for (int i = 0; i < len; i++) {
                 int to = -1, from = -1;
-                if (indicesCopy.contains(i))
-                {
+                if (indicesCopy.contains(i)) {
                     // check change "initialized to empty"                    
-                    if ((i + 1) % lonSize != 0 && !indicesCopy.contains(i + 1))
-                    {
+                    if ((i + 1) % lonSize != 0 && !indicesCopy.contains(i + 1)) {
                         // set right from current
                         from = i;
                         to = i + 1;
-                    } else if (i + lonSize < len && !indicesCopy.contains(i + lonSize))
-                    {
+                    } else if (i + lonSize < len && !indicesCopy.contains(i + lonSize)) {
                         // set below from current
                         from = i;
                         to = i + lonSize;
                     }
-                } else
-                {
-                    // check change "empty to initialized"
-                    if ((i + 1) % lonSize != 0 && indicesCopy.contains(i + 1))
-                    {
+                } else // check change "empty to initialized"
+                    if ((i + 1) % lonSize != 0 && indicesCopy.contains(i + 1)) {
                         // set from right
                         from = i + 1;
                         to = i;
-                    } else if (i + lonSize < len && indicesCopy.contains(i + lonSize))
-                    {
+                    } else if (i + lonSize < len && indicesCopy.contains(i + lonSize)) {
                         // set from below
                         from = i + lonSize;
                         to = i;
                     }
-                }
-                if (to >= 0)
-                {
-                    if (takenFrom[to] >= 0)
-                    {
+                if (to >= 0) {
+                    if (takenFrom[to] >= 0) {
                         // takenFrom[to] == to -> special case for normedDist == 0
                         if (takenFrom[to] == to
-                                || getNormedDist(from, to) >= getNormedDist(takenFrom[to], to))
-                        {
+                                || getNormedDist(from, to) >= getNormedDist(takenFrom[to], to)) {
                             continue;
                         }
                     }
@@ -296,8 +266,7 @@ private int fillEmptyIndices( GHBitSet filledIndices )
         return initializedCounter - tmp;
     }
 
-    double getNormedDist( int from, int to )
-    {
+    double getNormedDist(int from, int to) {
         int fromX = from % lonSize;
         int fromY = from / lonSize;
         int toX = to % lonSize;
@@ -311,15 +280,13 @@ private int fillEmptyIndices( GHBitSet filledIndices )
      * @return the node id (corresponding to a coordinate) closest to the specified lat,lon.
      */
     @Override
-    public int findID( final double lat, final double lon )
-    {
+    public int findID(final double lat, final double lon) {
         return findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
     }
 
     @Override
-    public QueryResult findClosest( final double queryLat, final double queryLon,
-                                    final EdgeFilter edgeFilter )
-    {
+    public QueryResult findClosest(final double queryLat, final double queryLon,
+                                   final EdgeFilter edgeFilter) {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
 
@@ -348,17 +315,14 @@ public QueryResult findClosest( final double queryLat, final double queryLon,
         res.setClosestNode(id);
         res.setQueryDistance(distCalc.calcNormalizedDist(queryLat, queryLon, mainLat, mainLon));
         goFurtherHook(id);
-        new BreadthFirstSearch()
-        {
+        new BreadthFirstSearch() {
             @Override
-            protected GHBitSet createBitSet()
-            {
+            protected GHBitSet createBitSet() {
                 return new GHTBitSet(10);
             }
 
             @Override
-            protected boolean goFurther( int baseNode )
-            {
+            protected boolean goFurther(int baseNode) {
                 if (baseNode == id)
                     return true;
 
@@ -366,8 +330,7 @@ protected boolean goFurther( int baseNode )
                 double currLat = nodeAccess.getLatitude(baseNode);
                 double currLon = nodeAccess.getLongitude(baseNode);
                 double currNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, currLat, currLon);
-                if (currNormedDist < res.getQueryDistance())
-                {
+                if (currNormedDist < res.getQueryDistance()) {
                     res.setQueryDistance(currNormedDist);
                     res.setClosestNode(baseNode);
                     return true;
@@ -382,13 +345,11 @@ protected boolean goFurther( int baseNode )
         return res;
     }
 
-    public void goFurtherHook( int n )
-    {
+    public void goFurtherHook(int n) {
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         index.setHeader(0, MAGIC_INT);
         index.setHeader(1 * 4, latSize);
         index.setHeader(2 * 4, lonSize);
@@ -397,20 +358,17 @@ public void flush()
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         index.close();
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return index.isClosed();
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
         index.setSegmentSize(bytes);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index 801e36b940..6367630960 100755
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -26,15 +26,15 @@
  * <p>
  * The implementations of findID needs to be thread safe!
  * <p>
+ *
  * @author Peter Karich
  */
-public interface LocationIndex extends Storable<LocationIndex>
-{
+public interface LocationIndex extends Storable<LocationIndex> {
     /**
      * Integer value to specify the resolution of this location index. The higher the better the
      * resolution.
      */
-    LocationIndex setResolution( int resolution );
+    LocationIndex setResolution(int resolution);
 
     /**
      * Creates this index - to be called once before findID.
@@ -42,31 +42,32 @@
     LocationIndex prepareIndex();
 
     /**
-     * @deprecated will be removed with 0.8 use 'QueryResult findClosest' instead
      * @return the closest node id for the specified geo location (latitude,longitude)
+     * @deprecated will be removed with 0.8 use 'QueryResult findClosest' instead
      */
-    int findID( double lat, double lon );
+    int findID(double lat, double lon);
 
     /**
      * This method returns the closest QueryResult for the specified location (lat, lon) and only if
      * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
      * search)
      * <p>
+     *
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
-     * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
-     *   new DefaultEdgeFilter(footFlagEncoder);
-     * </pre>
-     * <p>
+     *                   node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
+     *                     new DefaultEdgeFilter(footFlagEncoder);
+     *                   </pre>
+     *
      * @return An object containing the closest node and edge for the specified location. The node id
      * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
      * the method QueryResult.isValid will return false.
      */
-    QueryResult findClosest( double lat, double lon, EdgeFilter edgeFilter );
+    QueryResult findClosest(double lat, double lon, EdgeFilter edgeFilter);
 
     /**
      * @param approxDist false if initialization and querying should be faster but less precise.
      */
-    LocationIndex setApproximation( boolean approxDist );
+    LocationIndex setApproximation(boolean approxDist);
 
-    void setSegmentSize( int bytes );
+    void setSegmentSize(int bytes);
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 569b82bd14..9ac7f5e6fd 100755
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -21,11 +21,7 @@
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
@@ -33,12 +29,14 @@
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
-
-import java.util.*;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
 /**
  * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
  * <p>
@@ -46,30 +44,30 @@
  * line for different resolutions, especially if a leaf node could be split into a tree-node and
  * resolution changes.
  * <p>
+ *
  * @author Peter Karich
  */
-public class LocationIndexTree implements LocationIndex
-{
+public class LocationIndexTree implements LocationIndex {
+    // do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
+    static final int START_POINTER = 1;
+    protected final Graph graph;
+    final DataAccess dataAccess;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int MAGIC_INT;
+    private final NodeAccess nodeAccess;
     protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    protected SpatialKeyAlgo keyAlgo;
+    int maxRegionSearch = 4;
     private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
-    protected final Graph graph;
-    private final NodeAccess nodeAccess;
-    final DataAccess dataAccess;
     private int[] entries;
     private byte[] shifts;
     // convert spatial key to index for subentry of current depth
     private long[] bitmasks;
-    protected SpatialKeyAlgo keyAlgo;
     private int minResolutionInMeter = 300;
     private double deltaLat;
     private double deltaLon;
     private int initSizeLeafEntries = 4;
     private boolean initialized = false;
-    // do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
-    static final int START_POINTER = 1;
-    int maxRegionSearch = 4;
     /**
      * If normed distance is smaller than this value the node or edge is 'identical' and the
      * algorithm can stop search.
@@ -79,8 +77,7 @@
     /**
      * @param g the graph for which this index should do the lookup based on latitude,longitude.
      */
-    public LocationIndexTree( Graph g, Directory dir )
-    {
+    public LocationIndexTree(Graph g, Directory dir) {
         if (g instanceof CHGraph)
             throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
@@ -90,8 +87,7 @@ public LocationIndexTree( Graph g, Directory dir )
         dataAccess = dir.find("location_index");
     }
 
-    public int getMinResolutionInMeter()
-    {
+    public int getMinResolutionInMeter() {
         return minResolutionInMeter;
     }
 
@@ -99,8 +95,7 @@ public int getMinResolutionInMeter()
      * Minimum width in meter of one tile. Decrease this if you need faster queries, but keep in
      * mind that then queries with different coordinates are more likely to fail.
      */
-    public LocationIndexTree setMinResolutionInMeter( int minResolutionInMeter )
-    {
+    public LocationIndexTree setMinResolutionInMeter(int minResolutionInMeter) {
         this.minResolutionInMeter = minResolutionInMeter;
         return this;
     }
@@ -110,8 +105,7 @@ public LocationIndexTree setMinResolutionInMeter( int minResolutionInMeter )
      * (minResolutionInMeter*regionAround). Set to 1 for to force avoiding a fall back, good if you
      * have strict performance and lookup-quality requirements. Default is 4.
      */
-    public LocationIndexTree setMaxRegionSearch( int numTiles )
-    {
+    public LocationIndexTree setMaxRegionSearch(int numTiles) {
         if (numTiles < 1)
             throw new IllegalArgumentException("Region of location index must be at least 1 but was " + numTiles);
 
@@ -123,8 +117,7 @@ public LocationIndexTree setMaxRegionSearch( int numTiles )
         return this;
     }
 
-    void prepareAlgo()
-    {
+    void prepareAlgo() {
         // 0.1 meter should count as 'equal'
         equalNormedDelta = distCalc.calcNormalizedDist(0.1);
 
@@ -147,20 +140,15 @@ void prepareAlgo()
         TIntArrayList tmpEntries = new TIntArrayList();
         // the last one is always 4 to reduce costs if only a single entry
         tmp /= 4;
-        while (tmp > 1)
-        {
+        while (tmp > 1) {
             int tmpNo;
-            if (tmp >= 64)
-            {
+            if (tmp >= 64) {
                 tmpNo = 64;
-            } else if (tmp >= 16)
-            {
+            } else if (tmp >= 16) {
                 tmpNo = 16;
-            } else if (tmp >= 4)
-            {
+            } else if (tmp >= 4) {
                 tmpNo = 4;
-            } else
-            {
+            } else {
                 break;
             }
             tmpEntries.add(tmpNo);
@@ -170,8 +158,7 @@ void prepareAlgo()
         initEntries(tmpEntries.toArray());
         int shiftSum = 0;
         long parts = 1;
-        for (int i = 0; i < shifts.length; i++)
-        {
+        for (int i = 0; i < shifts.length; i++) {
             shiftSum += shifts[i];
             parts *= entries[i];
         }
@@ -184,11 +171,9 @@ void prepareAlgo()
         deltaLon = (bounds.maxLon - bounds.minLon) / parts;
     }
 
-    private LocationIndexTree initEntries( int[] entries )
-    {
-        if (entries.length < 1)
-        // at least one depth should have been specified
-        {
+    private LocationIndexTree initEntries(int[] entries) {
+        if (entries.length < 1) {
+            // at least one depth should have been specified
             throw new IllegalStateException("depth needs to be at least 1");
         }
         this.entries = entries;
@@ -196,10 +181,8 @@ private LocationIndexTree initEntries( int[] entries )
         shifts = new byte[depth];
         bitmasks = new long[depth];
         int lastEntry = entries[0];
-        for (int i = 0; i < depth; i++)
-        {
-            if (lastEntry < entries[i])
-            {
+        for (int i = 0; i < depth; i++) {
+            if (lastEntry < entries[i]) {
                 throw new IllegalStateException("entries should decrease or stay but was:"
                         + Arrays.toString(entries));
             }
@@ -210,8 +193,7 @@ private LocationIndexTree initEntries( int[] entries )
         return this;
     }
 
-    private byte getShift( int entries )
-    {
+    private byte getShift(int entries) {
         byte b = (byte) Math.round(Math.log(entries) / Math.log(2));
         if (b <= 0)
             throw new IllegalStateException("invalid shift:" + b);
@@ -219,26 +201,22 @@ private byte getShift( int entries )
         return b;
     }
 
-    private long getBitmask( int shift )
-    {
+    private long getBitmask(int shift) {
         long bm = (1L << shift) - 1;
-        if (bm <= 0)
-        {
+        if (bm <= 0) {
             throw new IllegalStateException("invalid bitmask:" + bm);
         }
         return bm;
     }
 
-    InMemConstructionIndex getPrepareInMemIndex()
-    {
+    InMemConstructionIndex getPrepareInMemIndex() {
         InMemConstructionIndex memIndex = new InMemConstructionIndex(entries[0]);
         memIndex.prepare();
         return memIndex;
     }
 
     @Override
-    public int findID( double lat, double lon )
-    {
+    public int findID(double lat, double lon) {
         QueryResult res = findClosest(lat, lon, EdgeFilter.ALL_EDGES);
         if (!res.isValid())
             return -1;
@@ -247,8 +225,7 @@ public int findID( double lat, double lon )
     }
 
     @Override
-    public LocationIndex setResolution( int minResolutionInMeter )
-    {
+    public LocationIndex setResolution(int minResolutionInMeter) {
         if (minResolutionInMeter <= 0)
             throw new IllegalStateException("Negative precision is not allowed!");
 
@@ -257,8 +234,7 @@ public LocationIndex setResolution( int minResolutionInMeter )
     }
 
     @Override
-    public LocationIndex setApproximation( boolean approx )
-    {
+    public LocationIndex setApproximation(boolean approx) {
         if (approx)
             distCalc = Helper.DIST_PLANE;
         else
@@ -267,14 +243,12 @@ public LocationIndex setApproximation( boolean approx )
     }
 
     @Override
-    public LocationIndexTree create( long size )
-    {
+    public LocationIndexTree create(long size) {
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
     @Override
-    public boolean loadExisting()
-    {
+    public boolean loadExisting() {
         if (initialized)
             throw new IllegalStateException("Call loadExisting only once");
 
@@ -295,8 +269,7 @@ public boolean loadExisting()
     }
 
     @Override
-    public void flush()
-    {
+    public void flush() {
         dataAccess.setHeader(0, MAGIC_INT);
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
@@ -306,8 +279,7 @@ public void flush()
     }
 
     @Override
-    public LocationIndex prepareIndex()
-    {
+    public LocationIndex prepareIndex() {
         if (initialized)
             throw new IllegalStateException("Call prepareIndex only once");
 
@@ -318,12 +290,10 @@ public LocationIndex prepareIndex()
 
         // compact & store to dataAccess
         dataAccess.create(64 * 1024);
-        try
-        {
+        try {
             inMem.store(inMem.root, START_POINTER);
             flush();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new IllegalStateException("Problem while storing location index. " + Helper.getMemInfo(), ex);
         }
         float entriesPerLeaf = (float) inMem.size / inMem.leafs;
@@ -340,271 +310,48 @@ public LocationIndex prepareIndex()
         return this;
     }
 
-    int calcChecksum()
-    {
+    int calcChecksum() {
         // do not include the edges as we could get problem with CHGraph due to shortcuts
         // ^ graph.getAllEdges().count();
         return graph.getNodes();
     }
 
     @Override
-    public void close()
-    {
+    public void close() {
         dataAccess.close();
     }
 
     @Override
-    public boolean isClosed()
-    {
+    public boolean isClosed() {
         return dataAccess.isClosed();
     }
 
     @Override
-    public long getCapacity()
-    {
+    public long getCapacity() {
         return dataAccess.getCapacity();
     }
 
     @Override
-    public void setSegmentSize( int bytes )
-    {
+    public void setSegmentSize(int bytes) {
         dataAccess.setSegmentSize(bytes);
     }
 
-    class InMemConstructionIndex
-    {
-        int size;
-        int leafs;
-        InMemTreeEntry root;
-
-        public InMemConstructionIndex( int noOfSubEntries )
-        {
-            root = new InMemTreeEntry(noOfSubEntries);
-        }
-
-        void prepare()
-        {
-            final EdgeIterator allIter = graph.getAllEdges();
-            try
-            {
-                while (allIter.next())
-                {
-                    int nodeA = allIter.getBaseNode();
-                    int nodeB = allIter.getAdjNode();
-                    double lat1 = nodeAccess.getLatitude(nodeA);
-                    double lon1 = nodeAccess.getLongitude(nodeA);
-                    double lat2;
-                    double lon2;
-                    PointList points = allIter.fetchWayGeometry(0);
-                    int len = points.getSize();
-                    for (int i = 0; i < len; i++)
-                    {
-                        lat2 = points.getLatitude(i);
-                        lon2 = points.getLongitude(i);
-                        addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
-                        lat1 = lat2;
-                        lon1 = lon2;
-                    }
-                    lat2 = nodeAccess.getLatitude(nodeB);
-                    lon2 = nodeAccess.getLongitude(nodeB);
-                    addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
-                }
-            } catch (Exception ex)
-            {
-                logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
-                        + ", edge:" + allIter.getEdge(), ex);
-            }
-        }
-
-        void addNode( final int nodeA, final int nodeB,
-                      final double lat1, final double lon1,
-                      final double lat2, final double lon2 )
-        {
-            PointEmitter pointEmitter = new PointEmitter()
-            {
-                @Override
-                public void set( double lat, double lon )
-                {
-                    long key = keyAlgo.encode(lat, lon);
-                    long keyPart = createReverseKey(key);
-                    // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, nodeA, 0, keyPart, key);
-                }
-            };
-
-            if (!distCalc.isCrossBoundary(lon1, lon2))
-            {
-                BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
-                        graph.getBounds().minLat, graph.getBounds().minLon,
-                        deltaLat, deltaLon);
-            }
-        }
-
-        void addNode( InMemEntry entry, int nodeId, int depth, long keyPart, long key )
-        {
-            if (entry.isLeaf())
-            {
-                InMemLeafEntry leafEntry = (InMemLeafEntry) entry;
-                leafEntry.addNode(nodeId);
-            } else
-            {
-                int index = (int) (bitmasks[depth] & keyPart);
-                keyPart = keyPart >>> shifts[depth];
-                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
-                InMemEntry subentry = treeEntry.getSubEntry(index);
-                depth++;
-                if (subentry == null)
-                {
-                    if (depth == entries.length)
-                    {
-                        subentry = new InMemLeafEntry(initSizeLeafEntries, key);
-                    } else
-                    {
-                        subentry = new InMemTreeEntry(entries[depth]);
-                    }
-                    treeEntry.setSubEntry(index, subentry);
-                }
-
-                addNode(subentry, nodeId, depth, keyPart, key);
-            }
-        }
-
-        Collection<InMemEntry> getEntriesOf( int selectDepth )
-        {
-            List<InMemEntry> list = new ArrayList<InMemEntry>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
-            return list;
-        }
-
-        void fillLayer( Collection<InMemEntry> list, int selectDepth, int depth, Collection<InMemEntry> entries )
-        {
-            for (InMemEntry entry : entries)
-            {
-                if (selectDepth == depth)
-                {
-                    list.add(entry);
-                } else if (entry instanceof InMemTreeEntry)
-                {
-                    fillLayer(list, selectDepth, depth + 1, ((InMemTreeEntry) entry).getSubEntriesForDebug());
-                }
-            }
-        }
-
-        String print()
-        {
-            StringBuilder sb = new StringBuilder();
-            print(root, sb, 0, 0);
-            return sb.toString();
-        }
-
-        void print( InMemEntry e, StringBuilder sb, long key, int depth )
-        {
-            if (e.isLeaf())
-            {
-                InMemLeafEntry leaf = (InMemLeafEntry) e;
-                int bits = keyAlgo.getBits();
-                // print reverse keys
-                sb.append(BitUtil.BIG.toBitString(BitUtil.BIG.reverse(key, bits), bits)).append("  ");
-                TIntArrayList entries = leaf.getResults();
-                for (int i = 0; i < entries.size(); i++)
-                {
-                    sb.append(leaf.get(i)).append(',');
-                }
-                sb.append('\n');
-            } else
-            {
-                InMemTreeEntry tree = (InMemTreeEntry) e;
-                key = key << shifts[depth];
-                for (int counter = 0; counter < tree.subEntries.length; counter++)
-                {
-                    InMemEntry sube = tree.subEntries[counter];
-                    if (sube != null)
-                    {
-                        print(sube, sb, key | counter, depth + 1);
-                    }
-                }
-            }
-        }
-
-        // store and freezes tree
-        int store( InMemEntry entry, int intIndex )
-        {
-            long refPointer = (long) intIndex * 4;
-            if (entry.isLeaf())
-            {
-                InMemLeafEntry leaf = ((InMemLeafEntry) entry);
-                TIntArrayList entries = leaf.getResults();
-                int len = entries.size();
-                if (len == 0)
-                {
-                    return intIndex;
-                }
-                size += len;
-                intIndex++;
-                leafs++;
-                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
-                if (len == 1)
-                {
-                    // less disc space for single entries
-                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
-                } else
-                {
-                    for (int index = 0; index < len; index++, intIndex++)
-                    {
-                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
-                    }
-                    dataAccess.setInt(refPointer, intIndex);
-                }
-            } else
-            {
-                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
-                int len = treeEntry.subEntries.length;
-                intIndex += len;
-                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4)
-                {
-                    InMemEntry subEntry = treeEntry.subEntries[subCounter];
-                    if (subEntry == null)
-                    {
-                        continue;
-                    }
-                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
-                    int beforeIntIndex = intIndex;
-                    intIndex = store(subEntry, beforeIntIndex);
-                    if (intIndex == beforeIntIndex)
-                    {
-                        dataAccess.setInt(refPointer, 0);
-                    } else
-                    {
-                        dataAccess.setInt(refPointer, beforeIntIndex);
-                    }
-                }
-            }
-            return intIndex;
-        }
-    }
-
-    TIntArrayList getEntries()
-    {
+    TIntArrayList getEntries() {
         return new TIntArrayList(entries);
     }
 
     // fillIDs according to how they are stored
-    final void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
-    {
+    final void fillIDs(long keyPart, int intIndex, TIntHashSet set, int depth) {
         long pointer = (long) intIndex << 2;
-        if (depth == entries.length)
-        {
+        if (depth == entries.length) {
             int value = dataAccess.getInt(pointer);
-            if (value < 0)
-            // single data entries (less disc space)            
-            {
+            if (value < 0) {
+                // single data entries (less disc space)
                 set.add(-(value + 1));
-            } else
-            {
+            } else {
                 long max = (long) value * 4;
                 // leaf entry => value is maxPointer
-                for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4)
-                {
+                for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
                     set.add(dataAccess.getInt(leafIndex));
                 }
             }
@@ -612,21 +359,18 @@ final void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
         }
         int offset = (int) (bitmasks[depth] & keyPart) << 2;
         int value = dataAccess.getInt(pointer + offset);
-        if (value > 0)
-        {
+        if (value > 0) {
             // tree entry => negative value points to subentries
             fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
         }
     }
 
     // this method returns the spatial key in reverse order for easier right-shifting
-    final long createReverseKey( double lat, double lon )
-    {
+    final long createReverseKey(double lat, double lon) {
         return BitUtil.BIG.reverse(keyAlgo.encode(lat, lon), keyAlgo.getBits());
     }
 
-    final long createReverseKey( long key )
-    {
+    final long createReverseKey(long key) {
         return BitUtil.BIG.reverse(key, keyAlgo.getBits());
     }
 
@@ -635,8 +379,7 @@ final long createReverseKey( long key )
      * context of a spatial key tile.
      * <p>
      */
-    final double calculateRMin( double lat, double lon )
-    {
+    final double calculateRMin(double lat, double lon) {
         return calculateRMin(lat, lon, 0);
     }
 
@@ -645,8 +388,7 @@ final double calculateRMin( double lat, double lon )
      * region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon
      * coordinate
      */
-    final double calculateRMin( double lat, double lon, int paddingTiles )
-    {
+    final double calculateRMin(double lat, double lon, int paddingTiles) {
         GHPoint query = new GHPoint(lat, lon);
         long key = keyAlgo.encode(query);
         GHPoint center = new GHPoint();
@@ -665,19 +407,15 @@ final double calculateRMin( double lat, double lon, int paddingTiles )
 
         // convert degree deltas into a radius in meter
         double dMinLat, dMinLon;
-        if (dSouthernLat < dNorthernLat)
-        {
+        if (dSouthernLat < dNorthernLat) {
             dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
-        } else
-        {
+        } else {
             dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
         }
 
-        if (dWesternLon < dEasternLon)
-        {
+        if (dWesternLon < dEasternLon) {
             dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
-        } else
-        {
+        } else {
             dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
         }
 
@@ -688,18 +426,15 @@ final double calculateRMin( double lat, double lon, int paddingTiles )
     /**
      * Provide info about tilesize for testing / visualization
      */
-    double getDeltaLat()
-    {
+    double getDeltaLat() {
         return deltaLat;
     }
 
-    double getDeltaLon()
-    {
+    double getDeltaLon() {
         return deltaLon;
     }
 
-    GHPoint getCenter( double lat, double lon )
-    {
+    GHPoint getCenter(double lat, double lon) {
         GHPoint query = new GHPoint(lat, lon);
         long key = keyAlgo.encode(query);
         GHPoint center = new GHPoint();
@@ -712,15 +447,14 @@ GHPoint getCenter( double lat, double lon )
      * which makes sure not too many nodes are collected as well as no nodes will be missing. See
      * discussion at issue #221.
      * <p>
+     *
      * @return true if no further call of this method is required. False otherwise, ie. a next
      * iteration is necessary and no early finish possible.
      */
-    public final boolean findNetworkEntries( double queryLat, double queryLon,
-                                             TIntHashSet foundEntries, int iteration )
-    {
+    public final boolean findNetworkEntries(double queryLat, double queryLon,
+                                            TIntHashSet foundEntries, int iteration) {
         // find entries in border of searchbox
-        for (int yreg = -iteration; yreg <= iteration; yreg++)
-        {
+        for (int yreg = -iteration; yreg <= iteration; yreg++) {
             double subqueryLat = queryLat + yreg * deltaLat;
             double subqueryLonA = queryLon - iteration * deltaLon;
             double subqueryLonB = queryLon + iteration * deltaLon;
@@ -731,8 +465,7 @@ public final boolean findNetworkEntries( double queryLat, double queryLon,
                 findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
         }
 
-        for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
-        {
+        for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++) {
             double subqueryLon = queryLon + xreg * deltaLon;
             double subqueryLatA = queryLat - iteration * deltaLat;
             double subqueryLatB = queryLat + iteration * deltaLat;
@@ -740,11 +473,9 @@ public final boolean findNetworkEntries( double queryLat, double queryLon,
             findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
         }
 
-        if (iteration % 2 != 0)
-        {
+        if (iteration % 2 != 0) {
             // Check if something was found already...
-            if (!foundEntries.isEmpty())
-            {
+            if (!foundEntries.isEmpty()) {
                 double rMin = calculateRMin(queryLat, queryLon, iteration);
                 double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
 
@@ -761,40 +492,34 @@ public final boolean findNetworkEntries( double queryLat, double queryLon,
         return false;
     }
 
-    final double calcMinDistance( double queryLat, double queryLon, TIntHashSet pointset )
-    {
+    final double calcMinDistance(double queryLat, double queryLon, TIntHashSet pointset) {
         double min = Double.MAX_VALUE;
         TIntIterator itr = pointset.iterator();
-        while (itr.hasNext())
-        {
+        while (itr.hasNext()) {
             int node = itr.next();
             double lat = nodeAccess.getLat(node);
             double lon = nodeAccess.getLon(node);
             double dist = distCalc.calcDist(queryLat, queryLon, lat, lon);
-            if (dist < min)
-            {
+            if (dist < min) {
                 min = dist;
             }
         }
         return min;
     }
 
-    final void findNetworkEntriesSingleRegion( TIntHashSet storedNetworkEntryIds, double queryLat, double queryLon )
-    {
+    final void findNetworkEntriesSingleRegion(TIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
         long keyPart = createReverseKey(queryLat, queryLon);
         fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
 
     @Override
-    public QueryResult findClosest( final double queryLat, final double queryLon, final EdgeFilter edgeFilter )
-    {
+    public QueryResult findClosest(final double queryLat, final double queryLon, final EdgeFilter edgeFilter) {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
 
         TIntHashSet allCollectedEntryIds = new TIntHashSet();
         final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
-        for (int iteration = 0; iteration < maxRegionSearch; iteration++)
-        {
+        for (int iteration = 0; iteration < maxRegionSearch; iteration++) {
             TIntHashSet storedNetworkEntryIds = new TIntHashSet();
             boolean earlyFinish = findNetworkEntries(queryLat, queryLon, storedNetworkEntryIds, iteration);
             storedNetworkEntryIds.removeAll(allCollectedEntryIds);
@@ -804,24 +529,18 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
             final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
             // find nodes from the network entries which are close to 'point'
             final EdgeExplorer explorer = graph.createEdgeExplorer();
-            storedNetworkEntryIds.forEach(new TIntProcedure()
-            {
+            storedNetworkEntryIds.forEach(new TIntProcedure() {
                 @Override
-                public boolean execute( int networkEntryNodeId )
-                {
-                    new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
-                    {
+                public boolean execute(int networkEntryNodeId) {
+                    new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter) {
                         @Override
-                        protected double getQueryDistance()
-                        {
+                        protected double getQueryDistance() {
                             return closestMatch.getQueryDistance();
                         }
 
                         @Override
-                        protected boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos )
-                        {
-                            if (normedDist < closestMatch.getQueryDistance())
-                            {
+                        protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos) {
+                            if (normedDist < closestMatch.getQueryDistance()) {
                                 closestMatch.setQueryDistance(normedDist);
                                 closestMatch.setClosestNode(node);
                                 closestMatch.setClosestEdge(edge.detach(false));
@@ -842,8 +561,7 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
         }
 
         // denormalize distance and calculate snapping point only if closed match was found
-        if (closestMatch.isValid())
-        {
+        if (closestMatch.isValid()) {
             closestMatch.setQueryDistance(distCalc.calcDenormalizedDist(closestMatch.getQueryDistance()));
             closestMatch.calcSnappedPoint(distCalc);
         }
@@ -851,23 +569,284 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
         return closestMatch;
     }
 
+    // make entries static as otherwise we get an additional reference to this class (memory waste)
+    interface InMemEntry {
+        boolean isLeaf();
+    }
+
+    static class InMemLeafEntry extends SortedIntSet implements InMemEntry {
+        // private long key;
+
+        public InMemLeafEntry(int count, long key) {
+            super(count);
+            // this.key = key;
+        }
+
+        public boolean addNode(int nodeId) {
+            return addOnce(nodeId);
+        }
+
+        @Override
+        public final boolean isLeaf() {
+            return true;
+        }
+
+        @Override
+        public String toString() {
+            return "LEAF " + /*key +*/ " " + super.toString();
+        }
+
+        TIntArrayList getResults() {
+            return this;
+        }
+    }
+
+    // Space efficient sorted integer set. Suited for only a few entries.
+    static class SortedIntSet extends TIntArrayList {
+        public SortedIntSet() {
+        }
+
+        public SortedIntSet(int capacity) {
+            super(capacity);
+        }
+
+        /**
+         * Allow adding a value only once
+         */
+        public boolean addOnce(int value) {
+            int foundIndex = binarySearch(value);
+            if (foundIndex >= 0) {
+                return false;
+            }
+            foundIndex = -foundIndex - 1;
+            insert(foundIndex, value);
+            return true;
+        }
+    }
+
+    static class InMemTreeEntry implements InMemEntry {
+        InMemEntry[] subEntries;
+
+        public InMemTreeEntry(int subEntryNo) {
+            subEntries = new InMemEntry[subEntryNo];
+        }
+
+        public InMemEntry getSubEntry(int index) {
+            return subEntries[index];
+        }
+
+        public void setSubEntry(int index, InMemEntry subEntry) {
+            this.subEntries[index] = subEntry;
+        }
+
+        public Collection<InMemEntry> getSubEntriesForDebug() {
+            List<InMemEntry> list = new ArrayList<InMemEntry>();
+            for (InMemEntry e : subEntries) {
+                if (e != null) {
+                    list.add(e);
+                }
+            }
+            return list;
+        }
+
+        @Override
+        public final boolean isLeaf() {
+            return false;
+        }
+
+        @Override
+        public String toString() {
+            return "TREE";
+        }
+    }
+
+    class InMemConstructionIndex {
+        int size;
+        int leafs;
+        InMemTreeEntry root;
+
+        public InMemConstructionIndex(int noOfSubEntries) {
+            root = new InMemTreeEntry(noOfSubEntries);
+        }
+
+        void prepare() {
+            final EdgeIterator allIter = graph.getAllEdges();
+            try {
+                while (allIter.next()) {
+                    int nodeA = allIter.getBaseNode();
+                    int nodeB = allIter.getAdjNode();
+                    double lat1 = nodeAccess.getLatitude(nodeA);
+                    double lon1 = nodeAccess.getLongitude(nodeA);
+                    double lat2;
+                    double lon2;
+                    PointList points = allIter.fetchWayGeometry(0);
+                    int len = points.getSize();
+                    for (int i = 0; i < len; i++) {
+                        lat2 = points.getLatitude(i);
+                        lon2 = points.getLongitude(i);
+                        addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
+                        lat1 = lat2;
+                        lon1 = lon2;
+                    }
+                    lat2 = nodeAccess.getLatitude(nodeB);
+                    lon2 = nodeAccess.getLongitude(nodeB);
+                    addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
+                }
+            } catch (Exception ex) {
+                logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
+                        + ", edge:" + allIter.getEdge(), ex);
+            }
+        }
+
+        void addNode(final int nodeA, final int nodeB,
+                     final double lat1, final double lon1,
+                     final double lat2, final double lon2) {
+            PointEmitter pointEmitter = new PointEmitter() {
+                @Override
+                public void set(double lat, double lon) {
+                    long key = keyAlgo.encode(lat, lon);
+                    long keyPart = createReverseKey(key);
+                    // no need to feed both nodes as we search neighbors in fillIDs
+                    addNode(root, nodeA, 0, keyPart, key);
+                }
+            };
+
+            if (!distCalc.isCrossBoundary(lon1, lon2)) {
+                BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
+                        graph.getBounds().minLat, graph.getBounds().minLon,
+                        deltaLat, deltaLon);
+            }
+        }
+
+        void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
+            if (entry.isLeaf()) {
+                InMemLeafEntry leafEntry = (InMemLeafEntry) entry;
+                leafEntry.addNode(nodeId);
+            } else {
+                int index = (int) (bitmasks[depth] & keyPart);
+                keyPart = keyPart >>> shifts[depth];
+                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
+                InMemEntry subentry = treeEntry.getSubEntry(index);
+                depth++;
+                if (subentry == null) {
+                    if (depth == entries.length) {
+                        subentry = new InMemLeafEntry(initSizeLeafEntries, key);
+                    } else {
+                        subentry = new InMemTreeEntry(entries[depth]);
+                    }
+                    treeEntry.setSubEntry(index, subentry);
+                }
+
+                addNode(subentry, nodeId, depth, keyPart, key);
+            }
+        }
+
+        Collection<InMemEntry> getEntriesOf(int selectDepth) {
+            List<InMemEntry> list = new ArrayList<InMemEntry>();
+            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+            return list;
+        }
+
+        void fillLayer(Collection<InMemEntry> list, int selectDepth, int depth, Collection<InMemEntry> entries) {
+            for (InMemEntry entry : entries) {
+                if (selectDepth == depth) {
+                    list.add(entry);
+                } else if (entry instanceof InMemTreeEntry) {
+                    fillLayer(list, selectDepth, depth + 1, ((InMemTreeEntry) entry).getSubEntriesForDebug());
+                }
+            }
+        }
+
+        String print() {
+            StringBuilder sb = new StringBuilder();
+            print(root, sb, 0, 0);
+            return sb.toString();
+        }
+
+        void print(InMemEntry e, StringBuilder sb, long key, int depth) {
+            if (e.isLeaf()) {
+                InMemLeafEntry leaf = (InMemLeafEntry) e;
+                int bits = keyAlgo.getBits();
+                // print reverse keys
+                sb.append(BitUtil.BIG.toBitString(BitUtil.BIG.reverse(key, bits), bits)).append("  ");
+                TIntArrayList entries = leaf.getResults();
+                for (int i = 0; i < entries.size(); i++) {
+                    sb.append(leaf.get(i)).append(',');
+                }
+                sb.append('\n');
+            } else {
+                InMemTreeEntry tree = (InMemTreeEntry) e;
+                key = key << shifts[depth];
+                for (int counter = 0; counter < tree.subEntries.length; counter++) {
+                    InMemEntry sube = tree.subEntries[counter];
+                    if (sube != null) {
+                        print(sube, sb, key | counter, depth + 1);
+                    }
+                }
+            }
+        }
+
+        // store and freezes tree
+        int store(InMemEntry entry, int intIndex) {
+            long refPointer = (long) intIndex * 4;
+            if (entry.isLeaf()) {
+                InMemLeafEntry leaf = ((InMemLeafEntry) entry);
+                TIntArrayList entries = leaf.getResults();
+                int len = entries.size();
+                if (len == 0) {
+                    return intIndex;
+                }
+                size += len;
+                intIndex++;
+                leafs++;
+                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
+                if (len == 1) {
+                    // less disc space for single entries
+                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
+                } else {
+                    for (int index = 0; index < len; index++, intIndex++) {
+                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
+                    }
+                    dataAccess.setInt(refPointer, intIndex);
+                }
+            } else {
+                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
+                int len = treeEntry.subEntries.length;
+                intIndex += len;
+                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
+                    InMemEntry subEntry = treeEntry.subEntries[subCounter];
+                    if (subEntry == null) {
+                        continue;
+                    }
+                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
+                    int beforeIntIndex = intIndex;
+                    intIndex = store(subEntry, beforeIntIndex);
+                    if (intIndex == beforeIntIndex) {
+                        dataAccess.setInt(refPointer, 0);
+                    } else {
+                        dataAccess.setInt(refPointer, beforeIntIndex);
+                    }
+                }
+            }
+            return intIndex;
+        }
+    }
+
     /**
      * Make it possible to collect nearby location also for other purposes.
      */
-    protected abstract class XFirstSearchCheck extends BreadthFirstSearch
-    {
+    protected abstract class XFirstSearchCheck extends BreadthFirstSearch {
+        final double queryLat;
+        final double queryLon;
+        final GHBitSet checkBitset;
+        final EdgeFilter edgeFilter;
         boolean goFurther = true;
         double currNormedDist;
         double currLat;
         double currLon;
         int currNode;
-        final double queryLat;
-        final double queryLon;
-        final GHBitSet checkBitset;
-        final EdgeFilter edgeFilter;
 
-        public XFirstSearchCheck( double queryLat, double queryLon, GHBitSet checkBitset, EdgeFilter edgeFilter )
-        {
+        public XFirstSearchCheck(double queryLat, double queryLon, GHBitSet checkBitset, EdgeFilter edgeFilter) {
             this.queryLat = queryLat;
             this.queryLon = queryLon;
             this.checkBitset = checkBitset;
@@ -875,14 +854,12 @@ public XFirstSearchCheck( double queryLat, double queryLon, GHBitSet checkBitset
         }
 
         @Override
-        protected GHBitSet createBitSet()
-        {
+        protected GHBitSet createBitSet() {
             return checkBitset;
         }
 
         @Override
-        protected boolean goFurther( int baseNode )
-        {
+        protected boolean goFurther(int baseNode) {
             currNode = baseNode;
             currLat = nodeAccess.getLatitude(baseNode);
             currLon = nodeAccess.getLongitude(baseNode);
@@ -891,19 +868,16 @@ protected boolean goFurther( int baseNode )
         }
 
         @Override
-        protected boolean checkAdjacent( EdgeIteratorState currEdge )
-        {
+        protected boolean checkAdjacent(EdgeIteratorState currEdge) {
             goFurther = false;
-            if (!edgeFilter.accept(currEdge))
-            {
+            if (!edgeFilter.accept(currEdge)) {
                 // only limit the adjNode to a certain radius as currNode could be the wrong side of a valid edge
                 // goFurther = currDist < minResolution2InMeterNormed;
                 return true;
             }
 
             int tmpClosestNode = currNode;
-            if (check(tmpClosestNode, currNormedDist, 0, currEdge, QueryResult.Position.TOWER))
-            {
+            if (check(tmpClosestNode, currNormedDist, 0, currEdge, QueryResult.Position.TOWER)) {
                 if (currNormedDist <= equalNormedDelta)
                     return false;
             }
@@ -921,31 +895,25 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
             double tmpNormedDist;
             PointList pointList = currEdge.fetchWayGeometry(2);
             int len = pointList.getSize();
-            for (int pointIndex = 0; pointIndex < len; pointIndex++)
-            {
+            for (int pointIndex = 0; pointIndex < len; pointIndex++) {
                 double wayLat = pointList.getLatitude(pointIndex);
                 double wayLon = pointList.getLongitude(pointIndex);
                 QueryResult.Position pos = QueryResult.Position.EDGE;
-                if (distCalc.isCrossBoundary(tmpLon, wayLon))
-                {
+                if (distCalc.isCrossBoundary(tmpLon, wayLon)) {
                     tmpLat = wayLat;
                     tmpLon = wayLon;
                     continue;
                 }
 
-                if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, wayLat, wayLon))
-                {
+                if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, wayLat, wayLon)) {
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             tmpLat, tmpLon, wayLat, wayLon);
                     check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else
-                {
-                    if (pointIndex + 1 == len)
-                    {
+                } else {
+                    if (pointIndex + 1 == len) {
                         tmpNormedDist = adjDist;
                         pos = QueryResult.Position.TOWER;
-                    } else
-                    {
+                    } else {
                         tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
                         pos = QueryResult.Position.PILLAR;
                     }
@@ -963,118 +931,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
 
         protected abstract double getQueryDistance();
 
-        protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
-    }
-
-    // make entries static as otherwise we get an additional reference to this class (memory waste)
-    interface InMemEntry
-    {
-        boolean isLeaf();
-    }
-
-    static class InMemLeafEntry extends SortedIntSet implements InMemEntry
-    {
-        // private long key;
-
-        public InMemLeafEntry( int count, long key )
-        {
-            super(count);
-            // this.key = key;
-        }
-
-        public boolean addNode( int nodeId )
-        {
-            return addOnce(nodeId);
-        }
-
-        @Override
-        public final boolean isLeaf()
-        {
-            return true;
-        }
-
-        @Override
-        public String toString()
-        {
-            return "LEAF " + /*key +*/ " " + super.toString();
-        }
-
-        TIntArrayList getResults()
-        {
-            return this;
-        }
-    }
-
-    // Space efficient sorted integer set. Suited for only a few entries.
-    static class SortedIntSet extends TIntArrayList
-    {
-        public SortedIntSet()
-        {
-        }
-
-        public SortedIntSet( int capacity )
-        {
-            super(capacity);
-        }
-
-        /**
-         * Allow adding a value only once
-         */
-        public boolean addOnce( int value )
-        {
-            int foundIndex = binarySearch(value);
-            if (foundIndex >= 0)
-            {
-                return false;
-            }
-            foundIndex = -foundIndex - 1;
-            insert(foundIndex, value);
-            return true;
-        }
-    }
-
-    static class InMemTreeEntry implements InMemEntry
-    {
-        InMemEntry[] subEntries;
-
-        public InMemTreeEntry( int subEntryNo )
-        {
-            subEntries = new InMemEntry[subEntryNo];
-        }
-
-        public InMemEntry getSubEntry( int index )
-        {
-            return subEntries[index];
-        }
-
-        public void setSubEntry( int index, InMemEntry subEntry )
-        {
-            this.subEntries[index] = subEntry;
-        }
-
-        public Collection<InMemEntry> getSubEntriesForDebug()
-        {
-            List<InMemEntry> list = new ArrayList<InMemEntry>();
-            for (InMemEntry e : subEntries)
-            {
-                if (e != null)
-                {
-                    list.add(e);
-                }
-            }
-            return list;
-        }
-
-        @Override
-        public final boolean isLeaf()
-        {
-            return false;
-        }
-
-        @Override
-        public String toString()
-        {
-            return "TREE";
-        }
+        protected abstract boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/PointEmitter.java b/core/src/main/java/com/graphhopper/storage/index/PointEmitter.java
index 55a9cf9761..9312ae7c0b 100755
--- a/core/src/main/java/com/graphhopper/storage/index/PointEmitter.java
+++ b/core/src/main/java/com/graphhopper/storage/index/PointEmitter.java
@@ -20,7 +20,6 @@
 /**
  * @author Peter Karich
  */
-public interface PointEmitter
-{
-    void set( double lat, double lon );
+public interface PointEmitter {
+    void set(double lat, double lon);
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 9025cf6620..7c1c90bfc4 100755
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -32,66 +32,43 @@
  * T--S----N
  * </pre>
  * <p>
+ *
  * @author Peter Karich
  */
-public class QueryResult
-{
+public class QueryResult {
+    private final GHPoint queryPoint;
     private double queryDistance = Double.MAX_VALUE;
     private int wayIndex = -1;
     private int closestNode = -1;
     private EdgeIteratorState closestEdge;
-    private final GHPoint queryPoint;
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
 
-    /**
-     * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
-     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
-     * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
-     * a default precision of 1e-6.
-     * <p>
-     * @see DistanceCalc#validEdgeDistance
-     */
-    public static enum Position
-    {
-        EDGE, TOWER, PILLAR
-    }
-
-    public QueryResult( double queryLat, double queryLon )
-    {
+    public QueryResult(double queryLat, double queryLon) {
         queryPoint = new GHPoint(queryLat, queryLon);
     }
 
-    public void setClosestNode( int node )
-    {
-        closestNode = node;
-    }
-
     /**
      * @return the closest matching node. -1 if nothing found, this should be avoided via a call of
      * 'isValid'
      */
-    public int getClosestNode()
-    {
+    public int getClosestNode() {
         return closestNode;
     }
 
-    public void setQueryDistance( double dist )
-    {
-        queryDistance = dist;
+    public void setClosestNode(int node) {
+        closestNode = node;
     }
 
     /**
      * @return the distance of the query to the snapped coordinates. In meter
      */
-    public double getQueryDistance()
-    {
+    public double getQueryDistance() {
         return queryDistance;
     }
 
-    public void setWayIndex( int wayIndex )
-    {
-        this.wayIndex = wayIndex;
+    public void setQueryDistance(double dist) {
+        queryDistance = dist;
     }
 
     /**
@@ -100,47 +77,44 @@ public void setWayIndex( int wayIndex )
      * wayGeometry indices (minus one) and L+1 to the *adjacent* node. Currently only initialized if
      * returned from Location2NodesNtree.
      */
-    public int getWayIndex()
-    {
+    public int getWayIndex() {
         return wayIndex;
     }
 
-    public void setSnappedPosition( Position pos )
-    {
-        this.snappedPosition = pos;
+    public void setWayIndex(int wayIndex) {
+        this.wayIndex = wayIndex;
     }
 
     /**
      * @return 0 if on edge. 1 if on pillar node and 2 if on tower node.
      */
-    public Position getSnappedPosition()
-    {
+    public Position getSnappedPosition() {
         return snappedPosition;
     }
 
+    public void setSnappedPosition(Position pos) {
+        this.snappedPosition = pos;
+    }
+
     /**
      * @return true if a close node was found
      */
-    public boolean isValid()
-    {
+    public boolean isValid() {
         return closestNode >= 0;
     }
 
-    public void setClosestEdge( EdgeIteratorState detach )
-    {
-        closestEdge = detach;
-    }
-
     /**
      * @return the closest matching edge. Will be null if nothing found or call isValid before
      */
-    public EdgeIteratorState getClosestEdge()
-    {
+    public EdgeIteratorState getClosestEdge() {
         return closestEdge;
     }
 
-    public GHPoint getQueryPoint()
-    {
+    public void setClosestEdge(EdgeIteratorState detach) {
+        closestEdge = detach;
+    }
+
+    public GHPoint getQueryPoint() {
         return queryPoint;
     }
 
@@ -148,8 +122,7 @@ public GHPoint getQueryPoint()
      * Calculates the position of the query point 'snapped' to a close road segment or node. Call
      * calcSnappedPoint before, if not, an IllegalStateException is thrown.
      */
-    public GHPoint3D getSnappedPoint()
-    {
+    public GHPoint3D getSnappedPoint() {
         if (snappedPoint == null)
             throw new IllegalStateException("Calculate snapped point before!");
         return snappedPoint;
@@ -158,8 +131,7 @@ public GHPoint3D getSnappedPoint()
     /**
      * Calculates the closet point on the edge from the query point.
      */
-    public void calcSnappedPoint( DistanceCalc distCalc )
-    {
+    public void calcSnappedPoint(DistanceCalc distCalc) {
         if (closestEdge == null)
             throw new IllegalStateException("No closest edge?");
         if (snappedPoint != null)
@@ -169,16 +141,14 @@ public void calcSnappedPoint( DistanceCalc distCalc )
         double tmpLat = fullPL.getLatitude(wayIndex);
         double tmpLon = fullPL.getLongitude(wayIndex);
         double tmpEle = fullPL.getElevation(wayIndex);
-        if (snappedPosition != Position.EDGE)
-        {
+        if (snappedPosition != Position.EDGE) {
             snappedPoint = new GHPoint3D(tmpLat, tmpLon, tmpEle);
             return;
         }
 
         double queryLat = getQueryPoint().lat, queryLon = getQueryPoint().lon;
         double adjLat = fullPL.getLatitude(wayIndex + 1), adjLon = fullPL.getLongitude(wayIndex + 1);
-        if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon))
-        {
+        if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon)) {
             GHPoint tmpPoint = distCalc.calcCrossingPointToEdge(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon);
             double adjEle = fullPL.getElevation(wayIndex + 1);
             snappedPoint = new GHPoint3D(tmpPoint.lat, tmpPoint.lon, (tmpEle + adjEle) / 2);
@@ -188,10 +158,22 @@ public void calcSnappedPoint( DistanceCalc distCalc )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         if (closestEdge != null)
             return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint;
         return closestNode + ", " + queryPoint + ", " + wayIndex;
     }
+
+    /**
+     * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
+     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
+     * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
+     * a default precision of 1e-6.
+     * <p>
+     *
+     * @see DistanceCalc#validEdgeDistance
+     */
+    public static enum Position {
+        EDGE, TOWER, PILLAR
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 1d10c36717..7fa179882b 100755
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -24,26 +24,23 @@
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
  * <p>
+ *
  * @author Johannes Pelzer
  * @author Peter Karich
  */
-public class AngleCalc
-{
+public class AngleCalc {
     private final static double PI_4 = Math.PI / 4.0;
     private final static double PI_2 = Math.PI / 2.0;
     private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
-    static final double atan2( double y, double x )
-    {
+    static final double atan2(double y, double x) {
         // kludge to prevent 0/0 condition
         double absY = Math.abs(y) + 1e-10;
         double r, angle;
-        if (x < 0.0)
-        {
+        if (x < 0.0) {
             r = (x + absY) / (absY - x);
             angle = PI3_4;
-        } else
-        {
+        } else {
             r = (x - absY) / (x + absY);
             angle = PI_4;
         }
@@ -58,10 +55,10 @@ static final double atan2( double y, double x )
     /**
      * Return orientation of line relative to east.
      * <p>
+     *
      * @return Orientation in interval -pi to +pi where 0 is east
      */
-    public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
-    {
+    public double calcOrientation(double lat1, double lon1, double lat2, double lon2) {
         double shrinkFactor = cos(toRadians((lat1 + lat2) / 2));
         return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
@@ -69,15 +66,15 @@ public double calcOrientation( double lat1, double lon1, double lat2, double lon
     /**
      * convert north based clockwise azimuth (0, 360) into x-axis/east based angle (-Pi, Pi)
      */
-    public double convertAzimuth2xaxisAngle(double azimuth)
-    {
-        if (Double.compare(azimuth, 360)>0 || Double.compare(azimuth, 0)<0)
-        {
+    public double convertAzimuth2xaxisAngle(double azimuth) {
+        if (Double.compare(azimuth, 360) > 0 || Double.compare(azimuth, 0) < 0) {
             throw new IllegalArgumentException("Azimuth " + azimuth + " must be in (0, 360)");
         }
-        double angleXY = PI_2 - azimuth/180.*Math.PI;
-        if (angleXY<-Math.PI) angleXY += 2*Math.PI;
-        if (angleXY>Math.PI) angleXY -= 2*Math.PI;
+        double angleXY = PI_2 - azimuth / 180. * Math.PI;
+        if (angleXY < -Math.PI)
+            angleXY += 2 * Math.PI;
+        if (angleXY > Math.PI)
+            angleXY -= 2 * Math.PI;
         return angleXY;
     }
 
@@ -86,23 +83,18 @@ public double convertAzimuth2xaxisAngle(double azimuth)
      * will be smaller or equal to PI (180 degree). This is achieved by adding or substracting a
      * 2*PI, so the direction of the orientation will not be changed
      */
-    public double alignOrientation( double baseOrientation, double orientation )
-    {
+    public double alignOrientation(double baseOrientation, double orientation) {
         double resultOrientation;
-        if (baseOrientation >= 0)
-        {
+        if (baseOrientation >= 0) {
             if (orientation < -Math.PI + baseOrientation)
                 resultOrientation = orientation + 2 * Math.PI;
             else
                 resultOrientation = orientation;
 
-        } else
-        {
-            if (orientation > +Math.PI + baseOrientation)
-                resultOrientation = orientation - 2 * Math.PI;
-            else
-                resultOrientation = orientation;
-        }
+        } else if (orientation > +Math.PI + baseOrientation)
+            resultOrientation = orientation - 2 * Math.PI;
+        else
+            resultOrientation = orientation;
         return resultOrientation;
     }
 
@@ -110,8 +102,7 @@ public double alignOrientation( double baseOrientation, double orientation )
      * Calculate the azimuth in degree for a line given by two coordinates. Direction in 'degree'
      * where 0 is north, 90 is east, 180 is south and 270 is west.
      */
-    double calcAzimuth( double lat1, double lon1, double lat2, double lon2 )
-    {
+    double calcAzimuth(double lat1, double lon1, double lat2, double lon2) {
         double orientation = -calcOrientation(lat1, lon1, lat2, lon2);
         orientation = Helper.round4(orientation + Math.PI / 2);
         if (orientation < 0)
@@ -120,37 +111,27 @@ public double alignOrientation( double baseOrientation, double orientation )
         return Math.toDegrees(orientation);
     }
 
-    String azimuth2compassPoint( double azimuth )
-    {
+    String azimuth2compassPoint(double azimuth) {
 
         String cp;
         double slice = 360.0 / 16;
-        if (azimuth < slice)
-        {
+        if (azimuth < slice) {
             cp = "N";
-        } else if (azimuth < slice * 3)
-        {
+        } else if (azimuth < slice * 3) {
             cp = "NE";
-        } else if (azimuth < slice * 5)
-        {
+        } else if (azimuth < slice * 5) {
             cp = "E";
-        } else if (azimuth < slice * 7)
-        {
+        } else if (azimuth < slice * 7) {
             cp = "SE";
-        } else if (azimuth < slice * 9)
-        {
+        } else if (azimuth < slice * 9) {
             cp = "S";
-        } else if (azimuth < slice * 11)
-        {
+        } else if (azimuth < slice * 11) {
             cp = "SW";
-        } else if (azimuth < slice * 13)
-        {
+        } else if (azimuth < slice * 13) {
             cp = "W";
-        } else if (azimuth < slice * 15)
-        {
+        } else if (azimuth < slice * 15) {
             cp = "NW";
-        } else
-        {
+        } else {
             cp = "N";
         }
         return cp;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index e38006621d..75265c42a3 100755
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -26,11 +26,11 @@
  * 1=&gt;1110 1011
  * 2=&gt;...
  * </pre> LITTLE endianess is default for GraphHopper and most microprocessors.
- * <p>
+ *
+ *
  * @author Peter Karich
  */
-public abstract class BitUtil
-{
+public abstract class BitUtil {
     /**
      * Default for GraphHopper
      */
@@ -40,146 +40,124 @@
      */
     public static final BitUtil BIG = new BitUtilBig();
 
-    public static BitUtil get( ByteOrder order )
-    {
+    public static BitUtil get(ByteOrder order) {
         if (order.equals(ByteOrder.BIG_ENDIAN))
             return BitUtil.BIG;
         else
             return BitUtil.LITTLE;
     }
 
-    public final double toDouble( byte[] bytes )
-    {
+    public final double toDouble(byte[] bytes) {
         return toDouble(bytes, 0);
     }
 
-    public final double toDouble( byte[] bytes, int offset )
-    {
+    public final double toDouble(byte[] bytes, int offset) {
         return Double.longBitsToDouble(toLong(bytes, offset));
     }
 
-    public final byte[] fromDouble( double value )
-    {
+    public final byte[] fromDouble(double value) {
         byte[] bytes = new byte[8];
         fromDouble(bytes, value, 0);
         return bytes;
     }
 
-    public final void fromDouble( byte[] bytes, double value )
-    {
+    public final void fromDouble(byte[] bytes, double value) {
         fromDouble(bytes, value, 0);
     }
 
-    public final void fromDouble( byte[] bytes, double value, int offset )
-    {
+    public final void fromDouble(byte[] bytes, double value, int offset) {
         fromLong(bytes, Double.doubleToRawLongBits(value), offset);
     }
 
-    public final float toFloat( byte[] bytes )
-    {
+    public final float toFloat(byte[] bytes) {
         return toFloat(bytes, 0);
     }
 
-    public final float toFloat( byte[] bytes, int offset )
-    {
+    public final float toFloat(byte[] bytes, int offset) {
         return Float.intBitsToFloat(toInt(bytes, offset));
     }
 
-    public final byte[] fromFloat( float value )
-    {
+    public final byte[] fromFloat(float value) {
         byte[] bytes = new byte[4];
         fromFloat(bytes, value, 0);
         return bytes;
     }
 
-    public final void fromFloat( byte[] bytes, float value )
-    {
+    public final void fromFloat(byte[] bytes, float value) {
         fromFloat(bytes, value, 0);
     }
 
-    public final void fromFloat( byte[] bytes, float value, int offset )
-    {
+    public final void fromFloat(byte[] bytes, float value, int offset) {
         fromInt(bytes, Float.floatToRawIntBits(value), offset);
     }
 
-    public final short toShort( byte[] b )
-    {
+    public final short toShort(byte[] b) {
         return toShort(b, 0);
     }
 
-    public abstract short toShort( byte[] b, int offset );
+    public abstract short toShort(byte[] b, int offset);
 
-    public final int toInt( byte[] b )
-    {
+    public final int toInt(byte[] b) {
         return toInt(b, 0);
     }
 
-    public abstract int toInt( byte[] b, int offset );
+    public abstract int toInt(byte[] b, int offset);
 
-    public final byte[] fromInt( int value )
-    {
+    public final byte[] fromInt(int value) {
         byte[] bytes = new byte[4];
         fromInt(bytes, value, 0);
         return bytes;
     }
 
-    public final void fromInt( byte[] bytes, int value )
-    {
+    public final void fromInt(byte[] bytes, int value) {
         fromInt(bytes, value, 0);
     }
 
-    public final byte[] fromShort( short value )
-    {
+    public final byte[] fromShort(short value) {
         byte[] bytes = new byte[4];
         fromShort(bytes, value, 0);
         return bytes;
     }
 
-    public final void fromShort( byte[] bytes, short value )
-    {
+    public final void fromShort(byte[] bytes, short value) {
         fromShort(bytes, value, 0);
     }
 
-    public abstract void fromShort( byte[] bytes, short value, int offset );
+    public abstract void fromShort(byte[] bytes, short value, int offset);
 
-    public abstract void fromInt( byte[] bytes, int value, int offset );
+    public abstract void fromInt(byte[] bytes, int value, int offset);
 
-    public final long toLong( byte[] b )
-    {
+    public final long toLong(byte[] b) {
         return toLong(b, 0);
     }
 
-    public abstract long toLong( int high, int low );
+    public abstract long toLong(int high, int low);
 
-    public abstract long toLong( byte[] b, int offset );
+    public abstract long toLong(byte[] b, int offset);
 
-    public final byte[] fromLong( long value )
-    {
+    public final byte[] fromLong(long value) {
         byte[] bytes = new byte[8];
         fromLong(bytes, value, 0);
         return bytes;
     }
 
-    public final void fromLong( byte[] bytes, long value )
-    {
+    public final void fromLong(byte[] bytes, long value) {
         fromLong(bytes, value, 0);
     }
 
-    public abstract void fromLong( byte[] bytes, long value, int offset );
+    public abstract void fromLong(byte[] bytes, long value, int offset);
 
     /**
      * The only purpose of this method is to test 'reverse'. toBitString is the reverse and both are
      * indepentent of the endianness.
      */
-    public final long fromBitString2Long( String str )
-    {
+    public final long fromBitString2Long(String str) {
         if (str.length() > 64)
             throw new UnsupportedOperationException("Strings needs to fit into a 'long' but length was " + str.length());
 
         long res = 0;
         int strLen = str.length();
-        for (int charIndex = 0; charIndex < strLen; charIndex++)
-        {
+        for (int charIndex = 0; charIndex < strLen; charIndex++) {
             res <<= 1;
             if (str.charAt(charIndex) != '0')
                 res |= 1;
@@ -188,22 +166,19 @@ public final long fromBitString2Long( String str )
         return res;
     }
 
-    public abstract byte[] fromBitString( String str );
+    public abstract byte[] fromBitString(String str);
 
     /**
      * Similar to Long.toBinaryString
      */
-    public final String toBitString( long value )
-    {
+    public final String toBitString(long value) {
         return toBitString(value, 64);
     }
 
-    public String toLastBitString( long value, int bits )
-    {
+    public String toLastBitString(long value, int bits) {
         StringBuilder sb = new StringBuilder(bits);
         long lastBit = 1L << bits - 1;
-        for (int i = 0; i < bits; i++)
-        {
+        for (int i = 0; i < bits; i++) {
             if ((value & lastBit) == 0)
                 sb.append('0');
             else
@@ -217,14 +192,13 @@ public String toLastBitString( long value, int bits )
     /**
      * Higher order bits comes first in the returned string.
      * <p>
+     *
      * @param bits how many bits should be returned.
      */
-    public String toBitString( long value, int bits )
-    {
+    public String toBitString(long value, int bits) {
         StringBuilder sb = new StringBuilder(bits);
         long lastBit = 1L << 63;
-        for (int i = 0; i < bits; i++)
-        {
+        for (int i = 0; i < bits; i++) {
             if ((value & lastBit) == 0)
                 sb.append('0');
             else
@@ -238,24 +212,22 @@ public String toBitString( long value, int bits )
     /**
      * Higher order bits comes first in the returned string.
      */
-    public abstract String toBitString( byte[] bytes );
+    public abstract String toBitString(byte[] bytes);
 
     /**
      * Reverses the bits in the specified long value and it removes the remaining higher bits. See
      * also http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious
      * <p>
+     *
      * @param maxBits the maximum number of recognized bits for reversal
      */
-    public final long reverse( long value, int maxBits )
-    {
+    public final long reverse(long value, int maxBits) {
         long res = 0;
-        for (; maxBits > 0; value >>>= 1)
-        {
+        for (; maxBits > 0; value >>>= 1) {
             res <<= 1;
             res |= value & 1;
             maxBits--;
-            if (value == 0)
-            {
+            if (value == 0) {
                 res <<= maxBits;
                 break;
             }
@@ -263,35 +235,29 @@ public final long reverse( long value, int maxBits )
         return res;
     }
 
-    public final int getIntLow( long longValue )
-    {
+    public final int getIntLow(long longValue) {
         return (int) (longValue & 0xFFFFFFFFL);
     }
 
-    public final int getIntHigh( long longValue )
-    {
+    public final int getIntHigh(long longValue) {
         return (int) (longValue >> 32);
     }
 
-    public final long combineIntsToLong( int intLow, int intHigh )
-    {
+    public final long combineIntsToLong(int intLow, int intHigh) {
         return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
     }
 
-    public final long reverseLeft( long value, int maxBits )
-    {
+    public final long reverseLeft(long value, int maxBits) {
         long res = 0;
         int delta = 64 - maxBits;
         long maxBit = 1L << delta;
-        for (; maxBits > 0; res <<= 1)
-        {
+        for (; maxBits > 0; res <<= 1) {
             if ((value & maxBit) != 0)
                 res |= 1;
 
             maxBit <<= 1;
             maxBits--;
-            if (maxBit == 0)
-            {
+            if (maxBit == 0) {
                 res <<= delta;
                 break;
             }
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilBig.java b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
index b46813c602..1c263c1407 100755
--- a/core/src/main/java/com/graphhopper/util/BitUtilBig.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
@@ -20,37 +20,32 @@
 /**
  * Conversion between "the memory" (integer/long/float/double/string) to bytes via BIG endianess.
  * <p>
+ *
  * @author Peter Karich
  */
-public class BitUtilBig extends BitUtil
-{
-    BitUtilBig()
-    {
+public class BitUtilBig extends BitUtil {
+    BitUtilBig() {
     }
 
     @Override
-    public final short toShort( byte[] b, int offset )
-    {
+    public final short toShort(byte[] b, int offset) {
         return (short) ((b[offset] & 0xFF) << 8 | (b[offset + 1] & 0xFF));
     }
 
     @Override
-    public final int toInt( byte[] b, int offset )
-    {
+    public final int toInt(byte[] b, int offset) {
         return (b[offset] & 0xFF) << 24 | (b[++offset] & 0xFF) << 16
                 | (b[++offset] & 0xFF) << 8 | (b[++offset] & 0xFF);
     }
 
     @Override
-    public void fromShort( byte[] bytes, short value, int offset )
-    {
+    public void fromShort(byte[] bytes, short value, int offset) {
         bytes[offset] = (byte) (value >> 8);
         bytes[offset + 1] = (byte) (value);
     }
 
     @Override
-    public final void fromInt( byte[] bytes, int value, int offset )
-    {
+    public final void fromInt(byte[] bytes, int value, int offset) {
         bytes[offset] = (byte) (value >> 24);
         bytes[++offset] = (byte) (value >> 16);
         bytes[++offset] = (byte) (value >> 8);
@@ -58,20 +53,17 @@ public final void fromInt( byte[] bytes, int value, int offset )
     }
 
     @Override
-    public final long toLong( int int0, int int1 )
-    {
+    public final long toLong(int int0, int int1) {
         return ((long) int0 << 32) | (int1 & 0xFFFFFFFFL);
     }
 
     @Override
-    public final long toLong( byte[] b, int offset )
-    {
+    public final long toLong(byte[] b, int offset) {
         return ((long) toInt(b, offset) << 32) | (toInt(b, offset + 4) & 0xFFFFFFFFL);
     }
 
     @Override
-    public final void fromLong( byte[] bytes, long value, int offset )
-    {
+    public final void fromLong(byte[] bytes, long value, int offset) {
         bytes[offset] = (byte) (value >> 56);
         bytes[++offset] = (byte) (value >> 48);
         bytes[++offset] = (byte) (value >> 40);
@@ -83,8 +75,7 @@ public final void fromLong( byte[] bytes, long value, int offset )
     }
 
     @Override
-    public byte[] fromBitString( String str )
-    {
+    public byte[] fromBitString(String str) {
         // no need for performance or memory tuning ...        
         int strLen = str.length();
         int bLen = str.length() / 8;
@@ -93,11 +84,9 @@ public final void fromLong( byte[] bytes, long value, int offset )
 
         byte[] bytes = new byte[bLen];
         int charI = 0;
-        for (int b = 0; b < bLen; b++)
-        {
+        for (int b = 0; b < bLen; b++) {
             byte res = 0;
-            for (int i = 0; i < 8; i++)
-            {
+            for (int i = 0; i < 8; i++) {
                 res <<= 1;
                 if (charI < strLen && str.charAt(charI) != '0')
                     res |= 1;
@@ -110,14 +99,11 @@ public final void fromLong( byte[] bytes, long value, int offset )
     }
 
     @Override
-    public String toBitString( byte[] bytes )
-    {
+    public String toBitString(byte[] bytes) {
         StringBuilder sb = new StringBuilder(bytes.length * 8);
         byte lastBit = (byte) (1 << 7);
-        for (byte b : bytes)
-        {
-            for (int i = 0; i < 8; i++)
-            {
+        for (byte b : bytes) {
+            for (int i = 0; i < 8; i++) {
                 if ((b & lastBit) == 0)
                     sb.append('0');
                 else
@@ -132,15 +118,13 @@ public String toBitString( byte[] bytes )
     /**
      * Touches only the specified bits - it does not zero out the higher bits (like reverse does).
      */
-    final long reversePart( long v, int maxBits )
-    {
+    final long reversePart(long v, int maxBits) {
         long rest = v & (~((1L << maxBits) - 1));
         return rest | reverse(v, maxBits);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "big";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index 7e56b6b0c9..5b4715551f 100755
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -20,37 +20,32 @@
 /**
  * Conversion between "the memory" (integer/long/float/double/string) to bytes via little endianess.
  * <p>
+ *
  * @author Peter Karich
  */
-public class BitUtilLittle extends BitUtil
-{
-    BitUtilLittle()
-    {
+public class BitUtilLittle extends BitUtil {
+    BitUtilLittle() {
     }
 
     @Override
-    public final short toShort( byte[] b, int offset )
-    {
+    public final short toShort(byte[] b, int offset) {
         return (short) ((b[offset + 1] & 0xFF) << 8 | (b[offset] & 0xFF));
     }
 
     @Override
-    public final int toInt( byte[] b, int offset )
-    {
+    public final int toInt(byte[] b, int offset) {
         return (b[offset + 3] & 0xFF) << 24 | (b[offset + 2] & 0xFF) << 16
                 | (b[offset + 1] & 0xFF) << 8 | (b[offset] & 0xFF);
     }
 
     @Override
-    public void fromShort( byte[] bytes, short value, int offset )
-    {
+    public void fromShort(byte[] bytes, short value, int offset) {
         bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
     @Override
-    public final void fromInt( byte[] bytes, int value, int offset )
-    {
+    public final void fromInt(byte[] bytes, int value, int offset) {
         bytes[offset + 3] = (byte) (value >>> 24);
         bytes[offset + 2] = (byte) (value >>> 16);
         bytes[offset + 1] = (byte) (value >>> 8);
@@ -58,20 +53,17 @@ public final void fromInt( byte[] bytes, int value, int offset )
     }
 
     @Override
-    public final long toLong( int int0, int int1 )
-    {
+    public final long toLong(int int0, int int1) {
         return ((long) int1 << 32) | (int0 & 0xFFFFFFFFL);
     }
 
     @Override
-    public final long toLong( byte[] b, int offset )
-    {
+    public final long toLong(byte[] b, int offset) {
         return ((long) toInt(b, offset + 4) << 32) | (toInt(b, offset) & 0xFFFFFFFFL);
     }
 
     @Override
-    public final void fromLong( byte[] bytes, long value, int offset )
-    {
+    public final void fromLong(byte[] bytes, long value, int offset) {
         bytes[offset + 7] = (byte) (value >> 56);
         bytes[offset + 6] = (byte) (value >> 48);
         bytes[offset + 5] = (byte) (value >> 40);
@@ -83,8 +75,7 @@ public final void fromLong( byte[] bytes, long value, int offset )
     }
 
     @Override
-    public byte[] fromBitString( String str )
-    {
+    public byte[] fromBitString(String str) {
         // no need for performance or memory tuning ...        
         int strLen = str.length();
         int bLen = str.length() / 8;
@@ -93,11 +84,9 @@ public final void fromLong( byte[] bytes, long value, int offset )
 
         byte[] bytes = new byte[bLen];
         int charI = 0;
-        for (int b = bLen - 1; b >= 0; b--)
-        {
+        for (int b = bLen - 1; b >= 0; b--) {
             byte res = 0;
-            for (int i = 0; i < 8; i++)
-            {
+            for (int i = 0; i < 8; i++) {
                 res <<= 1;
                 if (charI < strLen && str.charAt(charI) != '0')
                     res |= 1;
@@ -110,15 +99,12 @@ public final void fromLong( byte[] bytes, long value, int offset )
     }
 
     @Override
-    public String toBitString( byte[] bytes )
-    {
+    public String toBitString(byte[] bytes) {
         StringBuilder sb = new StringBuilder(bytes.length * 8);
         byte lastBit = (byte) (1 << 7);
-        for (int bIndex = bytes.length - 1; bIndex >= 0; bIndex--)
-        {
+        for (int bIndex = bytes.length - 1; bIndex >= 0; bIndex--) {
             byte b = bytes[bIndex];
-            for (int i = 0; i < 8; i++)
-            {
+            for (int i = 0; i < 8; i++) {
                 if ((b & lastBit) == 0)
                     sb.append('0');
                 else
@@ -131,8 +117,7 @@ public String toBitString( byte[] bytes )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "little";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
index ce09a26394..be5009a74b 100755
--- a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -22,30 +22,26 @@
 /**
  * Implementattion of breadth first search (BFS)
  * <p>
+ *
  * @author Peter Karich
  */
-public class BreadthFirstSearch extends XFirstSearch
-{
+public class BreadthFirstSearch extends XFirstSearch {
     @Override
-    public void start( EdgeExplorer explorer, int startNode )
-    {
+    public void start(EdgeExplorer explorer, int startNode) {
         SimpleIntDeque fifo = new SimpleIntDeque();
         GHBitSet visited = createBitSet();
         visited.add(startNode);
         fifo.push(startNode);
         int current;
-        while (!fifo.isEmpty())
-        {
+        while (!fifo.isEmpty()) {
             current = fifo.pop();
             if (!goFurther(current))
                 continue;
 
             EdgeIterator iter = explorer.setBaseNode(current);
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int connectedId = iter.getAdjNode();
-                if (checkAdjacent(iter) && !visited.contains(connectedId))
-                {
+                if (checkAdjacent(iter) && !visited.contains(connectedId)) {
                     visited.add(connectedId);
                     fifo.push(connectedId);
                 }
diff --git a/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
index 0183034f1e..157d4c69dd 100755
--- a/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
@@ -22,11 +22,11 @@
 /**
  * The edge explorer for CHGraph
  * <p>
+ *
  * @author Peter Karich
  * @see CHGraph
  */
-public interface CHEdgeExplorer extends EdgeExplorer
-{
+public interface CHEdgeExplorer extends EdgeExplorer {
     @Override
-    CHEdgeIterator setBaseNode( int baseNode );
+    CHEdgeIterator setBaseNode(int baseNode);
 }
diff --git a/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
index d06eebc000..01dfc0504b 100755
--- a/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
@@ -22,9 +22,9 @@
 /**
  * Support for CH edges
  * <p>
+ *
  * @author Peter Karich
  * @see CHGraph
  */
-public interface CHEdgeIterator extends EdgeIterator, CHEdgeIteratorState
-{
+public interface CHEdgeIterator extends EdgeIterator, CHEdgeIteratorState {
 }
diff --git a/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
index a5d3fe8190..c9651fb269 100755
--- a/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
@@ -23,12 +23,12 @@
 /**
  * The state returned from the EdgeIterator of a CHGraph
  * <p>
+ *
  * @author Peter Karich
  * @see CHGraph
  * @see CHEdgeIterator
  */
-public interface CHEdgeIteratorState extends EdgeIteratorState
-{
+public interface CHEdgeIteratorState extends EdgeIteratorState {
     int getSkippedEdge1();
 
     int getSkippedEdge2();
@@ -36,7 +36,7 @@
     /**
      * Sets the edges that this shortcut skips. Those skipped edges can be shortcuts too.
      */
-    void setSkippedEdges( int edge1, int edge2 );
+    void setSkippedEdges(int edge1, int edge2);
 
     /**
      * @return true if this edge is a shortcut, false otherwise.
@@ -46,17 +46,18 @@
     /**
      * This method is only used on preparation.
      * <p>
+     *
      * @see PrepareEncoder#canBeOverwritten(long, long)
      */
-    boolean canBeOverwritten( long flags );
+    boolean canBeOverwritten(long flags);
 
     /**
-     * Sets the weight calculated from Weighting.calcWeight, only applicable if isShortcut is true.
+     * Returns the weight of this shortcut.
      */
-    CHEdgeIteratorState setWeight( double weight );
+    double getWeight();
 
     /**
-     * Returns the weight of this shortcut.
+     * Sets the weight calculated from Weighting.calcWeight, only applicable if isShortcut is true.
      */
-    double getWeight();
+    CHEdgeIteratorState setWeight(double weight);
 }
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 0b8e654b1a..39d13f65ba 100755
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -29,33 +29,23 @@
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
  * <p>
+ *
  * @author Peter Karich
  */
-public class CmdArgs extends PMap
-{
+public class CmdArgs extends PMap {
 
-    public CmdArgs()
-    {
+    public CmdArgs() {
     }
 
-    public CmdArgs( Map<String, String> map )
-    {
+    public CmdArgs(Map<String, String> map) {
         super(map);
     }
 
-    @Override
-    public CmdArgs put( String key, Object str )
-    {
-        super.put(key, str);
-        return this;
-    }
-
     /**
-     * @param fileStr the file name of config.properties
+     * @param fileStr        the file name of config.properties
      * @param systemProperty the property name of the configuration. E.g. -Dgraphhopper.config
      */
-    public static CmdArgs readFromConfig( String fileStr, String systemProperty ) throws IOException
-    {
+    public static CmdArgs readFromConfig(String fileStr, String systemProperty) throws IOException {
         if (systemProperty.startsWith("-D"))
             systemProperty = systemProperty.substring(2);
 
@@ -71,12 +61,10 @@ public static CmdArgs readFromConfig( String fileStr, String systemProperty ) th
 
         // overwrite with system settings
         Properties props = System.getProperties();
-        for (Entry<Object, Object> e : props.entrySet())
-        {
+        for (Entry<Object, Object> e : props.entrySet()) {
             String k = ((String) e.getKey());
             String v = ((String) e.getValue());
-            if (k.startsWith("graphhopper."))
-            {
+            if (k.startsWith("graphhopper.")) {
                 k = k.substring("graphhopper.".length());
                 args.put(k, v);
             }
@@ -84,25 +72,20 @@ public static CmdArgs readFromConfig( String fileStr, String systemProperty ) th
         return args;
     }
 
-    public static CmdArgs read( String[] args )
-    {
+    public static CmdArgs read(String[] args) {
         Map<String, String> map = new LinkedHashMap<String, String>();
-        for (String arg : args)
-        {
+        for (String arg : args) {
             int index = arg.indexOf("=");
-            if (index <= 0)
-            {
+            if (index <= 0) {
                 continue;
             }
 
             String key = arg.substring(0, index);
-            if (key.startsWith("-"))
-            {
+            if (key.startsWith("-")) {
                 key = key.substring(1);
             }
 
-            if (key.startsWith("-"))
-            {
+            if (key.startsWith("-")) {
                 key = key.substring(1);
             }
 
@@ -116,23 +99,26 @@ public static CmdArgs read( String[] args )
     /**
      * Command line configuration overwrites the ones in the config file.
      * <p>
+     *
      * @return a new CmdArgs object if necessary.
      */
-    public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
-    {
+    public static CmdArgs readFromConfigAndMerge(CmdArgs args, String configKey, String configSysAttr) {
         String configVal = args.get(configKey, "");
-        if (!Helper.isEmpty(configVal))
-        {
-            try
-            {
+        if (!Helper.isEmpty(configVal)) {
+            try {
                 CmdArgs tmp = CmdArgs.readFromConfig(configVal, configSysAttr);
                 tmp.merge(args);
                 return tmp;
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 throw new RuntimeException(ex);
             }
         }
         return args;
     }
+
+    @Override
+    public CmdArgs put(String key, Object str) {
+        super.put(key, str);
+        return this;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/ConfigMap.java b/core/src/main/java/com/graphhopper/util/ConfigMap.java
new file mode 100644
index 0000000000..74c4c93b3c
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/ConfigMap.java
@@ -0,0 +1,129 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A properties map (String to Object) with convenient accessors
+ * <p>
+ *
+ * @author Peter Karich
+ * @see PMap
+ */
+public class ConfigMap {
+    private final Map<String, Object> map;
+
+    public ConfigMap() {
+        this(5);
+    }
+
+    public ConfigMap(int capacity) {
+        this(new HashMap<String, Object>(capacity));
+    }
+
+    public ConfigMap(Map<String, Object> map) {
+        this.map = map;
+    }
+
+    public ConfigMap put(ConfigMap map) {
+        this.map.putAll(map.map);
+        return this;
+    }
+
+    String checkKey(String key) {
+        if (!key.toLowerCase().equals(key))
+            throw new NullPointerException("keys have to be lower case but wasn't: " + key);
+        return key;
+    }
+
+    public ConfigMap put(String key, Object obj) {
+        if (obj == null)
+            throw new NullPointerException("Value cannot be null for key " + key + ". Use remove instead.");
+
+        map.put(checkKey(key), obj);
+        return this;
+    }
+
+    public ConfigMap remove(String key) {
+        map.remove(checkKey(key));
+        return this;
+    }
+
+    public boolean has(String key) {
+        return map.containsKey(checkKey(key));
+    }
+
+    public long getLong(String key, long _default) {
+        Long t = (Long) map.get(checkKey(key));
+        if (t == null)
+            return _default;
+        return t;
+    }
+
+    public int getInt(String key, int _default) {
+        Integer t = (Integer) map.get(checkKey(key));
+        if (t == null)
+            return _default;
+        return t;
+    }
+
+    public boolean getBool(String key, boolean _default) {
+        Boolean t = (Boolean) map.get(checkKey(key));
+        if (t == null)
+            return _default;
+        return t;
+    }
+
+    public double getDouble(String key, double _default) {
+        Double t = (Double) map.get(checkKey(key));
+        if (t == null)
+            return _default;
+        return t;
+    }
+
+    public <T> T get(String key, T _default) {
+        T t = (T) map.get(checkKey(key));
+        if (t == null)
+            return _default;
+        return t;
+    }
+
+    public <T> Map<String, T> getMap(String key, Class<T> embed) {
+        return (Map<String, T>) map.get(checkKey(key));
+    }
+
+    public Map<String, Object> getMap(String key) {
+        return (Map<String, Object>) map.get(checkKey(key));
+    }
+
+    public List getList(String key) {
+        return (List) map.get(checkKey(key));
+    }
+
+    public <T> List<T> getList(String key, Class<T> embed) {
+        return (List<T>) map.get(checkKey(key));
+    }
+
+    @Override
+    public String toString() {
+        return map.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 3ed9c6c3a0..4b4aab0ec6 100755
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -18,16 +18,16 @@
 package com.graphhopper.util;
 
 import com.graphhopper.GraphHopper;
-import static com.graphhopper.util.Helper.readFile;
 
 import java.io.InputStreamReader;
 import java.util.List;
 
+import static com.graphhopper.util.Helper.readFile;
+
 /**
  * Defining several important constants for GraphHopper. Partially taken from Lucene.
  */
-public class Constants
-{
+public class Constants {
     /**
      * The value of <tt>System.getProperty("java.version")</tt>. *
      */
@@ -68,38 +68,26 @@
     public static final String BUILD_DATE;
     public static final boolean SNAPSHOT;
 
-    public static String getVersions()
-    {
-        return VERSION_NODE + "," + VERSION_EDGE + "," + VERSION_GEOMETRY + "," + VERSION_LOCATION_IDX
-                + "," + VERSION_NAME_IDX + "," + VERSION_SHORTCUT;
-    }
-
-    static
-    {
+    static {
         String version = "0.0";
-        try
-        {
-            // see com/graphhopper/version file in resources which is modified in the maven packaging process 
+        try {
+            // see com/graphhopper/version file in resources which is modified in the maven packaging process
             // to contain the current version
             List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), Helper.UTF_CS));
             version = v.get(0);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             System.err.println("GraphHopper Initialization ERROR: cannot read version!? " + ex.getMessage());
         }
         int indexM = version.indexOf("-");
-        if ("${project.version}".equals(version))
-        {
+        if ("${project.version}".equals(version)) {
             VERSION = "0.0";
             SNAPSHOT = true;
             System.err.println("GraphHopper Initialization WARNING: maven did not preprocess the version file! Do not use the jar for a release!");
-        } else if ("0.0".equals(version))
-        {
+        } else if ("0.0".equals(version)) {
             VERSION = "0.0";
             SNAPSHOT = true;
             System.err.println("GraphHopper Initialization WARNING: cannot get version!?");
-        } else
-        {
+        } else {
             String tmp = version;
             // throw away the "-SNAPSHOT"
             if (indexM >= 0)
@@ -109,22 +97,24 @@ public static String getVersions()
             VERSION = tmp;
         }
         String buildDate = "";
-        try
-        {
+        try {
             List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), Helper.UTF_CS));
             buildDate = v.get(0);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         BUILD_DATE = buildDate;
     }
 
-    public static String getMajorVersion()
-    {
+    public static String getVersions() {
+        return VERSION_NODE + "," + VERSION_EDGE + "," + VERSION_GEOMETRY + "," + VERSION_LOCATION_IDX
+                + "," + VERSION_NAME_IDX + "," + VERSION_SHORTCUT;
+    }
+
+    public static String getMajorVersion() {
         int firstIdx = VERSION.indexOf(".");
         if (firstIdx < 0)
             throw new IllegalStateException("Cannot extract major version from version " + VERSION);
-        
+
         int sndIdx = VERSION.indexOf(".", firstIdx + 1);
         if (sndIdx < 0)
             return VERSION;
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
index 53b614c9fd..e89f09678b 100755
--- a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -23,34 +23,29 @@
 /**
  * Implementation of depth first search (DFS) by LIFO queue
  * <p>
+ *
  * @author Peter Karich
  * @author Jan Sölter
  */
-public class DepthFirstSearch extends XFirstSearch
-{
+public class DepthFirstSearch extends XFirstSearch {
     /**
      * beginning with startNode add all following nodes to LIFO queue. If node has been already
      * explored before, skip reexploration.
      */
     @Override
-    public void start( EdgeExplorer explorer, int startNode )
-    {
+    public void start(EdgeExplorer explorer, int startNode) {
         TIntArrayStack stack = new TIntArrayStack();
 
         GHBitSet explored = createBitSet();
         stack.push(startNode);
         int current;
-        while (stack.size() > 0)
-        {
+        while (stack.size() > 0) {
             current = stack.pop();
-            if (!explored.contains(current) && goFurther(current))
-            {
+            if (!explored.contains(current) && goFurther(current)) {
                 EdgeIterator iter = explorer.setBaseNode(current);
-                while (iter.next())
-                {
+                while (iter.next()) {
                     int connectedId = iter.getAdjNode();
-                    if (checkAdjacent(iter))
-                    {
+                    if (checkAdjacent(iter)) {
                         stack.push(connectedId);
                     }
                 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index dcb7029260..b36bb97d90 100755
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -28,31 +28,30 @@
  *
  * @author Peter Karich
  */
-public interface DistanceCalc
-{
-    BBox createBBox( double lat, double lon, double radiusInMeter );
+public interface DistanceCalc {
+    BBox createBBox(double lat, double lon, double radiusInMeter);
 
-    double calcCircumference( double lat );
+    double calcCircumference(double lat);
 
     /**
      * Calculates distance of (from, to) in meter.
      */
-    double calcDist( double fromLat, double fromLon, double toLat, double toLon );
+    double calcDist(double fromLat, double fromLon, double toLat, double toLon);
 
     /**
      * Returns the specified length in normalized meter.
      */
-    double calcNormalizedDist( double dist );
+    double calcNormalizedDist(double dist);
 
     /**
      * Inverse to calcNormalizedDist. Returned the length in meter.
      */
-    double calcDenormalizedDist( double normedDist );
+    double calcDenormalizedDist(double normedDist);
 
     /**
      * Calculates in normalized meter
      */
-    double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon );
+    double calcNormalizedDist(double fromLat, double fromLon, double toLat, double toLon);
 
     /**
      * This method decides for case 1: if we should use distance(r to edge) where r=(lat,lon) or
@@ -73,36 +72,36 @@
      *
      * @return true for case 1 which is "on edge" or the special case of 90° to the edge
      */
-    boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-                               double a_lat_deg, double a_lon_deg,
-                               double b_lat_deg, double b_lon_deg );
+    boolean validEdgeDistance(double r_lat_deg, double r_lon_deg,
+                              double a_lat_deg, double a_lon_deg,
+                              double b_lat_deg, double b_lon_deg);
 
     /**
      * This method calculates the distance from r to edge (a, b) where the crossing point is c
      *
      * @return the distance in normalized meter
      */
-    double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-                                       double a_lat_deg, double a_lon_deg,
-                                       double b_lat_deg, double b_lon_deg );
+    double calcNormalizedEdgeDistance(double r_lat_deg, double r_lon_deg,
+                                      double a_lat_deg, double a_lon_deg,
+                                      double b_lat_deg, double b_lon_deg);
 
     /**
      * @return the crossing point c of the vertical line from r to line (a, b)
      */
-    GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-                                     double a_lat_deg, double a_lon_deg,
-                                     double b_lat_deg, double b_lon_deg );
+    GHPoint calcCrossingPointToEdge(double r_lat_deg, double r_lon_deg,
+                                    double a_lat_deg, double a_lon_deg,
+                                    double b_lat_deg, double b_lon_deg);
 
     /**
      * This methods projects a point given in lat and long (in degrees) into a direction, given as
      * heading, measured clockwise from north in degrees. The distance is passed in km.
      */
-    public GHPoint projectCoordinate( double lat_deg, double lon_deg,
-                                      double distanceInMeter, double headingClockwiseFromNorth );
+    public GHPoint projectCoordinate(double lat_deg, double lon_deg,
+                                     double distanceInMeter, double headingClockwiseFromNorth);
 
     /*
      * Simple heuristic to detect if the specified two points are crossing the boundary +-180°. See
      * #667
      */
-    boolean isCrossBoundary( double lon1, double lon2 );
+    boolean isCrossBoundary(double lon1, double lon2);
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
index 22512905f1..489aecce2f 100755
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
@@ -17,24 +17,22 @@
  */
 package com.graphhopper.util;
 
-import static java.lang.Math.*;
+import static java.lang.Math.sqrt;
 
 /**
  * Calculates the distance of two points or one point and an edge in euclidean space.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DistanceCalc2D extends DistanceCalcEarth
-{
+public class DistanceCalc2D extends DistanceCalcEarth {
     @Override
-    public double calcDist( double fromY, double fromX, double toY, double toX )
-    {
+    public double calcDist(double fromY, double fromX, double toY, double toX) {
         return sqrt(calcNormalizedDist(fromY, fromX, toY, toX));
     }
 
     @Override
-    public double calcDenormalizedDist( double normedDist )
-    {
+    public double calcDenormalizedDist(double normedDist) {
         return sqrt(normedDist);
     }
 
@@ -42,8 +40,7 @@ public double calcDenormalizedDist( double normedDist )
      * Returns the specified length in normalized meter.
      */
     @Override
-    public double calcNormalizedDist( double dist )
-    {
+    public double calcNormalizedDist(double dist) {
         return dist * dist;
     }
 
@@ -51,16 +48,14 @@ public double calcNormalizedDist( double dist )
      * Calculates in normalized meter
      */
     @Override
-    public double calcNormalizedDist( double fromY, double fromX, double toY, double toX )
-    {
+    public double calcNormalizedDist(double fromY, double fromX, double toY, double toX) {
         double dX = fromX - toX;
         double dY = fromY - toY;
         return dX * dX + dY * dY;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "2D";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
index 69948cc11f..69759b70f9 100755
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
@@ -23,25 +23,23 @@
  * not so much sense as it is only important for large distances where then the rather smallish
  * heights would becomes neglectable.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DistanceCalc3D extends DistanceCalcEarth
-{
+public class DistanceCalc3D extends DistanceCalcEarth {
     /**
      * @param fromHeight in meters above 0
-     * @param toHeight in meters above 0
+     * @param toHeight   in meters above 0
      */
-    public double calcDist( double fromLat, double fromLon, double fromHeight,
-                            double toLat, double toLon, double toHeight )
-    {
+    public double calcDist(double fromLat, double fromLon, double fromHeight,
+                           double toLat, double toLon, double toHeight) {
         double len = super.calcDist(fromLat, fromLon, toLat, toLon);
         double delta = Math.abs(toHeight - fromHeight);
         return Math.sqrt(delta * delta + len * len);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "EXACT3D";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 362952cc42..49c1035f52 100755
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -25,8 +25,7 @@
 /**
  * @author Peter Karich
  */
-public class DistanceCalcEarth implements DistanceCalc
-{
+public class DistanceCalcEarth implements DistanceCalc {
     /**
      * mean radius of the earth
      */
@@ -48,15 +47,13 @@
      * cos(lat1).cos(lat2).sin²(Δlong/2) c = 2.atan2(√a, √(1−a)) d = R.c
      */
     @Override
-    public double calcDist( double fromLat, double fromLon, double toLat, double toLon )
-    {
+    public double calcDist(double fromLat, double fromLon, double toLat, double toLon) {
         double normedDist = calcNormalizedDist(fromLat, fromLon, toLat, toLon);
         return R * 2 * asin(sqrt(normedDist));
     }
 
     @Override
-    public double calcDenormalizedDist( double normedDist )
-    {
+    public double calcDenormalizedDist(double normedDist) {
         return R * 2 * asin(sqrt(normedDist));
     }
 
@@ -64,15 +61,13 @@ public double calcDenormalizedDist( double normedDist )
      * Returns the specified length in normalized meter.
      */
     @Override
-    public double calcNormalizedDist( double dist )
-    {
+    public double calcNormalizedDist(double dist) {
         double tmp = sin(dist / 2 / R);
         return tmp * tmp;
     }
 
     @Override
-    public double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon )
-    {
+    public double calcNormalizedDist(double fromLat, double fromLon, double toLat, double toLon) {
         double sinDeltaLat = sin(toRadians(toLat - fromLat) / 2);
         double sinDeltaLon = sin(toRadians(toLon - fromLon) / 2);
         return sinDeltaLat * sinDeltaLat
@@ -82,19 +77,16 @@ public double calcNormalizedDist( double fromLat, double fromLon, double toLat,
     /**
      * Circumference of the earth at different latitudes (breitengrad)
      */
-    public double calcCircumference( double lat )
-    {
+    public double calcCircumference(double lat) {
         return 2 * PI * R * cos(toRadians(lat));
     }
 
-    public boolean isDateLineCrossOver( double lon1, double lon2 )
-    {
+    public boolean isDateLineCrossOver(double lon1, double lon2) {
         return abs(lon1 - lon2) > 180.0;
     }
 
     @Override
-    public BBox createBBox( double lat, double lon, double radiusInMeter )
-    {
+    public BBox createBBox(double lat, double lon, double radiusInMeter) {
         if (radiusInMeter <= 0)
             throw new IllegalArgumentException("Distance must not be zero or negative! " + radiusInMeter + " lat,lon:" + lat + "," + lon);
 
@@ -109,23 +101,22 @@ public BBox createBBox( double lat, double lon, double radiusInMeter )
     }
 
     @Override
-    public double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-                                              double a_lat_deg, double a_lon_deg,
-                                              double b_lat_deg, double b_lon_deg )
-    {
+    public double calcNormalizedEdgeDistance(double r_lat_deg, double r_lon_deg,
+                                             double a_lat_deg, double a_lon_deg,
+                                             double b_lat_deg, double b_lon_deg) {
         return calcNormalizedEdgeDistanceNew(r_lat_deg, r_lon_deg, a_lat_deg, a_lon_deg, b_lat_deg, b_lon_deg, false);
     }
 
     /**
      * New edge distance calculation where no validEdgeDistance check would be necessary
      * <p>
+     *
      * @return the normalized distance of the query point "r" to the project point "c" onto the line
      * segment a-b
      */
-    public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
-                                                 double a_lat_deg, double a_lon_deg,
-                                                 double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
-    {
+    public double calcNormalizedEdgeDistanceNew(double r_lat_deg, double r_lon_deg,
+                                                double a_lat_deg, double a_lon_deg,
+                                                double b_lat_deg, double b_lon_deg, boolean reduceToSegment) {
         double shrinkFactor = calcShrinkFactor(a_lat_deg, b_lat_deg);
 
         double a_lat = a_lat_deg;
@@ -152,8 +143,7 @@ public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
         double factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat) / norm;
 
         // make new calculation compatible to old
-        if (reduceToSegment)
-        {
+        if (reduceToSegment) {
             if (factor > 1)
                 factor = 1;
             else if (factor < 0)
@@ -165,16 +155,14 @@ else if (factor < 0)
         return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
-    private double calcShrinkFactor( double a_lat_deg, double b_lat_deg )
-    {
+    private double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
         return cos(toRadians((a_lat_deg + b_lat_deg) / 2));
     }
 
     @Override
-    public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-                                            double a_lat_deg, double a_lon_deg,
-                                            double b_lat_deg, double b_lon_deg )
-    {
+    public GHPoint calcCrossingPointToEdge(double r_lat_deg, double r_lon_deg,
+                                           double a_lat_deg, double a_lon_deg,
+                                           double b_lat_deg, double b_lon_deg) {
         double shrinkFactor = calcShrinkFactor(a_lat_deg, b_lat_deg);
         double a_lat = a_lat_deg;
         double a_lon = a_lon_deg * shrinkFactor;
@@ -206,10 +194,9 @@ public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
     }
 
     @Override
-    public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-                                      double a_lat_deg, double a_lon_deg,
-                                      double b_lat_deg, double b_lon_deg )
-    {
+    public boolean validEdgeDistance(double r_lat_deg, double r_lon_deg,
+                                     double a_lat_deg, double a_lon_deg,
+                                     double b_lat_deg, double b_lon_deg) {
         double shrinkFactor = calcShrinkFactor(a_lat_deg, b_lat_deg);
         double a_lat = a_lat_deg;
         double a_lon = a_lon_deg * shrinkFactor;
@@ -238,8 +225,7 @@ public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
     }
 
     @Override
-    public GHPoint projectCoordinate( double latInDeg, double lonInDeg, double distanceInMeter, double headingClockwiseFromNorth )
-    {
+    public GHPoint projectCoordinate(double latInDeg, double lonInDeg, double distanceInMeter, double headingClockwiseFromNorth) {
         double angularDistance = distanceInMeter / R;
 
         double latInRadians = Math.toRadians(latInDeg);
@@ -264,14 +250,12 @@ public GHPoint projectCoordinate( double latInDeg, double lonInDeg, double dista
     }
 
     @Override
-    public boolean isCrossBoundary( double lon1, double lon2 )
-    {
+    public boolean isCrossBoundary(double lon1, double lon2) {
         return abs(lon1 - lon2) > 300;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "EXACT";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
index 4679bbbb20..e5b749a32e 100755
--- a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
+++ b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
@@ -30,13 +30,12 @@
  * http://en.wikipedia.org/wiki/Mercator_projection#Mathematics_of_the_Mercator_projection
  * http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b
  * <p>
+ *
  * @author Peter Karich
  */
-public class DistancePlaneProjection extends DistanceCalcEarth
-{
+public class DistancePlaneProjection extends DistanceCalcEarth {
     @Override
-    public double calcDist( double fromLat, double fromLon, double toLat, double toLon )
-    {
+    public double calcDist(double fromLat, double fromLon, double toLat, double toLon) {
         double dLat = toRadians(toLat - fromLat);
         double dLon = toRadians(toLon - fromLon);
         // use mean latitude as reference point for delta_lon
@@ -46,21 +45,18 @@ public double calcDist( double fromLat, double fromLon, double toLat, double toL
     }
 
     @Override
-    public double calcDenormalizedDist( double normedDist )
-    {
+    public double calcDenormalizedDist(double normedDist) {
         return R * sqrt(normedDist);
     }
 
     @Override
-    public double calcNormalizedDist( double dist )
-    {
+    public double calcNormalizedDist(double dist) {
         double tmp = dist / R;
         return tmp * tmp;
     }
 
     @Override
-    public double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon )
-    {
+    public double calcNormalizedDist(double fromLat, double fromLon, double toLat, double toLon) {
         double dLat = toRadians(toLat - fromLat);
         double dLon = toRadians(toLon - fromLon);
         double left = cos(toRadians((fromLat + toLat) / 2)) * dLon;
@@ -68,8 +64,7 @@ public double calcNormalizedDist( double fromLat, double fromLon, double toLat,
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "PLANE_PROJ";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index e86eb7abab..2a8040d822 100755
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -23,23 +23,21 @@
  * <p>
  * Calling simplify is thread safe.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DouglasPeucker
-{
+public class DouglasPeucker {
     private double normedMaxDist;
     private DistanceCalc calc;
     private boolean approx;
 
-    public DouglasPeucker()
-    {
+    public DouglasPeucker() {
         setApproximation(true);
         // 1m
         setMaxDistance(1);
     }
 
-    public void setApproximation( boolean a )
-    {
+    public void setApproximation(boolean a) {
         approx = a;
         if (approx)
             calc = Helper.DIST_PLANE;
@@ -50,8 +48,7 @@ public void setApproximation( boolean a )
     /**
      * maximum distance of discrepancy (from the normal way) in meter
      */
-    public DouglasPeucker setMaxDistance( double dist )
-    {
+    public DouglasPeucker setMaxDistance(double dist) {
         this.normedMaxDist = calc.calcNormalizedDist(dist);
         return this;
     }
@@ -59,25 +56,22 @@ public DouglasPeucker setMaxDistance( double dist )
     /**
      * This method removes points which are close to the line (defined by maxDist).
      * <p>
+     *
      * @return removed nodes
      */
-    public int simplify( PointList points )
-    {
+    public int simplify(PointList points) {
         int removed = 0;
         int size = points.getSize();
-        if (approx)
-        {
+        if (approx) {
             int delta = 500;
             int segments = size / delta + 1;
             int start = 0;
-            for (int i = 0; i < segments; i++)
-            {
+            for (int i = 0; i < segments; i++) {
                 // start of next is end of last segment, except for the last
                 removed += simplify(points, start, Math.min(size - 1, start + delta));
                 start += delta;
             }
-        } else
-        {
+        } else {
             removed = simplify(points, 0, size - 1);
         }
 
@@ -88,19 +82,15 @@ public int simplify( PointList points )
     /**
      * compress list: move points into EMPTY slots
      */
-    void compressNew( PointList points, int removed )
-    {
+    void compressNew(PointList points, int removed) {
         int freeIndex = -1;
-        for (int currentIndex = 0; currentIndex < points.getSize(); currentIndex++)
-        {
-            if (Double.isNaN(points.getLatitude(currentIndex)))
-            {
+        for (int currentIndex = 0; currentIndex < points.getSize(); currentIndex++) {
+            if (Double.isNaN(points.getLatitude(currentIndex))) {
                 if (freeIndex < 0)
                     freeIndex = currentIndex;
 
                 continue;
-            } else if (freeIndex < 0)
-            {
+            } else if (freeIndex < 0) {
                 continue;
             }
 
@@ -110,10 +100,8 @@ void compressNew( PointList points, int removed )
             int max = currentIndex;
             int searchIndex = freeIndex + 1;
             freeIndex = currentIndex;
-            for (; searchIndex < max; searchIndex++)
-            {
-                if (Double.isNaN(points.getLatitude(searchIndex)))
-                {
+            for (; searchIndex < max; searchIndex++) {
+                if (Double.isNaN(points.getLatitude(searchIndex))) {
                     freeIndex = searchIndex;
                     break;
                 }
@@ -123,10 +111,8 @@ void compressNew( PointList points, int removed )
     }
 
     // keep the points of fromIndex and lastIndex
-    int simplify( PointList points, int fromIndex, int lastIndex )
-    {
-        if (lastIndex - fromIndex < 2)
-        {
+    int simplify(PointList points, int fromIndex, int lastIndex) {
+        if (lastIndex - fromIndex < 2) {
             return 0;
         }
         int indexWithMaxDist = -1;
@@ -135,42 +121,34 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         double firstLon = points.getLongitude(fromIndex);
         double lastLat = points.getLatitude(lastIndex);
         double lastLon = points.getLongitude(lastIndex);
-        for (int i = fromIndex + 1; i < lastIndex; i++)
-        {
+        for (int i = fromIndex + 1; i < lastIndex; i++) {
             double lat = points.getLatitude(i);
-            if (Double.isNaN(lat))
-            {
+            if (Double.isNaN(lat)) {
                 continue;
             }
             double lon = points.getLongitude(i);
             double dist = calc.calcNormalizedEdgeDistance(lat, lon, firstLat, firstLon, lastLat, lastLon);
-            if (maxDist < dist)
-            {
+            if (maxDist < dist) {
                 indexWithMaxDist = i;
                 maxDist = dist;
             }
         }
 
-        if (indexWithMaxDist < 0)
-        {
+        if (indexWithMaxDist < 0) {
             throw new IllegalStateException("maximum not found in [" + fromIndex + "," + lastIndex + "]");
         }
 
         int counter = 0;
-        if (maxDist < normedMaxDist)
-        {
-            for (int i = fromIndex + 1; i < lastIndex; i++)
-            {
+        if (maxDist < normedMaxDist) {
+            for (int i = fromIndex + 1; i < lastIndex; i++) {
                 points.set(i, Double.NaN, Double.NaN, Double.NaN);
                 counter++;
             }
-        } else
-        {
+        } else {
             counter = simplify(points, fromIndex, indexWithMaxDist);
             counter += simplify(points, indexWithMaxDist, lastIndex);
         }
         return counter;
     }
 
-
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 0a9ccb93d6..b64ed245fb 100755
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -27,39 +27,32 @@
 /**
  * @author Peter Karich
  */
-public class Downloader
-{
-    public static void main( String[] args ) throws IOException
-    {
-        new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
-                new ProgressListener()
-                {
-                    @Override
-                    public void update( long val )
-                    {
-                        System.out.println("progress:" + val);
-                    }
-                });
-    }
-
-    private String referrer = "http://graphhopper.com";
+public class Downloader {
     private final String userAgent;
+    private String referrer = "http://graphhopper.com";
     private String acceptEncoding = "gzip, deflate";
     private int timeout = 4000;
 
-    public Downloader( String userAgent )
-    {
+    public Downloader(String userAgent) {
         this.userAgent = userAgent;
     }
 
-    public Downloader setTimeout( int timeout )
-    {
+    public static void main(String[] args) throws IOException {
+        new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
+                new ProgressListener() {
+            @Override
+            public void update(long val) {
+                System.out.println("progress:" + val);
+            }
+        });
+    }
+
+    public Downloader setTimeout(int timeout) {
         this.timeout = timeout;
         return this;
     }
 
-    public Downloader setReferrer( String referrer )
-    {
+    public Downloader setReferrer(String referrer) {
         this.referrer = referrer;
         return this;
     }
@@ -70,8 +63,7 @@ public Downloader setReferrer( String referrer )
      * true otherwise it throws an IOException if an error happens. Furthermore it wraps the stream
      * to decompress it if the connection content encoding is specified.
      */
-    public InputStream fetch( HttpURLConnection connection, boolean readErrorStreamNoException ) throws IOException
-    {
+    public InputStream fetch(HttpURLConnection connection, boolean readErrorStreamNoException) throws IOException {
         // create connection but before reading get the correct inputstream based on the compression and if error
         connection.connect();
 
@@ -85,27 +77,23 @@ public InputStream fetch( HttpURLConnection connection, boolean readErrorStreamN
             throw new IOException("Stream is null. Message:" + connection.getResponseMessage());
 
         // wrap
-        try
-        {
+        try {
             String encoding = connection.getContentEncoding();
             if (encoding != null && encoding.equalsIgnoreCase("gzip"))
                 is = new GZIPInputStream(is);
             else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
                 is = new InflaterInputStream(is, new Inflater(true));
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
         }
 
         return is;
     }
 
-    public InputStream fetch( String url ) throws IOException
-    {
+    public InputStream fetch(String url) throws IOException {
         return fetch((HttpURLConnection) createConnection(url), false);
     }
 
-    public HttpURLConnection createConnection( String urlStr ) throws IOException
-    {
+    public HttpURLConnection createConnection(String urlStr) throws IOException {
         URL url = new URL(urlStr);
         HttpURLConnection conn = (HttpURLConnection) url.openConnection();
         // Will yield in a POST request: conn.setDoOutput(true);
@@ -121,46 +109,38 @@ public HttpURLConnection createConnection( String urlStr ) throws IOException
         return conn;
     }
 
-    public void downloadFile( String url, String toFile ) throws IOException
-    {
+    public void downloadFile(String url, String toFile) throws IOException {
         HttpURLConnection conn = createConnection(url);
         InputStream iStream = fetch(conn, false);
         int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
-        try
-        {
+        try {
             byte[] buffer = new byte[size];
             int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
+            while ((numRead = in.read(buffer)) != -1) {
                 writer.write(buffer, 0, numRead);
             }
-        } finally
-        {
+        } finally {
             Helper.close(writer);
             Helper.close(in);
         }
     }
 
-    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
-    {
+    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
         HttpURLConnection conn = createConnection(url);
         final int length = conn.getContentLength();
         InputStream iStream = fetch(conn, false);
 
-        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
-        {
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
             @Override
-            public void update( long sumBytes )
-            {
+            public void update(long sumBytes) {
                 progressListener.update((int) (100 * sumBytes / length));
             }
         });
     }
 
-    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
-    {
+    public String downloadAsString(String url, boolean readErrorStreamNoException) throws IOException {
         return Helper.isToString(fetch((HttpURLConnection) createConnection(url), readErrorStreamNoException));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
index dc17907bb1..cba6710459 100755
--- a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
@@ -21,18 +21,19 @@
  * Class to get an EdgeIterator. Create it via graph.createEdgeExplorer() use one instance per
  * thread.
  * <p>
+ *
  * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeIteratorState
  */
-public interface EdgeExplorer
-{
+public interface EdgeExplorer {
     /**
      * This method sets the base node for iteration through neighboring edges (EdgeIteratorStates).
      * <p>
+     *
      * @return EdgeIterator around the specified baseNode. The resulting iterator can be a new
      * instance or a reused instance returned in a previous call. So be sure you do not use the
      * EdgeExplorer from multiple threads or in a nested loop.
      */
-    EdgeIterator setBaseNode( int baseNode );
+    EdgeIterator setBaseNode(int baseNode);
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index adce7d7329..6c689bfaed 100755
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -33,29 +33,28 @@
  * }
  * </pre>
  * <p>
+ *
  * @author Peter Karich
  * @see EdgeIteratorState
  * @see EdgeExplorer
  */
-public interface EdgeIterator extends EdgeIteratorState
-{
+public interface EdgeIterator extends EdgeIteratorState {
+    /**
+     * integer value to indicate if an edge is valid or not which then would be initialized with
+     * this value
+     */
+    int NO_EDGE = -1;
+
     /**
      * To be called to go to the next edge state.
      * <p>
+     *
      * @return true if an edge state is available
      */
     boolean next();
 
-    /**
-     * integer value to indicate if an edge is valid or not which then would be initialized with
-     * this value
-     */
-    int NO_EDGE = -1;
-
-    class Edge
-    {
-        public static boolean isValid( int edgeId )
-        {
+    class Edge {
+        public static boolean isValid(int edgeId) {
             return edgeId > NO_EDGE;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index 7030272973..3137e55f3a 100755
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -22,12 +22,12 @@
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
  * <p>
+ *
  * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
  */
-public interface EdgeIteratorState
-{
+public interface EdgeIteratorState {
     int K_UNFAVORED_EDGE = -1;
 
     /**
@@ -41,6 +41,7 @@
      * graph.getEdges(baseNode)". Often only used for convenience reasons. Do not confuse this with
      * a <i>source node</i> of a directed edge.
      * <p>
+     *
      * @return the requested node itself
      * @see EdgeIterator
      */
@@ -59,75 +60,79 @@
      * (docs/core/low-level-api.md#what-are-pillar-and-tower-nodes). Updates to the returned list
      * are not reflected in the graph, for that you've to use setWayGeometry.
      * <p>
+     *
      * @param mode can be <ul> <li>0 = only pillar nodes, no tower nodes</li> <li>1 = inclusive the
-     * base tower node only</li> <li>2 = inclusive the adjacent tower node only</li> <li>3 =
-     * inclusive the base and adjacent tower node</li> </ul>
+     *             base tower node only</li> <li>2 = inclusive the adjacent tower node only</li> <li>3 =
+     *             inclusive the base and adjacent tower node</li> </ul>
      * @return pillar nodes
      */
-    PointList fetchWayGeometry( int mode );
+    PointList fetchWayGeometry(int mode);
 
     /**
      * @param list is a sorted collection of nodes between the baseNode and the current adjacent
-     * node. Specify the list without the adjacent and base nodes.
+     *             node. Specify the list without the adjacent and base nodes.
      */
-    EdgeIteratorState setWayGeometry( PointList list );
+    EdgeIteratorState setWayGeometry(PointList list);
 
     /**
      * @return the distance of the current edge in meter
      */
     double getDistance();
 
-    EdgeIteratorState setDistance( double dist );
+    EdgeIteratorState setDistance(double dist);
 
     long getFlags();
 
-    EdgeIteratorState setFlags( long flags );
+    EdgeIteratorState setFlags(long flags);
 
     /**
      * @return the additional field value for this edge
      */
     int getAdditionalField();
 
+    /**
+     * Updates the additional field value for this edge
+     */
+    EdgeIteratorState setAdditionalField(int value);
+
     /**
      * @see FlagEncoder#isForward(long) and #472
      */
-    boolean isForward( FlagEncoder encoder );
+    boolean isForward(FlagEncoder encoder);
 
     /**
      * @see FlagEncoder#isBackward(long) and #472
      */
-    boolean isBackward( FlagEncoder encoder );
+    boolean isBackward(FlagEncoder encoder);
 
     /**
-     * get additional boolean edge information
+     * Get additional boolean information of the edge.
      * <p>
-     * @param reverse if property of reverse edge direction should be returned
+     *
+     * @param key      direction or vehicle dependent integer key
      * @param _default default value if key is not found
      */
-    boolean getBoolean( int key, boolean reverse, boolean _default );
-
-    /**
-     * Updates the additional field value for this edge
-     */
-    EdgeIteratorState setAdditionalField( int value );
+    boolean getBool(int key, boolean _default);
 
     String getName();
 
-    EdgeIteratorState setName( String name );
+    EdgeIteratorState setName(String name);
 
     /**
      * Clones this EdgeIteratorState.
      * <p>
+     *
      * @param reverse if true a detached edgeState with reversed properties is created where base
-     * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
-     * about why we need the new reverse parameter.
+     *                and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
+     *                about why we need the new reverse parameter.
      */
-    EdgeIteratorState detach( boolean reverse );
+    EdgeIteratorState detach(boolean reverse);
 
     /**
      * Copies the properties of this edge into the specified edge. Does not change nodes!
      * <p>
+     *
      * @return the specified edge e
      */
-    EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
+    EdgeIteratorState copyPropertiesTo(EdgeIteratorState e);
 }
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index 0af9288aad..3861b3a80e 100755
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -20,27 +20,35 @@
 /**
  * @author Peter Karich
  */
-public class FinishInstruction extends Instruction
-{
-    public FinishInstruction( final double lat, final double lon, final double ele )
-    {
-        super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
-        {
+public class FinishInstruction extends Instruction {
+    public FinishInstruction(String name, final double lat, final double lon, final double ele) {
+        super(FINISH, name, InstructionAnnotation.EMPTY, new PointList(2, true) {
             {
                 add(lat, lon, ele);
             }
         });
     }
 
-    public FinishInstruction( PointAccess pointAccess, int node )
-    {
+    public FinishInstruction(final double lat, final double lon, final double ele) {
+        super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true) {
+            {
+                add(lat, lon, ele);
+            }
+        });
+    }
+
+    public FinishInstruction(String name, PointAccess pointAccess, int node) {
+        this(name, pointAccess.getLatitude(node), pointAccess.getLongitude(node),
+                pointAccess.is3D() ? pointAccess.getElevation(node) : 0);
+    }
+
+    public FinishInstruction(PointAccess pointAccess, int node) {
         this(pointAccess.getLatitude(node), pointAccess.getLongitude(node),
                 pointAccess.is3D() ? pointAccess.getElevation(node) : 0);
     }
 
     @Override
-    public String getTurnDescription( Translation tr )
-    {
+    public String getTurnDescription(Translation tr) {
         if (rawName)
             return getName();
 
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 76649b4c59..743757d752 100755
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -19,8 +19,8 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.*;
@@ -34,24 +34,21 @@
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
  * methods are useful for unit tests or debugging only.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHUtility
-{
+public class GHUtility {
     /**
      * This method could throw exception if uncatched problems like index out of bounds etc
      */
-    public static List<String> getProblems( Graph g )
-    {
+    public static List<String> getProblems(Graph g) {
         List<String> problems = new ArrayList<String>();
         int nodes = g.getNodes();
         int nodeIndex = 0;
         NodeAccess na = g.getNodeAccess();
-        try
-        {
+        try {
             EdgeExplorer explorer = g.createEdgeExplorer();
-            for (; nodeIndex < nodes; nodeIndex++)
-            {
+            for (; nodeIndex < nodes; nodeIndex++) {
                 double lat = na.getLatitude(nodeIndex);
                 if (lat > 90 || lat < -90)
                     problems.add("latitude is not within its bounds " + lat);
@@ -61,20 +58,16 @@
                     problems.add("longitude is not within its bounds " + lon);
 
                 EdgeIterator iter = explorer.setBaseNode(nodeIndex);
-                while (iter.next())
-                {
-                    if (iter.getAdjNode() >= nodes)
-                    {
+                while (iter.next()) {
+                    if (iter.getAdjNode() >= nodes) {
                         problems.add("edge of " + nodeIndex + " has a node " + iter.getAdjNode() + " greater or equal to getNodes");
                     }
-                    if (iter.getAdjNode() < 0)
-                    {
+                    if (iter.getAdjNode() < 0) {
                         problems.add("edge of " + nodeIndex + " has a negative node " + iter.getAdjNode());
                     }
                 }
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("problem with node " + nodeIndex, ex);
         }
 
@@ -87,56 +80,45 @@
     /**
      * Counts reachable edges.
      */
-    public static int count( EdgeIterator iter )
-    {
+    public static int count(EdgeIterator iter) {
         int counter = 0;
-        while (iter.next())
-        {
+        while (iter.next()) {
             counter++;
         }
         return counter;
     }
 
-    public static Set<Integer> asSet( int... values )
-    {
+    public static Set<Integer> asSet(int... values) {
         Set<Integer> s = new HashSet<Integer>();
-        for (int v : values)
-        {
+        for (int v : values) {
             s.add(v);
         }
         return s;
     }
 
-    public static Set<Integer> getNeighbors( EdgeIterator iter )
-    {
+    public static Set<Integer> getNeighbors(EdgeIterator iter) {
         // make iteration order over set static => linked
         Set<Integer> list = new LinkedHashSet<Integer>();
-        while (iter.next())
-        {
+        while (iter.next()) {
             list.add(iter.getAdjNode());
         }
         return list;
     }
 
-    public static List<Integer> getEdgeIds( EdgeIterator iter )
-    {
+    public static List<Integer> getEdgeIds(EdgeIterator iter) {
         List<Integer> list = new ArrayList<Integer>();
-        while (iter.next())
-        {
+        while (iter.next()) {
             list.add(iter.getEdge());
         }
         return list;
     }
 
-    public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
-    {
+    public static void printEdgeInfo(final Graph g, FlagEncoder encoder) {
         System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
-        while (iter.next())
-        {
+        while (iter.next()) {
             String sc = "";
-            if (iter instanceof AllCHEdgesIterator)
-            {
+            if (iter instanceof AllCHEdgesIterator) {
                 AllCHEdgesIterator aeSkip = (AllCHEdgesIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
@@ -146,18 +128,14 @@ public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
         }
     }
 
-    public static void printInfo( final Graph g, int startNode, final int counts, final EdgeFilter filter )
-    {
-        new BreadthFirstSearch()
-        {
+    public static void printInfo(final Graph g, int startNode, final int counts, final EdgeFilter filter) {
+        new BreadthFirstSearch() {
             int counter = 0;
 
             @Override
-            protected boolean goFurther( int nodeId )
-            {
+            protected boolean goFurther(int nodeId) {
                 System.out.println(getNodeInfo(g, nodeId, filter));
-                if (counter++ > counts)
-                {
+                if (counter++ > counts) {
                     return false;
                 }
                 return true;
@@ -165,27 +143,23 @@ protected boolean goFurther( int nodeId )
         }.start(g.createEdgeExplorer(), startNode);
     }
 
-    public static String getNodeInfo( CHGraph g, int nodeId, EdgeFilter filter )
-    {
+    public static String getNodeInfo(CHGraph g, int nodeId, EdgeFilter filter) {
         CHEdgeExplorer ex = g.createEdgeExplorer(filter);
         CHEdgeIterator iter = ex.setBaseNode(nodeId);
         NodeAccess na = g.getNodeAccess();
         String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
-        while (iter.next())
-        {
+        while (iter.next()) {
             str += "  ->" + iter.getAdjNode() + "(" + iter.getSkippedEdge1() + "," + iter.getSkippedEdge2() + ") "
                     + iter.getEdge() + " \t" + BitUtil.BIG.toBitString(iter.getFlags(), 8) + "\n";
         }
         return str;
     }
 
-    public static String getNodeInfo( Graph g, int nodeId, EdgeFilter filter )
-    {
+    public static String getNodeInfo(Graph g, int nodeId, EdgeFilter filter) {
         EdgeIterator iter = g.createEdgeExplorer(filter).setBaseNode(nodeId);
         NodeAccess na = g.getNodeAccess();
         String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
-        while (iter.next())
-        {
+        while (iter.next()) {
             str += "  ->" + iter.getAdjNode() + " (" + iter.getDistance() + ") pillars:"
                     + iter.fetchWayGeometry(0).getSize() + ", edgeId:" + iter.getEdge()
                     + "\t" + BitUtil.BIG.toBitString(iter.getFlags(), 8) + "\n";
@@ -193,13 +167,11 @@ public static String getNodeInfo( Graph g, int nodeId, EdgeFilter filter )
         return str;
     }
 
-    public static Graph shuffle( Graph g, Graph sortedGraph )
-    {
+    public static Graph shuffle(Graph g, Graph sortedGraph) {
         int len = g.getNodes();
         TIntList list = new TIntArrayList(len, -1);
         list.fill(0, len, -1);
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             list.set(i, i);
         }
         list.shuffle(new Random());
@@ -210,8 +182,7 @@ public static Graph shuffle( Graph g, Graph sortedGraph )
      * Sorts the graph according to depth-first search traversal. Other traversals have either no
      * significant difference (bfs) for querying or are worse (z-curve).
      */
-    public static Graph sortDFS( Graph g, Graph sortedGraph )
-    {
+    public static Graph sortDFS(Graph g, Graph sortedGraph) {
         final TIntList list = new TIntArrayList(g.getNodes(), -1);
         int nodes = g.getNodes();
         list.fill(0, nodes, -1);
@@ -219,19 +190,15 @@ public static Graph sortDFS( Graph g, Graph sortedGraph )
         final AtomicInteger ref = new AtomicInteger(-1);
         EdgeExplorer explorer = g.createEdgeExplorer();
         for (int startNode = 0; startNode >= 0 && startNode < nodes;
-                startNode = bitset.nextClear(startNode + 1))
-        {
-            new DepthFirstSearch()
-            {
+             startNode = bitset.nextClear(startNode + 1)) {
+            new DepthFirstSearch() {
                 @Override
-                protected GHBitSet createBitSet()
-                {
+                protected GHBitSet createBitSet() {
                     return bitset;
                 }
 
                 @Override
-                protected boolean goFurther( int nodeId )
-                {
+                protected boolean goFurther(int nodeId) {
                     list.set(nodeId, ref.incrementAndGet());
                     return super.goFurther(nodeId);
                 }
@@ -240,11 +207,9 @@ protected boolean goFurther( int nodeId )
         return createSortedGraph(g, sortedGraph, list);
     }
 
-    static Graph createSortedGraph( Graph fromGraph, Graph toSortedGraph, final TIntList oldToNewNodeList )
-    {
+    static Graph createSortedGraph(Graph fromGraph, Graph toSortedGraph, final TIntList oldToNewNodeList) {
         AllEdgesIterator eIter = fromGraph.getAllEdges();
-        while (eIter.next())
-        {
+        while (eIter.next()) {
             int base = eIter.getBaseNode();
             int newBaseIndex = oldToNewNodeList.get(base);
             int adj = eIter.getAdjNode();
@@ -260,8 +225,7 @@ static Graph createSortedGraph( Graph fromGraph, Graph toSortedGraph, final TInt
         int nodes = fromGraph.getNodes();
         NodeAccess na = fromGraph.getNodeAccess();
         NodeAccess sna = toSortedGraph.getNodeAccess();
-        for (int old = 0; old < nodes; old++)
-        {
+        for (int old = 0; old < nodes; old++) {
             int newIndex = oldToNewNodeList.get(old);
             if (sna.is3D())
                 sna.setNode(newIndex, na.getLatitude(old), na.getLongitude(old), na.getElevation(old));
@@ -275,11 +239,9 @@ static Graph createSortedGraph( Graph fromGraph, Graph toSortedGraph, final TInt
      * @return the specified toGraph which is now filled with data from fromGraph
      */
     // TODO very similar to createSortedGraph -> use a 'int map(int)' interface
-    public static Graph copyTo( Graph fromGraph, Graph toGraph )
-    {
+    public static Graph copyTo(Graph fromGraph, Graph toGraph) {
         AllEdgesIterator eIter = fromGraph.getAllEdges();
-        while (eIter.next())
-        {
+        while (eIter.next()) {
             int base = eIter.getBaseNode();
             int adj = eIter.getAdjNode();
             eIter.copyPropertiesTo(toGraph.edge(base, adj));
@@ -288,8 +250,7 @@ public static Graph copyTo( Graph fromGraph, Graph toGraph )
         NodeAccess fna = fromGraph.getNodeAccess();
         NodeAccess tna = toGraph.getNodeAccess();
         int nodes = fromGraph.getNodes();
-        for (int node = 0; node < nodes; node++)
-        {
+        for (int node = 0; node < nodes; node++) {
             if (tna.is3D())
                 tna.setNode(node, fna.getLatitude(node), fna.getLongitude(node), fna.getElevation(node));
             else
@@ -298,15 +259,12 @@ public static Graph copyTo( Graph fromGraph, Graph toGraph )
         return toGraph;
     }
 
-    static Directory guessDirectory( GraphStorage store )
-    {
+    static Directory guessDirectory(GraphStorage store) {
         String location = store.getDirectory().getLocation();
         Directory outdir;
-        if (store.getDirectory() instanceof MMapDirectory)
-        {
+        if (store.getDirectory() instanceof MMapDirectory) {
             throw new IllegalStateException("not supported yet: mmap will overwrite existing storage at the same location");
-        } else
-        {
+        } else {
             boolean isStoring = ((GHDirectory) store.getDirectory()).isStoring();
             outdir = new RAMDirectory(location, isStoring);
         }
@@ -316,8 +274,7 @@ static Directory guessDirectory( GraphStorage store )
     /**
      * Create a new storage from the specified one without copying the data.
      */
-    public static GraphHopperStorage newStorage( GraphHopperStorage store )
-    {
+    public static GraphHopperStorage newStorage(GraphHopperStorage store) {
         Directory outdir = guessDirectory(store);
         boolean is3D = store.getNodeAccess().is3D();
 
@@ -326,228 +283,214 @@ public static GraphHopperStorage newStorage( GraphHopperStorage store )
                 create(store.getNodes());
     }
 
-    public static int getAdjNode( Graph g, int edge, int adjNode )
-    {
-        if (EdgeIterator.Edge.isValid(edge))
-        {
+    public static int getAdjNode(Graph g, int edge, int adjNode) {
+        if (EdgeIterator.Edge.isValid(edge)) {
             EdgeIteratorState iterTo = g.getEdgeIteratorState(edge, adjNode);
             return iterTo.getAdjNode();
         }
         return adjNode;
     }
 
+    public static EdgeIteratorState createMockedEdgeIteratorState(final double distance, final long flags) {
+        return new GHUtility.DisabledEdgeIterator() {
+            @Override
+            public double getDistance() {
+                return distance;
+            }
+
+            @Override
+            public long getFlags() {
+                return flags;
+            }
+
+            @Override
+            public boolean getBool(int key, boolean _default) {
+                return _default;
+            }
+        };
+    }
+
+    ;
+
+    /**
+     * @return the <b>first</b> edge containing the specified nodes base and adj. Returns null if
+     * not found.
+     */
+    public static EdgeIteratorState getEdge(Graph graph, int base, int adj) {
+        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(base);
+        while (iter.next()) {
+            if (iter.getAdjNode() == adj)
+                return iter;
+        }
+        return null;
+    }
+
+    /**
+     * Creates unique positive number for specified edgeId taking into account the direction defined
+     * by nodeA, nodeB and reverse.
+     */
+    public static int createEdgeKey(int nodeA, int nodeB, int edgeId, boolean reverse) {
+        edgeId = edgeId << 1;
+        if (reverse)
+            return (nodeA > nodeB) ? edgeId : edgeId + 1;
+        return (nodeA > nodeB) ? edgeId + 1 : edgeId;
+    }
+
+    /**
+     * Returns if the specified edgeKeys (created by createEdgeKey) are identical regardless of the
+     * direction.
+     */
+    public static boolean isSameEdgeKeys(int edgeKey1, int edgeKey2) {
+        return edgeKey1 / 2 == edgeKey2 / 2;
+    }
+
+    /**
+     * Returns the edgeKey of the opposite direction
+     */
+    public static int reverseEdgeKey(int edgeKey) {
+        return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
+    }
+
+    /**
+     * @return edge ID for edgeKey
+     */
+    public static int getEdgeFromEdgeKey(int edgeKey) {
+        return edgeKey / 2;
+    }
+
     /**
      * This edge iterator can be used in tests to mock specific iterator behaviour via overloading
      * certain methods.
      */
-    public static class DisabledEdgeIterator implements CHEdgeIterator
-    {
+    public static class DisabledEdgeIterator implements CHEdgeIterator {
         @Override
-        public EdgeIterator detach( boolean reverse )
-        {
+        public EdgeIterator detach(boolean reverse) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
+        public EdgeIteratorState setDistance(double dist) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
+        public EdgeIteratorState setFlags(long flags) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean next()
-        {
+        public boolean next() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getEdge()
-        {
+        public int getEdge() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getBaseNode()
-        {
+        public int getBaseNode() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getAdjNode()
-        {
+        public int getAdjNode() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public double getDistance()
-        {
+        public double getDistance() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public long getFlags()
-        {
+        public long getFlags() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public PointList fetchWayGeometry( int type )
-        {
+        public PointList fetchWayGeometry(int type) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
+        public EdgeIteratorState setWayGeometry(PointList list) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public String getName()
-        {
+        public String getName() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setName( String name )
-        {
+        public EdgeIteratorState setName(String name) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean getBoolean( int key, boolean reverse, boolean _default )
-        {
+        public boolean getBool(int key, boolean _default) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean isBackward( FlagEncoder encoder )
-        {
+        public boolean isBackward(FlagEncoder encoder) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean isForward( FlagEncoder encoder )
-        {
+        public boolean isForward(FlagEncoder encoder) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getAdditionalField()
-        {
+        public int getAdditionalField() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
+        public EdgeIteratorState setAdditionalField(int value) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
+        public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean isShortcut()
-        {
+        public boolean isShortcut() {
             return false;
         }
 
         @Override
-        public int getSkippedEdge1()
-        {
+        public int getSkippedEdge1() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getSkippedEdge2()
-        {
+        public int getSkippedEdge2() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
+        public void setSkippedEdges(int edge1, int edge2) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public double getWeight()
-        {
+        public double getWeight() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public CHEdgeIteratorState setWeight( double weight )
-        {
+        public CHEdgeIteratorState setWeight(double weight) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean canBeOverwritten( long flags )
-        {
+        public boolean canBeOverwritten(long flags) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
-    };
-
-    /**
-     * @return the <b>first</b> edge containing the specified nodes base and adj. Returns null if
-     * not found.
-     */
-    public static EdgeIteratorState getEdge( Graph graph, int base, int adj )
-    {
-        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(base);
-        while (iter.next())
-        {
-            if (iter.getAdjNode() == adj)
-                return iter;
-        }
-        return null;
-    }
-
-    /**
-     * Creates unique positive number for specified edgeId taking into account the direction defined
-     * by nodeA, nodeB and reverse.
-     */
-    public static int createEdgeKey( int nodeA, int nodeB, int edgeId, boolean reverse )
-    {
-        edgeId = edgeId << 1;
-        if (reverse)
-            return (nodeA > nodeB) ? edgeId : edgeId + 1;
-        return (nodeA > nodeB) ? edgeId + 1 : edgeId;
-    }
-
-    /**
-     * Returns if the specified edgeKeys (created by createEdgeKey) are identical regardless of the
-     * direction.
-     */
-    public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
-    {
-        return edgeKey1 / 2 == edgeKey2 / 2;
-    }
-
-    /**
-     * Returns the edgeKey of the opposite direction
-     */
-    public static int reverseEdgeKey( int edgeKey )
-    {
-        return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
-    }
-
-    /**
-     * @return edge ID for edgeKey
-     */
-    public static int getEdgeFromEdgeKey( int edgeKey )
-    {
-        return edgeKey / 2;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index bdd3009300..1a921245d9 100755
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -23,54 +23,45 @@
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint3D
-{
+public class GPXEntry extends GHPoint3D {
     private long time;
 
-    public GPXEntry( GHPoint p, long millis )
-    {
+    public GPXEntry(GHPoint p, long millis) {
         this(p.lat, p.lon, millis);
     }
 
-    public GPXEntry( double lat, double lon, long millis )
-    {
+    public GPXEntry(double lat, double lon, long millis) {
         super(lat, lon, Double.NaN);
         this.time = millis;
     }
 
-    public GPXEntry( double lat, double lon, double ele, long millis )
-    {
+    public GPXEntry(double lat, double lon, double ele, long millis) {
         super(lat, lon, ele);
         this.time = millis;
     }
 
-    boolean is3D()
-    {
+    boolean is3D() {
         return !Double.isNaN(ele);
     }
 
     /**
      * The time relative to the start time in milli seconds.
      */
-    public long getTime()
-    {
+    public long getTime() {
         return time;
     }
 
-    public void setTime( long time )
-    {
+    public void setTime(long time) {
         this.time = time;
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         return 59 * super.hashCode() + (int) (time ^ (time >>> 32));
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -79,8 +70,7 @@ public boolean equals( Object obj )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return super.toString() + ", " + time;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 4a926bbaa1..1d5613f827 100755
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,8 @@
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.*;
 import java.lang.reflect.Method;
@@ -35,91 +37,83 @@
 import java.util.*;
 import java.util.Map.Entry;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Several utility classes which are compatible with Java6 on Android.
  * <p>
+ *
  * @author Peter Karich
  * @see Helper7 for none-Android compatible methods.
  */
-public class Helper
-{
+public class Helper {
     public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
     public static final DistanceCalc3D DIST_3D = new DistanceCalc3D();
     public static final DistancePlaneProjection DIST_PLANE = new DistancePlaneProjection();
     public static final AngleCalc ANGLE_CALC = new AngleCalc();
-    private static final Logger LOGGER = LoggerFactory.getLogger(Helper.class);
     public static final Charset UTF_CS = Charset.forName("UTF-8");
     public static final TimeZone UTC = TimeZone.getTimeZone("UTC");
     public static final long MB = 1L << 20;
+    private static final Logger LOGGER = LoggerFactory.getLogger(Helper.class);
+    // +- 180 and +-90 => let use use 400
+    private static final float DEGREE_FACTOR = Integer.MAX_VALUE / 400f;
+    // milli meter is a bit extreme but we have integers
+    private static final float ELE_FACTOR = 1000f;
+
+    private Helper() {
+    }
 
-    public static ArrayList<Integer> tIntListToArrayList( TIntList from )
-    {
+    public static ArrayList<Integer> tIntListToArrayList(TIntList from) {
         int len = from.size();
         ArrayList<Integer> list = new ArrayList<Integer>(len);
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             list.add(from.get(i));
         }
         return list;
     }
 
-    public static Locale getLocale( String param )
-    {
+    public static Locale getLocale(String param) {
         int pointIndex = param.indexOf('.');
         if (pointIndex > 0)
             param = param.substring(0, pointIndex);
 
         param = param.replace("-", "_");
         int index = param.indexOf("_");
-        if (index < 0)
-        {
+        if (index < 0) {
             return new Locale(param);
         }
         return new Locale(param.substring(0, index), param.substring(index + 1));
     }
 
-    static String packageToPath( Package pkg )
-    {
+    static String packageToPath(Package pkg) {
         return pkg.getName().replaceAll("\\.", File.separator);
     }
 
-    public static int countBitValue( int maxTurnCosts )
-    {
-        double val = Math.log(maxTurnCosts) / Math.log(2);
-        int intVal = (int) val;
-        if (val == intVal)
-            return intVal;
-        return intVal + 1;
-    }
+    public static int countBitValue(int maxTurnCosts) {
+        if (maxTurnCosts < 0)
+            throw new IllegalArgumentException("maxTurnCosts cannot be negative " + maxTurnCosts);
 
-    private Helper()
-    {
+        int counter = 0;
+        while (maxTurnCosts > 0) {
+            maxTurnCosts >>= 1;
+            counter++;
+        }
+        return counter++;
     }
 
-    public static void loadProperties( Map<String, String> map, Reader tmpReader ) throws IOException
-    {
+    public static void loadProperties(Map<String, String> map, Reader tmpReader) throws IOException {
         BufferedReader reader = new BufferedReader(tmpReader);
         String line;
-        try
-        {
-            while ((line = reader.readLine()) != null)
-            {
-                if (line.startsWith("//") || line.startsWith("#"))
-                {
+        try {
+            while ((line = reader.readLine()) != null) {
+                if (line.startsWith("//") || line.startsWith("#")) {
                     continue;
                 }
 
-                if (Helper.isEmpty(line))
-                {
+                if (Helper.isEmpty(line)) {
                     continue;
                 }
 
                 int index = line.indexOf("=");
-                if (index < 0)
-                {
+                if (index < 0) {
                     LOGGER.warn("Skipping configuration at line:" + line);
                     continue;
                 }
@@ -128,102 +122,80 @@ public static void loadProperties( Map<String, String> map, Reader tmpReader ) t
                 String value = line.substring(index + 1);
                 map.put(field.trim(), value.trim());
             }
-        } finally
-        {
+        } finally {
             reader.close();
         }
     }
 
-    public static void saveProperties( Map<String, String> map, Writer tmpWriter ) throws IOException
-    {
+    public static void saveProperties(Map<String, String> map, Writer tmpWriter) throws IOException {
         BufferedWriter writer = new BufferedWriter(tmpWriter);
-        try
-        {
-            for (Entry<String, String> e : map.entrySet())
-            {
+        try {
+            for (Entry<String, String> e : map.entrySet()) {
                 writer.append(e.getKey());
                 writer.append('=');
                 writer.append(e.getValue());
                 writer.append('\n');
             }
-        } finally
-        {
+        } finally {
             writer.close();
         }
     }
 
-    public static List<String> readFile( String file ) throws IOException
-    {
+    public static List<String> readFile(String file) throws IOException {
         return readFile(new InputStreamReader(new FileInputStream(file), UTF_CS));
     }
 
-    public static List<String> readFile( Reader simpleReader ) throws IOException
-    {
+    public static List<String> readFile(Reader simpleReader) throws IOException {
         BufferedReader reader = new BufferedReader(simpleReader);
-        try
-        {
+        try {
             List<String> res = new ArrayList<String>();
             String line;
-            while ((line = reader.readLine()) != null)
-            {
+            while ((line = reader.readLine()) != null) {
                 res.add(line);
             }
             return res;
-        } finally
-        {
+        } finally {
             reader.close();
         }
     }
 
-    public static String isToString( InputStream inputStream ) throws IOException
-    {
+    public static String isToString(InputStream inputStream) throws IOException {
         int size = 1024 * 8;
         String encoding = "UTF-8";
         InputStream in = new BufferedInputStream(inputStream, size);
-        try
-        {
+        try {
             byte[] buffer = new byte[size];
             ByteArrayOutputStream output = new ByteArrayOutputStream();
             int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
+            while ((numRead = in.read(buffer)) != -1) {
                 output.write(buffer, 0, numRead);
             }
             return output.toString(encoding);
-        } finally
-        {
+        } finally {
             in.close();
         }
     }
 
-    public static int idealIntArraySize( int need )
-    {
+    public static int idealIntArraySize(int need) {
         return idealByteArraySize(need * 4) / 4;
     }
 
-    public static int idealByteArraySize( int need )
-    {
-        for (int i = 4; i < 32; i++)
-        {
-            if (need <= (1 << i) - 12)
-            {
+    public static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++) {
+            if (need <= (1 << i) - 12) {
                 return (1 << i) - 12;
             }
         }
         return need;
     }
 
-    public static boolean removeDir( File file )
-    {
-        if (!file.exists())
-        {
+    public static boolean removeDir(File file) {
+        if (!file.exists()) {
             return true;
         }
 
-        if (file.isDirectory())
-        {
-            for (File f : file.listFiles())
-            {
+        if (file.isDirectory()) {
+            for (File f : file.listFiles()) {
                 removeDir(f);
             }
         }
@@ -231,76 +203,61 @@ public static boolean removeDir( File file )
         return file.delete();
     }
 
-    public static long getTotalMB()
-    {
+    public static long getTotalMB() {
         return Runtime.getRuntime().totalMemory() / MB;
     }
 
-    public static long getUsedMB()
-    {
+    public static long getUsedMB() {
         return (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / MB;
     }
 
-    public static String getMemInfo()
-    {
+    public static String getMemInfo() {
         return "totalMB:" + getTotalMB() + ", usedMB:" + getUsedMB();
     }
 
-    public static int getSizeOfObjectRef( int factor )
-    {
+    public static int getSizeOfObjectRef(int factor) {
         // pointer to class, flags, lock
         return factor * (4 + 4 + 4);
     }
 
-    public static int getSizeOfLongArray( int length, int factor )
-    {
+    public static int getSizeOfLongArray(int length, int factor) {
         // pointer to class, flags, lock, size
         return factor * (4 + 4 + 4 + 4) + 8 * length;
     }
 
-    public static int getSizeOfObjectArray( int length, int factor )
-    {
+    public static int getSizeOfObjectArray(int length, int factor) {
         // improvements: add 4byte to make a multiple of 8 in some cases plus compressed oop
         return factor * (4 + 4 + 4 + 4) + 4 * length;
     }
 
-    public static void close( Closeable cl )
-    {
-        try
-        {
+    public static void close(Closeable cl) {
+        try {
             if (cl != null)
                 cl.close();
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             throw new RuntimeException("Couldn't close resource", ex);
         }
     }
 
-    public static boolean isEmpty( String str )
-    {
+    public static boolean isEmpty(String str) {
         return str == null || str.trim().length() == 0;
     }
 
     /**
      * Determines if the specified ByteBuffer is one which maps to a file!
      */
-    public static boolean isFileMapped( ByteBuffer bb )
-    {
-        if (bb instanceof MappedByteBuffer)
-        {
-            try
-            {
+    public static boolean isFileMapped(ByteBuffer bb) {
+        if (bb instanceof MappedByteBuffer) {
+            try {
                 ((MappedByteBuffer) bb).isLoaded();
                 return true;
-            } catch (UnsupportedOperationException ex)
-            {
+            } catch (UnsupportedOperationException ex) {
             }
         }
         return false;
     }
 
-    public static int calcIndexSize( BBox graphBounds )
-    {
+    public static int calcIndexSize(BBox graphBounds) {
         if (!graphBounds.isValid())
             throw new IllegalArgumentException("Bounding box is not valid to calculate index size: " + graphBounds);
 
@@ -311,47 +268,48 @@ public static int calcIndexSize( BBox graphBounds )
         return Math.max(2000, (int) (dist * dist));
     }
 
-    public static String pruneFileEnd( String file )
-    {
+    public static String pruneFileEnd(String file) {
         int index = file.lastIndexOf(".");
         if (index < 0)
             return file;
         return file.substring(0, index);
     }
 
-    public static TIntList createTList( int... list )
-    {
+    public static List<Double> createDoubleList(double[] values) {
+        List<Double> list = new ArrayList<>();
+        for (double v : values) {
+            list.add(v);
+        }
+        return list;
+    }
+
+    public static TIntList createTList(int... list) {
         TIntList res = new TIntArrayList(list.length);
-        for (int val : list)
-        {
+        for (int val : list) {
             res.add(val);
         }
         return res;
     }
 
-    public static PointList createPointList( double... list )
-    {
+    public static PointList createPointList(double... list) {
         if (list.length % 2 != 0)
             throw new IllegalArgumentException("list should consist of lat,lon pairs!");
 
         int max = list.length / 2;
         PointList res = new PointList(max, false);
-        for (int i = 0; i < max; i++)
-        {
+        for (int i = 0; i < max; i++) {
             res.add(list[2 * i], list[2 * i + 1], Double.NaN);
         }
         return res;
     }
 
-    public static PointList createPointList3D( double... list )
-    {
+    public static PointList createPointList3D(double... list) {
         if (list.length % 3 != 0)
             throw new IllegalArgumentException("list should consist of lat,lon,ele tuples!");
 
         int max = list.length / 3;
         PointList res = new PointList(max, true);
-        for (int i = 0; i < max; i++)
-        {
+        for (int i = 0; i < max; i++) {
             res.add(list[3 * i], list[3 * i + 1], list[3 * i + 2]);
         }
         return res;
@@ -362,10 +320,10 @@ public static PointList createPointList3D( double... list )
      * only integer values). But this conversion also reduces memory consumption where the precision
      * loss is accceptable. As +- 180° and +-90° are assumed as maximum values.
      * <p>
+     *
      * @return the integer of the specified degree
      */
-    public static final int degreeToInt( double deg )
-    {
+    public static final int degreeToInt(double deg) {
         if (deg >= Double.MAX_VALUE)
             return Integer.MAX_VALUE;
         if (deg <= -Double.MAX_VALUE)
@@ -376,10 +334,10 @@ public static final int degreeToInt( double deg )
     /**
      * Converts back the integer value.
      * <p>
+     *
      * @return the degree value of the specified integer
      */
-    public static final double intToDegree( int storedInt )
-    {
+    public static final double intToDegree(int storedInt) {
         if (storedInt == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
         if (storedInt == -Integer.MAX_VALUE)
@@ -390,8 +348,7 @@ public static final double intToDegree( int storedInt )
     /**
      * Converts elevation value (in meters) into integer for storage.
      */
-    public static final int eleToInt( double ele )
-    {
+    public static final int eleToInt(double ele) {
         if (ele >= Integer.MAX_VALUE)
             return Integer.MAX_VALUE;
         return (int) (ele * ELE_FACTOR);
@@ -401,43 +358,30 @@ public static final int eleToInt( double ele )
      * Converts the integer value retrieved from storage into elevation (in meters). Do not expect
      * more precision than meters although it currently is!
      */
-    public static final double intToEle( int integEle )
-    {
+    public static final double intToEle(int integEle) {
         if (integEle == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
         return integEle / ELE_FACTOR;
     }
 
-    // +- 180 and +-90 => let use use 400
-    private static final float DEGREE_FACTOR = Integer.MAX_VALUE / 400f;
-    // milli meter is a bit extreme but we have integers
-    private static final float ELE_FACTOR = 1000f;
-
-    public static void cleanMappedByteBuffer( final ByteBuffer buffer )
-    {
-        try
-        {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>()
-            {
+    public static void cleanMappedByteBuffer(final ByteBuffer buffer) {
+        try {
+            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
                 @Override
-                public Object run() throws Exception
-                {
-                    try
-                    {
+                public Object run() throws Exception {
+                    try {
                         final Method getCleanerMethod = buffer.getClass().getMethod("cleaner");
                         getCleanerMethod.setAccessible(true);
                         final Object cleaner = getCleanerMethod.invoke(buffer);
                         if (cleaner != null)
                             cleaner.getClass().getMethod("clean").invoke(cleaner);
-                    } catch (NoSuchMethodException ex)
-                    {
+                    } catch (NoSuchMethodException ex) {
                         // ignore if method cleaner or clean is not available, like on Android
                     }
                     return null;
                 }
             });
-        } catch (PrivilegedActionException e)
-        {
+        } catch (PrivilegedActionException e) {
             throw new RuntimeException("unable to unmap the mapped buffer", e);
         }
     }
@@ -446,23 +390,19 @@ public Object run() throws Exception
      * Trying to force the release of the mapped ByteBuffer. See
      * http://stackoverflow.com/q/2972986/194609 and use only if you know what you are doing.
      */
-    public static void cleanHack()
-    {
+    public static void cleanHack() {
         System.gc();
     }
 
-    public static String nf( long no )
-    {
+    public static String nf(long no) {
         // I like french localization the most: 123654 will be 123 654 instead
         // of comma vs. point confusion for english/german guys.
         // NumberFormat is not thread safe => but getInstance looks like it's cached
         return NumberFormat.getInstance(Locale.FRANCE).format(no);
     }
 
-    public static String firstBig( String sayText )
-    {
-        if (sayText == null || sayText.length() <= 0)
-        {
+    public static String firstBig(String sayText) {
+        if (sayText == null || sayText.length() <= 0) {
             return sayText;
         }
 
@@ -472,32 +412,27 @@ public static String firstBig( String sayText )
     /**
      * This methods returns the value or min if too small or max if too big.
      */
-    public static final double keepIn( double value, double min, double max )
-    {
+    public static final double keepIn(double value, double min, double max) {
         return Math.max(min, Math.min(value, max));
     }
 
     /**
      * Round the value to the specified exponent
      */
-    public static double round( double value, int exponent )
-    {
+    public static double round(double value, int exponent) {
         double factor = Math.pow(10, exponent);
         return Math.round(value * factor) / factor;
     }
 
-    public static final double round6( double value )
-    {
+    public static final double round6(double value) {
         return Math.round(value * 1e6) / 1e6;
     }
 
-    public static final double round4( double value )
-    {
+    public static final double round4(double value) {
         return Math.round(value * 1e4) / 1e4;
     }
 
-    public static final double round2( double value )
-    {
+    public static final double round2(double value) {
         return Math.round(value * 100) / 100d;
     }
 
@@ -505,16 +440,14 @@ public static final double round2( double value )
      * This creates a date formatter for yyyy-MM-dd'T'HH:mm:ss'Z' which is has to be identical to
      * buildDate used in pom.xml
      */
-    public static DateFormat createFormatter()
-    {
+    public static DateFormat createFormatter() {
         return createFormatter("yyyy-MM-dd'T'HH:mm:ss'Z'");
     }
 
     /**
      * Creates a SimpleDateFormat with the UK locale.
      */
-    public static DateFormat createFormatter( String str )
-    {
+    public static DateFormat createFormatter(String str) {
         DateFormat df = new SimpleDateFormat(str, Locale.UK);
         df.setTimeZone(UTC);
         return df;
@@ -524,27 +457,23 @@ public static DateFormat createFormatter( String str )
      * This method handles the specified (potentially negative) int as unsigned bit representation
      * and returns the positive converted long.
      */
-    public static final long toUnsignedLong( int x )
-    {
+    public static final long toUnsignedLong(int x) {
         return ((long) x) & 0xFFFFffffL;
     }
 
     /**
      * Converts the specified long back into a signed int (reverse method for toUnsignedLong)
      */
-    public static final int toSignedInt( long x )
-    {
+    public static final int toSignedInt(long x) {
         return (int) x;
     }
 
-    public static final String camelCaseToUnderScore( String key )
-    {
+    public static final String camelCaseToUnderScore(String key) {
         if (key.isEmpty())
             return key;
 
         StringBuilder sb = new StringBuilder(key.length());
-        for (int i = 0; i < key.length(); i++)
-        {
+        for (int i = 0; i < key.length(); i++) {
             char c = key.charAt(i);
             if (Character.isUpperCase(c))
                 sb.append("_").append(Character.toLowerCase(c));
@@ -555,17 +484,14 @@ public static final String camelCaseToUnderScore( String key )
         return sb.toString();
     }
 
-    public static final String underScoreToCamelCase( String key )
-    {
+    public static final String underScoreToCamelCase(String key) {
         if (key.isEmpty())
             return key;
 
         StringBuilder sb = new StringBuilder(key.length());
-        for (int i = 0; i < key.length(); i++)
-        {
+        for (int i = 0; i < key.length(); i++) {
             char c = key.charAt(i);
-            if (c == '_')
-            {
+            if (c == '_') {
                 i++;
                 if (i < key.length())
                     sb.append(Character.toUpperCase(key.charAt(i)));
diff --git a/core/src/main/java/com/graphhopper/util/Helper7.java b/core/src/main/java/com/graphhopper/util/Helper7.java
index 77a927db93..f1807a1778 100755
--- a/core/src/main/java/com/graphhopper/util/Helper7.java
+++ b/core/src/main/java/com/graphhopper/util/Helper7.java
@@ -24,34 +24,30 @@
  * Put the usage of proprietary "sun" classes and after jdk6 classes into this class. To use Helper
  * class under Android as well.
  * <p>
+ *
  * @author Peter Karich
  */
-public class Helper7
-{
+public class Helper7 {
 
     /**
      * <code>true</code>, if this platform supports unmapping mmapped files.
      */
     public static final boolean UNMAP_SUPPORTED;
 
-    static
-    {
+    static {
         boolean v;
-        try
-        {
+        try {
             Class.forName("sun.misc.Cleaner");
             Class.forName("java.nio.DirectByteBuffer")
                     .getMethod("cleaner");
             v = true;
-        } catch (Exception e)
-        {
+        } catch (Exception e) {
             v = false;
         }
         UNMAP_SUPPORTED = v;
     }
 
-    public static String getBeanMemInfo()
-    {
+    public static String getBeanMemInfo() {
         java.lang.management.OperatingSystemMXBean mxbean = java.lang.management.ManagementFactory.getOperatingSystemMXBean();
         com.sun.management.OperatingSystemMXBean sunmxbean = (com.sun.management.OperatingSystemMXBean) mxbean;
         long freeMemory = sunmxbean.getFreePhysicalMemorySize();
@@ -60,16 +56,12 @@ public static String getBeanMemInfo()
                 + ", rfree:" + Runtime.getRuntime().freeMemory() / Helper.MB;
     }
 
-    public static void close( XMLStreamReader r )
-    {
-        try
-        {
-            if (r != null)
-            {
+    public static void close(XMLStreamReader r) {
+        try {
+            if (r != null) {
                 r.close();
             }
-        } catch (XMLStreamException ex)
-        {
+        } catch (XMLStreamException ex) {
             throw new RuntimeException("Couldn't close xml reader", ex);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 0f3e0991f3..7d8c150fc7 100755
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -21,10 +21,7 @@
 import java.util.List;
 import java.util.Map;
 
-public class Instruction
-{
-    private static final AngleCalc AC = Helper.ANGLE_CALC;
-
+public class Instruction {
     public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
@@ -36,21 +33,20 @@
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
     public static final int USE_ROUNDABOUT = 6;
-
+    private static final AngleCalc AC = Helper.ANGLE_CALC;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
     protected boolean rawName;
     protected int sign;
     protected String name;
     protected double distance;
     protected long time;
-    protected final PointList points;
-    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
-    {
+    public Instruction(int sign, String name, InstructionAnnotation ia, PointList pl) {
         this.sign = sign;
         this.name = name;
         this.points = pl;
@@ -61,95 +57,80 @@ public Instruction( int sign, String name, InstructionAnnotation ia, PointList p
      * This method does not perform translation or combination with the sign - it just uses the
      * provided name as instruction.
      */
-    public void setUseRawName()
-    {
+    public void setUseRawName() {
         rawName = true;
     }
 
-    public InstructionAnnotation getAnnotation()
-    {
+    public InstructionAnnotation getAnnotation() {
         return annotation;
     }
 
     /**
      * The instruction for the person/driver to execute.
      */
-    public int getSign()
-    {
+    public int getSign() {
         return sign;
     }
 
-    public String getName()
-    {
+    public String getName() {
         return name;
     }
 
-    public void setName( String name )
-    {
+    public void setName(String name) {
         this.name = name;
     }
 
-    public Map<String, Object> getExtraInfoJSON()
-    {
+    public Map<String, Object> getExtraInfoJSON() {
         return Collections.<String, Object>emptyMap();
     }
 
-    public void setExtraInfo( String key, Object value )
-    {
+    public void setExtraInfo(String key, Object value) {
         throw new IllegalArgumentException("Key" + key + " is not a valid option");
     }
 
-    public Instruction setDistance( double distance )
-    {
-        this.distance = distance;
-        return this;
-    }
-
     /**
      * Distance in meter until no new instruction
      */
-    public double getDistance()
-    {
+    public double getDistance() {
         return distance;
     }
 
-    public Instruction setTime( long time )
-    {
-        this.time = time;
+    public Instruction setDistance(double distance) {
+        this.distance = distance;
         return this;
     }
 
     /**
      * Time in time until no new instruction
      */
-    public long getTime()
-    {
+    public long getTime() {
         return time;
     }
 
+    public Instruction setTime(long time) {
+        this.time = time;
+        return this;
+    }
+
     /**
      * Latitude of the location where this instruction should take place.
      */
-    double getFirstLat()
-    {
+    double getFirstLat() {
         return points.getLatitude(0);
     }
 
     /**
      * Longitude of the location where this instruction should take place.
      */
-    double getFirstLon()
-    {
+    double getFirstLon() {
         return points.getLongitude(0);
     }
 
-    double getFirstEle()
-    {
+    double getFirstEle() {
         return points.getElevation(0);
     }
 
-    public PointList getPoints()
-    {
+    public PointList getPoints() {
         return points;
     }
 
@@ -157,11 +138,11 @@ public PointList getPoints()
      * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
      * <p>
+     *
      * @return the time offset to add for the next instruction
      */
-    long fillGPXList( List<GPXEntry> list, long time,
-                      Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
-    {
+    long fillGPXList(List<GPXEntry> list, long time,
+                     Instruction prevInstr, Instruction nextInstr, boolean firstInstr) {
         checkOne();
         int len = points.size();
         long prevTime = time;
@@ -172,8 +153,7 @@ long fillGPXList( List<GPXEntry> list, long time,
         if (is3D)
             ele = points.getElevation(0);
 
-        for (int i = 0; i < len; i++)
-        {
+        for (int i = 0; i < len; i++) {
             list.add(new GPXEntry(lat, lon, ele, prevTime));
 
             boolean last = i + 1 == len;
@@ -193,8 +173,7 @@ long fillGPXList( List<GPXEntry> list, long time,
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append('(');
         sb.append(sign).append(',');
@@ -209,8 +188,7 @@ public String toString()
      * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String calcDirection( Instruction nextI )
-    {
+    String calcDirection(Instruction nextI) {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
             return "";
@@ -223,21 +201,17 @@ String calcDirection( Instruction nextI )
      * instruction contains less than 2 points then NaN will be returned or the specified
      * instruction will be used if that is the finish instruction.
      */
-    public double calcAzimuth( Instruction nextI )
-    {
+    public double calcAzimuth(Instruction nextI) {
         double nextLat;
         double nextLon;
 
-        if (points.getSize() >= 2)
-        {
+        if (points.getSize() >= 2) {
             nextLat = points.getLatitude(1);
             nextLon = points.getLongitude(1);
-        } else if (nextI != null && points.getSize() == 1)
-        {
+        } else if (nextI != null && points.getSize() == 1) {
             nextLat = nextI.points.getLatitude(0);
             nextLon = nextI.points.getLongitude(0);
-        } else
-        {
+        } else {
             return Double.NaN;
         }
 
@@ -246,28 +220,23 @@ public double calcAzimuth( Instruction nextI )
         return AC.calcAzimuth(lat, lon, nextLat, nextLon);
     }
 
-    void checkOne()
-    {
+    void checkOne() {
         if (points.size() < 1)
             throw new IllegalStateException("Instruction must contain at least one point " + toString());
     }
 
-    public String getTurnDescription( Translation tr )
-    {
+    public String getTurnDescription(Translation tr) {
         if (rawName)
             return getName();
 
         String str;
         String streetName = getName();
         int indi = getSign();
-        if (indi == Instruction.CONTINUE_ON_STREET)
-        {
+        if (indi == Instruction.CONTINUE_ON_STREET) {
             str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
-        } else
-        {
+        } else {
             String dir = null;
-            switch (indi)
-            {
+            switch (indi) {
                 case Instruction.TURN_SHARP_LEFT:
                     dir = tr.tr("turn_sharp_left");
                     break;
diff --git a/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
index 848d98e079..28fa7826ae 100755
--- a/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
@@ -20,62 +20,51 @@
 /**
  * @author Peter Karich
  */
-public class InstructionAnnotation
-{
+public class InstructionAnnotation {
     public final static InstructionAnnotation EMPTY = new InstructionAnnotation();
     private boolean empty;
     private int importance;
     private String message;
 
-    private InstructionAnnotation()
-    {
+    private InstructionAnnotation() {
         setEmpty();
     }
 
-    public InstructionAnnotation( int importance, String message )
-    {
-        if (message.isEmpty() && importance == 0)
-        {
+    public InstructionAnnotation(int importance, String message) {
+        if (message.isEmpty() && importance == 0) {
             setEmpty();
-        } else
-        {
+        } else {
             this.empty = false;
             this.importance = importance;
             this.message = message;
         }
     }
 
-    private void setEmpty()
-    {
+    private void setEmpty() {
         this.empty = true;
         this.importance = 0;
         this.message = "";
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return empty;
     }
 
-    public int getImportance()
-    {
+    public int getImportance() {
         return importance;
     }
 
-    public String getMessage()
-    {
+    public String getMessage() {
         return message;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return importance + ": " + getMessage();
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 3;
         hash = 83 * hash + this.importance;
         hash = 83 * hash + (this.message != null ? this.message.hashCode() : 0);
@@ -83,8 +72,7 @@ public int hashCode()
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
         if (getClass() != obj.getClass())
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 51ff2d8847..8b244c8947 100755
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -23,58 +23,55 @@
 /**
  * List of instructions.
  */
-public class InstructionList implements Iterable<Instruction>
-{
+public class InstructionList implements Iterable<Instruction> {
     public static final InstructionList EMPTY = new InstructionList();
     private final List<Instruction> instructions;
     private final Translation tr;
 
-    private InstructionList()
-    {
+    private InstructionList() {
         this(0, null);
     }
 
-    public InstructionList( Translation tr )
-    {
+    public InstructionList(Translation tr) {
         this(10, tr);
     }
 
-    public InstructionList( int cap, Translation tr )
-    {
+    public InstructionList(int cap, Translation tr) {
         instructions = new ArrayList<Instruction>(cap);
         this.tr = tr;
     }
 
-    public void replaceLast( Instruction instr )
-    {
+    static String simpleXMLEscape(String str) {
+        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
+        return str.replaceAll("&", "&amp;").
+                // but do not care for:
+                replaceAll("[\\<\\>]", "_");
+    }
+
+    public void replaceLast(Instruction instr) {
         if (instructions.isEmpty())
             throw new IllegalStateException("Cannot replace last instruction as list is empty");
 
         instructions.set(instructions.size() - 1, instr);
     }
 
-    public void add( Instruction instr )
-    {
+    public void add(Instruction instr) {
         instructions.add(instr);
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return instructions.size();
     }
 
-    public int size()
-    {
+    public int size() {
         return instructions.size();
     }
 
-    public List<Map<String, Object>> createJson()
-    {
+    public List<Map<String, Object>> createJson() {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
         int pointsIndex = 0;
         int counter = 0;
-        for (Instruction instruction : instructions)
-        {
+        for (Instruction instruction : instructions) {
             Map<String, Object> instrJson = new HashMap<String, Object>();
             instrList.add(instrJson);
 
@@ -83,8 +80,7 @@ public int size()
             if (Helper.isEmpty(str))
                 str = ia.getMessage();
             instrJson.put("text", Helper.firstBig(str));
-            if (!ia.isEmpty())
-            {
+            if (!ia.isEmpty()) {
                 instrJson.put("annotation_text", ia.getMessage());
                 instrJson.put("annotation_importance", ia.getImportance());
             }
@@ -107,25 +103,21 @@ public int size()
         return instrList;
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return instructions.isEmpty();
     }
 
     @Override
-    public Iterator<Instruction> iterator()
-    {
+    public Iterator<Instruction> iterator() {
         return instructions.iterator();
     }
 
-    public Instruction get( int index )
-    {
+    public Instruction get(int index) {
         return instructions.get(index);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return instructions.toString();
     }
 
@@ -134,15 +126,13 @@ public String toString()
      * the first which is 0.
      * <p>
      */
-    public List<GPXEntry> createGPXList()
-    {
+    public List<GPXEntry> createGPXList() {
         if (isEmpty())
             return Collections.emptyList();
 
         List<GPXEntry> gpxList = new ArrayList<GPXEntry>();
         long timeOffset = 0;
-        for (int i = 0; i < size() - 1; i++)
-        {
+        for (int i = 0; i < size() - 1; i++) {
             Instruction prevInstr = (i > 0) ? get(i - 1) : null;
             boolean instrIsFirst = prevInstr == null;
             Instruction nextInstr = get(i + 1);
@@ -163,21 +153,19 @@ public String toString()
      * Creates the standard GPX string out of the points according to the schema found here:
      * https://graphhopper.com/public/schema/gpx-1.1.xsd
      * <p>
+     *
      * @return string to be stored as gpx file
      */
-    public String createGPX()
-    {
+    public String createGPX() {
         return createGPX("GraphHopper", new Date().getTime());
     }
 
-    public String createGPX( String trackName, long startTimeMillis )
-    {
+    public String createGPX(String trackName, long startTimeMillis) {
         boolean includeElevation = getSize() > 0 ? get(0).getPoints().is3D() : false;
         return createGPX(trackName, startTimeMillis, includeElevation, true, true, true);
     }
 
-    private void createWayPointBlock( StringBuilder output, Instruction instruction )
-    {
+    private void createWayPointBlock(StringBuilder output, Instruction instruction) {
         output.append("\n<wpt ");
         output.append("lat=\"").append(Helper.round6(instruction.getFirstLat()));
         output.append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
@@ -191,16 +179,7 @@ private void createWayPointBlock( StringBuilder output, Instruction instruction
         output.append("</wpt>");
     }
 
-    static String simpleXMLEscape( String str )
-    {
-        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
-        return str.replaceAll("&", "&amp;").
-                // but do not care for:
-                replaceAll("[\\<\\>]", "_");
-    }
-
-    public String createGPX( String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints )
-    {
+    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
         DateFormat formatter = Helper.createFormatter();
 
         String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
@@ -217,26 +196,21 @@ public String createGPX( String trackName, long startTimeMillis, boolean include
                 + "<time>" + formatter.format(startTimeMillis) + "</time>"
                 + "</metadata>";
         StringBuilder gpxOutput = new StringBuilder(header);
-        if (!isEmpty())
-        {
-            if (withWayPoints)
-            {                
+        if (!isEmpty()) {
+            if (withWayPoints) {
                 createWayPointBlock(gpxOutput, instructions.get(0));   // Start 
-                for (Instruction currInstr : instructions)
-                {
-                    if ((currInstr.getSign() == Instruction.REACHED_VIA) || // Via 
-                            (currInstr.getSign() == Instruction.FINISH))    // End
+                for (Instruction currInstr : instructions) {
+                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
+                            || (currInstr.getSign() == Instruction.FINISH)) // End
                     {
                         createWayPointBlock(gpxOutput, currInstr);
                     }
                 }
             }
-            if (withRoute)
-            {
+            if (withRoute) {
                 gpxOutput.append("\n<rte>");
                 Instruction nextInstr = null;
-                for (Instruction currInstr : instructions)
-                {
+                for (Instruction currInstr : instructions) {
                     if (null != nextInstr)
                         createRteptBlock(gpxOutput, nextInstr, currInstr);
 
@@ -246,13 +220,11 @@ public String createGPX( String trackName, long startTimeMillis, boolean include
                 gpxOutput.append("\n</rte>");
             }
         }
-        if (withTrack)
-        {
+        if (withTrack) {
             gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
 
             gpxOutput.append("<trkseg>");
-            for (GPXEntry entry : createGPXList())
-            {
+            for (GPXEntry entry : createGPXList()) {
                 gpxOutput.append("\n<trkpt lat=\"").append(Helper.round6(entry.getLat()));
                 gpxOutput.append("\" lon=\"").append(Helper.round6(entry.getLon())).append("\">");
                 if (includeElevation)
@@ -269,8 +241,7 @@ public String createGPX( String trackName, long startTimeMillis, boolean include
         return gpxOutput.toString();
     }
 
-    public void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
-    {
+    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI) {
         output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
                 append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
 
@@ -297,11 +268,9 @@ public void createRteptBlock( StringBuilder output, Instruction instruction, Ins
     /**
      * @return list of lat lon
      */
-    List<List<Double>> createStartPoints()
-    {
+    List<List<Double>> createStartPoints() {
         List<List<Double>> res = new ArrayList<List<Double>>(instructions.size());
-        for (Instruction instruction : instructions)
-        {
+        for (Instruction instruction : instructions) {
             res.add(Arrays.asList(instruction.getFirstLat(), instruction.getFirstLon()));
         }
         return res;
@@ -311,14 +280,13 @@ public void createRteptBlock( StringBuilder output, Instruction instruction, Ins
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
      * <p>
+     *
      * @param maxDistance the maximum acceptable distance to the instruction (in meter)
      * @return the next Instruction or null if too far away.
      */
-    public Instruction find( double lat, double lon, double maxDistance )
-    {
+    public Instruction find(double lat, double lon, double maxDistance) {
         // handle special cases
-        if (getSize() == 0)
-        {
+        if (getSize() == 0) {
             return null;
         }
         PointList points = get(0).getPoints();
@@ -329,35 +297,28 @@ public Instruction find( double lat, double lon, double maxDistance )
         int foundInstruction = 0;
 
         // Search the closest edge to the query point
-        if (getSize() > 1)
-        {
-            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
-            {
+        if (getSize() > 1) {
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++) {
                 points = get(instructionIndex).getPoints();
-                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
-                {
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {
                     double currLat = points.getLatitude(pointIndex);
                     double currLon = points.getLongitude(pointIndex);
 
-                    if (!(instructionIndex == 0 && pointIndex == 0))
-                    {
+                    if (!(instructionIndex == 0 && pointIndex == 0)) {
                         // calculate the distance from the point to the edge
                         double distance;
                         int index = instructionIndex;
-                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
-                        {
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon)) {
                             distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
                             if (pointIndex > 0)
                                 index++;
-                        } else
-                        {
+                        } else {
                             distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
                             if (pointIndex > 0)
                                 index++;
                         }
 
-                        if (distance < foundMinDistance)
-                        {
+                        if (distance < foundMinDistance) {
                             foundMinDistance = distance;
                             foundInstruction = index;
                         }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 98a108056c..3d9e9d361c 100755
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -17,16 +17,15 @@
  */
 package com.graphhopper.util;
 
-import java.text.DecimalFormat;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.text.DecimalFormat;
+
 /**
  * @author Peter Karich
  */
-public abstract class MiniPerfTest
-{
+public abstract class MiniPerfTest {
     protected Logger logger = LoggerFactory.getLogger(getClass());
     private int counts = 100;
     private double fullTime = 0;
@@ -34,16 +33,13 @@
     private double min = Double.MAX_VALUE;
     private int dummySum;
 
-    public MiniPerfTest start()
-    {
+    public MiniPerfTest start() {
         int warmupCount = Math.max(1, counts / 3);
-        for (int i = 0; i < warmupCount; i++)
-        {
+        for (int i = 0; i < warmupCount; i++) {
             dummySum += doCalc(true, i);
         }
         long startFull = System.nanoTime();
-        for (int i = 0; i < counts; i++)
-        {
+        for (int i = 0; i < counts; i++) {
             long start = System.nanoTime();
             dummySum += doCalc(false, i);
             long time = System.nanoTime() - start;
@@ -58,8 +54,7 @@ public MiniPerfTest start()
         return this;
     }
 
-    public MiniPerfTest setIterations( int counts )
-    {
+    public MiniPerfTest setIterations(int counts) {
         this.counts = counts;
         return this;
     }
@@ -67,42 +62,36 @@ public MiniPerfTest setIterations( int counts )
     /**
      * @return minimum time of every call, in ms
      */
-    public double getMin()
-    {
+    public double getMin() {
         return min / 1e6;
     }
 
     /**
      * @return maximum time of every calls, in ms
      */
-    public double getMax()
-    {
+    public double getMax() {
         return max / 1e6;
     }
 
     /**
      * @return time for all calls accumulated, in ms
      */
-    public double getSum()
-    {
+    public double getSum() {
         return fullTime / 1e6;
     }
 
     /**
      * @return mean time per call, in ms
      */
-    public double getMean()
-    {
+    public double getMean() {
         return getSum() / counts;
     }
 
-    public String getReport()
-    {
+    public String getReport() {
         return "sum:" + nf(getSum() / 1000f) + "s, time/call:" + nf(getMean() / 1000f) + "s";
     }
 
-    public String nf( Number num )
-    {
+    public String nf(Number num) {
         return new DecimalFormat("#.#").format(num);
     }
 
@@ -110,5 +99,5 @@ public String nf( Number num )
      * @return return some integer as result from your processing to make sure that the JVM cannot
      * optimize (away) the call or within the call something.
      */
-    public abstract int doCalc( boolean warmup, int run );
+    public abstract int doCalc(boolean warmup, int run);
 }
diff --git a/core/src/main/java/com/graphhopper/util/NotThreadSafe.java b/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
index 9884843fac..45d537920b 100755
--- a/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
+++ b/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
@@ -20,8 +20,8 @@
 /**
  * Marks classes or methods as none thread-safe
  * <p>
+ *
  * @author Peter Karich
  */
-public @interface NotThreadSafe
-{
+public @interface NotThreadSafe {
 }
diff --git a/core/src/main/java/com/graphhopper/util/NumHelper.java b/core/src/main/java/com/graphhopper/util/NumHelper.java
index 69d375d0ed..13aea2a56e 100755
--- a/core/src/main/java/com/graphhopper/util/NumHelper.java
+++ b/core/src/main/java/com/graphhopper/util/NumHelper.java
@@ -20,37 +20,30 @@
 /**
  * @author Peter Karich
  */
-public class NumHelper
-{
+public class NumHelper {
     private final static double DEFAULT_PRECISION = 1e-6;
 
-    public static boolean equalsEps( double d1, double d2 )
-    {
+    public static boolean equalsEps(double d1, double d2) {
         return equalsEps(d1, d2, DEFAULT_PRECISION);
     }
 
-    public static boolean equalsEps( double d1, double d2, double epsilon )
-    {
+    public static boolean equalsEps(double d1, double d2, double epsilon) {
         return Math.abs(d1 - d2) < epsilon;
     }
 
-    public static boolean equals( double d1, double d2 )
-    {
+    public static boolean equals(double d1, double d2) {
         return Double.compare(d1, d2) == 0;
     }
 
-    public static int compare( double d1, double d2 )
-    {
+    public static int compare(double d1, double d2) {
         return Double.compare(d1, d2);
     }
 
-    public static boolean equalsEps( float d1, float d2 )
-    {
+    public static boolean equalsEps(float d1, float d2) {
         return equalsEps(d1, d2, DEFAULT_PRECISION);
     }
 
-    public static boolean equalsEps( float d1, float d2, float epsilon )
-    {
+    public static boolean equalsEps(float d1, float d2, float epsilon) {
         return Math.abs(d1 - d2) < epsilon;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
index 6e850c8d37..24d4d71414 100755
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -21,36 +21,32 @@
 import java.util.Map;
 
 /**
- * A properties map with convenient accessors
+ * A properties map (String to String) with convenient accessors
  * <p>
+ *
  * @author Peter Karich
+ * @see ConfigMap
  */
-public class PMap
-{
+public class PMap {
     private final Map<String, String> map;
 
-    public PMap()
-    {
+    public PMap() {
         this(5);
     }
 
-    public PMap( int capacity )
-    {
+    public PMap(int capacity) {
         this(new HashMap<String, String>(capacity));
     }
 
-    public PMap( Map<String, String> map )
-    {
+    public PMap(Map<String, String> map) {
         this.map = map;
     }
 
-    public PMap( String propertiesString )
-    {
+    public PMap(String propertiesString) {
         // five chosen as arbitrary initial capacity
         this.map = new HashMap<String, String>(5);
 
-        for (String s : propertiesString.split("\\|"))
-        {
+        for (String s : propertiesString.split("\\|")) {
             s = s.trim();
             int index = s.indexOf("=");
             if (index < 0)
@@ -60,14 +56,12 @@ public PMap( String propertiesString )
         }
     }
 
-    public PMap put( PMap map )
-    {
+    public PMap put(PMap map) {
         this.map.putAll(map.map);
         return this;
     }
 
-    public PMap put( String key, Object str )
-    {
+    public PMap put(String key, Object str) {
         if (str == null)
             throw new NullPointerException("Value cannot be null. Use remove instead.");
 
@@ -76,81 +70,62 @@ public PMap put( String key, Object str )
         return this;
     }
 
-    public PMap remove( String key )
-    {
+    public PMap remove(String key) {
         // query accepts camelCase and under_score
         map.remove(Helper.camelCaseToUnderScore(key));
         return this;
     }
 
-    public boolean has( String key )
-    {
+    public boolean has(String key) {
         // query accepts camelCase and under_score
         return map.containsKey(Helper.camelCaseToUnderScore(key));
     }
 
-    public long getLong( String key, long _default )
-    {
+    public long getLong(String key, long _default) {
         String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
+        if (!Helper.isEmpty(str)) {
+            try {
                 return Long.parseLong(str);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
         }
         return _default;
     }
 
-    public int getInt( String key, int _default )
-    {
+    public int getInt(String key, int _default) {
         String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
+        if (!Helper.isEmpty(str)) {
+            try {
                 return Integer.parseInt(str);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
         }
         return _default;
     }
 
-    public boolean getBool( String key, boolean _default )
-    {
+    public boolean getBool(String key, boolean _default) {
         String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
+        if (!Helper.isEmpty(str)) {
+            try {
                 return Boolean.parseBoolean(str);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
         }
         return _default;
     }
 
-    public double getDouble( String key, double _default )
-    {
+    public double getDouble(String key, double _default) {
         String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
+        if (!Helper.isEmpty(str)) {
+            try {
                 return Double.parseDouble(str);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
         }
         return _default;
     }
 
-    public String get( String key, String _default )
-    {
+    public String get(String key, String _default) {
         String str = get(key);
         if (Helper.isEmpty(str))
             return _default;
@@ -158,8 +133,7 @@ public String get( String key, String _default )
         return str;
     }
 
-    String get( String key )
-    {
+    String get(String key) {
         if (Helper.isEmpty(key))
             return "";
 
@@ -174,25 +148,20 @@ String get( String key )
     /**
      * This method copies the underlying structur into a new Map object
      */
-    public Map<String, String> toMap()
-    {
+    public Map<String, String> toMap() {
         return new HashMap<String, String>(map);
     }
 
-    private Map<String, String> getMap()
-    {
+    private Map<String, String> getMap() {
         return map;
     }
 
-    public PMap merge( PMap read )
-    {
+    public PMap merge(PMap read) {
         return merge(read.getMap());
     }
 
-    PMap merge( Map<String, String> map )
-    {
-        for (Map.Entry<String, String> e : map.entrySet())
-        {
+    PMap merge(Map<String, String> map) {
+        for (Map.Entry<String, String> e : map.entrySet()) {
             if (Helper.isEmpty(e.getKey()))
                 continue;
 
@@ -201,9 +170,12 @@ PMap merge( Map<String, String> map )
         return this;
     }
 
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getMap().toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Parameters.java b/core/src/main/java/com/graphhopper/util/Parameters.java
index 23e451c714..09c47efc37 100755
--- a/core/src/main/java/com/graphhopper/util/Parameters.java
+++ b/core/src/main/java/com/graphhopper/util/Parameters.java
@@ -18,19 +18,16 @@
 package com.graphhopper.util;
 
 /**
- *
  * @author Peter Karich
  */
-public class Parameters
-{
+public class Parameters {
     /* Parameters with an 'INIT' prefix are used as defaults and/or are configured at start.*/
     static final String ROUTING_INIT_PREFIX = "routing.";
 
     /**
      * Parameters that can be used for algorithm.
      */
-    public static final class Algorithms
-    {
+    public static final class Algorithms {
         /**
          * Bidirectional Dijkstra
          */
@@ -63,8 +60,7 @@
         /**
          * All public properties for alternative routing.
          */
-        public static final class AltRoute
-        {
+        public static final class AltRoute {
             public static final String MAX_PATHS = ALT_ROUTE + ".max_paths";
 
             public static final String MAX_WEIGHT = ALT_ROUTE + ".max_weight_factor";
@@ -72,21 +68,18 @@
             public static final String MAX_SHARE = ALT_ROUTE + ".max_share_factor";
         }
 
-        public static final class AStar
-        {
+        public static final class AStar {
             public static final String EPSILON = ASTAR + ".epsilon";
         }
 
-        public static final class AStarBi
-        {
+        public static final class AStarBi {
             public static final String EPSILON = ASTAR_BI + ".epsilon";
         }
 
         /**
          * All public properties for round trip calculation.
          */
-        public static final class RoundTrip
-        {
+        public static final class RoundTrip {
             public static final String DISTANCE = ROUND_TRIP + ".distance";
             public static final String SEED = ROUND_TRIP + ".seed";
             public static final String HEADING = "heading";
@@ -97,8 +90,7 @@
     /**
      * Parameters that can be passed as hints and influence routing per request.
      */
-    public static final class Routing
-    {
+    public static final class Routing {
         public static final String EDGE_BASED = "edge_based";
         public static final String MAX_VISITED_NODES = "max_visited_nodes";
         public static final String INIT_MAX_VISITED_NODES = ROUTING_INIT_PREFIX + "max_visited_nodes";
@@ -122,8 +114,7 @@
     /**
      * Properties for CH routing
      */
-    public static final class CH
-    {
+    public static final class CH {
         /**
          * This property name in HintsMap configures at runtime if CH routing should be ignored.
          */
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 0f8294dfd1..70a06cb2f0 100755
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -19,49 +19,47 @@
 
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.Path;
+import com.graphhopper.util.exceptions.ConnectionNotFoundException;
+
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
  * This class merges a list of points into one point recognizing the specified places.
  * <p>
+ *
  * @author Peter Karich
  * @author ratrun
  */
-public class PathMerger
-{
+public class PathMerger {
     private static final DouglasPeucker DP = new DouglasPeucker();
     private boolean enableInstructions = true;
     private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker = DP;
     private boolean calcPoints = true;
 
-    public PathMerger setCalcPoints( boolean calcPoints )
-    {
+    public PathMerger setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
         return this;
     }
 
-    public PathMerger setDouglasPeucker( DouglasPeucker douglasPeucker )
-    {
+    public PathMerger setDouglasPeucker(DouglasPeucker douglasPeucker) {
         this.douglasPeucker = douglasPeucker;
         return this;
     }
 
-    public PathMerger setSimplifyResponse( boolean simplifyRes )
-    {
+    public PathMerger setSimplifyResponse(boolean simplifyRes) {
         this.simplifyResponse = simplifyRes;
         return this;
     }
 
-    public PathMerger setEnableInstructions( boolean enableInstructions )
-    {
+    public PathMerger setEnableInstructions(boolean enableInstructions) {
         this.enableInstructions = enableInstructions;
         return this;
     }
 
-    public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
-    {
+    public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         int origPoints = 0;
         long fullTimeInMillis = 0;
         double fullWeight = 0;
@@ -71,30 +69,24 @@ public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
         InstructionList fullInstructions = new InstructionList(tr);
         PointList fullPoints = PointList.EMPTY;
         List<String> description = new ArrayList<String>();
-        for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++)
-        {
+        for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
             Path path = paths.get(pathIndex);
             description.addAll(path.getDescription());
             fullTimeInMillis += path.getTime();
             fullDistance += path.getDistance();
             fullWeight += path.getWeight();
-            if (enableInstructions)
-            {
+            if (enableInstructions) {
                 InstructionList il = path.calcInstructions(tr);
 
-                if (!il.isEmpty())
-                {
-                    if (fullPoints.isEmpty())
-                    {
+                if (!il.isEmpty()) {
+                    if (fullPoints.isEmpty()) {
                         PointList pl = il.get(0).getPoints();
                         // do a wild guess about the total number of points to avoid reallocation a bit
                         fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
                     }
 
-                    for (Instruction i : il)
-                    {
-                        if (simplifyResponse)
-                        {
+                    for (Instruction i : il) {
+                        if (simplifyResponse) {
                             origPoints += i.getPoints().size();
                             douglasPeucker.simplify(i.getPoints());
                         }
@@ -103,22 +95,19 @@ public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
                     }
 
                     // if not yet reached finish replace with 'reached via'
-                    if (pathIndex + 1 < paths.size())
-                    {
+                    if (pathIndex + 1 < paths.size()) {
                         ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
                         newInstr.setViaCount(pathIndex + 1);
                         fullInstructions.replaceLast(newInstr);
                     }
                 }
 
-            } else if (calcPoints)
-            {
+            } else if (calcPoints) {
                 PointList tmpPoints = path.calcPoints();
                 if (fullPoints.isEmpty())
                     fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
-                if (simplifyResponse)
-                {
+                if (simplifyResponse) {
                     origPoints = tmpPoints.getSize();
                     douglasPeucker.simplify(tmpPoints);
                 }
@@ -128,8 +117,7 @@ public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
             allFound = allFound && path.isFound();
         }
 
-        if (!fullPoints.isEmpty())
-        {
+        if (!fullPoints.isEmpty()) {
             String debug = altRsp.getDebugInfo() + ", simplify (" + origPoints + "->" + fullPoints.getSize() + ")";
             altRsp.addDebugInfo(debug);
             if (fullPoints.is3D)
@@ -140,7 +128,7 @@ public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
             altRsp.setInstructions(fullInstructions);
 
         if (!allFound)
-            altRsp.addError(new RuntimeException("Connection between locations not found"));
+            altRsp.addError(new ConnectionNotFoundException("Connection between locations not found", Collections.<String, Object>emptyMap()));
 
         altRsp.setDescription(description).
                 setPoints(fullPoints).
@@ -149,13 +137,11 @@ public void doWork( PathWrapper altRsp, List<Path> paths, Translation tr )
                 setTime(fullTimeInMillis);
     }
 
-    private void calcAscendDescend( final PathWrapper rsp, final PointList pointList )
-    {
+    private void calcAscendDescend(final PathWrapper rsp, final PointList pointList) {
         double ascendMeters = 0;
         double descendMeters = 0;
         double lastEle = pointList.getElevation(0);
-        for (int i = 1; i < pointList.size(); ++i)
-        {
+        for (int i = 1; i < pointList.size(); ++i) {
             double ele = pointList.getElevation(i);
             double diff = Math.abs(ele - lastEle);
 
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index 92b1567f87..368decb38b 100755
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -20,8 +20,7 @@
 /**
  * @author Peter Karich
  */
-public interface PointAccess
-{
+public interface PointAccess {
     /**
      * @return true if elevation data is stored and can be retrieved
      */
@@ -36,7 +35,7 @@
      * This method ensures that the node with the specified index exists i.e. allocates space for
      * it.
      */
-    void ensureNode( int nodeId );
+    void ensureNode(int nodeId);
 
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
@@ -44,7 +43,7 @@
      * <p>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
-    void setNode( int nodeId, double lat, double lon );
+    void setNode(int nodeId, double lat, double lon);
 
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
@@ -52,26 +51,26 @@
      * <p>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
-    void setNode( int nodeId, double lat, double lon, double ele );
+    void setNode(int nodeId, double lat, double lon, double ele);
 
     /**
      * @return the latitude at the specified node index
      */
-    double getLatitude( int nodeId );
+    double getLatitude(int nodeId);
 
-    double getLat( int nodeId );
+    double getLat(int nodeId);
 
     /**
      * @return the longitude at the specified node index
      */
-    double getLongitude( int nodeId );
+    double getLongitude(int nodeId);
 
-    double getLon( int nodeId );
+    double getLon(int nodeId);
 
     /**
      * Returns the elevation of the specified nodeId.
      */
-    double getElevation( int nodeId );
+    double getElevation(int nodeId);
 
-    double getEle( int nodeId );
+    double getEle(int nodeId);
 }
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index c391e667a8..d810e856ed 100755
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -25,25 +25,129 @@
 /**
  * Slim list to store several points (without the need for a point object).
  * <p>
+ *
  * @author Peter Karich
  */
-public class PointList implements Iterable<GHPoint3D>, PointAccess
-{
+public class PointList implements Iterable<GHPoint3D>, PointAccess {
+    public static final PointList EMPTY = new PointList(0, true) {
+        @Override
+        public void set(int index, double lat, double lon, double ele) {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public void add(double lat, double lon, double ele) {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public double getLatitude(int index) {
+            throw new RuntimeException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getLongitude(int index) {
+            throw new RuntimeException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return true;
+        }
+
+        @Override
+        public void clear() {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public void trimToSize(int newSize) {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public void parse2DJSON(String str) {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public double calcDistance(DistanceCalc calc) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public PointList copy(int from, int end) {
+            throw new RuntimeException("cannot copy EMPTY PointList");
+        }
+
+        @Override
+        public PointList clone(boolean reverse) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getElevation(int index) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getLat(int index) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getLon(int index) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getEle(int index) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public List<Double[]> toGeoJson() {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public void reverse() {
+            throw new UnsupportedOperationException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public int getSize() {
+            return 0;
+        }
+
+        @Override
+        public int size() {
+            return 0;
+        }
+
+        @Override
+        public GHPoint3D toGHPoint(int index) {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public boolean is3D() {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+    };
     private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private static String ERR_MSG = "Tried to access PointList with too big index!";
+    protected int size = 0;
+    protected boolean is3D;
     private double[] latitudes;
     private double[] longitudes;
     private double[] elevations;
-    protected int size = 0;
-    protected boolean is3D;
 
-    public PointList()
-    {
+    public PointList() {
         this(10, false);
     }
 
-    public PointList( int cap, boolean is3D )
-    {
+    public PointList(int cap, boolean is3D) {
         latitudes = new double[cap];
         longitudes = new double[cap];
         this.is3D = is3D;
@@ -52,39 +156,33 @@ public PointList( int cap, boolean is3D )
     }
 
     @Override
-    public boolean is3D()
-    {
+    public boolean is3D() {
         return is3D;
     }
 
     @Override
-    public int getDimension()
-    {
+    public int getDimension() {
         if (is3D)
             return 3;
         return 2;
     }
 
     @Override
-    public void ensureNode( int nodeId )
-    {
+    public void ensureNode(int nodeId) {
         incCap(nodeId + 1);
     }
 
     @Override
-    public void setNode( int nodeId, double lat, double lon )
-    {
+    public void setNode(int nodeId, double lat, double lon) {
         set(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int nodeId, double lat, double lon, double ele )
-    {
+    public void setNode(int nodeId, double lat, double lon, double ele) {
         set(nodeId, lat, lon, ele);
     }
 
-    public void set( int index, double lat, double lon, double ele )
-    {
+    public void set(int index, double lat, double lon, double ele) {
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException("index has to be smaller than size " + size);
 
@@ -96,8 +194,7 @@ else if (!Double.isNaN(ele))
             throw new IllegalStateException("This is a 2D list we cannot store elevation: " + ele);
     }
 
-    private void incCap( int newSize )
-    {
+    private void incCap(int newSize) {
         if (newSize <= latitudes.length)
             return;
 
@@ -110,15 +207,13 @@ private void incCap( int newSize )
             elevations = Arrays.copyOf(elevations, cap);
     }
 
-    public void add( double lat, double lon )
-    {
+    public void add(double lat, double lon) {
         if (is3D)
             throw new IllegalStateException("Cannot add point without elevation data in 3D mode");
         add(lat, lon, Double.NaN);
     }
 
-    public void add( double lat, double lon, double ele )
-    {
+    public void add(double lat, double lon, double ele) {
         int newSize = size + 1;
         incCap(newSize);
         latitudes[size] = lat;
@@ -130,28 +225,24 @@ else if (!Double.isNaN(ele))
         size = newSize;
     }
 
-    public void add( PointAccess nodeAccess, int index )
-    {
+    public void add(PointAccess nodeAccess, int index) {
         if (is3D)
             add(nodeAccess.getLatitude(index), nodeAccess.getLongitude(index), nodeAccess.getElevation(index));
         else
             add(nodeAccess.getLatitude(index), nodeAccess.getLongitude(index));
     }
 
-    public void add( GHPoint point )
-    {
+    public void add(GHPoint point) {
         if (is3D)
             add(point.lat, point.lon, ((GHPoint3D) point).ele);
         else
             add(point.lat, point.lon);
     }
 
-    public void add( PointList points )
-    {
+    public void add(PointList points) {
         int newSize = size + points.getSize();
         incCap(newSize);
-        for (int i = 0; i < points.getSize(); i++)
-        {
+        for (int i = 0; i < points.getSize(); i++) {
             int tmp = size + i;
             latitudes[tmp] = points.getLatitude(i);
             longitudes[tmp] = points.getLongitude(i);
@@ -161,30 +252,25 @@ public void add( PointList points )
         size = newSize;
     }
 
-    public int size()
-    {
+    public int size() {
         return size;
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return size;
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return size == 0;
     }
 
     @Override
-    public double getLat( int index )
-    {
+    public double getLat(int index) {
         return getLatitude(index);
     }
 
     @Override
-    public double getLatitude( int index )
-    {
+    public double getLatitude(int index) {
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
 
@@ -192,14 +278,12 @@ public double getLatitude( int index )
     }
 
     @Override
-    public double getLon( int index )
-    {
+    public double getLon(int index) {
         return getLongitude(index);
     }
 
     @Override
-    public double getLongitude( int index )
-    {
+    public double getLongitude(int index) {
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
 
@@ -207,8 +291,7 @@ public double getLongitude( int index )
     }
 
     @Override
-    public double getElevation( int index )
-    {
+    public double getElevation(int index) {
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
         if (!is3D)
@@ -218,17 +301,14 @@ public double getElevation( int index )
     }
 
     @Override
-    public double getEle( int index )
-    {
+    public double getEle(int index) {
         return getElevation(index);
     }
 
-    public void reverse()
-    {
+    public void reverse() {
         // in-place reverse
         int max = size / 2;
-        for (int i = 0; i < max; i++)
-        {
+        for (int i = 0; i < max; i++) {
             int swapIndex = size - i - 1;
 
             double tmp = latitudes[i];
@@ -239,8 +319,7 @@ public void reverse()
             longitudes[i] = longitudes[swapIndex];
             longitudes[swapIndex] = tmp;
 
-            if (is3D)
-            {
+            if (is3D) {
                 tmp = elevations[i];
                 elevations[i] = elevations[swapIndex];
                 elevations[swapIndex] = tmp;
@@ -248,13 +327,11 @@ public void reverse()
         }
     }
 
-    public void clear()
-    {
+    public void clear() {
         size = 0;
     }
 
-    public void trimToSize( int newSize )
-    {
+    public void trimToSize(int newSize) {
         if (newSize > size)
             throw new IllegalArgumentException("new size needs be smaller than old size");
 
@@ -262,11 +339,9 @@ public void trimToSize( int newSize )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < size; i++)
-        {
+        for (int i = 0; i < size; i++) {
             if (i > 0)
                 sb.append(", ");
 
@@ -274,8 +349,7 @@ public String toString()
             sb.append(latitudes[i]);
             sb.append(',');
             sb.append(longitudes[i]);
-            if (is3D)
-            {
+            if (is3D) {
                 sb.append(',');
                 sb.append(elevations[i]);
             }
@@ -287,26 +361,21 @@ public String toString()
     /**
      * Attention: geoJson is LON,LAT or LON,LAT,ELE
      */
-    public List<Double[]> toGeoJson()
-    {
+    public List<Double[]> toGeoJson() {
         return toGeoJson(is3D);
     }
 
-    public List<Double[]> toGeoJson( boolean includeElevation )
-    {
+    public List<Double[]> toGeoJson(boolean includeElevation) {
 
         ArrayList<Double[]> points = new ArrayList<Double[]>(size);
-        for (int i = 0; i < size; i++)
-        {
+        for (int i = 0; i < size; i++) {
             if (includeElevation)
-                points.add(new Double[]
-                {
+                points.add(new Double[]{
                     Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)),
                     Helper.round2(getElevation(i))
                 });
             else
-                points.add(new Double[]
-                {
+                points.add(new Double[]{
                     Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
                 });
         }
@@ -314,8 +383,7 @@ public String toString()
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -326,8 +394,7 @@ public boolean equals( Object obj )
         if (this.getSize() != other.getSize() || this.is3D() != other.is3D())
             return false;
 
-        for (int i = 0; i < size; i++)
-        {
+        for (int i = 0; i < size; i++) {
             if (!NumHelper.equalsEps(latitudes[i], other.latitudes[i]))
                 return false;
 
@@ -340,17 +407,14 @@ public boolean equals( Object obj )
         return true;
     }
 
-    public PointList clone( boolean reverse )
-    {
+    public PointList clone(boolean reverse) {
         PointList clonePL = new PointList(size, is3D);
         if (is3D)
-            for (int i = 0; i < size; i++)
-            {
+            for (int i = 0; i < size; i++) {
                 clonePL.add(latitudes[i], longitudes[i], elevations[i]);
             }
         else
-            for (int i = 0; i < size; i++)
-            {
+            for (int i = 0; i < size; i++) {
                 clonePL.add(latitudes[i], longitudes[i]);
             }
         if (reverse)
@@ -358,8 +422,7 @@ public PointList clone( boolean reverse )
         return clonePL;
     }
 
-    public PointList copy( int from, int end )
-    {
+    public PointList copy(int from, int end) {
         if (from > end)
             throw new IllegalArgumentException("from must be smaller or equals to end");
         if (from < 0 || end > size)
@@ -367,13 +430,11 @@ public PointList copy( int from, int end )
 
         PointList copyPL = new PointList(size, is3D);
         if (is3D)
-            for (int i = from; i < end; i++)
-            {
+            for (int i = from; i < end; i++) {
                 copyPL.add(latitudes[i], longitudes[i], elevations[i]);
             }
         else
-            for (int i = from; i < end; i++)
-            {
+            for (int i = from; i < end; i++) {
                 copyPL.add(latitudes[i], longitudes[i], Double.NaN);
             }
 
@@ -381,11 +442,9 @@ public PointList copy( int from, int end )
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 5;
-        for (int i = 0; i < latitudes.length; i++)
-        {
+        for (int i = 0; i < latitudes.length; i++) {
             hash = 73 * hash + (int) Math.round(latitudes[i] * 1000000);
             hash = 73 * hash + (int) Math.round(longitudes[i] * 1000000);
         }
@@ -393,16 +452,13 @@ public int hashCode()
         return hash;
     }
 
-    public double calcDistance( DistanceCalc calc )
-    {
+    public double calcDistance(DistanceCalc calc) {
         double prevLat = Double.NaN;
         double prevLon = Double.NaN;
         double prevEle = Double.NaN;
         double dist = 0;
-        for (int i = 0; i < size; i++)
-        {
-            if (i > 0)
-            {
+        for (int i = 0; i < size; i++) {
+            if (i > 0) {
                 if (is3D)
                     dist += distCalc3D.calcDist(prevLat, prevLon, prevEle, latitudes[i], longitudes[i], elevations[i]);
                 else
@@ -421,10 +477,8 @@ public double calcDistance( DistanceCalc calc )
      * Takes the string from a json array ala [lon1,lat1], [lon2,lat2], ... and fills the list from
      * it.
      */
-    public void parse2DJSON( String str )
-    {
-        for (String latlon : str.split("\\["))
-        {
+    public void parse2DJSON(String str) {
+        for (String latlon : str.split("\\[")) {
             if (latlon.trim().length() == 0)
                 continue;
 
@@ -434,161 +488,26 @@ public void parse2DJSON( String str )
         }
     }
 
-    public GHPoint3D toGHPoint( int index )
-    {
+    public GHPoint3D toGHPoint(int index) {
         return new GHPoint3D(getLatitude(index), getLongitude(index), getElevation(index));
     }
 
-    public static final PointList EMPTY = new PointList(0, true)
-    {
-        @Override
-        public void set( int index, double lat, double lon, double ele )
-        {
-            throw new RuntimeException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public void add( double lat, double lon, double ele )
-        {
-            throw new RuntimeException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public double getLatitude( int index )
-        {
-            throw new RuntimeException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public double getLongitude( int index )
-        {
-            throw new RuntimeException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public boolean isEmpty()
-        {
-            return true;
-        }
-
-        @Override
-        public void clear()
-        {
-            throw new RuntimeException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public void trimToSize( int newSize )
-        {
-            throw new RuntimeException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public void parse2DJSON( String str )
-        {
-            throw new RuntimeException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public double calcDistance( DistanceCalc calc )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public PointList copy( int from, int end )
-        {
-            throw new RuntimeException("cannot copy EMPTY PointList");
-        }
-
-        @Override
-        public PointList clone( boolean reverse )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public double getElevation( int index )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public double getLat( int index )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public double getLon( int index )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public double getEle( int index )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public List<Double[]> toGeoJson()
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public void reverse()
-        {
-            throw new UnsupportedOperationException("cannot change EMPTY PointList");
-        }
-
-        @Override
-        public int getSize()
-        {
-            return 0;
-        }
-
-        @Override
-        public int size()
-        {
-            return 0;
-        }
-
-        @Override
-        public GHPoint3D toGHPoint( int index )
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
-        @Override
-        public boolean is3D()
-        {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-    };
-
-    int getCapacity()
-    {
+    int getCapacity() {
         return latitudes.length;
     }
 
     @Override
-    public Iterator<GHPoint3D> iterator()
-    {
-        return new Iterator<GHPoint3D>()
-        {
+    public Iterator<GHPoint3D> iterator() {
+        return new Iterator<GHPoint3D>() {
             int counter = 0;
 
             @Override
-            public boolean hasNext()
-            {
+            public boolean hasNext() {
                 return counter < getSize();
             }
 
             @Override
-            public GHPoint3D next()
-            {
+            public GHPoint3D next() {
                 if (counter >= getSize())
                     throw new NoSuchElementException();
 
@@ -598,8 +517,7 @@ public GHPoint3D next()
             }
 
             @Override
-            public void remove()
-            {
+            public void remove() {
                 throw new UnsupportedOperationException("Not supported.");
             }
         };
diff --git a/core/src/main/java/com/graphhopper/util/ProgressListener.java b/core/src/main/java/com/graphhopper/util/ProgressListener.java
index d47604bb4e..1016aca2d6 100755
--- a/core/src/main/java/com/graphhopper/util/ProgressListener.java
+++ b/core/src/main/java/com/graphhopper/util/ProgressListener.java
@@ -20,7 +20,6 @@
 /**
  * @author Peter Karich
  */
-public interface ProgressListener
-{
-    void update( long val );
+public interface ProgressListener {
+    void update(long val);
 }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index e711cc460c..9daf81b583 100755
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -23,67 +23,55 @@
 /**
  * @author jansoe
  */
-public class RoundaboutInstruction extends Instruction
-{
+public class RoundaboutInstruction extends Instruction {
     private int exitNumber = 0;
     // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
     private int clockwise = 0;
     private boolean exited = false;
     private double radian = Double.NaN;
 
-    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
-    {
+    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl) {
         super(sign, name, ia, pl);
     }
 
-    public RoundaboutInstruction increaseExitNumber()
-    {
+    public RoundaboutInstruction increaseExitNumber() {
         this.exitNumber += 1;
         return this;
     }
 
-    public RoundaboutInstruction setExitNumber( int exitNumber )
-    {
-        this.exitNumber = exitNumber;
-        return this;
-    }
-
-    public RoundaboutInstruction setDirOfRotation( double deltaIn )
-    {
-        if (clockwise == 0)
-        {
+    public RoundaboutInstruction setDirOfRotation(double deltaIn) {
+        if (clockwise == 0) {
             clockwise = deltaIn > 0 ? 1 : -1;
-        } else
-        {
+        } else {
             int clockwise2 = deltaIn > 0 ? 1 : -1;
-            if (clockwise != clockwise2)
-            {
+            if (clockwise != clockwise2) {
                 clockwise = 2;
             }
         }
         return this;
     }
 
-    public RoundaboutInstruction setExited()
-    {
+    public RoundaboutInstruction setExited() {
         exited = true;
         return this;
     }
 
-    public boolean isExited()
-    {
+    public boolean isExited() {
         return exited;
     }
 
-    public int getExitNumber()
-    {
-        if (exited && exitNumber == 0)
-        {
+    public int getExitNumber() {
+        if (exited && exitNumber == 0) {
             throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
         }
         return exitNumber;
     }
 
+    public RoundaboutInstruction setExitNumber(int exitNumber) {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
     /**
      * @return radian of angle -2PI &lt; x &lt; 2PI between roundabout entrance and exit values
      * <ul>
@@ -92,8 +80,7 @@ public int getExitNumber()
      * <li>NaN if direction of rotation is unclear</li>
      * </ul>
      */
-    public double getTurnAngle()
-    {
+    public double getTurnAngle() {
         if (Math.abs(clockwise) != 1)
             return Double.NaN;
         else
@@ -103,15 +90,13 @@ public double getTurnAngle()
     /**
      * The radian value between entrance (in) and exit (out) of this roundabout.
      */
-    public RoundaboutInstruction setRadian( double radian )
-    {
+    public RoundaboutInstruction setRadian(double radian) {
         this.radian = radian;
         return this;
     }
 
     @Override
-    public Map<String, Object> getExtraInfoJSON()
-    {
+    public Map<String, Object> getExtraInfoJSON() {
         Map<String, Object> tmpMap = new HashMap<String, Object>(2);
         tmpMap.put("exit_number", getExitNumber());
         double tmpAngle = getTurnAngle();
@@ -123,26 +108,21 @@ public RoundaboutInstruction setRadian( double radian )
     }
 
     @Override
-    public String getTurnDescription( Translation tr )
-    {
+    public String getTurnDescription(Translation tr) {
         if (rawName)
             return getName();
 
         String str;
         String streetName = getName();
         int indi = getSign();
-        if (indi == Instruction.USE_ROUNDABOUT)
-        {
-            if (!exited)
-            {
+        if (indi == Instruction.USE_ROUNDABOUT) {
+            if (!exited) {
                 str = tr.tr("roundabout_enter");
-            } else
-            {
+            } else {
                 str = Helper.isEmpty(streetName) ? tr.tr("roundabout_exit", getExitNumber())
                         : tr.tr("roundabout_exit_onto", getExitNumber(), streetName);
             }
-        } else
-        {
+        } else {
             throw new IllegalStateException(indi + "no roundabout indication");
         }
         return str;
diff --git a/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java b/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
index 369d08905a..3c7409fb58 100755
--- a/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
+++ b/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
@@ -22,29 +22,25 @@
 /**
  * push to end, pop from beginning
  * <p>
+ *
  * @author Peter Karich
  */
-public class SimpleIntDeque
-{
+public class SimpleIntDeque {
     private int[] arr;
     private float growFactor;
     private int frontIndex;
     private int endIndexPlusOne;
 
-    public SimpleIntDeque()
-    {
+    public SimpleIntDeque() {
         this(100, 2);
     }
 
-    public SimpleIntDeque( int initSize )
-    {
+    public SimpleIntDeque(int initSize) {
         this(initSize, 2);
     }
 
-    public SimpleIntDeque( int initSize, float growFactor )
-    {
-        if ((int) (initSize * growFactor) <= initSize)
-        {
+    public SimpleIntDeque(int initSize, float growFactor) {
+        if ((int) (initSize * growFactor) <= initSize) {
             throw new RuntimeException("initial size or increasing grow-factor too low!");
         }
 
@@ -52,30 +48,25 @@ public SimpleIntDeque( int initSize, float growFactor )
         this.arr = new int[initSize];
     }
 
-    int getCapacity()
-    {
+    int getCapacity() {
         return arr.length;
     }
 
-    public void setGrowFactor( float factor )
-    {
+    public void setGrowFactor(float factor) {
         this.growFactor = factor;
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return frontIndex >= endIndexPlusOne;
     }
 
-    public int pop()
-    {
+    public int pop() {
         int tmp = arr[frontIndex];
         frontIndex++;
 
         // removing the empty space of the front if too much is unused        
         int smallerSize = (int) (arr.length / growFactor);
-        if (frontIndex > smallerSize)
-        {
+        if (frontIndex > smallerSize) {
             endIndexPlusOne = getSize();
             // ensure that there are at least 10 entries
             int[] newArr = new int[endIndexPlusOne + 10];
@@ -87,15 +78,12 @@ public int pop()
         return tmp;
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return endIndexPlusOne - frontIndex;
     }
 
-    public void push( int v )
-    {
-        if (endIndexPlusOne >= arr.length)
-        {
+    public void push(int v) {
+        if (endIndexPlusOne >= arr.length) {
             arr = Arrays.copyOf(arr, (int) (arr.length * growFactor));
         }
 
@@ -104,13 +92,10 @@ public void push( int v )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = frontIndex; i < endIndexPlusOne; i++)
-        {
-            if (i > frontIndex)
-            {
+        for (int i = frontIndex; i < endIndexPlusOne; i++) {
+            if (i > frontIndex) {
                 sb.append(", ");
             }
             sb.append(arr[i]);
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index 784e9ca91f..f32034478b 100755
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -20,37 +20,32 @@
 /**
  * Make simple speed measurements possible.
  * <p>
+ *
  * @author Peter Karich
  */
-public class StopWatch
-{
+public class StopWatch {
     private long lastTime;
     private long nanoTime;
     private String name = "";
 
-    public StopWatch( String name )
-    {
+    public StopWatch(String name) {
         this.name = name;
     }
 
-    public StopWatch()
-    {
+    public StopWatch() {
     }
 
-    public StopWatch setName( String name )
-    {
+    public StopWatch setName(String name) {
         this.name = name;
         return this;
     }
 
-    public StopWatch start()
-    {
+    public StopWatch start() {
         lastTime = System.nanoTime();
         return this;
     }
 
-    public StopWatch stop()
-    {
+    public StopWatch stop() {
         if (lastTime < 0)
             return this;
 
@@ -62,30 +57,25 @@ public StopWatch stop()
     /**
      * @return the time delta in milliseconds
      */
-    public long getTime()
-    {
+    public long getTime() {
         return nanoTime / 1000000;
     }
 
-    public long getNanos()
-    {
+    public long getNanos() {
         return nanoTime;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = "";
-        if (!Helper.isEmpty(name))
-        {
+        if (!Helper.isEmpty(name)) {
             str += name + " ";
         }
 
         return str + "time:" + getSeconds();
     }
 
-    public float getSeconds()
-    {
+    public float getSeconds() {
         return nanoTime / 1e9f;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Translation.java b/core/src/main/java/com/graphhopper/util/Translation.java
index 9717f82ad8..002af95cdd 100755
--- a/core/src/main/java/com/graphhopper/util/Translation.java
+++ b/core/src/main/java/com/graphhopper/util/Translation.java
@@ -23,10 +23,9 @@
 /**
  * @author Peter Karich
  */
-public interface Translation
-{
+public interface Translation {
 
-    String tr( String key, Object... params );
+    String tr(String key, Object... params);
 
     Map<String, String> asMap();
 
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index eb8b13f599..5d6360c942 100755
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -25,10 +25,10 @@
  * A class which manages the translations in-memory. See here for more information:
  * ./docs/core/translations.md
  * <p>
+ *
  * @author Peter Karich
  */
-public class TranslationMap
-{
+public class TranslationMap {
     // ISO codes (639-1), use 'en_US' as reference
     private static final List<String> LOCALES = Arrays.asList("ar", "ast", "bg", "ca",
             "cs_CZ", "da_DK", "de_DE", "el", "en_US", "es", "fa", "fil", "fi",
@@ -37,23 +37,25 @@
             "vi_VI", "zh_CN", "zh_HK");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
+    public static int countOccurence(String phrase, String splitter) {
+        if (Helper.isEmpty(phrase))
+            return 0;
+        return phrase.trim().split(splitter).length;
+    }
+
     /**
      * This loads the translation files from the specified folder.
      */
-    public TranslationMap doImport( File folder )
-    {
-        try
-        {
-            for (String locale : LOCALES)
-            {
+    public TranslationMap doImport(File folder) {
+        try {
+            for (String locale : LOCALES) {
                 TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
                 trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
                 add(trMap);
             }
             postImportHook();
             return this;
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
@@ -61,26 +63,21 @@ public TranslationMap doImport( File folder )
     /**
      * This loads the translation files from classpath.
      */
-    public TranslationMap doImport()
-    {
-        try
-        {
-            for (String locale : LOCALES)
-            {
+    public TranslationMap doImport() {
+        try {
+            for (String locale : LOCALES) {
                 TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
                 trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
                 add(trMap);
             }
             postImportHook();
             return this;
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    public void add( Translation tr )
-    {
+    public void add(Translation tr) {
         Locale locale = tr.getLocale();
         translations.put(locale.toString(), tr);
         if (!locale.getCountry().isEmpty() && !translations.containsKey(tr.getLanguage()))
@@ -100,11 +97,9 @@ public void add( Translation tr )
      * Returns the Translation object for the specified locale and falls back to english if the
      * locale was not found.
      */
-    public Translation getWithFallBack( Locale locale )
-    {
+    public Translation getWithFallBack(Locale locale) {
         Translation tr = get(locale.toString());
-        if (tr == null)
-        {
+        if (tr == null) {
             tr = get(locale.getLanguage());
             if (tr == null)
                 tr = get("en");
@@ -115,8 +110,7 @@ public Translation getWithFallBack( Locale locale )
     /**
      * Returns the Translation object for the specified locale and returns null if not found.
      */
-    public Translation get( String locale )
-    {
+    public Translation get(String locale) {
         locale = locale.replace("-", "_");
         Translation tr = translations.get(locale);
         if (locale.contains("_") && tr == null)
@@ -125,48 +119,33 @@ public Translation get( String locale )
         return tr;
     }
 
-    public static int countOccurence( String phrase, String splitter )
-    {
-        if (Helper.isEmpty(phrase))
-            return 0;
-        return phrase.trim().split(splitter).length;
-    }
-
     /**
      * This method does some checks and fills missing translation from en
      */
-    private void postImportHook()
-    {
+    private void postImportHook() {
         Map<String, String> enMap = get("en").asMap();
         StringBuilder sb = new StringBuilder();
-        for (Translation tr : translations.values())
-        {
+        for (Translation tr : translations.values()) {
             Map<String, String> trMap = tr.asMap();
-            for (Entry<String, String> enEntry : enMap.entrySet())
-            {
+            for (Entry<String, String> enEntry : enMap.entrySet()) {
                 String value = trMap.get(enEntry.getKey());
-                if (Helper.isEmpty(value))
-                {
+                if (Helper.isEmpty(value)) {
                     trMap.put(enEntry.getKey(), enEntry.getValue());
                     continue;
                 }
 
                 int expectedCount = countOccurence(enEntry.getValue(), "\\%");
-                if (expectedCount != countOccurence(value, "\\%"))
-                {
+                if (expectedCount != countOccurence(value, "\\%")) {
                     sb.append(tr.getLocale()).append(" - error in ").
                             append(enEntry.getKey()).append("->").
                             append(value).append("\n");
-                } else
-                {
+                } else {
                     // try if formatting works, many times e.g. '%1$' instead of '%1$s'
                     Object[] strs = new String[expectedCount];
                     Arrays.fill(strs, "tmp");
-                    try
-                    {
+                    try {
                         String.format(value, strs);
-                    } catch (Exception ex)
-                    {
+                    } catch (Exception ex) {
                         sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
                                 append(enEntry.getKey()).append("->").
                                 append(value).append("\n");
@@ -175,43 +154,41 @@ private void postImportHook()
             }
         }
 
-        if (sb.length() > 0)
-        {
+        if (sb.length() > 0) {
             System.out.println(sb);
             throw new IllegalStateException(sb.toString());
         }
     }
 
-    public static class TranslationHashMap implements Translation
-    {
-        private final Map<String, String> map = new HashMap<String, String>();
+    @Override
+    public String toString() {
+        return translations.toString();
+    }
+
+    public static class TranslationHashMap implements Translation {
         final Locale locale;
+        private final Map<String, String> map = new HashMap<String, String>();
 
-        public TranslationHashMap( Locale locale )
-        {
+        public TranslationHashMap(Locale locale) {
             this.locale = locale;
         }
 
-        public void clear()
-        {
+        public void clear() {
             map.clear();
         }
 
         @Override
-        public Locale getLocale()
-        {
+        public Locale getLocale() {
             return locale;
         }
 
         @Override
-        public String getLanguage()
-        {
+        public String getLanguage() {
             return locale.getLanguage();
         }
 
         @Override
-        public String tr( String key, Object... params )
-        {
+        public String tr(String key, Object... params) {
             String val = map.get(key.toLowerCase());
             if (Helper.isEmpty(val))
                 return key;
@@ -219,8 +196,7 @@ public String tr( String key, Object... params )
             return String.format(val, params);
         }
 
-        public TranslationHashMap put( String key, String val )
-        {
+        public TranslationHashMap put(String key, String val) {
             String existing = map.put(key.toLowerCase(), val);
             if (existing != null)
                 throw new IllegalStateException("Cannot overwrite key " + key + " with " + val + ", was: " + existing);
@@ -228,25 +204,20 @@ public TranslationHashMap put( String key, String val )
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return map.toString();
         }
 
         @Override
-        public Map<String, String> asMap()
-        {
+        public Map<String, String> asMap() {
             return map;
         }
 
-        public TranslationHashMap doImport( InputStream is )
-        {
+        public TranslationHashMap doImport(InputStream is) {
             if (is == null)
                 throw new IllegalStateException("No input stream found in class path!?");
-            try
-            {
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
-                {
+            try {
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS))) {
                     if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
                         continue;
 
@@ -262,17 +233,10 @@ public TranslationHashMap doImport( InputStream is )
                         put(key, value);
 
                 }
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 throw new RuntimeException(ex);
             }
             return this;
         }
     }
-
-    @Override
-    public String toString()
-    {
-        return translations.toString();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index 0d3f68f662..0e3fccc8f0 100755
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -24,16 +24,13 @@
 /**
  * @author Peter Karich
  */
-public class Unzipper
-{
-    public void unzip( String from, boolean remove ) throws IOException
-    {
+public class Unzipper {
+    public void unzip(String from, boolean remove) throws IOException {
         String to = Helper.pruneFileEnd(from);
         unzip(from, to, remove);
     }
 
-    public boolean unzip( String fromStr, String toStr, boolean remove ) throws IOException
-    {
+    public boolean unzip(String fromStr, String toStr, boolean remove) throws IOException {
         File from = new File(fromStr);
         if (!from.exists() || fromStr.equals(toStr))
             return false;
@@ -48,42 +45,34 @@ public boolean unzip( String fromStr, String toStr, boolean remove ) throws IOEx
     /**
      * @param progressListener updates not in percentage but the number of bytes already read.
      */
-    public void unzip( InputStream fromIs, File toFolder, ProgressListener progressListener ) throws IOException
-    {
+    public void unzip(InputStream fromIs, File toFolder, ProgressListener progressListener) throws IOException {
         if (!toFolder.exists())
             toFolder.mkdirs();
 
         long sumBytes = 0;
         ZipInputStream zis = new ZipInputStream(fromIs);
-        try
-        {
+        try {
             ZipEntry ze = zis.getNextEntry();
             byte[] buffer = new byte[8 * 1024];
-            while (ze != null)
-            {
-                if (ze.isDirectory())
-                {
+            while (ze != null) {
+                if (ze.isDirectory()) {
                     new File(toFolder, ze.getName()).mkdir();
-                } else
-                {
+                } else {
                     double factor = 1;
                     if (ze.getCompressedSize() > 0 && ze.getSize() > 0)
                         factor = (double) ze.getCompressedSize() / ze.getSize();
 
                     File newFile = new File(toFolder, ze.getName());
                     FileOutputStream fos = new FileOutputStream(newFile);
-                    try
-                    {
+                    try {
                         int len;
-                        while ((len = zis.read(buffer)) > 0)
-                        {
+                        while ((len = zis.read(buffer)) > 0) {
                             fos.write(buffer, 0, len);
                             sumBytes += len * factor;
                             if (progressListener != null)
                                 progressListener.update(sumBytes);
                         }
-                    } finally
-                    {
+                    } finally {
                         fos.close();
                     }
                 }
@@ -91,8 +80,7 @@ public void unzip( InputStream fromIs, File toFolder, ProgressListener progressL
                 ze = zis.getNextEntry();
             }
             zis.closeEntry();
-        } finally
-        {
+        } finally {
             zis.close();
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index 6ce7e55eea..c2c45104dc 100755
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -20,38 +20,32 @@
 /**
  * @author Peter Karich
  */
-public class ViaInstruction extends Instruction
-{
+public class ViaInstruction extends Instruction {
     private int viaPosition = -1;
 
-    public ViaInstruction( String name, InstructionAnnotation ia, PointList pl )
-    {
+    public ViaInstruction(String name, InstructionAnnotation ia, PointList pl) {
         super(REACHED_VIA, name, ia, pl);
     }
 
-    public ViaInstruction( Instruction instr )
-    {
+    public ViaInstruction(Instruction instr) {
         this(instr.getName(), instr.getAnnotation(), instr.getPoints());
         setDistance(instr.getDistance());
         setTime(instr.getTime());
     }
 
-    public void setViaCount( int count )
-    {
-        this.viaPosition = count;
-    }
-
-    public int getViaCount()
-    {
+    public int getViaCount() {
         if (viaPosition < 0)
             throw new IllegalStateException("Uninitialized via count in instruction " + getName());
 
         return viaPosition;
     }
 
+    public void setViaCount(int count) {
+        this.viaPosition = count;
+    }
+
     @Override
-    public String getTurnDescription( Translation tr )
-    {
+    public String getTurnDescription(Translation tr) {
         if (rawName)
             return getName();
 
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index 465852afa7..d0fa5af64c 100755
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -23,24 +23,21 @@
 /**
  * This abstract class defines commonalities for BFS and DFS
  * <p>
+ *
  * @author Jan Sölter
  */
-public abstract class XFirstSearch
-{
-    protected GHBitSet createBitSet()
-    {
+public abstract class XFirstSearch {
+    protected GHBitSet createBitSet() {
         return new GHBitSetImpl();
     }
 
-    public abstract void start( EdgeExplorer explorer, int startNode );
+    public abstract void start(EdgeExplorer explorer, int startNode);
 
-    protected boolean goFurther( int nodeId )
-    {
+    protected boolean goFurther(int nodeId) {
         return true;
     }
 
-    protected boolean checkAdjacent( EdgeIteratorState edge )
-    {
+    protected boolean checkAdjacent(EdgeIteratorState edge) {
         return true;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java b/core/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java
new file mode 100644
index 0000000000..a512cb6db6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.exceptions;
+
+import java.util.Map;
+
+/**
+ * If a route cannot be found due to disconnected graphs.
+ *
+ * @author Peter Karich
+ */
+public class ConnectionNotFoundException extends DetailedIllegalArgumentException {
+    public ConnectionNotFoundException(String var1, Map<String, Object> details) {
+        super(var1, details);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java b/core/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
new file mode 100644
index 0000000000..5e01d77e27
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 peterk.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util.exceptions;
+
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public class DetailedIllegalArgumentException extends IllegalArgumentException implements GHException {
+
+    private final Map<String, Object> details;
+
+    public DetailedIllegalArgumentException(String var1, Map<String, Object> details) {
+        super(var1);
+        this.details = details;
+    }
+
+    @Override
+    public Map<String, Object> getDetails() {
+        return details;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java b/core/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java
new file mode 100644
index 0000000000..5d133b5c3a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 peterk.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util.exceptions;
+
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public class DetailedRuntimeException extends RuntimeException implements GHException {
+
+    private final Map<String, Object> details;
+
+    public DetailedRuntimeException(String var1, Map<String, Object> details) {
+        super(var1);
+        this.details = details;
+    }
+
+    @Override
+    public Map<String, Object> getDetails() {
+        return details;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/GHException.java b/core/src/main/java/com/graphhopper/util/exceptions/GHException.java
new file mode 100644
index 0000000000..e8e1f2bbbc
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/GHException.java
@@ -0,0 +1,29 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.exceptions;
+
+import java.util.Map;
+
+/**
+ * Generic GHException that allows to add details to the exception message
+ *
+ * @author Robin Boldt
+ */
+public interface GHException {
+    public abstract Map<String, Object> getDetails();
+}
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java b/core/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java
new file mode 100644
index 0000000000..d5abfcb557
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java
@@ -0,0 +1,46 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.exceptions;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * Represents an instance of the "Cannot find Point" Exception, whereas the Point that cannot be
+ * found is at pointIndex.
+ *
+ * @author Robin Boldt
+ */
+public class PointNotFoundException extends IllegalArgumentException implements GHException {
+
+    protected final int pointIndex;
+
+    public PointNotFoundException(String var1, int pointIndex) {
+        super(var1);
+        this.pointIndex = pointIndex;
+    }
+
+    public int getPointIndex() {
+        return this.pointIndex;
+    }
+
+    @Override
+    public Map<String, Object> getDetails() {
+        return Collections.<String, Object>singletonMap("point_index", pointIndex);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java b/core/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java
new file mode 100644
index 0000000000..774ebfeb33
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java
@@ -0,0 +1,12 @@
+package com.graphhopper.util.exceptions;
+
+/**
+ * Refinement of the CannotFindPointException that indicates that a point is placed out of the graphs bounds
+ *
+ * @author Robin Boldt
+ */
+public class PointOutOfBoundsException extends PointNotFoundException {
+    public PointOutOfBoundsException(String var1, int pointIndex) {
+        super(var1, pointIndex);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index b90e24b161..977c0162bb 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -31,11 +31,12 @@
  * Nice German overview:
  * http://www.geoinf.uni-jena.de/fileadmin/Geoinformatik/Lehre/Diplomarbeiten/DA_Andres.pdf
  * <p>
+ *
  * @author Peter Karich
  */
-public class BBox implements Shape, Cloneable
-{
+public class BBox implements Shape, Cloneable {
 
+    private final boolean elevation;
     // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
@@ -43,20 +44,16 @@
     public double maxLat;
     public double minEle;
     public double maxEle;
-    private final boolean elevation;
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat )
-    {
+    public BBox(double minLon, double maxLon, double minLat, double maxLat) {
         this(minLon, maxLon, minLat, maxLat, Double.NaN, Double.NaN, false);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle )
-    {
+    public BBox(double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle) {
         this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
-    {
+    public BBox(double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation) {
         this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
@@ -66,63 +63,49 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this.maxEle = maxEle;
     }
 
-    public boolean hasElevation()
-    {
-        return elevation;
-    }
-
     /**
      * Prefills BBox with minimum values so that it can increase.
      */
-    public static BBox createInverse( boolean elevation )
-    {
-        if (elevation)
-        {
+    public static BBox createInverse(boolean elevation) {
+        if (elevation) {
             return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
                     Double.MAX_VALUE, -Double.MAX_VALUE, true);
-        } else
-        {
+        } else {
             return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
                     Double.NaN, Double.NaN, false);
         }
     }
 
-    public void update( double lat, double lon )
-    {
-        if (lat > maxLat)
-        {
+    public boolean hasElevation() {
+        return elevation;
+    }
+
+    public void update(double lat, double lon) {
+        if (lat > maxLat) {
             maxLat = lat;
         }
 
-        if (lat < minLat)
-        {
+        if (lat < minLat) {
             minLat = lat;
         }
 
-        if (lon > maxLon)
-        {
+        if (lon > maxLon) {
             maxLon = lon;
         }
-        if (lon < minLon)
-        {
+        if (lon < minLon) {
             minLon = lon;
         }
     }
 
-    public void update( double lat, double lon, double elev )
-    {
-        if (elevation)
-        {
-            if (elev > maxEle)
-            {
+    public void update(double lat, double lon, double elev) {
+        if (elevation) {
+            if (elev > maxEle) {
                 maxEle = elev;
             }
-            if (elev < minEle)
-            {
+            if (elev < minEle) {
                 minEle = elev;
             }
-        } else
-        {
+        } else {
             throw new IllegalStateException("No BBox with elevation to update");
         }
         update(lat, lon);
@@ -130,19 +113,15 @@ public void update( double lat, double lon, double elev )
     }
 
     @Override
-    public BBox clone()
-    {
+    public BBox clone() {
         return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
-    public boolean intersect( Shape s )
-    {
-        if (s instanceof BBox)
-        {
+    public boolean intersect(Shape s) {
+        if (s instanceof BBox) {
             return intersect((BBox) s);
-        } else if (s instanceof Circle)
-        {
+        } else if (s instanceof Circle) {
             return ((Circle) s).intersect(this);
         }
 
@@ -150,50 +129,41 @@ public boolean intersect( Shape s )
     }
 
     @Override
-    public boolean contains( Shape s )
-    {
-        if (s instanceof BBox)
-        {
+    public boolean contains(Shape s) {
+        if (s instanceof BBox) {
             return contains((BBox) s);
-        } else if (s instanceof Circle)
-        {
+        } else if (s instanceof Circle) {
             return contains((Circle) s);
         }
 
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect( Circle s )
-    {
+    public boolean intersect(Circle s) {
         return ((Circle) s).intersect(this);
     }
 
-    public boolean intersect( BBox o )
-    {
+    public boolean intersect(BBox o) {
         // return (o.minLon < minLon && o.maxLon > minLon || o.minLon < maxLon && o.minLon >= minLon)
         //  && (o.maxLat < maxLat && o.maxLat >= minLat || o.maxLat >= maxLat && o.minLat < maxLat);
         return minLon < o.maxLon && minLat < o.maxLat && o.minLon < maxLon && o.minLat < maxLat;
     }
 
     @Override
-    public boolean contains( double lat, double lon )
-    {
-        return lat < maxLat && lat >= minLat && lon < maxLon && lon >= minLon;
+    public boolean contains(double lat, double lon) {
+        return lat <= maxLat && lat >= minLat && lon <= maxLon && lon >= minLon;
     }
 
-    public boolean contains( BBox b )
-    {
+    public boolean contains(BBox b) {
         return maxLat >= b.maxLat && minLat <= b.minLat && maxLon >= b.maxLon && minLon <= b.minLon;
     }
 
-    public boolean contains( Circle c )
-    {
+    public boolean contains(Circle c) {
         return contains(c.getBounds());
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
         if (elevation)
             str += "," + minEle + "," + maxEle;
@@ -201,20 +171,17 @@ public String toString()
         return str;
     }
 
-    public String toLessPrecisionString()
-    {
+    public String toLessPrecisionString() {
         return (float) minLon + "," + (float) maxLon + "," + (float) minLat + "," + (float) maxLat;
     }
 
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return this;
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -225,8 +192,7 @@ public boolean equals( Object obj )
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 3;
         hash = 17 * hash + (int) (Double.doubleToLongBits(this.minLon) ^ (Double.doubleToLongBits(this.minLon) >>> 32));
         hash = 17 * hash + (int) (Double.doubleToLongBits(this.maxLon) ^ (Double.doubleToLongBits(this.maxLon) >>> 32));
@@ -235,8 +201,7 @@ public int hashCode()
         return hash;
     }
 
-    public boolean isValid()
-    {
+    public boolean isValid() {
         // second longitude should be bigger than the first
         if (minLon >= maxLon)
             return false;
@@ -245,8 +210,7 @@ public boolean isValid()
         if (minLat >= maxLat)
             return false;
 
-        if (elevation)
-        {
+        if (elevation) {
             // equal elevation is okay
             if (minEle > maxEle)
                 return false;
@@ -266,8 +230,7 @@ public boolean isValid()
      * @return array containing this bounding box. Attention: GeoJson is lon,lat! If 3D is gets even
      * worse: lon,lat,ele
      */
-    public List<Double> toGeoJson()
-    {
+    public List<Double> toGeoJson() {
         List<Double> list = new ArrayList<Double>(4);
         list.add(Helper.round6(minLon));
         list.add(Helper.round6(minLat));
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
index 83e1bdbe0f..f538b3fae6 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -23,22 +23,19 @@
 /**
  * @author Peter Karich
  */
-public class Circle implements Shape
-{
-    private DistanceCalc calc = Helper.DIST_EARTH;
+public class Circle implements Shape {
     private final double radiusInKm;
     private final double lat;
     private final double lon;
     private final double normedDist;
     private final BBox bbox;
+    private DistanceCalc calc = Helper.DIST_EARTH;
 
-    public Circle( double lat, double lon, double radiusInMeter )
-    {
+    public Circle(double lat, double lon, double radiusInMeter) {
         this(lat, lon, radiusInMeter, Helper.DIST_EARTH);
     }
 
-    public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
-    {
+    public Circle(double lat, double lon, double radiusInMeter, DistanceCalc calc) {
         this.calc = calc;
         this.lat = lat;
         this.lon = lon;
@@ -47,41 +44,33 @@ public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
         bbox = calc.createBBox(lat, lon, radiusInMeter);
     }
 
-    public double getLat()
-    {
+    public double getLat() {
         return lat;
     }
 
-    public double getLon()
-    {
+    public double getLon() {
         return lon;
     }
 
     @Override
-    public boolean contains( double lat1, double lon1 )
-    {
+    public boolean contains(double lat1, double lon1) {
         return normDist(lat1, lon1) <= normedDist;
     }
 
     @Override
-    public BBox getBounds()
-    {
+    public BBox getBounds() {
         return bbox;
     }
 
-    private double normDist( double lat1, double lon1 )
-    {
+    private double normDist(double lat1, double lon1) {
         return calc.calcNormalizedDist(lat, lon, lat1, lon1);
     }
 
     @Override
-    public boolean intersect( Shape o )
-    {
-        if (o instanceof Circle)
-        {
+    public boolean intersect(Shape o) {
+        if (o instanceof Circle) {
             return intersect((Circle) o);
-        } else if (o instanceof BBox)
-        {
+        } else if (o instanceof BBox) {
             return intersect((BBox) o);
         }
 
@@ -89,76 +78,60 @@ public boolean intersect( Shape o )
     }
 
     @Override
-    public boolean contains( Shape o )
-    {
-        if (o instanceof Circle)
-        {
+    public boolean contains(Shape o) {
+        if (o instanceof Circle) {
             return contains((Circle) o);
-        } else if (o instanceof BBox)
-        {
+        } else if (o instanceof BBox) {
             return contains((BBox) o);
         }
 
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect( BBox b )
-    {
+    public boolean intersect(BBox b) {
         // test top intersect
-        if (lat > b.maxLat)
-        {
-            if (lon < b.minLon)
-            {
+        if (lat > b.maxLat) {
+            if (lon < b.minLon) {
                 return normDist(b.maxLat, b.minLon) <= normedDist;
             }
-            if (lon > b.maxLon)
-            {
+            if (lon > b.maxLon) {
                 return normDist(b.maxLat, b.maxLon) <= normedDist;
             }
             return b.maxLat - bbox.minLat > 0;
         }
 
         // test bottom intersect
-        if (lat < b.minLat)
-        {
-            if (lon < b.minLon)
-            {
+        if (lat < b.minLat) {
+            if (lon < b.minLon) {
                 return normDist(b.minLat, b.minLon) <= normedDist;
             }
-            if (lon > b.maxLon)
-            {
+            if (lon > b.maxLon) {
                 return normDist(b.minLat, b.maxLon) <= normedDist;
             }
             return bbox.maxLat - b.minLat > 0;
         }
 
         // test middle intersect
-        if (lon < b.minLon)
-        {
+        if (lon < b.minLon) {
             return bbox.maxLon - b.minLon > 0;
         }
-        if (lon > b.maxLon)
-        {
+        if (lon > b.maxLon) {
             return b.maxLon - bbox.minLon > 0;
         }
         return true;
     }
 
-    public boolean intersect( Circle c )
-    {
+    public boolean intersect(Circle c) {
         // necessary to improve speed?
-        if (!getBounds().intersect(c.getBounds()))
-        {
+        if (!getBounds().intersect(c.getBounds())) {
             return false;
         }
 
         return normDist(c.lat, c.lon) <= calc.calcNormalizedDist(radiusInKm + c.radiusInKm);
     }
 
-    public boolean contains( BBox b )
-    {
-        if (bbox.contains(b))
-        {
+    public boolean contains(BBox b) {
+        if (bbox.contains(b)) {
             return contains(b.maxLat, b.minLon) && contains(b.minLat, b.minLon)
                     && contains(b.maxLat, b.maxLon) && contains(b.minLat, b.maxLon);
         }
@@ -166,11 +139,9 @@ public boolean contains( BBox b )
         return false;
     }
 
-    public boolean contains( Circle c )
-    {
+    public boolean contains(Circle c) {
         double res = radiusInKm - c.radiusInKm;
-        if (res < 0)
-        {
+        if (res < 0) {
             return false;
         }
 
@@ -178,8 +149,7 @@ public boolean contains( Circle c )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return lat + "," + lon + ", radius:" + radiusInKm;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
index f3038a0f16..8d13b1a595 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
@@ -22,50 +22,42 @@
 /**
  * Specifies a place by its coordinates or name
  * <p>
+ *
  * @author Peter Karich
  */
-public class GHPlace extends GHPoint
-{
+public class GHPlace extends GHPoint {
     private String name = "";
 
-    public GHPlace()
-    {
+    public GHPlace() {
     }
 
-    public GHPlace( String name )
-    {
+    public GHPlace(String name) {
         setName(name);
     }
 
-    public GHPlace( double lat, double lon )
-    {
+    public GHPlace(double lat, double lon) {
         super(lat, lon);
     }
 
-    public void setValue( String t )
-    {
+    public void setValue(String t) {
         setName(t);
     }
 
-    public GHPlace setName( String name )
-    {
-        this.name = name;
-        return this;
+    public String getName() {
+        return name;
     }
 
-    public String getName()
-    {
-        return name;
+    public GHPlace setName(String name) {
+        this.name = name;
+        return this;
     }
 
-    public boolean isValidName()
-    {
+    public boolean isValidName() {
         return !Helper.isEmpty(name);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         String str = "";
         if (isValidName())
             str += name;
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 4c280f492b..af751414d9 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -22,39 +22,46 @@
 /**
  * @author Peter Karich
  */
-public class GHPoint
-{
+public class GHPoint {
     public double lat = Double.NaN;
     public double lon = Double.NaN;
 
-    public GHPoint()
-    {
+    public GHPoint() {
     }
 
-    public GHPoint( double lat, double lon )
-    {
+    public GHPoint(double lat, double lon) {
         this.lat = lat;
         this.lon = lon;
     }
 
-    public double getLon()
-    {
+    public static GHPoint parse(String str) {
+        // if the point is in the format of lat,lon we don't need to call geocoding service
+        String[] fromStrs = str.split(",");
+        if (fromStrs.length == 2) {
+            try {
+                double fromLat = Double.parseDouble(fromStrs[0]);
+                double fromLon = Double.parseDouble(fromStrs[1]);
+                return new GHPoint(fromLat, fromLon);
+            } catch (Exception ex) {
+            }
+        }
+        return null;
+    }
+
+    public double getLon() {
         return lon;
     }
 
-    public double getLat()
-    {
+    public double getLat() {
         return lat;
     }
 
-    public boolean isValid()
-    {
+    public boolean isValid() {
         return !Double.isNaN(lat) && !Double.isNaN(lon);
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 7;
         hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
         hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
@@ -62,8 +69,7 @@ public int hashCode()
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -73,37 +79,14 @@ public boolean equals( Object obj )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return lat + "," + lon;
     }
 
     /**
      * Attention: geoJson is LON,LAT
      */
-    public Double[] toGeoJson()
-    {
-        return new Double[]
-                {
-                        lon, lat
-                };
-    }
-
-    public static GHPoint parse( String str )
-    {
-        // if the point is in the format of lat,lon we don't need to call geocoding service
-        String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2)
-        {
-            try
-            {
-                double fromLat = Double.parseDouble(fromStrs[0]);
-                double fromLon = Double.parseDouble(fromStrs[1]);
-                return new GHPoint(fromLat, fromLon);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return null;
+    public Double[] toGeoJson() {
+        return new Double[]{lon, lat};
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
index 3b4f1aa1f7..f138baf661 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -22,37 +22,31 @@
 /**
  * @author Peter Karich
  */
-public class GHPoint3D extends GHPoint
-{
+public class GHPoint3D extends GHPoint {
     public double ele;
 
-    public GHPoint3D( double lat, double lon, double elevation )
-    {
+    public GHPoint3D(double lat, double lon, double elevation) {
         super(lat, lon);
         this.ele = elevation;
     }
 
-    public double getElevation()
-    {
+    public double getElevation() {
         return ele;
     }
 
-    public double getEle()
-    {
+    public double getEle() {
         return ele;
     }
 
     @Override
-    public int hashCode()
-    {
+    public int hashCode() {
         int hash = 59 * super.hashCode()
                 + (int) (Double.doubleToLongBits(this.ele) ^ (Double.doubleToLongBits(this.ele) >>> 32));
         return hash;
     }
 
     @Override
-    public boolean equals( Object obj )
-    {
+    public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
@@ -67,17 +61,12 @@ public boolean equals( Object obj )
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return super.toString() + "," + ele;
     }
 
     @Override
-    public Double[] toGeoJson()
-    {
-        return new Double[]
-                {
-                        lon, lat, ele
-                };
+    public Double[] toGeoJson() {
+        return new Double[]{lon, lat, ele};
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Shape.java b/core/src/main/java/com/graphhopper/util/shapes/Shape.java
index 5fdc904642..1dace9efd8 100755
--- a/core/src/main/java/com/graphhopper/util/shapes/Shape.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Shape.java
@@ -20,25 +20,25 @@
 /**
  * A shape interface to implement circles or rectangles.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface Shape
-{
+public interface Shape {
     /**
      * @return true if edges or areas of this and the specified shapes overlap
      */
-    boolean intersect( Shape o );
+    boolean intersect(Shape o);
 
     /**
      * @return true only if lat and lon are inside (or on the edge) of this shape
      */
-    boolean contains( double lat, double lon );
+    boolean contains(double lat, double lon);
 
     /**
      * @return true if the specified shape is fully contained in this shape. Only iff
      * <pre> s1.contains(s2) &amp;&amp; s2.contains(s1) </pre> then s1 is equal to s2
      */
-    boolean contains( Shape s );
+    boolean contains(Shape s);
 
     /**
      * @return the minimal rectangular bounding box of this shape
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
index 7083f551de..249f183415 100755
--- a/core/src/main/resources/com/graphhopper/util/ar.txt
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ast.txt b/core/src/main/resources/com/graphhopper/util/ast.txt
index f5a38a5eea..644cb329c1 100755
--- a/core/src/main/resources/com/graphhopper/util/ast.txt
+++ b/core/src/main/resources/com/graphhopper/util/ast.txt
@@ -66,3 +66,4 @@ web.refresh_button=Refrescar la páxina
 web.server_status=Estáu
 web.zoom_in=Averar
 web.zoom_out=Alloñar
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index bc9aebee04..9a419d78d7 100755
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index 2734907054..9438eabf82 100755
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -66,3 +66,4 @@ web.refresh_button=Refrescar la plana
 web.server_status=Estat
 web.zoom_in=Apropar
 web.zoom_out=Allunyar
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
index f5bf05a023..944b008168 100755
--- a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -66,3 +66,4 @@ web.refresh_button=Obnovit stránku
 web.server_status=Stav
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/da_DK.txt b/core/src/main/resources/com/graphhopper/util/da_DK.txt
index 65341ee73e..60293ba81b 100755
--- a/core/src/main/resources/com/graphhopper/util/da_DK.txt
+++ b/core/src/main/resources/com/graphhopper/util/da_DK.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index a9d403329d..1b35c214a3 100755
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -66,3 +66,4 @@ web.refresh_button=Lade Seite neu
 web.server_status=Status
 web.zoom_in=Vergrössern
 web.zoom_out=Verkleinern
+web.drag_to_reorder=Zum Ändern der Reihenfolge ziehen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index c232898655..fd62d2f6d9 100755
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -66,3 +66,4 @@ web.refresh_button=Ανανέωση σελίδας
 web.server_status=Κατάσταση
 web.zoom_in=Μεγέθυνση
 web.zoom_out=Σμίκρυνση
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 88e354ef6f..8532012f6a 100755
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -66,3 +66,4 @@ web.refresh_button=Refresh page
 web.server_status=Status
 web.zoom_in=Zoom in
 web.zoom_out=Zoom out
+web.drag_to_reorder=Drag to reorder
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index 4bc75658bd..5a149d4104 100755
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -66,3 +66,4 @@ web.refresh_button=Actualizar página
 web.server_status=Estado
 web.zoom_in=Acercar
 web.zoom_out=Alejar
+web.drag_to_reorder=Arrastra para cambiar el orden
diff --git a/core/src/main/resources/com/graphhopper/util/fa.txt b/core/src/main/resources/com/graphhopper/util/fa.txt
index e4d479f785..539ea0a66f 100755
--- a/core/src/main/resources/com/graphhopper/util/fa.txt
+++ b/core/src/main/resources/com/graphhopper/util/fa.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/fi.txt b/core/src/main/resources/com/graphhopper/util/fi.txt
index cb3882310c..17f101a936 100755
--- a/core/src/main/resources/com/graphhopper/util/fi.txt
+++ b/core/src/main/resources/com/graphhopper/util/fi.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
index ba7430f6a9..113b43b956 100755
--- a/core/src/main/resources/com/graphhopper/util/fil.txt
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/fr_CH.txt b/core/src/main/resources/com/graphhopper/util/fr_CH.txt
index 6bf22c5780..d214de42df 100755
--- a/core/src/main/resources/com/graphhopper/util/fr_CH.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr_CH.txt
@@ -66,3 +66,4 @@ web.refresh_button=Rafraîchir
 web.server_status=Statut
 web.zoom_in=Zoom avant
 web.zoom_out=Zoom arrière
+web.drag_to_reorder=Faire glisser pour réorganiser
diff --git a/core/src/main/resources/com/graphhopper/util/fr_FR.txt b/core/src/main/resources/com/graphhopper/util/fr_FR.txt
index 6ecaf0ed96..4387cb8ba4 100755
--- a/core/src/main/resources/com/graphhopper/util/fr_FR.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr_FR.txt
@@ -66,3 +66,4 @@ web.refresh_button=Rafraîchir
 web.server_status=Statut
 web.zoom_in=Zoom avant
 web.zoom_out=Zoom arrière
+web.drag_to_reorder=Faire glisser pour réorganiser
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
index e7e312abfe..571542efc8 100755
--- a/core/src/main/resources/com/graphhopper/util/gl.txt
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index 167840834a..22741dda49 100755
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -22,10 +22,10 @@ web.racingbike=מסלולי אופניים
 web.mtb=אופני הרים
 web.car=מכונית
 web.foot=רגל
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
+web.hike=טיול רגלי
+web.small_truck=משאית קטנה
+web.bus=אוטובוס
+web.truck=משאית
 web.staticlink=קישור קבוע
 web.motorcycle=אופנוע
 via=דרך
@@ -41,28 +41,29 @@ road=כביש
 off_bike=לרדת מהאופניים
 cycleway=דרך לאופניים
 way=דרך
-small_way=
+small_way=דרך צרה
 paved=סלולה
 unpaved=לא סלולה
 stopover=נקודת עצירה מס׳ %1$s
 roundabout_enter=יש להיכנס לכיכר
 roundabout_exit=בכיכר, יש לצאת ביציאה %1$s
 roundabout_exit_onto=בכיכר, יש לצאת ביציאה %1$s לתוך %2$s
-total_ascend=
-total_descend=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
+total_ascend=עלייה כוללת של %1$s
+total_descend=ירידה כוללת של %1$s
+web.start_label=התחלה
+web.intermediate_label=אמצע
+web.end_label=סוף
+web.set_start=הגדרה כהתחלה
+web.set_intermediate=הגדרה כאמצע
+web.set_end=הגדרה כסוף
+web.center_map=למרכז את המפה לכאן
+web.show_coords=הצגת נקודות ציון
+web.route=דרך
+web.delete_from_route=מחיקה מהדרך
+web.marker=הדגשה
+web.gh_offline_info=‏ GraphHopper API לא מקוון?
+web.refresh_button=רענון הדף
+web.server_status=מצב
+web.zoom_in=התקרבות
+web.zoom_out=התרחקות
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/hr_HR.txt b/core/src/main/resources/com/graphhopper/util/hr_HR.txt
index 762ce636f4..acef1b8ee4 100755
--- a/core/src/main/resources/com/graphhopper/util/hr_HR.txt
+++ b/core/src/main/resources/com/graphhopper/util/hr_HR.txt
@@ -66,3 +66,4 @@ web.refresh_button=Osvježi stranicu
 web.server_status=Status
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/hsb.txt b/core/src/main/resources/com/graphhopper/util/hsb.txt
index 48852e3606..478391c687 100755
--- a/core/src/main/resources/com/graphhopper/util/hsb.txt
+++ b/core/src/main/resources/com/graphhopper/util/hsb.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/hu_HU.txt b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
index b54d76694d..f0d9f80b21 100755
--- a/core/src/main/resources/com/graphhopper/util/hu_HU.txt
+++ b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index 54e1192a60..1d56fe1fe1 100755
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -66,3 +66,4 @@ web.refresh_button=Ricarica pagina
 web.server_status=Stato
 web.zoom_in=Zoom avanti
 web.zoom_out=Zoom indietro
+web.drag_to_reorder=Trascina per riordinare
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 93b9567f33..c2d5239ddd 100755
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -66,3 +66,4 @@ web.refresh_button=更新
 web.server_status=ステータス
 web.zoom_in=拡大
 web.zoom_out=縮小
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ko.txt b/core/src/main/resources/com/graphhopper/util/ko.txt
index e74311dcf5..f2ffb0c84d 100755
--- a/core/src/main/resources/com/graphhopper/util/ko.txt
+++ b/core/src/main/resources/com/graphhopper/util/ko.txt
@@ -66,3 +66,4 @@ web.refresh_button=새로고침
 web.server_status=상태
 web.zoom_in=확대
 web.zoom_out=축소
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/lt_LT.txt b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
index 07bf234bb9..dd542bb151 100755
--- a/core/src/main/resources/com/graphhopper/util/lt_LT.txt
+++ b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ne.txt b/core/src/main/resources/com/graphhopper/util/ne.txt
index 542fa61cd4..3f0ff0555c 100755
--- a/core/src/main/resources/com/graphhopper/util/ne.txt
+++ b/core/src/main/resources/com/graphhopper/util/ne.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index 2585230268..e28c765284 100755
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/pl_PL.txt b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
index 1d675a23b4..6707732bce 100755
--- a/core/src/main/resources/com/graphhopper/util/pl_PL.txt
+++ b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index b30057734c..c296440709 100755
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -66,3 +66,4 @@ web.refresh_button=Recarregar página
 web.server_status=Status
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index dc4db61515..a1510cf6d2 100755
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index 92edbade92..f5793e5d41 100755
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -66,3 +66,4 @@ web.refresh_button=Reîmprospătează pagina
 web.server_status=Disponibilitate
 web.zoom_in=Mărește
 web.zoom_out=Micșorează
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index 58e5d26158..85119e60d0 100755
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -22,11 +22,11 @@ web.racingbike=Гоночный велосипед
 web.mtb=Горный велосипед
 web.car=Автомобиль
 web.foot=Пешком
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
-web.staticlink=Ссылка
+web.hike=Пеший туризм
+web.small_truck=Лёгкий грузовик
+web.bus=Автобус
+web.truck=Грузовой автомобиль
+web.staticlink=Постоянная ссылка
 web.motorcycle=Мотоцикл
 via=через
 finish=Цель достигнута!
@@ -38,31 +38,32 @@ m_abbr=м
 mi_abbr=ми
 ft_abbr=фт
 road=дорога
-off_bike=слезьте с велосипеда
+off_bike=спешьтесь с вела
 cycleway=велодорожка
 way=путь
-small_way=
+small_way=узкий путь
 paved=с покрытием
 unpaved=без покрытия
 stopover=остановка %1$s
 roundabout_enter=Въезжайте на кольцо
 roundabout_exit=У кольца используйте съезд %1$s
 roundabout_exit_onto=У кольца используйте съезд %1$s на %2$s
-total_ascend=
-total_descend=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
+total_ascend=подъём на %1$s
+total_descend=спуск на %1$s
+web.start_label=Начало
+web.intermediate_label=Промежуточная точка
+web.end_label=Конец
+web.set_start=Установить начало здесь
+web.set_intermediate=Установить промежуточной точкой
+web.set_end=Установить конец здесь
+web.center_map=Сдвинуть карту сюда 
+web.show_coords=Показать координаты 
+web.route=Маршрут
+web.delete_from_route=Удалить из маршрута
+web.marker=Значок
+web.gh_offline_info=GraphHopper API недоступен?
+web.refresh_button=Обновить страницу
+web.server_status=Статус сервера
+web.zoom_in=Приблизить 
+web.zoom_out=Отдалить
+web.drag_to_reorder=Перетащите путевую точку
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index bfe61eec5d..2a540d6dbf 100755
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 6c38567d61..034ccb97ae 100755
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -66,3 +66,4 @@ web.refresh_button=Obnoviť stránku
 web.server_status=Stav
 web.zoom_in=Priblížiť
 web.zoom_out=Oddialiť
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
index cf25d2176c..6927d6ac89 100755
--- a/core/src/main/resources/com/graphhopper/util/sv_SE.txt
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index e776b7fc6f..8991b1ba97 100755
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index cdbdd131bd..957a3ee904 100755
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -66,3 +66,4 @@ web.refresh_button=Оновити сторінку
 web.server_status=Стан
 web.zoom_in=Наблизити
 web.zoom_out=Віддалити
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
index d49a3cd377..8eec781c10 100755
--- a/core/src/main/resources/com/graphhopper/util/vi_VI.txt
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
index 41269295bf..6703e1418b 100755
--- a/core/src/main/resources/com/graphhopper/util/zh_CN.txt
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -66,3 +66,4 @@ web.refresh_button=
 web.server_status=
 web.zoom_in=
 web.zoom_out=
+web.drag_to_reorder=拖动可重新排序
diff --git a/core/src/main/resources/com/graphhopper/util/zh_HK.txt b/core/src/main/resources/com/graphhopper/util/zh_HK.txt
index a566cf44e8..38d6139808 100755
--- a/core/src/main/resources/com/graphhopper/util/zh_HK.txt
+++ b/core/src/main/resources/com/graphhopper/util/zh_HK.txt
@@ -66,3 +66,4 @@ web.refresh_button=刷新網頁
 web.server_status=狀況
 web.zoom_in=放大
 web.zoom_out=縮小
+web.drag_to_reorder=
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index 7aa8382f5e..0a0c6d64d9 100755
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -29,11 +29,9 @@
 /**
  * @author Peter Karich
  */
-public class GHRequestTest
-{
+public class GHRequestTest {
     @Test
-    public void testGetHint()
-    {
+    public void testGetHint() {
         GHRequest instance = new GHRequest(10, 12, 12, 10);
         instance.getHints().put("something", "1");
         assertEquals(1, instance.getHints().getInt("something", 2));
@@ -42,8 +40,7 @@ public void testGetHint()
     }
 
     @Test
-    public void testCorrectInit()
-    {
+    public void testCorrectInit() {
         double lat0 = 51, lon0 = 1, lat1 = 52, lon1 = 2, lat2 = 53, lon2 = 3;
 
         ArrayList<GHPoint> points = new ArrayList<GHPoint>(3);
@@ -97,10 +94,8 @@ public void testCorrectInit()
         compareFavoredHeadings(instance, emptyHeadings);
     }
 
-    private void compareFavoredHeadings( GHRequest request, List<Double> expected )
-    {
-        for (int ind = 0; ind < expected.size(); ind++)
-        {
+    private void compareFavoredHeadings(GHRequest request, List<Double> expected) {
+        for (int ind = 0; ind < expected.size(); ind++) {
             double favoredHeading = request.getFavoredHeading(ind);
             assertEquals(ind + " favored Heading does not match" + expected.get(ind) + " vs ." + favoredHeading,
                     expected.get(ind), favoredHeading, 0.01);
diff --git a/core/src/test/java/com/graphhopper/GHResponseTest.java b/core/src/test/java/com/graphhopper/GHResponseTest.java
index 3c0e088ce7..ec3b23c37c 100755
--- a/core/src/test/java/com/graphhopper/GHResponseTest.java
+++ b/core/src/test/java/com/graphhopper/GHResponseTest.java
@@ -17,20 +17,19 @@
  */
 package com.graphhopper;
 
-import static org.junit.Assert.*;
 import org.junit.Test;
 
-public class GHResponseTest
-{
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class GHResponseTest {
     @Test
-    public void testToString() throws Exception
-    {
+    public void testToString() throws Exception {
         assertEquals("no paths", new GHResponse().toString());
     }
 
     @Test
-    public void testHasNoErrorIfEmpty() throws Exception
-    {
+    public void testHasNoErrorIfEmpty() throws Exception {
         assertFalse(new GHResponse().hasErrors());
         GHResponse rsp = new GHResponse();
         rsp.add(new PathWrapper());
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 29b39acfb6..8e66d12f93 100755
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -19,24 +19,21 @@
 
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIterator;
+import org.junit.Test;
 
 import java.util.PriorityQueue;
 import java.util.Random;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public abstract class AbstractBinHeapTest
-{
-    public abstract BinHeapWrapper<Number, Integer> createHeap( int capacity );
+public abstract class AbstractBinHeapTest {
+    public abstract BinHeapWrapper<Number, Integer> createHeap(int capacity);
 
     @Test
-    public void test0()
-    {
+    public void test0() {
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
         binHeap.insert(123, 0);
         assertEquals(123, binHeap.peekKey().intValue());
@@ -48,8 +45,7 @@ public void test0()
     }
 
     @Test
-    public void testBasic()
-    {
+    public void testBasic() {
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
         binHeap.insert(20, 1);
         binHeap.insert(123, 2);
@@ -63,8 +59,7 @@ public void testBasic()
     }
 
     @Test
-    public void testClear()
-    {
+    public void testClear() {
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
         binHeap.insert(20, 1);
         binHeap.insert(123, 2);
@@ -78,15 +73,13 @@ public void testClear()
     }
 
     @Test
-    public void testSpreading()
-    {
+    public void testSpreading() {
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
         binHeap.insert(100, 101);
         binHeap.insert(49, 51);
         binHeap.insert(71, 71);
         binHeap.insert(29, 31);
-        for (int i = 0; i < 20; i++)
-        {
+        for (int i = 0; i < 20; i++) {
             binHeap.insert(i * 10, i * 11);
         }
         binHeap.insert(59, 61);
@@ -108,8 +101,7 @@ public void testSpreading()
     }
 
     @Test
-    public void testRekey()
-    {
+    public void testRekey() {
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
         binHeap.insert(20, 1);
         binHeap.insert(123, 2);
@@ -123,15 +115,13 @@ public void testRekey()
     }
 
     @Test
-    public void testSize()
-    {
+    public void testSize() {
         PriorityQueue<SPTEntry> juQueue = new PriorityQueue<SPTEntry>(100);
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
 
         Random rand = new Random(1);
         int N = 1000;
-        for (int i = 0; i < N; i++)
-        {
+        for (int i = 0; i < N; i++) {
             int val = rand.nextInt();
             binHeap.insert(val, i);
             juQueue.add(new SPTEntry(EdgeIterator.NO_EDGE, i, val));
@@ -139,8 +129,7 @@ public void testSize()
 
         assertEquals(juQueue.size(), binHeap.getSize());
 
-        for (int i = 0; i < N; i++)
-        {
+        for (int i = 0; i < N; i++) {
             assertEquals(juQueue.poll().adjNode, binHeap.pollElement(), 1e-5);
         }
 
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
index 6dcdb64eb0..c23638cd98 100755
--- a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
@@ -17,20 +17,18 @@
  */
 package com.graphhopper.coll;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Peter Karich
  */
-public abstract class AbstractMyBitSetTest
-{
-    public abstract GHBitSet createBitSet( int no );
+public abstract class AbstractMyBitSetTest {
+    public abstract GHBitSet createBitSet(int no);
 
     @Test
-    public void testCopy()
-    {
+    public void testCopy() {
         GHBitSet bs = createBitSet(100);
         bs.add(100);
         bs.add(70);
@@ -57,8 +55,7 @@ public void testCopy()
     }
 
     @Test
-    public void testToString()
-    {
+    public void testToString() {
         GHBitSet bs = createBitSet(100);
         bs.add(12);
         bs.add(1);
@@ -66,8 +63,7 @@ public void testToString()
     }
 
     @Test
-    public void testNext()
-    {
+    public void testNext() {
         GHBitSet bs = createBitSet(100);
         bs.add(7);
         bs.add(90);
@@ -78,18 +74,15 @@ public void testNext()
     }
 
     @Test
-    public void testEnsureCapacity()
-    {
+    public void testEnsureCapacity() {
         GHBitSet bs = createBitSet(8);
         bs.add(7);
-        try
-        {
+        try {
             bs.add(8);
             assertTrue(false);
-        } catch (Throwable ex)
-        {
+        } catch (Throwable ex) {
         }
-        
+
         bs.add(8);
         bs.add(9);
         assertFalse(bs.contains(6));
@@ -98,8 +91,7 @@ public void testEnsureCapacity()
     }
 
     @Test
-    public void testClear()
-    {
+    public void testClear() {
         GHBitSet bs = createBitSet(100);
         bs.add(12);
         bs.add(1);
diff --git a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
index 36858c71e5..38ccabf19b 100755
--- a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class BitSetImplTest extends AbstractMyBitSetTest
-{
+public class BitSetImplTest extends AbstractMyBitSetTest {
     @Override
-    public GHBitSet createBitSet( int no )
-    {
+    public GHBitSet createBitSet(int no) {
         return new GHBitSetImpl(no);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 2dddafae09..1f447f9c7a 100755
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -18,21 +18,19 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
 
 import java.util.Random;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 /**
  * @author Peter Karich
  */
-public class CompressedArrayTest
-{
+public class CompressedArrayTest {
     @Test
-    public void testCompress() throws Exception
-    {
+    public void testCompress() throws Exception {
         CompressedArray arr = new CompressedArray();
         arr.write(10, 1);
         arr.write(11, 2);
@@ -56,12 +54,10 @@ public void testCompress() throws Exception
     }
 
     @Test
-    public void testCompress2() throws Exception
-    {
+    public void testCompress2() throws Exception {
         CompressedArray arr = new CompressedArray();
         Random rand = new Random(0);
-        for (int i = 0; i < 10000; i++)
-        {
+        for (int i = 0; i < 10000; i++) {
             arr.write(i / 1000.0, rand.nextDouble() * 90);
         }
 
diff --git a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
index 7a0b23069a..797f2a6389 100755
--- a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
@@ -17,35 +17,30 @@
  */
 package com.graphhopper.coll;
 
+import org.junit.Test;
+
 import java.util.LinkedHashSet;
 import java.util.Random;
 import java.util.Set;
 
-import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class GHLongIntBTreeTest
-{
+public class GHLongIntBTreeTest {
     @Test
-    public void testThrowException_IfPutting_NoNumber()
-    {
+    public void testThrowException_IfPutting_NoNumber() {
         GHLongIntBTree instance = new GHLongIntBTree(2);
-        try
-        {
+        try {
             instance.put(-1, 1);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testTwoSplits()
-    {
+    public void testTwoSplits() {
         GHLongIntBTree instance = new GHLongIntBTree(3);
         instance.put(1, 2);
         instance.put(2, 4);
@@ -73,8 +68,7 @@ public void testTwoSplits()
     }
 
     @Test
-    public void testSplitAndOverwrite()
-    {
+    public void testSplitAndOverwrite() {
         GHLongIntBTree instance = new GHLongIntBTree(3);
         instance.put(1, 2);
         instance.put(2, 4);
@@ -88,17 +82,14 @@ public void testSplitAndOverwrite()
         assertEquals(6, instance.get(3));
     }
 
-    void check( GHLongIntBTree instance, int from )
-    {
-        for (int i = from; i < instance.getSize(); i++)
-        {
+    void check(GHLongIntBTree instance, int from) {
+        for (int i = from; i < instance.getSize(); i++) {
             assertEquals(i * 2, instance.get(i));
         }
     }
 
     @Test
-    public void testPut()
-    {
+    public void testPut() {
         GHLongIntBTree instance = new GHLongIntBTree(3);
         instance.put(2, 4);
         instance.put(7, 14);
@@ -125,8 +116,7 @@ public void testPut()
     }
 
     @Test
-    public void testUpdate()
-    {
+    public void testUpdate() {
         GHLongIntBTree instance = new GHLongIntBTree(2);
         int result = instance.put(100, 10);
         assertEquals(instance.getNoNumberValue(), result);
@@ -142,26 +132,21 @@ public void testUpdate()
     }
 
     @Test
-    public void testRandom()
-    {
-        for (int j = 3; j < 12; j += 4)
-        {
+    public void testRandom() {
+        for (int j = 3; j < 12; j += 4) {
             GHLongIntBTree instance = new GHLongIntBTree(j);
             int size = 500;
             Random rand = new Random(123);
             Set<Integer> addedValues = new LinkedHashSet<Integer>(size);
-            for (int i = 0; i < size; i++)
-            {
+            for (int i = 0; i < size; i++) {
                 int val = rand.nextInt(size);
                 addedValues.add(val);
-                try
-                {
+                try {
                     instance.put(val, val);
 //                    System.out.println(i + "--------------" + val);
 //                    instance.print();
 //                    System.out.println("\n\n");
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     ex.printStackTrace();
                     assertFalse(j + "| Problem with " + i + " " + ex, true);
                 }
@@ -169,15 +154,13 @@ public void testRandom()
                 assertEquals(j + "| Size not equal to set! In " + i + " added " + val, addedValues.size(), instance.getSize());
             }
             int i = 0;
-            for (int val : addedValues)
-            {
+            for (int val : addedValues) {
                 assertEquals(j + "| Problem with " + i, val, instance.get(val));
                 i++;
             }
             instance.optimize();
             i = 0;
-            for (int val : addedValues)
-            {
+            for (int val : addedValues) {
                 assertEquals(j + "| Problem with " + i, val, instance.get(val));
                 i++;
             }
diff --git a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
index d9f6bbc0c9..1d046db5e1 100755
--- a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
@@ -19,16 +19,15 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class GHSortedCollectionTest
-{
+public class GHSortedCollectionTest {
     @Test
-    public void testPoll()
-    {
+    public void testPoll() {
         GHSortedCollection instance = new GHSortedCollection();
         assertTrue(instance.isEmpty());
         instance.insert(0, 10);
@@ -42,8 +41,7 @@ public void testPoll()
     }
 
     @Test
-    public void testInsert()
-    {
+    public void testInsert() {
         GHSortedCollection instance = new GHSortedCollection();
         assertTrue(instance.isEmpty());
         instance.insert(0, 10);
@@ -62,8 +60,7 @@ public void testInsert()
     }
 
     @Test
-    public void testUpdate()
-    {
+    public void testUpdate() {
         GHSortedCollection instance = new GHSortedCollection();
         assertTrue(instance.isEmpty());
         instance.insert(0, 10);
diff --git a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
index 3709ebf94f..d88bbbc2c8 100755
--- a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
@@ -17,28 +17,24 @@
  */
 package com.graphhopper.coll;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class GHTBitSetTest extends AbstractMyBitSetTest
-{
+public class GHTBitSetTest extends AbstractMyBitSetTest {
     @Override
-    public GHBitSet createBitSet( int no )
-    {
+    public GHBitSet createBitSet(int no) {
         return new GHTBitSet(no);
     }
 
     @Override
-    public void testNext()
-    {
+    public void testNext() {
         // not supported (yet) -> due to sorting
     }
 
     @Override
-    public void testToString()
-    {
+    public void testToString() {
         // unsorted output!
         GHBitSet bs = createBitSet(100);
         bs.add(12);
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index 8ec1f90ef6..6da12df2b2 100755
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -19,16 +19,14 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class GHTreeMapComposedTest
-{
+public class GHTreeMapComposedTest {
     @Test
-    public void testInsert()
-    {
+    public void testInsert() {
         GHTreeMapComposed instance = new GHTreeMapComposed();
         instance.insert(1, 100);
         assertEquals(1, instance.peekKey());
diff --git a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
index 7aafdd93cc..2c17655895 100755
--- a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class IntDoubleBinHeapTest extends AbstractBinHeapTest
-{
+public class IntDoubleBinHeapTest extends AbstractBinHeapTest {
     @Override
-    public BinHeapWrapper<Number, Integer> createHeap( int capacity )
-    {
+    public BinHeapWrapper<Number, Integer> createHeap(int capacity) {
         return new IntDoubleBinHeap(capacity);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
index 3bb8f5299c..a0d9e269f0 100755
--- a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
@@ -21,16 +21,14 @@
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class OSMIDMapTest
-{
+public class OSMIDMapTest {
     @Test
-    public void testGet()
-    {
+    public void testGet() {
         OSMIDMap map = new OSMIDMap(new RAMDirectory());
         map.put(9, 0);
         map.put(10, -50);
@@ -53,16 +51,14 @@ public void testGet()
         assertEquals(2, map.get(31));
         assertEquals(-1, map.get(32));
 
-        for (int i = 0; i < 50; i++)
-        {
+        for (int i = 0; i < 50; i++) {
             map.put(i + 50, i + 7);
         }
         assertEquals(57, map.getSize());
     }
 
     @Test
-    public void testBinSearch()
-    {
+    public void testBinSearch() {
         DataAccess da = new RAMDirectory().find("");
         da.create(100);
 
@@ -89,8 +85,7 @@ public void testBinSearch()
     }
 
     @Test
-    public void testGetLong()
-    {
+    public void testGetLong() {
         OSMIDMap map = new OSMIDMap(new RAMDirectory());
         map.put(12, 0);
         map.put(Long.MAX_VALUE / 10, 1);
@@ -103,8 +98,7 @@ public void testGetLong()
     }
 
     @Test
-    public void testGet2()
-    {
+    public void testGet2() {
         OSMIDMap map = new OSMIDMap(new RAMDirectory());
         map.put(9, 0);
         map.put(10, 1);
@@ -131,8 +125,7 @@ public void testGet2()
     }
 
     @Test
-    public void testUpdateOfLowerKeys()
-    {
+    public void testUpdateOfLowerKeys() {
         OSMIDMap map = new OSMIDMap(new RAMDirectory());
         map.put(9, 0);
         map.put(10, 1);
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index 70b43ed726..b9aae20fe7 100755
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -19,19 +19,16 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
-
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
-public class LinearKeyAlgoTest
-{
+public class LinearKeyAlgoTest {
     @Test
-    public void testEncode()
-    {
+    public void testEncode() {
         KeyAlgo algo = new LinearKeyAlgo(3, 4).setBounds(-1, 9, -2, 20);
         assertEquals(2L, algo.encode(-1, 5));
         assertEquals(11L, algo.encode(14, 7));
@@ -48,8 +45,7 @@ public void testEncode()
     }
 
     @Test
-    public void testDecode()
-    {
+    public void testDecode() {
         KeyAlgo algo = new LinearKeyAlgo(3, 4).setBounds(-1, 9, -2, 20);
         GHPoint latLon = new GHPoint();
 
@@ -75,8 +71,7 @@ public void testDecode()
     * Test if different constructors yield same results
      */
     @Test
-    public void testInstantiation()
-    {
+    public void testInstantiation() {
         double minLon = 0;
         double minLat = 2;
         double maxLat = 6;
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index 9b7f91eb4b..2f6b9c04f3 100755
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -22,24 +22,22 @@
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class SpatialKeyAlgoTest
-{
+public class SpatialKeyAlgoTest {
     @Test
-    public void testEncode()
-    {
+    public void testEncode() {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(32);
         long val = algo.encode(-24.235345f, 47.234234f);
         assertEquals("01100110101000111100000110010100", BitUtil.BIG.toLastBitString(val, 32));
     }
 
     @Test
-    public void testEncode3BytesPrecision()
-    {
+    public void testEncode3BytesPrecision() {
         // 3 bytes => c / 1^12 = ~10km
         int bits = 3 * 8;
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
@@ -60,8 +58,7 @@ public void testEncode3BytesPrecision()
     }
 
     @Test
-    public void testEncode4BytesPrecision()
-    {
+    public void testEncode4BytesPrecision() {
         int bits = 4 * 8;
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
         float lat = 24.235345f;
@@ -80,8 +77,7 @@ public void testEncode4BytesPrecision()
     }
 
     @Test
-    public void testEncode6BytesPrecision()
-    {
+    public void testEncode6BytesPrecision() {
         int bits = 6 * 8;
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
         float lat = 24.235345f;
@@ -100,10 +96,8 @@ public void testEncode6BytesPrecision()
     }
 
     @Test
-    public void testBijectionBug2()
-    {
-        for (long i = 4; i <= 64; i += 4)
-        {
+    public void testBijectionBug2() {
+        for (long i = 4; i <= 64; i += 4) {
             SpatialKeyAlgo algo = new SpatialKeyAlgo((int) i);
             long keyX = algo.encode(1, 1);
 
@@ -123,8 +117,7 @@ public void testBijectionBug2()
     }
 
     @Test
-    public void testBijection()
-    {
+    public void testBijection() {
         // fix bijection precision problem!
         //
         // the latitude encoding "10" would result in 1.0 but a rounding error could lead to e.g. 0.99
@@ -142,8 +135,7 @@ public void testBijection()
         testBijection(8 * 8);
     }
 
-    public void testBijection( int bits )
-    {
+    public void testBijection(int bits) {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
         GHPoint coord11 = new GHPoint();
         long key = algo.encode(1, 1);
@@ -190,8 +182,7 @@ public void testBijection( int bits )
     }
 
     @Test
-    public void testNoFurtherIterationIfBitsIs1()
-    {
+    public void testNoFurtherIterationIfBitsIs1() {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(4).setBounds(0, 5, 0, 5);
         // 1001
         GHPoint coord = new GHPoint();
@@ -201,8 +192,7 @@ public void testNoFurtherIterationIfBitsIs1()
     }
 
     @Test
-    public void testOddBits()
-    {
+    public void testOddBits() {
         GHPoint coord = new GHPoint();
         SpatialKeyAlgo algo = new SpatialKeyAlgo(8);
         long key = algo.encode(5, 30);
@@ -219,8 +209,7 @@ public void testOddBits()
     }
 
     @Test
-    public void testDifferentInitialBounds()
-    {
+    public void testDifferentInitialBounds() {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(8).setBounds(0, 5, 0, 5);
         assertEquals(1, algo.encode(0, 0.5));
         assertEquals(5, algo.encode(0, 1));
@@ -234,8 +223,7 @@ public void testDifferentInitialBounds()
     }
 
     @Test
-    public void testEdgeCases()
-    {
+    public void testEdgeCases() {
         double minLon = -1, maxLon = 1.6;
         double minLat = -1, maxLat = 0.5;
         int parts = 4;
diff --git a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
index 98ce93374b..b6aa5458b0 100755
--- a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
@@ -17,23 +17,20 @@
  */
 package com.graphhopper.reader;
 
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.ReaderElement;
+import org.junit.Test;
+
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class OSMElementTest
-{
+public class OSMElementTest {
     @Test
-    public void testHasTag()
-    {
+    public void testHasTag() {
         ReaderElement instance = new ReaderWay(1);
         instance.setTag("surface", "something");
         assertTrue(instance.hasTag("surface", "now", "something"));
@@ -41,8 +38,7 @@ public void testHasTag()
     }
 
     @Test
-    public void testSetTags()
-    {
+    public void testSetTags() {
         ReaderElement instance = new ReaderWay(1);
         Map<String, String> map = new HashMap<String, String>();
         map.put("test", "xy");
diff --git a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
index 5a53432b14..fe792c128d 100755
--- a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
@@ -17,19 +17,17 @@
  */
 package com.graphhopper.reader;
 
-import com.graphhopper.reader.ReaderNode;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class OSMNodeTest
-{
+public class OSMNodeTest {
     @Test
-    public void testSetTags()
-    {
+    public void testSetTags() {
         ReaderNode instance = new ReaderNode(0, 10, 10);
         assertTrue(Double.isNaN(instance.getEle()));
 
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReader.java b/core/src/test/java/com/graphhopper/reader/PrinctonReader.java
index 1a359932c3..13f3084157 100755
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/test/java/com/graphhopper/reader/PrinctonReader.java
@@ -27,78 +27,65 @@
 /**
  * Data taken from here http://algs4.cs.princeton.edu/44sp/
  * <p>
+ *
  * @author Peter Karich
  */
-public class PrinctonReader
-{
+public class PrinctonReader {
     private Graph g;
     private InputStream is;
 
-    public PrinctonReader( Graph graph )
-    {
+    public PrinctonReader(Graph graph) {
         g = graph;
     }
 
-    public PrinctonReader setStream( InputStream is )
-    {
+    public PrinctonReader setStream(InputStream is) {
         this.is = is;
         return this;
     }
 
-    public void read()
-    {
+    public void read() {
         BufferedReader reader = new BufferedReader(new InputStreamReader(is, Helper.UTF_CS), 8 * (1 << 10));
         int lineNo = 0;
-        try
-        {
+        try {
             lineNo++;
             int nodes = Integer.parseInt(reader.readLine());
             lineNo++;
             int edges = Integer.parseInt(reader.readLine());
-            for (int i = 0; i < edges; i++)
-            {
+            for (int i = 0; i < edges; i++) {
                 lineNo++;
                 String line = reader.readLine();
                 if (line == null)
                     throw new IllegalStateException("Cannot read line " + lineNo);
-                
+
                 String args[] = line.split(" ");
                 int from = -1;
                 int to = -1;
                 double dist = -1;
                 int counter = 0;
-                for (int j = 0; j < args.length; j++)
-                {
-                    if (Helper.isEmpty(args[j]))
-                    {
+                for (int j = 0; j < args.length; j++) {
+                    if (Helper.isEmpty(args[j])) {
                         continue;
                     }
 
-                    if (counter == 0)
-                    {
+                    if (counter == 0) {
                         from = Integer.parseInt(args[j]);
-                    } else if (counter == 1)
-                    {
+                    } else if (counter == 1) {
                         to = Integer.parseInt(args[j]);
-                    } else
-                    {
+                    } else {
                         dist = Double.parseDouble(args[j]);
                     }
 
                     counter++;
                 }
-                if (counter != 3)
-                {
+                if (counter != 3) {
                     throw new RuntimeException("incorrect read!? from:" + from + ", to:" + to + ", dist:" + dist);
                 }
 
                 g.edge(from, to, dist, false);
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Problem in line " + lineNo, ex);
-        } finally
-        {
+        } finally {
             Helper.close(reader);
         }
     }
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
index 6fb1539e66..ac6d083f4b 100755
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
@@ -21,30 +21,25 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
-
-import static com.graphhopper.util.GHUtility.*;
-
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeExplorer;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.zip.GZIPInputStream;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class PrinctonReaderTest
-{
+public class PrinctonReaderTest {
     private EncodingManager encodingManager = new EncodingManager("car");
     private EdgeFilter carOutEdges = new DefaultEdgeFilter(encodingManager.getEncoder("car"), false, true);
 
     @Test
-    public void testRead()
-    {
+    public void testRead() {
         Graph graph = new GraphBuilder(encodingManager).create();
         new PrinctonReader(graph).setStream(PrinctonReader.class.getResourceAsStream("tinyEWD.txt")).read();
         assertEquals(8, graph.getNodes());
@@ -54,8 +49,7 @@ public void testRead()
     }
 
     @Test
-    public void testMediumRead() throws IOException
-    {
+    public void testMediumRead() throws IOException {
         Graph graph = new GraphBuilder(encodingManager).create();
         new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream("mediumEWD.txt.gz"))).read();
         assertEquals(250, graph.getNodes());
diff --git a/core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java
new file mode 100644
index 0000000000..66836865cf
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java
@@ -0,0 +1,84 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import java.util.Arrays;
+
+import org.junit.After;
+import org.junit.Before;
+
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+
+import gnu.trove.set.hash.TIntHashSet;
+
+/**
+ * @author Alexey Valikov
+ */
+public abstract class AbstractEdgeElevationInterpolatorTest {
+
+    protected static final double PRECISION = ElevationInterpolator.EPSILON2;
+    protected ReaderWay interpolatableWay;
+    protected ReaderWay normalWay;
+
+    protected GraphHopperStorage graph;
+    protected DataFlagEncoder dataFlagEncoder;
+    protected AbstractEdgeElevationInterpolator edgeElevationInterpolator;
+
+    @SuppressWarnings("resource")
+    @Before
+    public void setUp() {
+        dataFlagEncoder = new DataFlagEncoder();
+        graph = new GraphHopperStorage(new RAMDirectory(),
+                        new EncodingManager(Arrays.asList(dataFlagEncoder, new FootFlagEncoder()),
+                                        8),
+                        true, new GraphExtension.NoOpExtension()).create(100);
+
+        edgeElevationInterpolator = createEdgeElevationInterpolator();
+
+        interpolatableWay = createInterpolatableWay();
+        normalWay = new ReaderWay(0);
+        normalWay.setTag("highway", "primary");
+    }
+    
+    @After
+    public void tearDown() {
+        Helper.close(graph);
+    }
+
+    protected abstract ReaderWay createInterpolatableWay();
+
+    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new BridgeElevationInterpolator(graph, dataFlagEncoder);
+    }
+
+    protected void gatherOuterAndInnerNodeIdsOfStructure(EdgeIteratorState edge,
+                    final TIntHashSet outerNodeIds, final TIntHashSet innerNodeIds) {
+        edgeElevationInterpolator.gatherOuterAndInnerNodeIds(
+                        edgeElevationInterpolator.getStorage().createEdgeExplorer(), edge,
+                        new GHBitSetImpl(), outerNodeIds, innerNodeIds);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java
new file mode 100644
index 0000000000..4662525955
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java
@@ -0,0 +1,135 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.Arrays;
+
+import org.junit.Test;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+
+import gnu.trove.set.hash.TIntHashSet;
+
+/**
+ * @author Alexey Valikov
+ */
+public class BridgeElevationInterpolatorTest extends AbstractEdgeElevationInterpolatorTest {
+
+    @Override
+    protected ReaderWay createInterpolatableWay() {
+        ReaderWay bridgeWay = new ReaderWay(0);
+        bridgeWay.setTag("highway", "primary");
+        bridgeWay.setTag("bridge", "yes");
+        return bridgeWay;
+    }
+
+    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new BridgeElevationInterpolator(graph, dataFlagEncoder);
+    }
+
+    @Test
+    public void interpolatesElevationOfPillarNodes() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0-----1-----2-----3-----4
+		 *        \    |    /
+		 *         \   |   /
+		 *          T  T  T
+		 *           \ | /
+		 *            \|/
+		 * 5-----6--T--7--T--8-----9
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 10);
+        na.setNode(2, 20, 0, 20);
+        na.setNode(3, 30, 0, 30);
+        na.setNode(4, 40, 0, 40);
+        na.setNode(5, 0, 10, 40);
+        na.setNode(6, 10, 10, 30);
+        na.setNode(7, 20, 10, 1000);
+        na.setNode(8, 30, 10, 10);
+        na.setNode(9, 40, 10, 0);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+        EdgeIteratorState edge56 = graph.edge(5, 6, 10, true);
+        EdgeIteratorState edge67 = graph.edge(6, 7, 10, true);
+        EdgeIteratorState edge78 = graph.edge(7, 8, 10, true);
+        EdgeIteratorState edge89 = graph.edge(8, 9, 10, true);
+        EdgeIteratorState edge17 = graph.edge(1, 7, 10, true);
+        EdgeIteratorState edge27 = graph.edge(2, 7, 10, true);
+        EdgeIteratorState edge37 = graph.edge(3, 7, 10, true);
+        edge17.setWayGeometry(
+                        Helper.createPointList3D(12, 2, 200, 14, 4, 400, 16, 6, 600, 18, 8, 800));
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge23.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        edge56.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge67.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge78.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge89.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        edge17.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge27.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge37.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge27, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Arrays.asList(1, 2, 3, 6, 8)), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(7)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(0, na.getElevation(0), PRECISION);
+        assertEquals(10, na.getElevation(1), PRECISION);
+        assertEquals(20, na.getElevation(2), PRECISION);
+        assertEquals(30, na.getElevation(3), PRECISION);
+        assertEquals(40, na.getElevation(4), PRECISION);
+        assertEquals(40, na.getElevation(5), PRECISION);
+        assertEquals(30, na.getElevation(6), PRECISION);
+        assertEquals(20, na.getElevation(7), PRECISION);
+        assertEquals(10, na.getElevation(8), PRECISION);
+        assertEquals(0, na.getElevation(9), PRECISION);
+
+        final PointList edge17PointList = edge17.fetchWayGeometry(3);
+        assertEquals(6, edge17PointList.size());
+        assertEquals(10, edge17PointList.getEle(0), PRECISION);
+        assertEquals(12, edge17PointList.getEle(1), PRECISION);
+        assertEquals(14, edge17PointList.getEle(2), PRECISION);
+        assertEquals(16, edge17PointList.getEle(3), PRECISION);
+        assertEquals(18, edge17PointList.getEle(4), PRECISION);
+        assertEquals(20, edge17PointList.getEle(5), PRECISION);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
index 1be9231c8f..d39bc7647d 100755
--- a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -18,31 +18,30 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.util.Downloader;
+import org.junit.Before;
+import org.junit.Test;
+
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
-import org.junit.Test;
 
-import static org.junit.Assert.*;
-import org.junit.Before;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class CGIARProviderTest
-{
+public class CGIARProviderTest {
     CGIARProvider instance;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         instance = new CGIARProvider();
     }
 
     @Test
-    public void testDown()
-    {
+    public void testDown() {
         assertEquals(50, instance.down(52.5));
         assertEquals(0, instance.down(0.1));
         assertEquals(0, instance.down(0.01));
@@ -54,8 +53,7 @@ public void testDown()
     }
 
     @Test
-    public void testFileName()
-    {
+    public void testFileName() {
         assertEquals("srtm_36_02", instance.getFileName(52, -0.1));
         assertEquals("srtm_35_02", instance.getFileName(50, -10));
 
@@ -70,18 +68,15 @@ public void testFileName()
     }
 
     @Test
-    public void testFileNotFound()
-    {
+    public void testFileNotFound() {
         File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
         File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".zip");
         file.delete();
         zipFile.delete();
 
-        instance.setDownloader(new Downloader("test GH")
-        {
+        instance.setDownloader(new Downloader("test GH") {
             @Override
-            public void downloadFile( String url, String toFile ) throws IOException
-            {
+            public void downloadFile(String url, String toFile) throws IOException {
                 throw new FileNotFoundException("xyz");
             }
         });
@@ -91,22 +86,18 @@ public void downloadFile( String url, String toFile ) throws IOException
         assertTrue(file.exists());
         assertEquals(228, file.length());
 
-        instance.setDownloader(new Downloader("test GH")
-        {
+        instance.setDownloader(new Downloader("test GH") {
             @Override
-            public void downloadFile( String url, String toFile ) throws IOException
-            {
+            public void downloadFile(String url, String toFile) throws IOException {
                 throw new SocketTimeoutException("xyz");
             }
         });
 
-        try
-        {
+        try {
             instance.setSleep(30);
             instance.getEle(16, -20);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
 
         file.delete();
diff --git a/core/src/test/java/com/graphhopper/reader/dem/ElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/ElevationInterpolatorTest.java
new file mode 100644
index 0000000000..99a1d8f92c
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/ElevationInterpolatorTest.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * @author Alexey Valikov
+ */
+public class ElevationInterpolatorTest {
+
+    private static final double PRECISION = ElevationInterpolator.EPSILON2;
+
+    private ElevationInterpolator elevationInterpolator = new ElevationInterpolator();
+    
+    @Test
+    public void calculatesElevationOnTwoPoints() {
+        assertEquals(15, elevationInterpolator.calculateElevationBasedOnTwoPoints(0, 0, -10, -10,
+                        10, 10, 10, 20), PRECISION);
+        assertEquals(15, elevationInterpolator.calculateElevationBasedOnTwoPoints(-10, 10, -10, -10,
+                        10, 10, 10, 20), PRECISION);
+        assertEquals(15, elevationInterpolator.calculateElevationBasedOnTwoPoints(-5, 5, -10, -10,
+                        10, 10, 10, 20), PRECISION);
+        assertEquals(19, elevationInterpolator.calculateElevationBasedOnTwoPoints(8, 8, -10, -10,
+                        10, 10, 10, 20), PRECISION);
+        assertEquals(10, elevationInterpolator.calculateElevationBasedOnTwoPoints(0, 0,
+                        -ElevationInterpolator.EPSILON / 3, 0, 10,
+                        ElevationInterpolator.EPSILON / 2, 0, 20), PRECISION);
+        assertEquals(20, elevationInterpolator.calculateElevationBasedOnTwoPoints(0, 0,
+                        -ElevationInterpolator.EPSILON / 2, 0, 10,
+                        ElevationInterpolator.EPSILON / 3, 0, 20), PRECISION);
+        assertEquals(10, elevationInterpolator.calculateElevationBasedOnTwoPoints(0, 0, 0, 0, 10, 0,
+                        0, 20), PRECISION);
+    }
+
+    @Test
+    public void calculatesElevationOnThreePoints() {
+        assertEquals(-0.88, elevationInterpolator.calculateElevationBasedOnThreePoints(0, 0, 1,
+                        2, 3, 4, 6, 9, 12, 11, 9), PRECISION);
+        assertEquals(15, elevationInterpolator.calculateElevationBasedOnThreePoints(10, 0, 0, 0, 0,
+                        10, 10, 10, 10, -10, 20), PRECISION);
+        assertEquals(5, elevationInterpolator.calculateElevationBasedOnThreePoints(5, 5, 0, 0, 0,
+                        10, 10, 10, 20, 20, 20), PRECISION);
+    }
+
+    @Test
+    public void calculatesElevationOnNPoints() {
+        assertEquals(0, elevationInterpolator.calculateElevationBasedOnPointList(5, 5,
+                        Helper.createPointList3D(0, 0, 0, 10, 0, 0, 10, 10, 0, 0, 10, 0)),
+                        PRECISION);
+        assertEquals(10, elevationInterpolator.calculateElevationBasedOnPointList(5, 5,
+                        Helper.createPointList3D(0, 0, 0, 10, 0, 10, 10, 10, 20, 0, 10, 10)),
+                        PRECISION);
+        assertEquals(5, elevationInterpolator.calculateElevationBasedOnPointList(5, 5,
+                        Helper.createPointList3D(0, 0, 0, 10, 0, 10, 10, 10, 0, 0, 10, 10)),
+                        PRECISION);
+        assertEquals(2.65, elevationInterpolator.calculateElevationBasedOnPointList(2.5,
+                        2.5, Helper.createPointList3D(0, 0, 0, 10, 0, 10, 10, 10, 0, 0, 10, 10)),
+                        PRECISION);
+        assertEquals(0, elevationInterpolator.calculateElevationBasedOnPointList(0.1,
+                        0.1, Helper.createPointList3D(0, 0, 0, 10, 0, 10, 10, 10, 0, 0, 10, 10)),
+                        PRECISION);
+        assertEquals(0, elevationInterpolator.calculateElevationBasedOnPointList(
+                        ElevationInterpolator.EPSILON / 2, ElevationInterpolator.EPSILON / 2,
+                        Helper.createPointList3D(0, 0, 0, 10, 0, 10, 10, 10, 0, 0, 10, 10)),
+                        PRECISION);
+        assertEquals(0, elevationInterpolator.calculateElevationBasedOnPointList(5, 0,
+                        Helper.createPointList3D(0, 0, 0, 10, 1, 10, 10, -1, -10, 20, 0, 0)),
+                        PRECISION);
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index 552fdf6f29..046ff8d5e8 100755
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -21,16 +21,14 @@
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class HeightTileTest
-{
+public class HeightTileTest {
     @Test
-    public void testGetHeight()
-    {
+    public void testGetHeight() {
         // data access has same coordinate system as graphical or UI systems have (or the original DEM data has).
         // But HeightTile has lat,lon system ('mathematically')
         int width = 10;
@@ -75,8 +73,7 @@ public void testGetHeight()
     }
 
     @Test
-    public void testGetHeightForNegativeTile()
-    {
+    public void testGetHeightForNegativeTile() {
         int width = 10;
         HeightTile instance = new HeightTile(-20, -20, width, 1e-6, 10);
         DataAccess heights = new RAMDirectory().find("tmp");
@@ -98,8 +95,7 @@ public void testGetHeightForNegativeTile()
     }
 
     @Test
-    public void testCalcMean()
-    {
+    public void testCalcMean() {
         int width = 10;
         HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10).setCalcMean(true);
         DataAccess heights = new RAMDirectory().find("tmp");
@@ -125,12 +121,9 @@ public void testCalcMean()
         assertEquals((10 + 2) / 3d, instance.getHeight(-0.5, -0.5), 1e-3);
     }
 
-    private void init( DataAccess da, int width, int i )
-    {
-        for (int x = 0; x < width; x++)
-        {
-            for (int y = 0; y < width; y++)
-            {
+    private void init(DataAccess da, int width, int i) {
+        for (int x = 0; x < width; x++) {
+            for (int y = 0; y < width; y++) {
                 da.setShort(2 * (y * width + x), (short) 1);
             }
         }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 6bff4de61e..9d277b0a4d 100755
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -18,39 +18,33 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
-
-import java.io.File;
-import java.io.IOException;
-
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.io.File;
+import java.io.IOException;
 
-import org.junit.Before;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class SRTMProviderTest
-{
+public class SRTMProviderTest {
     SRTMProvider instance;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         instance = new SRTMProvider();
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         instance.release();
     }
 
     @Test
-    public void testGetFileString()
-    {
+    public void testGetFileString() {
         assertEquals("Eurasia/N49E011", instance.getFileString(49, 11));
         assertEquals("Eurasia/N52W002", instance.getFileString(52.268157, -1.230469));
         assertEquals("Africa/S06E034", instance.getFileString(-5.965754, 34.804687));
@@ -63,8 +57,7 @@ public void testGetFileString()
     }
 
     @Test
-    public void testGetHeight() throws IOException
-    {
+    public void testGetHeight() throws IOException {
         instance.setCacheDir(new File("./files/"));
         // easy to verify orientation of tile:
 //        instance.getEle(43, 13);
@@ -93,8 +86,7 @@ public void testGetHeight() throws IOException
     }
 
     @Test
-    public void testGetHeight_issue545() throws IOException
-    {
+    public void testGetHeight_issue545() throws IOException {
         instance.setCacheDir(new File("./files/"));
 
         // test different precision of the elevation file (3600)
@@ -102,8 +94,7 @@ public void testGetHeight_issue545() throws IOException
     }
 
     @Test
-    public void testGetHeightMMap() throws IOException
-    {
+    public void testGetHeightMMap() throws IOException {
         instance.setCacheDir(new File("./files/"));
         instance.setDAType(DAType.MMAP);
         assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
diff --git a/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java
new file mode 100644
index 0000000000..53c5572aa1
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java
@@ -0,0 +1,305 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+import org.junit.Test;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeIteratorState;
+
+import gnu.trove.set.hash.TIntHashSet;
+
+/**
+ * @author Alexey Valikov
+ */
+public class TunnelElevationInterpolatorTest extends AbstractEdgeElevationInterpolatorTest {
+
+    @Override
+    protected ReaderWay createInterpolatableWay() {
+        ReaderWay tunnelWay = new ReaderWay(0);
+        tunnelWay.setTag("highway", "primary");
+        tunnelWay.setTag("tunnel", "yes");
+        return tunnelWay;
+    }
+
+    @Override
+    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new TunnelElevationInterpolator(graph, dataFlagEncoder);
+    }
+
+    @Test
+    public void doesNotInterpolateElevationOfTunnelWithZeroOuterNodes() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0--T--1--T--2     3--T--4
+		 * Tunnel 0-1-2 has a single outer node 2.
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 0);
+        na.setNode(2, 20, 0, 10);
+        na.setNode(3, 30, 0, 20);
+        na.setNode(4, 40, 0, 0);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge01, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Collections.<Integer>emptyList()), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(0, 1, 2)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(0, na.getElevation(0), PRECISION);
+        assertEquals(0, na.getElevation(1), PRECISION);
+        assertEquals(10, na.getElevation(2), PRECISION);
+        assertEquals(20, na.getElevation(3), PRECISION);
+        assertEquals(0, na.getElevation(4), PRECISION);
+    }
+
+    @Test
+    public void interpolatesElevationOfTunnelWithSingleOuterNode() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0--T--1--T--2-----3--T--4
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 00);
+        na.setNode(2, 20, 0, 10);
+        na.setNode(3, 30, 0, 20);
+        na.setNode(4, 40, 0, 00);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge23.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge01, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Arrays.asList(2)), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(0, 1)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(10, na.getElevation(0), PRECISION);
+        assertEquals(10, na.getElevation(1), PRECISION);
+        assertEquals(10, na.getElevation(2), PRECISION);
+        assertEquals(20, na.getElevation(3), PRECISION);
+        assertEquals(20, na.getElevation(4), PRECISION);
+    }
+
+    @Test
+    public void interpolatesElevationOfTunnelWithTwoOuterNodes() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0-----1--T--2--T--3-----4
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 10);
+        na.setNode(2, 20, 0, 1000);
+        na.setNode(3, 30, 0, 30);
+        na.setNode(4, 40, 0, 40);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge12, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Arrays.asList(1, 3)), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(2)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(0, na.getElevation(0), PRECISION);
+        assertEquals(10, na.getElevation(1), PRECISION);
+        assertEquals(20, na.getElevation(2), PRECISION);
+        assertEquals(30, na.getElevation(3), PRECISION);
+        assertEquals(40, na.getElevation(4), PRECISION);
+    }
+
+    @Test
+    public void interpolatesElevationOfTunnelWithThreeOuterNodes() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0-----1--T--2--T--3-----4
+		 *             |
+		 *             |
+		 *             T
+		 *             |
+		 *             |
+		 *             5--T--6-----7
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 10);
+        na.setNode(2, 20, 0, 1000);
+        na.setNode(3, 30, 0, 30);
+        na.setNode(4, 40, 0, 40);
+        na.setNode(5, 20, 10, 1000);
+        na.setNode(6, 30, 10, 30);
+        na.setNode(7, 40, 10, 40);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+        EdgeIteratorState edge25 = graph.edge(2, 5, 10, true);
+        EdgeIteratorState edge56 = graph.edge(5, 6, 10, true);
+        EdgeIteratorState edge67 = graph.edge(6, 7, 10, true);
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge25.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge56.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge67.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge12, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Arrays.asList(1, 3, 6)), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(2, 5)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(0, na.getElevation(0), PRECISION);
+        assertEquals(10, na.getElevation(1), PRECISION);
+        assertEquals(20, na.getElevation(2), PRECISION);
+        assertEquals(30, na.getElevation(3), PRECISION);
+        assertEquals(40, na.getElevation(4), PRECISION);
+        assertEquals(20, na.getElevation(5), PRECISION);
+        assertEquals(30, na.getElevation(6), PRECISION);
+        assertEquals(40, na.getElevation(7), PRECISION);
+    }
+
+    @Test
+    public void interpolatesElevationOfTunnelWithFourOuterNodes() {
+
+        // @formatter:off
+		/*
+		 * Graph structure:
+		 * 0-----1--T--2--T--3-----4
+		 *             |
+		 *             |
+		 *             T
+		 *             |
+		 *             |
+		 * 5-----6--T--7--T--8-----9
+		 */
+        // @formatter:on
+
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 10, 0, 10);
+        na.setNode(2, 20, 0, 1000);
+        na.setNode(3, 30, 0, 30);
+        na.setNode(4, 40, 0, 40);
+        na.setNode(5, 0, 10, 40);
+        na.setNode(6, 10, 10, 30);
+        na.setNode(7, 20, 10, 1000);
+        na.setNode(8, 30, 10, 10);
+        na.setNode(9, 40, 10, 0);
+
+        EdgeIteratorState edge01 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
+        EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
+        EdgeIteratorState edge56 = graph.edge(5, 6, 10, true);
+        EdgeIteratorState edge67 = graph.edge(6, 7, 10, true);
+        EdgeIteratorState edge78 = graph.edge(7, 8, 10, true);
+        EdgeIteratorState edge89 = graph.edge(8, 9, 10, true);
+        EdgeIteratorState edge27 = graph.edge(2, 7, 10, true);
+
+        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        edge56.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge67.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge78.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge89.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+
+        edge27.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+
+        final TIntHashSet outerNodeIds = new TIntHashSet();
+        final TIntHashSet innerNodeIds = new TIntHashSet();
+        gatherOuterAndInnerNodeIdsOfStructure(edge12, outerNodeIds, innerNodeIds);
+
+        assertEquals(new TIntHashSet(Arrays.asList(1, 3, 6, 8)), outerNodeIds);
+        assertEquals(new TIntHashSet(Arrays.asList(2, 7)), innerNodeIds);
+
+        edgeElevationInterpolator.execute();
+        assertEquals(0, na.getElevation(0), PRECISION);
+        assertEquals(10, na.getElevation(1), PRECISION);
+        assertEquals(20, na.getElevation(2), PRECISION);
+        assertEquals(30, na.getElevation(3), PRECISION);
+        assertEquals(40, na.getElevation(4), PRECISION);
+        assertEquals(40, na.getElevation(5), PRECISION);
+        assertEquals(30, na.getElevation(6), PRECISION);
+        assertEquals(20, na.getElevation(7), PRECISION);
+        assertEquals(10, na.getElevation(8), PRECISION);
+        assertEquals(0, na.getElevation(9), PRECISION);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/osm/conditional/CalendarBasedTest.java b/core/src/test/java/com/graphhopper/reader/osm/conditional/CalendarBasedTest.java
index c24e1114b3..7db159ab40 100755
--- a/core/src/test/java/com/graphhopper/reader/osm/conditional/CalendarBasedTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osm/conditional/CalendarBasedTest.java
@@ -22,12 +22,11 @@
 /**
  * Base Test for calendar based tasks.
  * <p>
+ *
  * @author Robin Boldt
  */
-public abstract class CalendarBasedTest
-{
-    protected Calendar getCalendar( int year, int month, int day )
-    {
+public abstract class CalendarBasedTest {
+    protected Calendar getCalendar(int year, int month, int day) {
         Calendar calendar = DateRangeParser.createCalendar();
         calendar.set(Calendar.YEAR, year);
         calendar.set(Calendar.MONTH, month);
diff --git a/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspectorTest.java b/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspectorTest.java
index 1186d10298..a0b163bf94 100755
--- a/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspectorTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspectorTest.java
@@ -23,16 +23,42 @@
 
 import java.util.*;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Robin Boldt
  */
-public class ConditionalOSMTagInspectorTest extends CalendarBasedTest
-{
+public class ConditionalOSMTagInspectorTest extends CalendarBasedTest {
+    private static Set<String> getSampleRestrictedValues() {
+        Set<String> restrictedValues = new HashSet<String>();
+        restrictedValues.add("private");
+        restrictedValues.add("agricultural");
+        restrictedValues.add("forestry");
+        restrictedValues.add("no");
+        restrictedValues.add("restricted");
+        restrictedValues.add("delivery");
+        restrictedValues.add("military");
+        restrictedValues.add("emergency");
+        return restrictedValues;
+    }
+
+    private static Set<String> getSamplePermissiveValues() {
+        Set<String> restrictedValues = new HashSet<String>();
+        restrictedValues.add("yes");
+        restrictedValues.add("permissive");
+        return restrictedValues;
+    }
+
+    private static List<String> getSampleConditionalTags() {
+        List<String> conditionalTags = new ArrayList<String>();
+        conditionalTags.add("vehicle");
+        conditionalTags.add("access");
+        return conditionalTags;
+    }
+
     @Test
-    public void testConditionalAccept()
-    {
+    public void testConditionalAccept() {
         Calendar cal = getCalendar(2014, Calendar.MARCH, 10);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -41,8 +67,7 @@ public void testConditionalAccept()
     }
 
     @Test
-    public void testConditionalAcceptNextYear()
-    {
+    public void testConditionalAcceptNextYear() {
         Calendar cal = getCalendar(2014, Calendar.MARCH, 10);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -51,8 +76,7 @@ public void testConditionalAcceptNextYear()
     }
 
     @Test
-    public void testConditionalReject()
-    {
+    public void testConditionalReject() {
         Calendar cal = getCalendar(2014, Calendar.MARCH, 10);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -61,8 +85,7 @@ public void testConditionalReject()
     }
 
     @Test
-    public void testConditionalAllowance()
-    {
+    public void testConditionalAllowance() {
         Calendar cal = getCalendar(2014, Calendar.MARCH, 10);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -71,8 +94,7 @@ public void testConditionalAllowance()
     }
 
     @Test
-    public void testConditionalAllowanceReject()
-    {
+    public void testConditionalAllowanceReject() {
         Calendar cal = getCalendar(2014, Calendar.MARCH, 10);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -81,8 +103,7 @@ public void testConditionalAllowanceReject()
     }
 
     @Test
-    public void testConditionalSingleDay()
-    {
+    public void testConditionalSingleDay() {
         Calendar cal = getCalendar(2015, Calendar.DECEMBER, 27);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -91,8 +112,7 @@ public void testConditionalSingleDay()
     }
 
     @Test
-    public void testConditionalAllowanceSingleDay()
-    {
+    public void testConditionalAllowanceSingleDay() {
         Calendar cal = getCalendar(2015, Calendar.DECEMBER, 27);
         ConditionalTagInspector acceptor = new ConditionalOSMTagInspector(cal, getSampleConditionalTags(), getSampleRestrictedValues(), getSamplePermissiveValues());
         ReaderWay way = new ReaderWay(1);
@@ -100,34 +120,4 @@ public void testConditionalAllowanceSingleDay()
         assertTrue(acceptor.isRestrictedWayConditionallyPermitted(way));
     }
 
-    private static Set<String> getSampleRestrictedValues()
-    {
-        Set<String> restrictedValues = new HashSet<String>();
-        restrictedValues.add("private");
-        restrictedValues.add("agricultural");
-        restrictedValues.add("forestry");
-        restrictedValues.add("no");
-        restrictedValues.add("restricted");
-        restrictedValues.add("delivery");
-        restrictedValues.add("military");
-        restrictedValues.add("emergency");
-        return restrictedValues;
-    }
-
-    private static Set<String> getSamplePermissiveValues()
-    {
-        Set<String> restrictedValues = new HashSet<String>();
-        restrictedValues.add("yes");
-        restrictedValues.add("permissive");
-        return restrictedValues;
-    }
-
-    private static List<String> getSampleConditionalTags()
-    {
-        List<String> conditionalTags = new ArrayList<String>();
-        conditionalTags.add("vehicle");
-        conditionalTags.add("access");
-        return conditionalTags;
-    }
-
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalParserTest.java b/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalParserTest.java
index 8a2ab74a3f..d78a2380ab 100755
--- a/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalParserTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osm/conditional/ConditionalParserTest.java
@@ -30,13 +30,11 @@
 /**
  * @author Robin Boldt
  */
-public class ConditionalParserTest extends CalendarBasedTest
-{
+public class ConditionalParserTest extends CalendarBasedTest {
     ConditionalParser parser;
 
     @Before
-    public void setup()
-    {
+    public void setup() {
         HashSet<String> restrictedValues = new HashSet<String>();
         restrictedValues.add("private");
         restrictedValues.add("agricultural");
@@ -51,23 +49,20 @@ public void setup()
     }
 
     @Test
-    public void testParseConditional() throws ParseException
-    {
+    public void testParseConditional() throws ParseException {
         ValueRange dateRange = parser.getRange("no @ (2015 Sep 1-2015 Sep 30)");
         assertFalse(dateRange.isInRange(getCalendar(2015, Calendar.AUGUST, 31)));
         assertTrue(dateRange.isInRange(getCalendar(2015, Calendar.SEPTEMBER, 30)));
     }
 
     @Test
-    public void testParseAllowingCondition() throws ParseException
-    {
+    public void testParseAllowingCondition() throws ParseException {
         ValueRange dateRange = parser.getRange("yes @ (2015 Sep 1-2015 Sep 30)");
         assertNull(dateRange);
     }
 
     @Test
-    public void testParsingOfLeading0() throws ParseException
-    {
+    public void testParsingOfLeading0() throws ParseException {
         ValueRange dateRange = parser.getRange("no @ (01.11. - 31.03.)");
         assertTrue(dateRange.isInRange(getCalendar(2015, Calendar.DECEMBER, 2)));
 
@@ -76,8 +71,7 @@ public void testParsingOfLeading0() throws ParseException
     }
 
     @Test
-    public void testGetRange() throws Exception
-    {
+    public void testGetRange() throws Exception {
         Set<String> set = new HashSet<>();
         set.add("no");
         ConditionalParser instance = new ConditionalParser(set);
@@ -124,8 +118,7 @@ public void testGetRange() throws Exception
     }
 
     @Test
-    public void parseNumber()
-    {
+    public void parseNumber() {
         // TODO currently no unit conversation is done which can be required if a different one is passed in isInRange        
         Set<String> set = new HashSet<>();
         ConditionalParser p = new ConditionalParser(set);
diff --git a/core/src/test/java/com/graphhopper/reader/osm/conditional/DateRangeParserTest.java b/core/src/test/java/com/graphhopper/reader/osm/conditional/DateRangeParserTest.java
index 484c786671..92c5284fe7 100755
--- a/core/src/test/java/com/graphhopper/reader/osm/conditional/DateRangeParserTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osm/conditional/DateRangeParserTest.java
@@ -27,11 +27,9 @@
 /**
  * @author Robin Boldt
  */
-public class DateRangeParserTest extends CalendarBasedTest
-{
+public class DateRangeParserTest extends CalendarBasedTest {
     @Test
-    public void testParseConditional() throws ParseException
-    {
+    public void testParseConditional() throws ParseException {
         assertSameDate(2014, Calendar.DECEMBER, 15, "2014 Dec 15");
         assertSameDate(2015, Calendar.MARCH, 2, "2015 Mar 2");
         assertSameDate(2015, Calendar.MARCH, 1, "2015 Mar");
@@ -40,15 +38,13 @@ public void testParseConditional() throws ParseException
     }
 
     @Test
-    public void testToString() throws ParseException
-    {
+    public void testToString() throws ParseException {
         DateRange instance = DateRangeParser.parseDateRange("Mar-Oct");
         assertEquals("yearless:true, dayOnly:false, reverse:false, from:1970-03-01T00:00:00Z, to:1970-10-31T23:59:59Z", instance.toString());
     }
 
     @Test
-    public void testParseSimpleDateRange() throws ParseException
-    {
+    public void testParseSimpleDateRange() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("2014 Aug 10-2014 Aug 14");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 9)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 10)));
@@ -58,8 +54,7 @@ public void testParseSimpleDateRange() throws ParseException
     }
 
     @Test
-    public void testParseSimpleDateRangeWithoutYear() throws ParseException
-    {
+    public void testParseSimpleDateRangeWithoutYear() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Aug 10-Aug 14");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 9)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 10)));
@@ -69,8 +64,7 @@ public void testParseSimpleDateRangeWithoutYear() throws ParseException
     }
 
     @Test
-    public void testParseSimpleDateRangeWithoutYearAndDay() throws ParseException
-    {
+    public void testParseSimpleDateRangeWithoutYearAndDay() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Jul-Aug");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.JUNE, 9)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.JULY, 10)));
@@ -79,8 +73,7 @@ public void testParseSimpleDateRangeWithoutYearAndDay() throws ParseException
     }
 
     @Test
-    public void testParseSimpleDateRangeWithoutYearAndDay2() throws ParseException
-    {
+    public void testParseSimpleDateRangeWithoutYearAndDay2() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Mar-Sep");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.FEBRUARY, 25)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.MARCH, 1)));
@@ -89,8 +82,7 @@ public void testParseSimpleDateRangeWithoutYearAndDay2() throws ParseException
     }
 
     @Test
-    public void testParseReverseDateRange() throws ParseException
-    {
+    public void testParseReverseDateRange() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("2014 Aug 14-2015 Mar 10");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 13)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 14)));
@@ -99,8 +91,7 @@ public void testParseReverseDateRange() throws ParseException
     }
 
     @Test
-    public void testParseReverseDateRangeWithoutYear() throws ParseException
-    {
+    public void testParseReverseDateRangeWithoutYear() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Aug 14-Aug 10");
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.JANUARY, 9)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 9)));
@@ -112,8 +103,7 @@ public void testParseReverseDateRangeWithoutYear() throws ParseException
     }
 
     @Test
-    public void testParseReverseDateRangeWithoutYearAndDay() throws ParseException
-    {
+    public void testParseReverseDateRangeWithoutYearAndDay() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Sep-Mar");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 31)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.SEPTEMBER, 1)));
@@ -124,8 +114,7 @@ public void testParseReverseDateRangeWithoutYearAndDay() throws ParseException
     }
 
     @Test
-    public void testParseReverseDateRangeWithoutYearAndDay_645() throws ParseException
-    {
+    public void testParseReverseDateRangeWithoutYearAndDay_645() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Aug 10-Jan");
         assertFalse(dateRange.isInRange(getCalendar(2016, Calendar.AUGUST, 9)));
         assertTrue(dateRange.isInRange(getCalendar(2016, Calendar.AUGUST, 10)));
@@ -136,8 +125,7 @@ public void testParseReverseDateRangeWithoutYearAndDay_645() throws ParseExcepti
     }
 
     @Test
-    public void testParseSingleDateRange() throws ParseException
-    {
+    public void testParseSingleDateRange() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("2014 Sep 1");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 31)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.SEPTEMBER, 1)));
@@ -147,8 +135,7 @@ public void testParseSingleDateRange() throws ParseException
     }
 
     @Test
-    public void testParseSingleDateRangeWithoutDay() throws ParseException
-    {
+    public void testParseSingleDateRangeWithoutDay() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("2014 Sep");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 31)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.SEPTEMBER, 1)));
@@ -158,8 +145,7 @@ public void testParseSingleDateRangeWithoutDay() throws ParseException
     }
 
     @Test
-    public void testParseSingleDateRangeWithoutYearAndDay() throws ParseException
-    {
+    public void testParseSingleDateRangeWithoutYearAndDay() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Sep");
         assertFalse(dateRange.isInRange(getCalendar(2014, Calendar.AUGUST, 31)));
         assertTrue(dateRange.isInRange(getCalendar(2014, Calendar.SEPTEMBER, 1)));
@@ -168,8 +154,7 @@ public void testParseSingleDateRangeWithoutYearAndDay() throws ParseException
     }
 
     @Test
-    public void testParseSingleDateRangeOneDayOnly() throws ParseException
-    {
+    public void testParseSingleDateRangeOneDayOnly() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Sa");
         assertFalse(dateRange.isInRange(getCalendar(2015, Calendar.DECEMBER, 25)));
         assertTrue(dateRange.isInRange(getCalendar(2015, Calendar.DECEMBER, 26)));
@@ -177,8 +162,7 @@ public void testParseSingleDateRangeOneDayOnly() throws ParseException
     }
 
     @Test
-    public void testParseSingleDateRangeOneDayOnlyIncludingPh() throws ParseException
-    {
+    public void testParseSingleDateRangeOneDayOnlyIncludingPh() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Su, PH");
         assertFalse(dateRange.isInRange(getCalendar(2015, Calendar.DECEMBER, 26)));
         assertTrue(dateRange.isInRange(getCalendar(2015, Calendar.DECEMBER, 27)));
@@ -186,8 +170,7 @@ public void testParseSingleDateRangeOneDayOnlyIncludingPh() throws ParseExceptio
     }
 
     @Test
-    public void testParseSingleDateRangeDayOnly() throws ParseException
-    {
+    public void testParseSingleDateRangeDayOnly() throws ParseException {
         DateRange dateRange = DateRangeParser.parseDateRange("Mo-Fr");
         assertTrue(dateRange.dayOnly);
         assertFalse(dateRange.reverse);
@@ -199,8 +182,7 @@ public void testParseSingleDateRangeDayOnly() throws ParseException
     }
 
     @Test
-    public void testParseReverseDateRangeDayOnly() throws ParseException
-    {
+    public void testParseReverseDateRangeDayOnly() throws ParseException {
         // This is reverse since Su=7 and Mo=1 
         // Note: If we use Locale.Germany or Locale.UK for calendar creation 
         // then cal.set(DAY_OF_WEEK, 7) results in a "time in millis" after Saturday leading to reverse=false
@@ -214,14 +196,12 @@ public void testParseReverseDateRangeDayOnly() throws ParseException
     }
 
     @Test(expected = ParseException.class)
-    public void testParseUnparsableDate() throws ParseException
-    {
+    public void testParseUnparsableDate() throws ParseException {
         DateRangeParser.parseDateRange("Sat");
         fail();
     }
 
-    private void assertSameDate( int year, int month, int day, String dateString ) throws ParseException
-    {
+    private void assertSameDate(int year, int month, int day, String dateString) throws ParseException {
         Calendar expected = getCalendar(year, month, day);
         ParsedCalendar actualParsed = DateRangeParser.parseDateString(dateString);
         Calendar actual = actualParsed.parsedCalendar;
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 69fd610598..4b94f5e5e2 100755
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,77 +17,57 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.ShortestWeighting;
-
-import java.util.Arrays;
-import java.util.Collection;
-
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
 import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.Assert.assertEquals;
 
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class AStarBidirectionTest extends AbstractRoutingAlgorithmTester
-{
+public class AStarBidirectionTest extends AbstractRoutingAlgorithmTester {
+    private final TraversalMode traversalMode;
+
+    public AStarBidirectionTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-                {
-                        {
-                                TraversalMode.NODE_BASED
-                        },
-                        {
-                                TraversalMode.EDGE_BASED_1DIR
-                        },
-                        {
-                                TraversalMode.EDGE_BASED_2DIR
-                        },
-                        {
-                                TraversalMode.EDGE_BASED_2DIR_UTURN
-                        }
-                });
-    }
-
-    private final TraversalMode traversalMode;
-
-    public AStarBidirectionTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {TraversalMode.NODE_BASED},
+            {TraversalMode.EDGE_BASED_1DIR},
+            {TraversalMode.EDGE_BASED_2DIR},
+            {TraversalMode.EDGE_BASED_2DIR_UTURN}
+        });
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
-    {
-        return new RoutingAlgorithmFactory()
-        {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+        return new RoutingAlgorithmFactory() {
             @Override
-            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-            {
-                return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
+            public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+                return new AStarBidirection(g, opts.getWeighting(), traversalMode);
             }
         };
     }
 
     @Test
-    public void testInitFromAndTo()
-    {
+    public void testInitFromAndTo() {
         Graph g = createGHStorage(false);
         g.edge(0, 1, 1, true);
         updateDistancesFor(g, 0, 0.00, 0.00);
@@ -95,18 +75,15 @@ public void testInitFromAndTo()
 
         final AtomicReference<AStar.AStarEntry> fromRef = new AtomicReference<AStar.AStarEntry>();
         final AtomicReference<AStar.AStarEntry> toRef = new AtomicReference<AStar.AStarEntry>();
-        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(carEncoder), traversalMode)
-        {
+        AStarBidirection astar = new AStarBidirection(g, new ShortestWeighting(carEncoder), traversalMode) {
             @Override
-            public void initFrom( int from, double weight )
-            {
+            public void initFrom(int from, double weight) {
                 super.initFrom(from, weight);
                 fromRef.set(currFrom);
             }
 
             @Override
-            public void initTo( int to, double weight )
-            {
+            public void initTo(int to, double weight) {
                 super.initTo(to, weight);
                 toRef.set(currTo);
             }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 08b08ea923..8cd206fcea 100755
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -17,55 +17,46 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-
-import java.util.Arrays;
-import java.util.Collection;
-
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
+import java.util.Arrays;
+import java.util.Collection;
 
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class AStarTest extends AbstractRoutingAlgorithmTester
-{
+public class AStarTest extends AbstractRoutingAlgorithmTester {
+    private final TraversalMode traversalMode;
+
+    public AStarTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-                {
-                        {TraversalMode.NODE_BASED},
-                        {TraversalMode.EDGE_BASED_1DIR},
-                        {TraversalMode.EDGE_BASED_2DIR},
-                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
-                });
-    }
-
-    private final TraversalMode traversalMode;
-
-    public AStarTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {TraversalMode.NODE_BASED},
+            {TraversalMode.EDGE_BASED_1DIR},
+            {TraversalMode.EDGE_BASED_2DIR},
+            {TraversalMode.EDGE_BASED_2DIR_UTURN}
+        });
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
-    {
-        return new RoutingAlgorithmFactory()
-        {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+        return new RoutingAlgorithmFactory() {
             @Override
-            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-            {
-                return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
+            public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+                return new AStar(g, opts.getWeighting(), traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 0335581ea1..bece84ae92 100755
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -18,69 +18,163 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import gnu.trove.list.TIntList;
-import java.util.*;
-
-import static org.junit.Assert.*;
-
 import org.junit.Before;
 import org.junit.Test;
 
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import static org.junit.Assert.*;
+
 /**
  * @author Peter Karich
  */
-public abstract class AbstractRoutingAlgorithmTester
-{
+public abstract class AbstractRoutingAlgorithmTester {
     protected static final EncodingManager encodingManager = new EncodingManager("car,foot");
+    private static final DistanceCalc distCalc = new DistanceCalcEarth();
     protected FlagEncoder carEncoder;
     protected FlagEncoder footEncoder;
     protected AlgorithmOptions defaultOpts;
 
+    // 0-1-2-3-4
+    // |     / |
+    // |    8  |
+    // \   /   |
+    //  7-6----5
+    public static Graph initBiGraph(Graph graph) {
+        // distance will be overwritten in second step as we need to calculate it from lat,lon
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(4, 5, 1, true);
+        graph.edge(5, 6, 1, true);
+        graph.edge(6, 7, 1, true);
+        graph.edge(7, 0, 1, true);
+        graph.edge(3, 8, 1, true);
+        graph.edge(8, 6, 1, true);
+
+        // we need lat,lon for edge precise queries because the distances of snapped point
+        // to adjacent nodes is calculated from lat,lon of the necessary points
+        updateDistancesFor(graph, 0, 0.001, 0);
+        updateDistancesFor(graph, 1, 0.100, 0.0005);
+        updateDistancesFor(graph, 2, 0.010, 0.0010);
+        updateDistancesFor(graph, 3, 0.001, 0.0011);
+        updateDistancesFor(graph, 4, 0.001, 0.00111);
+
+        updateDistancesFor(graph, 8, 0.0005, 0.0011);
+
+        updateDistancesFor(graph, 7, 0, 0);
+        updateDistancesFor(graph, 6, 0, 0.001);
+        updateDistancesFor(graph, 5, 0, 0.004);
+        return graph;
+    }
+
+    public static void updateDistancesFor(Graph g, int node, double lat, double lon) {
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(node, lat, lon);
+        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
+        while (iter.next()) {
+            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
+        }
+    }
+
+    protected static GraphHopperStorage createMatrixAlikeGraph(GraphHopperStorage tmpGraph) {
+        int WIDTH = 10;
+        int HEIGHT = 15;
+        int[][] matrix = new int[WIDTH][HEIGHT];
+        int counter = 0;
+        Random rand = new Random(12);
+        boolean print = false;
+        for (int h = 0; h < HEIGHT; h++) {
+            if (print) {
+                for (int w = 0; w < WIDTH; w++) {
+                    System.out.print(" |\t           ");
+                }
+                System.out.println();
+            }
+
+            for (int w = 0; w < WIDTH; w++) {
+                matrix[w][h] = counter++;
+                if (h > 0) {
+                    float dist = 5 + Math.abs(rand.nextInt(5));
+                    if (print)
+                        System.out.print(" " + (int) dist + "\t           ");
+
+                    tmpGraph.edge(matrix[w][h], matrix[w][h - 1], dist, true);
+                }
+            }
+            if (print) {
+                System.out.println();
+                if (h > 0) {
+                    for (int w = 0; w < WIDTH; w++) {
+                        System.out.print(" |\t           ");
+                    }
+                    System.out.println();
+                }
+            }
+
+            for (int w = 0; w < WIDTH; w++) {
+                if (w > 0) {
+                    float dist = 5 + Math.abs(rand.nextInt(5));
+                    if (print)
+                        System.out.print("-- " + (int) dist + "\t-- ");
+                    tmpGraph.edge(matrix[w][h], matrix[w - 1][h], dist, true);
+                }
+                if (print)
+                    System.out.print("(" + matrix[w][h] + ")\t");
+            }
+            if (print)
+                System.out.println();
+        }
+
+        return tmpGraph;
+    }
+
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
         footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
-        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+        defaultOpts = AlgorithmOptions.start().
                 weighting(new ShortestWeighting(carEncoder)).build();
     }
 
-    protected Graph getGraph( GraphHopperStorage ghStorage, Weighting weighting )
-    {
+    protected Graph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
         return ghStorage.getGraph(Graph.class, weighting);
     }
 
-    protected GraphHopperStorage createGHStorage( EncodingManager em, List<? extends Weighting> weightings, boolean is3D )
-    {
+    protected GraphHopperStorage createGHStorage(EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
         return new GraphBuilder(em).set3D(is3D).create();
     }
 
-    protected GraphHopperStorage createGHStorage( boolean is3D )
-    {
+    protected GraphHopperStorage createGHStorage(boolean is3D) {
         return createGHStorage(encodingManager, Arrays.asList(defaultOpts.getWeighting()), is3D);
     }
 
-    protected final RoutingAlgorithm createAlgo( GraphHopperStorage g )
-    {
+    protected final RoutingAlgorithm createAlgo(GraphHopperStorage g) {
         return createAlgo(g, defaultOpts);
     }
 
-    protected final RoutingAlgorithm createAlgo( GraphHopperStorage ghStorage, AlgorithmOptions opts )
-    {
+    protected final RoutingAlgorithm createAlgo(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         return createFactory(ghStorage, opts).createAlgo(getGraph(ghStorage, opts.getWeighting()), opts);
     }
 
-    public abstract RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts );
+    public abstract RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts);
 
     @Test
-    public void testCalcShortestPath()
-    {
+    public void testCalcShortestPath() {
         GraphHopperStorage ghStorage = createTestStorage();
         RoutingAlgorithm algo = createAlgo(ghStorage);
         Path p = algo.calcPath(0, 7);
@@ -90,8 +184,7 @@ public void testCalcShortestPath()
 
     // see calc-fastest-graph.svg
     @Test
-    public void testCalcFastestPath()
-    {
+    public void testCalcFastestPath() {
         GraphHopperStorage graphShortest = createGHStorage(false);
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
         Path p1 = createAlgo(graphShortest, defaultOpts).
@@ -100,7 +193,7 @@ public void testCalcFastestPath()
         assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).
+        AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(new FastestWeighting(carEncoder)).build();
         GraphHopperStorage graphFastest = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), false);
         initDirectedAndDiffSpeed(graphFastest, carEncoder);
@@ -116,8 +209,7 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
-    {
+    protected void initDirectedAndDiffSpeed(Graph graph, FlagEncoder enc) {
         graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
         graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
@@ -153,9 +245,8 @@ protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     }
 
     @Test
-    public void testCalcFootPath()
-    {
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(footEncoder).
+    public void testCalcFootPath() {
+        AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(new ShortestWeighting(footEncoder)).build();
         GraphHopperStorage ghStorage = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), false);
         initFootVsCar(ghStorage);
@@ -166,8 +257,7 @@ public void testCalcFootPath()
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    protected void initFootVsCar( Graph graph )
-    {
+    protected void initFootVsCar(Graph graph) {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
 
@@ -191,8 +281,7 @@ protected void initFootVsCar( Graph graph )
     }
 
     // see test-graph.svg !
-    protected GraphHopperStorage createTestStorage()
-    {
+    protected GraphHopperStorage createTestStorage() {
         GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 7, true);
@@ -230,8 +319,7 @@ protected GraphHopperStorage createTestStorage()
     }
 
     @Test
-    public void testNoPathFound()
-    {
+    public void testNoPathFound() {
         GraphHopperStorage graph = createGHStorage(false);
         graph.edge(100, 101);
         assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
@@ -258,8 +346,7 @@ public void testNoPathFound()
     }
 
     @Test
-    public void testWikipediaShortestPath()
-    {
+    public void testWikipediaShortestPath() {
         GraphHopperStorage ghStorage = createWikipediaTestGraph();
         Path p = createAlgo(ghStorage).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
@@ -267,16 +354,14 @@ public void testWikipediaShortestPath()
     }
 
     @Test
-    public void testCalcIf1EdgeAway()
-    {
+    public void testCalcIf1EdgeAway() {
         Path p = createAlgo(createTestStorage()).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
-    protected GraphHopperStorage createWikipediaTestGraph()
-    {
+    protected GraphHopperStorage createWikipediaTestGraph() {
         GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 7, true);
         graph.edge(0, 2, 9, true);
@@ -290,58 +375,8 @@ protected GraphHopperStorage createWikipediaTestGraph()
         return graph;
     }
 
-    // 0-1-2-3-4
-    // |     / |
-    // |    8  |
-    // \   /   |
-    //  7-6----5
-    public static Graph initBiGraph( Graph graph )
-    {
-        // distance will be overwritten in second step as we need to calculate it from lat,lon
-        graph.edge(0, 1, 1, true);
-        graph.edge(1, 2, 1, true);
-        graph.edge(2, 3, 1, true);
-        graph.edge(3, 4, 1, true);
-        graph.edge(4, 5, 1, true);
-        graph.edge(5, 6, 1, true);
-        graph.edge(6, 7, 1, true);
-        graph.edge(7, 0, 1, true);
-        graph.edge(3, 8, 1, true);
-        graph.edge(8, 6, 1, true);
-
-        // we need lat,lon for edge precise queries because the distances of snapped point 
-        // to adjacent nodes is calculated from lat,lon of the necessary points
-        updateDistancesFor(graph, 0, 0.001, 0);
-        updateDistancesFor(graph, 1, 0.100, 0.0005);
-        updateDistancesFor(graph, 2, 0.010, 0.0010);
-        updateDistancesFor(graph, 3, 0.001, 0.0011);
-        updateDistancesFor(graph, 4, 0.001, 0.00111);
-
-        updateDistancesFor(graph, 8, 0.0005, 0.0011);
-
-        updateDistancesFor(graph, 7, 0, 0);
-        updateDistancesFor(graph, 6, 0, 0.001);
-        updateDistancesFor(graph, 5, 0, 0.004);
-        return graph;
-    }
-
-    private static final DistanceCalc distCalc = new DistanceCalcEarth();
-
-    public static void updateDistancesFor( Graph g, int node, double lat, double lon )
-    {
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(node, lat, lon);
-        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
-        while (iter.next())
-        {
-            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
-            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
-        }
-    }
-
     @Test
-    public void testBidirectional()
-    {
+    public void testBidirectional() {
         GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
@@ -358,8 +393,7 @@ public void testBidirectional()
     }
 
     @Test
-    public void testMaxVisitedNodes()
-    {
+    public void testMaxVisitedNodes() {
         GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
@@ -379,8 +413,7 @@ public void testMaxVisitedNodes()
     // \   /   /
     //  8-7-6-/
     @Test
-    public void testBidirectional2()
-    {
+    public void testBidirectional2() {
         GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 100, true);
@@ -401,8 +434,7 @@ public void testBidirectional2()
     }
 
     @Test
-    public void testRekeyBugOfIntBinHeap()
-    {
+    public void testRekeyBugOfIntBinHeap() {
         // using Dijkstra + IntBinHeap then rekey loops endlessly
         GraphHopperStorage matrixGraph = createMatrixGraph();
         Path p = createAlgo(matrixGraph).calcPath(36, 91);
@@ -410,8 +442,7 @@ public void testRekeyBugOfIntBinHeap()
 
         TIntList list = p.calcNodes();
         if (!Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91).equals(list)
-                && !Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list))
-        {
+                && !Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list)) {
             assertTrue("wrong locations: " + list.toString(), false);
         }
         assertEquals(66f, p.getDistance(), 1e-3);
@@ -420,24 +451,21 @@ public void testRekeyBugOfIntBinHeap()
         testCorrectWeight(matrixGraph);
     }
 
-    public void testBug1( GraphHopperStorage g )
-    {
+    public void testBug1(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
     }
 
-    public void testCorrectWeight( GraphHopperStorage g )
-    {
+    public void testCorrectWeight(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
 
     @Test
-    public void testCannotCalculateSP()
-    {
+    public void testCannotCalculateSP() {
         GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
@@ -447,8 +475,7 @@ public void testCannotCalculateSP()
     }
 
     @Test
-    public void testDirectedGraphBug1()
-    {
+    public void testDirectedGraphBug1() {
         GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 3, false);
         graph.edge(1, 2, 2.99, false);
@@ -464,8 +491,7 @@ public void testDirectedGraphBug1()
     }
 
     @Test
-    public void testDirectedGraphBug2()
-    {
+    public void testDirectedGraphBug2() {
         GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
@@ -482,8 +508,7 @@ public void testDirectedGraphBug2()
     // |  /  /  |
     // d-2--3-e-4
     @Test
-    public void testWithCoordinates()
-    {
+    public void testWithCoordinates() {
         Weighting weighting = new ShortestWeighting(carEncoder);
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
 
@@ -504,7 +529,7 @@ public void testWithCoordinates()
         updateDistancesFor(graph, 3, 0, 1);
         updateDistancesFor(graph, 4, 0, 2);
 
-        AlgorithmOptions opts = new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting);
+        AlgorithmOptions opts = new AlgorithmOptions(DIJKSTRA_BI, weighting);
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
         Path p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
@@ -518,16 +543,14 @@ public void testWithCoordinates()
     }
 
     @Test
-    public void testCalcIfEmptyWay()
-    {
+    public void testCalcIfEmptyWay() {
         Path p = createAlgo(createTestStorage()).calcPath(0, 0);
         assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
     }
 
     @Test
-    public void testViaEdges_FromEqualsTo()
-    {
+    public void testViaEdges_FromEqualsTo() {
         GraphHopperStorage ghStorage = createTestStorage();
         // identical tower nodes
         Path p = calcPathViaQuery(ghStorage, 0.001, 0.000, 0.001, 0.000);
@@ -550,12 +573,11 @@ public void testViaEdges_FromEqualsTo()
     }
 
     @Test
-    public void testViaEdges_BiGraph()
-    {
+    public void testViaEdges_BiGraph() {
         GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
-        // 0-7 to 4-3        
+        // 0-7 to 4-3
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
         assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
@@ -567,8 +589,7 @@ public void testViaEdges_BiGraph()
     }
 
     @Test
-    public void testViaEdges_WithCoordinates()
-    {
+    public void testViaEdges_WithCoordinates() {
         GraphHopperStorage ghStorage = createTestStorage();
         Path p = calcPath(ghStorage, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
@@ -576,8 +597,7 @@ public void testViaEdges_WithCoordinates()
     }
 
     @Test
-    public void testViaEdges_SpecialCases()
-    {
+    public void testViaEdges_SpecialCases() {
         GraphHopperStorage graph = createGHStorage(false);
         // 0->1\
         // |    2
@@ -611,8 +631,7 @@ public void testViaEdges_SpecialCases()
     }
 
     @Test
-    public void testQueryGraphAndFastest()
-    {
+    public void testQueryGraphAndFastest() {
         Weighting weighting = new FastestWeighting(carEncoder);
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
         initDirectedAndDiffSpeed(graph, carEncoder);
@@ -621,29 +640,26 @@ public void testQueryGraphAndFastest()
         assertEquals(602.98, p.getDistance(), 1e-1);
     }
 
-    Path calcPathViaQuery( GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
-    {
+    Path calcPathViaQuery(GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon) {
         return calcPathViaQuery(defaultOpts.getWeighting(), ghStorage, fromLat, fromLon, toLat, toLon);
     }
 
-    Path calcPathViaQuery( Weighting weighting, GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
-    {
+    Path calcPathViaQuery(Weighting weighting, GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon) {
         LocationIndex index = new LocationIndexTree(ghStorage, new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
 
         // correct order for CH: in factory do prepare and afterwards wrap in query graph
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).build();
+        AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).build();
         RoutingAlgorithmFactory factory = createFactory(ghStorage, opts);
         QueryGraph qGraph = new QueryGraph(getGraph(ghStorage, weighting)).lookup(from, to);
         return factory.createAlgo(qGraph, opts).
                 calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
-    Path calcPath( GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int toNode1, int toNode2 )
-    {
-        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2                
+    Path calcPath(GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int toNode1, int toNode2) {
+        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2
         QueryResult from = newQR(ghStorage, fromNode1, fromNode2);
         QueryResult to = newQR(ghStorage, toNode1, toNode2);
 
@@ -655,8 +671,7 @@ Path calcPath( GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int t
     /**
      * Creates query result on edge (node1-node2) very close to node1.
      */
-    QueryResult newQR( Graph graph, int node1, int node2 )
-    {
+    QueryResult newQR(Graph graph, int node1, int node2) {
         EdgeIteratorState edge = GHUtility.getEdge(graph, node1, node2);
         if (edge == null)
             throw new IllegalStateException("edge not found? " + node1 + "-" + node2);
@@ -677,19 +692,17 @@ QueryResult newQR( Graph graph, int node1, int node2 )
     }
 
     @Test
-    public void testTwoWeightsPerEdge()
-    {
+    public void testTwoWeightsPerEdge() {
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
         EncodingManager em = new EncodingManager(encoder);
-        AlgorithmOptions opts = AlgorithmOptions.start().
-                flagEncoder(encoder).
+        AlgorithmOptions opts = AlgorithmOptions.start().                
                 weighting(new FastestWeighting(encoder)).build();
         GraphHopperStorage graph = createGHStorage(em, Arrays.asList(opts.getWeighting()), true);
         initEleGraph(graph);
         // force the other path
         GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
 
-        // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
+        // for two weights per edge it happened that Path (and also the Weighting) read the wrong side
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
         Path p = createAlgo(graph, opts).
                 calcPath(0, 10);
@@ -699,8 +712,7 @@ public void testTwoWeightsPerEdge()
     }
 
     @Test
-    public void test0SpeedButUnblocked_Issue242()
-    {
+    public void test0SpeedButUnblocked_Issue242() {
         GraphHopperStorage graph = createGHStorage(false);
         long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
 
@@ -708,41 +720,33 @@ public void test0SpeedButUnblocked_Issue242()
         graph.edge(1, 2).setFlags(flags).setDistance(10);
 
         RoutingAlgorithm algo = createAlgo(graph);
-        try
-        {
+        try {
             Path p = algo.calcPath(0, 2);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
         }
     }
 
     @Test
-    public void testTwoWeightsPerEdge2()
-    {
+    public void testTwoWeightsPerEdge2() {
         // other direction should be different!
-        Weighting fakeWeighting = new Weighting()
-        {
+        Weighting fakeWeighting = new Weighting() {
             @Override
-            public FlagEncoder getFlagEncoder()
-            {
+            public FlagEncoder getFlagEncoder() {
                 return carEncoder;
             }
 
             @Override
-            public double getMinWeight( double distance )
-            {
+            public double getMinWeight(double distance) {
                 return 0.8 * distance;
             }
 
             @Override
-            public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-            {
+            public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
                 int adj = edgeState.getAdjNode();
                 int base = edgeState.getBaseNode();
-                if (reverse)
-                {
+                if (reverse) {
                     int tmp = base;
                     base = adj;
                     adj = tmp;
@@ -759,27 +763,32 @@ else if (adj == 4)
                 return edgeState.getDistance() * 0.8;
             }
 
+            private final Weighting tmpW = new FastestWeighting(carEncoder);
+
             @Override
-            public boolean matches( HintsMap map )
-            {
+            public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+                return tmpW.calcMillis(edgeState, reverse, prevOrNextEdgeId);
+            }
+
+            @Override
+            public boolean matches(HintsMap map) {
                 throw new UnsupportedOperationException("Not supported");
             }
 
             @Override
-            public String getName()
-            {
+            public String getName() {
                 return "custom";
             }
         };
 
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(defaultOpts.getWeighting()).build();
+        AlgorithmOptions opts = AlgorithmOptions.start().weighting(defaultOpts.getWeighting()).build();
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), true);
         initEleGraph(graph);
         Path p = createAlgo(graph, opts).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
         assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
 
-        AlgorithmOptions fakeOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        AlgorithmOptions fakeOpts = AlgorithmOptions.start().weighting(fakeWeighting).build();
         graph = createGHStorage(encodingManager, Arrays.asList(fakeOpts.getWeighting()), true);
         initEleGraph(graph);
         QueryResult from = newQR(graph, 3, 0);
@@ -795,14 +804,13 @@ public String getName()
     }
 
     @Test
-    public void testMultipleVehicles_issue548()
-    {
+    public void testMultipleVehicles_issue548() {
         FastestWeighting footWeighting = new FastestWeighting(footEncoder);
-        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+        AlgorithmOptions footOptions = AlgorithmOptions.start().
                 weighting(footWeighting).build();
 
         FastestWeighting carWeighting = new FastestWeighting(carEncoder);
-        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+        AlgorithmOptions carOptions = AlgorithmOptions.start().
                 weighting(carWeighting).build();
 
         GraphHopperStorage ghStorage = createGHStorage(encodingManager,
@@ -829,8 +837,7 @@ public void testMultipleVehicles_issue548()
     // 5-6-7
     // | |\|
     // 8-9-10
-    Graph initEleGraph( Graph g )
-    {
+    Graph initEleGraph(Graph g) {
         g.edge(0, 1, 10, true);
         g.edge(0, 4, 12, true);
         g.edge(0, 3, 5, true);
@@ -865,71 +872,7 @@ Graph initEleGraph( Graph g )
         return g;
     }
 
-    protected GraphHopperStorage createMatrixGraph()
-    {
+    protected GraphHopperStorage createMatrixGraph() {
         return createMatrixAlikeGraph(createGHStorage(false));
     }
-
-    protected static GraphHopperStorage createMatrixAlikeGraph( GraphHopperStorage tmpGraph )
-    {
-        int WIDTH = 10;
-        int HEIGHT = 15;
-        int[][] matrix = new int[WIDTH][HEIGHT];
-        int counter = 0;
-        Random rand = new Random(12);
-        boolean print = false;
-        for (int h = 0; h < HEIGHT; h++)
-        {
-            if (print)
-            {
-                for (int w = 0; w < WIDTH; w++)
-                {
-                    System.out.print(" |\t           ");
-                }
-                System.out.println();
-            }
-
-            for (int w = 0; w < WIDTH; w++)
-            {
-                matrix[w][h] = counter++;
-                if (h > 0)
-                {
-                    float dist = 5 + Math.abs(rand.nextInt(5));
-                    if (print)
-                        System.out.print(" " + (int) dist + "\t           ");
-
-                    tmpGraph.edge(matrix[w][h], matrix[w][h - 1], dist, true);
-                }
-            }
-            if (print)
-            {
-                System.out.println();
-                if (h > 0)
-                {
-                    for (int w = 0; w < WIDTH; w++)
-                    {
-                        System.out.print(" |\t           ");
-                    }
-                    System.out.println();
-                }
-            }
-
-            for (int w = 0; w < WIDTH; w++)
-            {
-                if (w > 0)
-                {
-                    float dist = 5 + Math.abs(rand.nextInt(5));
-                    if (print)
-                        System.out.print("-- " + (int) dist + "\t-- ");
-                    tmpGraph.edge(matrix[w][h], matrix[w - 1][h], dist, true);
-                }
-                if (print)
-                    System.out.print("(" + matrix[w][h] + ")\t");
-            }
-            if (print)
-                System.out.println();
-        }
-
-        return tmpGraph;
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
index a54709b335..93e69af915 100755
--- a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
@@ -17,61 +17,51 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.AlternativeRoute.AlternativeBidirSearch;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.Helper;
-
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.List;
 
 import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
-import com.graphhopper.routing.AlternativeRoute.AlternativeBidirSearch;
-import com.graphhopper.storage.*;
-import java.util.Arrays;
-import java.util.Collection;
 import static org.junit.Assert.*;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-public class AlternativeRouteTest
-{
+public class AlternativeRouteTest {
     private final FlagEncoder carFE = new CarFlagEncoder();
     private final EncodingManager em = new EncodingManager(carFE);
     private final TraversalMode traversalMode;
 
+    public AlternativeRouteTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameterized.Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-        {
-            {
-                TraversalMode.NODE_BASED
-            },
-            {
-                TraversalMode.EDGE_BASED_2DIR
-            }
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {TraversalMode.NODE_BASED},
+            {TraversalMode.EDGE_BASED_2DIR}
         });
     }
 
-    public AlternativeRouteTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
-    }
-
-    public GraphHopperStorage createTestGraph( boolean fullGraph, EncodingManager tmpEM )
-    {
+    public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmpEM) {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, new GraphExtension.NoOpExtension());
         graph.create(1000);
 
@@ -114,18 +104,17 @@ public GraphHopperStorage createTestGraph( boolean fullGraph, EncodingManager tm
     }
 
     @Test
-    public void testCalcAlternatives() throws Exception
-    {
+    public void testCalcAlternatives() throws Exception {
         Weighting weighting = new FastestWeighting(carFE);
         GraphHopperStorage g = createTestGraph(true, em);
-        AlternativeRoute altDijkstra = new AlternativeRoute(g, carFE, weighting, traversalMode);
+        AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxShareFactor(0.5);
         altDijkstra.setMaxWeightFactor(2);
         List<AlternativeRoute.AlternativeInfo> pathInfos = altDijkstra.calcAlternatives(5, 4);
         checkAlternatives(pathInfos);
         assertEquals(2, pathInfos.size());
 
-        DijkstraBidirectionRef dijkstra = new DijkstraBidirectionRef(g, carFE, weighting, traversalMode);
+        DijkstraBidirectionRef dijkstra = new DijkstraBidirectionRef(g, weighting, traversalMode);
         Path bestPath = dijkstra.calcPath(5, 4);
 
         Path bestAlt = pathInfos.get(0).getPath();
@@ -144,11 +133,10 @@ public void testCalcAlternatives() throws Exception
     }
 
     @Test
-    public void testCalcAlternatives2() throws Exception
-    {
+    public void testCalcAlternatives2() throws Exception {
         Weighting weighting = new FastestWeighting(carFE);
         Graph g = createTestGraph(true, em);
-        AlternativeRoute altDijkstra = new AlternativeRoute(g, carFE, weighting, traversalMode);
+        AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxPaths(3);
         altDijkstra.setMaxShareFactor(0.7);
         altDijkstra.setMinPlateauFactor(0.15);
@@ -167,12 +155,10 @@ public void testCalcAlternatives2() throws Exception
         assertEquals(2416.0, pathInfos.get(2).getPath().getWeight(), .1);
     }
 
-    void checkAlternatives( List<AlternativeRoute.AlternativeInfo> alternativeInfos )
-    {
+    void checkAlternatives(List<AlternativeRoute.AlternativeInfo> alternativeInfos) {
         assertFalse("alternativeInfos should contain alternatives", alternativeInfos.isEmpty());
         AlternativeRoute.AlternativeInfo bestInfo = alternativeInfos.get(0);
-        for (int i = 1; i < alternativeInfos.size(); i++)
-        {
+        for (int i = 1; i < alternativeInfos.size(); i++) {
             AlternativeRoute.AlternativeInfo a = alternativeInfos.get(i);
             if (a.getPath().getWeight() < bestInfo.getPath().getWeight())
                 assertTrue("alternative is not longer -> " + a + " vs " + bestInfo, false);
@@ -184,15 +170,14 @@ void checkAlternatives( List<AlternativeRoute.AlternativeInfo> alternativeInfos
     }
 
     @Test
-    public void testDisconnectedAreas()
-    {
+    public void testDisconnectedAreas() {
         Graph g = createTestGraph(true, em);
 
         // one single disconnected node
         updateDistancesFor(g, 20, 0.00, -0.01);
 
         Weighting weighting = new FastestWeighting(carFE);
-        AlternativeBidirSearch altDijkstra = new AlternativeBidirSearch(g, carFE, weighting, traversalMode, 1);
+        AlternativeBidirSearch altDijkstra = new AlternativeBidirSearch(g, weighting, traversalMode, 1);
         Path path = altDijkstra.calcPath(1, 20);
         assertFalse(path.isFound());
 
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index e5681782c2..34ff8c1bdb 100755
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -17,55 +17,46 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-
-import java.util.Arrays;
-import java.util.Collection;
-
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
+import java.util.Arrays;
+import java.util.Collection;
 
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class DijkstraBidirectionRefTest extends AbstractRoutingAlgorithmTester
-{
+public class DijkstraBidirectionRefTest extends AbstractRoutingAlgorithmTester {
+    private final TraversalMode traversalMode;
+
+    public DijkstraBidirectionRefTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-                {
-                        {TraversalMode.NODE_BASED},
-                        {TraversalMode.EDGE_BASED_1DIR},
-                        {TraversalMode.EDGE_BASED_2DIR},
-                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
-                });
-    }
-
-    private final TraversalMode traversalMode;
-
-    public DijkstraBidirectionRefTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {TraversalMode.NODE_BASED},
+            {TraversalMode.EDGE_BASED_1DIR},
+            {TraversalMode.EDGE_BASED_2DIR},
+            {TraversalMode.EDGE_BASED_2DIR_UTURN}
+        });
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
-    {
-        return new RoutingAlgorithmFactory()
-        {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+        return new RoutingAlgorithmFactory() {
             @Override
-            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-            {
-                return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
+            public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+                return new DijkstraBidirectionRef(g, opts.getWeighting(), traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 8a4d236d99..be52e4a04a 100755
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -17,105 +17,115 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
-
-import java.util.Arrays;
-import java.util.Collection;
-
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
+import java.util.Arrays;
+import java.util.Collection;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class DijkstraOneToManyTest extends AbstractRoutingAlgorithmTester
-{
+public class DijkstraOneToManyTest extends AbstractRoutingAlgorithmTester {
+    private final TraversalMode traversalMode;
+
+    public DijkstraOneToManyTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-        {
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
             {
                 TraversalMode.NODE_BASED
-            },
-//            TODO { TraversalMode.EDGE_BASED_1DIR },
-//            TODO { TraversalMode.EDGE_BASED_2DIR },
-//            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
+            }, //            TODO { TraversalMode.EDGE_BASED_1DIR },
+        //            TODO { TraversalMode.EDGE_BASED_2DIR },
+        //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
         });
     }
 
-    private final TraversalMode traversalMode;
+    public static Graph initGraphWeightLimit(Graph g) {
+        //      0----1
+        //     /     |
+        //    7--    |
+        //   /   |   |
+        //   6---5   |
+        //   |   |   |
+        //   4---3---2
 
-    public DijkstraOneToManyTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+
+        g.edge(3, 2, 1, true);
+        g.edge(3, 5, 1, true);
+        g.edge(5, 7, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(4, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        g.edge(6, 5, 1, true);
+        g.edge(0, 7, 1, true);
+        return g;
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
-    {
-        return new RoutingAlgorithmFactory()
-        {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+        return new RoutingAlgorithmFactory() {
             @Override
-            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-            {
-                return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
+            public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+                return new DijkstraOneToMany(g, opts.getWeighting(), traversalMode);
             }
         };
     }
 
     @Override
-    public void testViaEdges_BiGraph()
-    {
+    public void testViaEdges_BiGraph() {
         // calcPath with QueryResult not supported
     }
 
     @Override
-    public void testViaEdges_SpecialCases()
-    {
+    public void testViaEdges_SpecialCases() {
         // calcPath with QueryResult not supported
     }
 
     @Override
-    public void testViaEdges_FromEqualsTo()
-    {
+    public void testViaEdges_FromEqualsTo() {
         // calcPath with QueryResult not supported
     }
 
     @Override
-    public void testViaEdges_WithCoordinates()
-    {
+    public void testViaEdges_WithCoordinates() {
         // calcPath with QueryResult not supported
     }
 
     @Override
-    public void testQueryGraphAndFastest()
-    {
+    public void testQueryGraphAndFastest() {
         // calcPath with QueryResult not supported
     }
 
     @Override
-    public void testTwoWeightsPerEdge2()
-    {
+    public void testTwoWeightsPerEdge2() {
         // calcPath with QueryResult not supported
     }
 
     @Test
-    public void testIssue182()
-    {
+    public void testIssue182() {
         GraphHopperStorage storage = createGHStorage(false);
         initGraph(storage);
         RoutingAlgorithm algo = createAlgo(storage);
@@ -128,8 +138,7 @@ public void testIssue182()
     }
 
     @Test
-    public void testIssue239_and362()
-    {
+    public void testIssue239_and362() {
         GraphHopperStorage g = createGHStorage(false);
         g.edge(0, 1, 1, true);
         g.edge(1, 2, 1, true);
@@ -148,8 +157,7 @@ public void testIssue239_and362()
     }
 
     @Test
-    public void testUseCache()
-    {
+    public void testUseCache() {
         RoutingAlgorithm algo = createAlgo(createTestStorage());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
@@ -164,8 +172,7 @@ public void testUseCache()
     }
 
     @Test
-    public void testDifferentEdgeFilter()
-    {
+    public void testDifferentEdgeFilter() {
         GraphHopperStorage g = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
         g.edge(4, 3, 10, true);
         g.edge(3, 6, 10, true);
@@ -174,11 +181,9 @@ public void testDifferentEdgeFilter()
         g.edge(5, 6, 10, true);
 
         DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
-        algo.setEdgeFilter(new EdgeFilter()
-        {
+        algo.setEdgeFilter(new EdgeFilter() {
             @Override
-            public boolean accept( EdgeIteratorState iter )
-            {
+            public boolean accept(EdgeIteratorState iter) {
                 return iter.getAdjNode() != 5;
             }
         });
@@ -187,11 +192,9 @@ public boolean accept( EdgeIteratorState iter )
 
         // important call!
         algo.clear();
-        algo.setEdgeFilter(new EdgeFilter()
-        {
+        algo.setEdgeFilter(new EdgeFilter() {
             @Override
-            public boolean accept( EdgeIteratorState iter )
-            {
+            public boolean accept(EdgeIteratorState iter) {
                 return iter.getAdjNode() != 3;
             }
         });
@@ -199,8 +202,7 @@ public boolean accept( EdgeIteratorState iter )
         assertEquals(Helper.createTList(4, 5, 6), p.calcNodes());
     }
 
-    private Graph initGraph( Graph g )
-    {
+    private Graph initGraph(Graph g) {
         // 0-1-2-3-4
         // |       /
         // 7-10----
@@ -218,8 +220,7 @@ private Graph initGraph( Graph g )
     }
 
     @Test
-    public void testWeightLimit_issue380()
-    {
+    public void testWeightLimit_issue380() {
         GraphHopperStorage graph = createGHStorage(false);
         initGraphWeightLimit(graph);
 
@@ -236,8 +237,7 @@ public void testWeightLimit_issue380()
     }
 
     @Test
-    public void testUseCacheZeroPath_issue707()
-    {
+    public void testUseCacheZeroPath_issue707() {
         RoutingAlgorithm algo = createAlgo(createTestStorage());
 
         Path p = algo.calcPath(0, 0);
@@ -255,28 +255,4 @@ public void testUseCacheZeroPath_issue707()
         assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
     }
 
-    public static Graph initGraphWeightLimit( Graph g )
-    {
-        //      0----1
-        //     /     |
-        //    7--    |
-        //   /   |   |
-        //   6---5   |
-        //   |   |   |
-        //   4---3---2
-
-        g.edge(0, 1, 1, true);
-        g.edge(1, 2, 1, true);
-
-        g.edge(3, 2, 1, true);
-        g.edge(3, 5, 1, true);
-        g.edge(5, 7, 1, true);
-        g.edge(3, 4, 1, true);
-        g.edge(4, 6, 1, true);
-        g.edge(6, 7, 1, true);
-        g.edge(6, 5, 1, true);
-        g.edge(0, 7, 1, true);
-        return g;
-    }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 13c070ef5c..40f1b03e45 100755
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -17,55 +17,46 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-
-import java.util.Arrays;
-import java.util.Collection;
-
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
+import java.util.Arrays;
+import java.util.Collection;
 
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class DijkstraTest extends AbstractRoutingAlgorithmTester
-{
+public class DijkstraTest extends AbstractRoutingAlgorithmTester {
+    private final TraversalMode traversalMode;
+
+    public DijkstraTest(TraversalMode tMode) {
+        this.traversalMode = tMode;
+    }
+
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-                {
-                        {TraversalMode.NODE_BASED},
-                        {TraversalMode.EDGE_BASED_1DIR},
-                        {TraversalMode.EDGE_BASED_2DIR},
-                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
-                });
-    }
-
-    private final TraversalMode traversalMode;
-
-    public DijkstraTest( TraversalMode tMode )
-    {
-        this.traversalMode = tMode;
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {TraversalMode.NODE_BASED},
+            {TraversalMode.EDGE_BASED_1DIR},
+            {TraversalMode.EDGE_BASED_2DIR},
+            {TraversalMode.EDGE_BASED_2DIR_UTURN}
+        });
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
-    {
-        return new RoutingAlgorithmFactory()
-        {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+        return new RoutingAlgorithmFactory() {
             @Override
-            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-            {
-                return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
+            public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+                return new Dijkstra(g, opts.getWeighting(), traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 79cdab089e..68f5ea6c46 100755
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -18,69 +18,48 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
-
-import static org.junit.Assert.*;
-import static com.graphhopper.util.GHUtility.*;
-import static com.graphhopper.util.Parameters.Algorithms.*;
-
-import java.util.Arrays;
-import java.util.Collection;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
+import java.util.Arrays;
+import java.util.Collection;
+
+import static com.graphhopper.util.GHUtility.getEdge;
+import static com.graphhopper.util.Parameters.Algorithms.*;
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
-public class EdgeBasedRoutingAlgorithmTest
-{
-    private FlagEncoder carEncoder;
-
-    EncodingManager createEncodingManager( boolean restrictedOnly )
-    {
-        if (restrictedOnly)
-            carEncoder = new CarFlagEncoder(5, 5, 1);
-        else
-            // allow for basic costs too
-            carEncoder = new CarFlagEncoder(5, 5, 3);
-        return new EncodingManager(carEncoder);
-    }
-
-    @Parameters(name = "{0}")
-    public static Collection<Object[]> configs()
-    {
-        return Arrays.asList(new Object[][]
-                {
-                        {DIJKSTRA},
-                        {DIJKSTRA_BI},
-                        {ASTAR},
-                        {ASTAR_BI}
-                        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
-                });
-    }
-
+public class EdgeBasedRoutingAlgorithmTest {
     private final String algoStr;
+    private FlagEncoder carEncoder;
 
-    public EdgeBasedRoutingAlgorithmTest( String algo )
-    {
+    public EdgeBasedRoutingAlgorithmTest(String algo) {
         this.algoStr = algo;
     }
 
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {
-        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
-        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
-    }
-
-    protected GraphHopperStorage createStorage( EncodingManager em )
-    {
-        return new GraphBuilder(em).create();
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs() {
+        return Arrays.asList(new Object[][]{
+            {DIJKSTRA},
+            {DIJKSTRA_BI},
+            {ASTAR},
+            {ASTAR_BI}
+        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+        });
     }
 
     // 0---1
@@ -88,8 +67,7 @@ protected GraphHopperStorage createStorage( EncodingManager em )
     // 2--3--4
     // |  |  |
     // 5--6--7
-    public static void initGraph( Graph g )
-    {
+    public static void initGraph(Graph g) {
         g.edge(0, 1, 3, true);
         g.edge(0, 2, 1, true);
         g.edge(1, 3, 1, true);
@@ -102,8 +80,25 @@ public static void initGraph( Graph g )
         g.edge(6, 7, 1, true);
     }
 
-    private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder )
-    {
+    EncodingManager createEncodingManager(boolean restrictedOnly) {
+        if (restrictedOnly)
+            carEncoder = new CarFlagEncoder(5, 5, 1);
+        else
+            // allow for basic costs too
+            carEncoder = new CarFlagEncoder(5, 5, 3);
+        return new EncodingManager(carEncoder);
+    }
+
+    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
+        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
+        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
+    }
+
+    protected GraphHopperStorage createStorage(EncodingManager em) {
+        return new GraphBuilder(em).create();
+    }
+
+    private void initTurnRestrictions(Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder) {
         long tflags = tEncoder.getTurnFlags(true, 0);
 
         // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
@@ -130,20 +125,17 @@ private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncod
         tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
     }
 
-    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
-    {
-        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
+    Weighting createWeighting(FlagEncoder encoder, TurnCostExtension tcs, double turnCosts) {
+        return new TurnWeighting(new FastestWeighting(encoder), tcs).setDefaultUTurnCost(turnCosts);
     }
 
     @Test
-    public void testBasicTurnRestriction()
-    {
+    public void testBasicTurnRestriction() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
         Path p = createAlgo(g, AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
@@ -151,14 +143,12 @@ public void testBasicTurnRestriction()
 
         // test 7-6-5 and reverse
         p = createAlgo(g, AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 7);
         assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
 
         p = createAlgo(g, AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(7, 5);
@@ -166,8 +156,7 @@ public void testBasicTurnRestriction()
     }
 
     @Test
-    public void testUTurns()
-    {
+    public void testUTurns() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
@@ -183,7 +172,6 @@ public void testUTurns()
         tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
         tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
         AlgorithmOptions opts = AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 50)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         Path p = createAlgo(g, opts).calcPath(7, 5);
@@ -192,7 +180,6 @@ public void testUTurns()
 
         // no u-turn for 6-3
         opts = AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 100)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
@@ -202,13 +189,11 @@ public void testUTurns()
     }
 
     @Test
-    public void testBasicTurnCosts()
-    {
+    public void testBasicTurnCosts() {
         GraphHopperStorage g = createStorage(createEncodingManager(false));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         Path p = createAlgo(g, AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
@@ -223,7 +208,6 @@ public void testBasicTurnCosts()
         tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
 
         p = createAlgo(g, AlgorithmOptions.start().
-                flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 8043a220fb..d465ac43e9 100755
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -17,38 +17,38 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
-
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
-public class PathBidirRefTest
-{
+public class PathBidirRefTest {
     private final EncodingManager encodingManager = new EncodingManager("car");
     private FlagEncoder carEncoder = encodingManager.getEncoder("car");
     private EdgeFilter carOutEdges = new DefaultEdgeFilter(carEncoder, false, true);
 
-    Graph createGraph()
-    {
+    Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
     }
 
     @Test
-    public void testExtract()
-    {
+    public void testExtract() {
         Graph g = createGraph();
         g.edge(1, 2, 10, true);
-        PathBidirRef pw = new PathBidirRef(g, carEncoder);
+        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
         EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
         EdgeIterator iter = explorer.setBaseNode(1);
         iter.next();
@@ -61,15 +61,14 @@ public void testExtract()
     }
 
     @Test
-    public void testExtract2()
-    {
+    public void testExtract2() {
         Graph g = createGraph();
         g.edge(1, 2, 10, false);
         g.edge(2, 3, 20, false);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
         EdgeIterator iter = explorer.setBaseNode(1);
         iter.next();
-        PathBidirRef pw = new PathBidirRef(g, carEncoder);
+        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
         pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 10);
         pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
 
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 596868774e..867ff9b720 100755
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -18,28 +18,21 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.Helper;
-
-import static com.graphhopper.storage.AbstractGraphStorageTester.*;
-
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.*;
+import org.junit.Test;
 
 import java.util.*;
 
-import org.junit.Test;
-
+import static com.graphhopper.storage.AbstractGraphStorageTester.assertPList;
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class PathTest
-{
+public class PathTest {
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
     private final EncodingManager mixedEncoders = new EncodingManager(new CarFlagEncoder());
@@ -48,10 +41,9 @@
     private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
 
     @Test
-    public void testFound()
-    {
+    public void testFound() {
         GraphHopperStorage g = new GraphBuilder(carManager).create();
-        Path p = new Path(g, encoder);
+        Path p = new Path(g, new FastestWeighting(encoder));
         assertFalse(p.isFound());
         assertEquals(0, p.getDistance(), 1e-7);
         assertEquals(0, p.calcNodes().size());
@@ -59,21 +51,21 @@ public void testFound()
     }
 
     @Test
-    public void testTime()
-    {
+    public void testTime() {
         FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
         GraphHopperStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
-        Path p = new Path(g, tmpEnc);
+        Path p = new Path(g, new FastestWeighting(tmpEnc));
         long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
-        assertEquals(375 * 60 * 1000, p.calcMillis(100000, flags, false));
-        assertEquals(600 * 60 * 1000, p.calcMillis(100000, flags, true));
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(100000, flags);
+                
+        assertEquals(375 * 60 * 1000, p.calcMillis(edge, false));
+        assertEquals(600 * 60 * 1000, p.calcMillis(edge, true));
 
         g.close();
     }
 
     @Test
-    public void testWayList()
-    {
+    public void testWayList() {
         GraphHopperStorage g = new GraphBuilder(carManager).create();
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0.0, 0.1);
@@ -85,7 +77,7 @@ public void testWayList()
         EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).setFlags(encoder.setProperties(50, true, true));
         edge2.setWayGeometry(Helper.createPointList(11, 1, 10, 1));
 
-        Path path = new Path(g, encoder);
+        Path path = new Path(g, new FastestWeighting(encoder));
         SPTEntry e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
@@ -111,7 +103,7 @@ public void testWayList()
 
         // force minor change for instructions
         edge2.setName("2");
-        path = new Path(g, encoder);
+        path = new Path(g, new FastestWeighting(encoder));
         e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
@@ -135,7 +127,7 @@ public void testWayList()
         assertEquals(path.calcPoints().size() - 1, lastIndex);
 
         // now reverse order
-        path = new Path(g, encoder);
+        path = new Path(g, new FastestWeighting(encoder));
         e1 = new SPTEntry(edge1.getEdge(), 0, 1);
         e1.parent = new SPTEntry(edge2.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 2, 1);
@@ -162,8 +154,7 @@ public void testWayList()
     }
 
     @Test
-    public void testFindInstruction()
-    {
+    public void testFindInstruction() {
         Graph g = new GraphBuilder(carManager).create();
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0.0, 0.0);
@@ -185,7 +176,7 @@ public void testFindInstruction()
         edge4.setWayGeometry(Helper.createPointList());
         edge4.setName("Street 4");
 
-        Path path = new Path(g, encoder);
+        Path path = new Path(g, new FastestWeighting(encoder));
         SPTEntry e1 = new SPTEntry(edge4.getEdge(), 4, 1);
         e1.parent = new SPTEntry(edge3.getEdge(), 3, 1);
         e1.parent.parent = new SPTEntry(edge2.getEdge(), 2, 1);
@@ -215,107 +206,13 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
-    private class RoundaboutGraph
-    {
-        private final EdgeIteratorState edge3to6, edge3to9;
-        boolean clockwise = false;
-        final public Graph g = new GraphBuilder(mixedEncoders).create();
-        final public NodeAccess na = g.getNodeAccess();
-        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
-
-        private RoundaboutGraph()
-        {
-            //                          
-            //      8
-            //       \
-            //         5
-            //       /  \
-            //  1 - 2    4 - 7
-            //       \  /
-            //        3
-            //        | \
-            //        6 [ 9 ] edge 9 is turned off in default mode 
-
-            na.setNode(1, 52.514, 13.348);
-            na.setNode(2, 52.514, 13.349);
-            na.setNode(3, 52.5135, 13.35);
-            na.setNode(4, 52.514, 13.351);
-            na.setNode(5, 52.5145, 13.351);
-            na.setNode(6, 52.513, 13.35);
-            na.setNode(7, 52.514, 13.352);
-            na.setNode(8, 52.515, 13.351);
-            na.setNode(9, 52.513, 13.351);
-
-            g.edge(1, 2, 5, true).setName("MainStreet 1 2");
-
-            // roundabout            
-            roundaboutEdges.add(g.edge(3, 2, 5, false).setName("2-3"));
-            roundaboutEdges.add(g.edge(4, 3, 5, false).setName("3-4"));
-            roundaboutEdges.add(g.edge(5, 4, 5, false).setName("4-5"));
-            roundaboutEdges.add(g.edge(2, 5, 5, false).setName("5-2"));
-
-            g.edge(4, 7, 5, true).setName("MainStreet 4 7");
-            g.edge(5, 8, 5, true).setName("5-8");
-
-            edge3to6 = g.edge(3, 6, 5, true).setName("3-6");
-            edge3to9 = g.edge(3, 9, 5, false).setName("3-9");
-
-            setRoundabout(clockwise);
-            inverse3to9();
-
-        }
-
-        public void setRoundabout( boolean clockwise )
-        {
-            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
-            {
-                for (EdgeIteratorState edge : roundaboutEdges)
-                {
-                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
-                    edge.setFlags(encoder.setBool(edge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-                }
-            }
-            this.clockwise = clockwise;
-        }
-
-        public void inverse3to9()
-        {
-            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
-            {
-                long flags = edge3to9.getFlags();
-                edge3to9.setFlags(encoder.setAccess(flags, !edge3to9.isForward(encoder), false));
-            }
-        }
-
-        public void inverse3to6()
-        {
-            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
-            {
-                long flags = edge3to6.getFlags();
-                edge3to6.setFlags(encoder.setAccess(flags, !edge3to6.isForward(encoder), true));
-            }
-        }
-
-        private double getAngle( int n1, int n2, int n3, int n4 )
-        {
-            double inOrientation = Helper.ANGLE_CALC.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
-            double outOrientation = Helper.ANGLE_CALC.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
-            outOrientation = Helper.ANGLE_CALC.alignOrientation(inOrientation, outOrientation);
-            double delta = (inOrientation - outOrientation);
-            delta = clockwise ? (Math.PI + delta) : -1 * (Math.PI - delta);
-            return delta;
-        }
-    }
-
     /**
      * Test roundabout instructions for different profiles
      */
     @Test
-    public void testCalcInstructionsRoundabout()
-    {
-        for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
-        {
-            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+    public void testCalcInstructionsRoundabout() {
+        for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
+            Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                     .calcPath(1, 8);
             assertTrue(p.isFound());
             InstructionList wayList = p.calcInstructions(tr);
@@ -331,7 +228,7 @@ public void testCalcInstructionsRoundabout()
             assertEquals(delta, instr.getTurnAngle(), 0.01);
 
             // case of continuing a street through a roundabout
-            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
+            p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
                     calcPath(1, 7);
             wayList = p.calcInstructions(tr);
             tmpList = pick("text", wayList.createJson());
@@ -350,9 +247,8 @@ public void testCalcInstructionsRoundabout()
      * case starting in Roundabout
      */
     @Test
-    public void testCalcInstructionsRoundaboutBegin()
-    {
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+    public void testCalcInstructionsRoundaboutBegin() {
+        Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(2, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
@@ -366,10 +262,9 @@ public void testCalcInstructionsRoundaboutBegin()
      * case with one node being containig already exit
      */
     @Test
-    public void testCalcInstructionsRoundaboutDirectExit()
-    {
+    public void testCalcInstructionsRoundaboutDirectExit() {
         roundaboutGraph.inverse3to9();
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
@@ -385,10 +280,9 @@ public void testCalcInstructionsRoundaboutDirectExit()
      * case with one edge being not an exit
      */
     @Test
-    public void testCalcInstructionsRoundabout2()
-    {
+    public void testCalcInstructionsRoundabout2() {
         roundaboutGraph.inverse3to6();
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
@@ -405,8 +299,7 @@ public void testCalcInstructionsRoundabout2()
     }
 
     @Test
-    public void testCalcInstructionsRoundaboutIssue353()
-    {
+    public void testCalcInstructionsRoundaboutIssue353() {
         final Graph g = new GraphBuilder(carManager).create();
         final NodeAccess na = g.getNodeAccess();
 
@@ -428,14 +321,14 @@ public void testCalcInstructionsRoundaboutIssue353()
         na.setNode(6, 52.513, 13.35);
         na.setNode(7, 52.514, 13.352);
         na.setNode(8, 52.515, 13.351);
-        
+
         na.setNode(9, 52.5135, 13.349);
         na.setNode(10, 52.5135, 13.348);
         na.setNode(11, 52.514, 13.347);
-        
+
         g.edge(2, 1, 5, false).setName("MainStreet 2 1");
         g.edge(1, 11, 5, false).setName("MainStreet 1 11");
-        
+
         // roundabout
         EdgeIteratorState tmpEdge;
         tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
@@ -459,7 +352,7 @@ public void testCalcInstructionsRoundaboutIssue353()
         g.edge(5, 8, 5, true).setName("5-8");
         g.edge(3, 6, 5, true).setName("3-6");
 
-        Path p = new Dijkstra(g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 11);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
@@ -473,10 +366,9 @@ public void testCalcInstructionsRoundaboutIssue353()
      * clockwise roundabout
      */
     @Test
-    public void testCalcInstructionsRoundaboutClockwise()
-    {
+    public void testCalcInstructionsRoundaboutClockwise() {
         roundaboutGraph.setRoundabout(true);
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
@@ -491,15 +383,95 @@ public void testCalcInstructionsRoundaboutClockwise()
         assertEquals(delta, instr.getTurnAngle(), 0.01);
     }
 
-    List<String> pick( String key, List<Map<String, Object>> instructionJson )
-    {
+    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
         List<String> list = new ArrayList<String>();
 
-        for (Map<String, Object> json : instructionJson)
-        {
+        for (Map<String, Object> json : instructionJson) {
             list.add(json.get(key).toString());
         }
         return list;
     }
 
+    private class RoundaboutGraph {
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
+        final public NodeAccess na = g.getNodeAccess();
+        private final EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
+
+        private RoundaboutGraph() {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135, 13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145, 13.351);
+            na.setNode(6, 52.513, 13.35);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+            na.setNode(9, 52.513, 13.351);
+
+            g.edge(1, 2, 5, true).setName("MainStreet 1 2");
+
+            // roundabout
+            roundaboutEdges.add(g.edge(3, 2, 5, false).setName("2-3"));
+            roundaboutEdges.add(g.edge(4, 3, 5, false).setName("3-4"));
+            roundaboutEdges.add(g.edge(5, 4, 5, false).setName("4-5"));
+            roundaboutEdges.add(g.edge(2, 5, 5, false).setName("5-2"));
+
+            g.edge(4, 7, 5, true).setName("MainStreet 4 7");
+            g.edge(5, 8, 5, true).setName("5-8");
+
+            edge3to6 = g.edge(3, 6, 5, true).setName("3-6");
+            edge3to9 = g.edge(3, 9, 5, false).setName("3-9");
+
+            setRoundabout(clockwise);
+            inverse3to9();
+
+        }
+
+        public void setRoundabout(boolean clockwise) {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
+                for (EdgeIteratorState edge : roundaboutEdges) {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+                }
+            }
+            this.clockwise = clockwise;
+        }
+
+        public void inverse3to9() {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !edge3to9.isForward(encoder), false));
+            }
+        }
+
+        public void inverse3to6() {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !edge3to6.isForward(encoder), true));
+            }
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4) {
+            double inOrientation = Helper.ANGLE_CALC.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = Helper.ANGLE_CALC.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = Helper.ANGLE_CALC.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise ? (Math.PI + delta) : -1 * (Math.PI - delta);
+            return delta;
+        }
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index 15dfec8660..04a698640b 100755
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -18,50 +18,43 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
-
-import static com.graphhopper.storage.index.QueryResult.Position.*;
-
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TIntObjectMap;
-
-import java.util.Arrays;
-import java.util.Collections;
-
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.util.Arrays;
 
-import org.junit.Before;
+import static com.graphhopper.storage.index.QueryResult.Position.*;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class QueryGraphTest
-{
+public class QueryGraphTest {
     private EncodingManager encodingManager;
     private FlagEncoder carEncoder;
     private GraphHopperStorage g;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         carEncoder = new CarFlagEncoder();
         encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false, new GraphExtension.NoOpExtension()).create(100);
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         g.close();
     }
 
-    void initGraph( Graph g )
-    {
+    void initGraph(Graph g) {
         //
         //  /*-*\
         // 0     1
@@ -76,8 +69,7 @@ void initGraph( Graph g )
     }
 
     @Test
-    public void testOneVirtualNode()
-    {
+    public void testOneVirtualNode() {
         initGraph(g);
         EdgeExplorer expl = g.createEdgeExplorer();
 
@@ -148,8 +140,7 @@ public void testOneVirtualNode()
     }
 
     @Test
-    public void testFillVirtualEdges()
-    {
+    public void testFillVirtualEdges() {
         initGraph(g);
         g.getNodeAccess().setNode(3, 0, 1);
         g.edge(1, 3);
@@ -158,12 +149,10 @@ public void testFillVirtualEdges()
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(baseNode);
         iter.next();
         QueryResult res1 = createLocationResult(2, 1.7, iter, 1, PILLAR);
-        QueryGraph queryGraph = new QueryGraph(g)
-        {
+        QueryGraph queryGraph = new QueryGraph(g) {
 
             @Override
-            void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
-            {
+            void fillVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl) {
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
                 if (towerNode == 3)
@@ -184,8 +173,7 @@ else if (towerNode == 1)
     }
 
     @Test
-    public void testMultipleVirtualNodes()
-    {
+    public void testMultipleVirtualNodes() {
         initGraph(g);
 
         // snap to edge which has pillar nodes        
@@ -230,8 +218,7 @@ public void testMultipleVirtualNodes()
     }
 
     @Test
-    public void testOneWay()
-    {
+    public void testOneWay() {
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, 1);
@@ -255,8 +242,7 @@ public void testOneWay()
     }
 
     @Test
-    public void testVirtEdges()
-    {
+    public void testVirtEdges() {
         initGraph(g);
 
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(0);
@@ -269,8 +255,7 @@ public void testVirtEdges()
     }
 
     @Test
-    public void testUseMeanElevation()
-    {
+    public void testUseMeanElevation() {
         g.close();
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension()).create(100);
         NodeAccess na = g.getNodeAccess();
@@ -296,8 +281,7 @@ public void testUseMeanElevation()
     }
 
     @Test
-    public void testLoopStreet_Issue151()
-    {
+    public void testLoopStreet_Issue151() {
         // do query at x should result in ignoring only the bottom edge 1-3 not the upper one => getNeighbors are 0, 5, 3 and not only 0, 5
         //
         // 0--1--3--4
@@ -326,8 +310,7 @@ public void testLoopStreet_Issue151()
     }
 
     @Test
-    public void testOneWayLoop_Issue162()
-    {
+    public void testOneWayLoop_Issue162() {
         // do query at x, where edge is oneway
         //
         // |\
@@ -366,8 +349,7 @@ public void testOneWayLoop_Issue162()
     }
 
     @Test
-    public void testEdgesShareOneNode()
-    {
+    public void testEdgesShareOneNode() {
         initGraph(g);
 
         EdgeIteratorState iter = GHUtility.getEdge(g, 0, 2);
@@ -383,8 +365,7 @@ public void testEdgesShareOneNode()
     }
 
     @Test
-    public void testAvoidDuplicateVirtualNodesIfIdentical()
-    {
+    public void testAvoidDuplicateVirtualNodesIfIdentical() {
         initGraph(g);
 
         EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
@@ -412,8 +393,7 @@ public void testAvoidDuplicateVirtualNodesIfIdentical()
     }
 
     @Test
-    public void testGetEdgeProps()
-    {
+    public void testGetEdgeProps() {
         initGraph(g);
         EdgeIteratorState e1 = GHUtility.getEdge(g, 0, 2);
         QueryGraph queryGraph = new QueryGraph(g);
@@ -425,17 +405,15 @@ public void testGetEdgeProps()
         assertEquals(e1.getEdge(), e2.getEdge());
     }
 
-    PointList getPoints( Graph g, int base, int adj )
-    {
+    PointList getPoints(Graph g, int base, int adj) {
         EdgeIteratorState edge = GHUtility.getEdge(g, base, adj);
         if (edge == null)
             throw new IllegalStateException("edge " + base + "-" + adj + " not found");
         return edge.fetchWayGeometry(3);
     }
 
-    public QueryResult createLocationResult( double lat, double lon,
-                                             EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
-    {
+    public QueryResult createLocationResult(double lat, double lon,
+                                            EdgeIteratorState edge, int wayIndex, QueryResult.Position pos) {
         if (edge == null)
             throw new IllegalStateException("Specify edge != null");
         QueryResult tmp = new QueryResult(lat, lon);
@@ -447,8 +425,7 @@ public QueryResult createLocationResult( double lat, double lon,
     }
 
     @Test
-    public void testIteration_Issue163()
-    {
+    public void testIteration_Issue163() {
         EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("car"), false, true);
         EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("car"), true, false);
         EdgeExplorer inExplorer = g.createEdgeExplorer(inEdgeFilter);
@@ -489,8 +466,7 @@ public void testIteration_Issue163()
         assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeD, nodeB);
     }
 
-    private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer outExplorer, int startNode, int endNode )
-    {
+    private void assertEdgeIdsStayingEqual(EdgeExplorer inExplorer, EdgeExplorer outExplorer, int startNode, int endNode) {
         EdgeIterator it = outExplorer.setBaseNode(startNode);
         it.next();
         assertEquals(startNode, it.getBaseNode());
@@ -509,8 +485,7 @@ private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer ou
     }
 
     @Test
-    public void testTurnCostsProperlyPropagated_Issue282()
-    {
+    public void testTurnCostsProperlyPropagated_Issue282() {
         TurnCostExtension turnExt = new TurnCostExtension();
         FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
 
@@ -527,7 +502,7 @@ public void testTurnCostsProperlyPropagated_Issue282()
 
         QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
         FastestWeighting weighting = new FastestWeighting(encoder);
-        TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, (TurnCostExtension) qGraph.getExtension());
 
         assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
 
@@ -548,8 +523,7 @@ public void testTurnCostsProperlyPropagated_Issue282()
         graphWithTurnCosts.close();
     }
 
-    private void initHorseshoeGraph( Graph g )
-    {
+    private void initHorseshoeGraph(Graph g) {
         // setup graph
         //   ____
         //  |    |
@@ -561,8 +535,7 @@ private void initHorseshoeGraph( Graph g )
         g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(2, 0, 2, 2));
     }
 
-    private QueryResult fakeEdgeQueryResult( EdgeIteratorState edge, double lat, double lon, int wayIndex )
-    {
+    private QueryResult fakeEdgeQueryResult(EdgeIteratorState edge, double lat, double lon, int wayIndex) {
         QueryResult qr = new QueryResult(lat, lon);
         qr.setClosestEdge(edge);
         qr.setWayIndex(wayIndex);
@@ -571,16 +544,13 @@ private QueryResult fakeEdgeQueryResult( EdgeIteratorState edge, double lat, dou
         return qr;
     }
 
-    private boolean getEdgePreference( QueryGraph queryGraph, int virtualEdgeTypeId, boolean reverse, boolean _default )
-    {
-        boolean edgeUnfavored = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBoolean(
-                EdgeIteratorState.K_UNFAVORED_EDGE, reverse, _default);
-        return edgeUnfavored;
+    private boolean isAvoidEdge(QueryGraph queryGraph, int virtualEdgeTypeId, boolean _default) {
+        boolean avoidEdge = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBool(EdgeIteratorState.K_UNFAVORED_EDGE, _default);
+        return avoidEdge;
     }
 
     @Test
-    public void testEnforceHeading()
-    {
+    public void testEnforceHeading() {
 
         initHorseshoeGraph(g);
         EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
@@ -594,21 +564,21 @@ public void testEnforceHeading()
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
         // test penalized south
         boolean expect = true;
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
 
         queryGraph.clearUnfavoredStatus();
         // test cleared edges south
         expect = false;
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
 
         // enforce coming in north
         queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
         // test penalized south
         expect = true;
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, true, !expect));
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, false, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
 
         // query result on second vertical part of way (downward)
         qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
@@ -619,21 +589,20 @@ public void testEnforceHeading()
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
         // test penalized south
         expect = true;
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, false, !expect));
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, true, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV, !expect));
 
         queryGraph.clearUnfavoredStatus();
         // enforce coming in north
         queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
         // test penalized south
         expect = true;
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, true, !expect));
-        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, false, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV, !expect));
     }
 
     @Test
-    public void testEnforceHeadingByEdgeId()
-    {
+    public void testEnforceHeadingByEdgeId() {
 
         initHorseshoeGraph(g);
         EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
@@ -650,21 +619,20 @@ public void testEnforceHeadingByEdgeId()
         VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, 2);
 
         VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, incomingEdge.getBaseNode());
-        // expect incoming edge in reverse direction to be unfavored
-        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
-        // expect reverse incoming edge to be unfavored
-        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+        // expect incoming edge in reverse direction to be avoided
+        assertEquals(expect, incomingEdge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
+        // expect reverse incoming edge to be avoided
+        assertEquals(expect, incomingEdgeReverse.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
 
         queryGraph.clearUnfavoredStatus();
         expect = false;
-        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        assertEquals(expect, incomingEdge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
         // expect reverse incoming edge to be unfavored
-        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+        assertEquals(expect, incomingEdgeReverse.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
     }
 
     @Test
-    public void testInternalAPIOriginalTraversalKey()
-    {
+    public void testInternalAPIOriginalTraversalKey() {
         initGraph(g);
 
         EdgeExplorer explorer = g.createEdgeExplorer();
@@ -692,17 +660,16 @@ public void testInternalAPIOriginalTraversalKey()
     }
 
     @Test
-    public void useEECache()
-    {
-        initGraph(g);        
-        EdgeExplorer explorer = g.createEdgeExplorer();        
+    public void useEECache() {
+        initGraph(g);
+        EdgeExplorer explorer = g.createEdgeExplorer();
         EdgeIterator iter = explorer.setBaseNode(1);
-        assertTrue(iter.next());        
+        assertTrue(iter.next());
         QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
-        
-        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);        
+
+        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);
         queryGraph.lookup(Arrays.asList(res));
-        
+
         EdgeExplorer edgeExplorer = queryGraph.createEdgeExplorer();
         // using cache means same reference
         assertTrue(edgeExplorer == queryGraph.createEdgeExplorer());
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 385593af2d..9f9858f197 100755
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -19,33 +19,80 @@
 
 import com.graphhopper.reader.PrinctonReader;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import static com.graphhopper.util.Parameters.Algorithms.*;
 import com.graphhopper.util.StopWatch;
+import org.junit.Test;
 
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
 import java.util.zip.GZIPInputStream;
 
-import static org.junit.Assert.*;
-
-import org.junit.Test;
+import static com.graphhopper.util.Parameters.Algorithms.*;
+import static org.junit.Assert.assertTrue;
 
 /**
  * Try algorithms, indices and graph storages with real data
  * <p>
+ *
  * @author Peter Karich
  */
-public class RoutingAlgorithmIT
-{
+public class RoutingAlgorithmIT {
+    public static List<AlgoHelperEntry> createAlgos(GraphHopperStorage ghStorage,
+                                                    LocationIndex idx, boolean withCh,
+                                                    final TraversalMode tMode, final Weighting weighting,
+                                                    final EncodingManager manager) {
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(ASTAR, weighting, tMode), idx));
+        // later: include dijkstraOneToMany
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(DIJKSTRA, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(ASTAR_BI, weighting, tMode);
+        astarbiOpts.getHints().put(ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, dijkstrabiOpts, idx));
+
+        if (withCh) {
+            GraphHopperStorage storageCopy = new GraphBuilder(manager).
+                    set3D(ghStorage.getNodeAccess().is3D()).setCHGraph(weighting).
+                    create();
+            ghStorage.copyTo(storageCopy);
+            storageCopy.freeze();
+            final CHGraph graphCH = storageCopy.getGraph(CHGraph.class, weighting);
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(
+                    new GHDirectory("", DAType.RAM_INT), storageCopy, graphCH, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTree(storageCopy, new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, dijkstrabiOpts, idxCH) {
+                @Override
+                public RoutingAlgorithm createAlgo(Graph qGraph) {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
+
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, astarbiOpts, idxCH) {
+                @Override
+                public RoutingAlgorithm createAlgo(Graph qGraph) {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
+        }
+        return prepare;
+    }
+
     @Test
-    public void testPerformance() throws IOException
-    {
+    public void testPerformance() throws IOException {
         int N = 10;
         int noJvmWarming = N / 4;
 
@@ -56,13 +103,11 @@ public void testPerformance() throws IOException
 
         String bigFile = "10000EWD.txt.gz";
         new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
-        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, false, TraversalMode.NODE_BASED,
                 new ShortestWeighting(encoder), eManager);
-        for (AlgoHelperEntry entry : prepares)
-        {
+        for (AlgoHelperEntry entry : prepares) {
             StopWatch sw = new StopWatch();
-            for (int i = 0; i < N; i++)
-            {
+            for (int i = 0; i < N; i++) {
                 int node1 = Math.abs(rand.nextInt(graph.getNodes()));
                 int node2 = Math.abs(rand.nextInt(graph.getNodes()));
                 RoutingAlgorithm d = entry.createAlgo(graph);
@@ -83,53 +128,4 @@ public void testPerformance() throws IOException
             assertTrue("speed to low!? " + perRun + " per run", perRun < 0.08);
         }
     }
-
-    public static List<AlgoHelperEntry> createAlgos( GraphHopperStorage ghStorage,
-                                              LocationIndex idx, final FlagEncoder encoder, boolean withCh,
-                                              final TraversalMode tMode, final Weighting weighting,
-                                              final EncodingManager manager )
-    {
-        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
-        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(ASTAR, encoder, weighting, tMode), idx));
-        // later: include dijkstraOneToMany        
-        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(DIJKSTRA, encoder, weighting, tMode), idx));
-
-        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(ASTAR_BI, encoder, weighting, tMode);
-        astarbiOpts.getHints().put(ASTAR_BI + ".approximation", "BeelineSimplification");
-        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(DIJKSTRA_BI, encoder, weighting, tMode);
-        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, astarbiOpts, idx));
-        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, dijkstrabiOpts, idx));
-
-        if (withCh)
-        {
-            GraphHopperStorage storageCopy = new GraphBuilder(manager).
-                    set3D(ghStorage.getNodeAccess().is3D()).setCHGraph(weighting).
-                    create();
-            ghStorage.copyTo(storageCopy);
-            storageCopy.freeze();
-            final CHGraph graphCH = storageCopy.getGraph(CHGraph.class, weighting);
-            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(
-                    new GHDirectory("", DAType.RAM_INT), storageCopy, graphCH, encoder, weighting, tMode);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTree(storageCopy, new RAMDirectory()).prepareIndex();
-            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, dijkstrabiOpts, idxCH)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo( Graph qGraph )
-                {
-                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
-                }
-            });
-
-            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, astarbiOpts, idxCH)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo( Graph qGraph )
-                {
-                    return prepareCH.createAlgo(qGraph, astarbiOpts);
-                }
-            });
-        }
-        return prepare;
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
index ac68fba513..ec94968a9b 100755
--- a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
@@ -18,20 +18,19 @@
 package com.graphhopper.routing.ch;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
- *
  * @author Peter Karich
  */
-public class CHAlgoFactoryDecoratorTest
-{
+public class CHAlgoFactoryDecoratorTest {
     @Test
-    public void testCreatePreparations()
-    {
+    public void testCreatePreparations() {
         CHAlgoFactoryDecorator instance = new CHAlgoFactoryDecorator();
         assertFalse(instance.isDisablingAllowed());
-        
+
         instance.setEnabled(false);
         assertTrue(instance.isDisablingAllowed());
     }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index de12b65e92..f50a5b37fa 100755
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -19,54 +19,53 @@
 
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
+import org.junit.Test;
+
 import java.util.Arrays;
 import java.util.List;
 
-import static org.junit.Assert.*;
-
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
 
 /**
  * Tests if a graph optimized by contraction hierarchies returns the same results as a none
  * optimized one. Additionally fine grained path unpacking is tested.
  * <p>
+ *
  * @author Peter Karich
  */
-public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
-{
+public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester {
     @Override
-    protected CHGraph getGraph( GraphHopperStorage ghStorage, Weighting weighting )
-    {
+    protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
         return ghStorage.getGraph(CHGraph.class, weighting);
     }
 
     @Override
-    protected GraphHopperStorage createGHStorage( EncodingManager em,
-                                                  List<? extends Weighting> weightings, boolean is3D )
-    {
+    protected GraphHopperStorage createGHStorage(EncodingManager em,
+                                                 List<? extends Weighting> weightings, boolean is3D) {
         return new GraphHopperStorage(weightings, new RAMDirectory(),
                 em, is3D, new GraphExtension.NoOpExtension()).
                 create(1000);
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts )
-    {
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
                 ghStorage, getGraph(ghStorage, opts.getWeighting()),
-                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+                opts.getWeighting(), TraversalMode.NODE_BASED);
         ch.doWork();
         return ch;
     }
 
     @Test
-    public void testPathRecursiveUnpacking()
-    {
+    public void testPathRecursiveUnpacking() {
         // use an encoder where it is possible to store 2 weights per edge        
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
         EncodingManager em = new EncodingManager(encoder);
@@ -105,9 +104,9 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        AlgorithmOptions opts = new AlgorithmOptions(Parameters.Algorithms.DIJKSTRA_BI, encoder, weighting);
+        AlgorithmOptions opts = new AlgorithmOptions(Parameters.Algorithms.DIJKSTRA_BI, weighting);
         Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                ghStorage, g2, encoder, weighting, TraversalMode.NODE_BASED).
+                ghStorage, g2, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
@@ -116,11 +115,10 @@ public void testPathRecursiveUnpacking()
     }
 
     @Test
-    public void testBaseGraph()
-    {
+    public void testBaseGraph() {
         CarFlagEncoder carFE = new CarFlagEncoder();
         EncodingManager em = new EncodingManager(carFE);
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carFE).
+        AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(new ShortestWeighting(carFE)).build();
         GraphHopperStorage ghStorage = createGHStorage(em,
                 Arrays.asList(opts.getWeighting()), false);
@@ -138,11 +136,10 @@ public void testBaseGraph()
     }
 
     @Test
-    public void testBaseGraphMultipleVehicles()
-    {
-        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+    public void testBaseGraphMultipleVehicles() {
+        AlgorithmOptions footOptions = AlgorithmOptions.start().
                 weighting(new FastestWeighting(footEncoder)).build();
-        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+        AlgorithmOptions carOptions = AlgorithmOptions.start().
                 weighting(new FastestWeighting(carEncoder)).build();
 
         GraphHopperStorage g = createGHStorage(encodingManager,
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index b415f46861..89ae7aaf53 100755
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -19,40 +19,116 @@
 
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.BikeFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import gnu.trove.list.TIntList;
-import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
 
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
-import org.junit.Before;
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public class PrepareContractionHierarchiesTest
-{
+public class PrepareContractionHierarchiesTest {
     private final CarFlagEncoder carEncoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = new EncodingManager(carEncoder);
     private final Weighting weighting = new ShortestWeighting(carEncoder);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private Directory dir;
 
-    GraphHopperStorage createGHStorage()
-    {
+    // 0-1-.....-9-10
+    // |         ^   \
+    // |         |    |
+    // 17-16-...-11<-/
+    public static void initDirected2(Graph g) {
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        g.edge(7, 8, 1, true);
+        g.edge(8, 9, 1, true);
+        g.edge(9, 10, 1, true);
+        g.edge(10, 11, 1, false);
+        g.edge(11, 12, 1, true);
+        g.edge(11, 9, 3, false);
+        g.edge(12, 13, 1, true);
+        g.edge(13, 14, 1, true);
+        g.edge(14, 15, 1, true);
+        g.edge(15, 16, 1, true);
+        g.edge(16, 17, 1, true);
+        g.edge(17, 0, 1, true);
+    }
+
+    //       8
+    //       |
+    //    6->0->1->3->7
+    //    |        |
+    //    |        v
+    //10<-2---4<---5
+    //    9
+    public static void initDirected1(Graph g) {
+        g.edge(0, 8, 1, true);
+        g.edge(0, 1, 1, false);
+        g.edge(1, 3, 1, false);
+        g.edge(3, 7, 1, false);
+        g.edge(3, 5, 1, false);
+        g.edge(5, 4, 1, false);
+        g.edge(4, 2, 1, true);
+        g.edge(2, 9, 1, false);
+        g.edge(2, 10, 1, false);
+        g.edge(2, 6, 1, true);
+        g.edge(6, 0, 1, false);
+    }
+
+    // prepare-routing.svg
+    public static Graph initShortcutsGraph(Graph g) {
+        g.edge(0, 1, 1, true);
+        g.edge(0, 2, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1.5, true);
+        g.edge(1, 4, 1, true);
+        g.edge(2, 9, 1, true);
+        g.edge(9, 3, 1, true);
+        g.edge(10, 3, 1, true);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        g.edge(7, 8, 1, true);
+        g.edge(8, 9, 1, true);
+        g.edge(4, 11, 1, true);
+        g.edge(9, 14, 1, true);
+        g.edge(10, 14, 1, true);
+        g.edge(11, 12, 1, true);
+        g.edge(12, 15, 1, true);
+        g.edge(12, 13, 1, true);
+        g.edge(13, 16, 1, true);
+        g.edge(15, 16, 2, true);
+        g.edge(14, 16, 1, true);
+        return g;
+    }
+
+    GraphHopperStorage createGHStorage() {
         return new GraphBuilder(encodingManager).setCHGraph(weighting).create();
     }
 
-    GraphHopperStorage createExampleGraph()
-    {
+    GraphHopperStorage createExampleGraph() {
         GraphHopperStorage g = createGHStorage();
 
         //5-1-----2
@@ -72,20 +148,18 @@ GraphHopperStorage createExampleGraph()
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
     @Test
-    public void testShortestPathSkipNode()
-    {
+    public void testShortestPathSkipNode() {
         GraphHopperStorage g = createExampleGraph();
-        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
+        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
         CHGraph lg = g.getGraph(CHGraph.class);
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg,
-                carEncoder, weighting, tMode);
+                weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(100);
@@ -99,14 +173,13 @@ public void testShortestPathSkipNode()
     }
 
     @Test
-    public void testShortestPathSkipNode2()
-    {
+    public void testShortestPathSkipNode2() {
         GraphHopperStorage g = createExampleGraph();
         CHGraph lg = g.getGraph(CHGraph.class);
-        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
+        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(10);
@@ -118,13 +191,12 @@ public void testShortestPathSkipNode2()
     }
 
     @Test
-    public void testShortestPathLimit()
-    {
+    public void testShortestPathLimit() {
         GraphHopperStorage g = createExampleGraph();
         CHGraph lg = g.getGraph(CHGraph.class);
 
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(0));
         algo.setWeightLimit(2);
@@ -134,32 +206,29 @@ public void testShortestPathLimit()
     }
 
     @Test
-    public void testAddShortcuts()
-    {
+    public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
         CHGraph lg = g.getGraph(CHGraph.class);
         int old = lg.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 1, lg.getAllEdges().getMaxId());
     }
 
     @Test
-    public void testMoreComplexGraph()
-    {
+    public void testMoreComplexGraph() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         initShortcutsGraph(lg);
         int oldCount = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(oldCount, g.getAllEdges().getMaxId());
         assertEquals(oldCount + 7, lg.getAllEdges().getMaxId());
     }
 
     @Test
-    public void testDirectedGraph()
-    {
+    public void testDirectedGraph() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         g.edge(5, 4, 3, false);
@@ -171,25 +240,24 @@ public void testDirectedGraph()
         g.freeze();
         int oldCount = GHUtility.count(lg.getAllEdges());
         assertEquals(6, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
         assertEquals(oldCount + 2, GHUtility.count(lg.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting, tMode));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
     }
 
     @Test
-    public void testDirectedGraph2()
-    {
+    public void testDirectedGraph2() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         initDirected2(g);
         int oldCount = GHUtility.count(g.getAllEdges());
         assertEquals(19, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(oldCount, g.getAllEdges().getMaxId());
@@ -198,15 +266,14 @@ public void testDirectedGraph2()
         assertEquals(9, prepare.getShortcuts());
         assertEquals(oldCount + 9, lg.getAllEdges().getMaxId());
         assertEquals(oldCount + 9, GHUtility.count(lg.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting, tMode));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
     }
 
     @Test
-    public void testDirectedGraph3()
-    {
+    public void testDirectedGraph3() {
         GraphHopperStorage g = createGHStorage();
         CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
         //5 6 7
@@ -218,7 +285,7 @@ public void testDirectedGraph3()
         g.edge(0, 2, 2, true);
         g.edge(10, 2, 2, true);
         g.edge(11, 2, 2, true);
-        // create a longer one directional edge => no longish one-dir shortcut should be created        
+        // create a longer one directional edge => no longish one-dir shortcut should be created
         g.edge(2, 1, 2, true);
         g.edge(2, 1, 10, false);
 
@@ -228,7 +295,7 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.initFromGraph();
         prepare.prepareNodes();
 
@@ -238,8 +305,7 @@ public void testDirectedGraph3()
         Iterator<Shortcut> iter = scs.iterator();
         Shortcut sc1 = iter.next();
         Shortcut sc2 = iter.next();
-        if (sc1.weight > sc2.weight)
-        {
+        if (sc1.weight > sc2.weight) {
             Shortcut tmp = sc1;
             sc1 = sc2;
             sc2 = tmp;
@@ -257,8 +323,7 @@ public void testDirectedGraph3()
         assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
     }
 
-    void initRoundaboutGraph( Graph g )
-    {
+    void initRoundaboutGraph(Graph g) {
         //              roundabout:
         //16-0-9-10--11   12<-13
         //    \       \  /      \
@@ -310,24 +375,22 @@ void initRoundaboutGraph( Graph g )
     }
 
     @Test
-    public void testRoundaboutUnpacking()
-    {
+    public void testRoundaboutUnpacking() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         initRoundaboutGraph(g);
         int oldCount = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(oldCount, g.getAllEdges().getMaxId());
         assertEquals(oldCount + 23, lg.getAllEdges().getMaxId());
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting, tMode));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
 
     @Test
-    public void testFindShortcuts_Roundabout()
-    {
+    public void testFindShortcuts_Roundabout() {
         GraphHopperStorage ghStorage = createGHStorage();
         CHGraph lg = ghStorage.getGraph(CHGraph.class);
         EdgeIteratorState iter1_3 = ghStorage.edge(1, 3, 1, true);
@@ -340,7 +403,7 @@ public void testFindShortcuts_Roundabout()
         ghStorage.freeze();
 
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg,
-                carEncoder, weighting, tMode);
+                weighting, tMode);
         CHEdgeIteratorState tmp = lg.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
@@ -368,8 +431,7 @@ public void testFindShortcuts_Roundabout()
         Iterator<Shortcut> iter = sc.iterator();
         Shortcut sc1 = iter.next();
         Shortcut sc2 = iter.next();
-        if (sc1.from > sc2.from)
-        {
+        if (sc1.from > sc2.from) {
             Shortcut tmpSc = sc1;
             sc1 = sc2;
             sc2 = tmpSc;
@@ -379,8 +441,7 @@ public void testFindShortcuts_Roundabout()
         assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
     }
 
-    void initUnpackingGraph( GraphHopperStorage ghStorage, CHGraph g, Weighting w )
-    {
+    void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
         final long flags = carEncoder.setProperties(30, true, false);
         double dist = 1;
         g.edge(10, 0).setDistance(dist).setFlags(flags);
@@ -426,36 +487,33 @@ void initUnpackingGraph( GraphHopperStorage ghStorage, CHGraph g, Weighting w )
     }
 
     @Test
-    public void testUnpackingOrder()
-    {
+    public void testUnpackingOrder() {
         GraphHopperStorage ghStorage = createGHStorage();
         CHGraph lg = ghStorage.getGraph(CHGraph.class);
         initUnpackingGraph(ghStorage, lg, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting, tMode));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
     }
 
     @Test
-    public void testUnpackingOrder_Fastest()
-    {
+    public void testUnpackingOrder_Fastest() {
         GraphHopperStorage ghStorage = createGHStorage();
         CHGraph lg = ghStorage.getGraph(CHGraph.class);
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(ghStorage, lg, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, carEncoder, weighting, tMode));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
     }
 
     @Test
-    public void testCircleBug()
-    {
+    public void testCircleBug() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         //  /--1
@@ -465,14 +523,13 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
 
     @Test
-    public void testBug178()
-    {
+    public void testBug178() {
         // 5--------6__
         // |        |  \
         // 0-1->-2--3--4
@@ -490,7 +547,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -500,8 +557,7 @@ public void testBug178()
     // |    8  |
     // \   /   /
     //  7-6-5-/
-    void initBiGraph( Graph graph )
-    {
+    void initBiGraph(Graph graph) {
         graph.edge(0, 1, 100, true);
         graph.edge(1, 2, 1, true);
         graph.edge(2, 3, 1, true);
@@ -514,83 +570,6 @@ void initBiGraph( Graph graph )
         graph.edge(8, 6, 20, true);
     }
 
-    // 0-1-.....-9-10
-    // |         ^   \
-    // |         |    |
-    // 17-16-...-11<-/
-    public static void initDirected2( Graph g )
-    {
-        g.edge(0, 1, 1, true);
-        g.edge(1, 2, 1, true);
-        g.edge(2, 3, 1, true);
-        g.edge(3, 4, 1, true);
-        g.edge(4, 5, 1, true);
-        g.edge(5, 6, 1, true);
-        g.edge(6, 7, 1, true);
-        g.edge(7, 8, 1, true);
-        g.edge(8, 9, 1, true);
-        g.edge(9, 10, 1, true);
-        g.edge(10, 11, 1, false);
-        g.edge(11, 12, 1, true);
-        g.edge(11, 9, 3, false);
-        g.edge(12, 13, 1, true);
-        g.edge(13, 14, 1, true);
-        g.edge(14, 15, 1, true);
-        g.edge(15, 16, 1, true);
-        g.edge(16, 17, 1, true);
-        g.edge(17, 0, 1, true);
-    }
-
-    //       8
-    //       |
-    //    6->0->1->3->7
-    //    |        |
-    //    |        v
-    //10<-2---4<---5
-    //    9
-    public static void initDirected1( Graph g )
-    {
-        g.edge(0, 8, 1, true);
-        g.edge(0, 1, 1, false);
-        g.edge(1, 3, 1, false);
-        g.edge(3, 7, 1, false);
-        g.edge(3, 5, 1, false);
-        g.edge(5, 4, 1, false);
-        g.edge(4, 2, 1, true);
-        g.edge(2, 9, 1, false);
-        g.edge(2, 10, 1, false);
-        g.edge(2, 6, 1, true);
-        g.edge(6, 0, 1, false);
-    }
-
-    // prepare-routing.svg
-    public static Graph initShortcutsGraph( Graph g )
-    {
-        g.edge(0, 1, 1, true);
-        g.edge(0, 2, 1, true);
-        g.edge(1, 2, 1, true);
-        g.edge(2, 3, 1.5, true);
-        g.edge(1, 4, 1, true);
-        g.edge(2, 9, 1, true);
-        g.edge(9, 3, 1, true);
-        g.edge(10, 3, 1, true);
-        g.edge(4, 5, 1, true);
-        g.edge(5, 6, 1, true);
-        g.edge(6, 7, 1, true);
-        g.edge(7, 8, 1, true);
-        g.edge(8, 9, 1, true);
-        g.edge(4, 11, 1, true);
-        g.edge(9, 14, 1, true);
-        g.edge(10, 14, 1, true);
-        g.edge(11, 12, 1, true);
-        g.edge(12, 15, 1, true);
-        g.edge(12, 13, 1, true);
-        g.edge(13, 16, 1, true);
-        g.edge(15, 16, 2, true);
-        g.edge(14, 16, 1, true);
-        return g;
-    }
-
     //    public static void printEdges(CHGraph g) {
 //        RawEdgeIterator iter = g.getAllEdges();
 //        while (iter.next()) {
@@ -604,8 +583,7 @@ public static Graph initShortcutsGraph( Graph g )
 //        System.out.println("---");
 //    }
     @Test
-    public void testBits()
-    {
+    public void testBits() {
         int fromNode = Integer.MAX_VALUE / 3 * 2;
         int endNode = Integer.MAX_VALUE / 37 * 17;
 
@@ -615,8 +593,7 @@ public void testBits()
     }
 
     @Test
-    public void testMultiplePreparationsIdenticalView()
-    {
+    public void testMultiplePreparationsIdenticalView() {
         CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
         BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
         EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
@@ -631,15 +608,13 @@ public void testMultiplePreparationsIdenticalView()
 
         ghStorage.freeze();
 
-        for (Weighting w : chWeightings)
-        {
+        for (Weighting w : chWeightings) {
             checkPath(ghStorage, w, 7, 5, Helper.createTList(3, 9, 14, 16, 13, 12));
         }
     }
 
     @Test
-    public void testMultiplePreparationsDifferentView()
-    {
+    public void testMultiplePreparationsDifferentView() {
         CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
         BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
         EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
@@ -660,13 +635,12 @@ public void testMultiplePreparationsDifferentView()
         checkPath(ghStorage, bikeWeighting, 9, 5, Helper.createTList(3, 10, 14, 16, 13, 12));
     }
 
-    void checkPath( GraphHopperStorage ghStorage, Weighting w, int expShortcuts, double expDistance, TIntList expNodes )
-    {
+    void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, double expDistance, TIntList expNodes) {
         CHGraph lg = ghStorage.getGraph(CHGraph.class, w);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, w.getFlagEncoder(), w, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, w, tMode);
         prepare.doWork();
         assertEquals(w.toString(), expShortcuts, prepare.getShortcuts());
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, w.getFlagEncoder(), w, tMode));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, w, tMode));
         Path p = algo.calcPath(3, 12);
         assertEquals(w.toString(), expDistance, p.getDistance(), 1e-5);
         assertEquals(w.toString(), expNodes, p.calcNodes());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
index 181f4c5804..d0caee0f51 100755
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -19,17 +19,16 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class PrepareEncoderTest
-{
+public class PrepareEncoderTest {
 
     @Test
-    public void testOverwrite()
-    {
+    public void testOverwrite() {
         long forward = PrepareEncoder.getScFwdDir();
         long backward = PrepareEncoder.getScFwdDir() ^ PrepareEncoder.getScDirMask();
         long both = PrepareEncoder.getScDirMask();
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
similarity index 87%
rename from core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
rename to core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
index aff4576a54..8e1b4b502a 100755
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
@@ -15,42 +15,38 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.subnetwork;
 
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.routing.util.PrepareRoutingSubnetworks.PrepEdgeFilter;
+import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.PrepEdgeFilter;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
-
 import gnu.trove.list.array.TIntArrayList;
+import org.junit.Test;
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
-import org.junit.*;
-
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class PrepareRoutingSubnetworksTest
-{
+public class PrepareRoutingSubnetworksTest {
     private final FlagEncoder carFlagEncoder = new CarFlagEncoder();
     private final EncodingManager em = new EncodingManager(carFlagEncoder);
 
-    GraphHopperStorage createStorage( EncodingManager eman )
-    {
+    GraphHopperStorage createStorage(EncodingManager eman) {
         return new GraphBuilder(eman).create();
     }
 
-    GraphHopperStorage createSubnetworkTestStorage()
-    {
+    GraphHopperStorage createSubnetworkTestStorage() {
         GraphHopperStorage g = createStorage(em);
         // big network
         g.edge(1, 2, 1, true);
@@ -77,8 +73,7 @@ GraphHopperStorage createSubnetworkTestStorage()
         return g;
     }
 
-    GraphHopperStorage createSubnetworkTestStorage2( EncodingManager em )
-    {
+    GraphHopperStorage createSubnetworkTestStorage2(EncodingManager em) {
         GraphHopperStorage g = createStorage(em);
         // large network
         g.edge(0, 1, 1, true);
@@ -99,8 +94,7 @@ GraphHopperStorage createSubnetworkTestStorage2( EncodingManager em )
     }
 
     @Test
-    public void testFindSubnetworks()
-    {
+    public void testFindSubnetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
         PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
@@ -116,8 +110,7 @@ public void testFindSubnetworks()
     }
 
     @Test
-    public void testKeepLargestNetworks()
-    {
+    public void testKeepLargestNetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
         PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
@@ -136,8 +129,7 @@ public void testKeepLargestNetworks()
     }
 
     @Test
-    public void testRemoveSubnetworkIfOnlyOneVehicle()
-    {
+    public void testRemoveSubnetworkIfOnlyOneVehicle() {
         GraphHopperStorage g = createSubnetworkTestStorage2(em);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em.fetchEdgeEncoders());
         instance.setMinNetworkSize(4);
@@ -158,8 +150,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
     }
 
     @Test
-    public void testRemoveNode()
-    {
+    public void testRemoveNode() {
         FlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
         EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
@@ -172,10 +163,8 @@ public void testRemoveNode()
         assertFalse(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 6));
 
         // mark certain edges inaccessible for all encoders
-        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(g, 5, 6), GHUtility.getEdge(g, 4, 5), GHUtility.getEdge(g, 4, 6)))
-        {
-            for (FlagEncoder encoders : em2.fetchEdgeEncoders())
-            {
+        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(g, 5, 6), GHUtility.getEdge(g, 4, 5), GHUtility.getEdge(g, 4, 6))) {
+            for (FlagEncoder encoders : em2.fetchEdgeEncoders()) {
                 edge.setFlags(encoders.setAccess(0, false, false));
             }
         }
@@ -186,13 +175,13 @@ public void testRemoveNode()
     }
 
     @Test
-    public void testRemoveSubnetworkWhenMultipleVehicles()
-    {
+    public void testRemoveSubnetworkWhenMultipleVehicles() {
         FlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
         EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
         GraphHopperStorage g = createSubnetworkTestStorage2(em2);
-        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false) | bikeEncoder.setProperties(5, true, true));
+        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false)
+                | bikeEncoder.setProperties(5, true, true));
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
         instance.setMinNetworkSize(5);
         instance.doWork();
@@ -213,8 +202,7 @@ public void testRemoveSubnetworkWhenMultipleVehicles()
         assertEquals(6, g.getNodes());
     }
 
-    GraphHopperStorage createDeadEndUnvisitedNetworkStorage( EncodingManager em )
-    {
+    GraphHopperStorage createDeadEndUnvisitedNetworkStorage(EncodingManager em) {
         GraphHopperStorage g = createStorage(em);
         // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
         g.edge(0, 1, 1, true);
@@ -232,8 +220,7 @@ GraphHopperStorage createDeadEndUnvisitedNetworkStorage( EncodingManager em )
         return g;
     }
 
-    GraphHopperStorage createTarjanTestStorage()
-    {
+    GraphHopperStorage createTarjanTestStorage() {
         GraphHopperStorage g = createStorage(em);
 
         g.edge(1, 2, 1, false);
@@ -256,8 +243,7 @@ GraphHopperStorage createTarjanTestStorage()
     }
 
     @Test
-    public void testRemoveDeadEndUnvisitedNetworks()
-    {
+    public void testRemoveDeadEndUnvisitedNetworks() {
         GraphHopperStorage g = createDeadEndUnvisitedNetworkStorage(em);
         assertEquals(11, g.getNodes());
 
@@ -273,8 +259,7 @@ public void testRemoveDeadEndUnvisitedNetworks()
     }
 
     @Test
-    public void testTarjan()
-    {
+    public void testTarjan() {
         GraphHopperStorage g = createSubnetworkTestStorage();
 
         // Requires a single vehicle type, otherwise we throw.
@@ -286,28 +271,15 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]
-        {
-            13, 5, 3, 7, 0
-        }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]
-        {
-            2, 4, 12, 11, 8, 1
-        }), components.get(1));
-        assertEquals(new TIntArrayList(new int[]
-        {
-            10, 14, 6
-        }), components.get(2));
-        assertEquals(new TIntArrayList(new int[]
-        {
-            15, 9
-        }), components.get(3));
+        assertEquals(new TIntArrayList(new int[]{13, 5, 3, 7, 0}), components.get(0));
+        assertEquals(new TIntArrayList(new int[]{2, 4, 12, 11, 8, 1}), components.get(1));
+        assertEquals(new TIntArrayList(new int[]{10, 14, 6}), components.get(2));
+        assertEquals(new TIntArrayList(new int[]{15, 9}), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression()
-    {
+    public void testNodeOrderingRegression() {
         // 1 -> 2 -> 0
         GraphHopperStorage g = createStorage(em);
         g.edge(1, 2, 1, false);
@@ -320,8 +292,7 @@ public void testNodeOrderingRegression()
     }
 
     @Test
-    public void test481()
-    {
+    public void test481() {
         // 0->1->3->4->5->6
         //  2        7<--/
         GraphHopperStorage g = createStorage(em);
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 565f65c288..602d6374fb 100755
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -21,32 +21,33 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.Helper;
-import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import org.junit.Test;
+
 import java.util.Arrays;
 import java.util.List;
-import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import static org.junit.Assert.assertEquals;
 
 /**
- *
  * @author Peter Karich
  */
-public class RoundTripRoutingTemplateTest
-{
+public class RoundTripRoutingTemplateTest {
     private final FlagEncoder carFE = new CarFlagEncoder();
     private final EncodingManager em = new EncodingManager(carFE);
     // TODO private final TraversalMode tMode = TraversalMode.EDGE_BASED_2DIR;
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
 
     @Test
-    public void testCalcRoundTrip() throws Exception
-    {
+    public void testCalcRoundTrip() throws Exception {
         Weighting weighting = new FastestWeighting(carFE);
         Graph g = createTestGraph(true);
 
@@ -63,7 +64,7 @@ public void testCalcRoundTrip() throws Exception
         QueryGraph qGraph = new QueryGraph(g);
         qGraph.lookup(qr4, qr5);
         rTripRouting.setQueryResults(Arrays.asList(qr5, qr4, qr5));
-        List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, carFE, weighting, tMode));
+        List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
         assertEquals(Helper.createTList(5, 6, 3, 4), paths.get(0).calcNodes());
         assertEquals(Helper.createTList(4, 8, 7, 6, 5), paths.get(1).calcNodes());
@@ -71,14 +72,13 @@ public void testCalcRoundTrip() throws Exception
         qGraph = new QueryGraph(g);
         qGraph.lookup(qr4, qr6);
         rTripRouting.setQueryResults(Arrays.asList(qr6, qr4, qr6));
-        paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, carFE, weighting, tMode));
+        paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
         assertEquals(Helper.createTList(6, 3, 4), paths.get(0).calcNodes());
         assertEquals(Helper.createTList(4, 8, 7, 6), paths.get(1).calcNodes());
     }
 
-    private Graph createTestGraph( boolean fullGraph )
-    {
+    private Graph createTestGraph(boolean fullGraph) {
         return new AlternativeRouteTest(tMode).createTestGraph(fullGraph, em);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index c68d7350ca..b1bc39cd01 100755
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -19,59 +19,53 @@
 
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.Translation;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.text.DateFormat;
+import java.util.Date;
 import java.util.Locale;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
-import com.graphhopper.util.Helper;
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
-import java.text.DateFormat;
-import java.util.Date;
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  * @author ratrun
  */
-public abstract class AbstractBikeFlagEncoderTester
-{
+public abstract class AbstractBikeFlagEncoderTester {
     protected BikeCommonFlagEncoder encoder;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         encoder = createBikeEncoder();
     }
 
     protected abstract BikeCommonFlagEncoder createBikeEncoder();
 
-    protected void assertPriority( int expectedPrio, ReaderWay way )
-    {
+    protected void assertPriority(int expectedPrio, ReaderWay way) {
         assertPriority(expectedPrio, way, 0);
     }
 
-    protected void assertPriority( int expectedPrio, ReaderWay way, long relationFlags )
-    {
+    protected void assertPriority(int expectedPrio, ReaderWay way, long relationFlags) {
         assertEquals(expectedPrio, encoder.handlePriority(way, 18, (int) encoder.relationCodeEncoder.getValue(relationFlags)));
     }
 
-    protected double getSpeedFromFlags( ReaderWay way )
-    {
+    protected double getSpeedFromFlags(ReaderWay way) {
         long allowed = encoder.acceptBit;
         long flags = encoder.handleWayTags(way, allowed, 0);
         return encoder.getSpeed(flags);
     }
 
-    protected String getWayTypeFromFlags( ReaderWay way )
-    {
+    protected String getWayTypeFromFlags(ReaderWay way) {
         return getWayTypeFromFlags(way, 0);
     }
 
-    protected String getWayTypeFromFlags( ReaderWay way, long relationFlags )
-    {
+    protected String getWayTypeFromFlags(ReaderWay way, long relationFlags) {
         long allowed = encoder.acceptBit;
         long flags = encoder.handleWayTags(way, allowed, relationFlags);
         Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
@@ -79,8 +73,7 @@ protected String getWayTypeFromFlags( ReaderWay way, long relationFlags )
     }
 
     @Test
-    public void testAccess()
-    {
+    public void testAccess() {
         ReaderWay way = new ReaderWay(1);
 
         way.setTag("highway", "motorway");
@@ -203,11 +196,10 @@ public void testAccess()
     }
 
     @Test
-    public void testTramStations()
-    {
+    public void testTramStations() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
-        way.setTag("railway", "rail");        
+        way.setTag("railway", "rail");
         assertTrue(encoder.acceptWay(way) > 0);
 
         way = new ReaderWay(1);
@@ -218,10 +210,10 @@ public void testTramStations()
         way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "station");
-        way.setTag("bicycle", "yes");        
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
-        
-        way.setTag("bicycle", "no");        
+
+        way.setTag("bicycle", "no");
         assertTrue(encoder.acceptWay(way) == 0);
 
         way = new ReaderWay(1);
@@ -244,8 +236,7 @@ public void testTramStations()
     }
 
     @Test
-    public void testAvoidTunnel()
-    {
+    public void testAvoidTunnel() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "residential");
         assertPriority(PREFER.getValue(), osmWay);
@@ -262,8 +253,7 @@ public void testAvoidTunnel()
     }
 
     @Test
-    public void testTram()
-    {
+    public void testTram() {
         ReaderWay way = new ReaderWay(1);
         // very dangerous
         way.setTag("highway", "secondary");
@@ -276,8 +266,7 @@ public void testTram()
     }
 
     @Test
-    public void testHandleCommonWayTags()
-    {
+    public void testHandleCommonWayTags() {
         ReaderWay way = new ReaderWay(1);
         String wayType;
 
@@ -369,8 +358,7 @@ public void testHandleCommonWayTags()
     }
 
     @Test
-    public void testService()
-    {
+    public void testService() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         assertEquals(14, encoder.getSpeed(way));
@@ -382,8 +370,7 @@ public void testService()
     }
 
     @Test
-    public void testSacScale()
-    {
+    public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
@@ -395,16 +382,14 @@ public void testSacScale()
     }
 
     @Test
-    public void testReduceToMaxSpeed()
-    {
+    public void testReduceToMaxSpeed() {
         ReaderWay way = new ReaderWay(12);
         way.setTag("maxspeed", "90");
         assertEquals(12, encoder.applyMaxSpeed(way, 12), 1e-2);
     }
 
     @Test
-    public void testPreferenceForSlowSpeed()
-    {
+    public void testPreferenceForSlowSpeed() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "tertiary");
         assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49))), 1e-1);
@@ -412,8 +397,7 @@ public void testPreferenceForSlowSpeed()
     }
 
     @Test
-    public void testHandleWayTagsCallsHandlePriority()
-    {
+    public void testHandleWayTagsCallsHandlePriority() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "cycleway");
         long encoded = encoder.handleWayTags(osmWay, encoder.acceptBit, 0);
@@ -421,8 +405,7 @@ public void testHandleWayTagsCallsHandlePriority()
     }
 
     @Test
-    public void testAvoidMotorway()
-    {
+    public void testAvoidMotorway() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "motorway");
         osmWay.setTag("bicycle", "yes");
@@ -430,8 +413,7 @@ public void testAvoidMotorway()
     }
 
     @Test
-    public void testPriority()
-    {
+    public void testPriority() {
         long flags = encoder.priorityWayEncoder.setValue(0, PriorityCode.BEST.getValue());
         assertEquals(1, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
 
@@ -440,8 +422,7 @@ public void testPriority()
     }
 
     @Test
-    public void testBarrierAccess()
-    {
+    public void testBarrierAccess() {
         // by default allow access through the gate for bike & foot!
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("barrier", "gate");
@@ -481,8 +462,7 @@ public void testBarrierAccess()
     }
 
     @Test
-    public void testBarrierAccessFord()
-    {
+    public void testBarrierAccessFord() {
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("ford", "yes");
         // barrier!
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index e96e9e8d25..6754e17dab 100755
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -19,16 +19,14 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class AbstractFlagEncoderTest
-{
+public class AbstractFlagEncoderTest {
     @Test
-    public void testAcceptsCar()
-    {
+    public void testAcceptsCar() {
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 0);
         assertEquals(40, encoder.parseSpeed("40 km/h"), 1e-3);
         assertEquals(40, encoder.parseSpeed("40km/h"), 1e-3);
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index c3027ea946..819080dde1 100755
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -27,18 +27,15 @@
 /**
  * @author Peter Karich
  */
-public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
-{
+public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest {
     private final EncodingManager em = new EncodingManager("bike,bike2");
 
     @Override
-    protected BikeCommonFlagEncoder createBikeEncoder()
-    {
+    protected BikeCommonFlagEncoder createBikeEncoder() {
         return (BikeCommonFlagEncoder) em.getEncoder("bike2");
     }
 
-    private Graph initExampleGraph()
-    {
+    private Graph initExampleGraph() {
         GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true, new GraphExtension.NoOpExtension()).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
@@ -53,8 +50,7 @@ private Graph initExampleGraph()
     }
 
     @Test
-    public void testApplyWayTags()
-    {
+    public void testApplyWayTags() {
         Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         ReaderWay way = new ReaderWay(1);
@@ -68,8 +64,7 @@ public void testApplyWayTags()
     }
 
     @Test
-    public void testUnchangedForStepsBridgeAndTunnel()
-    {
+    public void testUnchangedForStepsBridgeAndTunnel() {
         Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         long oldFlags = edge.getFlags();
@@ -81,8 +76,7 @@ public void testUnchangedForStepsBridgeAndTunnel()
     }
 
     @Test
-    public void testSetSpeed0_issue367()
-    {
+    public void testSetSpeed0_issue367() {
         long flags = encoder.setProperties(10, true, true);
         flags = encoder.setSpeed(flags, 0);
 
@@ -93,8 +87,7 @@ public void testSetSpeed0_issue367()
     }
 
     @Test
-    public void testRoutingFailsWithInvalidGraph_issue665()
-    {
+    public void testRoutingFailsWithInvalidGraph_issue665() {
         GraphHopperStorage graph = new GraphHopperStorage(
                 new RAMDirectory(), em, true, new GraphExtension.NoOpExtension());
         graph.create(100);
@@ -110,8 +103,7 @@ public void testRoutingFailsWithInvalidGraph_issue665()
         assertTrue(isGraphValid(graph, encoder));
     }
 
-    private boolean isGraphValid( Graph graph, FlagEncoder encoder )
-    {
+    private boolean isGraphValid(Graph graph, FlagEncoder encoder) {
         EdgeExplorer explorer = graph.createEdgeExplorer();
 
         // iterator at node 0 considers the edge 0-1 to be undirected
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 4312e7845c..456f348fec 100755
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -20,29 +20,25 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.PriorityWeighting;
+import org.junit.Test;
 
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
-
-import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  * @author ratrun
  */
-public class BikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
-{
+public class BikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
     @Override
-    protected BikeCommonFlagEncoder createBikeEncoder()
-    {
+    protected BikeCommonFlagEncoder createBikeEncoder() {
         return (BikeCommonFlagEncoder) new EncodingManager("bike,mtb").getEncoder("bike");
     }
 
     @Test
-    public void testGetSpeed()
-    {
+    public void testGetSpeed() {
         long result = encoder.setProperties(10, true, true);
         assertEquals(10, encoder.getSpeed(result), 1e-1);
         ReaderWay way = new ReaderWay(1);
@@ -74,33 +70,68 @@ public void testGetSpeed()
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("bicycle", "yes");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("segregated", "no");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("segregated", "yes");
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
-        assertPriority(UNCHANGED.getValue(), way);
+        assertPriority(PREFER.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("surface", "paved");
         way.setTag("bicycle", "yes");
-
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("segregated", "yes");
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
-        assertPriority(UNCHANGED.getValue(), way);
+        assertPriority(PREFER.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "cycleway");
         assertEquals(18, encoder.getSpeed(way));
         assertPriority(VERY_NICE.getValue(), way);
         int cyclewaySpeed = encoder.getSpeed(way);
+        way.setTag("foot", "yes");
+        way.setTag("segregated", "yes");
+        assertPriority(VERY_NICE.getValue(), way);
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        way.setTag("segregated", "no");
+        assertPriority(PREFER.getValue(), way);
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
 
-        // Make sure that highway=cycleway" and highway=path with bicycle = designated give same result
+        // Make sure that "highway=cycleway" and "highway=path" with "bicycle=designated" give the same result
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("bicycle", "designated");
         assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        // Assume foot=no for designated in absence of a foot tag
+        assertPriority(VERY_NICE.getValue(), way);
+        way.setTag("foot", "yes");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.setTag("foot", "no");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
+
+        way.setTag("segregated", "yes");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
+
+        way.setTag("segregated", "no");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
         assertPriority(VERY_NICE.getValue(), way);
 
         way.setTag("bicycle", "yes");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.setTag("segregated", "yes");
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
-        assertPriority(UNCHANGED.getValue(), way);
+        assertPriority(PREFER.getValue(), way);
 
         way.setTag("surface", "unpaved");
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
@@ -131,7 +162,7 @@ public void testGetSpeed()
         way.setTag("surface", "paved");
         way.setTag("bicycle", "designated");
         assertEquals(cyclewaySpeed, encoder.getSpeed(way));
-        assertPriority(PREFER.getValue(), way);
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "track");
@@ -171,6 +202,12 @@ public void testGetSpeed()
         way.setTag("surface", "paved");
         assertEquals(18, encoder.getSpeed(way));
 
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "ground");
+        assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
@@ -185,6 +222,13 @@ public void testGetSpeed()
         way.setTag("surface", "fine_gravel");
         assertEquals(18, encoder.getSpeed(way));
 
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("surface", "gravel");
+        way.setTag("tracktype", "grade2");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "primary");
         way.setTag("surface", "paved");
@@ -206,8 +250,7 @@ public void testGetSpeed()
     }
 
     @Test
-    public void testHandleWayTags()
-    {
+    public void testHandleWayTags() {
         ReaderWay way = new ReaderWay(1);
         String wayType;
         way.setTag("highway", "track");
@@ -251,8 +294,7 @@ public void testHandleWayTags()
     }
 
     @Test
-    public void testOneway()
-    {
+    public void testOneway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "tertiary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -328,8 +370,7 @@ public void testOneway()
     }
 
     @Test
-    public void testHandleWayTagsInfluencedByRelation()
-    {
+    public void testHandleWayTagsInfluencedByRelation() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "road");
         long allowed = encoder.acceptBit;
@@ -343,6 +384,10 @@ public void testHandleWayTagsInfluencedByRelation()
 
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(12, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
         osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
@@ -395,8 +440,7 @@ public void testHandleWayTagsInfluencedByRelation()
     }
 
     @Test
-    public void testUnchangedRelationShouldNotInfluencePriority()
-    {
+    public void testUnchangedRelationShouldNotInfluencePriority() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "secondary");
 
@@ -408,8 +452,7 @@ public void testUnchangedRelationShouldNotInfluencePriority()
 
     @Test
     @Override
-    public void testSacScale()
-    {
+    public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
@@ -433,8 +476,7 @@ public void testSacScale()
     }
 
     @Test
-    public void testCalcPriority()
-    {
+    public void testCalcPriority() {
         long allowed = encoder.acceptBit;
         ReaderWay osmWay = new ReaderWay(1);
         ReaderRelation osmRel = new ReaderRelation(1);
@@ -452,8 +494,7 @@ public void testCalcPriority()
     }
 
     @Test
-    public void testMaxSpeed()
-    {
+    public void testMaxSpeed() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("maxspeed", "10");
@@ -486,8 +527,7 @@ public void testMaxSpeed()
     }
 
     @Test
-    public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts()
-    {
+    public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts() {
         // default is disabled turn costs and no restrictions
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
@@ -509,8 +549,7 @@ public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts()
     }
 
     @Test
-    public void testTurnFlagEncoding_withCosts()
-    {
+    public void testTurnFlagEncoding_withCosts() {
         encoder = new BikeFlagEncoder(4, 2, 127);
         new EncodingManager(encoder);
 
@@ -529,12 +568,10 @@ public void testTurnFlagEncoding_withCosts()
         assertFalse(encoder.isTurnRestricted(flags_20));
 
         long flags_r220 = encoder.getTurnFlags(true, 0);
-        try
-        {
+        try {
             encoder.getTurnFlags(false, 220);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         long flags_126 = encoder.getTurnFlags(false, 126);
         assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r220)));
@@ -547,8 +584,7 @@ public void testTurnFlagEncoding_withCosts()
     // Issue 407 : Always block kissing_gate execpt for mountainbikes
     @Test
     @Override
-    public void testBarrierAccess()
-    {
+    public void testBarrierAccess() {
         // kissing_gate without bicycle tag
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("barrier", "kissing_gate");
@@ -564,8 +600,7 @@ public void testBarrierAccess()
     }
 
     @Test
-    public void testClassBicycle()
-    {
+    public void testClassBicycle() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "tertiary");
         way.setTag("class:bicycle", "3");
diff --git a/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java
new file mode 100644
index 0000000000..2f75746e9e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java
@@ -0,0 +1,129 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.ReaderNode;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.util.Helper;
+import org.junit.Test;
+
+import java.text.DateFormat;
+import java.util.Date;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ * @author zstadler
+ */
+public class Car4WDFlagEncoderTest extends CarFlagEncoderTest {
+    private final EncodingManager em = new EncodingManager("car4wd,bike,foot");
+    private final Car4WDFlagEncoder encoder = (Car4WDFlagEncoder) em.getEncoder("car4wd");
+
+    @Override
+    @Test
+    public void testAccess() {
+        ReaderWay way = new ReaderWay(1);
+        assertFalse(encoder.acceptWay(way) > 0);
+        way.setTag("highway", "service");
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("access", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        // for now allow grade1+2+3 for every country, see #253
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade2");
+        assertTrue(encoder.acceptWay(way) > 0);
+	// This is the only difference from a "car"
+        way.setTag("tracktype", "grade4");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "delivery");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+        assertFalse(encoder.acceptWay(way) > 0);
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        way.setTag("motorcar", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+
+        way.clearTags();
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "emergency");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("motor_vehicle", "emergency");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
+
+        way.clearTags();
+        way.setTag("highway", "road");
+        way.setTag("access:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "road");
+        way.setTag("access", "no");
+        way.setTag("access:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
+        assertTrue(encoder.acceptWay(way) > 0);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 222edcf2dd..41e6dc880e 100755
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -20,9 +20,9 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.util.Helper;
-import java.text.DateFormat;
 import org.junit.Test;
 
+import java.text.DateFormat;
 import java.util.Date;
 
 import static org.junit.Assert.*;
@@ -30,14 +30,12 @@
 /**
  * @author Peter Karich
  */
-public class CarFlagEncoderTest
-{
+public class CarFlagEncoderTest {
     private final EncodingManager em = new EncodingManager("car,bike,foot");
     private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("car");
 
     @Test
-    public void testAccess()
-    {
+    public void testAccess() {
         ReaderWay way = new ReaderWay(1);
         assertFalse(encoder.acceptWay(way) > 0);
         way.setTag("highway", "service");
@@ -127,8 +125,7 @@ public void testAccess()
     }
 
     @Test
-    public void testMilitaryAccess()
-    {
+    public void testMilitaryAccess() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("access", "military");
@@ -136,8 +133,7 @@ public void testMilitaryAccess()
     }
 
     @Test
-    public void testFordAccess()
-    {
+    public void testFordAccess() {
         ReaderNode node = new ReaderNode(0, 0.0, 0.0);
         node.setTag("ford", "yes");
 
@@ -150,21 +146,18 @@ public void testFordAccess()
         assertFalse(encoder.acceptWay(way) > 0);
         assertTrue(encoder.handleNodeTags(node) > 0);
 
-        try
-        {
+        try {
             // Now they are passable
             encoder.setBlockFords(false);
             assertTrue(encoder.acceptWay(way) > 0);
             assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally
-        {
+        } finally {
             encoder.setBlockFords(true);
         }
     }
 
     @Test
-    public void testOneway()
-    {
+    public void testOneway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -198,8 +191,7 @@ public void testOneway()
     }
 
     @Test
-    public void testSetAccess()
-    {
+    public void testSetAccess() {
         assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
         assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
 
@@ -222,8 +214,7 @@ public void testSetAccess()
     }
 
     @Test
-    public void testMaxSpeed()
-    {
+    public void testMaxSpeed() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "trunk");
         way.setTag("maxspeed", "500");
@@ -258,8 +249,7 @@ public void testMaxSpeed()
     }
 
     @Test
-    public void testSpeed()
-    {
+    public void testSpeed() {
         // limit bigger than default road speed
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "trunk");
@@ -288,24 +278,27 @@ public void testSpeed()
         encoded = encoder.handleWayTags(way, allowed, 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
 
-        try
-        {
+        way.clearTags();
+        way.setTag("highway", "secondary");
+        way.setTag("surface", "compacted");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(30, encoder.getSpeed(encoded), 1e-1);
+
+        try {
             encoder.setSpeed(0, -1);
             assertTrue(false);
-        } catch (IllegalArgumentException ex)
-        {
+        } catch (IllegalArgumentException ex) {
         }
     }
 
     @Test
-    public void testSetSpeed()
-    {
+    public void testSetSpeed() {
         assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
     }
 
     @Test
-    public void testSetSpeed0_issue367()
-    {
+    public void testSetSpeed0_issue367() {
         long flags = encoder.setProperties(10, true, true);
         flags = encoder.setSpeed(flags, encoder.speedFactor * 0.49);
 
@@ -316,8 +309,7 @@ public void testSetSpeed0_issue367()
     }
 
     @Test
-    public void testRoundabout()
-    {
+    public void testRoundabout() {
         long flags = encoder.setAccess(0, true, true);
         long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
         assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
@@ -344,11 +336,10 @@ public void testRoundabout()
     }
 
     @Test
-    public void testRailway()
-    {
+    public void testRailway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
-        way.setTag("railway", "rail");        
+        way.setTag("railway", "rail");
         assertTrue(encoder.acceptWay(way) > 0);
 
         way.clearTags();
@@ -397,7 +388,7 @@ public void testRailway()
         // We can't store 0.5km/h, but we expect the lowest possible speed (5km/h)
         assertEquals(2.5, encoder.getFerrySpeed(way, 20, 30, 40), 1e-1);
         assertEquals(5, encoder.getSpeed(encoder.setSpeed(0, 2.5)), 1e-1);
-        
+
         //Test for an unrealisitic long duration
         way = new ReaderWay(1);
         way.setTag("route", "ferry");
@@ -412,8 +403,7 @@ public void testRailway()
     }
 
     @Test
-    public void testSwapDir()
-    {
+    public void testSwapDir() {
         long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
         assertTrue(encoder.isForward(swappedFlags));
         assertTrue(encoder.isBackward(swappedFlags));
@@ -427,8 +417,7 @@ public void testSwapDir()
     }
 
     @Test
-    public void testBarrierAccess()
-    {
+    public void testBarrierAccess() {
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("barrier", "lift_gate");
         node.setTag("access", "yes");
@@ -467,8 +456,7 @@ public void testBarrierAccess()
     }
 
     @Test
-    public void testTurnFlagEncoding_noCosts()
-    {
+    public void testTurnFlagEncoding_noCosts() {
         FlagEncoder tmpEnc = new CarFlagEncoder(8, 5, 0);
         EncodingManager em = new EncodingManager(tmpEnc);
 
@@ -492,8 +480,7 @@ public void testTurnFlagEncoding_noCosts()
     }
 
     @Test
-    public void testTurnFlagEncoding_withCosts()
-    {
+    public void testTurnFlagEncoding_withCosts() {
         FlagEncoder tmpEncoder = new CarFlagEncoder(8, 5, 127);
         EncodingManager em = new EncodingManager(tmpEncoder);
 
@@ -512,20 +499,17 @@ public void testTurnFlagEncoding_withCosts()
         assertFalse(tmpEncoder.isTurnRestricted(flags_20));
 
         long flags_r220 = tmpEncoder.getTurnFlags(true, 0);
-        try
-        {
+        try {
             tmpEncoder.getTurnFlags(false, 220);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r220)));
         assertTrue(tmpEncoder.isTurnRestricted(flags_r220));
     }
 
     @Test
-    public void testMaxValue()
-    {
+    public void testMaxValue() {
         CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         ReaderWay way = new ReaderWay(1);
@@ -548,30 +532,25 @@ public void testMaxValue()
     }
 
     @Test
-    public void testRegisterOnlyOnceAllowed()
-    {
+    public void testRegisterOnlyOnceAllowed() {
         CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager tmpEM = new EncodingManager(instance);
-        try
-        {
+        try {
             tmpEM = new EncodingManager(instance);
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
         }
     }
 
     @Test
-    public void testSetToMaxSpeed()
-    {
+    public void testSetToMaxSpeed() {
         ReaderWay way = new ReaderWay(12);
         way.setTag("maxspeed", "90");
         assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
     }
 
     @Test
-    public void testCombination()
-    {
+    public void testCombination() {
         ReaderWay way = new ReaderWay(123);
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
@@ -583,4 +562,12 @@ public void testCombination()
         assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
         assertTrue(em.getEncoder("bike").isForward(edgeFlags));
     }
+    @Test
+    public void testApplyBadSurfaceSpeed() {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("surface", "unpaved");
+        assertEquals(30, encoder.applyBadSurfaceSpeed(way, 90), 1e-1);
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
new file mode 100644
index 0000000000..114daf3b4b
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -0,0 +1,194 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.junit.Test;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+
+/**
+ * @author Peter Karich
+ */
+public class DataFlagEncoderTest {
+    private final DataFlagEncoder encoder;
+    private final EncodingManager encodingManager;
+    private final int motorVehicleInt;
+
+    public DataFlagEncoderTest() {
+        encoder = new DataFlagEncoder();
+        encodingManager = new EncodingManager(encoder);
+
+        motorVehicleInt = encoder.getAccessType("motor_vehicle");
+    }
+
+    @Test
+    public void testHighway() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("surface", "sand");
+        osmWay.setTag("tunnel", "yes");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("primary", encoder.getHighwayAsString(edge));
+        assertEquals("sand", encoder.getSurfaceAsString(edge));
+        assertEquals("tunnel", encoder.getTransportModeAsString(edge));
+        assertTrue(encoder.isForward(edge, motorVehicleInt));
+        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+
+        osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertTrue(encoder.isForward(edge, motorVehicleInt));
+        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+
+        osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "unknownX");
+        flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("_default", encoder.getHighwayAsString(edge));
+    }
+
+    @Test
+    public void testTunnel() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("tunnel", "yes");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("primary", encoder.getHighwayAsString(edge));
+        assertEquals("tunnel", encoder.getTransportModeAsString(edge));
+        assertTrue(encoder.isTransportModeTunnel(edge));
+        assertFalse(encoder.isTransportModeBridge(edge));
+
+        osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("bridge", "yes");
+        flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("bridge", encoder.getTransportModeAsString(edge));
+        assertFalse(encoder.isTransportModeTunnel(edge));
+        assertTrue(encoder.isTransportModeBridge(edge));
+    }
+
+    @Test
+    public void testBridge() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("bridge", "yes");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("primary", encoder.getHighwayAsString(edge));
+        assertEquals("bridge", encoder.getTransportModeAsString(edge));
+        assertFalse(encoder.isTransportModeTunnel(edge));
+        assertTrue(encoder.isTransportModeBridge(edge));
+
+        osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("bridge", "yes");
+        osmWay.setTag("tunnel", "yes");
+        flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals("bridge", encoder.getTransportModeAsString(edge));
+        assertFalse(encoder.isTransportModeTunnel(edge));
+        assertTrue(encoder.isTransportModeBridge(edge));
+    }
+
+    @Test
+    public void testHighwaySpeed() {
+        Map<String, Double> map = new LinkedHashMap<>();
+        map.put("motorway", 100d);
+        map.put("motorway_link", 100d);
+        map.put("motorroad", 90d);
+        map.put("trunk", 90d);
+        map.put("trunk_link", 90d);
+
+        double[] arr = encoder.getHighwaySpeedMap(map);
+        assertEquals("[0.0, 100.0, 100.0, 90.0, 90.0, 90.0]", Helper.createDoubleList(arr).subList(0, 6).toString());
+    }
+
+    @Test
+    public void testMaxspeed() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("maxspeed", "10");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
+        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+
+        osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("maxspeed:forward", "10");
+        flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
+        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+    }
+
+    @Test
+    public void reverseEdge() {
+        Graph graph = new GraphBuilder(encodingManager).create();
+        EdgeIteratorState edge = graph.edge(0, 1);
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        osmWay.setTag("maxspeed:forward", "10");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        edge.setFlags(flags);
+
+        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
+        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+
+        edge = edge.detach(true);
+        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
+        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+    }
+
+    @Test
+    public void setAccess() {
+        Graph graph = new GraphBuilder(encodingManager).create();
+        EdgeIteratorState edge = graph.edge(0, 1);
+
+        edge.setFlags(encoder.setAccess(edge.getFlags(), true, true));
+        assertTrue(encoder.isForward(edge, motorVehicleInt));
+        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+
+        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+        assertTrue(encoder.isForward(edge, motorVehicleInt));
+        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+
+        edge = edge.detach(true);
+        assertFalse(encoder.isForward(edge, motorVehicleInt));
+        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+        edge = edge.detach(true);
+        assertTrue(encoder.isForward(edge, motorVehicleInt));
+        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+
+        edge.setFlags(encoder.setAccess(edge.getFlags(), false, false));
+        assertFalse(encoder.isForward(edge, motorVehicleInt));
+        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+    }
+
+    @Test
+    public void acceptWay() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "primary");
+        assertTrue(encoder.acceptWay(osmWay) != 0);
+
+        // important to filter out illegal highways to reduce the number of edges before adding them to the graph
+        osmWay.setTag("highway", "building");
+        assertTrue(encoder.acceptWay(osmWay) == 0);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
index 489588f574..dc9b365962 100755
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -20,37 +20,23 @@
 import com.graphhopper.reader.ReaderWay;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class EncodedDoubleValueTest
-{
+public class EncodedDoubleValueTest {
     @Test
-    public void testSetDoubleValue()
-    {
+    public void testSetDoubleValue() {
         EncodedDoubleValue instance = new EncodedDoubleValue("test", 6, 10, 0.01, 5, 10);
         assertEquals(10.12, instance.getDoubleValue(instance.setDoubleValue(0, 10.12)), 1e-4);
     }
 
     @Test
-    public void testMaxValue()
-    {
+    public void testMaxValue() {
         EncodedDoubleValue instance1 = new EncodedDoubleValue("test1", 0, 8, 0.5, 60, 100);
         long flags = instance1.setDoubleValue(0, instance1.getMaxValue());
         assertEquals(100, instance1.getDoubleValue(flags), 1e-1);
-    }
-
-    @Test
-    public void testMaxValueAndSwap()
-    {
-        EncodedDoubleValue instance1 = new EncodedDoubleValue("test1", 0, 8, 0.5, 60, 100);
-        EncodedDoubleValue instance2 = new EncodedDoubleValue("test2", 8, 8, 0.5, 60, 100);
-        long flags = instance2.setDoubleValue(instance1.setDoubleValue(0, 100), 90);
-        long expectedFlags = instance2.setDoubleValue(instance1.setDoubleValue(0, 90), 100);
-        long swappedFlags = instance1.swap(flags, instance2);
-        assertEquals(expectedFlags, swappedFlags);
 
         CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
         new EncodingManager(carEncoder);
@@ -65,8 +51,7 @@ public void testMaxValueAndSwap()
     }
 
     @Test
-    public void testUnsignedRightShift_issue417()
-    {
+    public void testUnsignedRightShift_issue417() {
         EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);
         Long flags = -72057594037927936L;
         assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
index 66f15396f2..28c5bdb897 100755
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
@@ -19,16 +19,14 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class EncodedValueTest
-{
+public class EncodedValueTest {
     @Test
-    public void testSetValue()
-    {
+    public void testSetValue() {
         EncodedValue instance = new EncodedValue("test", 6, 4, 1, 5, 10);
         assertEquals(10, instance.getValue(instance.setValue(0, 10)));
 
@@ -40,8 +38,7 @@ public void testSetValue()
     }
 
     @Test
-    public void testSwap()
-    {
+    public void testSwap() {
         EncodedValue instance1 = new EncodedValue("test1", 0, 10, 1, 5, 1000);
         EncodedValue instance2 = new EncodedValue("test2", 10, 10, 1, 5, 1000);
         long flags = instance2.setValue(instance1.setValue(0, 13), 874);
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 10d837b6ac..842bc303d9 100755
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -17,30 +17,25 @@
  */
 package com.graphhopper.routing.util;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.Rule;
-import org.junit.Test;
-
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.PriorityWeighting;
 import com.graphhopper.util.BitUtil;
+import org.junit.Rule;
+import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Peter Karich
  */
-public class EncodingManagerTest
-{
+public class EncodingManagerTest {
     @Rule
     public ExpectedException thrown = ExpectedException.none();
 
     @Test
-    public void testCompatibility()
-    {
+    public void testCompatibility() {
         EncodingManager manager = new EncodingManager("car,bike,foot");
         BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike");
         CarFlagEncoder car = (CarFlagEncoder) manager.getEncoder("car");
@@ -60,91 +55,74 @@ public void testCompatibility()
         assertEquals(foot3, foot2);
         assertEquals(foot3.hashCode(), foot2.hashCode());
 
-        try
-        {
+        try {
             new EncodingManager("car,car");
             assertTrue("do not allow duplicate flag encoders", false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testEncoderAcceptNoException()
-    {
+    public void testEncoderAcceptNoException() {
         EncodingManager manager = new EncodingManager("car");
         assertTrue(manager.supports("car"));
         assertFalse(manager.supports("foot"));
     }
 
     @Test
-    public void testEncoderWithWrongVersionIsRejected()
-    {
+    public void testEncoderWithWrongVersionIsRejected() {
         thrown.expect(IllegalArgumentException.class);
         EncodingManager manager = new EncodingManager("car|version=0");
     }
 
     @Test
-    public void testWrongEncoders()
-    {
-        try
-        {
+    public void testWrongEncoders() {
+        try {
             FootFlagEncoder foot = new FootFlagEncoder();
             new EncodingManager(foot, foot);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertEquals("You must not register a FlagEncoder (foot) twice!", ex.getMessage());
         }
 
-        try
-        {
+        try {
             new EncodingManager(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
             assertTrue(false);
-        } catch (Exception ex)
-        {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting more than 32 bits of way flags. Decrease the"));
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting 44 bits, more than 32 bits of way flags. Decrease the"));
         }
     }
 
     @Test
-    public void testToDetailsStringIncludesEncoderVersionNumber()
-    {
-        FlagEncoder encoder = new AbstractFlagEncoder(1, 2.0, 3)
-        {
+    public void testToDetailsStringIncludesEncoderVersionNumber() {
+        FlagEncoder encoder = new AbstractFlagEncoder(1, 2.0, 3) {
             @Override
-            public int getVersion()
-            {
+            public int getVersion() {
                 return 10;
             }
 
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return "new_encoder";
             }
 
             @Override
-            protected String getPropertiesString()
-            {
+            protected String getPropertiesString() {
                 return "my_properties";
             }
 
             @Override
-            public long handleRelationTags( ReaderRelation relation, long oldRelationFlags )
-            {
+            public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
                 return 0;
             }
 
             @Override
-            public long acceptWay( ReaderWay way )
-            {
+            public long acceptWay(ReaderWay way) {
                 return 0;
             }
 
             @Override
-            public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
-            {
+            public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
                 return 0;
             }
         };
@@ -155,39 +133,33 @@ public long handleWayTags( ReaderWay way, long allowed, long relationFlags )
     }
 
     @Test
-    public void testCombineRelations()
-    {
+    public void testCombineRelations() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "track");
         ReaderRelation osmRel = new ReaderRelation(1);
 
         BikeFlagEncoder defaultBike = new BikeFlagEncoder();
-        BikeFlagEncoder lessRelationCodes = new BikeFlagEncoder()
-        {
+        BikeFlagEncoder lessRelationCodes = new BikeFlagEncoder() {
             @Override
-            public int defineRelationBits( int index, int shift )
-            {
+            public int defineRelationBits(int index, int shift) {
                 relationCodeEncoder = new EncodedValue("RelationCode2", shift, 2, 1, 0, 3);
                 return shift + 2;
             }
 
             @Override
-            public long handleRelationTags( ReaderRelation relation, long oldRelFlags )
-            {
+            public long handleRelationTags(ReaderRelation relation, long oldRelFlags) {
                 if (relation.hasTag("route", "bicycle"))
                     return relationCodeEncoder.setValue(0, 2);
                 return relationCodeEncoder.setValue(0, 0);
             }
 
             @Override
-            protected int handlePriority( ReaderWay way, double wayTypeSpeed, int priorityFromRelation )
-            {
+            protected int handlePriority(ReaderWay way, double wayTypeSpeed, int priorityFromRelation) {
                 return priorityFromRelation;
             }
 
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return "less_relations_bits";
             }
         };
@@ -205,8 +177,7 @@ public String toString()
     }
 
     @Test
-    public void testMixBikeTypesAndRelationCombination()
-    {
+    public void testMixBikeTypesAndRelationCombination() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "track");
         osmWay.setTag("tracktype", "grade1");
@@ -230,8 +201,7 @@ public void testMixBikeTypesAndRelationCombination()
                 > mtbEncoder.getDouble(flags, PriorityWeighting.KEY));
     }
 
-    public void testFullBitMask()
-    {
+    public void testFullBitMask() {
         BitUtil bitUtil = BitUtil.LITTLE;
         EncodingManager manager = new EncodingManager("car,foot");
         AbstractFlagEncoder carr = (AbstractFlagEncoder) manager.getEncoder("car");
@@ -242,15 +212,13 @@ public void testFullBitMask()
     }
 
     @Test
-    public void testFixWayName()
-    {
+    public void testFixWayName() {
         assertEquals("B8, B12", EncodingManager.fixWayName("B8;B12"));
         assertEquals("B8, B12", EncodingManager.fixWayName("B8; B12"));
     }
 
     @Test
-    public void testCompatibilityBug()
-    {
+    public void testCompatibilityBug() {
         EncodingManager manager2 = new EncodingManager(FlagEncoderFactory.DEFAULT, "bike2", 8);
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "footway");
@@ -276,8 +244,7 @@ public void testCompatibilityBug()
     }
 
     @Test
-    public void testSupportFords()
-    {
+    public void testSupportFords() {
         // 1) no encoder crossing fords
         String flagEncodersStr = "car,bike,foot";
         EncodingManager manager = new EncodingManager(FlagEncoderFactory.DEFAULT, flagEncodersStr, 8);
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 6d9bd3d70c..10d8cfe9ff 100755
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -24,10 +24,9 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
-import java.text.DateFormat;
-
 import org.junit.Test;
 
+import java.text.DateFormat;
 import java.util.Date;
 
 import static org.junit.Assert.*;
@@ -35,21 +34,18 @@
 /**
  * @author Peter Karich
  */
-public class FootFlagEncoderTest
-{
+public class FootFlagEncoderTest {
     private final EncodingManager encodingManager = new EncodingManager("car,bike,foot");
     private final FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
 
     @Test
-    public void testGetSpeed()
-    {
+    public void testGetSpeed() {
         long fl = footEncoder.setProperties(10, true, true);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
     }
 
     @Test
-    public void testBasics()
-    {
+    public void testBasics() {
         long fl = footEncoder.flagsDefault(true, true);
         assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(fl), 1e-1);
 
@@ -59,8 +55,7 @@ public void testBasics()
     }
 
     @Test
-    public void testCombined()
-    {
+    public void testCombined() {
         FlagEncoder carEncoder = encodingManager.getEncoder("car");
         long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
@@ -75,8 +70,7 @@ public void testCombined()
     }
 
     @Test
-    public void testGraph()
-    {
+    public void testGraph() {
         Graph g = new GraphBuilder(encodingManager).create();
         g.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         g.edge(0, 2).setDistance(10).setFlags(footEncoder.setProperties(5, true, true));
@@ -88,8 +82,7 @@ public void testGraph()
     }
 
     @Test
-    public void testAccess()
-    {
+    public void testAccess() {
         ReaderWay way = new ReaderWay(1);
 
         way.setTag("highway", "motorway");
@@ -183,8 +176,7 @@ public void testAccess()
     }
 
     @Test
-    public void testRailPlatformIssue366()
-    {
+    public void testRailPlatformIssue366() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("railway", "platform");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
@@ -204,8 +196,7 @@ public void testRailPlatformIssue366()
     }
 
     @Test
-    public void testMixSpeedAndSafe()
-    {
+    public void testMixSpeedAndSafe() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "motorway");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
@@ -222,8 +213,7 @@ public void testMixSpeedAndSafe()
     }
 
     @Test
-    public void testPriority()
-    {
+    public void testPriority() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "cycleway");
         assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
@@ -274,8 +264,7 @@ public void testPriority()
     }
 
     @Test
-    public void testSlowHiking()
-    {
+    public void testSlowHiking() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("sac_scale", "hiking");
@@ -289,8 +278,7 @@ public void testSlowHiking()
     }
 
     @Test
-    public void testTurnFlagEncoding_noCostsAndRestrictions()
-    {
+    public void testTurnFlagEncoding_noCostsAndRestrictions() {
         long flags_r0 = footEncoder.getTurnFlags(true, 0);
         long flags_0 = footEncoder.getTurnFlags(false, 0);
 
@@ -311,8 +299,7 @@ public void testTurnFlagEncoding_noCostsAndRestrictions()
     }
 
     @Test
-    public void testBarrierAccess()
-    {
+    public void testBarrierAccess() {
         // by default allow access through the gate for bike & foot!
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("barrier", "gate");
@@ -348,8 +335,7 @@ public void testBarrierAccess()
     }
 
     @Test
-    public void handleWayTagsRoundabout()
-    {
+    public void handleWayTagsRoundabout() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("junction", "roundabout");
         way.setTag("highway", "tertiary");
@@ -357,8 +343,7 @@ public void handleWayTagsRoundabout()
         assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
-    public void testFord()
-    {
+    public void testFord() {
         // by default deny access through fords!
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("ford", "no");
diff --git a/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
index f9b5f31e2a..d79363ce4f 100755
--- a/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
@@ -19,19 +19,18 @@
 
 import com.graphhopper.reader.ReaderWay;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class HikeFlagEncoderTest
-{
+public class HikeFlagEncoderTest {
     private final EncodingManager encodingManager = new EncodingManager("car,hike");
     private final HikeFlagEncoder hikeEncoder = (HikeFlagEncoder) encodingManager.getEncoder("hike");
 
     @Test
-    public void testPriority()
-    {
+    public void testPriority() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "cycleway");
         assertEquals(PriorityCode.UNCHANGED.getValue(), hikeEncoder.handlePriority(way, 0));
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 5915d44454..8e84e1cd61 100755
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -22,9 +22,9 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
-import java.text.DateFormat;
 import org.junit.Test;
 
+import java.text.DateFormat;
 import java.util.Date;
 
 import static org.junit.Assert.*;
@@ -32,13 +32,11 @@
 /**
  * @author Peter Karich
  */
-public class MotorcycleFlagEncoderTest
-{
+public class MotorcycleFlagEncoderTest {
     private final EncodingManager em = new EncodingManager("motorcycle,foot");
     private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
-    private Graph initExampleGraph()
-    {
+    private Graph initExampleGraph() {
         GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true, new GraphExtension.NoOpExtension()).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
@@ -53,8 +51,7 @@ private Graph initExampleGraph()
     }
 
     @Test
-    public void testAccess()
-    {
+    public void testAccess() {
         ReaderWay way = new ReaderWay(1);
         assertFalse(encoder.acceptWay(way) > 0);
         way.setTag("highway", "service");
@@ -127,8 +124,7 @@ public void testAccess()
     }
 
     @Test
-    public void testHandleWayTags()
-    {
+    public void testHandleWayTags() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         long flags = encoder.acceptWay(way);
@@ -139,8 +135,7 @@ public void testHandleWayTags()
     }
 
     @Test
-    public void testSetSpeed0_issue367()
-    {
+    public void testSetSpeed0_issue367() {
         long flags = encoder.setProperties(10, true, true);
         flags = encoder.setSpeed(flags, 0);
 
@@ -151,8 +146,7 @@ public void testSetSpeed0_issue367()
     }
 
     @Test
-    public void testCurvature()
-    {
+    public void testCurvature() {
         Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
 
@@ -162,8 +156,7 @@ public void testCurvature()
         assertTrue("The bendiness of the straight road is smaller than the one of the curvy road", bendinessOfCurvyWay < bendinessOfStraightWay);
     }
 
-    private double getBendiness( EdgeIteratorState edge, double estimatedDistance )
-    {
+    private double getBendiness(EdgeIteratorState edge, double estimatedDistance) {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
         way.setTag("estimated_distance", estimatedDistance);
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index 1b7c427edf..92bb345d81 100755
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -20,24 +20,19 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-
-import static com.graphhopper.routing.util.PriorityCode.*;
-
 import org.junit.Test;
 
+import static com.graphhopper.routing.util.PriorityCode.*;
 import static org.junit.Assert.*;
 
-public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
-{
+public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
     @Override
-    protected BikeCommonFlagEncoder createBikeEncoder()
-    {
+    protected BikeCommonFlagEncoder createBikeEncoder() {
         return (BikeCommonFlagEncoder) new EncodingManager("bike,mtb").getEncoder("mtb");
     }
 
     @Test
-    public void testGetSpeed()
-    {
+    public void testGetSpeed() {
         long result = encoder.setProperties(10, true, true);
         assertEquals(10, encoder.getSpeed(result), 1e-1);
         ReaderWay way = new ReaderWay(1);
@@ -87,8 +82,7 @@ public void testGetSpeed()
 
     @Test
     @Override
-    public void testSacScale()
-    {
+    public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
@@ -106,8 +100,7 @@ public void testSacScale()
     }
 
     @Test
-    public void testHandleWayTags()
-    {
+    public void testHandleWayTags() {
         ReaderWay way = new ReaderWay(1);
         String wayType;
 
@@ -155,8 +148,7 @@ public void testHandleWayTags()
     }
 
     @Test
-    public void testHandleWayTagsInfluencedByRelation()
-    {
+    public void testHandleWayTagsInfluencedByRelation() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "track");
         long allowed = encoder.acceptBit;
@@ -209,8 +201,7 @@ public void testHandleWayTagsInfluencedByRelation()
     // Issue 407 : Always block kissing_gate execpt for mountainbikes
     @Test
     @Override
-    public void testBarrierAccess()
-    {
+    public void testBarrierAccess() {
         // kissing_gate without bicycle tag
         ReaderNode node = new ReaderNode(1, -1, -1);
         node.setTag("barrier", "kissing_gate");
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index 22e34ebd02..e620b5c0ee 100755
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,29 +19,25 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import org.junit.Test;
 
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author ratrun
  */
-public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
-{
+public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
     @Override
-    protected BikeCommonFlagEncoder createBikeEncoder()
-    {
+    protected BikeCommonFlagEncoder createBikeEncoder() {
         return (BikeCommonFlagEncoder) new EncodingManager("bike,racingbike").getEncoder("racingbike");
     }
 
     @Test
     @Override
-    public void testAvoidTunnel()
-    {
+    public void testAvoidTunnel() {
         // tunnel is not that bad for racing bike
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "residential");
@@ -58,8 +54,7 @@ public void testAvoidTunnel()
 
     @Test
     @Override
-    public void testService()
-    {
+    public void testService() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         assertEquals(12, encoder.getSpeed(way));
@@ -72,8 +67,7 @@ public void testService()
 
     @Test
     @Override
-    public void testSacScale()
-    {
+    public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "mountain_hiking");
@@ -98,8 +92,7 @@ public void testSacScale()
     }
 
     @Test
-    public void testGetSpeed()
-    {
+    public void testGetSpeed() {
         long result = encoder.setProperties(10, true, true);
         assertEquals(10, encoder.getSpeed(result), 1e-1);
         ReaderWay way = new ReaderWay(1);
@@ -133,8 +126,7 @@ public void testGetSpeed()
     }
 
     @Test
-    public void testHandleWayTagsInfluencedByRelation()
-    {
+    public void testHandleWayTagsInfluencedByRelation() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "track");
         assertEquals(PUSHING_SECTION_SPEED / 2, getSpeedFromFlags(osmWay), 1e-1);
@@ -205,8 +197,7 @@ public void testHandleWayTagsInfluencedByRelation()
     }
 
     @Test
-    public void testAvoidanceOfHighMaxSpeed()
-    {
+    public void testAvoidanceOfHighMaxSpeed() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "tertiary");
         osmWay.setTag("maxspeed", "50");
@@ -266,8 +257,7 @@ public void testAvoidanceOfHighMaxSpeed()
     }
 
     @Test
-    public void testClassBicycle()
-    {
+    public void testClassBicycle() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "tertiary");
         way.setTag("class:bicycle:roadcycling", "3");
diff --git a/core/src/test/java/com/graphhopper/routing/util/tour/SinglePointTourTest.java b/core/src/test/java/com/graphhopper/routing/util/tour/SinglePointTourTest.java
index 39a271611f..f9b9a4bcbe 100755
--- a/core/src/test/java/com/graphhopper/routing/util/tour/SinglePointTourTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/tour/SinglePointTourTest.java
@@ -17,20 +17,19 @@
  */
 package com.graphhopper.routing.util.tour;
 
-import java.util.Random;
 import org.junit.Test;
 
+import java.util.Random;
+
 import static junit.framework.TestCase.assertEquals;
 import static junit.framework.TestCase.assertTrue;
 
 /**
  * @author Robin Boldt
  */
-public class SinglePointTourTest
-{
+public class SinglePointTourTest {
     @Test
-    public void testBasics()
-    {
+    public void testBasics() {
         SinglePointTour tour = new SinglePointTour(new Random(0), 100);
         assertEquals(1, tour.getNumberOfGeneratedPoints());
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/AbstractWeightingTest.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java
rename to core/src/test/java/com/graphhopper/routing/weighting/AbstractWeightingTest.java
index 94472ca862..5587d168e6 100755
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/AbstractWeightingTest.java
@@ -15,20 +15,19 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
- *
  * @author Peter Karich
  */
-public class AbstractWeightingTest
-{
+public class AbstractWeightingTest {
     @Test
-    public void testToString()
-    {
+    public void testToString() {
         assertTrue(AbstractWeighting.isValidName("blup"));
         assertTrue(AbstractWeighting.isValidName("blup_a"));
         assertTrue(AbstractWeighting.isValidName("blup|a"));
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
similarity index 53%
rename from core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
rename to core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
index 7429253200..d66bbb1f3f 100755
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
@@ -15,86 +15,85 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
 import com.graphhopper.routing.VirtualEdgeIteratorState;
-import com.graphhopper.util.*;
+import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.Parameters.Routing;
 import org.junit.Test;
 
+import static com.graphhopper.util.GHUtility.createMockedEdgeIteratorState;
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class FastestWeightingTest
-{
+public class FastestWeightingTest {
     private final FlagEncoder encoder = new EncodingManager("car").getEncoder("car");
 
     @Test
-    public void testMinWeightHasSameUnitAs_getWeight()
-    {
+    public void testMinWeightHasSameUnitAs_getWeight() {
         Weighting instance = new FastestWeighting(encoder);
         long flags = encoder.setProperties(encoder.getMaxSpeed(), true, true);
-        assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
+        assertEquals(instance.getMinWeight(10), instance.calcWeight(createMockedEdgeIteratorState(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     @Test
-    public void testWeightWrongHeading()
-    {
-        Weighting instance = new FastestWeighting(encoder, new PMap().put(Parameters.Routing.HEADING_PENALTY, "100"));
+    public void testWeightWrongHeading() {
+        Weighting instance = new FastestWeighting(encoder, new PMap().
+                put(Parameters.Routing.HEADING_PENALTY, "100"));
         VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
                 encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
         double time = instance.calcWeight(virtEdge, false, 0);
 
-        virtEdge.setVirtualEdgePreference(true);
+        virtEdge.setUnfavored(true);
         // heading penalty on edge
         assertEquals(time + 100, instance.calcWeight(virtEdge, false, 0), 1e-8);
         // only after setting it
-        virtEdge.setVirtualEdgePreference(true);
+        virtEdge.setUnfavored(true);
         assertEquals(time + 100, instance.calcWeight(virtEdge, true, 0), 1e-8);
         // but not after releasing it
-        virtEdge.setVirtualEdgePreference(false);
+        virtEdge.setUnfavored(false);
         assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
-        
+
         // test default penalty
-        virtEdge.setVirtualEdgePreference(true);
+        virtEdge.setUnfavored(true);
         instance = new FastestWeighting(encoder);
         assertEquals(time + Routing.DEFAULT_HEADING_PENALTY, instance.calcWeight(virtEdge, false, 0), 1e-8);
     }
 
     @Test
-    public void testSpeed0()
-    {
+    public void testSpeed0() {
         Weighting instance = new FastestWeighting(encoder);
 
-        assertEquals(1.0 / 0, instance.calcWeight(createEdge(10, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
+        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(10, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
 
         // 0 / 0 returns NaN but calcWeight should not return NaN!
-        assertEquals(1.0 / 0, instance.calcWeight(createEdge(0, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
+        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(0, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
-    EdgeIterator createEdge( final double distance, final long flags )
-    {
-        return new GHUtility.DisabledEdgeIterator()
-        {
-            @Override
-            public double getDistance()
-            {
-                return distance;
-            }
+    @Test
+    public void testTime() {
+        FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
+        GraphHopperStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
+        Weighting w = new FastestWeighting(tmpEnc);
+
+        long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(100000, flags);
 
-            @Override
-            public long getFlags()
-            {
-                return flags;
-            }
+        assertEquals(375 * 60 * 1000, w.calcMillis(edge, false, EdgeIterator.NO_EDGE));
+        assertEquals(600 * 60 * 1000, w.calcMillis(edge, true, EdgeIterator.NO_EDGE));
 
-            @Override
-            public boolean getBoolean( int key, boolean reverse, boolean _default )
-            {
-                return _default;
-            }
-        };
+        g.close();
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/ShortFastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
similarity index 72%
rename from core/src/test/java/com/graphhopper/routing/util/ShortFastestWeightingTest.java
rename to core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
index 5c071b5322..5022920a0d 100755
--- a/core/src/test/java/com/graphhopper/routing/util/ShortFastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
@@ -15,9 +15,14 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.routing.weighting;
 
-import com.graphhopper.util.*;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -26,13 +31,11 @@
 /**
  * @author Peter Karich
  */
-public class ShortFastestWeightingTest
-{
+public class ShortFastestWeightingTest {
     private final FlagEncoder encoder = new EncodingManager("car").getEncoder("car");
 
     @Test
-    public void testShort()
-    {
+    public void testShort() {
         EdgeIteratorState edge = createEdge(10, encoder.setProperties(50, true, true));
         Weighting instance = new ShortFastestWeighting(encoder, 0.03);
         assertEquals(1.02, instance.calcWeight(edge, false, EdgeIterator.NO_EDGE), 1e-8);
@@ -43,36 +46,28 @@ public void testShort()
     }
 
     @Test
-    public void testTooSmall()
-    {
-        try
-        {
+    public void testTooSmall() {
+        try {
             new ShortFastestWeighting(encoder, new PMap("short_fastest.distance_factor=0|short_fastest.time_factor=0"));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
-    EdgeIterator createEdge( final double distance, final long flags )
-    {
-        return new GHUtility.DisabledEdgeIterator()
-        {
+    EdgeIterator createEdge(final double distance, final long flags) {
+        return new GHUtility.DisabledEdgeIterator() {
             @Override
-            public double getDistance()
-            {
+            public double getDistance() {
                 return distance;
             }
 
             @Override
-            public long getFlags()
-            {
+            public long getFlags() {
                 return flags;
             }
 
             @Override
-            public boolean getBoolean( int key, boolean reverse, boolean _default )
-            {
+            public boolean getBool(int key, boolean _default) {
                 return _default;
             }
         };
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index 693417d76a..da7ff83621 100755
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -19,24 +19,23 @@
 
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.Helper;
-import java.io.File;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class NameIndexTest
-{
+public class NameIndexTest {
     @Test
-    public void testNoErrorOnLargeName()
-    {
+    public void testNoErrorOnLargeName() {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         // 127 => bytes.length == 254
         String str = "";
-        for (int i = 0; i < 127; i++)
-        {
+        for (int i = 0; i < 127; i++) {
             str += "ß";
         }
         long result = index.put(str);
@@ -44,8 +43,7 @@ public void testNoErrorOnLargeName()
     }
 
     @Test
-    public void testPut()
-    {
+    public void testPut() {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         long result = index.put("Something Streetä");
         assertEquals("Something Streetä", index.get(result));
@@ -63,8 +61,7 @@ public void testPut()
     }
 
     @Test
-    public void testCreate()
-    {
+    public void testCreate() {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         String str1 = "nice";
         long pointer1 = index.put(str1);
@@ -78,15 +75,13 @@ public void testCreate()
     }
 
     @Test
-    public void testTooLongNameNoError()
-    {
+    public void testTooLongNameNoError() {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         // WTH are they doing in OSM? There are exactly two names in the full planet export which violates this limitation!
         index.put("Бухарестская улица (http://ru.wikipedia.org/wiki/%D0%91%D1%83%D1%85%D0%B0%D1%80%D0%B5%D1%81%D1%82%D1%81%D0%BA%D0%B0%D1%8F_%D1%83%D0%BB%D0%B8%D1%86%D0%B0_(%D0%A1%D0%B0%D0%BD%D0%BA%D1%82-%D0%9F%D0%B5%D1%82%D0%B5%D1%80%D0%B1%D1%83%D1%80%D0%B3))");
 
         String str = "sdfsdfds";
-        for (int i = 0; i < 256 * 3; i++)
-        {
+        for (int i = 0; i < 256 * 3; i++) {
             str += "Б";
         }
         index.put(str);
@@ -94,8 +89,7 @@ public void testTooLongNameNoError()
     }
 
     @Test
-    public void testFlush()
-    {
+    public void testFlush() {
         String location = "./target/nameindex-store";
         Helper.removeDir(new File(location));
 
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index 77baf39bb1..61472da135 100755
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -18,56 +18,49 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
-
-import java.io.File;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.io.File;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public abstract class AbstractDirectoryTester
-{
+public abstract class AbstractDirectoryTester {
     protected String location = "./target/tmp/dir";
     private DataAccess da;
 
     abstract Directory createDir();
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         if (da != null)
             da.close();
         Helper.removeDir(new File(location));
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         Helper.removeDir(new File(location));
     }
 
     @Test
-    public void testRequestedDataAccessHasToBeTheIdenticalType()
-    {
+    public void testRequestedDataAccessHasToBeTheIdenticalType() {
         Directory dir = createDir();
         da = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, false));
-        try
-        {
+        try {
             dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, true));
             assertFalse(true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testSynched()
-    {
+    public void testSynched() {
         Directory dir = createDir();
         DataAccess da1 = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, true, false));
         da = dir.find("testing_synched", new DAType(DAType.MemRef.HEAP, false, false, true, true));
@@ -76,8 +69,7 @@ public void testSynched()
     }
 
     @Test
-    public void testNoDuplicates()
-    {
+    public void testNoDuplicates() {
         Directory dir = createDir();
         DataAccess da1 = dir.find("testing");
         DataAccess da2 = dir.find("testing");
@@ -87,8 +79,7 @@ public void testNoDuplicates()
     }
 
     @Test
-    public void testNoErrorForDACreate()
-    {
+    public void testNoErrorForDACreate() {
         Directory dir = createDir();
         da = dir.find("testing");
         da.create(100);
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 06e5db059f..0a2e98f8df 100755
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -17,46 +17,75 @@
  */
 package com.graphhopper.storage;
 
-import static com.graphhopper.util.GHUtility.count;
-import static org.junit.Assert.*;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.Closeable;
 import java.io.File;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.routing.util.*;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.BBox;
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.*;
 
 /**
  * Abstract test class to be extended for implementations of the Graph interface. Graphs
  * implementing GraphStorage should extend GraphStorageTest instead.
  * <p>
+ *
  * @author Peter Karich
  */
-public abstract class AbstractGraphStorageTester
-{
+public abstract class AbstractGraphStorageTester {
     private final String locationParent = "./target/graphstorage";
     protected int defaultSize = 100;
     protected String defaultGraphLoc = "./target/graphstorage/default";
     protected EncodingManager encodingManager = new EncodingManager("car,foot");
     protected CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
     protected FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
+    protected GraphHopperStorage graph;
     EdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
     EdgeFilter carInFilter = new DefaultEdgeFilter(carEncoder, true, false);
     EdgeExplorer carOutExplorer;
     EdgeExplorer carInExplorer;
     EdgeExplorer carAllExplorer;
-    protected GraphHopperStorage graph;
 
-    protected GraphHopperStorage createGHStorage()
-    {
+    public static void assertPList(PointList expected, PointList list) {
+        assertEquals("size of point lists is not equal", expected.getSize(), list.getSize());
+        for (int i = 0; i < expected.getSize(); i++) {
+            assertEquals(expected.getLatitude(i), list.getLatitude(i), 1e-4);
+            assertEquals(expected.getLongitude(i), list.getLongitude(i), 1e-4);
+        }
+    }
+
+    public static int getIdOf(Graph g, double latitude) {
+        int s = g.getNodes();
+        NodeAccess na = g.getNodeAccess();
+        for (int i = 0; i < s; i++) {
+            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    public static int getIdOf(Graph g, double latitude, double longitude) {
+        int s = g.getNodes();
+        NodeAccess na = g.getNodeAccess();
+        for (int i = 0; i < s; i++) {
+            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4 && Math.abs(na.getLongitude(i) - longitude) < 1e-4) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("did not find node with location " + (float) latitude + "," + (float) longitude);
+    }
+
+    protected GraphHopperStorage createGHStorage() {
         GraphHopperStorage g = createGHStorage(defaultGraphLoc, false);
         carOutExplorer = g.createEdgeExplorer(carOutFilter);
         carInExplorer = g.createEdgeExplorer(carInFilter);
@@ -64,29 +93,25 @@ protected GraphHopperStorage createGHStorage()
         return g;
     }
 
-    abstract GraphHopperStorage createGHStorage( String location, boolean is3D );
+    abstract GraphHopperStorage createGHStorage(String location, boolean is3D);
 
-    protected final GraphHopperStorage newRAMGHStorage()
-    {
+    protected final GraphHopperStorage newRAMGHStorage() {
         return new GraphHopperStorage(new RAMDirectory(), encodingManager, false, new GraphExtension.NoOpExtension());
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         Helper.removeDir(new File(locationParent));
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.close((Closeable) graph);
         Helper.removeDir(new File(locationParent));
     }
 
     @Test
-    public void testSetTooBigDistance_435()
-    {
+    public void testSetTooBigDistance_435() {
         graph = createGHStorage();
 
         double maxDist = EdgeAccess.MAX_DIST;
@@ -94,22 +119,18 @@ public void testSetTooBigDistance_435()
         assertEquals(maxDist, edge1.getDistance(), 1);
 
         // max out should NOT lead to infinity as this leads fast to NaN!
-        try
-        {
+        try {
             graph.edge(0, 2, maxDist + 1, true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Distance too large"));
         }
     }
 
     @Test
-    public void testSetNodes()
-    {
+    public void testSetNodes() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < defaultSize * 2; i++)
-        {
+        for (int i = 0; i < defaultSize * 2; i++) {
             na.setNode(i, 2 * i, 3 * i);
         }
         graph.edge(defaultSize + 1, defaultSize + 2, 10, true);
@@ -118,16 +139,14 @@ public void testSetNodes()
     }
 
     @Test
-    public void testPropertiesWithNoInit()
-    {
+    public void testPropertiesWithNoInit() {
         graph = createGHStorage();
         assertEquals(0, graph.edge(0, 1).getFlags());
         assertEquals(0, graph.edge(0, 2).getDistance(), 1e-6);
     }
 
     @Test
-    public void testCreateLocation()
-    {
+    public void testCreateLocation() {
         graph = createGHStorage();
         graph.edge(3, 1, 50, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(1)));
@@ -137,8 +156,7 @@ public void testCreateLocation()
     }
 
     @Test
-    public void testEdges()
-    {
+    public void testEdges() {
         graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(2)));
@@ -150,8 +168,7 @@ public void testEdges()
     }
 
     @Test
-    public void testUnidirectional()
-    {
+    public void testUnidirectional() {
         graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
@@ -184,8 +201,7 @@ public void testUnidirectional()
     }
 
     @Test
-    public void testUnidirectionalEdgeFilter()
-    {
+    public void testUnidirectionalEdgeFilter() {
         graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
@@ -220,8 +236,7 @@ public void testUnidirectionalEdgeFilter()
     }
 
     @Test
-    public void testUpdateUnidirectional()
-    {
+    public void testUpdateUnidirectional() {
         graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
@@ -244,8 +259,7 @@ public void testUpdateUnidirectional()
     }
 
     @Test
-    public void testClone()
-    {
+    public void testClone() {
         graph = createGHStorage();
         graph.edge(1, 2, 10, true);
         NodeAccess na = graph.getNodeAccess();
@@ -265,8 +279,7 @@ public void testClone()
     }
 
     @Test
-    public void testCopyProperties()
-    {
+    public void testCopyProperties() {
         graph = createGHStorage();
         EdgeIteratorState edge = graph.edge(1, 3, 10, false).setName("testing").setWayGeometry(Helper.createPointList(1, 2));
 
@@ -279,8 +292,7 @@ public void testCopyProperties()
     }
 
     @Test
-    public void testGetLocations()
-    {
+    public void testGetLocations() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
@@ -299,31 +311,26 @@ public void testGetLocations()
     }
 
     @Test
-    public void testCopyTo()
-    {
+    public void testCopyTo() {
         graph = createGHStorage();
         initExampleGraph(graph);
         GraphHopperStorage gs = newRAMGHStorage();
         gs.setSegmentSize(8000);
         gs.create(10);
-        try
-        {
+        try {
             graph.copyTo(gs);
             checkExampleGraph(gs);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             ex.printStackTrace();
             assertTrue(ex.toString(), false);
         }
 
-        try
-        {
+        try {
             Helper.close((Closeable) graph);
             graph = createGHStorage();
             gs.copyTo(graph);
             checkExampleGraph(graph);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             ex.printStackTrace();
             assertTrue(ex.toString(), false);
         }
@@ -331,15 +338,13 @@ public void testCopyTo()
     }
 
     @Test
-    public void testAddLocation()
-    {
+    public void testAddLocation() {
         graph = createGHStorage();
         initExampleGraph(graph);
         checkExampleGraph(graph);
     }
 
-    protected void initExampleGraph( Graph g )
-    {
+    protected void initExampleGraph(Graph g) {
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 38.33f, 135.3f);
@@ -354,8 +359,7 @@ protected void initExampleGraph( Graph g )
         g.edge(0, 5, 212, true);
     }
 
-    private void checkExampleGraph( Graph graph )
-    {
+    private void checkExampleGraph(Graph graph) {
         NodeAccess na = graph.getNodeAccess();
         assertEquals(12f, na.getLatitude(0), 1e-6);
         assertEquals(23f, na.getLongitude(0), 1e-6);
@@ -371,19 +375,16 @@ private void checkExampleGraph( Graph graph )
 
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(carOutExplorer.setBaseNode((1))));
         assertEquals(GHUtility.asSet(5, 4, 3, 2, 1), GHUtility.getNeighbors(carOutExplorer.setBaseNode(0)));
-        try
-        {
+        try {
             assertEquals(0, count(carOutExplorer.setBaseNode(6)));
             // for now return empty iterator
             // assertFalse(true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testDirectional()
-    {
+    public void testDirectional() {
         graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         graph.edge(2, 3, 12, false);
@@ -413,8 +414,7 @@ public void testDirectional()
     }
 
     @Test
-    public void testDozendEdges()
-    {
+    public void testDozendEdges() {
         graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         assertEquals(1, count(carAllExplorer.setBaseNode(1)));
@@ -446,8 +446,7 @@ public void testDozendEdges()
     }
 
     @Test
-    public void testCheckFirstNode()
-    {
+    public void testCheckFirstNode() {
         graph = createGHStorage();
 
         assertEquals(0, count(carAllExplorer.setBaseNode(1)));
@@ -456,8 +455,7 @@ public void testCheckFirstNode()
     }
 
     @Test
-    public void testDeleteNodeForUnidir()
-    {
+    public void testDeleteNodeForUnidir() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(10, 10, 1);
@@ -488,19 +486,16 @@ public void testDeleteNodeForUnidir()
     }
 
     @Test
-    public void testComplexDeleteNode()
-    {
+    public void testComplexDeleteNode() {
         testDeleteNodes(21);
     }
 
     @Test
-    public void testComplexDeleteNode2()
-    {
+    public void testComplexDeleteNode2() {
         testDeleteNodes(6);
     }
 
-    public void testDeleteNodes( int fillToSize )
-    {
+    public void testDeleteNodes(int fillToSize) {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
@@ -511,15 +506,12 @@ public void testDeleteNodes( int fillToSize )
         na.setNode(5, 2.5f, 1);
 
         int deleted = 2;
-        for (int i = 6; i < fillToSize; i++)
-        {
+        for (int i = 6; i < fillToSize; i++) {
             na.setNode(i, i * 1.5, i * 1.6);
-            if (i % 3 == 0)
-            {
+            if (i % 3 == 0) {
                 graph.markNodeRemoved(i);
                 deleted++;
-            } else
-            {
+            } else {
                 // connect to
                 // ... a deleted node
                 graph.edge(i, 0, 10 * i, true);
@@ -559,11 +551,9 @@ public void testDeleteNodes( int fillToSize )
         assertFalse(containsLatitude(graph, carAllExplorer.setBaseNode(id3), 12));
     }
 
-    public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
-    {
+    public boolean containsLatitude(Graph g, EdgeIterator iter, double latitude) {
         NodeAccess na = g.getNodeAccess();
-        while (iter.next())
-        {
+        while (iter.next()) {
             if (Math.abs(na.getLatitude(iter.getAdjNode()) - latitude) < 1e-4)
                 return true;
         }
@@ -571,8 +561,7 @@ public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
     }
 
     @Test
-    public void testSimpleDelete()
-    {
+    public void testSimpleDelete() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
@@ -602,8 +591,7 @@ public void testSimpleDelete()
     }
 
     @Test
-    public void testSimpleDelete2()
-    {
+    public void testSimpleDelete2() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         assertEquals(-1, getIdOf(graph, 12));
@@ -651,8 +639,7 @@ public void testSimpleDelete2()
     }
 
     @Test
-    public void testSimpleDelete3()
-    {
+    public void testSimpleDelete3() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(7, 7, 1);
@@ -683,8 +670,7 @@ public void testSimpleDelete3()
     }
 
     @Test
-    public void testDeleteAndOptimize()
-    {
+    public void testDeleteAndOptimize() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(20, 10, 10);
@@ -695,8 +681,7 @@ public void testDeleteAndOptimize()
     }
 
     @Test
-    public void testBounds()
-    {
+    public void testBounds() {
         graph = createGHStorage();
         BBox b = graph.getBounds();
         assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
@@ -714,8 +699,7 @@ public void testBounds()
     }
 
     @Test
-    public void testFlags()
-    {
+    public void testFlags() {
         graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(carEncoder.setProperties(100, true, true));
         graph.edge(2, 3).setDistance(10).setFlags(carEncoder.setProperties(10, true, false));
@@ -728,18 +712,15 @@ public void testFlags()
         assertTrue(iter.next());
         assertEquals(carEncoder.setProperties(10, true, false), iter.getFlags());
 
-        try
-        {
+        try {
             graph.edge(0, 1).setDistance(-1);
             assertTrue(false);
-        } catch (IllegalArgumentException ex)
-        {
+        } catch (IllegalArgumentException ex) {
         }
     }
 
     @Test
-    public void testEdgeProperties()
-    {
+    public void testEdgeProperties() {
         graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(0, 2, 20, true);
@@ -771,41 +752,34 @@ public void testEdgeProperties()
         graph.optimize();
 
         // throw exception if accessing deleted edge
-        try
-        {
+        try {
             graph.getEdgeIteratorState(iter1.getEdge(), -1);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testCreateDuplicateEdges()
-    {
+    public void testCreateDuplicateEdges() {
         graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         graph.edge(2, 3, 12, true);
         graph.edge(2, 3, 13, false);
         assertEquals(3, GHUtility.count(carOutExplorer.setBaseNode(2)));
 
-        // no exception        
+        // no exception
         graph.getEdgeIteratorState(1, 3);
 
         // raise exception
-        try
-        {
+        try {
             graph.getEdgeIteratorState(4, 3);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
-        try
-        {
+        try {
             graph.getEdgeIteratorState(-1, 3);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
 
         EdgeIterator iter = carOutExplorer.setBaseNode(2);
@@ -827,16 +801,14 @@ public void testCreateDuplicateEdges()
     }
 
     @Test
-    public void testIdenticalNodes()
-    {
+    public void testIdenticalNodes() {
         graph = createGHStorage();
         graph.edge(0, 0, 100, true);
         assertEquals(1, GHUtility.count(carAllExplorer.setBaseNode(0)));
     }
 
     @Test
-    public void testIdenticalNodes2()
-    {
+    public void testIdenticalNodes2() {
         graph = createGHStorage();
         graph.edge(0, 0, 100, false);
         graph.edge(0, 0, 100, false);
@@ -844,8 +816,7 @@ public void testIdenticalNodes2()
     }
 
     @Test
-    public void testEdgeReturn()
-    {
+    public void testEdgeReturn() {
         graph = createGHStorage();
         EdgeIteratorState iter = graph.edge(4, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false));
         assertEquals(4, iter.getBaseNode());
@@ -856,8 +827,7 @@ public void testEdgeReturn()
     }
 
     @Test
-    public void testPillarNodes()
-    {
+    public void testPillarNodes() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.01, 0.01);
@@ -906,8 +876,7 @@ public void testPillarNodes()
     }
 
     @Test
-    public void testFootMix()
-    {
+    public void testFootMix() {
         graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         graph.edge(0, 2).setDistance(10).setFlags(carEncoder.setProperties(10, true, true));
@@ -918,8 +887,7 @@ public void testFootMix()
     }
 
     @Test
-    public void testGetAllEdges()
-    {
+    public void testGetAllEdges() {
         graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         graph.edge(3, 1, 1, false);
@@ -946,8 +914,7 @@ public void testGetAllEdges()
     }
 
     @Test
-    public void testGetAllEdgesWithDelete()
-    {
+    public void testGetAllEdgesWithDelete() {
         graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0, 5);
@@ -982,47 +949,8 @@ public void testGetAllEdgesWithDelete()
         assertFalse(iter.next());
     }
 
-    public static void assertPList( PointList expected, PointList list )
-    {
-        assertEquals("size of point lists is not equal", expected.getSize(), list.getSize());
-        for (int i = 0; i < expected.getSize(); i++)
-        {
-            assertEquals(expected.getLatitude(i), list.getLatitude(i), 1e-4);
-            assertEquals(expected.getLongitude(i), list.getLongitude(i), 1e-4);
-        }
-    }
-
-    public static int getIdOf( Graph g, double latitude )
-    {
-        int s = g.getNodes();
-        NodeAccess na = g.getNodeAccess();
-        for (int i = 0; i < s; i++)
-        {
-            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4)
-            {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    public static int getIdOf( Graph g, double latitude, double longitude )
-    {
-        int s = g.getNodes();
-        NodeAccess na = g.getNodeAccess();
-        for (int i = 0; i < s; i++)
-        {
-            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4 && Math.abs(na.getLongitude(i) - longitude) < 1e-4)
-            {
-                return i;
-            }
-        }
-        throw new IllegalArgumentException("did not find node with location " + (float) latitude + "," + (float) longitude);
-    }
-
     @Test
-    public void testNameIndex()
-    {
+    public void testNameIndex() {
         graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         iter1.setName("named street1");
@@ -1035,15 +963,12 @@ public void testNameIndex()
     }
 
     @Test
-    public void test8BytesFlags()
-    {
+    public void test8BytesFlags() {
         Directory dir = new RAMDirectory();
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
-        list.add(new TmpCarFlagEncoder(29, 0.001, 0)
-        {
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0) {
             @Override
-            public String toString()
-            {
+            public String toString() {
                 return "car2";
             }
         });
@@ -1080,8 +1005,7 @@ public String toString()
     }
 
     @Test
-    public void testEnabledElevation()
-    {
+    public void testEnabledElevation() {
         graph = createGHStorage(defaultGraphLoc, true);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
@@ -1097,8 +1021,34 @@ public void testEnabledElevation()
     }
 
     @Test
-    public void testDetachEdge()
-    {
+    public void testDontGrowOnUpdate() throws IOException {
+        graph = createGHStorage(defaultGraphLoc, true);
+        NodeAccess na = graph.getNodeAccess();
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
+
+        EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
+        final BaseGraph baseGraph = (BaseGraph) graph.getBaseGraph();
+        assertEquals(4, baseGraph.getMaxGeoRef());
+        iter2.setWayGeometry(Helper.createPointList3D(1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8, 9));
+        assertEquals(4 + (1 + 12), baseGraph.getMaxGeoRef());
+        iter2.setWayGeometry(Helper.createPointList3D(1, 2, 3, 3, 4, 5, 5, 6, 7));
+        assertEquals(4 + (1 + 12), baseGraph.getMaxGeoRef());
+        iter2.setWayGeometry(Helper.createPointList3D(1, 2, 3, 3, 4, 5));
+        assertEquals(4 + (1 + 12), baseGraph.getMaxGeoRef());
+        iter2.setWayGeometry(Helper.createPointList3D(1, 2, 3));
+        assertEquals(4 + (1 + 12), baseGraph.getMaxGeoRef());
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
+        assertEquals(4 + (1 + 12) + (1 + 6), baseGraph.getMaxGeoRef());
+        EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
+        assertEquals(4 + (1 + 12) + (1 + 6) + (1 + 6), baseGraph.getMaxGeoRef());
+    }
+
+    @Test
+    public void testDetachEdge() {
         graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         long flags = carEncoder.setProperties(10, true, false);
@@ -1106,13 +1056,11 @@ public void testDetachEdge()
         graph.edge(1, 2, 2, true);
 
         EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(0);
-        try
-        {
+        try {
             // currently not possible to detach without next, without introducing a new property inside EdgeIterable
             iter.detach(false);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
 
         iter.next();
@@ -1149,10 +1097,8 @@ public void testDetachEdge()
         assertEquals(edgeState20.getFlags(), edgeState33.detach(true).getFlags());
     }
 
-    static class TmpCarFlagEncoder extends CarFlagEncoder
-    {
-        public TmpCarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-        {
+    static class TmpCarFlagEncoder extends CarFlagEncoder {
+        public TmpCarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
             super(speedBits, speedFactor, maxTurnCosts);
         }
     }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
index 59ad282534..b8816282d3 100755
--- a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -19,41 +19,35 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.File;
 
-import org.junit.After;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import org.junit.Before;
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public abstract class AbstractLockFactoryTester
-{
+public abstract class AbstractLockFactoryTester {
     protected final File lockDir = new File("./target/lockingtest/");
 
     protected abstract LockFactory createLockFactory();
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         lockDir.mkdirs();
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.removeDir(lockDir);
     }
 
     @Test
-    public void testObtain()
-    {
+    public void testObtain() {
         LockFactory instance = createLockFactory();
         instance.setLockDir(lockDir);
         Lock lock = instance.create("test", true);
@@ -70,14 +64,12 @@ public void testObtain()
         // although it is locked do not allow release:
         // lock2.release();
         // assertTrue(lock.isLocked());
-
         lock.release();
         assertFalse(lock.isLocked());
     }
 
     @Test
-    public void testForceDelete()
-    {
+    public void testForceDelete() {
         LockFactory instance = createLockFactory();
         instance.setLockDir(lockDir);
         Lock lock = instance.create("testlock", true);
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index a9fae439f4..1c79a66532 100755
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -19,32 +19,28 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.File;
 import java.nio.ByteOrder;
 
-import org.junit.After;
-
 import static org.junit.Assert.*;
 
-import org.junit.Before;
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public abstract class DataAccessTest
-{
-    protected ByteOrder defaultOrder = ByteOrder.LITTLE_ENDIAN;
+public abstract class DataAccessTest {
     private final File folder = new File("./target/tmp/da");
+    protected ByteOrder defaultOrder = ByteOrder.LITTLE_ENDIAN;
     protected String directory;
     protected String name = "dataacess";
 
-    public abstract DataAccess createDataAccess( String location );
+    public abstract DataAccess createDataAccess(String location);
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         if (!Helper.removeDir(folder))
             throw new IllegalStateException("cannot delete folder " + folder);
 
@@ -53,14 +49,12 @@ public void setUp()
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.removeDir(folder);
     }
 
     @Test
-    public void testLoadFlush()
-    {
+    public void testLoadFlush() {
         DataAccess da = createDataAccess(name);
         assertFalse(da.loadExisting());
         da.create(300);
@@ -78,12 +72,10 @@ public void testLoadFlush()
         da.close();
 
         // cannot load data if already closed
-        try
-        {
+        try {
             da.loadExisting();
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertEquals("already closed", ex.getMessage());
         }
 
@@ -94,23 +86,19 @@ public void testLoadFlush()
     }
 
     @Test
-    public void testExceptionIfNoEnsureCapacityWasCalled()
-    {
+    public void testExceptionIfNoEnsureCapacityWasCalled() {
         DataAccess da = createDataAccess(name);
         assertFalse(da.loadExisting());
         // throw some undefined exception if no ensureCapacity was called
-        try
-        {
+        try {
             da.setInt(2 * 4, 321);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testLoadClose()
-    {
+    public void testLoadClose() {
         DataAccess da = createDataAccess(name);
         da.create(300);
         da.setInt(2 * 4, 321);
@@ -124,8 +112,7 @@ public void testLoadClose()
     }
 
     @Test
-    public void testHeader()
-    {
+    public void testHeader() {
         DataAccess da = createDataAccess(name);
         da.create(300);
         da.setHeader(7 * 4, 123);
@@ -145,8 +132,7 @@ public void testHeader()
     }
 
     @Test
-    public void testEnsureCapacity()
-    {
+    public void testEnsureCapacity() {
         DataAccess da = createDataAccess(name);
         da.create(128);
         da.setInt(31 * 4, 200);
@@ -167,8 +153,7 @@ public void testEnsureCapacity()
     }
 
     @Test
-    public void testCopy()
-    {
+    public void testCopy() {
         DataAccess da1 = createDataAccess(name);
         da1.create(1001 * 4);
         da1.setHeader(4, 12);
@@ -195,8 +180,7 @@ public void testCopy()
     }
 
     @Test
-    public void testSegments()
-    {
+    public void testSegments() {
         DataAccess da = createDataAccess(name);
         da.setSegmentSize(128);
         da.create(10);
@@ -217,8 +201,7 @@ public void testSegments()
     }
 
     @Test
-    public void testTrimTo()
-    {
+    public void testTrimTo() {
         DataAccess da = createDataAccess(name);
         da.setSegmentSize(128);
         da.create(128 * 11);
@@ -254,8 +237,7 @@ public void testTrimTo()
     }
 
     @Test
-    public void testBoundsCheck()
-    {
+    public void testBoundsCheck() {
         DataAccess da = createDataAccess(name);
         da.setSegmentSize(128);
         da.create(128 * 11);
@@ -263,32 +245,27 @@ public void testBoundsCheck()
 
         // make smaller
         da.trimTo(128 * 1);
-        try
-        {
+        try {
             assertEquals(302, da.getInt(32 * 4));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         da.close();
 
         da = createDataAccess(name);
         da.create(128);
         da.setInt(31 * 4, 200);
-        try
-        {
+        try {
             // this should fail with an index out of bounds exception
             da.setInt(32 * 4, 220);
             assertFalse(true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         da.close();
     }
 
     @Test
-    public void testSegmentSize()
-    {
+    public void testSegmentSize() {
         DataAccess da = createDataAccess(name);
         da.setSegmentSize(20);
         assertEquals(128, da.getSegmentSize());
@@ -296,24 +273,20 @@ public void testSegmentSize()
     }
 
     @Test
-    public void testRenameNoFlush()
-    {
+    public void testRenameNoFlush() {
         DataAccess da = createDataAccess(name);
         da.create(100);
         da.setInt(17 * 4, 17);
-        try
-        {
+        try {
             da.rename(name + "wow");
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         da.close();
     }
 
     @Test
-    public void testRenameFlush()
-    {
+    public void testRenameFlush() {
         DataAccess da = createDataAccess(name);
         da.create(100);
         da.setInt(17 * 4, 17);
@@ -332,8 +305,7 @@ public void testRenameFlush()
     }
 
     @Test
-    public void testSet_GetBytes()
-    {
+    public void testSet_GetBytes() {
         DataAccess da = createDataAccess(name);
         da.create(300);
         assertEquals(128, da.getSegmentSize());
@@ -360,8 +332,7 @@ public void testSet_GetBytes()
     }
 
     @Test
-    public void testSet_Get_Short_Long()
-    {
+    public void testSet_Get_Short_Long() {
         DataAccess da = createDataAccess(name);
         da.create(300);
         da.setShort(6, (short) (Short.MAX_VALUE / 5));
@@ -371,8 +342,7 @@ public void testSet_Get_Short_Long()
         assertEquals(Short.MAX_VALUE / 7, da.getShort(8));
 
         // currently RAMIntDA does not support arbitrary byte positions
-        if (!(da instanceof RAMIntDataAccess))
-        {
+        if (!(da instanceof RAMIntDataAccess)) {
             da.setShort(7, (short) (Short.MAX_VALUE / 3));
             assertEquals(Short.MAX_VALUE / 3, da.getShort(7));
             // should be overwritten
diff --git a/core/src/test/java/com/graphhopper/storage/EdgeTest.java b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
index 806bc5dd8f..4e79999d23 100755
--- a/core/src/test/java/com/graphhopper/storage/EdgeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
@@ -25,11 +25,9 @@
 /**
  * @author Peter Karich
  */
-public class EdgeTest
-{
+public class EdgeTest {
     @Test
-    public void testCloneFull()
-    {
+    public void testCloneFull() {
         SPTEntry de = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
         SPTEntry de2 = de.parent = new SPTEntry(EdgeIterator.NO_EDGE, -2, 20);
         SPTEntry de3 = de2.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 30);
@@ -39,8 +37,7 @@ public void testCloneFull()
         SPTEntry tmp2 = cloning;
 
         assertNotNull(tmp1);
-        while (tmp1 != null)
-        {
+        while (tmp1 != null) {
             assertFalse(tmp1 == tmp2);
             assertEquals(tmp1.edge, tmp2.edge);
             tmp1 = tmp1.parent;
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 47b2b60483..87d665f63e 100755
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -20,49 +20,44 @@
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import org.junit.Test;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static org.junit.Assert.*;
 
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public class GraphHopperStorageCHTest extends GraphHopperStorageTest
-{
-    protected CHGraph getGraph( GraphHopperStorage ghStorage )
-    {
+public class GraphHopperStorageCHTest extends GraphHopperStorageTest {
+    protected CHGraph getGraph(GraphHopperStorage ghStorage) {
         return ghStorage.getGraph(CHGraph.class);
     }
 
     @Override
-    public GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
-    {
+    public GraphHopperStorage newGHStorage(Directory dir, boolean is3D) {
         return new GraphHopperStorage(Arrays.asList(new FastestWeighting(carEncoder)), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
     }
 
     @Test
-    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
-    {
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass() {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         graph.flush();
         graph.close();
 
         graph = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
-        try
-        {
+        try {
             graph.loadExisting();
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
 
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
@@ -72,8 +67,7 @@ public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     }
 
     @Test
-    public void testPrios()
-    {
+    public void testPrios() {
         graph = createGHStorage();
         CHGraph g = getGraph(graph);
         g.getNodeAccess().ensureNode(30);
@@ -89,8 +83,7 @@ public void testPrios()
     }
 
     @Test
-    public void testEdgeFilter()
-    {
+    public void testEdgeFilter() {
         graph = createGHStorage();
         CHGraph g = getGraph(graph);
         g.edge(0, 1, 10, true);
@@ -120,8 +113,7 @@ public void testEdgeFilter()
     }
 
     @Test
-    public void testDisconnectEdge()
-    {
+    public void testDisconnectEdge() {
         graph = createGHStorage();
         CHGraphImpl lg = (CHGraphImpl) getGraph(graph);
 
@@ -172,8 +164,7 @@ public void testDisconnectEdge()
     }
 
     @Test
-    public void testGetWeight()
-    {
+    public void testGetWeight() {
         graph = createGHStorage();
         CHGraphImpl g = (CHGraphImpl) getGraph(graph);
         assertFalse(g.edge(0, 1).isShortcut());
@@ -207,8 +198,7 @@ public void testGetWeight()
     }
 
     @Test
-    public void testGetWeightIfAdvancedEncoder()
-    {
+    public void testGetWeightIfAdvancedEncoder() {
         FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
         EncodingManager em = new EncodingManager(customEncoder);
         FastestWeighting weighting = new FastestWeighting(customEncoder);
@@ -235,8 +225,7 @@ public void testGetWeightIfAdvancedEncoder()
     }
 
     @Test
-    public void testQueryGraph()
-    {
+    public void testQueryGraph() {
         graph = createGHStorage();
         CHGraph chGraph = getGraph(graph);
         NodeAccess na = chGraph.getNodeAccess();
@@ -269,8 +258,7 @@ public void testQueryGraph()
         assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
     }
 
-    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
-    {
+    QueryResult createQR(double lat, double lon, int wayIndex, EdgeIteratorState edge) {
         QueryResult res = new QueryResult(lat, lon);
         res.setClosestEdge(edge);
         res.setWayIndex(wayIndex);
@@ -281,8 +269,7 @@ QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState ed
 
     @Test
     @Override
-    public void testSave_and_Freeze() throws IOException
-    {
+    public void testSave_and_Freeze() throws IOException {
         // belongs to each other
         super.testSave_and_Freeze();
         graph.close();
@@ -337,8 +324,7 @@ public void testSave_and_Freeze() throws IOException
     }
 
     @Test
-    public void testSimpleShortcutCreationAndTraversal()
-    {
+    public void testSimpleShortcutCreationAndTraversal() {
         graph = createGHStorage();
         graph.edge(1, 3, 10, true);
         graph.edge(3, 4, 10, true);
@@ -354,8 +340,7 @@ public void testSimpleShortcutCreationAndTraversal()
     }
 
     @Test
-    public void testShortcutCreationAndAccessForManyVehicles()
-    {
+    public void testShortcutCreationAndAccessForManyVehicles() {
         FlagEncoder tmpCar = new CarFlagEncoder();
         FlagEncoder tmpBike = new Bike2WeightFlagEncoder();
         EncodingManager em = new EncodingManager(tmpCar, tmpBike);
@@ -382,12 +367,10 @@ public void testShortcutCreationAndAccessForManyVehicles()
         assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isBackward(tmpCar));
 
         // throw exception for wrong encoder
-        try
-        {
+        try {
             assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpBike));
             assertTrue(false);
-        } catch (AssertionError ex)
-        {
+        } catch (AssertionError ex) {
         }
 
         // assert bike CH graph
@@ -395,12 +378,10 @@ public void testShortcutCreationAndAccessForManyVehicles()
         assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpBike));
 
         // throw exception for wrong encoder
-        try
-        {
+        try {
             assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpCar));
             assertTrue(false);
-        } catch (AssertionError ex)
-        {
+        } catch (AssertionError ex) {
         }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 21c74e41bf..ea33fd0d76 100755
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -19,21 +19,18 @@
 
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import org.junit.Test;
 
 import java.io.IOException;
 
 import static org.junit.Assert.*;
 
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public class GraphHopperStorageTest extends AbstractGraphStorageTester
-{
+public class GraphHopperStorageTest extends AbstractGraphStorageTester {
     @Override
-    public GraphHopperStorage createGHStorage( String location, boolean enabled3D )
-    {
+    public GraphHopperStorage createGHStorage(String location, boolean enabled3D) {
         // reduce segment size in order to test the case where multiple segments come into the game
         GraphHopperStorage gs = newGHStorage(new RAMDirectory(location), enabled3D);
         gs.setSegmentSize(defaultSize / 2);
@@ -41,34 +38,27 @@ public GraphHopperStorage createGHStorage( String location, boolean enabled3D )
         return gs;
     }
 
-    protected GraphHopperStorage newGHStorage( Directory dir, boolean enabled3D )
-    {
+    protected GraphHopperStorage newGHStorage(Directory dir, boolean enabled3D) {
         return new GraphHopperStorage(dir, encodingManager, enabled3D, new GraphExtension.NoOpExtension());
     }
 
     @Test
-    public void testNoCreateCalled() throws IOException
-    {
+    public void testNoCreateCalled() throws IOException {
         GraphHopperStorage gs = new GraphBuilder(encodingManager).build();
-        try
-        {
+        try {
             ((BaseGraph) gs.getGraph(Graph.class)).ensureNodeIndex(123);
             assertFalse("AssertionError should be raised", true);
-        } catch (AssertionError err)
-        {
+        } catch (AssertionError err) {
             assertTrue(true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertFalse("AssertionError should be raised, but was " + ex.toString(), true);
-        } finally
-        {
+        } finally {
             gs.close();
         }
     }
 
     @Test
-    public void testSave_and_fileFormat() throws IOException
-    {
+    public void testSave_and_fileFormat() throws IOException {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
@@ -104,8 +94,7 @@ public void testSave_and_fileFormat() throws IOException
     }
 
     @Test
-    public void testSave_and_Freeze() throws IOException
-    {
+    public void testSave_and_Freeze() throws IOException {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         graph.edge(1, 0);
         graph.freeze();
@@ -119,8 +108,7 @@ public void testSave_and_Freeze() throws IOException
         assertTrue(graph.isFrozen());
     }
 
-    protected void checkGraph( Graph g )
-    {
+    protected void checkGraph(Graph g) {
         NodeAccess na = g.getNodeAccess();
         assertTrue(na.is3D());
         assertTrue(g.getBounds().isValid());
@@ -160,8 +148,7 @@ protected void checkGraph( Graph g )
     }
 
     @Test
-    public void internalDisconnect()
-    {
+    public void internalDisconnect() {
         GraphHopperStorage storage = createGHStorage();
         BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
         EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
@@ -190,8 +177,7 @@ public void internalDisconnect()
     }
 
     @Test
-    public void testEnsureSize()
-    {
+    public void testEnsureSize() {
         Directory dir = new RAMDirectory();
         graph = newGHStorage(dir, false).create(defaultSize);
         int testIndex = dir.find("edges").getSegmentSize() * 3;
@@ -202,8 +188,7 @@ public void testEnsureSize()
     }
 
     @Test
-    public void testBigDataEdge()
-    {
+    public void testBigDataEdge() {
         Directory dir = new RAMDirectory();
         GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(defaultSize);
@@ -213,107 +198,88 @@ public void testBigDataEdge()
     }
 
     @Test
-    public void testDoThrowExceptionIfDimDoesNotMatch()
-    {
+    public void testDoThrowExceptionIfDimDoesNotMatch() {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
         graph.create(1000);
         graph.flush();
         graph.close();
 
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
-        try
-        {
+        try {
             graph.loadExisting();
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testIdentical()
-    {
+    public void testIdentical() {
         GraphHopperStorage store = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension());
         assertEquals(store.getNodes(), store.getGraph(Graph.class).getNodes());
         assertEquals(store.getAllEdges().getMaxId(), store.getGraph(Graph.class).getAllEdges().getMaxId());
     }
 
-    public void testAdditionalEdgeField()
-    {
-        GraphExtension extStorage = new GraphExtension()
-        {
+    public void testAdditionalEdgeField() {
+        GraphExtension extStorage = new GraphExtension() {
             @Override
-            public boolean isRequireNodeField()
-            {
+            public boolean isRequireNodeField() {
                 return false;
             }
 
             @Override
-            public boolean isRequireEdgeField()
-            {
+            public boolean isRequireEdgeField() {
                 return true;
             }
 
             @Override
-            public int getDefaultNodeFieldValue()
-            {
+            public int getDefaultNodeFieldValue() {
                 throw new UnsupportedOperationException("Not supported.");
             }
 
             @Override
-            public int getDefaultEdgeFieldValue()
-            {
+            public int getDefaultEdgeFieldValue() {
                 return 2;
             }
 
             @Override
-            public void init( Graph graph, Directory dir )
-            {
+            public void init(Graph graph, Directory dir) {
             }
 
             @Override
-            public void setSegmentSize( int bytes )
-            {
+            public void setSegmentSize(int bytes) {
 
             }
 
             @Override
-            public GraphExtension copyTo( GraphExtension extStorage )
-            {
+            public GraphExtension copyTo(GraphExtension extStorage) {
                 return this;
             }
 
             @Override
-            public boolean loadExisting()
-            {
+            public boolean loadExisting() {
                 return true;
             }
 
             @Override
-            public GraphExtension create( long byteCount )
-            {
+            public GraphExtension create(long byteCount) {
                 return this;
             }
 
             @Override
-            public void flush()
-            {
+            public void flush() {
             }
 
             @Override
-            public void close()
-            {
+            public void close() {
             }
 
             @Override
-            public boolean isClosed()
-            {
+            public boolean isClosed() {
                 return false;
             }
 
             @Override
-            public long getCapacity()
-            {
+            public long getCapacity() {
                 return 0;
             }
         };
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index 0caf058968..2ab54ed023 100755
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -17,34 +17,31 @@
  */
 package com.graphhopper.storage;
 
-import java.io.IOException;
-import java.util.Random;
-
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.util.Random;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Karl Hübner
  */
-public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
-{
+public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest {
     private TurnCostExtension turnCostStorage;
 
     @Override
-    protected GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
-    {
+    protected GraphHopperStorage newGHStorage(Directory dir, boolean is3D) {
         turnCostStorage = new TurnCostExtension();
         return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
     @Override
     @Test
-    public void testSave_and_fileFormat() throws IOException
-    {
+    public void testSave_and_fileFormat() throws IOException {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
@@ -90,8 +87,7 @@ public void testSave_and_fileFormat() throws IOException
     }
 
     @Test
-    public void testEnsureCapacity() throws IOException
-    {
+    public void testEnsureCapacity() throws IOException {
         graph = newGHStorage(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
@@ -102,8 +98,7 @@ public void testEnsureCapacity() throws IOException
         Random r = new Random();
 
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < 100; i++)
-        {
+        for (int i = 0; i < 100; i++) {
             double randomLat = 90 * r.nextDouble();
             double randomLon = 180 * r.nextDouble();
 
@@ -111,18 +106,15 @@ public void testEnsureCapacity() throws IOException
         }
 
         // Make node 50 the 'center' node
-        for (int nodeId = 51; nodeId < 100; nodeId++)
-        {
+        for (int nodeId = 51; nodeId < 100; nodeId++) {
             graph.edge(50, nodeId, r.nextDouble(), true);
         }
-        for (int nodeId = 0; nodeId < 50; nodeId++)
-        {
+        for (int nodeId = 0; nodeId < 50; nodeId++) {
             graph.edge(nodeId, 50, r.nextDouble(), true);
         }
 
         // add 100 turn cost entries around node 50
-        for (int edgeId = 0; edgeId < 50; edgeId++)
-        {
+        for (int edgeId = 0; edgeId < 50; edgeId++) {
             turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
             turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
         }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
index b85f39495f..96be23ed26 100755
--- a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class GraphStorageViaMMapTest extends AbstractGraphStorageTester
-{
+public class GraphStorageViaMMapTest extends AbstractGraphStorageTester {
     @Override
-    public GraphHopperStorage createGHStorage( String location, boolean is3D )
-    {
+    public GraphHopperStorage createGHStorage(String location, boolean is3D) {
         GraphHopperStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
         gs.setSegmentSize(defaultSize / 2);
         gs.create(defaultSize);
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index d0c21b5725..442f573d96 100755
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -17,24 +17,21 @@
  */
 package com.graphhopper.storage;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Peter Karich
  */
-public class MMapDataAccessTest extends DataAccessTest
-{
+public class MMapDataAccessTest extends DataAccessTest {
     @Override
-    public DataAccess createDataAccess( String name )
-    {
+    public DataAccess createDataAccess(String name) {
         return new MMapDataAccess(name, directory, defaultOrder, true).setSegmentSize(128);
     }
 
     @Test
-    public void textMixRAM2MMAP()
-    {
+    public void textMixRAM2MMAP() {
         DataAccess da = new RAMDataAccess(name, directory, true, defaultOrder);
         assertFalse(da.loadExisting());
         da.create(100);
@@ -48,8 +45,7 @@ public void textMixRAM2MMAP()
     }
 
     @Test
-    public void textMixMMAP2RAM()
-    {
+    public void textMixMMAP2RAM() {
         DataAccess da = createDataAccess(name);
         assertFalse(da.loadExisting());
         da.create(100);
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
index fb7eeecf6c..e6751ef939 100755
--- a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class MMapDirectoryTest extends AbstractDirectoryTester
-{
+public class MMapDirectoryTest extends AbstractDirectoryTester {
     @Override
-    Directory createDir()
-    {
+    Directory createDir() {
         return new MMapDirectory(location).create();
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
index 82d0973649..9e608b2409 100755
--- a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -17,26 +17,23 @@
  */
 package com.graphhopper.storage;
 
-import java.nio.channels.OverlappingFileLockException;
-
 import org.junit.Test;
 
+import java.nio.channels.OverlappingFileLockException;
+
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
-{
+public class NativeFSLockFactoryTest extends AbstractLockFactoryTester {
     @Override
-    protected LockFactory createLockFactory()
-    {
+    protected LockFactory createLockFactory() {
         return new NativeFSLockFactory(lockDir);
     }
 
     @Test
-    public void testMultiReadObtain()
-    {
+    public void testMultiReadObtain() {
         LockFactory instance = createLockFactory();
         instance.setLockDir(lockDir);
         Lock writeLock1 = instance.create("test", true);
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
index 2e1581256b..d23df73fb4 100755
--- a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class RAMDataAccessTest extends DataAccessTest
-{
+public class RAMDataAccessTest extends DataAccessTest {
     @Override
-    public DataAccess createDataAccess( String name )
-    {
+    public DataAccess createDataAccess(String name) {
         return new RAMDataAccess(name, directory, true, defaultOrder).setSegmentSize(128);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
index 710b507d95..3e277ab754 100755
--- a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class RAMDirectoryTest extends AbstractDirectoryTester
-{
+public class RAMDirectoryTest extends AbstractDirectoryTester {
     @Override
-    Directory createDir()
-    {
+    Directory createDir() {
         return new RAMDirectory(location, true).create();
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
index aa8c6d81db..90f81e0456 100755
--- a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
@@ -20,17 +20,14 @@
 /**
  * @author Peter Karich
  */
-public class RAMIntDataAccessTest extends DataAccessTest
-{
+public class RAMIntDataAccessTest extends DataAccessTest {
     @Override
-    public DataAccess createDataAccess( String name )
-    {
+    public DataAccess createDataAccess(String name) {
         return new RAMIntDataAccess(name, directory, true, defaultOrder).setSegmentSize(128);
     }
 
     @Override
-    public void testSet_GetBytes()
-    {
+    public void testSet_GetBytes() {
         // should we implement this?
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index fb7fa00dbe..2e620bb847 100755
--- a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
-{
+public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester {
     @Override
-    protected LockFactory createLockFactory()
-    {
+    protected LockFactory createLockFactory() {
         return new SimpleFSLockFactory(lockDir);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
index a15a904fe9..0874232e4d 100755
--- a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
+++ b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
@@ -18,26 +18,22 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+import org.junit.Test;
 
 import java.io.File;
 
-import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class StorablePropertiesTest
-{
-    Directory createDir( String location, boolean store )
-    {
+public class StorablePropertiesTest {
+    Directory createDir(String location, boolean store) {
         return new RAMDirectory(location, store).create();
     }
 
     @Test
-    public void testLoad()
-    {
+    public void testLoad() {
         StorableProperties instance = new StorableProperties(createDir("", false));
         // an in-memory storage does not load anything
         assertFalse(instance.loadExisting());
@@ -48,8 +44,7 @@ public void testLoad()
     }
 
     @Test
-    public void testVersionCheck()
-    {
+    public void testVersionCheck() {
         StorableProperties instance = new StorableProperties(createDir("", false));
         instance.putCurrentVersions();
         assertTrue(instance.checkVersions(true));
@@ -57,19 +52,16 @@ public void testVersionCheck()
         instance.put("nodes.version", 0);
         assertFalse(instance.checkVersions(true));
 
-        try
-        {
+        try {
             instance.checkVersions(false);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
         instance.close();
     }
 
     @Test
-    public void testStore()
-    {
+    public void testStore() {
         String dir = "./target/test";
         Helper.removeDir(new File(dir));
         StorableProperties instance = new StorableProperties(createDir(dir, true));
diff --git a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
index bbd739bcab..93e07a58bf 100755
--- a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
@@ -20,11 +20,9 @@
 /**
  * @author Peter Karich
  */
-public class SynchedDAWrapperTest extends DataAccessTest
-{
+public class SynchedDAWrapperTest extends DataAccessTest {
     @Override
-    public DataAccess createDataAccess( String name )
-    {
+    public DataAccess createDataAccess(String name) {
         return new SynchedDAWrapper(new RAMDataAccess(name, directory, true, defaultOrder)).setSegmentSize(128);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
index a7689c6e2c..21b253bfd0 100755
--- a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
@@ -18,39 +18,33 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.BitUtil;
+import org.junit.Test;
 
 import java.nio.ByteOrder;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class UnsafeDataAccessTest extends DataAccessTest
-{
+public class UnsafeDataAccessTest extends DataAccessTest {
     @Override
-    public DataAccess createDataAccess( String name )
-    {
+    public DataAccess createDataAccess(String name) {
         return new UnsafeDataAccess(name, directory, defaultOrder).setSegmentSize(128);
     }
 
     @Override
-    public void testExceptionIfNoEnsureCapacityWasCalled()
-    {
+    public void testExceptionIfNoEnsureCapacityWasCalled() {
         // SKIP as unsafe failes with SIGSEGV and not with an exception!
     }
 
     @Override
-    public void testBoundsCheck()
-    {
+    public void testBoundsCheck() {
         // SKIP as unsafe has no bounds checks
     }
 
     @Test
-    public void testNativeOrder()
-    {
+    public void testNativeOrder() {
         BitUtil bitUtil = BitUtil.get(ByteOrder.nativeOrder());
         long address = UnsafeDataAccess.UNSAFE.allocateMemory(8);
         long val = 123123123123L * 123L;
@@ -58,17 +52,13 @@ public void testNativeOrder()
         byte[] bytes = new byte[8];
         bitUtil.fromLong(bytes, val);
 
-        if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN))
-        {
-            for (int i = 7; i >= 0; i--)
-            {
+        if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {
+            for (int i = 7; i >= 0; i--) {
                 UnsafeDataAccess.UNSAFE.putByte(address + i, bytes[i]);
             }
-        } else
-        {
+        } else {
             // not tested:
-            for (int i = 0; i < 8; i++)
-            {
+            for (int i = 0; i < 8; i++) {
                 UnsafeDataAccess.UNSAFE.putByte(address + i, bytes[i]);
             }
         }
diff --git a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
index 5eaa6ada8f..e3a914828a 100755
--- a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
@@ -19,16 +19,14 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class VLongStorageTest
-{
+public class VLongStorageTest {
     @Test
-    public void testWrite()
-    {
+    public void testWrite() {
         VLongStorage store = new VLongStorage();
         store.seek(0);
         store.writeVLong(1);
@@ -44,8 +42,7 @@ public void testWrite()
     }
 
     @Test
-    public void testWriteWithTrim()
-    {
+    public void testWriteWithTrim() {
         VLongStorage store = new VLongStorage();
         store.seek(0);
         store.writeVLong(1);
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index 2482ab4f10..976d1bbd85 100755
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -23,35 +23,31 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.Closeable;
 import java.io.File;
 import java.util.Random;
 
-import org.junit.After;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public abstract class AbstractLocationIndexTester
-{
+public abstract class AbstractLocationIndexTester {
     String location = "./target/tmp/";
     LocationIndex idx;
 
-    public abstract LocationIndex createIndex( Graph g, int resolution );
+    public abstract LocationIndex createIndex(Graph g, int resolution);
 
-    GraphHopperStorage createGHStorage( EncodingManager encodingManager )
-    {
+    GraphHopperStorage createGHStorage(EncodingManager encodingManager) {
         return AbstractLocationIndexTester.this.createGHStorage(new RAMDirectory(), encodingManager, false);
     }
 
-    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
-    {
+    GraphHopperStorage createGHStorage(Directory dir, EncodingManager encodingManager, boolean is3D) {
         return new GraphHopperStorage(dir, encodingManager, is3D, new GraphExtension.NoOpExtension()).create(100);
     }
 
@@ -59,28 +55,24 @@ protected int findID(LocationIndex index, double lat, double lon) {
         return index.findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
     }
 
-    public boolean hasEdgeSupport()
-    {
+    public boolean hasEdgeSupport() {
         return false;
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         Helper.removeDir(new File(location));
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         if (idx != null)
             idx.close();
         Helper.removeDir(new File(location));
     }
 
     @Test
-    public void testSimpleGraph()
-    {
+    public void testSimpleGraph() {
         Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("car"));
         initSimpleGraph(g);
 
@@ -89,19 +81,16 @@ public void testSimpleGraph()
         assertEquals(3, findID(idx, 1.5, 2));
         assertEquals(0, findID(idx, -1, -1));
 
-        if (hasEdgeSupport())
-        // now get the edge 1-4 and not node 6
+        if (hasEdgeSupport()) // now get the edge 1-4 and not node 6
         {
             assertEquals(4, findID(idx, 4, 0));
-        } else
-        {
+        } else {
             assertEquals(6, findID(idx, 4, 0));
         }
         Helper.close((Closeable) g);
     }
 
-    public void initSimpleGraph( Graph g )
-    {
+    public void initSimpleGraph(Graph g) {
         //  6 |       4
         //  5 |           
         //    |     6
@@ -133,8 +122,7 @@ public void initSimpleGraph( Graph g )
     }
 
     @Test
-    public void testSimpleGraph2()
-    {
+    public void testSimpleGraph2() {
         Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("car"));
         initSimpleGraph(g);
 
@@ -143,12 +131,10 @@ public void testSimpleGraph2()
         assertEquals(3, findID(idx, 1.5, 2));
         assertEquals(0, findID(idx, -1, -1));
         assertEquals(6, findID(idx, 4.5, -0.5));
-        if (hasEdgeSupport())
-        {
+        if (hasEdgeSupport()) {
             assertEquals(4, findID(idx, 4, 1));
             assertEquals(4, findID(idx, 4, 0));
-        } else
-        {
+        } else {
             assertEquals(6, findID(idx, 4, 1));
             assertEquals(6, findID(idx, 4, 0));
         }
@@ -158,8 +144,7 @@ public void testSimpleGraph2()
     }
 
     @Test
-    public void testGrid()
-    {
+    public void testGrid() {
         Graph g = createSampleGraph(new EncodingManager("car"));
         int locs = g.getNodes();
 
@@ -168,8 +153,7 @@ public void testGrid()
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
         NodeAccess na = g.getNodeAccess();
-        for (int i = 0; i < locs; i++)
-        {
+        for (int i = 0; i < locs; i++) {
             double lat = na.getLatitude(i);
             double lon = na.getLongitude(i);
             assertEquals("nodeId:" + i + " " + (float) lat + "," + (float) lon, i, findID(idx, lat, lon));
@@ -184,8 +168,7 @@ public void testGrid()
             fullIndex = new Location2IDFullIndex(g);
 
         DistanceCalc dist = new DistanceCalcEarth();
-        for (int i = 0; i < 100; i++)
-        {
+        for (int i = 0; i < 100; i++) {
             double lat = rand.nextDouble() * 5;
             double lon = rand.nextDouble() * 5;
             int fullId = findID(fullIndex, lat, lon);
@@ -197,8 +180,7 @@ public void testGrid()
             double newLon = na.getLongitude(newId);
             float newDist = (float) dist.calcDist(lat, lon, newLat, newLon);
 
-            if (testGridIgnore(i))
-            {
+            if (testGridIgnore(i)) {
                 continue;
             }
 
@@ -212,14 +194,12 @@ public void testGrid()
     }
 
     // our simple index has only one node per tile => problems if multiple subnetworks
-    boolean testGridIgnore( int i )
-    {
+    boolean testGridIgnore(int i) {
         return false;
     }
 
     @Test
-    public void testSinglePoints120()
-    {
+    public void testSinglePoints120() {
         Graph g = createSampleGraph(new EncodingManager("car"));
         idx = createIndex(g, -1);
 
@@ -234,19 +214,16 @@ public void testSinglePoints120()
     }
 
     @Test
-    public void testSinglePoints32()
-    {
+    public void testSinglePoints32() {
         Graph g = createSampleGraph(new EncodingManager("car"));
         idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, findID(idx, 3.649, 1.375));
         assertEquals(10, findID(idx, 3.8465748, 0.021762699));
-        if (hasEdgeSupport())
-        {
+        if (hasEdgeSupport()) {
             assertEquals(4, findID(idx, 2.485, 1.373));
-        } else
-        {
+        } else {
             assertEquals(6, findID(idx, 2.485, 1.373));
         }
         assertEquals(0, findID(idx, 0.64628404, 0.53006625));
@@ -254,23 +231,20 @@ public void testSinglePoints32()
     }
 
     @Test
-    public void testNoErrorOnEdgeCase_lastIndex()
-    {
+    public void testNoErrorOnEdgeCase_lastIndex() {
         final EncodingManager encodingManager = new EncodingManager("car");
         int locs = 10000;
         Graph g = AbstractLocationIndexTester.this.createGHStorage(new MMapDirectory(location), encodingManager, false);
         NodeAccess na = g.getNodeAccess();
         Random rand = new Random(12);
-        for (int i = 0; i < locs; i++)
-        {
+        for (int i = 0; i < locs; i++) {
             na.setNode(i, (float) rand.nextDouble() * 10 + 10, (float) rand.nextDouble() * 10 + 10);
         }
         idx = createIndex(g, 200);
         Helper.close((Closeable) g);
     }
 
-    public Graph createSampleGraph( EncodingManager encodingManager )
-    {
+    public Graph createSampleGraph(EncodingManager encodingManager) {
         Graph graph = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         // length does not matter here but lat,lon and outgoing edges do!
 
@@ -350,8 +324,7 @@ public Graph createSampleGraph( EncodingManager encodingManager )
     }
 
     @Test
-    public void testDifferentVehicles()
-    {
+    public void testDifferentVehicles() {
         final EncodingManager encodingManager = new EncodingManager("car,foot");
         Graph g = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         initSimpleGraph(g);
@@ -361,8 +334,7 @@ public void testDifferentVehicles()
         // now make all edges from node 1 accessible for CAR only
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(1);
         CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
-        while (iter.next())
-        {
+        while (iter.next()) {
             iter.setFlags(carEncoder.setProperties(50, true, true));
         }
         idx.close();
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 6621d1d2fc..b0224ef3c0 100755
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -21,56 +21,47 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class BresenhamLineTest
-{
+public class BresenhamLineTest {
     final PointList points = new PointList(10, false);
-    PointEmitter emitter = new PointEmitter()
-    {
+    PointEmitter emitter = new PointEmitter() {
         @Override
-        public void set( double lat, double lon )
-        {
+        public void set(double lat, double lon) {
             points.add(lat, lon);
         }
     };
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         points.clear();
     }
 
     @Test
-    public void testBresenhamLineLeftDown()
-    {
+    public void testBresenhamLineLeftDown() {
         BresenhamLine.calcPoints(5, 2, 0, 0, emitter);
         // 5,2, 4,2, 3,2, 3,1, 2,1, 1,1, 0,0
         assertEquals(Helper.createPointList(5, 2, 4, 2, 3, 1, 2, 1, 1, 0, 0, 0), points);
     }
 
     @Test
-    public void testBresenhamLineRightDown()
-    {
+    public void testBresenhamLineRightDown() {
         BresenhamLine.calcPoints(3, 1, 0, 3, emitter);
         // 3,1, 2,1, 1,1, 1,2, 0,2, 0,3
         assertEquals(Helper.createPointList(3, 1, 2, 2, 1, 2, 0, 3), points);
     }
 
     @Test
-    public void testBresenhamLineLeftUp()
-    {
+    public void testBresenhamLineLeftUp() {
         BresenhamLine.calcPoints(2, 2, 3, 0, emitter);
         // 2,2, 2,1, 2,0, 3,0
 
@@ -78,37 +69,32 @@ public void testBresenhamLineLeftUp()
     }
 
     @Test
-    public void testBresenhamLineRightUp()
-    {
+    public void testBresenhamLineRightUp() {
         BresenhamLine.calcPoints(0, 0, 2, 3, emitter);
         // 0,0, 0,1, 1,1, 1,2, 2,2, 2,3
         assertEquals(Helper.createPointList(0, 0, 1, 1, 1, 2, 2, 3), points);
     }
 
     @Test
-    public void testBresenhamBug()
-    {
+    public void testBresenhamBug() {
         BresenhamLine.calcPoints(0.5, -0.5, -0.6, 1.6, emitter, -1, -1, 0.75, 1.3);
         assertEquals(Helper.createPointList(0.575, -0.87, -0.175, 0.43, -0.925, 1.73), points);
     }
 
     @Test
-    public void testBresenhamHorizontal()
-    {
+    public void testBresenhamHorizontal() {
         BresenhamLine.calcPoints(.5, -.5, .5, 1, emitter, -1, -1, 0.6, 0.4);
         assertEquals(Helper.createPointList(.26, -.56, .26, -0.16, .26, .24, .26, .64, .26, 1.04), points);
     }
 
     @Test
-    public void testBresenhamVertical()
-    {
+    public void testBresenhamVertical() {
         BresenhamLine.calcPoints(-.5, .5, 1, 0.5, emitter, 0, 0, 0.4, 0.6);
         assertEquals(Helper.createPointList(-0.36, .06, 0.04, 0.06, 0.44, 0.06, 0.84, 0.06), points);
     }
 
     @Test
-    public void testRealBresenham()
-    {
+    public void testRealBresenham() {
         int parts = 4;
         int bits = (int) (Math.log(parts * parts) / Math.log(2));
         double minLon = -1, maxLon = 1.6;
@@ -117,11 +103,9 @@ public void testRealBresenham()
         double deltaLat = (maxLat - minLat) / parts;
         double deltaLon = (maxLon - minLon) / parts;
         final ArrayList<Long> keys = new ArrayList<Long>();
-        PointEmitter tmpEmitter = new PointEmitter()
-        {
+        PointEmitter tmpEmitter = new PointEmitter() {
             @Override
-            public void set( double lat, double lon )
-            {
+            public void set(double lat, double lon) {
                 keys.add(keyAlgo.encode(lat, lon));
             }
         };
@@ -145,8 +129,7 @@ public void set( double lat, double lon )
     }
 
     @Test
-    public void testBresenhamToLeft()
-    {
+    public void testBresenhamToLeft() {
         BresenhamLine.calcPoints(
                 47.57383, 9.61984,
                 47.57382, 9.61890, emitter, 47, 9, 0.00647, 0.00964);
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
index 64d2f6d061..07678466dd 100755
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
@@ -19,30 +19,26 @@
 
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
-import org.junit.*;
+import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class Location2IDFullIndexTest extends AbstractLocationIndexTester
-{
+public class Location2IDFullIndexTest extends AbstractLocationIndexTester {
     @Override
-    public LocationIndex createIndex( Graph g, int resolution )
-    {
+    public LocationIndex createIndex(Graph g, int resolution) {
         return new Location2IDFullIndex(g);
     }
 
     @Override
-    public void testGrid()
-    {
+    public void testGrid() {
         // do not test against itself
     }
 
     @Test
-    public void testFullIndex()
-    {
+    public void testFullIndex() {
         LocationIndex tmpIdx = new Location2IDFullIndex(createSampleGraph(new EncodingManager("car")));
         assertEquals(5, findID(tmpIdx, 2, 3));
         assertEquals(10, findID(tmpIdx, 4, 1));
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
index bc84de9283..9f0f434ca0 100755
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
@@ -21,34 +21,29 @@
 import com.graphhopper.storage.Graph;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class Location2IDFullWithEdgesIndexTest extends AbstractLocationIndexTester
-{
+public class Location2IDFullWithEdgesIndexTest extends AbstractLocationIndexTester {
     @Override
-    public LocationIndex createIndex( Graph g, int resolution )
-    {
+    public LocationIndex createIndex(Graph g, int resolution) {
         return new Location2IDFullWithEdgesIndex(g);
     }
 
     @Override
-    public boolean hasEdgeSupport()
-    {
+    public boolean hasEdgeSupport() {
         return true;
     }
 
     @Override
-    public void testGrid()
-    {
+    public void testGrid() {
         // do not test against itself
     }
 
     @Test
-    public void testFullIndex()
-    {
+    public void testFullIndex() {
         LocationIndex tmpIdx = new Location2IDFullWithEdgesIndex(createSampleGraph(new EncodingManager("car")));
         assertEquals(5, findID(tmpIdx, 2, 3));
         assertEquals(10, findID(tmpIdx, 4, 1));
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 71a4860384..a170efc4d4 100755
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -21,19 +21,16 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.MMapDirectory;
 import com.graphhopper.storage.RAMDirectory;
-
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
-public class Location2IDQuadtreeTest extends AbstractLocationIndexTester
-{
+public class Location2IDQuadtreeTest extends AbstractLocationIndexTester {
     @Override
-    public LocationIndex createIndex( Graph g, int resolution )
-    {
+    public LocationIndex createIndex(Graph g, int resolution) {
         if (resolution < 0)
             resolution = 120;
         return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex").create()).
@@ -41,8 +38,7 @@ public LocationIndex createIndex( Graph g, int resolution )
     }
 
     @Test
-    public void testNormedDist()
-    {
+    public void testNormedDist() {
         Location2IDQuadtree index = new Location2IDQuadtree(createGHStorage(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
@@ -54,20 +50,17 @@ public void testNormedDist()
     }
 
     @Override
-    boolean testGridIgnore( int i )
-    {
+    boolean testGridIgnore(int i) {
         // conceptual limitation where we are stuck in a blind alley limited
         // to the current tile
-        if (i == 6 || i == 36 || i == 90 || i == 96)
-        {
+        if (i == 6 || i == 36 || i == 90 || i == 96) {
             return true;
         }
         return false;
     }
 
     @Override
-    public void testDifferentVehicles()
-    {
+    public void testDifferentVehicles() {
         // currently unsupported
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
index a72a22bc87..9e55a15717 100755
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
@@ -17,43 +17,38 @@
  */
 package com.graphhopper.storage.index;
 
-import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.TIntList;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
+import org.junit.Test;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeCHTest extends LocationIndexTreeTest
-{
+public class LocationIndexTreeCHTest extends LocationIndexTreeTest {
     @Override
-    public LocationIndexTree createIndex( Graph g, int resolution )
-    {
+    public LocationIndexTree createIndex(Graph g, int resolution) {
         if (resolution < 0)
             resolution = 500000;
         return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
     @Override
-    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
-    {
+    public LocationIndexTree createIndexNoPrepare(Graph g, int resolution) {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIdx = new LocationIndexTree(g, dir);
         tmpIdx.setResolution(resolution);
@@ -61,15 +56,13 @@ public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     }
 
     @Override
-    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
-    {
+    GraphHopperStorage createGHStorage(Directory dir, EncodingManager encodingManager, boolean is3D) {
         return new GraphHopperStorage(Arrays.asList(new FastestWeighting(encodingManager.getEncoder("car"))), dir, encodingManager, is3D, new GraphExtension.NoOpExtension()).
                 create(100);
     }
 
     @Test
-    public void testCHGraph()
-    {
+    public void testCHGraph() {
         GraphHopperStorage ghStorage = createGHStorage(new RAMDirectory(), encodingManager, false);
         CHGraph lg = ghStorage.getGraph(CHGraph.class);
         // 0
@@ -108,8 +101,7 @@ public void testCHGraph()
     }
 
     @Test
-    public void testSortHighLevelFirst()
-    {
+    public void testSortHighLevelFirst() {
         GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
         final CHGraph lg = g.getGraph(CHGraph.class);
         lg.getNodeAccess().ensureNode(4);
@@ -120,11 +112,9 @@ public void testSortHighLevelFirst()
 
         // nodes with high level should come first to be covered by lower level nodes
         ArrayList<Integer> list = Helper.tIntListToArrayList(tlist);
-        Collections.sort(list, new Comparator<Integer>()
-        {
+        Collections.sort(list, new Comparator<Integer>() {
             @Override
-            public int compare( Integer o1, Integer o2 )
-            {
+            public int compare(Integer o1, Integer o2) {
                 return lg.getLevel(o2) - lg.getLevel(o1);
             }
         });
@@ -134,8 +124,7 @@ public int compare( Integer o1, Integer o2 )
     }
 
     @Test
-    public void testCHGraphBug()
-    {
+    public void testCHGraphBug() {
         // 0
         // |
         // | X  2--3
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index b57d83ceb2..9f2b7440c7 100755
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -25,30 +25,27 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+import org.junit.Test;
 
 import java.util.Arrays;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeTest extends AbstractLocationIndexTester
-{
+public class LocationIndexTreeTest extends AbstractLocationIndexTester {
     protected final EncodingManager encodingManager = new EncodingManager("car");
 
     @Override
-    public LocationIndexTree createIndex( Graph g, int resolution )
-    {
+    public LocationIndexTree createIndex(Graph g, int resolution) {
         if (resolution < 0)
             resolution = 500000;
         return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
-    {
+    public LocationIndexTree createIndexNoPrepare(Graph g, int resolution) {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
         tmpIDX.setResolution(resolution);
@@ -56,8 +53,7 @@ public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     }
 
     @Override
-    public boolean hasEdgeSupport()
-    {
+    public boolean hasEdgeSupport() {
         return true;
     }
 
@@ -66,8 +62,7 @@ public boolean hasEdgeSupport()
     // |1----3-\|
     // |____/   4
     // 2-------/
-    Graph createTestGraph( EncodingManager em )
-    {
+    Graph createTestGraph(EncodingManager em) {
         Graph graph = createGHStorage(new RAMDirectory(), em, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
@@ -86,8 +81,7 @@ Graph createTestGraph( EncodingManager em )
     }
 
     @Test
-    public void testSnappedPointAndGeometry()
-    {
+    public void testSnappedPointAndGeometry() {
         Graph graph = createTestGraph(encodingManager);
         LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
@@ -106,8 +100,7 @@ public void testSnappedPointAndGeometry()
     }
 
     @Test
-    public void testInMemIndex()
-    {
+    public void testInMemIndex() {
         Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndexNoPrepare(graph, 50000);
         index.prepareAlgo();
@@ -154,8 +147,7 @@ public void testInMemIndex()
     }
 
     @Test
-    public void testInMemIndex2()
-    {
+    public void testInMemIndex2() {
         Graph graph = createTestGraph2();
         LocationIndexTree index = createIndexNoPrepare(graph, 500);
         index.prepareAlgo();
@@ -195,8 +187,7 @@ public void testInMemIndex2()
     }
 
     @Test
-    public void testInMemIndex3()
-    {
+    public void testInMemIndex3() {
         LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
@@ -215,8 +206,7 @@ public void testInMemIndex3()
     }
 
     @Test
-    public void testReverseSpatialKey()
-    {
+    public void testReverseSpatialKey() {
         LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
@@ -226,8 +216,7 @@ public void testReverseSpatialKey()
     }
 
     @Test
-    public void testMoreReal()
-    {
+    public void testMoreReal() {
         Graph graph = createGHStorage(new EncodingManager("car"));
         NodeAccess na = graph.getNodeAccess();
         na.setNode(1, 51.2492152, 9.4317166);
@@ -251,8 +240,7 @@ public void testMoreReal()
     //  |  |/------/  /
     //-1|  2---------/
     //  |
-    private Graph createTestGraphWithWayGeometry()
-    {
+    private Graph createTestGraphWithWayGeometry() {
         Graph graph = createGHStorage(encodingManager);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
@@ -272,8 +260,7 @@ private Graph createTestGraphWithWayGeometry()
     }
 
     @Test
-    public void testWayGeometry()
-    {
+    public void testWayGeometry() {
         Graph g = createTestGraphWithWayGeometry();
         LocationIndex index = createIndex(g, -1);
         assertEquals(1, findID(index, 0, 0));
@@ -283,8 +270,7 @@ public void testWayGeometry()
     }
 
     @Test
-    public void testFindingWayGeometry()
-    {
+    public void testFindingWayGeometry() {
         Graph g = createGHStorage(encodingManager);
         NodeAccess na = g.getNodeAccess();
         na.setNode(10, 51.2492152, 9.4317166);
@@ -300,25 +286,21 @@ public void testFindingWayGeometry()
     }
 
     @Test
-    public void testEdgeFilter()
-    {
+    public void testEdgeFilter() {
         Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
-        assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
-        {
+        assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter() {
             @Override
-            public boolean accept( EdgeIteratorState iter )
-            {
+            public boolean accept(EdgeIteratorState iter) {
                 return iter.getBaseNode() == 2 || iter.getAdjNode() == 2;
             }
         }).getClosestNode());
     }
 
     // see testgraph2.jpg
-    Graph createTestGraph2()
-    {
+    Graph createTestGraph2() {
         Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(8, 49.94553, 11.57214);
@@ -413,8 +395,7 @@ Graph createTestGraph2()
     }
 
     @Test
-    public void testRMin()
-    {
+    public void testRMin() {
         Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndex(graph, 50000);
 
@@ -445,8 +426,7 @@ public void testRMin()
     }
 
     @Test
-    public void testSearchWithFilter_issue318()
-    {
+    public void testSearchWithFilter_issue318() {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
 
@@ -456,10 +436,8 @@ public void testSearchWithFilter_issue318()
 
         // distance from point to point is roughly 1 km
         int MAX = 5;
-        for (int latIdx = 0; latIdx < MAX; latIdx++)
-        {
-            for (int lonIdx = 0; lonIdx < MAX; lonIdx++)
-            {
+        for (int latIdx = 0; latIdx < MAX; latIdx++) {
+            for (int lonIdx = 0; lonIdx < MAX; lonIdx++) {
                 int index = lonIdx * 10 + latIdx;
                 na.setNode(index, 0.01 * latIdx, 0.01 * lonIdx);
                 if (latIdx < MAX - 1)
@@ -472,12 +450,10 @@ public void testSearchWithFilter_issue318()
 
         // reduce access for bike to two edges only
         AllEdgesIterator iter = graph.getAllEdges();
-        while (iter.next())
-        {
+        while (iter.next()) {
             iter.setFlags(bikeEncoder.setAccess(iter.getFlags(), false, false));
         }
-        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(graph, 0, 1), GHUtility.getEdge(graph, 1, 2)))
-        {
+        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(graph, 0, 1), GHUtility.getEdge(graph, 1, 2))) {
             edge.setFlags(bikeEncoder.setAccess(edge.getFlags(), true, true));
         }
 
@@ -500,8 +476,7 @@ public void testSearchWithFilter_issue318()
     // |  |  |  |
     // 4--5--6--7
     @Test
-    public void testCrossBoundaryNetwork_issue667()
-    {
+    public void testCrossBoundaryNetwork_issue667() {
         Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.1, 179.5);
@@ -535,8 +510,7 @@ public void testCrossBoundaryNetwork_issue667()
         index.prepareIndex();
 
         assertTrue(graph.getNodes() > 0);
-        for (int i = 0; i < graph.getNodes(); i++)
-        {
+        for (int i = 0; i < graph.getNodes(); i++) {
             QueryResult qr = index.findClosest(na.getLat(i), na.getLon(i), EdgeFilter.ALL_EDGES);
             assertEquals(i, qr.getClosestNode());
         }
diff --git a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
index cf96326da5..1b51abbccc 100755
--- a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
+++ b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
@@ -17,22 +17,20 @@
  */
 package com.graphhopper.util;
 
-import static org.junit.Assert.assertEquals;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
-public abstract class AbstractBitUtilTester
-{
+public abstract class AbstractBitUtilTester {
     protected BitUtil bitUtil = getBitUtil();
 
     abstract BitUtil getBitUtil();
 
     @Test
-    public void testToFloat()
-    {
+    public void testToFloat() {
         byte[] bytes = bitUtil.fromFloat(Float.MAX_VALUE);
         assertEquals(Float.MAX_VALUE, bitUtil.toFloat(bytes), 1e-9);
 
@@ -41,8 +39,7 @@ public void testToFloat()
     }
 
     @Test
-    public void testToDouble()
-    {
+    public void testToDouble() {
         byte[] bytes = bitUtil.fromDouble(Double.MAX_VALUE);
         assertEquals(Double.MAX_VALUE, bitUtil.toDouble(bytes), 1e-9);
 
@@ -51,8 +48,7 @@ public void testToDouble()
     }
 
     @Test
-    public void testToInt()
-    {
+    public void testToInt() {
         byte[] bytes = bitUtil.fromInt(Integer.MAX_VALUE);
         assertEquals(Integer.MAX_VALUE, bitUtil.toInt(bytes));
 
@@ -61,8 +57,7 @@ public void testToInt()
     }
 
     @Test
-    public void testToShort()
-    {
+    public void testToShort() {
         byte[] bytes = bitUtil.fromShort(Short.MAX_VALUE);
         assertEquals(Short.MAX_VALUE, bitUtil.toShort(bytes));
 
@@ -77,8 +72,7 @@ public void testToShort()
     }
 
     @Test
-    public void testToLong()
-    {
+    public void testToLong() {
         byte[] bytes = bitUtil.fromLong(Long.MAX_VALUE);
         assertEquals(Long.MAX_VALUE, bitUtil.toLong(bytes));
 
@@ -87,8 +81,7 @@ public void testToLong()
     }
 
     @Test
-    public void testToLastBitString()
-    {
+    public void testToLastBitString() {
         assertEquals("1", bitUtil.toLastBitString(1L, 1));
         assertEquals("01", bitUtil.toLastBitString(1L, 2));
         assertEquals("001", bitUtil.toLastBitString(1L, 3));
@@ -97,16 +90,14 @@ public void testToLastBitString()
     }
 
     @Test
-    public void testBitString2Long()
-    {
+    public void testBitString2Long() {
         String str = "01000000000110000011100000011110";
         assertEquals(str + "00000000000000000000000000000000", bitUtil.toBitString(bitUtil.fromBitString2Long(str)));
         assertEquals("1000000000000000000000000000000000000000000000000000000000000000", bitUtil.toBitString(1L << 63));
     }
 
     @Test
-    public void testReverse()
-    {
+    public void testReverse() {
         String str48 = "000000000000000000000000000000000000000000000000";
         long ret = bitUtil.reverse(bitUtil.fromBitString2Long(str48 + "0111000000000101"), 16);
         assertEquals(str48 + "1010000000001110", bitUtil.toBitString(ret, 64));
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index e7deb70b61..485b575940 100755
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -17,21 +17,19 @@
  */
 package com.graphhopper.util;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Johannes Pelzer
  * @author Peter Karich
  */
-public class AngleCalcTest
-{
+public class AngleCalcTest {
     private final AngleCalc AC = Helper.ANGLE_CALC;
 
     @Test
-    public void testOrientation()
-    {
+    public void testOrientation() {
         assertEquals(90.0, Math.toDegrees(AC.calcOrientation(0, 0, 1, 0)), 0.01);
         assertEquals(45.0, Math.toDegrees(AC.calcOrientation(0, 0, 1, 1)), 0.01);
         assertEquals(0.0, Math.toDegrees(AC.calcOrientation(0, 0, 0, 1)), 0.01);
@@ -44,8 +42,7 @@ public void testOrientation()
     }
 
     @Test
-    public void testAlignOrientation()
-    {
+    public void testAlignOrientation() {
         assertEquals(90.0, Math.toDegrees(AC.alignOrientation(Math.toRadians(90), Math.toRadians(90))), 0.001);
         assertEquals(225.0, Math.toDegrees(AC.alignOrientation(Math.toRadians(90), Math.toRadians(-135))), 0.001);
         assertEquals(-45.0, Math.toDegrees(AC.alignOrientation(Math.toRadians(-135), Math.toRadians(-45))), 0.001);
@@ -53,8 +50,7 @@ public void testAlignOrientation()
     }
 
     @Test
-    public void testCombined()
-    {
+    public void testCombined() {
         double orientation = AC.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
         assertEquals(132.7, Math.toDegrees(AC.alignOrientation(0, orientation)), 1);
 
@@ -63,8 +59,7 @@ public void testCombined()
     }
 
     @Test
-    public void testCalcAzimuth()
-    {
+    public void testCalcAzimuth() {
         assertEquals(45.0, AC.calcAzimuth(0, 0, 1, 1), 0.001);
         assertEquals(90.0, AC.calcAzimuth(0, 0, 0, 1), 0.001);
         assertEquals(180.0, AC.calcAzimuth(0, 0, -1, 0), 0.001);
@@ -73,14 +68,12 @@ public void testCalcAzimuth()
     }
 
     @Test
-    public void testAzimuthCompassPoint()
-    {
+    public void testAzimuthCompassPoint() {
         assertEquals("S", AC.azimuth2compassPoint(199));
     }
 
     @Test
-    public void testAtan2()
-    {
+    public void testAtan2() {
         // assertEquals(0, AngleCalc.atan2(0, 0), 1e-4);
         // assertEquals(0, AngleCalc.atan2(-0.002, 0), 1e-4);
         assertEquals(45, AngleCalc.atan2(5, 5) * 180 / Math.PI, 1e-2);
@@ -92,28 +85,26 @@ public void testAtan2()
         assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
         assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
     }
-    
+
     @Test
-    public void testConvertAzimuth2xaxisAngle()
-    {
-        assertEquals(Math.PI/2, AC.convertAzimuth2xaxisAngle(0), 1E-6);
-        assertEquals(Math.PI/2, Math.abs(AC.convertAzimuth2xaxisAngle(360)), 1E-6);
+    public void testConvertAzimuth2xaxisAngle() {
+        assertEquals(Math.PI / 2, AC.convertAzimuth2xaxisAngle(0), 1E-6);
+        assertEquals(Math.PI / 2, Math.abs(AC.convertAzimuth2xaxisAngle(360)), 1E-6);
         assertEquals(0, AC.convertAzimuth2xaxisAngle(90), 1E-6);
-        assertEquals(-Math.PI/2, AC.convertAzimuth2xaxisAngle(180), 1E-6);
+        assertEquals(-Math.PI / 2, AC.convertAzimuth2xaxisAngle(180), 1E-6);
         assertEquals(Math.PI, Math.abs(AC.convertAzimuth2xaxisAngle(270)), 1E-6);
-        assertEquals(-3*Math.PI/4, AC.convertAzimuth2xaxisAngle(225), 1E-6);
-        assertEquals(3*Math.PI/4, AC.convertAzimuth2xaxisAngle(315), 1E-6);
+        assertEquals(-3 * Math.PI / 4, AC.convertAzimuth2xaxisAngle(225), 1E-6);
+        assertEquals(3 * Math.PI / 4, AC.convertAzimuth2xaxisAngle(315), 1E-6);
     }
-    
+
     @Test
-    public void checkAzimuthConsitency()
-    {
-        double azimuthDegree =  AC.calcAzimuth(0, 0, 1, 1);
+    public void checkAzimuthConsitency() {
+        double azimuthDegree = AC.calcAzimuth(0, 0, 1, 1);
         double radianXY = AC.calcOrientation(0, 0, 1, 1);
         double radian2 = AC.convertAzimuth2xaxisAngle(azimuthDegree);
         assertEquals(radianXY, radian2, 1E-3);
 
-        azimuthDegree =  AC.calcAzimuth(0, 4, 1, 3);
+        azimuthDegree = AC.calcAzimuth(0, 4, 1, 3);
         radianXY = AC.calcOrientation(0, 4, 1, 3);
         radian2 = AC.convertAzimuth2xaxisAngle(azimuthDegree);
         assertEquals(radianXY, radian2, 1E-3);
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
index 627aff29eb..1ae9f58878 100755
--- a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
@@ -19,22 +19,19 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class BitUtilBigTest extends AbstractBitUtilTester
-{
+public class BitUtilBigTest extends AbstractBitUtilTester {
     @Override
-    BitUtil getBitUtil()
-    {
+    BitUtil getBitUtil() {
         return BitUtil.BIG;
     }
 
     @Test
-    public void testToBitString()
-    {
+    public void testToBitString() {
         assertEquals("0010101010101010101010101010101010101010101010101010101010101010", bitUtil.toBitString(Long.MAX_VALUE / 3));
         assertEquals("0111111111111111111111111111111111111111111111111111111111111111", bitUtil.toBitString(Long.MAX_VALUE));
 
@@ -45,8 +42,7 @@ public void testToBitString()
     }
 
     @Test
-    public void testFromBitString()
-    {
+    public void testFromBitString() {
         String str = "011011100";
         assertEquals(str + "0000000", bitUtil.toBitString(bitUtil.fromBitString(str)));
 
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
index aacb5198da..091b69b377 100755
--- a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
@@ -19,22 +19,19 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class BitUtilLittleTest extends AbstractBitUtilTester
-{
+public class BitUtilLittleTest extends AbstractBitUtilTester {
     @Override
-    BitUtil getBitUtil()
-    {
+    BitUtil getBitUtil() {
         return BitUtil.LITTLE;
     }
 
     @Test
-    public void testToBitString()
-    {
+    public void testToBitString() {
         assertEquals("0010101010101010101010101010101010101010101010101010101010101010", bitUtil.toBitString(Long.MAX_VALUE / 3));
         assertEquals("0111111111111111111111111111111111111111111111111111111111111111", bitUtil.toBitString(Long.MAX_VALUE));
 
@@ -45,8 +42,7 @@ public void testToBitString()
     }
 
     @Test
-    public void testFromBitString()
-    {
+    public void testFromBitString() {
         String str = "001110110";
         assertEquals(str + "0000000", bitUtil.toBitString(bitUtil.fromBitString(str)));
 
diff --git a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index cb6fd3cb8a..ab77565e81 100755
--- a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -18,39 +18,35 @@
 package com.graphhopper.util;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class BreadthFirstSearchTest
-{
+public class BreadthFirstSearchTest {
     int counter;
     TIntHashSet set = new TIntHashSet();
     TIntList list = new TIntArrayList();
 
     @Before
-    public void setup()
-    {
+    public void setup() {
         counter = 0;
     }
 
     @Test
-    public void testBFS()
-    {
-        BreadthFirstSearch bfs = new BreadthFirstSearch()
-        {
+    public void testBFS() {
+        BreadthFirstSearch bfs = new BreadthFirstSearch() {
             @Override
-            public boolean goFurther( int v )
-            {
+            public boolean goFurther(int v) {
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
@@ -81,13 +77,10 @@ public boolean goFurther( int v )
     }
 
     @Test
-    public void testBFS2()
-    {
-        BreadthFirstSearch bfs = new BreadthFirstSearch()
-        {
+    public void testBFS2() {
+        BreadthFirstSearch bfs = new BreadthFirstSearch() {
             @Override
-            public boolean goFurther( int v )
-            {
+            public boolean goFurther(int v) {
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
@@ -110,5 +103,4 @@ public boolean goFurther( int v )
         assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
     }
 
-
 }
diff --git a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index d083334f96..78f26bf9d9 100755
--- a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -17,23 +17,24 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
-
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
-public class CHEdgeIteratorTest
-{
+public class CHEdgeIteratorTest {
     @Test
-    public void testUpdateFlags()
-    {
+    public void testUpdateFlags() {
         CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         EncodingManager encodingManager = new EncodingManager(carFlagEncoder);
         FastestWeighting weighting = new FastestWeighting(carFlagEncoder);
diff --git a/core/src/test/java/com/graphhopper/util/ConfigMapTest.java b/core/src/test/java/com/graphhopper/util/ConfigMapTest.java
new file mode 100644
index 0000000000..4307fc92b1
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/ConfigMapTest.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class ConfigMapTest {
+    @Test
+    public void testPut() {
+        ConfigMap instance = new ConfigMap();
+        instance.put("int_val", 1);
+        instance.put("test_pest", true);
+
+        assertTrue(instance.get("test_pest", false));
+        assertFalse(instance.get("test_pest_", false));
+        assertEquals(1L, instance.getInt("int_val", 0));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index 98acd7d338..645b38411b 100755
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -28,32 +28,28 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author jansoe
  */
-public class DepthFirstSearchTest
-{
+public class DepthFirstSearchTest {
 
     int counter;
     TIntHashSet set = new TIntHashSet();
     TIntList list = new TIntArrayList();
 
     @Before
-    public void setup()
-    {
+    public void setup() {
         counter = 0;
     }
 
     @Test
-    public void testDFS1()
-    {
-        DepthFirstSearch dfs = new DepthFirstSearch()
-        {
+    public void testDFS1() {
+        DepthFirstSearch dfs = new DepthFirstSearch() {
             @Override
-            public boolean goFurther( int v )
-            {
+            public boolean goFurther(int v) {
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
@@ -80,13 +76,10 @@ public boolean goFurther( int v )
     }
 
     @Test
-    public void testDFS2()
-    {
-        DepthFirstSearch dfs = new DepthFirstSearch()
-        {
+    public void testDFS2() {
+        DepthFirstSearch dfs = new DepthFirstSearch() {
             @Override
-            public boolean goFurther( int v )
-            {
+            public boolean goFurther(int v) {
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 285b458cc5..001d0d2c84 100755
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -18,27 +18,23 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
 
 import static org.junit.Assert.*;
 
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public class DistanceCalcEarthTest
-{
+public class DistanceCalcEarthTest {
     private DistanceCalc dc = new DistanceCalcEarth();
 
     @Test
-    public void testCalcCircumference()
-    {
+    public void testCalcCircumference() {
         assertEquals(DistanceCalcEarth.C, dc.calcCircumference(0), 1e-7);
     }
 
     @Test
-    public void testDistance()
-    {
+    public void testDistance() {
         float lat = 24.235f;
         float lon = 47.234f;
         DistanceCalc approxDist = new DistancePlaneProjection();
@@ -86,8 +82,7 @@ public void testDistance()
     }
 
     @Test
-    public void testEdgeDistance()
-    {
+    public void testEdgeDistance() {
         double dist = dc.calcNormalizedEdgeDistance(49.94241, 11.544356,
                 49.937964, 11.541824,
                 49.942272, 11.555643);
@@ -105,8 +100,7 @@ public void testEdgeDistance()
     }
 
     @Test
-    public void testValidEdgeDistance()
-    {
+    public void testValidEdgeDistance() {
         assertTrue(dc.validEdgeDistance(49.94241, 11.544356, 49.937964, 11.541824, 49.942272, 11.555643));
         assertTrue(dc.validEdgeDistance(49.936624, 11.547636, 49.937964, 11.541824, 49.942272, 11.555643));
         assertTrue(dc.validEdgeDistance(49.940712, 11.556069, 49.937964, 11.541824, 49.942272, 11.555643));
@@ -125,8 +119,7 @@ public void testValidEdgeDistance()
     }
 
     @Test
-    public void testPrecisionBug()
-    {
+    public void testPrecisionBug() {
         DistanceCalc dist = new DistancePlaneProjection();
 //        DistanceCalc dist = new DistanceCalc();
         double queryLat = 42.56819, queryLon = 1.603231;
@@ -152,8 +145,7 @@ public void testPrecisionBug()
     }
 
     @Test
-    public void testPrecisionBug2()
-    {
+    public void testPrecisionBug2() {
         DistanceCalc distCalc = new DistancePlaneProjection();
         double queryLat = 55.818994, queryLon = 37.595354;
         double tmpLat = 55.81777239183573, tmpLon = 37.59598350366913;
diff --git a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
index 9224698f5d..d3a6fb9ce2 100755
--- a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
+++ b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
@@ -19,13 +19,13 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
 /**
  * @author Peter Karich
  */
-public class DouglasPeuckerTest
-{
+public class DouglasPeuckerTest {
 
     // get some real life points from graphhopper API
     // http://217.92.216.224:8080/?point=49.945642,11.571436&point=49.946001,11.580706
@@ -35,10 +35,11 @@
             + "[11.576840167720023,49.94727782787258],[11.576961425921949,49.94725827009808],[11.577226852861648,49.947215242994176],[11.577394863457863,49.94717668623872],[11.577511092517772,49.94715005041249],[11.577635517216523,49.947112238715114],"
             + "[11.577917149169382,49.94702655703634],[11.577969116970207,49.947010724552214],[11.578816061738493,49.94673523932849],[11.579533552666014,49.94648974269233],[11.580073719771365,49.946299007824784],[11.580253092503245,49.946237913062525],"
             + "[11.580604946179799,49.94608871518274],[11.580740546749693,49.94603041438826]]";
+    String points2 = "[[9.961074440801317,50.203764443183644],[9.96106605889796,50.20365789987872],[9.960999562464645,50.20318963087774],[9.96094144793469,50.202952888673984],[9.96223002587773,50.20267889356641],[9.962200968612752,50.20262022024289],"
+            + "[9.961859918278305,50.201853928011374],[9.961668810881722,50.20138565901039],[9.96216874485095,50.20128507617008],[9.961953795595925,50.20088553877664],[9.961899033827313,50.200686794534775],[9.961716680863127,50.20014066696481],[9.961588158344957,50.199798499043254]]";
 
     @Test
-    public void testParse()
-    {
+    public void testParse() {
         PointList pointList = new PointList();
         pointList.parse2DJSON("[[11.571499218899739,49.945605917549265],[11.571664621792689,49.94570668665409]]");
         assertEquals(49.945605917549265, pointList.getLatitude(0), 1e-6);
@@ -48,8 +49,7 @@ public void testParse()
     }
 
     @Test
-    public void testPathSimplify()
-    {
+    public void testPathSimplify() {
         PointList pointList = new PointList();
         pointList.parse2DJSON(points1);
         assertEquals(32, pointList.getSize());
@@ -59,8 +59,7 @@ public void testPathSimplify()
     }
 
     @Test
-    public void testSimplifyCheckPointCount()
-    {
+    public void testSimplifyCheckPointCount() {
         PointList pointList = new PointList();
         pointList.parse2DJSON(points1);
         DouglasPeucker dp = new DouglasPeucker().setMaxDistance(.5);
@@ -70,12 +69,8 @@ public void testSimplifyCheckPointCount()
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
     }
 
-    String points2 = "[[9.961074440801317,50.203764443183644],[9.96106605889796,50.20365789987872],[9.960999562464645,50.20318963087774],[9.96094144793469,50.202952888673984],[9.96223002587773,50.20267889356641],[9.962200968612752,50.20262022024289],"
-            + "[9.961859918278305,50.201853928011374],[9.961668810881722,50.20138565901039],[9.96216874485095,50.20128507617008],[9.961953795595925,50.20088553877664],[9.961899033827313,50.200686794534775],[9.961716680863127,50.20014066696481],[9.961588158344957,50.199798499043254]]";
-
     @Test
-    public void testSimplifyCheckPointOrder()
-    {
+    public void testSimplifyCheckPointOrder() {
         PointList pointList = new PointList();
         pointList.parse2DJSON(points2);
         assertEquals(13, pointList.getSize());
@@ -83,7 +78,7 @@ public void testSimplifyCheckPointOrder()
         assertEquals(11, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
         assertEquals("(50.203764443183644,9.961074440801317), (50.20318963087774,9.960999562464645), (50.202952888673984,9.96094144793469), (50.20267889356641,9.96223002587773), (50.201853928011374,9.961859918278305), "
-                        + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
+                + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
                 pointList.toString());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 3d4995a2f6..cf431375e0 100755
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -19,24 +19,21 @@
 
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
+import org.junit.Test;
 
 import static org.junit.Assert.*;
 
-import org.junit.Test;
-
 /**
  * @author Peter Karich
  */
-public class GHUtilityTest
-{
+public class GHUtilityTest {
     private final FlagEncoder carEncoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = new EncodingManager(carEncoder);
 
-    Graph createGraph()
-    {
+    Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
     }
 
@@ -47,8 +44,7 @@ Graph createGraph()
     //   6     \1
     //   ______/
     // 0/
-    Graph initUnsorted( Graph g )
-    {
+    Graph initUnsorted(Graph g) {
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 1);
         na.setNode(1, 2.5, 4.5);
@@ -69,8 +65,7 @@ Graph initUnsorted( Graph g )
     }
 
     @Test
-    public void testSort()
-    {
+    public void testSort() {
         Graph g = initUnsorted(createGraph());
         Graph newG = GHUtility.sortDFS(g, createGraph());
         assertEquals(g.getNodes(), newG.getNodes());
@@ -85,8 +80,7 @@ public void testSort()
     }
 
     @Test
-    public void testSort2()
-    {
+    public void testSort2() {
         Graph g = initUnsorted(createGraph());
         Graph newG = GHUtility.sortDFS(g, createGraph());
         assertEquals(g.getNodes(), newG.getNodes());
@@ -98,8 +92,7 @@ public void testSort2()
     }
 
     @Test
-    public void testSortDirected()
-    {
+    public void testSortDirected() {
         Graph g = createGraph();
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 1);
@@ -111,8 +104,7 @@ public void testSortDirected()
     }
 
     @Test
-    public void testCopyWithSelfRef()
-    {
+    public void testCopyWithSelfRef() {
         Graph g = initUnsorted(createGraph());
         EdgeIteratorState eb = g.edge(0, 0, 11, true);
 
@@ -123,8 +115,7 @@ public void testCopyWithSelfRef()
     }
 
     @Test
-    public void testCopy()
-    {
+    public void testCopy() {
         Graph g = initUnsorted(createGraph());
         EdgeIteratorState edgeState = g.edge(6, 5, 11, true);
         edgeState.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
@@ -167,8 +158,7 @@ public void testCopy()
     }
 
     @Test
-    public void testEdgeStuff()
-    {
+    public void testEdgeStuff() {
         assertEquals(6, GHUtility.createEdgeKey(1, 2, 3, false));
         assertEquals(7, GHUtility.createEdgeKey(2, 1, 3, false));
         assertEquals(7, GHUtility.createEdgeKey(1, 2, 3, true));
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 6a674ef42b..76b740af76 100755
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -17,6 +17,10 @@
  */
 package com.graphhopper.util;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
@@ -24,40 +28,36 @@
 import java.util.Locale;
 import java.util.Map;
 
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class HelperTest
-{
+public class HelperTest {
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         Helper.removeDir(new File("test"));
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.removeDir(new File("test"));
     }
 
     @Test
-    public void testCountBitValue() throws Exception
-    {
-        assertEquals(2, Helper.countBitValue(4));
+    public void testCountBitValue() throws Exception {
+        assertEquals(1, Helper.countBitValue(1));
+        assertEquals(2, Helper.countBitValue(2));
+        assertEquals(2, Helper.countBitValue(3));
+        assertEquals(3, Helper.countBitValue(4));
+        assertEquals(3, Helper.countBitValue(7));
+        assertEquals(4, Helper.countBitValue(8));
         assertEquals(5, Helper.countBitValue(20));
     }
 
     @Test
-    public void testUnzip() throws Exception
-    {
+    public void testUnzip() throws Exception {
         String to = "./target/tmp/test";
         Helper.removeDir(new File(to));
         new Unzipper().unzip("./src/test/resources/com/graphhopper/util/test.zip", to, false);
@@ -68,8 +68,7 @@ public void testUnzip() throws Exception
     }
 
     @Test
-    public void testGetLocale() throws Exception
-    {
+    public void testGetLocale() throws Exception {
         assertEquals(Locale.GERMAN, Helper.getLocale("de"));
         assertEquals(Locale.GERMANY, Helper.getLocale("de_DE"));
         assertEquals(Locale.GERMANY, Helper.getLocale("de-DE"));
@@ -79,24 +78,21 @@ public void testGetLocale() throws Exception
     }
 
     @Test
-    public void testRound()
-    {
+    public void testRound() {
         assertEquals(100.94, Helper.round(100.94, 2), 1e-7);
         assertEquals(100.9, Helper.round(100.94, 1), 1e-7);
         assertEquals(101.0, Helper.round(100.95, 1), 1e-7);
     }
 
     @Test
-    public void testKeepIn()
-    {
+    public void testKeepIn() {
         assertEquals(2, Helper.keepIn(2, 1, 4), 1e-2);
         assertEquals(3, Helper.keepIn(2, 3, 4), 1e-2);
         assertEquals(3, Helper.keepIn(-2, 3, 4), 1e-2);
     }
 
     @Test
-    public void testLoadProperties() throws IOException
-    {
+    public void testLoadProperties() throws IOException {
         Map<String, String> map = new HashMap<String, String>();
         Helper.loadProperties(map, new StringReader("blup=test\n blup2 = xy"));
         assertEquals("test", map.get("blup"));
@@ -104,8 +100,7 @@ public void testLoadProperties() throws IOException
     }
 
     @Test
-    public void testUnsignedConversions()
-    {
+    public void testUnsignedConversions() {
         long l = Helper.toUnsignedLong(-1);
         assertEquals(4294967295L, l);
         assertEquals(-1, Helper.toSignedInt(l));
@@ -127,18 +122,16 @@ public void testUnsignedConversions()
     }
 
     @Test
-    public void testCamelCaseToUnderscore()
-    {
+    public void testCamelCaseToUnderscore() {
         assertEquals("test_case", Helper.camelCaseToUnderScore("testCase"));
         assertEquals("test_case_t_b_d", Helper.camelCaseToUnderScore("testCaseTBD"));
         assertEquals("_test_case", Helper.camelCaseToUnderScore("TestCase"));
-        
+
         assertEquals("_test_case", Helper.camelCaseToUnderScore("_test_case"));
     }
 
     @Test
-    public void testUnderscoreToCamelCase()
-    {
+    public void testUnderscoreToCamelCase() {
         assertEquals("testCase", Helper.underScoreToCamelCase("test_case"));
         assertEquals("testCaseTBD", Helper.underScoreToCamelCase("test_case_t_b_d"));
         assertEquals("TestCase_", Helper.underScoreToCamelCase("_test_case_"));
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 094ece9145..31fa5a97d0 100755
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -18,38 +18,36 @@
 package com.graphhopper.util;
 
 import com.graphhopper.reader.ReaderWay;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
-
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.NodeAccess;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.xml.sax.SAXException;
 
-import java.io.*;
-import java.util.*;
 import javax.xml.XMLConstants;
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
-
-import org.json.JSONObject;
-import org.junit.Test;
+import java.io.StringReader;
+import java.util.*;
 
 import static org.junit.Assert.*;
 
-import org.junit.Before;
-import org.xml.sax.SAXException;
-
 /**
  * @author Peter Karich
  */
-public class InstructionListTest
-{
+public class InstructionListTest {
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
@@ -57,16 +55,14 @@
     private FlagEncoder carEncoder;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         carEncoder = new CarFlagEncoder();
         carManager = new EncodingManager(carEncoder);
     }
 
     @SuppressWarnings("unchecked")
     @Test
-    public void testWayList()
-    {
+    public void testWayList() {
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -112,7 +108,7 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
@@ -142,7 +138,7 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
 
@@ -155,28 +151,24 @@ public void testWayList()
                 wayList.createStartPoints());
 
         // special case of identical start and end
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
         wayList = p.calcInstructions(usTR);
         assertEquals(1, wayList.size());
         assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
     }
 
-    List<String> pick( String key, List<Map<String, Object>> instructionJson )
-    {
+    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
         List<String> list = new ArrayList<String>();
 
-        for (Map<String, Object> json : instructionJson)
-        {
+        for (Map<String, Object> json : instructionJson) {
             list.add(json.get(key).toString());
         }
         return list;
     }
 
-    List<List<Double>> createList( PointList pl, List<Integer> integs )
-    {
+    List<List<Double>> createList(PointList pl, List<Integer> integs) {
         List<List<Double>> list = new ArrayList<List<Double>>();
-        for (int i : integs)
-        {
+        for (int i : integs) {
             List<Double> entryList = new ArrayList<Double>(2);
             entryList.add(pl.getLatitude(i));
             entryList.add(pl.getLongitude(i));
@@ -185,37 +177,30 @@ public void testWayList()
         return list;
     }
 
-    void compare( List<List<Double>> expected, List<List<Double>> was )
-    {
-        for (int i = 0; i < expected.size(); i++)
-        {
+    void compare(List<List<Double>> expected, List<List<Double>> was) {
+        for (int i = 0; i < expected.size(); i++) {
             List<Double> e = expected.get(i);
             List<Double> wasE = was.get(i);
-            for (int j = 0; j < e.size(); j++)
-            {
+            for (int j = 0; j < e.size(); j++) {
                 assertEquals("at " + j + " value " + e + " vs " + wasE, e.get(j), wasE.get(j), 1e-5d);
             }
         }
     }
 
-    List<Double> asL( Double... list )
-    {
+    List<Double> asL(Double... list) {
         return Arrays.asList(list);
     }
 
-    double sumDistances( InstructionList il )
-    {
+    double sumDistances(InstructionList il) {
         double val = 0;
-        for (Instruction i : il)
-        {
+        for (Instruction i : il) {
             val += i.getDistance();
         }
         return val;
     }
 
     @Test
-    public void testWayList2()
-    {
+    public void testWayList2() {
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -237,14 +222,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -253,8 +238,7 @@ public void testWayList2()
 
     // problem: we normally don't want instructions if streetname stays but here it is suboptimal:
     @Test
-    public void testNoInstructionIfSameStreet()
-    {
+    public void testNoInstructionIfSameStreet() {
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -276,15 +260,14 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
     }
 
     @Test
-    public void testInstructionsWithTimeAndPlace()
-    {
+    public void testInstructionsWithTimeAndPlace() {
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -303,7 +286,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -347,8 +330,7 @@ public void testInstructionsWithTimeAndPlace()
     }
 
     @Test
-    public void testRoundaboutJsonIntegrity()
-    {
+    public void testRoundaboutJsonIntegrity() {
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -374,8 +356,7 @@ public void testRoundaboutJsonIntegrity()
 
     // Roundabout with unknown dir of rotation
     @Test
-    public void testRoundaboutJsonNaN()
-    {
+    public void testRoundaboutJsonNaN() {
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -397,16 +378,13 @@ public void testRoundaboutJsonNaN()
     }
 
     @Test
-    public void testCreateGPXWithEle()
-    {
+    public void testCreateGPXWithEle() {
         final List<GPXEntry> fakeList = new ArrayList<GPXEntry>();
         fakeList.add(new GPXEntry(12, 13, 0));
         fakeList.add(new GPXEntry(12.5, 13, 1000));
-        InstructionList il = new InstructionList(usTR)
-        {
+        InstructionList il = new InstructionList(usTR) {
             @Override
-            public List<GPXEntry> createGPXList()
-            {
+            public List<GPXEntry> createGPXList() {
                 return fakeList;
             }
         };
@@ -425,8 +403,7 @@ public void testCreateGPXWithEle()
     }
 
     @Test
-    public void testCreateGPX()
-    {
+    public void testCreateGPX() {
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         InstructionList instructions = new InstructionList(usTR);
         PointList pl = new PointList();
@@ -455,8 +432,7 @@ public void testCreateGPX()
         verifyGPX(instructions.createGPX());
     }
 
-    private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour )
-    {
+    private long flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "motorway");
         way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
@@ -464,42 +440,35 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
     }
 
     @Test
-    public void testEmptyList()
-    {
+    public void testEmptyList() {
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
     }
 
-    public void verifyGPX( String gpx )
-    {
+    public void verifyGPX(String gpx) {
         SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
         Schema schema = null;
-        try
-        {
+        try {
             Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
             schema = schemaFactory.newSchema(schemaFile);
 
             // using more schemas: http://stackoverflow.com/q/1094893/194609
-        } catch (SAXException e1)
-        {
+        } catch (SAXException e1) {
             throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
         }
         Validator validator = schema.newValidator();
-        try
-        {
+        try {
             validator.validate(new StreamSource(new StringReader(gpx)));
-        } catch (Exception e)
-        {
+        } catch (Exception e) {
             throw new RuntimeException(e);
         }
     }
 
     @Test
-    public void testFind()
-    {
+    public void testFind() {
         Graph g = new GraphBuilder(carManager).create();
         //   n-4-5   (n: pillar node)
         //   |
@@ -520,7 +489,7 @@ public void testFind()
         g.edge(3, 4, 10000, true).setName("3-4").setWayGeometry(waypoint);
         g.edge(4, 5, 10000, true).setName("4-5");
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
 
         // query on first edge, get instruction for second edge
@@ -537,8 +506,7 @@ public void testFind()
     }
 
     @Test
-    public void testXMLEscape_issue572()
-    {
+    public void testXMLEscape_issue572() {
         assertEquals("_", InstructionList.simpleXMLEscape("<"));
         assertEquals("_blup_", InstructionList.simpleXMLEscape("<blup>"));
         assertEquals("a&amp;b", InstructionList.simpleXMLEscape("a&b"));
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 5033d515af..964568ab11 100755
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -19,16 +19,15 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Johannes Pelzer
  */
-public class InstructionTest
-{
+public class InstructionTest {
     @Test
-    public void testCalcAzimuthAndGetDirection()
-    {
+    public void testCalcAzimuthAndGetDirection() {
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
diff --git a/core/src/test/java/com/graphhopper/util/PMapTest.java b/core/src/test/java/com/graphhopper/util/PMapTest.java
index 0372f4b234..1487894e96 100755
--- a/core/src/test/java/com/graphhopper/util/PMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/PMapTest.java
@@ -20,24 +20,19 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
-public class PMapTest
-{
+public class PMapTest {
 
     @Test
-    public void singleStringPropertyCanBeRetrieved()
-    {
+    public void singleStringPropertyCanBeRetrieved() {
         PMap subject = new PMap("foo=bar");
 
         Assert.assertEquals("bar", subject.get("foo"));
     }
 
     @Test
-    public void propertyFromStringWithMultiplePropertiesCanBeRetrieved()
-    {
+    public void propertyFromStringWithMultiplePropertiesCanBeRetrieved() {
         PMap subject = new PMap("foo=valueA|bar=valueB");
 
         Assert.assertEquals("valueA", subject.get("foo", ""));
@@ -45,8 +40,7 @@ public void propertyFromStringWithMultiplePropertiesCanBeRetrieved()
     }
 
     @Test
-    public void keyCannotHaveAnyCasing()
-    {
+    public void keyCannotHaveAnyCasing() {
         PMap subject = new PMap("foo=valueA|bar=valueB");
 
         assertEquals("valueA", subject.get("foo", ""));
@@ -54,24 +48,21 @@ public void keyCannotHaveAnyCasing()
     }
 
     @Test
-    public void numericPropertyCanBeRetrievedAsLong()
-    {
+    public void numericPropertyCanBeRetrievedAsLong() {
         PMap subject = new PMap("foo=1234|bar=5678");
 
         assertEquals(1234L, subject.getLong("foo", 0));
     }
 
     @Test
-    public void numericPropertyCanBeRetrievedAsDouble()
-    {
+    public void numericPropertyCanBeRetrievedAsDouble() {
         PMap subject = new PMap("foo=123.45|bar=56.78");
 
         assertEquals(123.45, subject.getDouble("foo", 0), 1e-4);
     }
 
     @Test
-    public void hasReturnsCorrectResult()
-    {
+    public void hasReturnsCorrectResult() {
         PMap subject = new PMap("foo=123.45|bar=56.78");
 
         assertTrue(subject.has("foo"));
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index 18e603e033..fa1c91c7ad 100755
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,16 +20,14 @@
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class PointListTest
-{
+public class PointListTest {
     @Test
-    public void testEquals()
-    {
+    public void testEquals() {
         assertEquals(Helper.createPointList(), PointList.EMPTY);
         PointList list1 = Helper.createPointList(38.5, -120.2, 43.252, -126.453, 40.7, -120.95,
                 50.3139, 10.612793, 50.04303, 9.497681);
@@ -39,8 +37,7 @@ public void testEquals()
     }
 
     @Test
-    public void testReverse()
-    {
+    public void testReverse() {
         PointList instance = new PointList();
         instance.add(1, 1);
         instance.reverse();
@@ -58,11 +55,9 @@ public void testReverse()
     }
 
     @Test
-    public void testAddPL()
-    {
+    public void testAddPL() {
         PointList instance = new PointList();
-        for (int i = 0; i < 7; i++)
-        {
+        for (int i = 0; i < 7; i++) {
             instance.add(0, 0);
         }
         assertEquals(7, instance.getSize());
@@ -83,22 +78,19 @@ public void testAddPL()
         assertEquals(12, instance.getSize());
         assertEquals(24, instance.getCapacity());
 
-        for (int i = 0; i < toAdd.size(); i++)
-        {
+        for (int i = 0; i < toAdd.size(); i++) {
             assertEquals(toAdd.getLatitude(i), instance.getLatitude(7 + i), 1e-1);
         }
     }
 
     @Test
-    public void testIterable()
-    {
+    public void testIterable() {
         PointList toAdd = new PointList();
         toAdd.add(1, 1);
         toAdd.add(2, 2);
         toAdd.add(3, 3);
         int counter = 0;
-        for (GHPoint point : toAdd)
-        {
+        for (GHPoint point : toAdd) {
             counter++;
             assertEquals(counter, point.getLat(), 0.1);
         }
diff --git a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
index 68b16f0cc2..3e2fc1655f 100755
--- a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
+++ b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
@@ -19,24 +19,22 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class SimpleIntDequeTest
-{
+public class SimpleIntDequeTest {
     @Test
-    public void testSmall()
-    {
+    public void testSmall() {
         SimpleIntDeque deque = new SimpleIntDeque(8, 2f);
         assertTrue(deque.isEmpty());
         assertEquals(0, deque.getSize());
     }
 
     @Test
-    public void testEmpty()
-    {
+    public void testEmpty() {
         SimpleIntDeque deque = new SimpleIntDeque(1, 2f);
         deque.push(1);
         assertEquals(1, deque.getSize());
@@ -47,12 +45,10 @@ public void testEmpty()
     }
 
     @Test
-    public void testPush()
-    {
+    public void testPush() {
         SimpleIntDeque deque = new SimpleIntDeque(8, 2f);
 
-        for (int i = 0; i < 60; i++)
-        {
+        for (int i = 0; i < 60; i++) {
             deque.push(i);
             assertEquals(i + 1, deque.getSize());
         }
@@ -70,8 +66,7 @@ public void testPush()
         deque.push(3);
         assertEquals(60, deque.getSize());
 
-        for (int i = 0; i < 50; i++)
-        {
+        for (int i = 0; i < 50; i++) {
             assertEquals(i + 2, deque.pop());
         }
 
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index bdc0f86fae..fe60923295 100755
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -17,23 +17,22 @@
  */
 package com.graphhopper.util;
 
-import java.util.Locale;
-
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class TranslationMapTest
-{
+public class TranslationMapTest {
     // use a static singleton to parse the I18N files only once per test execution
     public final static TranslationMap SINGLETON = new TranslationMap().doImport();
 
     @Test
-    public void testToString()
-    {
+    public void testToString() {
         Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
         assertEquals("continue onto blp street", enMap.tr("continue_onto", "blp street"));
 
@@ -64,8 +63,7 @@ public void testToString()
     }
 
     @Test
-    public void testToRoundaboutString()
-    {
+    public void testToRoundaboutString() {
         Translation ptMap = SINGLETON.get("pt");
         assertTrue(ptMap.tr("roundabout_exit_onto", "1", "somestreet").contains("somestreet"));
     }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index 0551aa3f9d..81dbd4f8c9 100755
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -19,18 +19,16 @@
 
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
-import org.junit.*;
+import org.junit.Test;
 
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class BBoxTest
-{
+public class BBoxTest {
     @Test
-    public void testCreate()
-    {
+    public void testCreate() {
         DistanceCalc c = new DistanceCalcEarth();
         BBox b = c.createBBox(52, 10, 100000);
 
@@ -48,8 +46,7 @@ public void testCreate()
     }
 
     @Test
-    public void testContains()
-    {
+    public void testContains() {
         assertTrue(new BBox(1, 2, 0, 1).contains(new BBox(1, 2, 0, 1)));
         assertTrue(new BBox(1, 2, 0, 1).contains(new BBox(1.5, 2, 0.5, 1)));
         assertFalse(new BBox(1, 2, 0, 0.5).contains(new BBox(1.5, 2, 0.5, 1)));
@@ -60,8 +57,7 @@ public void testContains()
     }
 
     @Test
-    public void testIntersect()
-    {
+    public void testIntersect() {
         //    ---
         //    | |
         // ---------
@@ -86,49 +82,40 @@ public void testIntersect()
     }
 
     @Test
-    public void testBasicJavaOverload()
-    {
-        new BBox(2, 4, 0, 1)
-        {
+    public void testBasicJavaOverload() {
+        new BBox(2, 4, 0, 1) {
             @Override
-            public boolean intersect( Circle c )
-            {
+            public boolean intersect(Circle c) {
                 assertTrue(true);
                 return super.intersect(c);
             }
 
             @Override
-            public boolean intersect( Shape c )
-            {
+            public boolean intersect(Shape c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect( BBox c )
-            {
+            public boolean intersect(BBox c) {
                 assertTrue(false);
                 return true;
             }
-        }.intersect(new Circle(1, 2, 3)
-        {
+        }.intersect(new Circle(1, 2, 3) {
             @Override
-            public boolean intersect( Circle c )
-            {
+            public boolean intersect(Circle c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect( Shape b )
-            {
+            public boolean intersect(Shape b) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect( BBox b )
-            {
+            public boolean intersect(BBox b) {
                 assertTrue(true);
                 return true;
             }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index 0a4161f6c5..ed63c1708d 100755
--- a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -17,25 +17,23 @@
  */
 package com.graphhopper.util.shapes;
 
-import org.junit.*;
+import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class CircleTest
-{
+public class CircleTest {
     @Test
-    public void testIntersectCircleCircle()
-    {
+    public void testIntersectCircleCircle() {
         assertTrue(new Circle(0, 0, 80000).intersect(new Circle(1, 1, 80000)));
         assertFalse(new Circle(0, 0, 75000).intersect(new Circle(1, 1, 80000)));
     }
 
     @Test
-    public void testIntersectCircleBBox()
-    {
+    public void testIntersectCircleBBox() {
         assertTrue(new Circle(10, 10, 120000).intersect(new BBox(9, 11, 8, 9)));
         assertTrue(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 120000)));
 
@@ -44,8 +42,7 @@ public void testIntersectCircleBBox()
     }
 
     @Test
-    public void testContains()
-    {
+    public void testContains() {
         Circle c = new Circle(10, 10, 120000);
         assertTrue(c.contains(new BBox(9, 11, 10, 10.1)));
         assertFalse(c.contains(new BBox(9, 11, 8, 9)));
@@ -53,8 +50,7 @@ public void testContains()
     }
 
     @Test
-    public void testContainsCircle()
-    {
+    public void testContainsCircle() {
         Circle c = new Circle(10, 10, 120000);
         assertTrue(c.contains(new Circle(9.9, 10.2, 90000)));
         assertFalse(c.contains(new Circle(10, 10.4, 90000)));
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index 774499a3d3..f21c6be450 100755
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -17,14 +17,9 @@
  */
 package com.graphhopper.util.shapes;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
 /**
  * @author Peter Karich
  */
-public class CoordTrigTest
-{
+public class CoordTrigTest {
 
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
index a54231519e..f423a4388d 100755
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -19,16 +19,15 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 
 /**
  * @author Peter Karich
  */
-public class GHPoint3DTest
-{
+public class GHPoint3DTest {
     @Test
-    public void testEquals()
-    {
+    public void testEquals() {
         GHPoint3D point1 = new GHPoint3D(1, 2, Double.NaN);
         GHPoint3D point2 = new GHPoint3D(1, 2, Double.NaN);
         assertEquals(point1, point2);
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
index 276a49aa18..278251f37f 100755
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -19,16 +19,15 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class GHPointTest
-{
+public class GHPointTest {
     @Test
-    public void testIsValid()
-    {
+    public void testIsValid() {
         GHPoint instance = new GHPoint();
         assertFalse(instance.isValid());
         instance.lat = 1;
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
index 913bee91b9..9ba53c6fe8 100755
--- a/docs/android/android-studio-setup.md
+++ b/docs/android/android-studio-setup.md
@@ -5,7 +5,6 @@ Get the [GraphHopper sources and demo](./index.md) before you proceed.
 ## Setup
 
 [Download](http://developer.android.com/sdk/index.html) and start android studio. 
-Now you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar
 
 Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
 
diff --git a/docs/android/index.md b/docs/android/index.md
index 883563ad9c..dfff89e9ab 100755
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -1,11 +1,11 @@
 # Get Demo
 
-[Download GraphHopper Demo APK](http://graphhopper.com/#download)
+[Download GraphHopper Demo APK](http://graphhopper.com/#community)
 
 # Set-up Development
 
 As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) 
-which can be used from Android Studio, NetBeans, gradle or maven.
+which can be used directly from Android Studio and NetBeans via gradle or maven.
 
 Before the installation fetch the source, the OpenStreetMap data and the dependencies:
 
@@ -38,9 +38,9 @@ $ gradle installDebug
 
 ## Maps
 
-Now that you have a running android app you need to copy somehow the routing and maps data. 
+Now that you have a running Android app you need to copy the routing and maps data to the device. 
 
- 1. [Download the raw openstreetmap file](http://download.geofabrik.de/openstreetmap/) - you'll need that only for the next step to create the routing data
+ 1. [Download the raw openstreetmap file](http://download.geofabrik.de/openstreetmap/) - you'll need that for the next step to create the routing data
  2. Execute `./graphhopper.sh import <your-osm-file>`. This creates the routing data
  3. [Download a map](http://download.mapsforge.org/maps/) e.g. berlin.map
  4. Copy berlin.map into the created berlin-gh folder
diff --git a/docs/core/ch.md b/docs/core/ch.md
index f1e3ef6e8c..c8c1540921 100755
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -8,4 +8,4 @@ which allows to store shortcuts too.
 
 A prepared graph can also be used for normal graph traversal IF you use chGraph.getBaseGraph().
 
-If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
+If CH is enabled multiple vehicles will work.
diff --git a/docs/core/deploy.md b/docs/core/deploy.md
index 43fa07d9a4..09e34c0d5f 100755
--- a/docs/core/deploy.md
+++ b/docs/core/deploy.md
@@ -19,39 +19,39 @@ export JAVA=java-home/bin/java
 export JAVA_OPTIONS="-server -Xconcurrentio -Xmx17000m -Xms17000m"
 ```
 
-Important notes:
+Notes:
 
  * jsonp support needs to be enabled in the config.properties
- * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/104)
- * if you have strange speed problems which could be related to low memory you can try to [entire disable swap](http://askubuntu.com/questions/103915/how-do-i-configure-swappiness). Or just try it out via `sudo swapoff -a`. Swapping out is very harmful to Java programs especially when the GC kicks in.
+ * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/734)
 
 ### API Tokens
 
-By default, GraphHopper uses [Omniscale](http://omniscale.com/) as layer service. 
-Either you get a plan there or you have to remove Omniscale from the [JavaScript file](https://github.com/graphhopper/graphhopper/blob/master/web/src/main/webapp/js/main.js). 
+By default, GraphHopper uses [Omniscale](http://omniscale.com/) and/or [Thunderforest](http://thunderforest.com/) as layer service. 
+Either you get a plan there, then set the API key in the options.js file or you 
+have to remove Omniscale from the [JavaScript file](https://github.com/graphhopper/graphhopper/blob/master/web/src/main/webapp/js/main.js). 
  
 GraphHopper uses the [GraphHopper Directions API](https://graphhopper.com/api/1/docs/) for geocoding. To be able to use the autocomplete feature of the point inputs you have to:
 
- * Get your API Token at: https://graphhopper.com/
- * Uncomment this [line](https://github.com/graphhopper/graphhopper/blob/master/web/src/main/webapp/js/main-template.js#L37) and insert your API Token as second parameter.
-   * Don't forget the Attribution
+ * Get your API Token at: https://graphhopper.com/ and set this in the options.js
+ * Don't forget the Attribution
  
 ## World Wide 
 
-GraphHopper is able to handle coverage for the whole [Openstreetmap road network](http://planet.osm.org/). 
+GraphHopper is able to handle coverage for the whole [OpenStreetMap road network](http://planet.osm.org/). 
 It needs approximately 22GB RAM for the import (CAR only) and ~1 hour (plus ~5h for contraction). 
-If you can accept slower import times this can be reduced to 14GB RAM - you'll need to set osmreader.dataaccess=MMAP
+If you can accept slower import times this can be reduced to 14GB RAM - you'll need to set datareader.dataaccess=MMAP
 
-Then, to run the web service with this world wide graph 'only' 15GB are necessary. Without contraction hierarchy 
-this would be about 9GB.
+Then 'only' 15GB are necessary. Without contraction hierarchy this would be about 9GB.
 
 With CH the service is able to handle about 180 queries per second (from localhost to localhost this was 300qps). 
 Measured for CAR routing, real world requests, at least 100km long, on a linux machine with 8 cores and 32GB, 
-java 1.7.0_25, jetty 8.1.10 via custom QueryTorture class (10 worker threads).
+java 1.7.0_25, jetty 8.1.10 via the QueryTorture class (10 worker threads).
 
-### JVM
+### System and JVM tuning
 
-If GC pauses are too long try `-XX:+UseG1GC`
+Especially for large heaps you should use `-XX:+UseG1GC`. Optionally add `-XX:MetaspaceSize=100M`.
+
+Avoid swapping e.g. on linux via `vm.swappiness=0` in /etc/sysctl.conf. See some tuning discussion in the answers [here](http://stackoverflow.com/q/38905739/194609).
 
 ### Elevation Data 
 
@@ -64,8 +64,3 @@ If you want to use elevation data you need to increase the allowed number of ope
  * add: `fs.file-max = 90000`
  * reboot now (or sudo sysctl -p; and re-login)
  * afterwards `ulimit -Hn` and `ulimit -Sn` should give you 100000
-
-
-### TODOs
-
- * Try out to disable NUMA -> http://engineering.linkedin.com/performance/optimizing-linux-memory-management-low-latency-high-throughput-databases
diff --git a/docs/core/eclipse-tomcat-setup.md b/docs/core/eclipse-tomcat-setup.md
index 40365e4836..a74e883e82 100755
--- a/docs/core/eclipse-tomcat-setup.md
+++ b/docs/core/eclipse-tomcat-setup.md
@@ -82,7 +82,7 @@ At this step you need to include specific VM arguments corresponds to _map_ and
 * In “(x)= Arguments”  tab,  and in “VM arguments” part, add the necessary arguments and their corresponding paths that are not included. You only need to add the below arguments and paths:
  * **1.-Dgraphhopper.config="_Path to config.properties file_"**: config.properties is a file that contains GraphHopper's configurations.
  * **2.-Dgraphhopper.graph.location="_Path to graph folder_"**: In _graph_ folder ( with any optional name) a graph would be created. Upon running GraphHopper a folder ( with the name defined in VM arguments) will be created to keep the graph. So do not worry about manually creating it in the configuration folder.
- * **3.-Dgraphhopper.osmreader.osm="_Path to map.osm file_"**:  *.osm file contains the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. 
+ * **3.-Dgraphhopper.datareader.file="_Path to map.osm or map.pbf file_"**:  *.osm file contains the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. 
 
 ![](./images/8.jpg)
 
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index 69a18b839a..160d8bff78 100755
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -1,3 +1,5 @@
+# Location Index
+
 You get the location index from the GraphHopper instance, after you imported or loaded the data:
 
 ```java
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index de8cf7fe1a..73c5b09624 100755
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -21,9 +21,12 @@ edges the same applies for edge IDs too.
 
 ### What are virtual edges and nodes?
 
-For a route you do not only need *junction-precision*, i.e. from tower node to tower node, but we want *GPS-precise* routes, otherwise [you'll get lots of trouble](https://github.com/graphhopper/graphhopper/issues/27) for oneways and similar.
+For a route you do not only need *junction-precision*, i.e. from tower node to tower node, but we want 
+*GPS-precise* routes, otherwise [you'll get lots of trouble](https://github.com/graphhopper/graphhopper/issues/27) 
+for oneways and similar.
 
-To make GPS precise routes possible, although we route from tower node to tower node, we introduce one new virtual node x and virtual edges A-x, x-B for every query point located on an edge A-B:
+To make GPS precise routes possible, although we route from tower node to tower node, we introduce one new 
+virtual node x and virtual edges A-x, x-B for every query point located on an edge A-B:
 
 ```bash
 \                /
@@ -31,11 +34,13 @@ To make GPS precise routes possible, although we route from tower node to tower
 /                \
 ```
 
-But we need to decouple requests from each other and therefor we create a very lightweight graph called `QueryGraph` for every request which handles also stuff like two query points on the same edge.
+But we need to decouple requests from each other and therefor we create a very lightweight graph called 
+`QueryGraph` for every request which handles also stuff like two query points on the same edge.
 
 The virtual nodes and edges have a higher `int` ID than `graph.getNodes()` or `allEdges.getMaxId()`
 
-A call `queryGraph.lookup(allQRs)` will determine the correct node for all `QueryResult`s: and either create new virtual nodes or if close enough use the existing junction node.
+A call `queryGraph.lookup(allQRs)` will determine the correct node for all `QueryResult`s: and either 
+create new virtual nodes or if close enough use the existing junction node.
 
 ### Create and save the graph
 
@@ -48,7 +53,7 @@ GraphStorage graph = gb.create();
 EdgeIteratorState edge = graph.edge(fromId, toId);
 edge.setDistance(distance);
 edge.setFlags(encoder.setProperties(speed, true, true));
-// Store to disc
+// Flush to disc
 graph.flush();
 ```
 
@@ -117,7 +122,7 @@ queryGraph.lookup(fromQR, toQR);
 
 // create the algorithm using the PrepareContractionHierarchies object
 AlgorithmOptions algoOpts = AlgorithmOptions.start().
-   algorithm(Parameters.Algorithms.DIJKSTRA_BI).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+   algorithm(Parameters.Algorithms.DIJKSTRA_BI).traversalMode(tMode).weighting(weighting).
    build();
 RoutingAlgorithm algorithm = pch.createAlgo(queryGraph, algoOpts);
 Path path = algorithm.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index f6ccb51590..8eb2df1e5a 100755
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -1,11 +1,13 @@
 # GraphHopper - Quick Start Guide for Developers
 
+[Watch this video](https://www.youtube.com/watch?v=HBVe_E5j0TM) for a simple introduction.
+
 ## Try out
 
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md). 
 
-Now, before you proceed install git and jdk7 or 8, then do:
+Now, before you proceed install git and jdk8, then do:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git
@@ -29,22 +31,12 @@ $ ./graphhopper.sh web north-america_us_new-york.pbf
 
 ## Start Development
 
-Open the project with NetBeans, IntelliJ or enable Maven in your IDE. 
-[Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
-installed when executing graphhopper.sh.
-
-### NetBeans, IntelliJ, Eclipse
-
- * For IntelliJ you need to import the code formatting settings (File|Import Settings). Load them from `core/files/intellij-settings.jar`. See the [special setup](../android/android-studio-setup.md) for Android if using Android studio.
-   * For IntelliJ15 there is also a formatting description, that should be imported using (Preferences|Editor|Code Style|Java|Manage|Import) from `core/files/IntelliJ15GraphHopperFormatting.xml`. 
- * For Eclipse please refer to [this separate setup documentation](./eclipse-setup.md).
- * Nothing special needs to be done for NetBeans.
+Open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
 
 ### Java, Embedded Usage
 
-Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
-be embedded](./routing.md) into your application and like a [custom weighting](./weighting.md) 
-can be implemented.
+Have a look into the [Java API documentation](../index.md#developer) for further details e.g. how [GraphHopper can
+be embedded](./routing.md) into your application and how you create a [custom weighting](./weighting.md).
 
 Look [here](http://graphhopper.com/#community) for the maven snippet to use GraphHopper in your
 application. To use an unreleased snapshot version of GraphHopper you need the following snippet in your pom.xml
@@ -65,33 +57,10 @@ as those versions are not in maven central:
     </repositories>
 ```
 
-### Java, Routing Server Usage
-
-The Web API documentation is [here](../web). 
-We provide Java client code [here](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java#L43)
-to query the routing server.
-
-The routing API (json,jsonp,gpx) is optimized regarding several aspects:
- * It tries to return a smallish data set (encoded polyline, gzip filter)
- * It enables cross-site scripting on the server- and client-site
- * The JavaScript client utilizes the jquery Deferred object to chain ajax requests and avoids browser UI blocking when resolving locations in parallel.
-
-#### Routing Service Deployment
+### JavaScript
 
-If you want to setup graphhopper on your own server, we have a separate information page [Deploy](./deploy.md).
-
-### JavaScript Usage
-
-For an example of how to use graphhopper in a web application see the 
-[web subfolder](https://github.com/graphhopper/graphhopper/tree/master/web)
-
-The routing server can be queried from [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js)
-as well. You can see this in action at [GraphHopper Maps](https://graphhopper.com/maps/).
-
-If you need **offline** routing in the browser like for smaller areas or hybrid routing solution
-then there is a highly experimental version of GraphHopper using TeaVM. 
-Have a look into this [blog post](http://karussell.wordpress.com/2014/05/04/graphhopper-in-the-browser-teavm-makes-offline-routing-via-openstreetmap-possible-in-javascript/) 
-for a demo and more information.
+When you started GraphHopper via `./graphhopper.sh web <your_osm.pbf>` a web server is already
+started and waiting for your commands. You can see this for the whole world at [GraphHopper Maps](https://graphhopper.com/maps/).
 
 If you want to change the JavaScript you have to setup the JavaScript environment - 
 i.e. install the node package manager (npm):
@@ -106,18 +75,18 @@ nvm use 4.2.2
 
 For windows download either [nvm](https://github.com/coreybutler/nvm-windows) or [node](https://nodejs.org/en/download/) directly.
 
-Then create the main.js
+Then generate the main.js
 ```bash
 # git clone https://github.com/graphhopper/graphhopper.git
 cd graphhopper/web
 # download required packages:
 npm install
 npm test
-# create main.js
+# overwrites main.js
 npm run bundle
 ```
 
-Finally start GraphHopper e.g. via `graphhopper.sh` script and with the browser open `localhost:8989`.
+Finally start GraphHopper e.g. via the `./graphhopper.sh` script and open the browser at `localhost:8989`.
 
 There are more npm commands e.g. to change the main.js on the fly or create an uglified main.js for production:
 ```bash
@@ -139,31 +108,27 @@ npm run lint
 # see the package.json where more scripts are defined
 ```
 
+### Experimental
+
+If you need **offline** routing in the browser like for smaller areas or hybrid routing solution
+then there is a highly experimental version of GraphHopper using TeaVM. 
+Have a look into this [blog post](http://karussell.wordpress.com/2014/05/04/graphhopper-in-the-browser-teavm-makes-offline-routing-via-openstreetmap-possible-in-javascript/) 
+for a demo and more information.
+
 ### Android Usage
  
-For details on Android-usage have a look into this [Android site](../android/index.md) or at the
-[Android example](https://github.com/graphhopper/graphhopper/tree/master/android)
+For details on Android-usage have a look into this [Android site](../android/index.md)
 
 ### Swing and Desktop Usage
 
-You can use graphhopper on the Desktop with the help of the latest mapsforge swing library too. No example code
-yet but with the Android example combined with the Desktop example of the mapsforge project it should not be
-that hard.
+You can use Graphhopper on the Desktop with the help of mapsforge too. No example code is given yet 
+but with the Android example combined with the Desktop example of the mapsforge project it should not be hard.
 
 For smallish graph (e.g. size of Berlin) use a RAMDataAccess driven GraphStorage (loads all into memory).
-For larger ones use the ContractionHierarchies preparation class and MMapDataAccess to avoid OutOfMemoryErrors. 
+For larger ones use the ContractionHierarchies preparation class and MMapDataAccess to avoid OutOfMemoryErrors if you have only few RAM. 
 
 Raspberry Pi usage is also possible. Have a look into this [blog post](https://karussell.wordpress.com/2014/01/09/road-routing-on-raspberry-pi-with-graphhopper/).
 
 ## Contribute
 
 See this [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md) on how to contribute.
-
-## Technical Details
-
-Have a look in the more [technical documentation](./technical.md) or the [low level API](./low-level-api.md).
-
-Further Links
----------------
- * [Spatial Key](http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/)
- * [Author@Twitter](https://twitter.com/timetabling)
diff --git a/docs/core/routing.md b/docs/core/routing.md
index b4e6e75330..a1f550ea58 100755
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -4,7 +4,7 @@ To do routing in your Java code you'll need just a few lines of code:
 
 ```java
 // create one GraphHopper instance
-GraphHopper hopper = new GraphHopper().forServer();
+GraphHopper hopper = new GraphHopperOSM().forServer();
 hopper.setOSMFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
@@ -54,13 +54,14 @@ List<GPXEntry> list = il.createGPXList();
 
 The default is to use the speed-up mode. If you need multiple profiles you specify a list of profiles (e.g. car,bike). 
 
-You can also completely disable the speed-up mode to make all vehicles using the flexibility mode via setting `prepare.chWeighting=no` also see issue #631 for a "per request" configuration.
+You can also completely disable the speed-up mode before import (see config.properties `prepare.ch.weightings=no`)
+or for a per request setting (`ch.disable=true`). 
 
-Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as algorithm:
+Then pick one vehicle and optionally an algorithm like 'bidirectional astar':
 
 ```java
-GraphHopper hopper = new GraphHopper().forServer();
-hopper.setCHEnable(false);
+GraphHopper hopper = new GraphHopperOSM().forServer();
+hopper.setCHEnabled(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
 hopper.setEncodingManager(new EncodingManager("car,bike"));
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 84e3b4f14d..3e168b6a37 100755
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -9,17 +9,18 @@ There are mainly three parts:
 ### 1. Data Import
 
 The default import is done via OSMReader which imports OpenStreetMap data. You can configure it via API 
-or use the graphhopper.sh script which utilizes the config.properties where you can specify if it should 
-read CAR, FOOT etc or all at once. You'll have to make sure that you allocate enough memory for your 
-specific graph (E.g. ~1GB for Germany) e.g. `export JAVA_OPTS="-Xmx1g"`. The import process is fast e.g. 
-complete germany takes about 10 minutes on my oldish laptop. Additionally it will take time if you choose 
-prepare.chWeighting=fastest in the config.properties which will dramatically improve query time
+or use the `graphhopper.sh` script which utilizes the config.properties where you can specify if it should 
+read `car`, `foot` or all vehicles at once. You'll have to make sure that you allocate enough memory for your 
+specific graph (E.g. ~2GB for Germany) e.g. `export JAVA_OPTS="-Xmx2g"`. The import process is fast e.g. 
+complete Germany takes roughly 10 minutes. Additionally it will take time if you choose 
+`prepare.ch.weightings=fastest` in the config.properties which will dramatically improve query time
 but requires more RAM on import.
 
 ### 2. The Graph
 
 To process algorithms you need a _Graph_. At the moment there is one main implementation GraphHopperStorage 
-which can be used: 
+which can be used:
+
   * in-memory with a safe/flush option (RAMDataAccess) and 
   * a memory mapped (MMapDataAccess).
 
@@ -37,22 +38,24 @@ Some explanations:
  * One 'edge row' consists of two edgeIDs: nextA and nextB, then two nodeIDs nodeA and nodeB, and finally some properties like the distance and the flags.
  * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
  * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
+ * If CH is enabled the storage adds information for shortcuts, see [this issue](https://github.com/graphhopper/graphhopper/pull/447) for more details.
 
 For some algorithms there are special implementations of the Graph (CHGraph). You enable this in GraphHopperStorage
 to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. 
 For this the graph needs also some preprocessing (which can take several minutes for bigger areas) 
-which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. 
+which is done in the OSMReader when configured or via API in PrepareContractionHierarchies. 
 In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from 
 createAlgo() in the preparation class.
 
-Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+Also there is a version in every vehicle and every data structure which is changed if the 
+data structure of GraphHopper gets incompatible to the previous versions.
 
 ### 3. The Algorithms
 
 In the routing package you'll find some shortest path algorithms like Dijkstra or A* etc. For those 
 algorithms you need a _Graph_.
 
-An algorithm needs a kind of path extraction: from the shortest-path-tree one needs to determine the route 
+An algorithm needs the path extraction: from the shortest-path-tree one needs to determine the route 
 (list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
 can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
 For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
@@ -72,8 +75,7 @@ or similar. See issue #116 for more information.
 ## 4.1 LocationIndex
 
 In real world we have addresses and/or coordinates for the start and end point. 
-To get the coordinate from an address you will need a geocoding solution not part of GraphHopper,
-e.g. have a look into our [Routing Web API](http://graphhopper.com/#enterprise) for more information about this topic.
+To get the coordinate from an address you will need a geocoding solution not part of GraphHopper.
 
 To get the closest node or edge id from a coordinate we provide you with an efficient lookup concept:
 the LocationIndex. There are multiple implementations
@@ -83,6 +85,8 @@ See [here](./location-index.md) for more information. See #17 and #221.
 
 ## 4.2 QueryGraph
 
-In order to route not only from junctions (which are nodes) we introduced the _QueryGraph_ in issue #27,
+In order to route not only from junctions (which are nodes) we introduced with the _QueryGraph_ in issue #27,
 which creates virtual nodes and edges at the query coordinates. It provides a lightweight wrapper around
 the _Graph_ and is created per query so that queries do not influence each other.
+
+It can be also introduced for all kinds of dynamically changed nodes and is tested for a few thousand locations.
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
index adf01c47dd..e82c171e67 100755
--- a/docs/core/weighting.md
+++ b/docs/core/weighting.md
@@ -34,7 +34,7 @@ class MyGraphHopper extends GraphHopper {
 }
 ```
 
-For forbiddenEdges you need to determine the edges from some GPS coordinates. 
+For `forbiddenEdges` you need to determine the edges from some GPS coordinates. 
 Have a look into the [location index docs](./location-index.md). 
 
 If your blocking edges change per-request you need to disable the speed mode e.g. via `prepare.ch.weightings=no`
diff --git a/docs/core/windows-setup.md b/docs/core/windows-setup.md
index 53ccd01ee7..430c160c45 100755
--- a/docs/core/windows-setup.md
+++ b/docs/core/windows-setup.md
@@ -13,15 +13,15 @@ $ git clone https://github.com/graphhopper/graphhopper.git
 $ cd graphhopper
 
 # and execute
-$ ./graphhopper.sh web europe_germany_berlin.osm
+$ ./graphhopper.sh web europe_germany_berlin.pbf
 ```
 
 Now graphhopper web should start. After this open [http://localhost:8989/](http://localhost:8989/) in your browser.
 
 ### Troubleshooting
- * Make sure you have the JDK installed (6,7 or 8) and not only the JRE
+ * Make sure you have the latest JDK installed and not only the JRE
  * For me JAVA_HOME was not correct so I had to overwrite it:
    ```bash
-   $ export JAVA_HOME=/cygdrive/c/Programme/Java/jdk1.7.0_17
-   $ ./graphhopper.sh web europe_germany_berlin.osm
+   $ export JAVA_HOME=/cygdrive/c/Programme/Java/jdk1.8.0_77
+   $ ./graphhopper.sh web europe_germany_berlin.pbf
    ```
diff --git a/docs/index.md b/docs/index.md
index 7767dc50e3..3a5aab308e 100755
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,42 +1,79 @@
 # GraphHopper Documentation
 
-## Users
+## Getting Started
+
+Try out our live demo called [GraphHopper Maps](https://graphhopper.com/maps)
+
+ [![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
+
+[The Readme](../README.md#features) lists all features or [this list of slides](https://graphhopper.com/public/slides/).
+
+See [more users of GraphHopper](https://graphhopper.com/#usecases) or [Android apps](./android/index.md#apps) and let us know your application!
+
+## Contact
+
+For all questions regarding the GraphHopper routing engine please use [our forum](https://discuss.graphhopper.com). 
+
+For bugs see our contribute section below.
+
+## User
+
+[The user guide](./web/quickstart.md) is the HowTo for users. Other links:
 
- * [Quickstart](./web/quickstart.md): HowTo for users.
- * [Read Overview](https://graphhopper.com/#overview): Summary of the product GraphHopper. 
  * [Add GraphHopper Maps to your Browser](./web/open-search.md): Instructions how to setup GraphHopper as the standard search enginge in your browser.
  * [Embed GraphHopper on your website](https://github.com/karussell/graphhopper-embed-form): A small code snippet on how to integrate GraphHopper Maps in your web site like a contact form
 
-## Translators
+## Web
 
-* [Translations](./core/translations.md): Tutorial how to help with the GraphHopper translations or how to setup a new language.
+The web module provides a web API for other programming languages as well as starts a simple user interface called GraphHopper Maps
 
+ * [Routing API](./web/api-doc.md): Documentation of the Web API to communicate with any GraphHopper server via http.
+ * [Deployment Guide](./core/deploy.md): Details about deploying GraphHopper
+ * [Postgis query script](../core/files/postgis)
+ * There are official API clients in [Java](https://github.com/graphhopper/directions-api-java-client/) and [JavaScript](https://github.com/graphhopper/directions-api-js-client).
 
-## Developers
+### Configuration
 
- * [Quickstart](./core/quickstart-from-source.md): Introduction for developers. Explains git checkout, IDE setup and commands for setting up a GraphHopper server.
- * [Android](./android/index.md): Instructions how to setup the demo project for GraphHopper on Android as base for further development (i.e. with Android Studio).
- * [Windows](./core/windows-setup.md): Documentation about how to get an GraphHopper instance running on windows (cygwin).
- * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md): Detailed instructions how to setup GraphHopper in eclipse with maven.
- * [iOS](https://github.com/graphhopper/graphhopper-ios/): Link to the GraphHopper-iOS github repository.
+You can configure several aspects either programmatically or just via the [config.properties](../config-example.properties).
 
-### Core
+The elevation configuration is separately documented [here](./core/elevation.md).
 
- * [Simple routing](./core/routing.md): Tutorial how to integrate GraphHopper in your Java application (or pick any JVM language)
- * [Create custom weighting](./core/weighting.md): Documentation about how to create a custom weighting class to influence the track calculation.
- * [Elevation](./core/elevation.md): Documentation how to enable the usage of elevation for the output of the track.
- * [Slides](https://graphhopper.com/public/slides/): Small presentations about how GraphHopper is working.
+## Developer
 
-### Web
+[The quickstart](./core/quickstart-from-source.md) is an introduction for developers. Explains git checkout, IDE setup and commands for setting up a GraphHopper server.
 
- * [Routing API](./web/api-doc.md): Documentation of the Web API to communicate with any GraphHopper server via http.
- * [Deployment Guide](./core/deploy.md): Details about deploying GraphHopper.
+Find all changes in previous and current versions in the [changelogs](../core/files/changelogs.txt).
+
+### Contribute
+
+Read [here](../.github/CONTRIBUTING.md) on how to contribute as a developer and translator.
 
-### Advanced Topics
+### Technical
+
+Various topics are explained in more detail separately:
 
  * [Technical overview](./core/technical.md): Technical details about how GraphHopper its calculations are working.
- * [Contraction Hierarchies](./core/ch.md): Details about speeding up the track calculations by [Contraction Hierarchies](http://en.wikipedia.org/wiki/Contraction_hierarchies).
+ * [Simple routing](./core/routing.md): Tutorial how to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md): Documentation about how to create a custom weighting class to influence the track calculation.
+ * [LocationIndex](./core/location-index.md): Documentation about how to get the location index for getting i.e. the nearest edge. 
  * [Low level API](./core/low-level-api.md): Instructions how to use GraphHopper as a Java library.
+ * [Contraction Hierarchies](./core/ch.md): Details about speeding up the track calculations by [Contraction Hierarchies](http://en.wikipedia.org/wiki/Contraction_hierarchies).
  * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
- * [LocationIndex](./core/location-index.md): Documentation about how to get the location index for getting i.e. the nearest edge. 
- * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt): Latest changes.
+
+### Android
+
+ * [Android](./android/index.md): Instructions how to setup the demo project for GraphHopper on Android
+ * [Android Studio Setup](./android/android-studio-setup.md)
+
+### iOS
+
+Instructions on how to setup the GraphHopper-iOS clone for iOS development are [here](https://github.com/graphhopper/graphhopper-ios/)
+including a sample application.
+
+### Windows
+
+Documentation about how to get an GraphHopper instance running on windows via cygwin is available [here](./core/windows-setup.md).
+
+### Eclipse
+
+[Set up GraphHopper in Eclipse](./core/eclipse-setup.md) with maven and [tomcat](./core/eclipse-tomcat-setup.md).
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index 45609fdf1e..ef10a8eb82 100755
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -5,10 +5,10 @@ The following steps are simpler and only need the JRE, a jar file and an OSM fil
 
  1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.8-SNAPSHOT/) (~9MB)
  2. Unzip it and copy an OSM file into the created directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
- 3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf`
+ 3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties datareader.file=berlin-latest.osm.pbf`
  4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
 
-To see how GraphHopper is configured for production usage, see the separate site [Deploy](./../core/deploy.md).
+To see how GraphHopper is configured for production usage, see the [deployment guide](./../core/deploy.md).
 
 ## Troubleshooting
 
@@ -16,4 +16,4 @@ To see how GraphHopper is configured for production usage, see the separate site
  * Regarding step 2:
     * The folder where you execute the java command should contain the following files: berlin-latest.osm.pbf, config-example.properties and `graphhopper-web-[version].jar`
     * The first time you execute this it'll take ~30 seconds (for Berlin), further starts will only load the graph and should be nearly instantaneous. You should see log statements but no exceptions and the last entry should be something like: Started server at HTTP 8989
- * Join the [mailing list](http://graphhopper.com/#developers) and do not hesitate to ask questions!
+ * Or [contact us](../index.md#contact)
diff --git a/graphhopper.sh b/graphhopper.sh
index ef756718e8..7d50b8fae0 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -1,4 +1,6 @@
 #!/bin/bash
+(set -o igncr) 2>/dev/null && set -o igncr; # this comment is required for handling Windows cr/lf 
+# See StackOverflow answer http://stackoverflow.com/a/14607651
 
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
diff --git a/pom.xml b/pom.xml
index 6df1e8b3e6..6277cbdf33 100755
--- a/pom.xml
+++ b/pom.xml
@@ -6,13 +6,11 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.8-SNAPSHOT</version>
-    <packaging>pom</packaging> 
-    <url>https://graphhopper.com</url> 
+    <version>0.9-SNAPSHOT</version>
+    <packaging>pom</packaging>
+    <url>https://graphhopper.com</url>
     <inceptionYear>2012</inceptionYear>
-    <description>
-        Super pom of GraphHopper core, a fast Java road routing engine.
-    </description>
+    <description>Super pom of GraphHopper, the fast and flexible routing engine</description>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -20,42 +18,37 @@
         <slf4j.version>1.7.21</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         <json.org.version>20160212</json.org.version>
-        
-        <!-- netbeans formatting rules -->
-        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
+
+        <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
         <org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>4</org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>
         <org-netbeans-modules-editor-indent.CodeStyle.project.tab-size>8</org-netbeans-modules-editor-indent.CodeStyle.project.tab-size>
-        <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
-        <org-netbeans-modules-editor-indent.CodeStyle.project.expand-tabs>true</org-netbeans-modules-editor-indent.CodeStyle.project.expand-tabs>
         <org-netbeans-modules-editor-indent.CodeStyle.project.text-limit-width>100</org-netbeans-modules-editor-indent.CodeStyle.project.text-limit-width>
-        <org-netbeans-modules-editor-indent.CodeStyle.project.text-line-wrap>none</org-netbeans-modules-editor-indent.CodeStyle.project.text-line-wrap>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.blankLinesAfterClassHeader>0</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.blankLinesAfterClassHeader>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodDeclParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodDeclParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>
+        <org-netbeans-modules-editor-indent.CodeStyle.project.expand-tabs>true</org-netbeans-modules-editor-indent.CodeStyle.project.expand-tabs>
+        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.redundantIfBraces>LEAVE_ALONE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.redundantIfBraces>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.generateParagraphTagOnBlankLines>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.generateParagraphTagOnBlankLines>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>2</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>*</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>        
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignJavadocExceptionDescriptions>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignJavadocExceptionDescriptions>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignJavadocParameterDescriptions>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignJavadocParameterDescriptions>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.blankLinesAfterClassHeader>0</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.blankLinesAfterClassHeader>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.wrapCommentText>false</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.wrapCommentText>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.wrapOneLineComment>false</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.wrapOneLineComment>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>        
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineFor>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineFor>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineTryResources>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineTryResources>
     </properties>
-    
+
     <scm>
         <connection>scm:git:git@github.com:graphhopper/graphhopper.git</connection>
         <developerConnection>scm:git:git@github.com:graphhopper/graphhopper.git</developerConnection>
         <url>git@github.com:graphhopper/graphhopper.git</url>
     </scm>
-    
+
     <licenses>
         <license>
             <name>Apache License, Version 2.0</name>
             <url>http://www.apache.org/licenses/LICENSE-2.0</url>
         </license>
     </licenses>
-    
+
     <developers>
         <developer>
             <id>karussell</id>
@@ -63,7 +56,7 @@
             <email>my.name@graphhopper.com</email>
         </developer>
     </developers>
-    
+
     <mailingLists>
         <mailingList>
             <name>GraphHopper</name>
@@ -79,24 +72,25 @@
         <module>tools-lgpl</module>
         <module>core</module>
         <module>reader-osm</module>
+        <module>reader-overlay-data</module>
         <module>tools</module>
         <module>web</module>
     </modules>
-        
-    <build>        
+    <prerequisites>
+        <maven>3.2</maven>
+    </prerequisites>
+    <build>
         <plugins>
-        
-            <!-- to avoid problems with jvm 1.5 and @Override -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>3.5.1</version>
                 <configuration>
                     <!--
-                    <compilerArgument>-Xlint:unchecked</compilerArgument>                    
+                    <compilerArgument>-Xlint:unchecked</compilerArgument>
                     <compilerArgument>-Xlint:deprecation</compilerArgument>
                     -->
-                    
+
                     <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
@@ -104,9 +98,9 @@
                     <target>1.7</target>
                 </configuration>
             </plugin>
-            
+
             <!-- to run single tests -->
-            <plugin>                
+            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <version>2.19.1</version>
@@ -114,11 +108,11 @@
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
             </plugin>
-                        
+
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.19</version>
+                <version>2.19.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -128,21 +122,21 @@
                     </execution>
                 </executions>
             </plugin>
-                        
+
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.6</version>                    
+                <version>2.6</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>2.6</version>
+                <version>3.0.2</version>
             </plugin>
             <plugin>
                 <artifactId>maven-war-plugin</artifactId>
-                <version>2.6</version>                
-            </plugin>            
+                <version>3.0.0</version>
+            </plugin>
             <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -153,26 +147,26 @@
                 </configuration>
             </plugin>
             -->
-            
+
             <!-- create html output for findbugs -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-site-plugin</artifactId>
-                <version>3.5</version>
+                <version>3.5.1</version>
                 <configuration>
                     <reportPlugins>
                         <plugin>
                             <groupId>org.codehaus.mojo</groupId>
-                            <artifactId>findbugs-maven-plugin</artifactId>                            
+                            <artifactId>findbugs-maven-plugin</artifactId>
                         </plugin>
                     </reportPlugins>
                 </configuration>
             </plugin>
-            
+
             <plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>findbugs-maven-plugin</artifactId>
-                <version>3.0.3</version>                
+                <version>3.0.4</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -185,24 +179,24 @@
                 -->
             </plugin>
         </plugins>
-    </build>    
-    
+    </build>
+
     <dependencies>
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
             <version>4.12</version>
             <scope>test</scope>
-        </dependency>        
+        </dependency>
     </dependencies>
-    
+
     <distributionManagement>
         <snapshotRepository>
             <id>ossrh</id>
             <url>https://oss.sonatype.org/content/repositories/snapshots</url>
         </snapshotRepository>
-    </distributionManagement> 
-    
+    </distributionManagement>
+
     <!-- mvn clean deploy -P release -->
     <profiles>
         <profile>
@@ -237,11 +231,11 @@
                             <autoReleaseAfterClose>true</autoReleaseAfterClose>
                         </configuration>
                     </plugin>
-            
+
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
-                        <version>2.10.3</version>
+                        <version>2.10.4</version>
                         <executions>
                             <execution>
                                 <id>attach-javadocs</id>
@@ -254,7 +248,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-source-plugin</artifactId>
-                        <version>3.0.0</version>
+                        <version>3.0.1</version>
                         <executions>
                             <execution>
                                 <id>attach-sources</id>
@@ -267,7 +261,7 @@
                 </plugins>
             </build>
         </profile>
-        
+
         <profile>
             <id>include-android</id>
             <activation>
@@ -278,5 +272,5 @@
             </modules>
         </profile>
     </profiles>
-    
+
 </project>
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index 2ce3a4cf97..1fa7c781e6 100755
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.9-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for OpenStreetMap Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <version>0.9-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -62,31 +62,7 @@
             <version>${project.parent.version}</version>
             <type>test-jar</type>
             <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.seleniumhq.selenium</groupId>
-            <artifactId>selenium-java</artifactId>
-            <scope>test</scope>
-            <version>2.44.0</version>
-        </dependency>
-        <dependency>
-            <groupId>com.opera</groupId>
-            <artifactId>operadriver</artifactId>
-            <scope>test</scope>
-            <version>1.5</version>
-            <exclusions>
-                <exclusion>
-                    <groupId>org.seleniumhq.selenium</groupId>
-                    <artifactId>selenium-remote-driver</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <scope>test</scope>
-            <version>4.11</version>
-        </dependency>
+        </dependency>        
     </dependencies>
     <build>
         <plugins>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
index 6f5491ff06..0c8e47ff70 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
@@ -26,26 +26,22 @@
  *
  * @author Peter Karich
  */
-public class GraphHopperOSM extends GraphHopper
-{
+public class GraphHopperOSM extends GraphHopper {
     @Override
-    protected DataReader createReader( GraphHopperStorage ghStorage )
-    {
+    protected DataReader createReader(GraphHopperStorage ghStorage) {
         return initDataReader(new OSMReader(ghStorage));
     }
 
+    public String getOSMFile() {
+        return getDataReaderFile();
+    }
+
     /**
      * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
      * (.pbf).
      */
-    public GraphHopperOSM setOSMFile( String osmFileStr )
-    {
+    public GraphHopperOSM setOSMFile(String osmFileStr) {
         super.setDataReaderFile(osmFileStr);
         return this;
     }
-
-    public String getOSMFile()
-    {
-        return getDataReaderFile();
-    }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMFileHeader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMFileHeader.java
index 23eeed03b5..1445416080 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMFileHeader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMFileHeader.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader.osm;
 
 import com.graphhopper.reader.ReaderElement;
+
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
@@ -25,37 +26,32 @@
 /**
  * Represents an OSM file header
  * <p>
+ *
  * @author ratrun
  */
-public class OSMFileHeader extends ReaderElement
-{
+public class OSMFileHeader extends ReaderElement {
+    public OSMFileHeader() {
+        super(0, FILEHEADER);
+    }
+
     /**
      * Constructor for XML Parser
      */
-    public static OSMFileHeader create( long id, XMLStreamReader parser ) throws XMLStreamException
-    {
+    public static OSMFileHeader create(long id, XMLStreamReader parser) throws XMLStreamException {
         OSMFileHeader header = new OSMFileHeader();
         parser.nextTag();
         return header;
     }
 
-    public OSMFileHeader()
-    {
-        super(0, FILEHEADER);
-    }
-
-    protected void readFileHeader( XMLStreamReader parser ) throws XMLStreamException
-    {
+    protected void readFileHeader(XMLStreamReader parser) throws XMLStreamException {
         int event = parser.getEventType();
-        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("osm"))
-        {
+        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("osm")) {
             event = parser.nextTag();
         }
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "OSM File header:" + super.toString();
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMInputFile.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMInputFile.java
index c00483155b..b62830f9c4 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMInputFile.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMInputFile.java
@@ -17,9 +17,9 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.*;
-import com.graphhopper.reader.osm.pbf.Sink;
+import com.graphhopper.reader.ReaderElement;
 import com.graphhopper.reader.osm.pbf.PbfReader;
+import com.graphhopper.reader.osm.pbf.Sink;
 
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamConstants;
@@ -36,34 +36,31 @@
 /**
  * A readable OSM file.
  * <p>
+ *
  * @author Nop
  */
-public class OSMInputFile implements Sink, Closeable
-{
-    private boolean eof;
+public class OSMInputFile implements Sink, Closeable {
     private final InputStream bis;
+    private final BlockingQueue<ReaderElement> itemQueue;
+    Thread pbfReaderThread;
+    private boolean eof;
     // for xml parsing
     private XMLStreamReader parser;
     // for pbf parsing
     private boolean binary = false;
-    private final BlockingQueue<ReaderElement> itemQueue;
     private boolean hasIncomingData;
     private int workerThreads = -1;
     private OSMFileHeader fileheader;
 
-    public OSMInputFile( File file ) throws IOException
-    {
+    public OSMInputFile(File file) throws IOException {
         bis = decode(file);
         itemQueue = new LinkedBlockingQueue<ReaderElement>(50000);
     }
 
-    public OSMInputFile open() throws XMLStreamException
-    {
-        if (binary)
-        {
+    public OSMInputFile open() throws XMLStreamException {
+        if (binary) {
             openPBFReader(bis);
-        } else
-        {
+        } else {
             openXMLStream(bis);
         }
         return this;
@@ -72,23 +69,19 @@ public OSMInputFile open() throws XMLStreamException
     /**
      * Currently on for pbf format. Default is number of cores.
      */
-    public OSMInputFile setWorkerThreads( int num )
-    {
+    public OSMInputFile setWorkerThreads(int num) {
         workerThreads = num;
         return this;
     }
 
     @SuppressWarnings("unchecked")
-    private InputStream decode( File file ) throws IOException
-    {
+    private InputStream decode(File file) throws IOException {
         final String name = file.getName();
 
         InputStream ips = null;
-        try
-        {
+        try {
             ips = new BufferedInputStream(new FileInputStream(file), 50000);
-        } catch (FileNotFoundException e)
-        {
+        } catch (FileNotFoundException e) {
             throw new RuntimeException(e);
         }
         ips.mark(10);
@@ -104,56 +97,46 @@ private InputStream decode( File file ) throws IOException
          return new CBZip2InputStream(ips);
          }
          */
-        if (header[0] == 31 && header[1] == -117)
-        {
+        if (header[0] == 31 && header[1] == -117) {
             ips.reset();
             return new GZIPInputStream(ips, 50000);
         } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
                 && header[4] == 10 && header[5] == 9
-                && (header[3] == 13 || header[3] == 14))
-        {
+                && (header[3] == 13 || header[3] == 14)) {
             ips.reset();
             binary = true;
             return ips;
-        } else if (header[0] == 'P' && header[1] == 'K')
-        {
+        } else if (header[0] == 'P' && header[1] == 'K') {
             ips.reset();
             ZipInputStream zip = new ZipInputStream(ips);
             zip.getNextEntry();
 
             return zip;
-        } else if (name.endsWith(".osm") || name.endsWith(".xml"))
-        {
+        } else if (name.endsWith(".osm") || name.endsWith(".xml")) {
             ips.reset();
             return ips;
-        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2"))
-        {
+        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
             String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
-            try
-            {
+            try {
                 Class clazz = Class.forName(clName);
                 ips.reset();
                 Constructor<InputStream> ctor = clazz.getConstructor(InputStream.class, boolean.class);
                 return ctor.newInstance(ips, true);
-            } catch (Exception e)
-            {
+            } catch (Exception e) {
                 throw new IllegalArgumentException("Cannot instantiate " + clName, e);
             }
-        } else
-        {
+        } else {
             throw new IllegalArgumentException("Input file is not of valid type " + file.getPath());
         }
     }
 
-    private void openXMLStream( InputStream in )
-            throws XMLStreamException
-    {
+    private void openXMLStream(InputStream in)
+            throws XMLStreamException {
         XMLInputFactory factory = XMLInputFactory.newInstance();
         parser = factory.createXMLStreamReader(in, "UTF-8");
 
         int event = parser.next();
-        if (event != XMLStreamConstants.START_ELEMENT || !parser.getLocalName().equalsIgnoreCase("osm"))
-        {
+        if (event != XMLStreamConstants.START_ELEMENT || !parser.getLocalName().equalsIgnoreCase("osm")) {
             throw new IllegalArgumentException("File is not a valid OSM stream");
         }
         // See https://wiki.openstreetmap.org/wiki/PBF_Format#Definition_of_the_OSMHeader_fileblock
@@ -162,22 +145,18 @@ private void openXMLStream( InputStream in )
         if (timestamp == null)
             timestamp = parser.getAttributeValue(null, "timestamp");
 
-        if (timestamp != null)
-        {
-            try
-            {
+        if (timestamp != null) {
+            try {
                 fileheader = new OSMFileHeader();
                 fileheader.setTag("timestamp", timestamp);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
             }
         }
 
         eof = false;
     }
 
-    public ReaderElement getNext() throws XMLStreamException
-    {
+    public ReaderElement getNext() throws XMLStreamException {
         if (eof)
             throw new IllegalStateException("EOF reached");
 
@@ -194,39 +173,31 @@ public ReaderElement getNext() throws XMLStreamException
         return null;
     }
 
-    private ReaderElement getNextXML() throws XMLStreamException
-    {
+    private ReaderElement getNextXML() throws XMLStreamException {
 
         int event = parser.next();
-        if (fileheader != null)
-        {
+        if (fileheader != null) {
             ReaderElement copyfileheader = fileheader;
             fileheader = null;
             return copyfileheader;
         }
 
-        while (event != XMLStreamConstants.END_DOCUMENT)
-        {
-            if (event == XMLStreamConstants.START_ELEMENT)
-            {
+        while (event != XMLStreamConstants.END_DOCUMENT) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
                 String idStr = parser.getAttributeValue(null, "id");
-                if (idStr != null)
-                {
+                if (idStr != null) {
                     String name = parser.getLocalName();
                     long id = 0;
-                    switch (name.charAt(0))
-                    {
+                    switch (name.charAt(0)) {
                         case 'n':
                             // note vs. node
-                            if ("node".equals(name))
-                            {
+                            if ("node".equals(name)) {
                                 id = Long.parseLong(idStr);
                                 return OSMXMLHelper.createNode(id, parser);
                             }
                             break;
 
-                        case 'w':
-                        {
+                        case 'w': {
                             id = Long.parseLong(idStr);
                             return OSMXMLHelper.createWay(id, parser);
                         }
@@ -242,23 +213,18 @@ private ReaderElement getNextXML() throws XMLStreamException
         return null;
     }
 
-    public boolean isEOF()
-    {
+    public boolean isEOF() {
         return eof;
     }
 
     @Override
-    public void close() throws IOException
-    {
-        try
-        {
+    public void close() throws IOException {
+        try {
             if (!binary)
                 parser.close();
-        } catch (XMLStreamException ex)
-        {
+        } catch (XMLStreamException ex) {
             throw new IOException(ex);
-        } finally
-        {
+        } finally {
             eof = true;
             bis.close();
             // if exception happend on OSMInputFile-thread we need to shutdown the pbf handling
@@ -267,10 +233,7 @@ public void close() throws IOException
         }
     }
 
-    Thread pbfReaderThread;
-
-    private void openPBFReader( InputStream stream )
-    {
+    private void openPBFReader(InputStream stream) {
         hasIncomingData = true;
         if (workerThreads <= 0)
             workerThreads = 2;
@@ -281,14 +244,11 @@ private void openPBFReader( InputStream stream )
     }
 
     @Override
-    public void process( ReaderElement item )
-    {
-        try
-        {
+    public void process(ReaderElement item) {
+        try {
             // blocks if full
             itemQueue.put(item);
-        } catch (InterruptedException ex)
-        {
+        } catch (InterruptedException ex) {
             throw new RuntimeException(ex);
         }
 
@@ -297,29 +257,23 @@ public void process( ReaderElement item )
     }
 
     @Override
-    public void complete()
-    {
+    public void complete() {
         hasIncomingData = false;
     }
 
-    private ReaderElement getNextPBF()
-    {
+    private ReaderElement getNextPBF() {
         ReaderElement next = null;
-        while (next == null)
-        {
-            if (!hasIncomingData && itemQueue.isEmpty())
-            {
+        while (next == null) {
+            if (!hasIncomingData && itemQueue.isEmpty()) {
                 // we are done, stop polling
                 eof = true;
                 break;
             }
 
-            try
-            {
+            try {
                 // we cannot use "itemQueue.take()" as it blocks and hasIncomingData can change
                 next = itemQueue.poll(10, TimeUnit.MILLISECONDS);
-            } catch (InterruptedException ex)
-            {
+            } catch (InterruptedException ex) {
                 eof = true;
                 break;
             }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 3c663ab42d..3f0e9d2a08 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -17,44 +17,38 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.ReaderRelation;
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderElement;
-import static com.graphhopper.util.Helper.nf;
-
+import com.graphhopper.coll.GHLongIntBTree;
+import com.graphhopper.coll.LongIntMap;
+import com.graphhopper.reader.*;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
 import gnu.trove.map.TLongLongMap;
+import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TIntLongHashMap;
 import gnu.trove.map.hash.TLongLongHashMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
 import gnu.trove.set.TLongSet;
 import gnu.trove.set.hash.TLongHashSet;
-
-import java.io.File;
-import java.io.IOException;
-
-import javax.xml.stream.XMLStreamException;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.coll.GHLongIntBTree;
-import com.graphhopper.coll.LongIntMap;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
-import com.graphhopper.reader.PillarInfo;
-import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
-import gnu.trove.map.TLongObjectMap;
-import gnu.trove.map.hash.TLongObjectHashMap;
-
+import javax.xml.stream.XMLStreamException;
+import java.io.File;
+import java.io.IOException;
 import java.util.*;
 
+import static com.graphhopper.util.Helper.nf;
+
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
  * parsing processes in order to reduce memory usage compared to a single parsing processing.
@@ -76,24 +70,32 @@
  * When creating an edge the pillar node information from the intermediate datastructure will be
  * stored in the way geometry of that edge.
  * <p>
+ *
  * @author Peter Karich
  */
-public class OSMReader implements DataReader
-{
+public class OSMReader implements DataReader {
     protected static final int EMPTY = -1;
     // pillar node is >= 3
     protected static final int PILLAR_NODE = 1;
     // tower node is <= -3
     protected static final int TOWER_NODE = -2;
     private static final Logger LOGGER = LoggerFactory.getLogger(OSMReader.class);
-    private long locations;
-    private long skippedLocations;
     private final GraphStorage ghStorage;
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    private final TLongList barrierNodeIds = new TLongArrayList();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
+    private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private final boolean exitOnlyPillarNodeException = true;
+    private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    protected long zeroCounter = 0;
+    protected PillarInfo pillarInfo;
+    private long locations;
+    private long skippedLocations;
     private EncodingManager encodingManager = null;
     private int workerThreads = -1;
-    protected long zeroCounter = 0;
     // Using the correct Map<Long, Integer> is hard. We need a memory efficient and fast solution for big data sets!
     //
     // very slow: new SparseLongLongArray
@@ -109,25 +111,16 @@
     // stores osm way ids used by relations to identify which edge ids needs to be mapped later
     private TLongHashSet osmWayIdSet = new TLongHashSet();
     private TIntLongMap edgeIdToOsmWayIdMap;
-    private final TLongList barrierNodeIds = new TLongArrayList();
-    protected PillarInfo pillarInfo;
-    private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
-    private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
     private boolean doSimplify = true;
     private int nextTowerId = 0;
     private int nextPillarId = 0;
     // negative but increasing to avoid clash with custom created OSM files
     private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final boolean exitOnlyPillarNodeException = true;
     private File osmFile;
     private Date osmDataDate;
-    private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
-    private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
-    public OSMReader( GraphHopperStorage ghStorage )
-    {
+    public OSMReader(GraphHopperStorage ghStorage) {
         this.ghStorage = ghStorage;
         this.graph = ghStorage;
         this.nodeAccess = graph.getNodeAccess();
@@ -139,8 +132,7 @@ public OSMReader( GraphHopperStorage ghStorage )
     }
 
     @Override
-    public void readGraph() throws IOException
-    {
+    public void readGraph() throws IOException {
         if (encodingManager == null)
             throw new IllegalStateException("Encoding manager was not set.");
 
@@ -158,47 +150,40 @@ public void readGraph() throws IOException
         writeOsm2Graph(osmFile);
         sw2.stop();
 
-        LOGGER.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds() + " total:"
-                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
+        LOGGER.info("time pass1:" + (int) sw1.getSeconds() + "s, "
+                + "pass2:" + (int) sw2.getSeconds() + "s, "
+                + "total:" + (int) (sw1.getSeconds() + sw2.getSeconds()) + "s");
     }
 
     /**
      * Preprocessing of OSM file to select nodes which are used for highways. This allows a more
      * compact graph data structure.
      */
-    void preProcess( File osmFile )
-    {
+    void preProcess(File osmFile) {
         OSMInputFile in = null;
-        try
-        {
+        try {
             in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
 
             long tmpWayCounter = 1;
             long tmpRelationCounter = 1;
             ReaderElement item;
-            while ((item = in.getNext()) != null)
-            {
-                if (item.isType(ReaderElement.WAY))
-                {
+            while ((item = in.getNext()) != null) {
+                if (item.isType(ReaderElement.WAY)) {
                     final ReaderWay way = (ReaderWay) item;
                     boolean valid = filterWay(way);
-                    if (valid)
-                    {
+                    if (valid) {
                         TLongList wayNodes = way.getNodes();
                         int s = wayNodes.size();
-                        for (int index = 0; index < s; index++)
-                        {
+                        for (int index = 0; index < s; index++) {
                             prepareHighwayNode(wayNodes.get(index));
                         }
 
-                        if (++tmpWayCounter % 5000000 == 0)
-                        {
+                        if (++tmpWayCounter % 5000000 == 0) {
                             LOGGER.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
                                     + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
                         }
                     }
-                } else if (item.isType(ReaderElement.RELATION))
-                {
+                } else if (item.isType(ReaderElement.RELATION)) {
                     final ReaderRelation relation = (ReaderRelation) item;
                     if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
                         prepareWaysWithRelationInfo(relation);
@@ -206,32 +191,26 @@ void preProcess( File osmFile )
                     if (relation.hasTag("type", "restriction"))
                         prepareRestrictionRelation(relation);
 
-                    if (++tmpRelationCounter % 50000 == 0)
-                    {
+                    if (++tmpRelationCounter % 50000 == 0) {
                         LOGGER.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
                                 + " " + Helper.getMemInfo());
                     }
-                } else if (item.isType(ReaderElement.FILEHEADER))
-                {
+                } else if (item.isType(ReaderElement.FILEHEADER)) {
                     final OSMFileHeader fileHeader = (OSMFileHeader) item;
                     osmDataDate = Helper.createFormatter().parse(fileHeader.getTag("timestamp"));
                 }
 
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Problem while parsing file", ex);
-        } finally
-        {
+        } finally {
             Helper.close(in);
         }
     }
 
-    private void prepareRestrictionRelation( ReaderRelation relation )
-    {
+    private void prepareRestrictionRelation(ReaderRelation relation) {
         OSMTurnRelation turnRelation = createTurnRelation(relation);
-        if (turnRelation != null)
-        {
+        if (turnRelation != null) {
             getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
             getOsmWayIdSet().add(turnRelation.getOsmIdTo());
         }
@@ -240,13 +219,11 @@ private void prepareRestrictionRelation( ReaderRelation relation )
     /**
      * @return all required osmWayIds to process e.g. relations.
      */
-    private TLongSet getOsmWayIdSet()
-    {
+    private TLongSet getOsmWayIdSet() {
         return osmWayIdSet;
     }
 
-    private TIntLongMap getEdgeIdToOsmWayIdMap()
-    {
+    private TIntLongMap getEdgeIdToOsmWayIdMap() {
         if (edgeIdToOsmWayIdMap == null)
             edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
 
@@ -257,10 +234,10 @@ private TIntLongMap getEdgeIdToOsmWayIdMap()
      * Filter ways but do not analyze properties wayNodes will be filled with participating node
      * ids.
      * <p>
+     *
      * @return true the current xml entry is a way entry and has nodes
      */
-    boolean filterWay( ReaderWay item )
-    {
+    boolean filterWay(ReaderWay item) {
         // ignore broken geometry
         if (item.getNodes().size() < 2)
             return false;
@@ -275,8 +252,7 @@ boolean filterWay( ReaderWay item )
     /**
      * Creates the edges and nodes files from the specified osm file.
      */
-    private void writeOsm2Graph( File osmFile )
-    {
+    private void writeOsm2Graph(File osmFile) {
         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
         LOGGER.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
         ghStorage.create(tmp);
@@ -284,34 +260,28 @@ private void writeOsm2Graph( File osmFile )
         long relationStart = -1;
         long counter = 1;
         OSMInputFile in = null;
-        try
-        {
+        try {
             in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
             LongIntMap nodeFilter = getNodeMap();
 
             ReaderElement item;
-            while ((item = in.getNext()) != null)
-            {
-                switch (item.getType())
-                {
+            while ((item = in.getNext()) != null) {
+                switch (item.getType()) {
                     case ReaderElement.NODE:
-                        if (nodeFilter.get(item.getId()) != -1)
-                        {
+                        if (nodeFilter.get(item.getId()) != -1) {
                             processNode((ReaderNode) item);
                         }
                         break;
 
                     case ReaderElement.WAY:
-                        if (wayStart < 0)
-                        {
+                        if (wayStart < 0) {
                             LOGGER.info(nf(counter) + ", now parsing ways");
                             wayStart = counter;
                         }
                         processWay((ReaderWay) item);
                         break;
                     case ReaderElement.RELATION:
-                        if (relationStart < 0)
-                        {
+                        if (relationStart < 0) {
                             LOGGER.info(nf(counter) + ", now parsing relations");
                             relationStart = counter;
                         }
@@ -322,18 +292,15 @@ private void writeOsm2Graph( File osmFile )
                     default:
                         throw new IllegalStateException("Unknown type " + item.getType());
                 }
-                if (++counter % 100000000 == 0)
-                {
+                if (++counter % 100000000 == 0) {
                     LOGGER.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
                 }
             }
 
             // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
-        } finally
-        {
+        } finally {
             Helper.close(in);
         }
 
@@ -345,8 +312,7 @@ private void writeOsm2Graph( File osmFile )
     /**
      * Process properties, encode flags and create edges for the way.
      */
-    void processWay( ReaderWay way )
-    {
+    void processWay(ReaderWay way) {
         if (way.getNodes().size() < 2)
             return;
 
@@ -365,14 +331,12 @@ void processWay( ReaderWay way )
         // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
         TLongList osmNodeIds = way.getNodes();
         // Estimate length of ways containing a route tag e.g. for ferry speed calculation
-        if (osmNodeIds.size() > 1)
-        {
+        if (osmNodeIds.size() > 1) {
             int first = getNodeMap().get(osmNodeIds.get(0));
             int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
             double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon))
-            {
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
                 double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
                 // Add artificial tag for the estimated distance and center
                 way.setTag("estimated_distance", estimatedDist);
@@ -380,15 +344,12 @@ void processWay( ReaderWay way )
             }
         }
 
-        if (way.getTag("duration") != null)
-        {
-            try
-            {
+        if (way.getTag("duration") != null) {
+            try {
                 long dur = OSMTagParser.parseDuration(way.getTag("duration"));
                 // Provide the duration value in seconds in an artificial graphhopper specific tag:
                 way.setTag("duration:seconds", Long.toString(dur));
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 LOGGER.warn("Parsing error in way with OSMID=" + way.getId() + " : " + ex.getMessage());
             }
         }
@@ -401,22 +362,18 @@ void processWay( ReaderWay way )
         // look for barriers along the way
         final int size = osmNodeIds.size();
         int lastBarrier = -1;
-        for (int i = 0; i < size; i++)
-        {
+        for (int i = 0; i < size; i++) {
             long nodeId = osmNodeIds.get(i);
             long nodeFlags = getNodeFlagsMap().get(nodeId);
             // barrier was spotted and way is otherwise passable for that mode of travel
-            if (nodeFlags > 0)
-            {
-                if ((nodeFlags & wayFlags) > 0)
-                {
+            if (nodeFlags > 0) {
+                if ((nodeFlags & wayFlags) > 0) {
                     // remove barrier to avoid duplicates
                     getNodeFlagsMap().put(nodeId, 0);
 
                     // create shadow node copy for zero length edge
                     long newNodeId = addBarrierNode(nodeId);
-                    if (i > 0)
-                    {
+                    if (i > 0) {
                         // start at beginning of array if there was no previous barrier
                         if (lastBarrier < 0)
                             lastBarrier = 0;
@@ -429,8 +386,7 @@ void processWay( ReaderWay way )
 
                         // create zero length edge for barrier
                         createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));
-                    } else
-                    {
+                    } else {
                         // run edge from real first node to shadow node
                         createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));
 
@@ -444,40 +400,31 @@ void processWay( ReaderWay way )
         }
 
         // just add remainder of way to graph if barrier was not the last node
-        if (lastBarrier >= 0)
-        {
-            if (lastBarrier < size - 1)
-            {
+        if (lastBarrier >= 0) {
+            if (lastBarrier < size - 1) {
                 long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
                 TLongList partNodeIds = new TLongArrayList(transfer);
                 createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
             }
-        } else
-        {
+        } else {
             // no barriers - simply add the whole way
             createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
         }
 
-        for (EdgeIteratorState edge : createdEdges)
-        {
+        for (EdgeIteratorState edge : createdEdges) {
             encodingManager.applyWayTags(way, edge);
         }
     }
 
-    public void processRelation( ReaderRelation relation ) throws XMLStreamException
-    {
-        if (relation.hasTag("type", "restriction"))
-        {
+    public void processRelation(ReaderRelation relation) throws XMLStreamException {
+        if (relation.hasTag("type", "restriction")) {
             OSMTurnRelation turnRelation = createTurnRelation(relation);
-            if (turnRelation != null)
-            {
+            if (turnRelation != null) {
                 GraphExtension extendedStorage = graph.getExtension();
-                if (extendedStorage instanceof TurnCostExtension)
-                {
+                if (extendedStorage instanceof TurnCostExtension) {
                     TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
                     Collection<TurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
-                    for (TurnCostTableEntry entry : entries)
-                    {
+                    for (TurnCostTableEntry entry : entries) {
                         tcs.addTurnInfo(entry.edgeFrom, entry.nodeVia, entry.edgeTo, entry.flags);
                     }
                 }
@@ -485,21 +432,16 @@ public void processRelation( ReaderRelation relation ) throws XMLStreamException
         }
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation )
-    {
+    public Collection<TurnCostTableEntry> analyzeTurnRelation(OSMTurnRelation turnRelation) {
         TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
 
-        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
-        {
-            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation))
-            {
+        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
+            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation)) {
                 TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
-                if (oldEntry != null)
-                {
+                if (oldEntry != null) {
                     // merging different encoders
                     oldEntry.flags |= entry.flags;
-                } else
-                {
+                } else {
                     entries.put(entry.getItemId(), entry);
                 }
             }
@@ -508,16 +450,14 @@ public void processRelation( ReaderRelation relation ) throws XMLStreamException
         return entries.valueCollection();
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder, OSMTurnRelation turnRelation )
-    {
+    public Collection<TurnCostTableEntry> analyzeTurnRelation(FlagEncoder encoder, OSMTurnRelation turnRelation) {
         if (!encoder.supports(TurnWeighting.class))
             return Collections.emptyList();
 
         EdgeExplorer edgeOutExplorer = outExplorerMap.get(encoder);
         EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
 
-        if (edgeOutExplorer == null || edgeInExplorer == null)
-        {
+        if (edgeOutExplorer == null || edgeInExplorer == null) {
             edgeOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
             outExplorerMap.put(encoder, edgeOutExplorer);
 
@@ -531,13 +471,11 @@ public void processRelation( ReaderRelation relation ) throws XMLStreamException
      * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
      * order to reduce memory overhead.
      */
-    public long getOsmIdOfInternalEdge( int edgeId )
-    {
+    public long getOsmIdOfInternalEdge(int edgeId) {
         return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
-    public int getInternalNodeIdOfOsmNode( long nodeOsmId )
-    {
+    public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
         int id = getNodeMap().get(nodeOsmId);
         if (id < TOWER_NODE)
             return -id - 3;
@@ -546,17 +484,14 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
     }
 
     // TODO remove this ugly stuff via better preparsing phase! E.g. putting every tags etc into a helper file!
-    double getTmpLatitude( int id )
-    {
+    double getTmpLatitude(int id) {
         if (id == EMPTY)
             return Double.NaN;
-        if (id < TOWER_NODE)
-        {
+        if (id < TOWER_NODE) {
             // tower node
             id = -id - 3;
             return nodeAccess.getLatitude(id);
-        } else if (id > -TOWER_NODE)
-        {
+        } else if (id > -TOWER_NODE) {
             // pillar node
             id = id - 3;
             return pillarInfo.getLatitude(id);
@@ -565,17 +500,14 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
             return Double.NaN;
     }
 
-    double getTmpLongitude( int id )
-    {
+    double getTmpLongitude(int id) {
         if (id == EMPTY)
             return Double.NaN;
-        if (id < TOWER_NODE)
-        {
+        if (id < TOWER_NODE) {
             // tower node
             id = -id - 3;
             return nodeAccess.getLongitude(id);
-        } else if (id > -TOWER_NODE)
-        {
+        } else if (id > -TOWER_NODE) {
             // pillar node
             id = id - 3;
             return pillarInfo.getLon(id);
@@ -584,29 +516,24 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
             return Double.NaN;
     }
 
-    private void processNode( ReaderNode node )
-    {
-        if (isInBounds(node))
-        {
+    private void processNode(ReaderNode node) {
+        if (isInBounds(node)) {
             addNode(node);
 
             // analyze node tags for barriers
-            if (node.hasTags())
-            {
+            if (node.hasTags()) {
                 long nodeFlags = encodingManager.handleNodeTags(node);
                 if (nodeFlags != 0)
                     getNodeFlagsMap().put(node.getId(), nodeFlags);
             }
 
             locations++;
-        } else
-        {
+        } else {
             skippedLocations++;
         }
     }
 
-    boolean addNode( ReaderNode node )
-    {
+    boolean addNode(ReaderNode node) {
         int nodeType = getNodeMap().get(node.getId());
         if (nodeType == EMPTY)
             return false;
@@ -614,11 +541,9 @@ boolean addNode( ReaderNode node )
         double lat = node.getLat();
         double lon = node.getLon();
         double ele = getElevation(node);
-        if (nodeType == TOWER_NODE)
-        {
+        if (nodeType == TOWER_NODE) {
             addTowerNode(node.getId(), lat, lon, ele);
-        } else if (nodeType == PILLAR_NODE)
-        {
+        } else if (nodeType == PILLAR_NODE) {
             pillarInfo.setNode(nextPillarId, lat, lon, ele);
             getNodeMap().put(node.getId(), nextPillarId + 3);
             nextPillarId++;
@@ -626,20 +551,17 @@ boolean addNode( ReaderNode node )
         return true;
     }
 
-    protected double getElevation( ReaderNode node )
-    {
+    protected double getElevation(ReaderNode node) {
         return eleProvider.getEle(node.getLat(), node.getLon());
     }
 
-    void prepareWaysWithRelationInfo( ReaderRelation osmRelation )
-    {
+    void prepareWaysWithRelationInfo(ReaderRelation osmRelation) {
         // is there at least one tag interesting for the registed encoders?
         if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
             return;
 
         int size = osmRelation.getMembers().size();
-        for (int index = 0; index < size; index++)
-        {
+        for (int index = 0; index < size; index++) {
             ReaderRelation.Member member = osmRelation.getMembers().get(index);
             if (member.getType() != ReaderRelation.Member.WAY)
                 continue;
@@ -654,25 +576,20 @@ void prepareWaysWithRelationInfo( ReaderRelation osmRelation )
         }
     }
 
-    void prepareHighwayNode( long osmId )
-    {
+    void prepareHighwayNode(long osmId) {
         int tmpIndex = getNodeMap().get(osmId);
-        if (tmpIndex == EMPTY)
-        {
+        if (tmpIndex == EMPTY) {
             // osmId is used exactly once
             getNodeMap().put(osmId, PILLAR_NODE);
-        } else if (tmpIndex > EMPTY)
-        {
+        } else if (tmpIndex > EMPTY) {
             // mark node as tower node as it occured at least twice times
             getNodeMap().put(osmId, TOWER_NODE);
-        } else
-        {
+        } else {
             // tmpIndex is already negative (already tower node)
         }
     }
 
-    int addTowerNode( long osmId, double lat, double lon, double ele )
-    {
+    int addTowerNode(long osmId, double lat, double lon, double ele) {
         if (nodeAccess.is3D())
             nodeAccess.setNode(nextTowerId, lat, lon, ele);
         else
@@ -687,17 +604,14 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
-    {
+    Collection<EdgeIteratorState> addOSMWay(final TLongList osmNodeIds, final long flags, final long wayOsmId) {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
         int firstNode = -1;
         int lastIndex = osmNodeIds.size() - 1;
         int lastInBoundsPillarNode = -1;
-        try
-        {
-            for (int i = 0; i < osmNodeIds.size(); i++)
-            {
+        try {
+            for (int i = 0; i < osmNodeIds.size(); i++) {
                 long osmId = osmNodeIds.get(i);
                 int tmpNode = getNodeMap().get(osmId);
                 if (tmpNode == EMPTY)
@@ -707,19 +621,16 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                 if (tmpNode == TOWER_NODE)
                     continue;
 
-                if (tmpNode == PILLAR_NODE)
-                {
+                if (tmpNode == PILLAR_NODE) {
                     // In some cases no node information is saved for the specified osmId.
                     // ie. a way references a <node> which does not exist in the current file.
                     // => if the node before was a pillar node then convert into to tower node (as it is also end-standing).
-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
-                    {
+                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE) {
                         // transform the pillar node to a tower node
                         tmpNode = lastInBoundsPillarNode;
                         tmpNode = handlePillarNode(tmpNode, osmId, null, true);
                         tmpNode = -tmpNode - 3;
-                        if (pointList.getSize() > 1 && firstNode >= 0)
-                        {
+                        if (pointList.getSize() > 1 && firstNode >= 0) {
                             // TOWER node
                             newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
                             pointList.clear();
@@ -734,11 +645,9 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
                     throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
 
-                if (tmpNode > -TOWER_NODE)
-                {
+                if (tmpNode > -TOWER_NODE) {
                     boolean convertToTowerNode = i == 0 || i == lastIndex;
-                    if (!convertToTowerNode)
-                    {
+                    if (!convertToTowerNode) {
                         lastInBoundsPillarNode = tmpNode;
                     }
 
@@ -746,13 +655,11 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                     tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
                 }
 
-                if (tmpNode < TOWER_NODE)
-                {
+                if (tmpNode < TOWER_NODE) {
                     // TOWER node
                     tmpNode = -tmpNode - 3;
                     pointList.add(nodeAccess, tmpNode);
-                    if (firstNode >= 0)
-                    {
+                    if (firstNode >= 0) {
                         newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
                         pointList.clear();
                         pointList.add(nodeAccess, tmpNode);
@@ -760,8 +667,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                     firstNode = tmpNode;
                 }
             }
-        } catch (RuntimeException ex)
-        {
+        } catch (RuntimeException ex) {
             LOGGER.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
             if (exitOnlyPillarNodeException)
                 throw ex;
@@ -769,8 +675,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
         return newEdges;
     }
 
-    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
-    {
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId) {
         // sanity checks
         if (fromIndex < 0 || toIndex < 0)
             throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
@@ -784,13 +689,11 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         double lat, lon, ele = Double.NaN;
         PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
         int nodes = pointList.getSize();
-        for (int i = 1; i < nodes; i++)
-        {
+        for (int i = 1; i < nodes; i++) {
             // we could save some lines if we would use pointList.calcDistance(distCalc);
             lat = pointList.getLatitude(i);
             lon = pointList.getLongitude(i);
-            if (pointList.is3D())
-            {
+            if (pointList.is3D()) {
                 ele = pointList.getElevation(i);
                 if (!distCalc.isCrossBoundary(lon, prevLon))
                     towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
@@ -800,16 +703,14 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
 
             prevLat = lat;
             prevLon = lon;
-            if (nodes > 2 && i < nodes - 1)
-            {
+            if (nodes > 2 && i < nodes - 1) {
                 if (pillarNodes.is3D())
                     pillarNodes.add(lat, lon, ele);
                 else
                     pillarNodes.add(lat, lon);
             }
         }
-        if (towerNodeDistance < 0.0001)
-        {
+        if (towerNodeDistance < 0.0001) {
             // As investigation shows often two paths should have crossed via one identical point 
             // but end up in two very close points.
             zeroCounter++;
@@ -817,14 +718,12 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         }
 
         double maxDistance = (Integer.MAX_VALUE - 1) / 1000d;
-        if (Double.isNaN(towerNodeDistance))
-        {
+        if (Double.isNaN(towerNodeDistance)) {
             LOGGER.warn("Bug in OSM or GraphHopper. Illegal tower node distance " + towerNodeDistance + " reset to 1m, osm way " + wayOsmId);
             towerNodeDistance = 1;
         }
 
-        if (Double.isInfinite(towerNodeDistance) || towerNodeDistance > maxDistance)
-        {
+        if (Double.isInfinite(towerNodeDistance) || towerNodeDistance > maxDistance) {
             // Too large is very rare and often the wrong tagging. See #435 
             // so we can avoid the complexity of splitting the way for now (new towernodes would be required, splitting up geometry etc)
             LOGGER.warn("Bug in OSM or GraphHopper. Too big tower node distance " + towerNodeDistance + " reset to large value, osm way " + wayOsmId);
@@ -833,8 +732,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
 
         EdgeIteratorState iter = graph.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
 
-        if (nodes > 2)
-        {
+        if (nodes > 2) {
             if (doSimplify)
                 simplifyAlgo.simplify(pillarNodes);
 
@@ -847,10 +745,8 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
     /**
      * Stores only osmWayIds which are required for relations
      */
-    protected void storeOsmWayID( int edgeId, long osmWayId )
-    {
-        if (getOsmWayIdSet().contains(osmWayId))
-        {
+    protected void storeOsmWayID(int edgeId, long osmWayId) {
+        if (getOsmWayIdSet().contains(osmWayId)) {
             getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
         }
     }
@@ -858,8 +754,7 @@ protected void storeOsmWayID( int edgeId, long osmWayId )
     /**
      * @return converted tower node
      */
-    private int handlePillarNode( int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode )
-    {
+    private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode) {
         tmpNode = tmpNode - 3;
         double lat = pillarInfo.getLatitude(tmpNode);
         double lon = pillarInfo.getLongitude(tmpNode);
@@ -868,8 +763,7 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList, bool
             throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
                     + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
-        if (convertToTowerNode)
-        {
+        if (convertToTowerNode) {
             // convert pillarNode type to towerNode, make pillar values invalid
             pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
             tmpNode = addTowerNode(osmId, lat, lon, ele);
@@ -881,8 +775,7 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList, bool
         return (int) tmpNode;
     }
 
-    protected void finishedReading()
-    {
+    protected void finishedReading() {
         printInfo("way");
         pillarInfo.clear();
         eleProvider.release();
@@ -896,16 +789,13 @@ protected void finishedReading()
     /**
      * Create a copy of the barrier node
      */
-    long addBarrierNode( long nodeId )
-    {
+    long addBarrierNode(long nodeId) {
         ReaderNode newNode;
         int graphIndex = getNodeMap().get(nodeId);
-        if (graphIndex < TOWER_NODE)
-        {
+        if (graphIndex < TOWER_NODE) {
             graphIndex = -graphIndex - 3;
             newNode = new ReaderNode(createNewNodeId(), nodeAccess, graphIndex);
-        } else
-        {
+        } else {
             graphIndex = graphIndex - 3;
             newNode = new ReaderNode(createNewNodeId(), pillarInfo, graphIndex);
         }
@@ -916,16 +806,14 @@ long addBarrierNode( long nodeId )
         return id;
     }
 
-    private long createNewNodeId()
-    {
+    private long createNewNodeId() {
         return newUniqueOsmId++;
     }
 
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags, long nodeFlags, long wayOsmId )
-    {
+    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags, long nodeFlags, long wayOsmId) {
         // clear barred directions from routing flags
         flags &= ~nodeFlags;
         // add edge
@@ -938,35 +826,28 @@ private long createNewNodeId()
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
      * <p>
+     *
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
-    OSMTurnRelation createTurnRelation( ReaderRelation relation )
-    {
+    OSMTurnRelation createTurnRelation(ReaderRelation relation) {
         OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
-        if (type != OSMTurnRelation.Type.UNSUPPORTED)
-        {
+        if (type != OSMTurnRelation.Type.UNSUPPORTED) {
             long fromWayID = -1;
             long viaNodeID = -1;
             long toWayID = -1;
 
-            for (ReaderRelation.Member member : relation.getMembers())
-            {
-                if (ReaderElement.WAY == member.getType())
-                {
-                    if ("from".equals(member.getRole()))
-                    {
+            for (ReaderRelation.Member member : relation.getMembers()) {
+                if (ReaderElement.WAY == member.getType()) {
+                    if ("from".equals(member.getRole())) {
                         fromWayID = member.getRef();
-                    } else if ("to".equals(member.getRole()))
-                    {
+                    } else if ("to".equals(member.getRole())) {
                         toWayID = member.getRef();
                     }
-                } else if (ReaderElement.NODE == member.getType() && "via".equals(member.getRole()))
-                {
+                } else if (ReaderElement.NODE == member.getType() && "via".equals(member.getRole())) {
                     viaNodeID = member.getRef();
                 }
             }
-            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
-            {
+            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0) {
                 return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
             }
         }
@@ -976,26 +857,22 @@ OSMTurnRelation createTurnRelation( ReaderRelation relation )
     /**
      * Filter method, override in subclass
      */
-    boolean isInBounds( ReaderNode node )
-    {
+    boolean isInBounds(ReaderNode node) {
         return true;
     }
 
     /**
      * Maps OSM IDs (long) to internal node IDs (int)
      */
-    protected LongIntMap getNodeMap()
-    {
+    protected LongIntMap getNodeMap() {
         return osmNodeIdToInternalNodeMap;
     }
 
-    protected TLongLongMap getNodeFlagsMap()
-    {
+    protected TLongLongMap getNodeFlagsMap() {
         return osmNodeIdToNodeFlagsMap;
     }
 
-    TLongLongHashMap getRelFlagsMap()
-    {
+    TLongLongHashMap getRelFlagsMap() {
         return osmWayIdToRouteWeightMap;
     }
 
@@ -1003,30 +880,26 @@ TLongLongHashMap getRelFlagsMap()
      * Specify the type of the path calculation (car, bike, ...).
      */
     @Override
-    public OSMReader setEncodingManager( EncodingManager em )
-    {
+    public OSMReader setEncodingManager(EncodingManager em) {
         this.encodingManager = em;
         return this;
     }
 
     @Override
-    public OSMReader setWayPointMaxDistance( double maxDist )
-    {
+    public OSMReader setWayPointMaxDistance(double maxDist) {
         doSimplify = maxDist > 0;
         simplifyAlgo.setMaxDistance(maxDist);
         return this;
     }
 
     @Override
-    public OSMReader setWorkerThreads( int numOfWorkers )
-    {
+    public OSMReader setWorkerThreads(int numOfWorkers) {
         this.workerThreads = numOfWorkers;
         return this;
     }
 
     @Override
-    public OSMReader setElevationProvider( ElevationProvider eleProvider )
-    {
+    public OSMReader setElevationProvider(ElevationProvider eleProvider) {
         if (eleProvider == null)
             throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
@@ -1038,14 +911,12 @@ public OSMReader setElevationProvider( ElevationProvider eleProvider )
     }
 
     @Override
-    public DataReader setFile( File osmFile )
-    {
+    public DataReader setFile(File osmFile) {
         this.osmFile = osmFile;
         return this;
     }
 
-    private void printInfo( String str )
-    {
+    private void printInfo(String str) {
         LOGGER.info("finished " + str + " processing." + " nodes: " + graph.getNodes()
                 + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
                 + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
@@ -1054,14 +925,12 @@ private void printInfo( String str )
     }
 
     @Override
-    public Date getDataDate()
-    {
+    public Date getDataDate() {
         return osmDataDate;
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return getClass().getSimpleName();
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java
index 0fde8a96f2..55a97d53f8 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java
@@ -17,17 +17,16 @@
  */
 package com.graphhopper.reader.osm;
 
-import java.util.Date;
 import javax.xml.datatype.DatatypeFactory;
 import javax.xml.datatype.Duration;
+import java.util.Date;
 
 /**
  * This class currently parses the duration tag only.
  *
  * @author ratrun
  */
-public class OSMTagParser
-{
+public class OSMTagParser {
     // use a day somewhere within July 1970 which then makes two identical long months ala 31 days, see #588
     private final static Date STATIC_DATE = new Date((31 * 6) * 24 * 3600 * 1000);
 
@@ -36,42 +35,36 @@
      * string ala 'hh:mm', format for hours and minutes 'mm', 'hh:mm' or 'hh:mm:ss', or
      * alternatively ISO_8601 duration
      * <p>
+     *
      * @return duration value in seconds
      */
-    public static long parseDuration( String str ) throws IllegalArgumentException
-    {
+    public static long parseDuration(String str) throws IllegalArgumentException {
         long seconds = 0;
         if (str == null)
             return 0;
 
         // Check for ISO_8601 format
-        if (str.startsWith("P"))
-        {
+        if (str.startsWith("P")) {
             // A common mistake is when the minutes format is intended but the month format is specified 
             // e.g. one month "P1M" is set, but on minute "PT1M" is meant.
             Duration dur;
-            try
-            {
+            try {
                 dur = DatatypeFactory.newInstance().newDuration(str);
                 seconds = dur.getTimeInMillis(STATIC_DATE) / 1000;
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 throw new IllegalArgumentException("Cannot parse duration tag value: " + str, ex);
             }
             return seconds;
         }
 
-        try
-        {
+        try {
             int index = str.indexOf(":");
-            if (index > 0)
-            {
+            if (index > 0) {
                 String hourStr = str.substring(0, index);
                 String minStr = str.substring(index + 1);
                 String secondsStr = "0";
                 index = minStr.indexOf(":");
-                if (index > 0)
-                {
+                if (index > 0) {
                     secondsStr = minStr.substring(index + 1, index + 3);
                     minStr = minStr.substring(0, index);
                 }
@@ -80,13 +73,11 @@ public static long parseDuration( String str ) throws IllegalArgumentException
                 seconds += Integer.parseInt(minStr) * 60L;
                 seconds += Integer.parseInt(secondsStr);
                 return seconds;
-            } else
-            {
+            } else {
                 // value contains minutes
                 seconds = Integer.parseInt(str) * 60;
             }
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new IllegalArgumentException("Cannot parse duration tag value: " + str, ex);
         }
         return seconds;
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
index 5663c0c625..62a1994886 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
@@ -26,75 +26,43 @@
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
  * <p>
+ *
  * @author Karl Hübner
  */
-public class OSMTurnRelation
-{
-    enum Type
-    {
-        UNSUPPORTED, NOT, ONLY;
-
-        private static final Map<String, Type> tags = new HashMap<String, Type>();
-
-        static
-        {
-            tags.put("no_left_turn", NOT);
-            tags.put("no_right_turn", NOT);
-            tags.put("no_straight_on", NOT);
-            tags.put("no_u_turn", NOT);
-            tags.put("only_right_turn", ONLY);
-            tags.put("only_left_turn", ONLY);
-            tags.put("only_straight_on", ONLY);
-        }
-
-        public static Type getRestrictionType( String tag )
-        {
-            Type result = null;
-            if (tag != null)
-            {
-                result = tags.get(tag);
-            }
-            return (result != null) ? result : UNSUPPORTED;
-        }
-    }
-
+public class OSMTurnRelation {
     private final long fromOsmWayId;
     private final long viaOsmNodeId;
     private final long toOsmWayId;
     private final Type restriction;
 
-    OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
-    {
+    OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
         this.fromOsmWayId = fromWayID;
         this.viaOsmNodeId = viaNodeID;
         this.toOsmWayId = toWayID;
         this.restriction = restrictionType;
     }
 
-    long getOsmIdFrom()
-    {
+    long getOsmIdFrom() {
         return fromOsmWayId;
     }
 
-    long getOsmIdTo()
-    {
+    long getOsmIdTo() {
         return toOsmWayId;
     }
 
     /**
      * Transforms this relation into a collection of turn cost entries
      * <p>
+     *
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
-     * @param edgeInExplorer an edge filter which only allows incoming edges
+     * @param edgeInExplorer  an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
-    public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-                                                                   EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
-    {
+    public Collection<TurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
+                                                                  EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader) {
         int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
-        try
-        {
+        try {
             // street with restriction was not included (access or tag limits etc)
             if (nodeVia == OSMReader.EMPTY)
                 return Collections.emptyList();
@@ -104,10 +72,8 @@ long getOsmIdTo()
             // get all incoming edges and receive the edge which is defined by fromOsm
             EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
 
-            while (iter.next())
-            {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
-                {
+            while (iter.next()) {
+                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId) {
                     edgeIdFrom = iter.getEdge();
                     break;
                 }
@@ -117,17 +83,15 @@ long getOsmIdTo()
                 return Collections.emptyList();
 
             final Collection<TurnCostTableEntry> entries = new ArrayList<TurnCostTableEntry>();
-            // get all outgoing edges of the via node 
+            // get all outgoing edges of the via node
             iter = edgeOutExplorer.setBaseNode(nodeVia);
             // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
             // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
-            while (iter.next())
-            {
+            while (iter.next()) {
                 int edgeId = iter.getEdge();
                 long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
                 if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
-                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
-                {
+                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {
                     final TurnCostTableEntry entry = new TurnCostTableEntry();
                     entry.nodeVia = nodeVia;
                     entry.edgeFrom = edgeIdFrom;
@@ -140,23 +104,44 @@ long getOsmIdTo()
                 }
             }
             return entries;
-        } catch (Exception e)
-        {
+        } catch (Exception e) {
             throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
         }
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
+    enum Type {
+        UNSUPPORTED, NOT, ONLY;
+
+        private static final Map<String, Type> tags = new HashMap<String, Type>();
+
+        static {
+            tags.put("no_left_turn", NOT);
+            tags.put("no_right_turn", NOT);
+            tags.put("no_straight_on", NOT);
+            tags.put("no_u_turn", NOT);
+            tags.put("only_right_turn", ONLY);
+            tags.put("only_left_turn", ONLY);
+            tags.put("only_straight_on", ONLY);
+        }
+
+        public static Type getRestrictionType(String tag) {
+            Type result = null;
+            if (tag != null) {
+                result = tags.get(tag);
+            }
+            return (result != null) ? result : UNSUPPORTED;
+        }
+    }
+
     /**
      * Helper class to processing purposes only
      */
-    public static class TurnCostTableEntry
-    {
+    public static class TurnCostTableEntry {
         public int edgeFrom;
         public int nodeVia;
         public int edgeTo;
@@ -166,14 +151,12 @@ public String toString()
          * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
          * are involved.
          */
-        public long getItemId()
-        {
+        public long getItemId() {
             return ((long) edgeFrom) << 32 | ((long) edgeTo);
         }
 
         @Override
-        public String toString()
-        {
+        public String toString() {
             return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
         }
     }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMXMLHelper.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMXMLHelper.java
index d5058cad87..9c859537d4 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMXMLHelper.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMXMLHelper.java
@@ -22,19 +22,19 @@
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderRelation.Member;
 import com.graphhopper.reader.ReaderWay;
-import java.util.List;
+
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
+import java.util.List;
 
 /**
- *
  * @author Peter Karich
  */
-public class OSMXMLHelper
-{
-    public static ReaderNode createNode( long id, XMLStreamReader parser ) throws XMLStreamException
-    {
+public class OSMXMLHelper {
+    private static final String TYPE_DECODE = "nwr";
+
+    public static ReaderNode createNode(long id, XMLStreamReader parser) throws XMLStreamException {
         ReaderNode node = new ReaderNode(id,
                 Double.parseDouble(parser.getAttributeValue(null, "lat")),
                 Double.parseDouble(parser.getAttributeValue(null, "lon")));
@@ -44,8 +44,7 @@ public static ReaderNode createNode( long id, XMLStreamReader parser ) throws XM
         return node;
     }
 
-    public static ReaderWay createWay( long id, XMLStreamReader parser ) throws XMLStreamException
-    {
+    public static ReaderWay createWay(long id, XMLStreamReader parser) throws XMLStreamException {
         ReaderWay way = new ReaderWay(id);
         parser.nextTag();
         readNodes(way, parser);
@@ -53,13 +52,10 @@ public static ReaderWay createWay( long id, XMLStreamReader parser ) throws XMLS
         return way;
     }
 
-    private static void readNodes( ReaderWay way, XMLStreamReader parser ) throws XMLStreamException
-    {
+    private static void readNodes(ReaderWay way, XMLStreamReader parser) throws XMLStreamException {
         int event = parser.getEventType();
-        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("nd"))
-        {
-            if (event == XMLStreamConstants.START_ELEMENT)
-            {
+        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("nd")) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
                 // read node reference
                 String ref = parser.getAttributeValue(null, "ref");
                 way.getNodes().add(Long.parseLong(ref));
@@ -69,13 +65,10 @@ private static void readNodes( ReaderWay way, XMLStreamReader parser ) throws XM
         }
     }
 
-    private static void readTags( ReaderElement re, XMLStreamReader parser ) throws XMLStreamException
-    {
+    private static void readTags(ReaderElement re, XMLStreamReader parser) throws XMLStreamException {
         int event = parser.getEventType();
-        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("tag"))
-        {
-            if (event == XMLStreamConstants.START_ELEMENT)
-            {
+        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equals("tag")) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
                 // read tag
                 String key = parser.getAttributeValue(null, "k");
                 String value = parser.getAttributeValue(null, "v");
@@ -88,8 +81,7 @@ private static void readTags( ReaderElement re, XMLStreamReader parser ) throws
         }
     }
 
-    public static ReaderRelation createRelation( long id, XMLStreamReader parser ) throws XMLStreamException
-    {
+    public static ReaderRelation createRelation(long id, XMLStreamReader parser) throws XMLStreamException {
         ReaderRelation rel = new ReaderRelation(id);
 
         parser.nextTag();
@@ -98,13 +90,10 @@ public static ReaderRelation createRelation( long id, XMLStreamReader parser ) t
         return rel;
     }
 
-    private static void readMembers( List<Member> members, XMLStreamReader parser ) throws XMLStreamException
-    {
+    private static void readMembers(List<Member> members, XMLStreamReader parser) throws XMLStreamException {
         int event = parser.getEventType();
-        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equalsIgnoreCase("member"))
-        {
-            if (event == XMLStreamConstants.START_ELEMENT)
-            {
+        while (event != XMLStreamConstants.END_DOCUMENT && parser.getLocalName().equalsIgnoreCase("member")) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
                 // read member
                 members.add(createMember(parser));
             }
@@ -114,10 +103,7 @@ private static void readMembers( List<Member> members, XMLStreamReader parser )
 
     }
 
-    private static final String TYPE_DECODE = "nwr";
-
-    public static Member createMember( XMLStreamReader parser )
-    {
+    public static Member createMember(XMLStreamReader parser) {
         String typeName = parser.getAttributeValue(null, "type");
         int type = TYPE_DECODE.indexOf(typeName.charAt(0));
         long ref = Long.parseLong(parser.getAttributeValue(null, "ref"));
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoder.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoder.java
index d5a6a89922..9f289ca2d5 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoder.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoder.java
@@ -8,26 +8,25 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.reader.osm.OSMFileHeader;
 import com.graphhopper.util.Helper;
+import gnu.trove.list.TLongList;
 import org.openstreetmap.osmosis.osmbinary.Fileformat;
 import org.openstreetmap.osmosis.osmbinary.Osmformat;
-import gnu.trove.list.TLongList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.util.*;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Converts PBF block data into decoded entities ready to be passed into an Osmosis pipeline. This
  * class is designed to be passed into a pool of worker threads to allow multi-threaded decoding.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfBlobDecoder implements Runnable
-{
+public class PbfBlobDecoder implements Runnable {
     private static final Logger log = LoggerFactory.getLogger(PbfBlobDecoder.class);
     private final boolean checkData = false;
     private final String blobType;
@@ -38,62 +37,51 @@
     /**
      * Creates a new instance.
      * <p>
+     *
      * @param blobType The type of blob.
-     * @param rawBlob The raw data of the blob.
+     * @param rawBlob  The raw data of the blob.
      * @param listener The listener for receiving decoding results.
      */
-    public PbfBlobDecoder( String blobType, byte[] rawBlob, PbfBlobDecoderListener listener )
-    {
+    public PbfBlobDecoder(String blobType, byte[] rawBlob, PbfBlobDecoderListener listener) {
         this.blobType = blobType;
         this.rawBlob = rawBlob;
         this.listener = listener;
     }
 
-    private byte[] readBlobContent() throws IOException
-    {
+    private byte[] readBlobContent() throws IOException {
         Fileformat.Blob blob = Fileformat.Blob.parseFrom(rawBlob);
         byte[] blobData;
 
-        if (blob.hasRaw())
-        {
+        if (blob.hasRaw()) {
             blobData = blob.getRaw().toByteArray();
-        } else if (blob.hasZlibData())
-        {
+        } else if (blob.hasZlibData()) {
             Inflater inflater = new Inflater();
             inflater.setInput(blob.getZlibData().toByteArray());
             blobData = new byte[blob.getRawSize()];
-            try
-            {
+            try {
                 inflater.inflate(blobData);
-            } catch (DataFormatException e)
-            {
+            } catch (DataFormatException e) {
                 throw new RuntimeException("Unable to decompress PBF blob.", e);
             }
-            if (!inflater.finished())
-            {
+            if (!inflater.finished()) {
                 throw new RuntimeException("PBF blob contains incomplete compressed data.");
             }
-        } else
-        {
+        } else {
             throw new RuntimeException("PBF blob uses unsupported compression, only raw or zlib may be used.");
         }
 
         return blobData;
     }
 
-    private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferException
-    {
+    private void processOsmHeader(byte[] data) throws InvalidProtocolBufferException {
         Osmformat.HeaderBlock header = Osmformat.HeaderBlock.parseFrom(data);
 
         // Build the list of active and unsupported features in the file.
         List<String> supportedFeatures = Arrays.asList("OsmSchema-V0.6", "DenseNodes");
         List<String> unsupportedFeatures = new ArrayList<String>();
-        for (String feature : header.getRequiredFeaturesList())
-        {
-            if (supportedFeatures.contains(feature))
-            {
-            } else
-            {
+        for (String feature : header.getRequiredFeaturesList()) {
+            if (supportedFeatures.contains(feature)) {
+            } else {
                 unsupportedFeatures.add(feature);
             }
         }
@@ -101,8 +89,7 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
         // We can't continue if there are any unsupported features. We wait
         // until now so that we can display all unsupported features instead of
         // just the first one we encounter.
-        if (unsupportedFeatures.size() > 0)
-        {
+        if (unsupportedFeatures.size() > 0) {
             throw new RuntimeException("PBF file contains unsupported features " + unsupportedFeatures);
         }
 
@@ -128,14 +115,11 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
          */
     }
 
-    private Map<String, String> buildTags( List<Integer> keys, List<Integer> values, PbfFieldDecoder fieldDecoder )
-    {
+    private Map<String, String> buildTags(List<Integer> keys, List<Integer> values, PbfFieldDecoder fieldDecoder) {
 
         // Ensure parallel lists are of equal size.
-        if (checkData)
-        {
-            if (keys.size() != values.size())
-            {
+        if (checkData) {
+            if (keys.size() != values.size()) {
                 throw new RuntimeException("Number of tag keys (" + keys.size() + ") and tag values ("
                         + values.size() + ") don't match");
             }
@@ -143,11 +127,9 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
 
         Iterator<Integer> keyIterator = keys.iterator();
         Iterator<Integer> valueIterator = values.iterator();
-        if (keyIterator.hasNext())
-        {
+        if (keyIterator.hasNext()) {
             Map<String, String> tags = new HashMap<String, String>(keys.size());
-            while (keyIterator.hasNext())
-            {
+            while (keyIterator.hasNext()) {
                 String key = fieldDecoder.decodeString(keyIterator.next());
                 String value = fieldDecoder.decodeString(valueIterator.next());
                 tags.put(key, value);
@@ -157,10 +139,8 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
         return null;
     }
 
-    private void processNodes( List<Osmformat.Node> nodes, PbfFieldDecoder fieldDecoder )
-    {
-        for (Osmformat.Node node : nodes)
-        {
+    private void processNodes(List<Osmformat.Node> nodes, PbfFieldDecoder fieldDecoder) {
+        for (Osmformat.Node node : nodes) {
             Map<String, String> tags = buildTags(node.getKeysList(), node.getValsList(), fieldDecoder);
 
             ReaderNode osmNode = new ReaderNode(node.getId(), fieldDecoder.decodeLatitude(node
@@ -172,17 +152,14 @@ private void processNodes( List<Osmformat.Node> nodes, PbfFieldDecoder fieldDeco
         }
     }
 
-    private void processNodes( Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDecoder )
-    {
+    private void processNodes(Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDecoder) {
         List<Long> idList = nodes.getIdList();
         List<Long> latList = nodes.getLatList();
         List<Long> lonList = nodes.getLonList();
 
         // Ensure parallel lists are of equal size.
-        if (checkData)
-        {
-            if ((idList.size() != latList.size()) || (idList.size() != lonList.size()))
-            {
+        if (checkData) {
+            if ((idList.size() != latList.size()) || (idList.size() != lonList.size())) {
                 throw new RuntimeException("Number of ids (" + idList.size() + "), latitudes (" + latList.size()
                         + "), and longitudes (" + lonList.size() + ") don't match");
             }
@@ -205,8 +182,7 @@ private void processNodes( Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDeco
 //		int userSid = 0;
 //		long timestamp = 0;
 //		long changesetId = 0;
-        for (int i = 0; i < idList.size(); i++)
-        {
+        for (int i = 0; i < idList.size(); i++) {
             // Delta decode node fields.
             nodeId += idList.get(i);
             latitude += latList.get(i);
@@ -239,25 +215,20 @@ private void processNodes( Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDeco
             // in the same PBF array. Each set of tags is delimited by an index
             // with a value of 0.
             Map<String, String> tags = null;
-            while (keysValuesIterator.hasNext())
-            {
+            while (keysValuesIterator.hasNext()) {
                 int keyIndex = keysValuesIterator.next();
-                if (keyIndex == 0)
-                {
+                if (keyIndex == 0) {
                     break;
                 }
-                if (checkData)
-                {
-                    if (!keysValuesIterator.hasNext())
-                    {
+                if (checkData) {
+                    if (!keysValuesIterator.hasNext()) {
                         throw new RuntimeException(
                                 "The PBF DenseInfo keys/values list contains a key with no corresponding value.");
                     }
                 }
                 int valueIndex = keysValuesIterator.next();
 
-                if (tags == null)
-                {
+                if (tags == null) {
                     tags = new HashMap<String, String>();
                 }
 
@@ -272,10 +243,8 @@ private void processNodes( Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDeco
         }
     }
 
-    private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder )
-    {
-        for (Osmformat.Way way : ways)
-        {
+    private void processWays(List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder) {
+        for (Osmformat.Way way : ways) {
             Map<String, String> tags = buildTags(way.getKeysList(), way.getValsList(), fieldDecoder);
             ReaderWay osmWay = new ReaderWay(way.getId());
             osmWay.setTags(tags);
@@ -285,8 +254,7 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
             // the previous one.
             long nodeId = 0;
             TLongList wayNodes = osmWay.getNodes();
-            for (long nodeIdOffset : way.getRefsList())
-            {
+            for (long nodeIdOffset : way.getRefsList()) {
                 nodeId += nodeIdOffset;
                 wayNodes.add(nodeId);
             }
@@ -295,18 +263,15 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
         }
     }
 
-    private void buildRelationMembers( ReaderRelation relation,
-                                       List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
-                                       PbfFieldDecoder fieldDecoder )
-    {
+    private void buildRelationMembers(ReaderRelation relation,
+                                      List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
+                                      PbfFieldDecoder fieldDecoder) {
 
         List<ReaderRelation.Member> members = relation.getMembers();
 
         // Ensure parallel lists are of equal size.
-        if (checkData)
-        {
-            if ((memberIds.size() != memberRoles.size()) || (memberIds.size() != memberTypes.size()))
-            {
+        if (checkData) {
+            if ((memberIds.size() != memberRoles.size()) || (memberIds.size() != memberTypes.size())) {
                 throw new RuntimeException("Number of member ids (" + memberIds.size() + "), member roles ("
                         + memberRoles.size() + "), and member types (" + memberTypes.size() + ") don't match");
             }
@@ -320,23 +285,18 @@ private void buildRelationMembers( ReaderRelation relation,
         // delta encoded meaning that each id is stored as a delta against
         // the previous one.
         long refId = 0;
-        while (memberIdIterator.hasNext())
-        {
+        while (memberIdIterator.hasNext()) {
             Osmformat.Relation.MemberType memberType = memberTypeIterator.next();
             refId += memberIdIterator.next();
 
             int entityType = ReaderRelation.Member.NODE;
-            if (memberType == Osmformat.Relation.MemberType.WAY)
-            {
+            if (memberType == Osmformat.Relation.MemberType.WAY) {
                 entityType = ReaderRelation.Member.WAY;
-            } else if (memberType == Osmformat.Relation.MemberType.RELATION)
-            {
+            } else if (memberType == Osmformat.Relation.MemberType.RELATION) {
                 entityType = ReaderRelation.Member.RELATION;
             }
-            if (checkData)
-            {
-                if (entityType == ReaderRelation.Member.NODE && memberType != Osmformat.Relation.MemberType.NODE)
-                {
+            if (checkData) {
+                if (entityType == ReaderRelation.Member.NODE && memberType != Osmformat.Relation.MemberType.NODE) {
                     throw new RuntimeException("Member type of " + memberType + " is not supported.");
                 }
             }
@@ -347,10 +307,8 @@ private void buildRelationMembers( ReaderRelation relation,
         }
     }
 
-    private void processRelations( List<Osmformat.Relation> relations, PbfFieldDecoder fieldDecoder )
-    {
-        for (Osmformat.Relation relation : relations)
-        {
+    private void processRelations(List<Osmformat.Relation> relations, PbfFieldDecoder fieldDecoder) {
+        for (Osmformat.Relation relation : relations) {
             Map<String, String> tags = buildTags(relation.getKeysList(), relation.getValsList(), fieldDecoder);
 
             ReaderRelation osmRelation = new ReaderRelation(relation.getId());
@@ -364,13 +322,11 @@ private void processRelations( List<Osmformat.Relation> relations, PbfFieldDecod
         }
     }
 
-    private void processOsmPrimitives( byte[] data ) throws InvalidProtocolBufferException
-    {
+    private void processOsmPrimitives(byte[] data) throws InvalidProtocolBufferException {
         Osmformat.PrimitiveBlock block = Osmformat.PrimitiveBlock.parseFrom(data);
         PbfFieldDecoder fieldDecoder = new PbfFieldDecoder(block);
 
-        for (Osmformat.PrimitiveGroup primitiveGroup : block.getPrimitivegroupList())
-        {
+        for (Osmformat.PrimitiveGroup primitiveGroup : block.getPrimitivegroupList()) {
             log.debug("Processing OSM primitive group.");
             processNodes(primitiveGroup.getDense(), fieldDecoder);
             processNodes(primitiveGroup.getNodesList(), fieldDecoder);
@@ -379,37 +335,29 @@ private void processOsmPrimitives( byte[] data ) throws InvalidProtocolBufferExc
         }
     }
 
-    private void runAndTrapExceptions()
-    {
-        try
-        {
+    private void runAndTrapExceptions() {
+        try {
             decodedEntities = new ArrayList<ReaderElement>();
-            if ("OSMHeader".equals(blobType))
-            {
+            if ("OSMHeader".equals(blobType)) {
                 processOsmHeader(readBlobContent());
 
-            } else if ("OSMData".equals(blobType))
-            {
+            } else if ("OSMData".equals(blobType)) {
                 processOsmPrimitives(readBlobContent());
 
             } else if (log.isDebugEnabled())
                 log.debug("Skipping unrecognised blob type " + blobType);
-        } catch (IOException e)
-        {
+        } catch (IOException e) {
             throw new RuntimeException("Unable to process PBF blob", e);
         }
     }
 
     @Override
-    public void run()
-    {
-        try
-        {
+    public void run() {
+        try {
             runAndTrapExceptions();
             listener.complete(decodedEntities);
 
-        } catch (RuntimeException e)
-        {
+        } catch (RuntimeException e) {
             listener.error(e);
         }
     }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoderListener.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoderListener.java
index 0d64a7dc37..423608e9c5 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoderListener.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobDecoderListener.java
@@ -8,19 +8,20 @@
 /**
  * Instances of this interface are used to receive results from PBFBlobDecoder.
  * <p>
+ *
  * @author Brett Henderson
  */
-public interface PbfBlobDecoderListener
-{
+public interface PbfBlobDecoderListener {
     /**
      * Provides the listener with the list of decoded entities.
      * <p>
+     *
      * @param decodedEntities The decoded entities.
      */
-    void complete( List<ReaderElement> decodedEntities );
+    void complete(List<ReaderElement> decodedEntities);
 
     /**
      * Notifies the listener that an error occurred during processing.
      */
-    void error( Exception ex );
+    void error(Exception ex);
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobResult.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobResult.java
index 704e537a75..78f98a27cd 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobResult.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfBlobResult.java
@@ -1,17 +1,17 @@
 // This software is released into the Public Domain.  See copying.txt for details.
 package com.graphhopper.reader.osm.pbf;
 
-import java.util.List;
-
 import com.graphhopper.reader.ReaderElement;
 
+import java.util.List;
+
 /**
  * Stores the results for a decoded Blob.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfBlobResult
-{
+public class PbfBlobResult {
     private List<ReaderElement> entities;
     private boolean complete;
     private boolean success;
@@ -20,8 +20,7 @@
     /**
      * Creates a new instance.
      */
-    public PbfBlobResult()
-    {
+    public PbfBlobResult() {
         complete = false;
         success = false;
         ex = new RuntimeException("no success result stored");
@@ -30,10 +29,10 @@ public PbfBlobResult()
     /**
      * Stores the results of a successful blob decoding operation.
      * <p>
+     *
      * @param decodedEntities The entities from the blob.
      */
-    public void storeSuccessResult( List<ReaderElement> decodedEntities )
-    {
+    public void storeSuccessResult(List<ReaderElement> decodedEntities) {
         entities = decodedEntities;
         complete = true;
         success = true;
@@ -42,8 +41,7 @@ public void storeSuccessResult( List<ReaderElement> decodedEntities )
     /**
      * Stores a failure result for a blob decoding operation.
      */
-    public void storeFailureResult( Exception ex )
-    {
+    public void storeFailureResult(Exception ex) {
         complete = true;
         success = false;
         this.ex = ex;
@@ -52,25 +50,24 @@ public void storeFailureResult( Exception ex )
     /**
      * Gets the complete flag.
      * <p>
+     *
      * @return True if complete.
      */
-    public boolean isComplete()
-    {
+    public boolean isComplete() {
         return complete;
     }
 
     /**
      * Gets the success flag. This is only valid after complete becomes true.
      * <p>
+     *
      * @return True if successful.
      */
-    public boolean isSuccess()
-    {
+    public boolean isSuccess() {
         return success;
     }
 
-    public Exception getException()
-    {
+    public Exception getException() {
         return ex;
     }
 
@@ -78,10 +75,10 @@ public Exception getException()
      * Gets the entities decoded from the blob. This is only valid after complete becomes true, and
      * if success is true.
      * <p>
+     *
      * @return The list of decoded entities.
      */
-    public List<ReaderElement> getEntities()
-    {
+    public List<ReaderElement> getEntities() {
         return entities;
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfDecoder.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfDecoder.java
index 70319ef91a..15a536cfe1 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfDecoder.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfDecoder.java
@@ -3,8 +3,6 @@
 
 import com.graphhopper.reader.ReaderElement;
 
-import java.util.Date;
-
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
@@ -17,10 +15,10 @@
  * Decodes all blocks from a PBF stream using worker threads, and passes the results to the
  * downstream sink.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfDecoder implements Runnable
-{
+public class PbfDecoder implements Runnable {
     private final PbfStreamSplitter streamSplitter;
     private final ExecutorService executorService;
     private final int maxPendingBlobs;
@@ -32,14 +30,14 @@
     /**
      * Creates a new instance.
      * <p>
-     * @param streamSplitter The PBF stream splitter providing the source of blobs to be decoded.
+     *
+     * @param streamSplitter  The PBF stream splitter providing the source of blobs to be decoded.
      * @param executorService The executor service managing the thread pool.
      * @param maxPendingBlobs The maximum number of blobs to have in progress at any point in time.
-     * @param sink The sink to send all decoded entities to.
+     * @param sink            The sink to send all decoded entities to.
      */
-    public PbfDecoder( PbfStreamSplitter streamSplitter, ExecutorService executorService, int maxPendingBlobs,
-                       Sink sink )
-    {
+    public PbfDecoder(PbfStreamSplitter streamSplitter, ExecutorService executorService, int maxPendingBlobs,
+                      Sink sink) {
         this.streamSplitter = streamSplitter;
         this.executorService = executorService;
         this.maxPendingBlobs = maxPendingBlobs;
@@ -57,14 +55,10 @@ public PbfDecoder( PbfStreamSplitter streamSplitter, ExecutorService executorSer
      * Any thread can call this method when they wish to wait until an update has been performed by
      * another thread.
      */
-    private void waitForUpdate()
-    {
-        try
-        {
+    private void waitForUpdate() {
+        try {
             dataWaitCondition.await();
-
-        } catch (InterruptedException e)
-        {
+        } catch (InterruptedException e) {
             throw new RuntimeException("Thread was interrupted.", e);
         }
     }
@@ -73,26 +67,21 @@ private void waitForUpdate()
      * Any thread can call this method when they wish to signal another thread that an update has
      * occurred.
      */
-    private void signalUpdate()
-    {
+    private void signalUpdate() {
         dataWaitCondition.signal();
     }
 
-    private void sendResultsToSink( int targetQueueSize )
-    {
-        while (blobResults.size() > targetQueueSize)
-        {
+    private void sendResultsToSink(int targetQueueSize) {
+        while (blobResults.size() > targetQueueSize) {
             // Get the next result from the queue and wait for it to complete.
             PbfBlobResult blobResult = blobResults.remove();
-            while (!blobResult.isComplete())
-            {
+            while (!blobResult.isComplete()) {
                 // The thread hasn't finished processing yet so wait for an
                 // update from another thread before checking again.
                 waitForUpdate();
             }
 
-            if (!blobResult.isSuccess())
-            {
+            if (!blobResult.isSuccess()) {
                 throw new RuntimeException("A PBF decoding worker thread failed, aborting.", blobResult.getException());
             }
 
@@ -100,24 +89,19 @@ private void sendResultsToSink( int targetQueueSize )
             // for the duration of processing to allow worker threads to post
             // their results.
             lock.unlock();
-            try
-            {
-                for (ReaderElement entity : blobResult.getEntities())
-                {
+            try {
+                for (ReaderElement entity : blobResult.getEntities()) {
                     sink.process(entity);
                 }
-            } finally
-            {
+            } finally {
                 lock.lock();
             }
         }
     }
 
-    private void processBlobs()
-    {
+    private void processBlobs() {
         // Process until the PBF stream is exhausted.
-        while (streamSplitter.hasNext())
-        {
+        while (streamSplitter.hasNext()) {
             // Obtain the next raw blob from the PBF stream.
             PbfRawBlob rawBlob = streamSplitter.next();
 
@@ -128,35 +112,28 @@ private void processBlobs()
 
             // Create the listener object that will update the blob results
             // based on an event fired by the blob decoder.
-            PbfBlobDecoderListener decoderListener = new PbfBlobDecoderListener()
-            {
+            PbfBlobDecoderListener decoderListener = new PbfBlobDecoderListener() {
                 @Override
-                public void error( Exception ex )
-                {
+                public void error(Exception ex) {
                     lock.lock();
-                    try
-                    {
+                    try {
                         // System.out.println("ERROR: " + new Date());
                         blobResult.storeFailureResult(ex);
                         signalUpdate();
 
-                    } finally
-                    {
+                    } finally {
                         lock.unlock();
                     }
                 }
 
                 @Override
-                public void complete( List<ReaderElement> decodedEntities )
-                {
+                public void complete(List<ReaderElement> decodedEntities) {
                     lock.lock();
-                    try
-                    {
+                    try {
                         blobResult.storeSuccessResult(decodedEntities);
                         signalUpdate();
 
-                    } finally
-                    {
+                    } finally {
                         lock.unlock();
                     }
                 }
@@ -177,15 +154,12 @@ public void complete( List<ReaderElement> decodedEntities )
     }
 
     @Override
-    public void run()
-    {
+    public void run() {
         lock.lock();
-        try
-        {
+        try {
             processBlobs();
 
-        } finally
-        {
+        } finally {
             lock.unlock();
         }
     }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfFieldDecoder.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfFieldDecoder.java
index 37798885a3..925c3c9bc9 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfFieldDecoder.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfFieldDecoder.java
@@ -1,18 +1,18 @@
 // This software is released into the Public Domain.  See copying.txt for details.
 package com.graphhopper.reader.osm.pbf;
 
-import java.util.Date;
-
 import org.openstreetmap.osmosis.osmbinary.Osmformat;
 
+import java.util.Date;
+
 /**
  * Manages decoding of the lower level PBF data structures.
  * <p>
+ *
  * @author Brett Henderson
- *         <p>
+ * <p>
  */
-public class PbfFieldDecoder
-{
+public class PbfFieldDecoder {
     private static final double COORDINATE_SCALING_FACTOR = 0.000000001;
     private String[] strings;
     private int coordGranularity;
@@ -23,10 +23,10 @@
     /**
      * Creates a new instance.
      * <p>
+     *
      * @param primitiveBlock The primitive block containing the fields to be decoded.
      */
-    public PbfFieldDecoder( Osmformat.PrimitiveBlock primitiveBlock )
-    {
+    public PbfFieldDecoder(Osmformat.PrimitiveBlock primitiveBlock) {
         this.coordGranularity = primitiveBlock.getGranularity();
         this.coordLatitudeOffset = primitiveBlock.getLatOffset();
         this.coordLongitudeOffset = primitiveBlock.getLonOffset();
@@ -34,8 +34,7 @@ public PbfFieldDecoder( Osmformat.PrimitiveBlock primitiveBlock )
 
         Osmformat.StringTable stringTable = primitiveBlock.getStringtable();
         strings = new String[stringTable.getSCount()];
-        for (int i = 0; i < strings.length; i++)
-        {
+        for (int i = 0; i < strings.length; i++) {
             strings[i] = stringTable.getS(i).toStringUtf8();
         }
     }
@@ -43,44 +42,44 @@ public PbfFieldDecoder( Osmformat.PrimitiveBlock primitiveBlock )
     /**
      * Decodes a raw latitude value into degrees.
      * <p>
+     *
      * @param rawLatitude The PBF encoded value.
      * @return The latitude in degrees.
      */
-    public double decodeLatitude( long rawLatitude )
-    {
+    public double decodeLatitude(long rawLatitude) {
         return COORDINATE_SCALING_FACTOR * (coordLatitudeOffset + (coordGranularity * rawLatitude));
     }
 
     /**
      * Decodes a raw longitude value into degrees.
      * <p>
+     *
      * @param rawLongitude The PBF encoded value.
      * @return The longitude in degrees.
      */
-    public double decodeLongitude( long rawLongitude )
-    {
+    public double decodeLongitude(long rawLongitude) {
         return COORDINATE_SCALING_FACTOR * (coordLongitudeOffset + (coordGranularity * rawLongitude));
     }
 
     /**
      * Decodes a raw timestamp value into a Date.
      * <p>
+     *
      * @param rawTimestamp The PBF encoded timestamp.
      * @return The timestamp as a Date.
      */
-    public Date decodeTimestamp( long rawTimestamp )
-    {
+    public Date decodeTimestamp(long rawTimestamp) {
         return new Date(dateGranularity * rawTimestamp);
     }
 
     /**
      * Decodes a raw string into a String.
      * <p>
+     *
      * @param rawString The PBF encoding string.
      * @return The string as a String.
      */
-    public String decodeString( int rawString )
-    {
+    public String decodeString(int rawString) {
         return strings[rawString];
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfRawBlob.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfRawBlob.java
index 360fa81340..fd1c127a2c 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfRawBlob.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfRawBlob.java
@@ -5,22 +5,22 @@
  * Represents a single piece of raw blob data extracted from the PBF stream. It has not yet been
  * decoded into a PBF blob object.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfRawBlob
-{
+public class PbfRawBlob {
     private String type;
     private byte[] data;
 
     /**
      * Creates a new instance.
      * <p>
+     *
      * @param type The type of data represented by this blob. This corresponds to the type field in
-     * the blob header.
+     *             the blob header.
      * @param data The raw contents of the blob in binary undecoded form.
      */
-    public PbfRawBlob( String type, byte[] data )
-    {
+    public PbfRawBlob(String type, byte[] data) {
         this.type = type;
         this.data = data;
     }
@@ -29,20 +29,20 @@ public PbfRawBlob( String type, byte[] data )
      * Gets the type of data represented by this blob. This corresponds to the type field in the
      * blob header.
      * <p>
+     *
      * @return The blob type.
      */
-    public String getType()
-    {
+    public String getType() {
         return type;
     }
 
     /**
      * Gets the raw contents of the blob in binary undecoded form.
      * <p>
+     *
      * @return The raw blob data.
      */
-    public byte[] getData()
-    {
+    public byte[] getData() {
         return data;
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfReader.java
index 26f2e66a67..7663c0ac03 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfReader.java
@@ -9,10 +9,10 @@
 /**
  * An OSM data source reading from a PBF file. The entire contents of the file are read.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfReader implements Runnable
-{
+public class PbfReader implements Runnable {
     private InputStream inputStream;
     private Sink sink;
     private int workers;
@@ -20,22 +20,20 @@
     /**
      * Creates a new instance.
      * <p>
-     * @param in The file to read.
+     *
+     * @param in      The file to read.
      * @param workers The number of worker threads for decoding PBF blocks.
      */
-    public PbfReader( InputStream in, Sink sink, int workers )
-    {
+    public PbfReader(InputStream in, Sink sink, int workers) {
         this.inputStream = in;
         this.sink = sink;
         this.workers = workers;
     }
 
     @Override
-    public void run()
-    {
+    public void run() {
         ExecutorService executorService = Executors.newFixedThreadPool(workers);
-        try
-        {
+        try {
             // Create a stream splitter to break the PBF stream into blobs.
             PbfStreamSplitter streamSplitter = new PbfStreamSplitter(new DataInputStream(inputStream));
 
@@ -48,11 +46,9 @@ public void run()
             PbfDecoder pbfDecoder = new PbfDecoder(streamSplitter, executorService, workers + 1, sink);
             pbfDecoder.run();
 
-        } catch (Exception e)
-        {
+        } catch (Exception e) {
             throw new RuntimeException("Unable to read PBF file.", e);
-        } finally
-        {
+        } finally {
             sink.complete();
             executorService.shutdownNow();
         }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfStreamSplitter.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfStreamSplitter.java
index f2a7120d28..8c73ac0219 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfStreamSplitter.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/PbfStreamSplitter.java
@@ -14,10 +14,10 @@
  * Parses a PBF data stream and extracts the raw data of each blob in sequence until the end of the
  * stream is reached.
  * <p>
+ *
  * @author Brett Henderson
  */
-public class PbfStreamSplitter implements Iterator<PbfRawBlob>
-{
+public class PbfStreamSplitter implements Iterator<PbfRawBlob> {
     private static Logger log = Logger.getLogger(PbfStreamSplitter.class.getName());
     private DataInputStream dis;
     private int dataBlockCount;
@@ -27,17 +27,16 @@
     /**
      * Creates a new instance.
      * <p>
+     *
      * @param pbfStream The PBF data stream to be parsed.
      */
-    public PbfStreamSplitter( DataInputStream pbfStream )
-    {
+    public PbfStreamSplitter(DataInputStream pbfStream) {
         dis = pbfStream;
         dataBlockCount = 0;
         eof = false;
     }
 
-    private Fileformat.BlobHeader readHeader( int headerLength ) throws IOException
-    {
+    private Fileformat.BlobHeader readHeader(int headerLength) throws IOException {
         byte[] headerBuffer = new byte[headerLength];
         dis.readFully(headerBuffer);
 
@@ -46,8 +45,7 @@ public PbfStreamSplitter( DataInputStream pbfStream )
         return blobHeader;
     }
 
-    private byte[] readRawBlob( Fileformat.BlobHeader blobHeader ) throws IOException
-    {
+    private byte[] readRawBlob(Fileformat.BlobHeader blobHeader) throws IOException {
         byte[] rawBlob = new byte[blobHeader.getDatasize()];
 
         dis.readFully(rawBlob);
@@ -55,48 +53,39 @@ public PbfStreamSplitter( DataInputStream pbfStream )
         return rawBlob;
     }
 
-    private void getNextBlob()
-    {
-        try
-        {
+    private void getNextBlob() {
+        try {
             // Read the length of the next header block. This is the only time
             // we should expect to encounter an EOF exception. In all other
             // cases it indicates a corrupt or truncated file.
             int headerLength;
-            try
-            {
+            try {
                 headerLength = dis.readInt();
-            } catch (EOFException e)
-            {
+            } catch (EOFException e) {
                 eof = true;
                 return;
             }
 
-            if (log.isLoggable(Level.FINER))
-            {
+            if (log.isLoggable(Level.FINER)) {
                 log.finer("Reading header for blob " + dataBlockCount++);
             }
             Fileformat.BlobHeader blobHeader = readHeader(headerLength);
 
-            if (log.isLoggable(Level.FINER))
-            {
+            if (log.isLoggable(Level.FINER)) {
                 log.finer("Processing blob of type " + blobHeader.getType() + ".");
             }
             byte[] blobData = readRawBlob(blobHeader);
 
             nextBlob = new PbfRawBlob(blobHeader.getType(), blobData);
 
-        } catch (IOException e)
-        {
+        } catch (IOException e) {
             throw new RuntimeException("Unable to get next blob from PBF stream.", e);
         }
     }
 
     @Override
-    public boolean hasNext()
-    {
-        if (nextBlob == null && !eof)
-        {
+    public boolean hasNext() {
+        if (nextBlob == null && !eof) {
             getNextBlob();
         }
 
@@ -104,8 +93,7 @@ public boolean hasNext()
     }
 
     @Override
-    public PbfRawBlob next()
-    {
+    public PbfRawBlob next() {
         PbfRawBlob result = nextBlob;
         nextBlob = null;
 
@@ -113,20 +101,15 @@ public PbfRawBlob next()
     }
 
     @Override
-    public void remove()
-    {
+    public void remove() {
         throw new UnsupportedOperationException();
     }
 
-    public void release()
-    {
-        if (dis != null)
-        {
-            try
-            {
+    public void release() {
+        if (dis != null) {
+            try {
                 dis.close();
-            } catch (IOException e)
-            {
+            } catch (IOException e) {
                 log.log(Level.SEVERE, "Unable to close PBF stream.", e);
             }
         }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/Sink.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/Sink.java
index 480e9f67f3..31849c41a0 100755
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/Sink.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/pbf/Sink.java
@@ -22,9 +22,8 @@
 /**
  * @author Nop
  */
-public interface Sink
-{
-    void process( ReaderElement item );
+public interface Sink {
+    void process(ReaderElement item);
 
     void complete();
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperAPITest.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 1082ca4169..6ae541b494 100755
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.PointList;
 import org.junit.Test;
 
@@ -28,13 +30,11 @@
 /**
  * @author Peter Karich
  */
-public class GraphHopperAPITest
-{
+public class GraphHopperAPITest {
     final EncodingManager encodingManager = new EncodingManager("car");
 
     @Test
-    public void testLoad()
-    {
+    public void testLoad() {
         GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
@@ -57,7 +57,7 @@ public void testLoad()
         assertFalse(rsp.hasErrors());
         PathWrapper arsp = rsp.getBest();
         assertEquals(80, arsp.getDistance(), 1e-6);
-        
+
         PointList points = arsp.getPoints();
         assertEquals(42, points.getLatitude(0), 1e-5);
         assertEquals(10.4, points.getLongitude(0), 1e-5);
@@ -68,8 +68,7 @@ public void testLoad()
     }
 
     @Test
-    public void testDisconnected179()
-    {
+    public void testDisconnected179() {
         GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
@@ -87,39 +86,32 @@ public void testDisconnected179()
         GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
         assertTrue(rsp.hasErrors());
 
-        try
-        {
+        try {
             rsp.getBest().getPoints();
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
 
         instance.close();
     }
 
     @Test
-    public void testNoLoad()
-    {
+    public void testNoLoad() {
         GraphHopper instance = new GraphHopper().
                 setStoreOnFlush(false).
                 setEncodingManager(encodingManager).setCHEnabled(false);
-        try
-        {
+        try {
             instance.route(new GHRequest(42, 10.4, 42, 10));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Do a successful call to load or importOrLoad before routing"));
         }
 
         instance = new GraphHopper().setEncodingManager(encodingManager);
-        try
-        {
+        try {
             instance.route(new GHRequest(42, 10.4, 42, 10));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Do a successful call to load or importOrLoad before routing"));
         }
     }
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 9d32b0680b..3296751d3f 100755
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -21,7 +21,6 @@
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
-import static com.graphhopper.util.Parameters.Algorithms.*;
 import com.graphhopper.util.Parameters.CH;
 import com.graphhopper.util.Parameters.Routing;
 import com.graphhopper.util.shapes.GHPoint;
@@ -32,44 +31,32 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.graphhopper.util.Parameters.Algorithms.*;
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class GraphHopperIT
-{
+public class GraphHopperIT {
+    private static final double PRECISION = 0.01;
     public static final String DIR = "../core/files";
-    private static GraphHopper hopper;
     private static final String graphFileFoot = "target/graphhopperIT-foot";
     private static final String osmFile = DIR + "/monaco.osm.gz";
     private static final String importVehicles = "foot";
+    private static final String genericImportVehicles = "generic,foot";
     private static final String vehicle = "foot";
     private static final String weightCalcStr = "shortest";
-
+    private static GraphHopper hopper;
     private final String tmpGraphFile = "target/graphhopperIT-tmp";
 
-    @Before
-    public void setUp()
-    {
-        Helper.removeDir(new File(tmpGraphFile));
-    }
-
-    @After
-    public void tearDown()
-    {
-        Helper.removeDir(new File(tmpGraphFile));
-    }
-
     @BeforeClass
-    public static void beforeClass()
-    {
+    public static void beforeClass() {
         // make sure we are using fresh graphhopper files with correct vehicle
         Helper.removeDir(new File(graphFileFoot));
 
         hopper = new GraphHopperOSM().
                 setOSMFile(osmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setCHEnabled(false).
                 setGraphHopperLocation(graphFileFoot).
                 setEncodingManager(new EncodingManager(importVehicles)).
@@ -77,14 +64,22 @@ public static void beforeClass()
     }
 
     @AfterClass
-    public static void afterClass()
-    {
+    public static void afterClass() {
         Helper.removeDir(new File(graphFileFoot));
     }
 
+    @Before
+    public void setUp() {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
+    @After
+    public void tearDown() {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
     @Test
-    public void testMonacoWithInstructions() throws Exception
-    {
+    public void testMonacoWithInstructions() throws Exception {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
@@ -92,7 +87,7 @@ public void testMonacoWithInstructions() throws Exception
         assertEquals(698, rsp.getHints().getLong("visited_nodes.sum", 0));
 
         PathWrapper arsp = rsp.getBest();
-        assertEquals(3437.6, arsp.getDistance(), .1);
+        assertEquals(3437.58, arsp.getDistance(), PRECISION);
         assertEquals(89, arsp.getPoints().getSize());
 
         assertEquals(43.7276852, arsp.getWaypoints().getLat(0), 1e-7);
@@ -131,8 +126,7 @@ public void testMonacoWithInstructions() throws Exception
     }
 
     @Test
-    public void testAlternativeRoutes()
-    {
+    public void testAlternativeRoutes() {
         GHRequest req = new GHRequest(43.729057, 7.41251, 43.740298, 7.423561).
                 setAlgorithm(ALT_ROUTE).setVehicle(vehicle).setWeighting(weightCalcStr);
 
@@ -155,8 +149,7 @@ public void testAlternativeRoutes()
     }
 
     @Test
-    public void testAlternativeRoutesBikeAndCar()
-    {
+    public void testAlternativeRoutesBikeAndCar() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
@@ -194,8 +187,7 @@ public void testAlternativeRoutesBikeAndCar()
     }
 
     @Test
-    public void testMonacoVia()
-    {
+    public void testMonacoVia() {
         GHResponse rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
                 addPoint(new GHPoint(43.74958, 7.436566)).
@@ -203,7 +195,7 @@ public void testMonacoVia()
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         PathWrapper arsp = rsp.getBest();
-        assertEquals(6875.1, arsp.getDistance(), .1);
+        assertEquals(6875.17, arsp.getDistance(), PRECISION);
         assertEquals(179, arsp.getPoints().getSize());
 
         InstructionList il = arsp.getInstructions();
@@ -245,8 +237,8 @@ public void testMonacoVia()
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         arsp = rsp.getBest();
-        assertEquals(0, arsp.getDistance(), .1);
-        assertEquals(0, arsp.getRouteWeight(), .1);
+        assertEquals(0, arsp.getDistance(), PRECISION);
+        assertEquals(0, arsp.getRouteWeight(), PRECISION);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(1, arsp.getInstructions().size());
         assertEquals("Finish!", arsp.getInstructions().createJson().get(0).get("text"));
@@ -259,8 +251,8 @@ public void testMonacoVia()
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         arsp = rsp.getBest();
-        assertEquals(0, arsp.getDistance(), .1);
-        assertEquals(0, arsp.getRouteWeight(), .1);
+        assertEquals(0, arsp.getDistance(), PRECISION);
+        assertEquals(0, arsp.getRouteWeight(), PRECISION);
         assertEquals(2, arsp.getPoints().getSize());
         assertEquals(2, arsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().createJson().get(0).get("sign"));
@@ -268,8 +260,7 @@ public void testMonacoVia()
     }
 
     @Test
-    public void testMonacoEnforcedDirection()
-    {
+    public void testMonacoEnforcedDirection() {
         GHRequest req = new GHRequest().
                 addPoint(new GHPoint(43.741069, 7.426854), 0.).
                 addPoint(new GHPoint(43.744445, 7.429483), 190.).
@@ -283,8 +274,7 @@ public void testMonacoEnforcedDirection()
     }
 
     @Test
-    public void testMonacoMaxVisitedNodes()
-    {
+    public void testMonacoMaxVisitedNodes() {
         GHPoint from = new GHPoint(43.741069, 7.426854);
         GHPoint to = new GHPoint(43.744445, 7.429483);
         GHRequest req = new GHRequest().
@@ -306,8 +296,7 @@ public void testMonacoMaxVisitedNodes()
     }
 
     @Test
-    public void testMonacoStraightVia()
-    {
+    public void testMonacoStraightVia() {
         GHRequest rq = new GHRequest().
                 addPoint(new GHPoint(43.741069, 7.426854)).
                 addPoint(new GHPoint(43.740371, 7.426946)).
@@ -319,11 +308,20 @@ public void testMonacoStraightVia()
         PathWrapper arsp = rsp.getBest();
         assertEquals(297, arsp.getDistance(), 5.);
         assertEquals(27, arsp.getPoints().getSize());
+
+        // test if start and first point are identical leading to an empty path, #788
+        rq = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.740371, 7.426946)).
+                setVehicle(vehicle).setWeighting("fastest");
+        rq.getHints().put(Routing.PASS_THROUGH, true);
+        rsp = hopper.route(rq);
+        assertEquals(91, rsp.getBest().getDistance(), 5.);
     }
 
     @Test
-    public void testSRTMWithInstructions() throws Exception
-    {
+    public void testSRTMWithInstructions() throws Exception {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(osmFile).
                 setStoreOnFlush(true).
@@ -338,7 +336,7 @@ public void testSRTMWithInstructions() throws Exception
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         PathWrapper arsp = rsp.getBest();
-        assertEquals(1626.8, arsp.getDistance(), .1);
+        assertEquals(1626.81, arsp.getDistance(), PRECISION);
         assertEquals(60, arsp.getPoints().getSize());
         assertTrue(arsp.getPoints().is3D());
 
@@ -377,8 +375,62 @@ public void testSRTMWithInstructions() throws Exception
     }
 
     @Test
-    public void testKremsCyclewayInstructionsWithWayTypeInfo()
-    {
+    public void testSRTMWithoutTunnelInterpolation() throws Exception {
+        GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
+                        .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
+                        .setEncodingManager(new EncodingManager(importVehicles, 8));
+
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+        tmpHopper.importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.74056471749763, 7.4299266210693755,
+                        43.73790260334179, 7.427984089259056).setAlgorithm(ASTAR)
+                                        .setVehicle(vehicle).setWeighting(weightCalcStr));
+        PathWrapper arsp = rsp.getBest();
+        assertEquals(356.79, arsp.getDistance(), PRECISION);
+        PointList pointList = arsp.getPoints();
+        assertEquals(6, pointList.getSize());
+        assertTrue(pointList.is3D());
+
+        assertEquals(17.0, pointList.getEle(0), PRECISION);
+        assertEquals(23.0, pointList.getEle(1), PRECISION);
+        assertEquals(23.0, pointList.getEle(2), PRECISION);
+        assertEquals(41.0, pointList.getEle(3), PRECISION);
+        assertEquals(19.0, pointList.getEle(4), PRECISION);
+        assertEquals(26.5, pointList.getEle(5), PRECISION);
+    }
+
+    @Test
+    public void testSRTMWithTunnelInterpolation() throws Exception {
+        GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
+                        .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
+                        .setEncodingManager(new EncodingManager(genericImportVehicles, 8));
+
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+        tmpHopper.importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.74056471749763, 7.4299266210693755,
+                        43.73790260334179, 7.427984089259056).setAlgorithm(ASTAR)
+                                        .setVehicle(vehicle).setWeighting(weightCalcStr));
+        PathWrapper arsp = rsp.getBest();
+        // Without
+        // interpolation:
+        // 356.79372559007476
+        assertEquals(351.39, arsp.getDistance(), PRECISION);
+        PointList pointList = arsp.getPoints();
+        assertEquals(6, pointList.getSize());
+        assertTrue(pointList.is3D());
+
+        assertEquals(17, pointList.getEle(0), PRECISION);
+        assertEquals(19.04, pointList.getEle(1), PRECISION);
+        assertEquals(21.67, pointList.getEle(2), PRECISION);
+        assertEquals(25.03, pointList.getEle(3), PRECISION);
+        assertEquals(28.65, pointList.getEle(4), PRECISION);
+        assertEquals(31.32, pointList.getEle(5), PRECISION);
+    }
+
+    @Test
+    public void testKremsCyclewayInstructionsWithWayTypeInfo() {
         String tmpOsmFile = DIR + "/krems.osm.gz";
         String tmpVehicle = "bike";
         String tmpImportVehicles = "car,bike";
@@ -396,7 +448,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo()
                 setAlgorithm(ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
         PathWrapper arsp = rsp.getBest();
-        assertEquals(6932.24, arsp.getDistance(), .1);
+        assertEquals(6932.24, arsp.getDistance(), PRECISION);
         assertEquals(110, arsp.getPoints().getSize());
 
         InstructionList il = arsp.getInstructions();
@@ -423,8 +475,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo()
     }
 
     @Test
-    public void testRoundaboutInstructionsWithCH()
-    {
+    public void testRoundaboutInstructionsWithCH() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
         String tmpVehicle = "car";
         String tmpImportVehicles = "car,bike";
@@ -432,7 +483,7 @@ public void testRoundaboutInstructionsWithCH()
 
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(tmpOsmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(tmpImportVehicles)).
                 importOrLoad();
@@ -464,12 +515,11 @@ public void testRoundaboutInstructionsWithCH()
     }
 
     @Test
-    public void testMultipleVehiclesWithCH()
-    {
+    public void testMultipleVehiclesWithCH() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(tmpOsmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager("bike,car")).
                 importOrLoad();
@@ -481,7 +531,7 @@ public void testMultipleVehiclesWithCH()
         // new instance, try different order, resulting only in different default vehicle
         tmpHopper = new GraphHopperOSM().
                 setOSMFile(tmpOsmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager("car,bike")).
                 importOrLoad();
@@ -490,8 +540,7 @@ public void testMultipleVehiclesWithCH()
         tmpHopper.close();
     }
 
-    private void checkMultiVehiclesWithCH( GraphHopper tmpHopper )
-    {
+    private void checkMultiVehiclesWithCH(GraphHopper tmpHopper) {
         String str = tmpHopper.getEncodingManager().toString();
         GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
                 .setVehicle("car"));
@@ -521,8 +570,7 @@ private void checkMultiVehiclesWithCH( GraphHopper tmpHopper )
     }
 
     @Test
-    public void testIfCHIsUsed() throws Exception
-    {
+    public void testIfCHIsUsed() throws Exception {
         // route directly after import
         executeCHFootRoute();
 
@@ -530,14 +578,13 @@ public void testIfCHIsUsed() throws Exception
         executeCHFootRoute();
     }
 
-    private void executeCHFootRoute()
-    {
+    private void executeCHFootRoute() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
         String tmpImportVehicles = "foot";
 
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(tmpOsmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(tmpImportVehicles));
         tmpHopper.getCHFactoryDecorator().setWeightingsAsStrings(weightCalcStr);
@@ -552,15 +599,14 @@ private void executeCHFootRoute()
         long sum = rsp.getHints().getLong("visited_nodes.sum", 0);
         assertNotEquals(sum, 0);
         assertTrue("Too many nodes visited " + sum, sum < 120);
-        assertEquals(3437.6, bestPath.getDistance(), .1);
+        assertEquals(3437.59, bestPath.getDistance(), PRECISION);
         assertEquals(89, bestPath.getPoints().getSize());
 
         tmpHopper.close();
     }
 
     @Test
-    public void testRoundTour()
-    {
+    public void testRoundTour() {
         GHRequest rq = new GHRequest().
                 addPoint(new GHPoint(43.741069, 7.426854)).
                 setVehicle(vehicle).setWeighting("fastest").
@@ -573,19 +619,18 @@ public void testRoundTour()
 
         assertEquals(1, rsp.getAll().size());
         PathWrapper pw = rsp.getBest();
-        assertEquals(1.5, rsp.getBest().getDistance() / 1000f, 0.1);
+        assertEquals(1.45, rsp.getBest().getDistance() / 1000f, PRECISION);
         assertEquals(17, rsp.getBest().getTime() / 1000f / 60, 1);
         assertEquals(65, pw.getPoints().size());
     }
 
     @Test
-    public void testFlexMode_631()
-    {
+    public void testFlexMode_631() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
 
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(tmpOsmFile).
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager("car"));
 
@@ -617,12 +662,11 @@ public void testFlexMode_631()
     }
 
     @Test
-    public void testTurnCostsOnOff()
-    {
+    public void testTurnCostsOnOff() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(DIR + "/moscow.osm.gz").
                 setStoreOnFlush(true).
-                setCHEnabled(false).                
+                setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager("car|turn_costs=true"));
         tmpHopper.importOrLoad();
@@ -644,11 +688,10 @@ public void testTurnCostsOnOff()
     }
 
     @Test
-    public void testCHAndTurnCostsWithFlexmode()
-    {
+    public void testCHAndTurnCostsWithFlexmode() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(DIR + "/moscow.osm.gz").
-                setStoreOnFlush(true).                
+                setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager("car|turn_costs=true"));
         tmpHopper.getCHFactoryDecorator().setDisablingAllowed(true);
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index 436c340a9e..ae6d133cb2 100755
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -22,16 +22,17 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
-import static com.graphhopper.util.Parameters.Algorithms.*;
 import com.graphhopper.util.Parameters.Routing;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
@@ -49,35 +50,33 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA;
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class GraphHopperOSMTest
-{
+public class GraphHopperOSMTest {
     private static final String ghLoc = "./target/tmp/ghosm";
     private static final String testOsm = "./src/test/resources/com/graphhopper/reader/osm/test-osm.xml";
     private static final String testOsm3 = "./src/test/resources/com/graphhopper/reader/osm/test-osm3.xml";
     private GraphHopper instance;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         Helper.removeDir(new File(ghLoc));
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         if (instance != null)
             instance.close();
         Helper.removeDir(new File(ghLoc));
     }
 
     @Test
-    public void testLoadOSM()
-    {
+    public void testLoadOSM() {
         GraphHopper closableInstance = new GraphHopperOSM().
                 setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car")).
@@ -99,28 +98,23 @@ public void testLoadOSM()
         assertEquals(3, rsp.getBest().getPoints().getSize());
 
         closableInstance.close();
-        try
-        {
+        try {
             rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertEquals("You need to create a new GraphHopper instance as it is already closed", ex.getMessage());
         }
 
-        try
-        {
+        try {
             closableInstance.getLocationIndex().findClosest(51.2492152, 9.4317166, EdgeFilter.ALL_EDGES);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertEquals("You need to create a new LocationIndex instance as it is already closed", ex.getMessage());
         }
     }
 
     @Test
-    public void testLoadOSMNoCH()
-    {
+    public void testLoadOSMNoCH() {
         GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
                 setEncodingManager(new EncodingManager("car")).
                 setGraphHopperLocation(ghLoc).
@@ -153,8 +147,7 @@ public void testLoadOSMNoCH()
     }
 
     @Test
-    public void testLoadingWithDifferentCHConfig_issue471()
-    {
+    public void testLoadingWithDifferentCHConfig_issue471() {
         // with CH should not be loadable without CH configured
         GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car")).
@@ -168,12 +161,10 @@ public void testLoadingWithDifferentCHConfig_issue471()
 
         gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
                 setEncodingManager(new EncodingManager("car"));
-        try
-        {
+        try {
             gh.load(ghLoc);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
         }
 
@@ -192,19 +183,16 @@ public void testLoadingWithDifferentCHConfig_issue471()
 
         gh = new GraphHopperOSM().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car"));
-        try
-        {
+        try {
             gh.load(ghLoc);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
         }
     }
 
     @Test
-    public void testAllowMultipleReadingInstances()
-    {
+    public void testAllowMultipleReadingInstances() {
         GraphHopper instance1 = new GraphHopperOSM().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car")).
                 setGraphHopperLocation(ghLoc).
@@ -227,21 +215,17 @@ public void testAllowMultipleReadingInstances()
     }
 
     @Test
-    public void testDoNotAllowWritingAndLoadingAtTheSameTime() throws Exception
-    {
+    public void testDoNotAllowWritingAndLoadingAtTheSameTime() throws Exception {
         final CountDownLatch latch1 = new CountDownLatch(1);
         final CountDownLatch latch2 = new CountDownLatch(1);
-        final GraphHopper instance1 = new GraphHopperOSM()
-        {
+        final GraphHopper instance1 = new GraphHopperOSM() {
             @Override
-            protected DataReader importData() throws IOException
-            {
-                try
-                {
+            protected DataReader importData() throws IOException {
+                try {
                     latch2.countDown();
                     latch1.await(3, TimeUnit.SECONDS);
-                } catch (InterruptedException ex)
-                {
+                } catch (InterruptedException ex) {
+                    throw new RuntimeException(ex);
                 }
                 return super.importData();
             }
@@ -250,16 +234,12 @@ protected DataReader importData() throws IOException
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         final AtomicReference<Exception> ar = new AtomicReference<Exception>();
-        Thread thread = new Thread()
-        {
+        Thread thread = new Thread() {
             @Override
-            public void run()
-            {
-                try
-                {
+            public void run() {
+                try {
                     instance1.importOrLoad();
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     ar.set(ex);
                 }
             }
@@ -269,19 +249,16 @@ public void run()
         GraphHopper instance2 = new GraphHopperOSM().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car")).
                 setDataReaderFile(testOsm);
-        try
-        {
+        try {
             // let thread reach the CountDownLatch
             latch2.await(3, TimeUnit.SECONDS);
             // now importOrLoad should have create a lock which this load call does not like
             instance2.load(ghLoc);
             assertTrue(false);
-        } catch (RuntimeException ex)
-        {
+        } catch (RuntimeException ex) {
             assertNotNull(ex);
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("To avoid reading partial data"));
-        } finally
-        {
+        } finally {
             instance2.close();
             latch1.countDown();
             // make sure the import process wasn't interrupted and no other error happened
@@ -294,8 +271,7 @@ public void run()
     }
 
     @Test
-    public void testPrepare()
-    {
+    public void testPrepare() {
         instance = new GraphHopperOSM().
                 setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("car")).
@@ -311,8 +287,7 @@ public void testPrepare()
     }
 
     @Test
-    public void testSortedGraph_noCH()
-    {
+    public void testSortedGraph_noCH() {
         instance = new GraphHopperOSM().setStoreOnFlush(false).
                 setSortGraph(true).
                 setEncodingManager(new EncodingManager("car")).setCHEnabled(false).
@@ -339,8 +314,7 @@ public void testSortedGraph_noCH()
     }
 
     @Test
-    public void testFootAndCar()
-    {
+    public void testFootAndCar() {
         // now all ways are imported
         instance = new GraphHopperOSM().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("car,foot")).setCHEnabled(false).
@@ -385,8 +359,7 @@ public void testFootAndCar()
     }
 
     @Test
-    public void testFailsForWrongConfig() throws IOException
-    {
+    public void testFailsForWrongConfig() throws IOException {
         instance = new GraphHopperOSM().init(
                 new CmdArgs().
                 put("datareader.file", testOsm3).
@@ -399,8 +372,7 @@ public void testFailsForWrongConfig() throws IOException
         instance.close();
 
         // different config (flagEncoder list)
-        try
-        {
+        try {
             GraphHopper tmpGH = new GraphHopperOSM().init(
                     new CmdArgs().
                     put("datareader.file", testOsm3).
@@ -410,8 +382,7 @@ public void testFailsForWrongConfig() throws IOException
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
 
@@ -424,18 +395,15 @@ public void testFailsForWrongConfig() throws IOException
                 put("graph.bytes_for_flags", 8).
                 put("prepare.ch.weightings", "no")).
                 setDataReaderFile(testOsm3);
-        try
-        {
+        try {
             instance.load(ghLoc);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.bytes_for_flags (8) is not equal to loaded 4"));
         }
 
         // different order is no longer okay, see #350
-        try
-        {
+        try {
             GraphHopper tmpGH = new GraphHopperOSM().init(new CmdArgs().
                     put("datareader.file", testOsm3).
                     put("datareader.dataaccess", "RAM").
@@ -444,34 +412,29 @@ public void testFailsForWrongConfig() throws IOException
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
     }
 
     @Test
-    public void testNoNPE_ifLoadNotSuccessful()
-    {
+    public void testNoNPE_ifLoadNotSuccessful() {
         instance = new GraphHopperOSM().
                 setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car"));
-        try
-        {
+        try {
             // loading from empty directory
             new File(ghLoc).mkdirs();
             assertFalse(instance.load(ghLoc));
             instance.route(new GHRequest(10, 40, 12, 32));
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
             assertEquals("Do a successful call to load or importOrLoad before routing", ex.getMessage());
         }
     }
 
     @Test
-    public void testDoesNotCreateEmptyFolderIfLoadingFromNonExistingPath()
-    {
+    public void testDoesNotCreateEmptyFolderIfLoadingFromNonExistingPath() {
         instance = new GraphHopperOSM().
                 setEncodingManager(new EncodingManager("car"));
 
@@ -480,37 +443,30 @@ public void testDoesNotCreateEmptyFolderIfLoadingFromNonExistingPath()
     }
 
     @Test
-    public void testFailsForMissingParameters() throws IOException
-    {
-        class GHTmp extends GraphHopperOSM
-        {
+    public void testFailsForMissingParameters() throws IOException {
+        class GHTmp extends GraphHopperOSM {
             @Override
-            public DataReader importData() throws IOException
-            {
+            public DataReader importData() throws IOException {
                 return super.importData();
             }
         }
 
         // missing load of graph
         GHTmp tmp = new GHTmp();
-        try
-        {
+        try {
             tmp.setDataReaderFile(testOsm);
             tmp.importData();
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
             assertEquals("Load graph before importing OSM data", ex.getMessage());
         }
 
         // missing graph location
         instance = new GraphHopperOSM();
-        try
-        {
+        try {
             instance.importOrLoad();
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
             assertEquals("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before", ex.getMessage());
         }
 
@@ -519,12 +475,10 @@ public DataReader importData() throws IOException
                 setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("car")).
                 setGraphHopperLocation(ghLoc);
-        try
-        {
+        try {
             instance.importOrLoad();
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
         }
@@ -534,12 +488,10 @@ public DataReader importData() throws IOException
                 setStoreOnFlush(true).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm3);
-        try
-        {
+        try {
             instance.importOrLoad();
             assertTrue(false);
-        } catch (IllegalStateException ex)
-        {
+        } catch (IllegalStateException ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Cannot load properties to fetch EncodingManager"));
         }
 
@@ -548,20 +500,17 @@ public DataReader importData() throws IOException
                 setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("car")).
                 setGraphHopperLocation(ghLoc);
-        try
-        {
+        try {
             instance.importOrLoad();
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
         }
     }
 
     @Test
-    public void testFootOnly()
-    {
+    public void testFootOnly() {
         // now only footable ways are imported => no A D C and B D E => the other both ways have pillar nodes!
         instance = new GraphHopperOSM().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("foot")).
@@ -573,15 +522,15 @@ public void testFootOnly()
         assertEquals(2, instance.getGraphHopperStorage().getAllEdges().getMaxId());
 
         // A to E only for foot
-        GHResponse grsp = instance.route(new GHRequest(11.1, 50, 11.2, 52.01).setVehicle("foot"));
+        GHResponse grsp = instance.route(new GHRequest(11.1, 50, 11.19, 52).setVehicle("foot"));
         assertFalse(grsp.hasErrors());
         PathWrapper rsp = grsp.getBest();
-        assertEquals(Helper.createPointList(11.1, 50, 10, 51, 11.2, 52), rsp.getPoints());
+        // the last points snaps to the edge
+        assertEquals(Helper.createPointList(11.1, 50, 10, 51, 11.194015, 51.995013), rsp.getPoints());
     }
 
     @Test
-    public void testVia()
-    {
+    public void testVia() {
         instance = new GraphHopperOSM().setStoreOnFlush(true).
                 init(new CmdArgs().
                         put("datareader.file", testOsm3).
@@ -611,8 +560,7 @@ public void testVia()
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement1()
-    {
+    public void testGetPathsDirectionEnforcement1() {
         // Test enforce start direction
         // Note: This Test does not pass for CH enabled    
         instance = createSquareGraphInstance(false);
@@ -626,15 +574,11 @@ public void testGetPathsDirectionEnforcement1()
         GHResponse response = new GHResponse();
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            9, 5, 8, 3, 10
-        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{9, 5, 8, 3, 10}, paths.get(0).calcNodes().toArray());
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement2()
-    {
+    public void testGetPathsDirectionEnforcement2() {
         // Test enforce south start direction and east end direction
         instance = createSquareGraphInstance(false);
 
@@ -647,25 +591,18 @@ public void testGetPathsDirectionEnforcement2()
         GHResponse response = new GHResponse();
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            9, 5, 8, 1, 2, 10
-        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{9, 5, 8, 1, 2, 10}, paths.get(0).calcNodes().toArray());
 
         // Test uni-directional case
         req.setAlgorithm(DIJKSTRA);
         response = new GHResponse();
         paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            9, 5, 8, 1, 2, 10
-        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{9, 5, 8, 1, 2, 10}, paths.get(0).calcNodes().toArray());
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement3()
-    {
+    public void testGetPathsDirectionEnforcement3() {
         instance = createSquareGraphInstance(false);
 
         // Start in middle of edge 4-5 
@@ -679,15 +616,11 @@ public void testGetPathsDirectionEnforcement3()
         GHResponse response = new GHResponse();
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            10, 5, 6, 7, 11
-        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{10, 5, 6, 7, 11}, paths.get(0).calcNodes().toArray());
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement4()
-    {
+    public void testGetPathsDirectionEnforcement4() {
         // Test straight via routing
         instance = createSquareGraphInstance(false);
 
@@ -703,19 +636,12 @@ public void testGetPathsDirectionEnforcement4()
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
         assertEquals(1, response.getAll().size());
-        assertArrayEquals(new int[]
-        {
-            10, 4, 3, 11
-        }, paths.get(0).calcNodes().toArray());
-        assertArrayEquals(new int[]
-        {
-            11, 8, 1, 2, 9
-        }, paths.get(1).calcNodes().toArray());
+        assertArrayEquals(new int[]{10, 4, 3, 11}, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{11, 8, 1, 2, 9}, paths.get(1).calcNodes().toArray());
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement5()
-    {
+    public void testGetPathsDirectionEnforcement5() {
         // Test independence of previous enforcement for subsequent pathes
         instance = createSquareGraphInstance(false);
 
@@ -730,19 +656,12 @@ public void testGetPathsDirectionEnforcement5()
         GHResponse response = new GHResponse();
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            10, 4, 3, 8, 7, 9
-        }, paths.get(0).calcNodes().toArray());
-        assertArrayEquals(new int[]
-        {
-            9, 6, 5, 10, 4, 3, 11
-        }, paths.get(1).calcNodes().toArray());
+        assertArrayEquals(new int[]{10, 4, 3, 8, 7, 9}, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{9, 6, 5, 10, 4, 3, 11}, paths.get(1).calcNodes().toArray());
     }
 
     @Test
-    public void testGetPathsDirectionEnforcement6()
-    {
+    public void testGetPathsDirectionEnforcement6() {
         // Test if query results at tower nodes are ignored
         instance = createSquareGraphInstance(false);
 
@@ -755,18 +674,11 @@ public void testGetPathsDirectionEnforcement6()
         GHResponse response = new GHResponse();
         List<Path> paths = instance.calcPaths(req, response);
         assertFalse(response.hasErrors());
-        assertArrayEquals(new int[]
-        {
-            0, 1, 2
-        }, paths.get(0).calcNodes().toArray());
-        assertArrayEquals(new int[]
-        {
-            2, 3, 4
-        }, paths.get(1).calcNodes().toArray());
+        assertArrayEquals(new int[]{0, 1, 2}, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]{2, 3, 4}, paths.get(1).calcNodes().toArray());
     }
 
-    private GraphHopper createSquareGraphInstance( boolean withCH )
-    {
+    private GraphHopper createSquareGraphInstance(boolean withCH) {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
         EncodingManager encodingManager = new EncodingManager(carEncoder);
         Weighting weighting = new FastestWeighting(carEncoder);
@@ -815,8 +727,7 @@ private GraphHopper createSquareGraphInstance( boolean withCH )
     }
 
     @Test
-    public void testCustomFactoryForNoneCH()
-    {
+    public void testCustomFactoryForNoneCH() {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
         EncodingManager em = new EncodingManager(carEncoder);
         // Weighting weighting = new FastestWeighting(carEncoder);
@@ -825,17 +736,14 @@ public void testCustomFactoryForNoneCH()
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         final RoutingAlgorithmFactory af = new RoutingAlgorithmFactorySimple();
-        instance.addAlgorithmFactoryDecorator(new RoutingAlgorithmFactoryDecorator()
-        {
+        instance.addAlgorithmFactoryDecorator(new RoutingAlgorithmFactoryDecorator() {
             @Override
-            public RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFactory algoFactory, HintsMap map )
-            {
+            public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory algoFactory, HintsMap map) {
                 return af;
             }
 
             @Override
-            public boolean isEnabled()
-            {
+            public boolean isEnabled() {
                 return true;
             }
         });
@@ -845,16 +753,12 @@ public boolean isEnabled()
 
         // test that hints are passed to algorithm opts
         final AtomicInteger cnt = new AtomicInteger(0);
-        instance.addAlgorithmFactoryDecorator(new RoutingAlgorithmFactoryDecorator()
-        {
+        instance.addAlgorithmFactoryDecorator(new RoutingAlgorithmFactoryDecorator() {
             @Override
-            public RoutingAlgorithmFactory getDecoratedAlgorithmFactory( RoutingAlgorithmFactory algoFactory, HintsMap map )
-            {
-                return new RoutingAlgorithmFactorySimple()
-                {
+            public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory algoFactory, HintsMap map) {
+                return new RoutingAlgorithmFactorySimple() {
                     @Override
-                    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-                    {
+                    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
                         cnt.addAndGet(1);
                         assertFalse(opts.getHints().getBool("test", true));
                         return super.createAlgo(g, opts);
@@ -863,8 +767,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             }
 
             @Override
-            public boolean isEnabled()
-            {
+            public boolean isEnabled() {
                 return true;
             }
         });
@@ -875,12 +778,10 @@ public boolean isEnabled()
     }
 
     @Test
-    public void testMultipleCHPreparationsInParallel()
-    {
+    public void testMultipleCHPreparationsInParallel() {
         HashMap<String, Integer> shortcutCountMap = new HashMap<String, Integer>();
         // try all parallelization modes        
-        for (int threadCount = 1; threadCount < 6; threadCount++)
-        {
+        for (int threadCount = 1; threadCount < 6; threadCount++) {
             EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
                     new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()),
                     8);
@@ -894,8 +795,7 @@ public void testMultipleCHPreparationsInParallel()
             tmpGH.importOrLoad();
 
             assertEquals(5, tmpGH.getCHFactoryDecorator().getPreparations().size());
-            for (RoutingAlgorithmFactory raf : tmpGH.getCHFactoryDecorator().getPreparations())
-            {
+            for (RoutingAlgorithmFactory raf : tmpGH.getCHFactoryDecorator().getPreparations()) {
                 PrepareContractionHierarchies pch = (PrepareContractionHierarchies) raf;
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
@@ -918,39 +818,22 @@ public void testMultipleCHPreparationsInParallel()
         }
     }
 
-    class TestEncoder extends CarFlagEncoder
-    {
-        private final String name;
-
-        public TestEncoder( String name )
-        {
-            this.name = name;
-        }
-
-        @Override
-        public String toString()
-        {
-            return name;
-        }
-    }
-
     @Test
-    public void testGetWeightingForCH()
-    {
+    public void testGetWeightingForCH() {
         TestEncoder truck = new TestEncoder("truck");
         TestEncoder simpleTruck = new TestEncoder("simple_truck");
 
         // use simple truck first
         EncodingManager em = new EncodingManager(simpleTruck, truck);
         CHAlgoFactoryDecorator decorator = new CHAlgoFactoryDecorator();
-        Weighting fwSimpleT = new FastestWeighting(simpleTruck);
-        Weighting fwT = new FastestWeighting(truck);
+        Weighting fwSimpleTruck = new FastestWeighting(simpleTruck);
+        Weighting fwTruck = new FastestWeighting(truck);
         RAMDirectory ramDir = new RAMDirectory();
-        GraphHopperStorage storage = new GraphHopperStorage(Arrays.asList(fwSimpleT, fwT), ramDir, em, false, new GraphExtension.NoOpExtension());
-        decorator.addWeighting(fwSimpleT);
-        decorator.addWeighting(fwT);
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleT), simpleTruck, fwSimpleT, TraversalMode.NODE_BASED));
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwT), truck, fwT, TraversalMode.NODE_BASED));
+        GraphHopperStorage storage = new GraphHopperStorage(Arrays.asList(fwSimpleTruck, fwTruck), ramDir, em, false, new GraphExtension.NoOpExtension());
+        decorator.addWeighting(fwSimpleTruck);
+        decorator.addWeighting(fwTruck);
+        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
+        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwTruck), fwTruck, TraversalMode.NODE_BASED));
 
         HintsMap wMap = new HintsMap("fastest");
         wMap.put("vehicle", "truck");
@@ -959,20 +842,17 @@ public void testGetWeightingForCH()
         assertEquals("fastest|simple_truck", ((PrepareContractionHierarchies) decorator.getDecoratedAlgorithmFactory(null, wMap)).getWeighting().toString());
 
         // make sure weighting cannot be mixed
-        decorator.addWeighting(fwT);
-        decorator.addWeighting(fwSimpleT);
-        try
-        {
-            decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleT), simpleTruck, fwSimpleT, TraversalMode.NODE_BASED));
+        decorator.addWeighting(fwTruck);
+        decorator.addWeighting(fwSimpleTruck);
+        try {
+            decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
             assertTrue(false);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
         }
     }
 
     @Test
-    public void testGetMultipleWeightingsForCH()
-    {
+    public void testGetMultipleWeightingsForCH() {
         EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder()), 8);
 
         GraphHopper tmpGH = new GraphHopperOSM().
@@ -982,4 +862,17 @@ public void testGetMultipleWeightingsForCH()
 
         assertEquals(2, tmpGH.getCHFactoryDecorator().getWeightingsAsStrings().size());
     }
+
+    class TestEncoder extends CarFlagEncoder {
+        private final String name;
+
+        public TestEncoder(String name) {
+            this.name = name;
+        }
+
+        @Override
+        public String toString() {
+            return name;
+        }
+    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index f8b1bb5ba1..1d4b42585a 100755
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -17,53 +17,42 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderRelation;
-import static org.junit.Assert.*;
-
-import gnu.trove.list.TLongList;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URISyntaxException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.GraphHopper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperIT;
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.ReaderNode;
+import com.graphhopper.reader.ReaderRelation;
+import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.list.TLongList;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
 import java.util.*;
 
+import static org.junit.Assert.*;
+
 /**
  * Tests the OSMReader with the normal helper initialized.
  * <p>
+ *
  * @author Peter Karich
  */
-public class OSMReaderTest
-{
+public class OSMReaderTest {
     private final String file1 = "test-osm.xml";
     private final String file2 = "test-osm2.xml";
     private final String file3 = "test-osm3.xml";
@@ -83,90 +72,26 @@
     private EdgeExplorer carAllExplorer;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         new File(dir).mkdirs();
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.removeDir(new File(dir));
     }
 
-    GraphHopperStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
-    {
+    GraphHopperStorage newGraph(String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport) {
         return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager, is3D,
                 turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoOpExtension());
     }
 
-    class GraphHopperTest extends GraphHopperOSM
-    {
-        public GraphHopperTest( String osmFile )
-        {
-            this(osmFile, false);
-        }
-
-        public GraphHopperTest( String osmFile, boolean turnCosts )
-        {
-            setStoreOnFlush(false);
-            setOSMFile(osmFile);
-            setGraphHopperLocation(dir);
-            setEncodingManager(new EncodingManager("car,foot"));
-            setCHEnabled(false);
-
-            if (turnCosts)
-            {
-                carEncoder = new CarFlagEncoder(5, 5, 1);
-                bikeEncoder = new BikeFlagEncoder(4, 2, 1);
-            } else
-            {
-                carEncoder = new CarFlagEncoder();
-                bikeEncoder = new BikeFlagEncoder();
-            }
-
-            footEncoder = new FootFlagEncoder();
-
-            setEncodingManager(new EncodingManager(footEncoder, carEncoder, bikeEncoder));
-        }
-
-        @Override
-        protected DataReader createReader( GraphHopperStorage tmpGraph )
-        {
-            return initDataReader(new OSMReader(tmpGraph));
-        }
-
-        @Override
-        protected DataReader importData() throws IOException
-        {
-            getEncodingManager().setPreferredLanguage(getPreferredLanguage());
-            GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
-                    getEncodingManager().needsTurnCostsSupport());
-            setGraphHopperStorage(tmpGraph);
-
-            DataReader osmReader = createReader(tmpGraph);
-            try
-            {
-                osmReader.setFile(new File(getClass().getResource(getOSMFile()).toURI()));
-            } catch (URISyntaxException e)
-            {
-                throw new RuntimeException(e);
-            }
-            osmReader.readGraph();
-            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
-            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
-            return osmReader;
-        }
-    }
-
-    InputStream getResource( String file )
-    {
+    InputStream getResource(String file) {
         return getClass().getResourceAsStream(file);
     }
 
     @Test
-    public void testMain()
-    {
+    public void testMain() {
         GraphHopper hopper = new GraphHopperTest(file1).importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
 
@@ -222,14 +147,12 @@ public void testMain()
         assertEquals(9, na.getLongitude(findID(hopper.getLocationIndex(), 51.25, 9.43)), 1e-3);
     }
 
-    protected int findID( LocationIndex index, double lat, double lon )
-    {
+    protected int findID(LocationIndex index, double lat, double lon) {
         return index.findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
     }
 
     @Test
-    public void testSort()
-    {
+    public void testSort() {
         GraphHopper hopper = new GraphHopperTest(file1).setSortGraph(true).importOrLoad();
         NodeAccess na = hopper.getGraphHopperStorage().getNodeAccess();
         assertEquals(10, na.getLongitude(findID(hopper.getLocationIndex(), 49, 10)), 1e-3);
@@ -237,18 +160,13 @@ public void testSort()
     }
 
     @Test
-    public void testWithBounds()
-    {
-        GraphHopper hopper = new GraphHopperTest(file1)
-        {
+    public void testWithBounds() {
+        GraphHopper hopper = new GraphHopperTest(file1) {
             @Override
-            protected DataReader createReader( GraphHopperStorage tmpGraph )
-            {
-                return new OSMReader(tmpGraph)
-                {
+            protected DataReader createReader(GraphHopperStorage tmpGraph) {
+                return new OSMReader(tmpGraph) {
                     @Override
-                    public boolean isInBounds( ReaderNode node )
-                    {
+                    public boolean isInBounds(ReaderNode node) {
                         return node.getLat() > 49 && node.getLon() > 8;
                     }
                 }.setEncodingManager(getEncodingManager());
@@ -289,8 +207,7 @@ public boolean isInBounds( ReaderNode node )
     }
 
     @Test
-    public void testOneWay()
-    {
+    public void testOneWay() {
         GraphHopper hopper = new GraphHopperTest(file2).importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
 
@@ -339,13 +256,10 @@ public void testOneWay()
     }
 
     @Test
-    public void testFerry()
-    {
-        GraphHopper hopper = new GraphHopperTest(file2)
-        {
+    public void testFerry() {
+        GraphHopper hopper = new GraphHopperTest(file2) {
             @Override
-            public void cleanUp()
-            {
+            public void cleanUp() {
             }
         }.importOrLoad();
         Graph graph = hopper.getGraphHopperStorage();
@@ -360,21 +274,18 @@ public void cleanUp()
         iter.next();
         assertEquals(5, carEncoder.getSpeed(iter.getFlags()), 1e-1);
 
-        // duration 01:10 is given => more precise speed calculation! 
-        // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h => / 1.4 => 71km/h        
+        // duration 01:10 is given => more precise speed calculation!
+        // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h => / 1.4 => 71km/h
         iter = carOutExplorer.setBaseNode(n40);
         iter.next();
         assertEquals(70, carEncoder.getSpeed(iter.getFlags()), 1e-1);
     }
 
     @Test
-    public void testMaxSpeed()
-    {
-        GraphHopper hopper = new GraphHopperTest(file2)
-        {
+    public void testMaxSpeed() {
+        GraphHopper hopper = new GraphHopperTest(file2) {
             @Override
-            public void cleanUp()
-            {
+            public void cleanUp() {
             }
         }.importOrLoad();
         Graph graph = hopper.getGraphHopperStorage();
@@ -386,8 +297,7 @@ public void cleanUp()
     }
 
     @Test
-    public void testWayReferencesNotExistingAdjNode()
-    {
+    public void testWayReferencesNotExistingAdjNode() {
         GraphHopper hopper = new GraphHopperTest(file4).importOrLoad();
         Graph graph = hopper.getGraphHopperStorage();
 
@@ -399,8 +309,7 @@ public void testWayReferencesNotExistingAdjNode()
     }
 
     @Test
-    public void testFoot()
-    {
+    public void testFoot() {
         GraphHopper hopper = new GraphHopperTest(file3).importOrLoad();
         Graph graph = hopper.getGraphHopperStorage();
 
@@ -422,8 +331,7 @@ public void testFoot()
     }
 
     @Test
-    public void testNegativeIds()
-    {
+    public void testNegativeIds() {
         GraphHopper hopper = new GraphHopperTest(fileNegIds).importOrLoad();
         Graph graph = hopper.getGraphHopperStorage();
         assertEquals(4, graph.getNodes());
@@ -447,8 +355,7 @@ public void testNegativeIds()
     }
 
     @Test
-    public void testBarriers()
-    {
+    public void testBarriers() {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).
                 setMinNetworkSize(0, 0).
                 importOrLoad();
@@ -485,8 +392,7 @@ public void testBarriers()
     }
 
     @Test
-    public void testBarriersOnTowerNodes()
-    {
+    public void testBarriersOnTowerNodes() {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).
                 setMinNetworkSize(0, 0).
                 importOrLoad();
@@ -509,8 +415,7 @@ public void testBarriersOnTowerNodes()
     }
 
     @Test
-    public void testRelation()
-    {
+    public void testRelation() {
         EncodingManager manager = new EncodingManager("bike");
         GraphHopperStorage ghStorage = new GraphHopperStorage(new RAMDirectory(), manager, false, new GraphExtension.NoOpExtension());
         OSMReader reader = new OSMReader(ghStorage).
@@ -540,8 +445,7 @@ public void testRelation()
     }
 
     @Test
-    public void testTurnRestrictions()
-    {
+    public void testTurnRestrictions() {
         GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
                 importOrLoad();
 
@@ -585,7 +489,7 @@ public void testTurnRestrictions()
         int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
         int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
 
-        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
+        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted
         long costsFlags = tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6);
         assertFalse(carEncoder.isTurnRestricted(costsFlags));
         assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
@@ -608,23 +512,19 @@ public void testTurnRestrictions()
     }
 
     @Test
-    public void testEstimatedCenter()
-    {
-        final CarFlagEncoder encoder = new CarFlagEncoder()
-        {
+    public void testEstimatedCenter() {
+        final CarFlagEncoder encoder = new CarFlagEncoder() {
             private EncodedValue objectEncoder;
 
             @Override
-            public int defineNodeBits( int index, int shift )
-            {
+            public int defineNodeBits(int index, int shift) {
                 shift = super.defineNodeBits(index, shift);
                 objectEncoder = new EncodedValue("oEnc", shift, 2, 1, 0, 3, true);
                 return shift + 2;
             }
 
             @Override
-            public long handleNodeTags( ReaderNode node )
-            {
+            public long handleNodeTags(ReaderNode node) {
                 if (node.hasTag("test", "now"))
                     return -objectEncoder.setValue(0, 1);
                 return 0;
@@ -640,24 +540,20 @@ public long handleNodeTags( ReaderNode node )
         lonMap.put(1, 1.0d);
         lonMap.put(2, 1.0d);
 
-        OSMReader osmreader = new OSMReader(ghStorage)
-        {
+        OSMReader osmreader = new OSMReader(ghStorage) {
             // mock data access
             @Override
-            double getTmpLatitude( int id )
-            {
+            double getTmpLatitude(int id) {
                 return latMap.get(id);
             }
 
             @Override
-            double getTmpLongitude( int id )
-            {
+            double getTmpLongitude(int id) {
                 return lonMap.get(id);
             }
 
             @Override
-            Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
-            {
+            Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long wayFlags, long osmId) {
                 return Collections.emptyList();
             }
         };
@@ -683,18 +579,13 @@ public long handleNodeTags( ReaderNode node )
     }
 
     @Test
-    public void testReadEleFromCustomOSM()
-    {
-        GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
-        {
+    public void testReadEleFromCustomOSM() {
+        GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml") {
             @Override
-            protected DataReader createReader( GraphHopperStorage tmpGraph )
-            {
-                return initDataReader(new OSMReader(tmpGraph)
-                {
+            protected DataReader createReader(GraphHopperStorage tmpGraph) {
+                return initDataReader(new OSMReader(tmpGraph) {
                     @Override
-                    protected double getElevation( ReaderNode node )
-                    {
+                    protected double getElevation(ReaderNode node) {
                         return node.getEle();
                     }
                 });
@@ -710,8 +601,7 @@ protected double getElevation( ReaderNode node )
     }
 
     @Test
-    public void testReadEleFromDataProvider()
-    {
+    public void testReadEleFromDataProvider() {
         GraphHopper hopper = new GraphHopperTest("test-osm5.xml");
         // get N10E046.hgt.zip
         ElevationProvider provider = new SRTMProvider();
@@ -737,8 +627,7 @@ public void testReadEleFromDataProvider()
      * Tests the combination of different turn cost flags by different encoders.
      */
     @Test
-    public void testTurnFlagCombination()
-    {
+    public void testTurnFlagCombination() {
         final OSMTurnRelation.TurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
         final OSMTurnRelation.TurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
         final OSMTurnRelation.TurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
@@ -749,32 +638,26 @@ public void testTurnFlagCombination()
         EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
 
         GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
-        OSMReader reader = new OSMReader(ghStorage)
-        {
+        OSMReader reader = new OSMReader(ghStorage) {
             @Override
-            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
-                                                                                       OSMTurnRelation turnRelation )
-            {
+            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation(FlagEncoder encoder,
+                                                                                      OSMTurnRelation turnRelation) {
                 // simulate by returning one turn cost entry directly
-                if (encoder.toString().equalsIgnoreCase("car"))
-                {
+                if (encoder.toString().equalsIgnoreCase("car")) {
 
                     return Collections.singleton(turnCostEntry_car);
-                } else if (encoder.toString().equalsIgnoreCase("foot"))
-                {
+                } else if (encoder.toString().equalsIgnoreCase("foot")) {
                     return Collections.singleton(turnCostEntry_foot);
-                } else if (encoder.toString().equalsIgnoreCase("bike"))
-                {
+                } else if (encoder.toString().equalsIgnoreCase("bike")) {
                     return Collections.singleton(turnCostEntry_bike);
-                } else
-                {
+                } else {
                     throw new IllegalArgumentException("illegal encoder " + encoder.toString());
                 }
             }
         }.setEncodingManager(manager);
 
-        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), 
-        // turn cost entry for bike is for another relation (different viaNode) 
+        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo),
+        // turn cost entry for bike is for another relation (different viaNode)
         turnCostEntry_car.edgeFrom = 1;
         turnCostEntry_foot.edgeFrom = 1;
         turnCostEntry_bike.edgeFrom = 2;
@@ -784,7 +667,7 @@ public void testTurnFlagCombination()
         turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
         turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
 
-        // we expect two different entries: the first one is a combination of turn flags of car and foot, 
+        // we expect two different entries: the first one is a combination of turn flags of car and foot,
         // since they provide the same relation, the other one is for bike only
         long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
         long assertFlag2 = turnCostEntry_bike.flags;
@@ -795,11 +678,9 @@ public void testTurnFlagCombination()
         // we expect two different turnCost entries
         assertEquals(2, entries.size());
 
-        for (OSMTurnRelation.TurnCostTableEntry entry : entries)
-        {
-            if (entry.edgeFrom == 1)
-            {
-                // the first entry provides turn flags for car and foot only 
+        for (OSMTurnRelation.TurnCostTableEntry entry : entries) {
+            if (entry.edgeFrom == 1) {
+                // the first entry provides turn flags for car and foot only
                 assertEquals(assertFlag1, entry.flags);
                 assertTrue(car.isTurnRestricted(entry.flags));
                 assertFalse(foot.isTurnRestricted(entry.flags));
@@ -808,8 +689,7 @@ public void testTurnFlagCombination()
                 assertTrue(Double.isInfinite(car.getTurnCost(entry.flags)));
                 assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
                 assertEquals(0, bike.getTurnCost(entry.flags), 1e-1);
-            } else if (entry.edgeFrom == 2)
-            {
+            } else if (entry.edgeFrom == 2) {
                 // the 2nd entry provides turn flags for bike only
                 assertEquals(assertFlag2, entry.flags);
                 assertFalse(car.isTurnRestricted(entry.flags));
@@ -824,8 +704,7 @@ public void testTurnFlagCombination()
     }
 
     @Test
-    public void testPreferredLanguage()
-    {
+    public void testPreferredLanguage() {
         GraphHopper hopper = new GraphHopperTest(file1).setPreferredLanguage("de").importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
@@ -843,8 +722,7 @@ public void testPreferredLanguage()
     }
 
     @Test
-    public void testDataDateWithinPBF()
-    {
+    public void testDataDateWithinPBF() {
         GraphHopper hopper = new GraphHopperTest(file6).importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
 
@@ -852,8 +730,7 @@ public void testDataDateWithinPBF()
     }
 
     @Test
-    public void testCrossBoundary_issue667()
-    {
+    public void testCrossBoundary_issue667() {
         GraphHopper hopper = new GraphHopperTest("test-osm-waterway.xml").importOrLoad();
         QueryResult qr = hopper.getLocationIndex().findClosest(0.1, 179.5, EdgeFilter.ALL_EDGES);
         assertTrue(qr.isValid());
@@ -868,8 +745,7 @@ public void testCrossBoundary_issue667()
         assertEquals(56, qr.getClosestEdge().getDistance() / 1000, 1);
     }
 
-    public void testRoutingRequestFails_issue665()
-    {
+    public void testRoutingRequestFails_issue665() {
         GraphHopper hopper = new GraphHopperOSM()
                 .setDataReaderFile("src/test/resources/com/graphhopper/reader/" + file7)
                 .setEncodingManager(new EncodingManager("car,motorcycle"))
@@ -883,4 +759,54 @@ public void testRoutingRequestFails_issue665()
         GHResponse ghRsp = hopper.route(req);
         assertFalse(ghRsp.getErrors().toString(), ghRsp.hasErrors());
     }
+
+    class GraphHopperTest extends GraphHopperOSM {
+        public GraphHopperTest(String osmFile) {
+            this(osmFile, false);
+        }
+
+        public GraphHopperTest(String osmFile, boolean turnCosts) {
+            setStoreOnFlush(false);
+            setOSMFile(osmFile);
+            setGraphHopperLocation(dir);
+            setEncodingManager(new EncodingManager("car,foot"));
+            setCHEnabled(false);
+
+            if (turnCosts) {
+                carEncoder = new CarFlagEncoder(5, 5, 1);
+                bikeEncoder = new BikeFlagEncoder(4, 2, 1);
+            } else {
+                carEncoder = new CarFlagEncoder();
+                bikeEncoder = new BikeFlagEncoder();
+            }
+
+            footEncoder = new FootFlagEncoder();
+
+            setEncodingManager(new EncodingManager(footEncoder, carEncoder, bikeEncoder));
+        }
+
+        @Override
+        protected DataReader createReader(GraphHopperStorage tmpGraph) {
+            return initDataReader(new OSMReader(tmpGraph));
+        }
+
+        @Override
+        protected DataReader importData() throws IOException {
+            getEncodingManager().setPreferredLanguage(getPreferredLanguage());
+            GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
+                    getEncodingManager().needsTurnCostsSupport());
+            setGraphHopperStorage(tmpGraph);
+
+            DataReader osmReader = createReader(tmpGraph);
+            try {
+                osmReader.setFile(new File(getClass().getResource(getOSMFile()).toURI()));
+            } catch (URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+            osmReader.readGraph();
+            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
+            return osmReader;
+        }
+    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java
index 1f48549821..5f2b5e43c5 100755
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java
@@ -17,21 +17,18 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.osm.OSMTagParser;
-import static org.junit.Assert.*;
-import static org.junit.Assert.fail;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
 /**
- *
  * @author Peter Karich
  * @author ratrun
  */
-public class OSMTagParserTest
-{
+public class OSMTagParserTest {
     @Test
-    public void testParseDuration()
-    {        
+    public void testParseDuration() {
         assertEquals(10 * 60, OSMTagParser.parseDuration("00:10"));
         assertEquals(35 * 60, OSMTagParser.parseDuration("35"));
         assertEquals(70 * 60, OSMTagParser.parseDuration("01:10"));
@@ -50,30 +47,23 @@ public void testParseDuration()
     }
 
     @Test
-    public void testWrongDurationFormats()
-    {
-        try
-        {
+    public void testWrongDurationFormats() {
+        try {
             OSMTagParser.parseDuration("PT5h12m36s");
             fail("parseDuration didn't throw when I expected it to");
-        } catch (IllegalArgumentException expectedException)
-        {
+        } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: PT5h12m36s");
         }
-        try
-        {
+        try {
             OSMTagParser.parseDuration("oh");
             fail("parseDuration didn't throw when I expected it to");
-        } catch (IllegalArgumentException expectedException)
-        {
+        } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: oh");
         }
-        try
-        {
+        try {
             OSMTagParser.parseDuration("01:10:2");
             fail("parseDuration didn't throw when I expected it to");
-        } catch (IllegalArgumentException expectedException)
-        {
+        } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: 01:10:2");
         }
 
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
index e012201342..d06724cfb8 100755
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
@@ -24,24 +24,21 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
+import org.junit.Test;
 
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class OSMTurnRelationTest
-{
+public class OSMTurnRelationTest {
     @Test
-    public void testGetRestrictionAsEntries()
-    {
+    public void testGetRestrictionAsEntries() {
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 1);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
@@ -53,18 +50,15 @@ public void testGetRestrictionAsEntries()
 
         GraphHopperStorage ghStorage = new GraphBuilder(new EncodingManager(encoder)).create();
         EdgeBasedRoutingAlgorithmTest.initGraph(ghStorage);
-        OSMReader osmReader = new OSMReader(ghStorage)
-        {
+        OSMReader osmReader = new OSMReader(ghStorage) {
 
             @Override
-            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
-            {
+            public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
                 return osmNodeToInternal.get(nodeOsmId);
             }
 
             @Override
-            public long getOsmIdOfInternalEdge( int edgeId )
-            {
+            public long getOsmIdOfInternalEdge(int edgeId) {
                 Long l = internalToOSMEdge.get(edgeId);
                 if (l == null)
                     return -1;
@@ -91,7 +85,6 @@ public long getOsmIdOfInternalEdge( int edgeId )
         assertEquals(2, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
 
-
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
         result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 88a6cbbd17..dc893c0f20 100755
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -17,49 +17,51 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.TestAlgoCollector;
 import com.graphhopper.GraphHopper;
-import static com.graphhopper.GraphHopperIT.DIR;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.*;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
-import static com.graphhopper.util.Parameters.Algorithms.*;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.File;
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
+import static com.graphhopper.GraphHopperIT.DIR;
+import static com.graphhopper.util.Parameters.Algorithms.ASTAR;
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import static org.junit.Assert.assertEquals;
+import org.junit.Ignore;
 
 /**
  * Try algorithms, indices and graph storages with real data
  * <p>
+ *
  * @author Peter Karich
  */
-public class RoutingAlgorithmWithOSMIT
-{    
+public class RoutingAlgorithmWithOSMIT {
     TestAlgoCollector testCollector;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         testCollector = new TestAlgoCollector("core integration tests");
     }
 
-    List<OneRun> createMonacoCar()
-    {
+    List<OneRun> createMonacoCar() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2580, 110));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
@@ -79,8 +81,7 @@ public void setUp()
     }
 
     @Test
-    public void testMonaco()
-    {
+    public void testMonaco() {
         Graph g = runAlgo(testCollector, DIR + "/monaco.osm.gz", "target/monaco-gh",
                 createMonacoCar(), "car", true, "car", "shortest", false);
 
@@ -96,8 +97,7 @@ public void testMonaco()
     }
 
     @Test
-    public void testMonacoMotorcycle()
-    {
+    public void testMonacoMotorcycle() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2703, 119));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3749, 170));
@@ -112,8 +112,7 @@ public void testMonacoMotorcycle()
     }
 
     @Test
-    public void testMonacoMotorcycleCurvature()
-    {
+    public void testMonacoMotorcycleCurvature() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2703, 119));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3749, 170));
@@ -128,8 +127,7 @@ public void testMonacoMotorcycleCurvature()
     }
 
     @Test
-    public void testBike2_issue432()
-    {
+    public void testBike2_issue432() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(52.349969, 8.013813, 52.349713, 8.013293, 56, 7));
         // reverse route avoids the location
@@ -141,8 +139,7 @@ public void testBike2_issue432()
     }
 
     @Test
-    public void testMonacoAllAlgorithmsWithBaseGraph()
-    {
+    public void testMonacoAllAlgorithmsWithBaseGraph() {
         String vehicle = "car";
         String graphFile = "target/monaco-gh";
         String osmFile = DIR + "/monaco.osm.gz";
@@ -163,28 +160,24 @@ public void testMonacoAllAlgorithmsWithBaseGraph()
         Weighting weighting = hopper.createWeighting(new HintsMap("shortest"), encoder);
 
         List<AlgoHelperEntry> prepares = RoutingAlgorithmIT.createAlgos(hopper.getGraphHopperStorage(), hopper.getLocationIndex(),
-                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+                true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
         AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
         if (!(chPrepare.getQueryGraph() instanceof CHGraph))
             throw new IllegalStateException("Last prepared QueryGraph has to be a CHGraph");
 
         // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
         Graph baseGraphOfCHPrepared = chPrepare.getBaseGraph();
-        for (AlgoHelperEntry ahe : prepares)
-        {
-            if (!(ahe.getQueryGraph() instanceof CHGraph))
-            {
+        for (AlgoHelperEntry ahe : prepares) {
+            if (!(ahe.getQueryGraph() instanceof CHGraph)) {
                 ahe.setQueryGraph(baseGraphOfCHPrepared);
             }
         }
 
         List<OneRun> forEveryAlgo = createMonacoCar();
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        for (AlgoHelperEntry entry : prepares)
-        {
+        for (AlgoHelperEntry entry : prepares) {
             LocationIndex idx = entry.getIdx();
-            for (OneRun oneRun : forEveryAlgo)
-            {
+            for (OneRun oneRun : forEveryAlgo) {
                 List<QueryResult> list = oneRun.getList(idx, edgeFilter);
                 testCollector.assertDistance(entry, list, oneRun);
             }
@@ -192,8 +185,7 @@ public void testMonacoAllAlgorithmsWithBaseGraph()
     }
 
     @Test
-    public void testOneWayCircleBug()
-    {
+    public void testOneWayCircleBug() {
         // export from http://www.openstreetmap.org/export#map=19/51.37605/-0.53155
         List<OneRun> list = new ArrayList<OneRun>();
         // going the bit longer way out of the circle
@@ -207,8 +199,7 @@ public void testOneWayCircleBug()
     }
 
     @Test
-    public void testMoscow()
-    {
+    public void testMoscow() {
         // extracted via ./graphhopper.sh extract "37.582641,55.805261,37.626929,55.824455"
         List<OneRun> list = new ArrayList<OneRun>();
         // choose perpendicular
@@ -226,8 +217,7 @@ public void testMoscow()
     }
 
     @Test
-    public void testMoscowTurnCosts()
-    {
+    public void testMoscowTurnCosts() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
         list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
@@ -240,8 +230,7 @@ public void testMoscowTurnCosts()
     }
 
     @Test
-    public void testSidewalkNo()
-    {
+    public void testSidewalkNo() {
         List<OneRun> list = new ArrayList<OneRun>();
         // roundabout contains sidewalk=no which should be avoided
         list.add(new OneRun(57.154888, -2.101822, 57.153445, -2.099869, 329, 31));
@@ -256,8 +245,7 @@ public void testSidewalkNo()
     }
 
     @Test
-    public void testMonacoFastest()
-    {
+    public void testMonacoFastest() {
         List<OneRun> list = createMonacoCar();
         list.get(0).setLocs(1, 117);
         list.get(0).setDistance(1, 2584);
@@ -271,8 +259,7 @@ public void testMonacoFastest()
     }
 
     @Test
-    public void testMonacoMixed()
-    {
+    public void testMonacoMixed() {
         // Additional locations are inserted because of new crossings from foot to highway paths!
         // Distance is the same.
         List<OneRun> list = createMonacoCar();
@@ -287,8 +274,7 @@ public void testMonacoMixed()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
-    List<OneRun> createMonacoFoot()
-    {
+    List<OneRun> createMonacoFoot() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730729, 7.421288, 43.727697, 7.419199, 1566, 92));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3438, 136));
@@ -298,8 +284,7 @@ public void testMonacoMixed()
     }
 
     @Test
-    public void testMonacoFoot()
-    {
+    public void testMonacoFoot() {
         Graph g = runAlgo(testCollector, DIR + "/monaco.osm.gz", "target/monaco-gh",
                 createMonacoFoot(), "foot", true, "foot", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
@@ -314,8 +299,7 @@ public void testMonacoFoot()
     }
 
     @Test
-    public void testMonacoFoot3D()
-    {
+    public void testMonacoFoot3D() {
         // most routes have same number of points as testMonaceFoot results but longer distance due to elevation difference
         List<OneRun> list = createMonacoFoot();
         list.get(0).setDistance(1, 1627);
@@ -332,8 +316,7 @@ public void testMonacoFoot3D()
     }
 
     @Test
-    public void testNorthBayreuthHikeFastestAnd3D()
-    {
+    public void testNorthBayreuthHikeFastestAnd3D() {
         List<OneRun> list = new ArrayList<OneRun>();
         // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
         list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
@@ -345,8 +328,7 @@ public void testNorthBayreuthHikeFastestAnd3D()
     }
 
     @Test
-    public void testMonacoBike3D_twoSpeedsPerEdge()
-    {
+    public void testMonacoBike3D_twoSpeedsPerEdge() {
         List<OneRun> list = new ArrayList<OneRun>();
         // 1. alternative: go over steps 'Rampe Major' => 1.7km vs. around 2.7km
         list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2710, 118));
@@ -370,8 +352,7 @@ public void testMonacoBike3D_twoSpeedsPerEdge()
     }
 
     @Test
-    public void testMonacoBike()
-    {
+    public void testMonacoBike() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1642, 87));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3580, 168));
@@ -383,11 +364,10 @@ public void testMonacoBike()
     }
 
     @Test
-    public void testMonacoMountainBike()
-    {
+    public void testMonacoMountainBike() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2322, 110));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3613, 178));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3655, 176));
         list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2331, 121));
         // hard to select between secondary and primary (both are AVOID for mtb)
         list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1459, 88));
@@ -401,8 +381,7 @@ public void testMonacoMountainBike()
     }
 
     @Test
-    public void testMonacoRacingBike()
-    {
+    public void testMonacoRacingBike() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2594, 111));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
@@ -418,12 +397,11 @@ public void testMonacoRacingBike()
     }
 
     @Test
-    public void testKremsBikeRelation()
-    {
+    public void testKremsBikeRelation() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12491, 159));
         // 3109m is better as cyclepath is used
-        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3077, 79));
+        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3112, 87));
         list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 94));
 
         runAlgo(testCollector, DIR + "/krems.osm.gz", "target/krems-gh",
@@ -436,8 +414,7 @@ public void testKremsBikeRelation()
     }
 
     @Test
-    public void testKremsMountainBikeRelation()
-    {
+    public void testKremsMountainBikeRelation() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12574, 169));
         list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3101, 94));
@@ -452,8 +429,7 @@ public void testKremsMountainBikeRelation()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
-    List<OneRun> createAndorra()
-    {
+    List<OneRun> createAndorra() {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(42.56819, 1.603231, 42.571034, 1.520662, 17708, 524));
         list.add(new OneRun(42.529176, 1.571302, 42.571034, 1.520662, 11408, 305));
@@ -461,24 +437,21 @@ public void testKremsMountainBikeRelation()
     }
 
     @Test
-    public void testAndorra()
-    {
+    public void testAndorra() {
         runAlgo(testCollector, DIR + "/andorra.osm.gz", "target/andorra-gh",
                 createAndorra(), "car", true, "car", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
     @Test
-    public void testAndorraPbf()
-    {
+    public void testAndorraPbf() {
         runAlgo(testCollector, DIR + "/andorra.osm.pbf", "target/andorra-gh",
                 createAndorra(), "car", true, "car", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
     @Test
-    public void testAndorraFoot()
-    {
+    public void testAndorraFoot() {
         List<OneRun> list = createAndorra();
         list.get(0).setDistance(1, 16354);
         list.get(0).setLocs(1, 648);
@@ -491,8 +464,7 @@ public void testAndorraFoot()
     }
 
     @Test
-    public void testCampoGrande()
-    {
+    public void testCampoGrande() {
         // test not only NE quadrant of earth!
 
         // bzcat campo-grande.osm.bz2 
@@ -507,8 +479,7 @@ public void testCampoGrande()
     }
 
     @Test
-    public void testMonacoVia()
-    {
+    public void testMonacoVia() {
         OneRun oneRun = new OneRun();
         oneRun.add(43.730729, 7.42135, 0, 0);
         oneRun.add(43.727697, 7.419199, 2581, 110);
@@ -523,19 +494,20 @@ public void testMonacoVia()
     }
 
     @Test
-    public void testHarsdorf()
-    {
+    public void testHarsdorf() {
         List<OneRun> list = new ArrayList<OneRun>();
+        // TODO somehow the bigger road is take even if we make it less preferred (e.g. introduce AVOID AT ALL costs for lanes=2&&maxspeed>50)
+        list.add(new OneRun(50.004333, 11.600254, 50.044449, 11.543434, 6952, 190));
+
         // choose Unterloher Weg and the following residential + cycleway
-        list.add(new OneRun(50.004333, 11.600254, 50.044449, 11.543434, 6931, 184));
+        // list.add(new OneRun(50.004333, 11.600254, 50.044449, 11.543434, 6931, 184));
         runAlgo(testCollector, DIR + "/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
                 list, "bike", true, "bike", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
     @Test
-    public void testNeudrossenfeld()
-    {
+    public void testNeudrossenfeld() {
         List<OneRun> list = new ArrayList<OneRun>();
         // choose cycleway (Dreschenauer Straße)
         list.add(new OneRun(49.987132, 11.510496, 50.018839, 11.505024, 3985, 106));
@@ -550,16 +522,14 @@ public void testNeudrossenfeld()
 
     /**
      * @param testAlsoCH if true also the CH algorithms will be tested which needs preparation and
-     * takes a bit longer
+     *                   takes a bit longer
      */
-    Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
-                   String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-                   boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
-    {
+    Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
+                  String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
+                  boolean testAlsoCH, String vehicle, String weightStr, boolean is3D) {
         AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
-        try
-        {
+        try {
             Helper.removeDir(new File(graphFile));
             GraphHopper hopper = new GraphHopperOSM().
                     setStoreOnFlush(true).
@@ -580,14 +550,12 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             Weighting weighting = hopper.createWeighting(new HintsMap(weightStr), encoder);
 
             Collection<AlgoHelperEntry> prepares = RoutingAlgorithmIT.createAlgos(hopper.getGraphHopperStorage(),
-                    hopper.getLocationIndex(), encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
+                    hopper.getLocationIndex(), testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-            for (AlgoHelperEntry entry : prepares)
-            {
+            for (AlgoHelperEntry entry : prepares) {
                 algoEntry = entry;
                 LocationIndex idx = entry.getIdx();
-                for (OneRun oneRun : forEveryAlgo)
-                {
+                for (OneRun oneRun : forEveryAlgo) {
                     tmpOneRun = oneRun;
                     List<QueryResult> list = oneRun.getList(idx, edgeFilter);
                     testCollector.assertDistance(algoEntry, list, oneRun);
@@ -595,22 +563,19 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             }
 
             return hopper.getGraphHopperStorage();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             if (algoEntry == null)
                 throw new RuntimeException("cannot handle file " + osmFile + ", " + ex.getMessage(), ex);
 
             throw new RuntimeException("cannot handle " + algoEntry.toString() + ", for " + tmpOneRun
                     + ", file " + osmFile + ", " + ex.getMessage(), ex);
-        } finally
-        {
+        } finally {
             // Helper.removeDir(new File(graphFile));
         }
     }
 
     @Test
-    public void testMonacoParallel() throws IOException
-    {
+    public void testMonacoParallel() throws IOException {
         System.out.println("testMonacoParallel takes a bit time...");
         String graphFile = "target/monaco-gh";
         Helper.removeDir(new File(graphFile));
@@ -635,25 +600,19 @@ public void testMonacoParallel() throws IOException
         int algosLength = 2;
         final Weighting weighting = new ShortestWeighting(encodingManager.getEncoder("car"));
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
-        for (int no = 0; no < MAX; no++)
-        {
-            for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++)
-            {
-                String[] algos = new String[]
-                {
+        for (int no = 0; no < MAX; no++) {
+            for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++) {
+                String[] algos = new String[]{
                     ASTAR, DIJKSTRA_BI
                 };
-                for (final String algoStr : algos)
-                {
+                for (final String algoStr : algos) {
                     // an algorithm is not thread safe! reuse via clear() is ONLY appropriated if used from same thread!
                     final int instanceIndex = instanceNo;
-                    Thread t = new Thread()
-                    {
+                    Thread t = new Thread() {
                         @Override
-                        public void run()
-                        {
+                        public void run() {
                             OneRun oneRun = instances.get(instanceIndex);
-                            AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
+                            AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).algorithm(algoStr).build();
                             testCollector.assertDistance(new AlgoHelperEntry(g, g, opts, idx),
                                     oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
@@ -665,13 +624,10 @@ public void run()
             }
         }
 
-        for (Thread t : threads)
-        {
-            try
-            {
+        for (Thread t : threads) {
+            try {
                 t.join();
-            } catch (InterruptedException ex)
-            {
+            } catch (InterruptedException ex) {
                 throw new RuntimeException(ex);
             }
         }
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-osm3.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-osm3.xml
index e56f318909..05d6d99c1f 100755
--- a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-osm3.xml
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-osm3.xml
@@ -22,8 +22,7 @@
     </node>
     <node id="50" lat="10" lon="51">
         <tag k="name" v="E" />
-    </node>  
-                      
+    </node>                      
     
     <way id="10" uid="85761">
         <nd ref="10"/>
@@ -37,7 +36,7 @@
     <way id="12" uid="85762">
         <nd ref="10"/>
         <nd ref="40"/>
-        <nd ref="30"/>
+        <nd ref="30"/>        
         <tag k="name" v="A D C" />
         <tag k="oneway" v="true" />
         <tag k="highway" v="motorway" />      
diff --git a/reader-overlay-data/pom.xml b/reader-overlay-data/pom.xml
new file mode 100644
index 0000000000..4e6c8650eb
--- /dev/null
+++ b/reader-overlay-data/pom.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-reader-overlay-data</artifactId>
+    <version>0.9-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <name>GraphHopper Reader for Overlay Data</name>
+
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>    	
+        <version>0.9-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <version>2.6.2</version>
+            <!-- in the future make implementation optional
+                 <scope>provided</scope>
+            -->
+        </dependency> 
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>${slf4j.version}</version>
+        </dependency>   
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>${log4j.version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>   
+    </dependencies>
+    
+</project>
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/GHson.java b/reader-overlay-data/src/main/java/com/graphhopper/json/GHson.java
new file mode 100644
index 0000000000..7225ce9f93
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/GHson.java
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json;
+
+import java.io.Reader;
+
+/**
+ * A simple JSON (de)serialization facade. E.g. to be easily replaced with platform specific
+ * implementations.
+ *
+ * @author Peter Karich
+ */
+public interface GHson {
+    /**
+     * This method reads JSON data from the provided source and creates an instance of the provided
+     * class.
+     */
+    <T> T fromJson(Reader source, Class<T> aClass);
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonBuilder.java b/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonBuilder.java
new file mode 100644
index 0000000000..1a1d1862f5
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonBuilder.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.graphhopper.json.geo.FeatureJsonDeserializer;
+import com.graphhopper.json.geo.JsonFeature;
+
+/**
+ * @author Peter Karich
+ */
+public class GHsonBuilder {
+    public GHson create() {
+        // for now always return Gson implementation        
+        Gson gson = new GsonBuilder()
+                .disableHtmlEscaping()
+                .registerTypeHierarchyAdapter(JsonFeature.class, new FeatureJsonDeserializer())
+                .create();
+        // for geojson we could rely on external libs instead of inventing our own:
+        // https://github.com/filosganga/geogson or https://github.com/3sidedcube/Android-GeoGson
+
+        return new GHsonGson(gson);
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonGson.java b/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonGson.java
new file mode 100644
index 0000000000..27fe0fc7cd
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/GHsonGson.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json;
+
+import com.google.gson.Gson;
+
+import java.io.Reader;
+
+/**
+ * @author Peter Karich
+ */
+public class GHsonGson implements GHson {
+    private final Gson gson;
+
+    public GHsonGson(Gson gson) {
+        this.gson = gson;
+    }
+
+    @Override
+    public <T> T fromJson(Reader source, Class<T> aClass) {
+        return gson.fromJson(source, aClass);
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/FeatureJsonDeserializer.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/FeatureJsonDeserializer.java
new file mode 100644
index 0000000000..f30e7f52b5
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/FeatureJsonDeserializer.java
@@ -0,0 +1,134 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.google.gson.*;
+import com.graphhopper.util.shapes.BBox;
+
+import java.lang.reflect.Type;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * Instructions how to read the different geometry types.
+ *
+ * @author Peter Karich
+ */
+public class FeatureJsonDeserializer implements JsonDeserializer<JsonFeature> {
+    @Override
+    public JsonFeature deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException {
+        try {
+            JsonFeature feature = new JsonFeature();
+            JsonObject obj = json.getAsJsonObject();
+
+            // TODO ensure uniqueness
+            if (obj.has("id"))
+                feature.id = obj.get("id").getAsString();
+            else
+                feature.id = UUID.randomUUID().toString();
+
+            if (obj.has("properties")) {
+                Map<String, Object> map = context.deserialize(obj.get("properties"), Map.class);
+                feature.properties = map;
+            }
+
+            if (obj.has("bbox"))
+                feature.bbox = parseBBox(obj.get("bbox").getAsJsonArray());
+
+            if (obj.has("geometry")) {
+                JsonObject geometry = obj.get("geometry").getAsJsonObject();
+
+                if (geometry.has("coordinates")) {
+                    if (!geometry.has("type"))
+                        throw new IllegalArgumentException("No type for non-empty coordinates specified");
+
+                    String strType = context.deserialize(geometry.get("type"), String.class);
+                    feature.type = strType;
+                    if ("Point".equals(strType)) {
+                        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
+                        double lon = arr.get(0).getAsDouble();
+                        double lat = arr.get(1).getAsDouble();
+                        if (arr.size() == 3)
+                            feature.geometry = new Point(lat, lon, arr.get(2).getAsDouble());
+                        else
+                            feature.geometry = new Point(lat, lon);
+
+                    } else if ("MultiPoint".equals(strType)) {
+                        feature.geometry = parseLineString(geometry);
+
+                    } else if ("LineString".equals(strType)) {
+                        feature.geometry = parseLineString(geometry);
+
+                    } else {
+                        throw new IllegalArgumentException("Coordinates type " + strType + " not yet supported");
+                    }
+                }
+            }
+
+            return feature;
+
+        } catch (Exception ex) {
+            throw new JsonParseException("Problem parsing JSON feature " + json);
+        }
+    }
+
+    LineString parseLineString(JsonObject geometry) {
+        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
+        boolean is3D = arr.size() == 0 || arr.get(0).getAsJsonArray().size() == 3;
+        LineString lineString = new LineString(arr.size(), is3D);
+
+        for (int i = 0; i < arr.size(); i++) {
+            JsonArray pointArr = arr.get(i).getAsJsonArray();
+            double lon = pointArr.get(0).getAsDouble();
+            double lat = pointArr.get(1).getAsDouble();
+            if (pointArr.size() == 3)
+                lineString.add(lat, lon, pointArr.get(2).getAsDouble());
+            else
+                lineString.add(lat, lon);
+        }
+        return lineString;
+    }
+
+    private BBox parseBBox(JsonArray arr) {
+        // The value of the bbox member must be a 2*n array where n is the number of dimensions represented 
+        // in the contained geometries, with the lowest values for all axes followed by the highest values. 
+        // The axes order of a bbox follows the axes order of geometries => lon,lat,ele
+        if (arr.size() == 6) {
+            double minLon = arr.get(0).getAsDouble();
+            double minLat = arr.get(1).getAsDouble();
+            double minEle = arr.get(2).getAsDouble();
+
+            double maxLon = arr.get(3).getAsDouble();
+            double maxLat = arr.get(4).getAsDouble();
+            double maxEle = arr.get(5).getAsDouble();
+
+            return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle);
+
+        } else if (arr.size() == 4) {
+            double minLon = arr.get(0).getAsDouble();
+            double minLat = arr.get(1).getAsDouble();
+
+            double maxLon = arr.get(2).getAsDouble();
+            double maxLat = arr.get(3).getAsDouble();
+
+            return new BBox(minLon, maxLon, minLat, maxLat);
+        } else {
+            throw new IllegalArgumentException("Illegal array dimension (" + arr.size() + ") of bbox " + arr.toString());
+        }
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Geometry.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Geometry.java
new file mode 100644
index 0000000000..e8eeefb72d
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Geometry.java
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.GHPoint;
+
+/**
+ * @author Peter Karich
+ */
+public interface Geometry {
+    String getType();
+
+    boolean isPoint();
+
+    GHPoint asPoint();
+
+    boolean isPointList();
+
+    PointList asPointList();
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeature.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeature.java
new file mode 100644
index 0000000000..466d30a3a7
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeature.java
@@ -0,0 +1,70 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.graphhopper.util.shapes.BBox;
+
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public class JsonFeature {
+    String id;
+    String type;
+    BBox bbox;
+    Geometry geometry;
+    Map<String, Object> properties;
+
+    public String getId() {
+        return id;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public BBox getBBox() {
+        return bbox;
+    }
+
+    public boolean hasGeometry() {
+        return geometry != null;
+    }
+
+    public Geometry getGeometry() {
+        return geometry;
+    }
+
+    public boolean hasProperties() {
+        return properties != null;
+    }
+
+    public Map<String, Object> getProperties() {
+        return properties;
+    }
+
+    public Object getProperty(String key) {
+        return properties.get(key);
+    }
+
+    @Override
+    public String toString() {
+        return "id:" + getId();
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
new file mode 100644
index 0000000000..9e846a9ce5
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ */
+public class JsonFeatureCollection {
+    String type;
+    List<JsonFeature> features;
+
+    public String getType() {
+        return type;
+    }
+
+    public List<JsonFeature> getFeatures() {
+        return features;
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/LineString.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/LineString.java
new file mode 100644
index 0000000000..d3c9359c61
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/LineString.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.GHPoint;
+
+/**
+ * Wrapper to read a PointList easily from GeoJSON (type=LineString)
+ *
+ * @author Peter Karich
+ */
+public class LineString extends PointList implements Geometry {
+    public LineString(int size, boolean is3D) {
+        super(size, is3D);
+    }
+
+    @Override
+    public String getType() {
+        return "LineString";
+    }
+
+    @Override
+    public boolean isPoint() {
+        return false;
+    }
+
+    @Override
+    public GHPoint asPoint() {
+        throw new UnsupportedOperationException("Not supported");
+    }
+
+    @Override
+    public boolean isPointList() {
+        return true;
+    }
+
+    @Override
+    public PointList asPointList() {
+        return this;
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Point.java b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Point.java
new file mode 100644
index 0000000000..29ade6a432
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/json/geo/Point.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
+
+/**
+ * Wrapper to read a GHPoint3D easily from GeoJSON (type=Point)
+ *
+ * @author Peter Karich
+ */
+public class Point extends GHPoint3D implements Geometry {
+    public Point(double lat, double lon) {
+        super(lat, lon, Double.NaN);
+    }
+
+    public Point(double lat, double lon, double ele) {
+        super(lat, lon, ele);
+    }
+
+    @Override
+    public String toString() {
+        return lat + ", " + lon;
+    }
+
+    @Override
+    public boolean isPoint() {
+        return true;
+    }
+
+    @Override
+    public GHPoint asPoint() {
+        return this;
+    }
+
+    @Override
+    public boolean isPointList() {
+        return false;
+    }
+
+    @Override
+    public PointList asPointList() {
+        throw new UnsupportedOperationException("Not supported");
+    }
+
+    @Override
+    public String getType() {
+        return "Point";
+    }
+}
diff --git a/reader-overlay-data/src/main/java/com/graphhopper/reader/overlaydata/FeedOverlayData.java b/reader-overlay-data/src/main/java/com/graphhopper/reader/overlaydata/FeedOverlayData.java
new file mode 100644
index 0000000000..3ea9cf8933
--- /dev/null
+++ b/reader-overlay-data/src/main/java/com/graphhopper/reader/overlaydata/FeedOverlayData.java
@@ -0,0 +1,213 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.overlaydata;
+
+import com.graphhopper.json.GHson;
+import com.graphhopper.json.geo.Geometry;
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.iterator.TIntIterator;
+import gnu.trove.set.TIntSet;
+import gnu.trove.set.hash.TIntHashSet;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public class FeedOverlayData {
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Graph graph;
+    private final LocationIndex locationIndex;
+    private final GHson ghson;
+    private final EncodingManager em;
+    private boolean enableLogging = false;
+
+    public FeedOverlayData(Graph graph, EncodingManager em, LocationIndex locationIndex, GHson ghson) {
+        this.ghson = ghson;
+        this.graph = graph;
+        this.em = em;
+        this.locationIndex = locationIndex;
+    }
+
+    public void setLogging(boolean log) {
+        enableLogging = log;
+    }
+
+    public long applyChanges(String fileOrFolderStr) {
+        File fileOrFolder = new File(fileOrFolderStr);
+        try {
+            if (fileOrFolder.isFile()) {
+                return applyChanges(new FileReader(fileOrFolder));
+            }
+
+            long sum = 0;
+            File[] fList = new File(fileOrFolderStr).listFiles(new FilenameFilter() {
+                @Override
+                public boolean accept(File dir, String name) {
+                    return name.endsWith(".json");
+                }
+            });
+            for (File f : fList) {
+                sum += applyChanges(new FileReader(f));
+            }
+            return sum;
+
+        } catch (FileNotFoundException ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    /**
+     * This method applies changes to the graph, specified by the reader.
+     *
+     * @return number of successfully applied edge changes
+     */
+    public long applyChanges(Reader reader) {
+        // read full file, later support one json feature or collection per line to avoid high mem consumption
+        JsonFeatureCollection data = ghson.fromJson(reader, JsonFeatureCollection.class);
+        long updates = 0;
+        for (JsonFeature jsonFeature : data.getFeatures()) {
+            if (!jsonFeature.hasProperties())
+                throw new IllegalArgumentException("One feature has no properties, please specify properties e.g. speed or access");
+
+            List<String> encodersAsStr = (List) jsonFeature.getProperty("vehicles");
+            if (encodersAsStr == null) {
+                for (FlagEncoder encoder : em.fetchEdgeEncoders()) {
+                    updates += applyChange(jsonFeature, encoder);
+                }
+            } else {
+                for (String encoderStr : encodersAsStr) {
+                    updates += applyChange(jsonFeature, em.getEncoder(encoderStr));
+                }
+            }
+        }
+
+        return updates;
+    }
+
+    private long applyChange(JsonFeature jsonFeature, FlagEncoder encoder) {
+        long updates = 0;
+        EdgeFilter filter = new DefaultEdgeFilter(encoder);
+        TIntSet edges = new TIntHashSet();
+        if (jsonFeature.hasGeometry()) {
+            fillEdgeIDs(edges, jsonFeature.getGeometry(), filter);
+        } else if (jsonFeature.getBBox() != null) {
+            fillEdgeIDs(edges, jsonFeature.getBBox(), filter);
+        } else
+            throw new IllegalArgumentException("Feature " + jsonFeature.getId() + " has no geometry and no bbox");
+
+        TIntIterator iter = edges.iterator();
+        Map<String, Object> props = jsonFeature.getProperties();
+        while (iter.hasNext()) {
+            int edgeId = iter.next();
+            EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE);
+
+            if (props.containsKey("access")) {
+                boolean value = (boolean) props.get("access");
+                updates++;
+                if (enableLogging)
+                    logger.info(encoder.toString() + " - access change via feature " + jsonFeature.getId());
+                edge.setFlags(encoder.setAccess(edge.getFlags(), value, value));
+
+            } else if (props.containsKey("speed")) {
+                // TODO use different speed for the different directions (see e.g. Bike2WeightFlagEncoder)
+                double value = ((Number) props.get("speed")).doubleValue();
+                double oldSpeed = encoder.getSpeed(edge.getFlags());
+                if (oldSpeed != value) {
+                    updates++;
+                    if (enableLogging)
+                        logger.info(encoder.toString() + " - speed change via feature " + jsonFeature.getId() + ". Old: " + oldSpeed + ", new:" + value);
+                    edge.setFlags(encoder.setSpeed(edge.getFlags(), value));
+                }
+            }
+        }
+        return updates;
+    }
+
+    public void fillEdgeIDs(TIntSet edgeIds, Geometry geometry, EdgeFilter filter) {
+        if (geometry.isPoint()) {
+            GHPoint point = geometry.asPoint();
+            QueryResult qr = locationIndex.findClosest(point.lat, point.lon, filter);
+            if (qr.isValid())
+                edgeIds.add(qr.getClosestEdge().getEdge());
+        } else if (geometry.isPointList()) {
+            PointList pl = geometry.asPointList();
+            if (geometry.getType().equals("LineString")) {
+                // TODO do map matching or routing
+                int lastIdx = pl.size() - 1;
+                if (pl.size() >= 2) {
+                    double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;
+                    double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;
+                    QueryResult qr = locationIndex.findClosest(meanLat, meanLon, filter);
+                    if (qr.isValid())
+                        edgeIds.add(qr.getClosestEdge().getEdge());
+                }
+            } else {
+                for (int i = 0; i < pl.size(); i++) {
+                    QueryResult qr = locationIndex.findClosest(pl.getLatitude(i), pl.getLongitude(i), filter);
+                    if (qr.isValid())
+                        edgeIds.add(qr.getClosestEdge().getEdge());
+                }
+            }
+        }
+    }
+
+    public void fillEdgeIDs(final TIntSet edgeIds, final BBox bbox, EdgeFilter filter) {
+        QueryResult qr = locationIndex.findClosest((bbox.maxLat + bbox.minLat) / 2, (bbox.maxLon + bbox.minLon) / 2, filter);
+        if (!qr.isValid())
+            return;
+
+        BreadthFirstSearch bfs = new BreadthFirstSearch() {
+            final NodeAccess na = graph.getNodeAccess();
+            final BBox localBBox = bbox;
+
+            @Override
+            protected boolean goFurther(int nodeId) {
+                return localBBox.contains(na.getLatitude(nodeId), na.getLongitude(nodeId));
+            }
+
+            @Override
+            protected boolean checkAdjacent(EdgeIteratorState edge) {
+                if (localBBox.contains(na.getLatitude(edge.getAdjNode()), na.getLongitude(edge.getAdjNode()))) {
+                    edgeIds.add(edge.getEdge());
+                    return true;
+                }
+                return false;
+            }
+        };
+        bfs.start(graph.createEdgeExplorer(filter), qr.getClosestNode());
+    }
+}
diff --git a/reader-overlay-data/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/reader-overlay-data/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
new file mode 100644
index 0000000000..691fe96d27
--- /dev/null
+++ b/reader-overlay-data/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.graphhopper.json.GHson;
+import com.graphhopper.json.GHsonBuilder;
+import com.graphhopper.util.Helper;
+import org.junit.Test;
+
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Peter Karich
+ */
+public class JsonFeatureCollectionTest {
+    private final GHson ghson = new GHsonBuilder().create();
+
+    @Test
+    public void testDeserialization() {
+        JsonFeatureCollection data = getJson("geojson1.json");
+        assertEquals(3, data.getFeatures().size());
+
+        JsonFeature f1 = data.getFeatures().get(0);
+        assertEquals("1", f1.getId());
+        assertEquals("value0", f1.getProperty("prop0"));
+        assertEquals(0.5, f1.getGeometry().asPoint().lat, .1);
+        assertEquals(102.0, f1.getGeometry().asPoint().lon, .1);
+
+        JsonFeature f2 = data.getFeatures().get(1);
+        // read as string despite the 2 (not a string) in json
+        assertEquals("2", f2.getId());
+        assertEquals(4, f2.getGeometry().asPointList().size());
+        assertEquals(0.0, f2.getGeometry().asPointList().getLat(0), .1);
+        assertEquals(102.0, f2.getGeometry().asPointList().getLon(0), .1);
+        assertEquals(1.0, f2.getGeometry().asPointList().getLat(1), .1);
+        assertEquals(103.0, f2.getGeometry().asPointList().getLon(1), .1);
+
+        JsonFeature f3 = data.getFeatures().get(2);
+        assertEquals("0.0,102.0,1.0,103.0", f3.getBBox().toString());
+        assertEquals("a", ((Map) f3.getProperty("prop1")).get("test"));
+    }
+
+    JsonFeatureCollection getJson(String name) {
+        Reader reader = new InputStreamReader(getClass().getResourceAsStream(name), Helper.UTF_CS);
+        return ghson.fromJson(reader, JsonFeatureCollection.class);
+    }
+
+}
diff --git a/reader-overlay-data/src/test/java/com/graphhopper/reader/overlaydata/FeedOverlayDataTest.java b/reader-overlay-data/src/test/java/com/graphhopper/reader/overlaydata/FeedOverlayDataTest.java
new file mode 100644
index 0000000000..c1eb195cf8
--- /dev/null
+++ b/reader-overlay-data/src/test/java/com/graphhopper/reader/overlaydata/FeedOverlayDataTest.java
@@ -0,0 +1,76 @@
+package com.graphhopper.reader.overlaydata;
+
+import com.graphhopper.json.GHson;
+import com.graphhopper.json.GHsonBuilder;
+import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class FeedOverlayDataTest {
+    private EncodingManager encodingManager;
+    private GraphHopperStorage graph;
+    private GHson ghson;
+
+    @Before
+    public void setUp() {
+        encodingManager = new EncodingManager("car");
+        graph = new GraphBuilder(encodingManager).create();
+        ghson = new GHsonBuilder().create();
+    }
+
+    @Test
+    public void testApplyChanges() {
+        // 0-1-2
+        // | |
+        // 3-4
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(0, 3, 1, true);
+        graph.edge(1, 4, 1, true);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
+
+        FlagEncoder encoder = encodingManager.getEncoder("car");
+        double defaultSpeed = encoder.getSpeed(GHUtility.getEdge(graph, 0, 1).getFlags());
+        AllEdgesIterator iter = graph.getAllEdges();
+        while (iter.next()) {
+            long flags = GHUtility.getEdge(graph, 0, 1).getFlags();
+            assertEquals(defaultSpeed, encoder.getSpeed(flags), .1);
+            assertTrue(encoder.isForward(flags));
+        }
+
+        FeedOverlayData instance = new FeedOverlayData(graph, encodingManager, locationIndex, ghson);
+        Reader reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata1.json"), Helper.UTF_CS);
+        long updates = instance.applyChanges(reader);
+        assertEquals(2, updates);
+
+        // assert changed speed and access
+        double newSpeed = encoder.getSpeed(GHUtility.getEdge(graph, 0, 1).getFlags());
+        assertEquals(10, newSpeed, .1);
+        assertTrue(newSpeed < defaultSpeed);
+        assertFalse(encoder.isForward(GHUtility.getEdge(graph, 3, 4).getFlags()));
+    }
+}
diff --git a/reader-overlay-data/src/test/resources/com/graphhopper/json/geo/geojson1.json b/reader-overlay-data/src/test/resources/com/graphhopper/json/geo/geojson1.json
new file mode 100644
index 0000000000..0044371bea
--- /dev/null
+++ b/reader-overlay-data/src/test/resources/com/graphhopper/json/geo/geojson1.json
@@ -0,0 +1,38 @@
+{
+    "type": "FeatureCollection",
+    "features": [
+        {
+            "id": "1",
+            "type": "Feature",
+            "geometry": {
+                "type": "Point",
+                "coordinates": [102.0, 0.5]
+            },
+            "properties": {
+                "prop0": "value0"
+            }
+        },
+        {
+            "id": 2,
+            "type": "Feature",
+            "geometry": {
+                "type": "LineString",
+                "coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]]
+            },
+            "properties": {
+                "prop0": "value1",
+                "prop1": 2
+            }
+        },
+        {
+            "type": "Feature",
+            "bbox": [0.0, 1, 102.0, 103.0],
+            "properties": {
+                "prop0": "value0",
+                "prop1": {
+                    "test": "a"
+                }
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/reader-overlay-data/src/test/resources/com/graphhopper/reader/overlaydata/overlaydata1.json b/reader-overlay-data/src/test/resources/com/graphhopper/reader/overlaydata/overlaydata1.json
new file mode 100644
index 0000000000..af1a700d58
--- /dev/null
+++ b/reader-overlay-data/src/test/resources/com/graphhopper/reader/overlaydata/overlaydata1.json
@@ -0,0 +1,26 @@
+{
+    "type": "FeatureCollection",
+    "features": [
+        {
+            "type": "Feature",
+            "geometry": {
+                "type": "Point",
+                "coordinates": [0.005, 0.01]
+            },
+            "properties": {
+                "vehicles": ["car"],
+                "speed": 10,
+                "assert_nodes": [0, 1]
+            }
+        },
+        {
+            "id": "2",
+            "type": "Feature",
+            "bbox": [-0.01, -0.01, 0.015, 0.005],
+            "properties": {
+                "access": false,
+                "assert_nodes": [3, 4]
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/tools-lgpl/pom.xml b/tools-lgpl/pom.xml
index dbe21ddcc3..8f46b9d838 100755
--- a/tools-lgpl/pom.xml
+++ b/tools-lgpl/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools-lgpl</artifactId>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.9-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools LGPL licensed</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <version>0.9-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java b/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
index da1776280b..d977f7dd8b 100755
--- a/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
+++ b/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
@@ -17,23 +17,19 @@
 /**
  * Taken from opentripplanner.
  */
-public class OTPIntDoubleBinHeap
-{
+public class OTPIntDoubleBinHeap {
     private static final double GROW_FACTOR = 2.0;
     private float[] keys;
     private int[] elem;
     private int size;
     private int capacity;
 
-    public OTPIntDoubleBinHeap()
-    {
+    public OTPIntDoubleBinHeap() {
         this(1000);
     }
 
-    public OTPIntDoubleBinHeap( int capacity )
-    {
-        if (capacity < 10)
-        {
+    public OTPIntDoubleBinHeap(int capacity) {
+        if (capacity < 10) {
             capacity = 10;
         }
         this.capacity = capacity;
@@ -45,82 +41,64 @@ public OTPIntDoubleBinHeap( int capacity )
         keys[0] = Float.NEGATIVE_INFINITY;
     }
 
-    public int getSize()
-    {
+    public int getSize() {
         return size;
     }
 
-    public int size()
-    {
+    public int size() {
         return size;
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return size == 0;
     }
 
-    public Double peekKey()
-    {
+    public Double peekKey() {
         return peek_key();
     }
 
-    public double peek_key()
-    {
-        if (size > 0)
-        {
+    public double peek_key() {
+        if (size > 0) {
             return keys[1];
-        } else
-        {
+        } else {
             throw new IllegalStateException("An empty queue does not have a minimum key.");
         }
     }
 
-    public Integer peekElement()
-    {
+    public Integer peekElement() {
         return peek_element();
     }
 
-    public int peek_element()
-    {
-        if (size > 0)
-        {
+    public int peek_element() {
+        if (size > 0) {
             return elem[1];
-        } else
-        {
+        } else {
             throw new IllegalStateException("An empty queue does not have a minimum value.");
         }
     }
 
-    public Integer pollElement()
-    {
+    public Integer pollElement() {
         return poll_element();
     }
 
-    public int poll_element()
-    {
+    public int poll_element() {
         int i, child;
         int minElem = elem[1];
         int lastElem = elem[size];
         double lastPrio = keys[size];
-        if (size <= 0)
-        {
+        if (size <= 0) {
             throw new IllegalStateException("An empty queue does not have a minimum value.");
         }
         size -= 1;
-        for (i = 1; i * 2 <= size; i = child)
-        {
+        for (i = 1; i * 2 <= size; i = child) {
             child = i * 2;
-            if (child != size && keys[child + 1] < keys[child])
-            {
+            if (child != size && keys[child + 1] < keys[child]) {
                 child++;
             }
-            if (lastPrio > keys[child])
-            {
+            if (lastPrio > keys[child]) {
                 elem[i] = elem[child];
                 keys[i] = keys[child];
-            } else
-            {
+            } else {
                 break;
             }
         }
@@ -129,55 +107,43 @@ public int poll_element()
         return minElem;
     }
 
-    public void update( Number key, Integer element )
-    {
+    public void update(Number key, Integer element) {
         update_(key.doubleValue(), element);
     }
 
-    public boolean update_( double key, int element )
-    {
+    public boolean update_(double key, int element) {
         // Perform "inefficient" but straightforward linear search 
         // for an element then change its key by sifting up or down
         int i;
-        for (i = 1; i <= size; i++)
-        {
-            if (elem[i] == element)
-            {
+        for (i = 1; i <= size; i++) {
+            if (elem[i] == element) {
                 break;
             }
         }
-        if (i > size)
-        {
+        if (i > size) {
             return false;
         }
 
-        if (key > keys[i])
-        {
+        if (key > keys[i]) {
             // sift up (as in extract)
-            while (i * 2 <= size)
-            {
+            while (i * 2 <= size) {
                 int child = i * 2;
-                if (child != size && keys[child + 1] < keys[child])
-                {
+                if (child != size && keys[child + 1] < keys[child]) {
                     child++;
                 }
-                if (key > keys[child])
-                {
+                if (key > keys[child]) {
                     elem[i] = elem[child];
                     keys[i] = keys[child];
                     i = child;
-                } else
-                {
+                } else {
                     break;
                 }
             }
             elem[i] = element;
             keys[i] = (float) key;
-        } else
-        {
+        } else {
             // sift down (as in insert_)
-            while (keys[i / 2] > key)
-            {
+            while (keys[i / 2] > key) {
                 elem[i] = elem[i / 2];
                 keys[i] = keys[i / 2];
                 i /= 2;
@@ -188,21 +154,17 @@ public boolean update_( double key, int element )
         return true;
     }
 
-    public void insert( Number key, Integer element )
-    {
+    public void insert(Number key, Integer element) {
         insert_(key.doubleValue(), element);
     }
 
-    public void insert_( double key, int element )
-    {
+    public void insert_(double key, int element) {
         int i;
         size += 1;
-        if (size > capacity)
-        {
+        if (size > capacity) {
             ensureCapacity((int) (capacity * GROW_FACTOR));
         }
-        for (i = size; keys[i / 2] > key; i /= 2)
-        {
+        for (i = size; keys[i / 2] > key; i /= 2) {
             elem[i] = elem[i / 2];
             keys[i] = keys[i / 2];
         }
@@ -210,11 +172,9 @@ public void insert_( double key, int element )
         keys[i] = (float) key;
     }
 
-    public void ensureCapacity( int capacity )
-    {
+    public void ensureCapacity(int capacity) {
         // System.out.println("Growing queue to " + capacity);
-        if (capacity < size)
-        {
+        if (capacity < size) {
             throw new IllegalStateException("BinHeap contains too many elements to fit in new capacity.");
         }
         this.capacity = capacity;
@@ -222,29 +182,24 @@ public void ensureCapacity( int capacity )
         elem = Arrays.copyOf(elem, capacity + 1);
     }
 
-    public int getCapacity()
-    {
+    public int getCapacity() {
         return capacity;
     }
 
-    float getKey( int index )
-    {
+    float getKey(int index) {
         return keys[index];
     }
 
-    int getElement( int index )
-    {
+    int getElement(int index) {
         return elem[index];
     }
 
-    void set( int index, float key, int element )
-    {
+    void set(int index, float key, int element) {
         keys[index] = key;
         elem[index] = element;
     }
 
-    void trimTo( int toSize )
-    {
+    void trimTo(int toSize) {
         this.size = toSize;
         toSize++;
         // necessary as we currently do not init arrays when inserting
@@ -252,19 +207,15 @@ void trimTo( int toSize )
         Arrays.fill(elem, toSize, size + 1, 0);
     }
 
-    public void clear()
-    {
+    public void clear() {
         trimTo(0);
     }
 
     @Override
-    public String toString()
-    {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = 1; i <= size; i++)
-        {
-            if (i > 1)
-            {
+        for (int i = 1; i <= size; i++) {
+            if (i > 1) {
                 sb.append(", ");
             }
             sb.append(keys[i]).append(":").append(elem[i]);
@@ -272,13 +223,10 @@ public String toString()
         return sb.toString();
     }
 
-    public String toKeyString()
-    {
+    public String toKeyString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = 1; i <= size; i++)
-        {
-            if (i > 1)
-            {
+        for (int i = 1; i <= size; i++) {
+            if (i > 1) {
                 sb.append(", ");
             }
             sb.append(keys[i]);
@@ -286,12 +234,9 @@ public String toKeyString()
         return sb.toString();
     }
 
-    public int indexOfValue( int value )
-    {
-        for (int i = 0; i <= size; i++)
-        {
-            if (elem[i] == value)
-            {
+    public int indexOfValue(int value) {
+        for (int i = 0; i <= size; i++) {
+            if (elem[i] == value) {
                 return i;
             }
         }
diff --git a/tools/pom.xml b/tools/pom.xml
index e035f529b2..14e6ac070e 100755
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.9-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <version>0.9-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/tools/src/main/java/com/graphhopper/tools/Bzip2.java b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
index 35d240e2fe..49db0f8444 100755
--- a/tools/src/main/java/com/graphhopper/tools/Bzip2.java
+++ b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
@@ -18,28 +18,23 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.util.Helper;
+import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
 
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 
-import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
-
 /**
  * Simple bzip2 uncompression. TODO integrate with OSMReader!
  */
-public class Bzip2
-{
-    public static void main( String[] args ) throws IOException
-    {
-        if (args.length == 0)
-        {
+public class Bzip2 {
+    public static void main(String[] args) throws IOException {
+        if (args.length == 0) {
             throw new IllegalArgumentException("You need to specify the bz2 file!");
         }
 
         String fromFile = args[0];
-        if (!fromFile.endsWith(".bz2"))
-        {
+        if (!fromFile.endsWith(".bz2")) {
             throw new IllegalArgumentException("You need to specify a bz2 file! But was:" + fromFile);
         }
         String toFile = Helper.pruneFileEnd(fromFile);
@@ -47,16 +42,13 @@ public static void main( String[] args ) throws IOException
         FileInputStream in = new FileInputStream(fromFile);
         FileOutputStream out = new FileOutputStream(toFile);
         BZip2CompressorInputStream bzIn = new BZip2CompressorInputStream(in);
-        try
-        {
+        try {
             final byte[] buffer = new byte[1024 * 8];
             int n = 0;
-            while (-1 != (n = bzIn.read(buffer)))
-            {
+            while (-1 != (n = bzIn.read(buffer))) {
                 out.write(buffer, 0, n);
             }
-        } finally
-        {
+        } finally {
             out.close();
             bzIn.close();
         }
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index bc95f8434f..9b668df757 100755
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -24,10 +24,8 @@
 /**
  * @author Peter Karich
  */
-public class Import
-{
-    public static void main( String[] strs ) throws Exception
-    {
+public class Import {
+    public static void main(String[] strs) throws Exception {
         CmdArgs args = CmdArgs.read(strs);
         GraphHopper hopper = new GraphHopperOSM().init(args);
         hopper.importOrLoad();
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 8797c26f1c..a800493f9c 100755
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -17,21 +17,27 @@
  */
 package com.graphhopper.tools;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Algorithms;
 import com.graphhopper.util.Parameters.CH;
 import com.graphhopper.util.shapes.BBox;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.FileWriter;
 import java.io.IOException;
@@ -44,28 +50,22 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * @author Peter Karich
  */
-public class Measurement
-{
-    public static void main( String[] strs )
-    {
-        new Measurement().start(CmdArgs.read(strs));
-    }
-
+public class Measurement {
     private static final Logger logger = LoggerFactory.getLogger(Measurement.class);
     private final Map<String, String> properties = new TreeMap<String, String>();
     private long seed;
     private int maxNode;
 
+    public static void main(String[] strs) {
+        new Measurement().start(CmdArgs.read(strs));
+    }
+
     // creates properties file in the format key=value
     // Every value is one y-value in a separate diagram with an identical x-value for every Measurement.start call
-    void start( CmdArgs args )
-    {
+    void start(CmdArgs args) {
         String graphLocation = args.get("graph.location", "");
         String propLocation = args.get("measurement.location", "");
         if (Helper.isEmpty(propLocation))
@@ -75,11 +75,9 @@ void start( CmdArgs args )
         String gitCommit = args.get("measurement.gitinfo", "");
         int count = args.getInt("measurement.count", 5000);
 
-        GraphHopper hopper = new GraphHopperOSM()
-        {
+        GraphHopper hopper = new GraphHopperOSM() {
             @Override
-            protected void prepare()
-            {
+            protected void prepare() {
                 StopWatch sw = new StopWatch().start();
                 super.prepare();
                 put("prepare.time", sw.stop().getTime());
@@ -90,8 +88,7 @@ protected void prepare()
             }
 
             @Override
-            protected DataReader importData() throws IOException
-            {
+            protected DataReader importData() throws IOException {
                 StopWatch sw = new StopWatch().start();
                 DataReader dr = super.importData();
                 put("graph.import_time", sw.stop().getSeconds());
@@ -105,16 +102,13 @@ protected DataReader importData() throws IOException
         hopper.importOrLoad();
 
         GraphHopperStorage g = hopper.getGraphHopperStorage();
-//        if ("true".equals(g.getProperties().get("prepare.done")))
-//            throw new IllegalStateException("Graph has to be unprepared but wasn't!");
-
+        
         String vehicleStr = args.get("graph.flag_encoders", "car");
         FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicleStr);
         Weighting weighting = hopper.getCHFactoryDecorator().getWeightings().get(0);
 
         StopWatch sw = new StopWatch().start();
-        try
-        {
+        try {
             maxNode = g.getNodes();
             GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
             boolean isCH = false;
@@ -132,12 +126,10 @@ protected DataReader importData() throws IOException
             printTimeOfRouteQuery(hopper, isCH, count, "routingCH", vehicleStr, true);
             printTimeOfRouteQuery(hopper, isCH, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             logger.error("Problem while measuring " + graphLocation, ex);
             put("error", ex.toString());
-        } finally
-        {
+        } finally {
             put("measurement.gitinfo", gitCommit);
             put("measurement.count", count);
             put("measurement.seed", seed);
@@ -145,28 +137,23 @@ protected DataReader importData() throws IOException
             System.gc();
             put("measurement.totalMB", Helper.getTotalMB());
             put("measurement.usedMB", Helper.getUsedMB());
-            try
-            {
+            try {
                 store(new FileWriter(propLocation), "measurement finish, "
                         + new Date().toString() + ", " + Constants.BUILD_DATE);
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 logger.error("Problem while storing properties " + graphLocation + ", " + propLocation, ex);
             }
         }
     }
 
-    void fillAllowedEdges( AllEdgesIterator iter, GHBitSet bs )
-    {
+    void fillAllowedEdges(AllEdgesIterator iter, GHBitSet bs) {
         bs.clear();
-        while (iter.next())
-        {
+        while (iter.next()) {
             bs.add(iter.getEdge());
         }
     }
 
-    private GHBitSet printGraphDetails( GraphHopperStorage g, String vehicleStr )
-    {
+    private GHBitSet printGraphDetails(GraphHopperStorage g, String vehicleStr) {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getMaxId());
@@ -181,18 +168,15 @@ private GHBitSet printGraphDetails( GraphHopperStorage g, String vehicleStr )
         return allowedEdges;
     }
 
-    private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
-    {
+    private void printLocationIndexQuery(Graph g, final LocationIndex idx, int count) {
         count *= 2;
         final BBox bbox = g.getBounds();
         final double latDelta = bbox.maxLat - bbox.minLat;
         final double lonDelta = bbox.maxLon - bbox.minLon;
         final Random rand = new Random(seed);
-        MiniPerfTest miniPerf = new MiniPerfTest()
-        {
+        MiniPerfTest miniPerf = new MiniPerfTest() {
             @Override
-            public int doCalc( boolean warmup, int run )
-            {
+            public int doCalc(boolean warmup, int run) {
                 double lat = rand.nextDouble() * latDelta + bbox.minLat;
                 double lon = rand.nextDouble() * lonDelta + bbox.minLon;
                 int val = idx.findClosest(lat, lon, EdgeFilter.ALL_EDGES).getClosestNode();
@@ -206,21 +190,17 @@ public int doCalc( boolean warmup, int run )
         print("location_index", miniPerf);
     }
 
-    private void printMiscUnitPerfTests( final Graph graph, boolean isCH, final FlagEncoder encoder,
-                                         int count, final GHBitSet allowedEdges )
-    {
+    private void printMiscUnitPerfTests(final Graph graph, boolean isCH, final FlagEncoder encoder,
+                                        int count, final GHBitSet allowedEdges) {
         final Random rand = new Random(seed);
         String description = "";
-        if (isCH)
-        {
+        if (isCH) {
             description = "CH";
             CHGraph lg = (CHGraph) graph;
             final CHEdgeExplorer chExplorer = lg.createEdgeExplorer(new LevelEdgeFilter(lg));
-            MiniPerfTest miniPerf = new MiniPerfTest()
-            {
+            MiniPerfTest miniPerf = new MiniPerfTest() {
                 @Override
-                public int doCalc( boolean warmup, int run )
-                {
+                public int doCalc(boolean warmup, int run) {
                     int nodeId = rand.nextInt(maxNode);
                     return GHUtility.count(chExplorer.setBaseNode(nodeId));
                 }
@@ -228,15 +208,12 @@ public int doCalc( boolean warmup, int run )
             print("unit_testsCH.level_edge_state_next", miniPerf);
 
             final CHEdgeExplorer chExplorer2 = lg.createEdgeExplorer();
-            miniPerf = new MiniPerfTest()
-            {
+            miniPerf = new MiniPerfTest() {
                 @Override
-                public int doCalc( boolean warmup, int run )
-                {
+                public int doCalc(boolean warmup, int run) {
                     int nodeId = rand.nextInt(maxNode);
                     CHEdgeIterator iter = chExplorer2.setBaseNode(nodeId);
-                    while (iter.next())
-                    {
+                    while (iter.next()) {
                         if (iter.isShortcut())
                             nodeId += (int) iter.getWeight();
                     }
@@ -248,11 +225,9 @@ public int doCalc( boolean warmup, int run )
 
         EdgeFilter outFilter = new DefaultEdgeFilter(encoder, false, true);
         final EdgeExplorer outExplorer = graph.createEdgeExplorer(outFilter);
-        MiniPerfTest miniPerf = new MiniPerfTest()
-        {
+        MiniPerfTest miniPerf = new MiniPerfTest() {
             @Override
-            public int doCalc( boolean warmup, int run )
-            {
+            public int doCalc(boolean warmup, int run) {
                 int nodeId = rand.nextInt(maxNode);
                 return GHUtility.count(outExplorer.setBaseNode(nodeId));
             }
@@ -260,11 +235,9 @@ public int doCalc( boolean warmup, int run )
         print("unit_tests" + description + ".out_edge_state_next", miniPerf);
 
         final EdgeExplorer allExplorer = graph.createEdgeExplorer();
-        miniPerf = new MiniPerfTest()
-        {
+        miniPerf = new MiniPerfTest() {
             @Override
-            public int doCalc( boolean warmup, int run )
-            {
+            public int doCalc(boolean warmup, int run) {
                 int nodeId = rand.nextInt(maxNode);
                 return GHUtility.count(allExplorer.setBaseNode(nodeId));
             }
@@ -272,13 +245,10 @@ public int doCalc( boolean warmup, int run )
         print("unit_tests" + description + ".all_edge_state_next", miniPerf);
 
         final int maxEdgesId = graph.getAllEdges().getMaxId();
-        miniPerf = new MiniPerfTest()
-        {
+        miniPerf = new MiniPerfTest() {
             @Override
-            public int doCalc( boolean warmup, int run )
-            {
-                while (true)
-                {
+            public int doCalc(boolean warmup, int run) {
+                while (true) {
                     int edgeId = rand.nextInt(maxEdgesId);
                     if (allowedEdges.contains(edgeId))
                         return graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE).getEdge();
@@ -288,9 +258,8 @@ public int doCalc( boolean warmup, int run )
         print("unit_tests" + description + ".get_edge_state", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, final boolean ch, int count, String prefix,
-                                        final String vehicle, final boolean withInstructions )
-    {
+    private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, int count, String prefix,
+                                       final String vehicle, final boolean withInstructions) {
         final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
@@ -309,11 +278,9 @@ private void printTimeOfRouteQuery( final GraphHopper hopper, final boolean ch,
 
         // if using none-bidirectional algorithm make sure you exclude CH routing
         final String algo = Algorithms.DIJKSTRA_BI;
-        MiniPerfTest miniPerf = new MiniPerfTest()
-        {
+        MiniPerfTest miniPerf = new MiniPerfTest() {
             @Override
-            public int doCalc( boolean warmup, int run )
-            {
+            public int doCalc(boolean warmup, int run) {
                 int from = rand.nextInt(maxNode);
                 int to = rand.nextInt(maxNode);
                 double fromLat = na.getLatitude(from);
@@ -331,18 +298,15 @@ public int doCalc( boolean warmup, int run )
                 // req.getHints().put(algo + ".epsilon", 2);
                 req.getHints().put("instructions", withInstructions);
                 GHResponse rsp;
-                try
-                {
+                try {
                     rsp = hopper.route(req);
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     // 'not found' can happen if import creates more than one subnetwork
                     throw new RuntimeException("Error while calculating route! "
                             + "nodes:" + from + " -> " + to + ", request:" + req, ex);
                 }
 
-                if (rsp.hasErrors())
-                {
+                if (rsp.hasErrors()) {
                     if (!warmup)
                         failedCount.incrementAndGet();
 
@@ -353,8 +317,7 @@ public int doCalc( boolean warmup, int run )
                 }
 
                 PathWrapper arsp = rsp.getBest();
-                if (!warmup)
-                {
+                if (!warmup) {
                     visitedNodesSum.addAndGet(rsp.getHints().getLong("visited_nodes.sum", 0));
                     long dist = (long) arsp.getDistance();
                     distSum.addAndGet(dist);
@@ -391,8 +354,7 @@ public int doCalc( boolean warmup, int run )
         print(prefix, miniPerf);
     }
 
-    void print( String prefix, MiniPerfTest perf )
-    {
+    void print(String prefix, MiniPerfTest perf) {
         logger.info(prefix + ": " + perf.getReport());
         put(prefix + ".sum", perf.getSum());
 //        put(prefix+".rms", perf.getRMS());
@@ -401,17 +363,14 @@ void print( String prefix, MiniPerfTest perf )
         put(prefix + ".max", perf.getMax());
     }
 
-    void put( String key, Object val )
-    {
+    void put(String key, Object val) {
         // convert object to string to make serialization possible
         properties.put(key, "" + val);
     }
 
-    private void store( FileWriter fileWriter, String comment ) throws IOException
-    {
+    private void store(FileWriter fileWriter, String comment) throws IOException {
         fileWriter.append("#" + comment + "\n");
-        for (Entry<String, String> e : properties.entrySet())
-        {
+        for (Entry<String, String> e : properties.entrySet()) {
             fileWriter.append(e.getKey());
             fileWriter.append("=");
             fileWriter.append(e.getValue());
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index d5a1044c32..3d24e4fb6c 100755
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -17,13 +17,10 @@
  */
 package com.graphhopper.tools;
 
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.*;
 import java.net.MalformedURLException;
@@ -34,21 +31,13 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Reads log files and queries any GraphHopper service
  * <p>
+ *
  * @author Peter Karich
  */
-public class QueryTorture
-{
-    public static void main( String[] args )
-    {
-        new QueryTorture().start(CmdArgs.read(args));
-    }
-
+public class QueryTorture {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private ExecutorService service;
     private BlockingQueue<Query> queryQueue;
@@ -66,12 +55,14 @@ public static void main( String[] args )
     private int statusUpdateCnt;
     private boolean logRequest = false;
 
-    public QueryTorture()
-    {
+    public QueryTorture() {
+    }
+
+    public static void main(String[] args) {
+        new QueryTorture().start(CmdArgs.read(args));
     }
 
-    public void start( CmdArgs cmdArgs )
-    {
+    public void start(CmdArgs cmdArgs) {
         String logfile = cmdArgs.get("logfile", "");
         int workers = cmdArgs.getInt("workers", 1);
         baseUrl = cmdArgs.get("baseurl", "");
@@ -82,8 +73,7 @@ public void start( CmdArgs cmdArgs )
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
-        if (!baseUrl.contains("?"))
-        {
+        if (!baseUrl.contains("?")) {
             if (!baseUrl.endsWith("/"))
                 baseUrl += "/";
             if (!baseUrl.endsWith("route/"))
@@ -105,11 +95,9 @@ public void start( CmdArgs cmdArgs )
 
         // start reading the logs and interrupt mainThread if no further entry available
         startReadingLogs(logfile);
-        try
-        {
+        try {
             mainThread.join();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             logger.info("End waiting", ex);
         }
 
@@ -126,34 +114,25 @@ public void start( CmdArgs cmdArgs )
         logger.info("mean query time in sec:" + sw.getSeconds() / successfullQueries.get());
     }
 
-    Thread startWorkers( final int workers )
-    {
-        Thread mainThread = new Thread("mainThread")
-        {
+    Thread startWorkers(final int workers) {
+        Thread mainThread = new Thread("mainThread") {
             @Override
-            public void run()
-            {
+            public void run() {
                 Collection<Callable<Object>> workerCollection = new ArrayList<Callable<Object>>(workers);
-                for (int i = 0; i < workers; i++)
-                {
+                for (int i = 0; i < workers; i++) {
                     final int workerNo = i;
-                    workerCollection.add(new Callable<Object>()
-                    {
+                    workerCollection.add(new Callable<Object>() {
                         @Override
-                        public Object call() throws Exception
-                        {
+                        public Object call() throws Exception {
                             workerStartedBarrier.countDown();
-                            try
-                            {
-                                while (!isInterrupted())
-                                {
+                            try {
+                                while (!isInterrupted()) {
                                     if (logfileEOFBarrier.getCount() == 0 && queryQueue.isEmpty())
                                         break;
 
                                     execute(workerNo);
                                 }
-                            } catch (Throwable ex)
-                            {
+                            } catch (Throwable ex) {
                                 logger.error(getName() + " - worker " + workerNo + " died", ex);
                             }
                             return null;
@@ -161,16 +140,13 @@ public Object call() throws Exception
                     });
                 }
                 service = Executors.newFixedThreadPool(workers);
-                try
-                {
+                try {
                     logger.info(getName() + " started with " + workers + " workers");
                     service.invokeAll(workerCollection);
                     logger.info(getName() + " FINISHED");
-                } catch (RejectedExecutionException ex)
-                {
+                } catch (RejectedExecutionException ex) {
                     logger.info(getName() + " cannot create threads", ex);
-                } catch (InterruptedException ex)
-                {
+                } catch (InterruptedException ex) {                    
                     // logger.info(getName() + " was interrupted", ex);
                 }
             }
@@ -179,11 +155,9 @@ public Object call() throws Exception
         return mainThread;
     }
 
-    void execute( int workerNo ) throws InterruptedException
-    {
+    void execute(int workerNo) throws InterruptedException {
         Query query = queryQueue.take();
-        try
-        {
+        try {
             String url = baseUrl + query.createQueryString();
             if (logRequest)
                 logger.info(url);
@@ -193,31 +167,24 @@ void execute( int workerNo ) throws InterruptedException
             else
                 successfullQueries.incrementAndGet();
 
-            if (successfullQueries.get() % statusUpdateCnt == 0)
-            {
+            if (successfullQueries.get() % statusUpdateCnt == 0) {
                 logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
             }
-        } catch (MalformedURLException ex)
-        {
+        } catch (MalformedURLException ex) {
             logger.error("Error while querying", ex);
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
 //            if (httpErrorCounter.get() % maxQueries == 0)
 //                logger.error("http error", ex);
             httpErrorCounter.incrementAndGet();
         }
     }
 
-    void startReadingLogs( final String logFile )
-    {
+    void startReadingLogs(final String logFile) {
         final DistanceCalc distCalc = new DistanceCalcEarth();
-        new Thread("readLogFile")
-        {
+        new Thread("readLogFile") {
             @Override
-            public void run()
-            {
-                try
-                {
+            public void run() {
+                try {
                     InputStream is;
                     if (logFile.endsWith(".gz"))
                         is = new GZIPInputStream(new FileInputStream(logFile));
@@ -225,18 +192,15 @@ public void run()
                         is = new FileInputStream(logFile);
 
                     BufferedReader reader = new BufferedReader(new InputStreamReader(is, Helper.UTF_CS));
-                    try
-                    {
+                    try {
                         String logLine;
-                        while ((logLine = reader.readLine()) != null)
-                        {
+                        while ((logLine = reader.readLine()) != null) {
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
 
                             double dist = distCalc.calcDist(q.start.lat, q.start.lon, q.end.lat, q.end.lon);
-                            if (dist < 100)
-                            {
+                            if (dist < 100) {
                                 skippedTooShort++;
                                 continue;
                             }
@@ -246,8 +210,7 @@ public void run()
                             if (noDuplicate.add(q))
                                 queryQueue.put(q);
                         }
-                    } finally
-                    {
+                    } finally {
                         reader.close();
                     }
 
@@ -259,8 +222,7 @@ public void run()
                     logfileEOFBarrier.countDown();
                     // now wait for termination
                     service.shutdown();
-                } catch (Exception ex)
-                {
+                } catch (Exception ex) {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
                     if (service != null)
@@ -270,15 +232,13 @@ public void run()
         }.start();
     }
 
-    static class Query
-    {
+    static class Query {
         GHPoint start;
         GHPoint end;
         List<String> points = new ArrayList<String>();
         Map<String, String> params = new HashMap<String, String>();
 
-        static Query parse( String logLine )
-        {
+        static Query parse(String logLine) {
             String START = "GHBaseServlet - ";
             int index = logLine.indexOf(START);
             if (index < 0)
@@ -292,16 +252,14 @@ static Query parse( String logLine )
             Query q = new Query();
             String queryString = logLine.substring(0, index);
             String[] tmpStrings = queryString.split("\\&");
-            for (String paramStr : tmpStrings)
-            {
+            for (String paramStr : tmpStrings) {
                 int equalIndex = paramStr.indexOf("=");
                 if (equalIndex <= 0)
                     continue;
 
                 String key = paramStr.substring(0, equalIndex);
                 String value = paramStr.substring(equalIndex + 1);
-                if (!paramStr.startsWith("point="))
-                {
+                if (!paramStr.startsWith("point=")) {
                     q.params.put(key, value);
                     continue;
                 }
@@ -323,23 +281,27 @@ else if (q.end == null)
             return null;
         }
 
-        public void put( String key, String value )
-        {
+        static String encodeURL(String str) {
+            try {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore) {
+                return str;
+            }
+        }
+
+        public void put(String key, String value) {
             params.put(key, value);
         }
 
-        public String createQueryString()
-        {
+        public String createQueryString() {
             String qStr = "";
-            for (String pointStr : points)
-            {
+            for (String pointStr : points) {
                 if (!qStr.isEmpty())
                     qStr += "&";
 
                 qStr += "point=" + encodeURL(pointStr);
             }
-            for (Entry<String, String> e : params.entrySet())
-            {
+            for (Entry<String, String> e : params.entrySet()) {
                 if (!qStr.isEmpty())
                     qStr += "&";
 
@@ -349,20 +311,8 @@ public String createQueryString()
             return qStr;
         }
 
-        static String encodeURL( String str )
-        {
-            try
-            {
-                return URLEncoder.encode(str, "UTF-8");
-            } catch (Exception _ignore)
-            {
-                return str;
-            }
-        }
-
         @Override
-        public String toString()
-        {
+        public String toString() {
             return createQueryString();
         }
     }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 81b42940f2..367a82b5ce 100755
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -18,41 +18,34 @@
 package com.graphhopper.ui;
 
 import com.graphhopper.routing.AStar;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.awt.Color;
-import java.awt.Graphics2D;
+import java.awt.*;
 
 /**
  * @author Peter Karich
  */
-public class DebugAStar extends AStar implements DebugAlgo
-{
-    private GraphicsWrapper mg;
+public class DebugAStar extends AStar implements DebugAlgo {
+    private final GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStar( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
-    {
-        super(graph, encoder, type, tMode);
+    public DebugAStar(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
+        super(graph, type, tMode);
         this.mg = mg;
     }
 
     @Override
-    public void setGraphics2D( Graphics2D g2 )
-    {
+    public void setGraphics2D(Graphics2D g2) {
         this.g2 = g2;
     }
 
     @Override
-    public void updateBestPath( EdgeIteratorState es, SPTEntry bestEE, int currLoc )
-    {
-        if (g2 != null)
-        {
+    public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
+        if (g2 != null) {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
         super.updateBestPath(es, bestEE, currLoc);
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index 6a7a21b1a9..c273f83fdf 100755
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -18,41 +18,34 @@
 package com.graphhopper.ui;
 
 import com.graphhopper.routing.AStarBidirection;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.awt.Color;
-import java.awt.Graphics2D;
+import java.awt.*;
 
 /**
  * @author Peter Karich
  */
-public class DebugAStarBi extends AStarBidirection implements DebugAlgo
-{
-    private GraphicsWrapper mg;
+public class DebugAStarBi extends AStarBidirection implements DebugAlgo {
+    private final GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStarBi( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
-    {
-        super(graph, encoder, type, tMode);
+    public DebugAStarBi(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
+        super(graph, type, tMode);
         this.mg = mg;
     }
 
     @Override
-    public void setGraphics2D( Graphics2D g2 )
-    {
+    public void setGraphics2D(Graphics2D g2) {
         this.g2 = g2;
     }
 
     @Override
-    public void updateBestPath( EdgeIteratorState es, SPTEntry bestEE, int currLoc )
-    {
-        if (g2 != null)
-        {
+    public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
+        if (g2 != null) {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
         super.updateBestPath(es, bestEE, currLoc);
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAlgo.java b/tools/src/main/java/com/graphhopper/ui/DebugAlgo.java
index 5964ddb251..7e6a39d0f1 100755
--- a/tools/src/main/java/com/graphhopper/ui/DebugAlgo.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAlgo.java
@@ -17,12 +17,11 @@
  */
 package com.graphhopper.ui;
 
-import java.awt.Graphics2D;
+import java.awt.*;
 
 /**
  * @author Peter Karich
  */
-public interface DebugAlgo
-{
-    void setGraphics2D( Graphics2D g2 );
+public interface DebugAlgo {
+    void setGraphics2D(Graphics2D g2);
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index 9dc8dbac65..57399b1105 100755
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -18,41 +18,34 @@
 package com.graphhopper.ui;
 
 import com.graphhopper.routing.DijkstraBidirectionRef;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.awt.Color;
-import java.awt.Graphics2D;
+import java.awt.*;
 
 /**
  * @author Peter Karich
  */
-public class DebugDijkstraBidirection extends DijkstraBidirectionRef implements DebugAlgo
-{
-    private GraphicsWrapper mg;
+public class DebugDijkstraBidirection extends DijkstraBidirectionRef implements DebugAlgo {
+    private final GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
-    {
-        super(graph, encoder, type, tMode);
+    public DebugDijkstraBidirection(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
+        super(graph, type, tMode);
         this.mg = mg;
     }
 
     @Override
-    public void setGraphics2D( Graphics2D g2 )
-    {
+    public void setGraphics2D(Graphics2D g2) {
         this.g2 = g2;
     }
 
     @Override
-    public void updateBestPath( EdgeIteratorState es, SPTEntry bestEE, int currLoc )
-    {
-        if (g2 != null)
-        {
+    public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
+        if (g2 != null) {
             mg.plotNode(g2, currLoc, Color.BLUE);
         }
         // System.out.println("new node:" + currLoc);
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index a21167e6db..5159811a16 100755
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -18,41 +18,34 @@
 package com.graphhopper.ui;
 
 import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.awt.Color;
-import java.awt.Graphics2D;
+import java.awt.*;
 
 /**
  * @author Peter Karich
  */
-public class DebugDijkstraSimple extends Dijkstra implements DebugAlgo
-{
-    private GraphicsWrapper mg;
+public class DebugDijkstraSimple extends Dijkstra implements DebugAlgo {
+    private final GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraSimple( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode, GraphicsWrapper mg )
-    {
-        super(graph, encoder, weighting, tMode);
+    public DebugDijkstraSimple(Graph graph, Weighting weighting, TraversalMode tMode, GraphicsWrapper mg) {
+        super(graph, weighting, tMode);
         this.mg = mg;
     }
 
     @Override
-    public void setGraphics2D( Graphics2D g2 )
-    {
+    public void setGraphics2D(Graphics2D g2) {
         this.g2 = g2;
     }
 
     @Override
-    public void updateBestPath( EdgeIteratorState es, SPTEntry bestEE, int currLoc )
-    {
-        if (g2 != null)
-        {
+    public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
+        if (g2 != null) {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
         super.updateBestPath(es, bestEE, currLoc);
diff --git a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
index 7b97fe2a22..fb496a5268 100755
--- a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
+++ b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
@@ -17,108 +17,89 @@
  */
 package com.graphhopper.ui;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.awt.image.RescaleOp;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * @author Peter Karich
  */
-public abstract class DefaultMapLayer implements MapLayer
-{
+public abstract class DefaultMapLayer implements MapLayer {
+    protected BufferedImage image;
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Rectangle bounds = new Rectangle();
     private Graphics2D tmpG;
-    protected BufferedImage image;
     private boolean buffering = true;
     // a bit transparent:
 //    private RescaleOp op = new RescaleOp(new float[]{1f, 1f, 1f, 0.5f}, new float[4], null);
-    private RescaleOp op = new RescaleOp(new float[]
-            {
-                    1f, 1f, 1f, 1f
-            }, new float[4], null);
+    private RescaleOp op = new RescaleOp(new float[]{1f, 1f, 1f, 1f}, new float[4], null);
 
-    protected abstract void paintComponent( Graphics2D createGraphics );
+    protected abstract void paintComponent(Graphics2D createGraphics);
 
     @Override
-    public void paint( Graphics2D mainGraphics )
-    {
-        if (!buffering)
-        {
-            try
-            {
+    public void paint(Graphics2D mainGraphics) {
+        if (!buffering) {
+            try {
                 paintComponent(mainGraphics);
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 logger.error("Problem in paintComponent", ex);
             }
             return;
         }
-        if (image != null)
-        {
+        if (image != null) {
             mainGraphics.drawImage(image, op, bounds.x, bounds.y);
         }
     }
 
     @Override
-    public void setBuffering( boolean enable )
-    {
+    public void setBuffering(boolean enable) {
         buffering = enable;
     }
 
     @Override
-    public final void repaint()
-    {
-        if (tmpG != null)
-        {
+    public final void repaint() {
+        if (tmpG != null) {
             paintComponent(tmpG);
         }
     }
 
     @Override
-    public Rectangle getBounds()
-    {
+    public Rectangle getBounds() {
         return bounds;
     }
 
-    public void makeTransparent( Graphics2D g2 )
-    {
+    @Override
+    public void setBounds(Rectangle bounds) {
+        if (image == null || image.getHeight() != bounds.height || image.getWidth() != bounds.width) {
+            image = new BufferedImage(bounds.width, bounds.height, BufferedImage.TYPE_INT_ARGB);
+            tmpG = image.createGraphics();
+            tmpG.setColor(Color.BLACK);
+            tmpG.setBackground(Color.WHITE);
+        }
+        this.bounds = bounds;
+        repaint();
+    }
+
+    public void makeTransparent(Graphics2D g2) {
         Color col = g2.getColor();
         Composite comp = null;
         // force transparence of this layer only. If no buffering we would clear layers below
-        if (buffering)
-        {
+        if (buffering) {
             comp = g2.getComposite();
             g2.setComposite(AlphaComposite.Clear);
         }
         g2.setColor(new Color(0, 0, 0, 0));
         g2.fillRect(0, 0, bounds.width, bounds.height);
         g2.setColor(col);
-        if (comp != null)
-        {
+        if (comp != null) {
             g2.setComposite(comp);
         }
     }
 
-    public void clearGraphics( Graphics2D g2 )
-    {
+    public void clearGraphics(Graphics2D g2) {
         g2.clearRect(0, 0, bounds.width, bounds.height);
     }
-
-    @Override
-    public void setBounds( Rectangle bounds )
-    {
-        if (image == null || image.getHeight() != bounds.height || image.getWidth() != bounds.width)
-        {
-            image = new BufferedImage(bounds.width, bounds.height, BufferedImage.TYPE_INT_ARGB);
-            tmpG = image.createGraphics();
-            tmpG.setColor(Color.BLACK);
-            tmpG.setBackground(Color.WHITE);
-        }
-        this.bounds = bounds;
-        repaint();
-    }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index c4dc898f20..ad2a1b7f45 100755
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -20,19 +20,15 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.shapes.BBox;
-
-import java.awt.BasicStroke;
-import java.awt.Color;
-import java.awt.Graphics2D;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.awt.*;
+
 /**
  * @author Peter Karich
  */
-public class GraphicsWrapper
-{
+public class GraphicsWrapper {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final NodeAccess na;
     private double scaleX;
@@ -41,8 +37,7 @@
     private double offsetY;
     private BBox bounds = new BBox(-180, 180, -90, 90);
 
-    public GraphicsWrapper( Graph g )
-    {
+    public GraphicsWrapper(Graph g) {
         this.na = g.getNodeAccess();
         BBox b = g.getBounds();
         scaleX = scaleY = 0.002 * (b.maxLat - b.minLat);
@@ -50,68 +45,55 @@ public GraphicsWrapper( Graph g )
         offsetX = -b.minLon;
     }
 
-    public double getOffsetX()
-    {
+    public double getOffsetX() {
         return offsetX;
     }
 
-    public double getOffsetY()
-    {
+    public double getOffsetY() {
         return offsetY;
     }
 
-    public double getScaleX()
-    {
+    public double getScaleX() {
         return scaleX;
     }
 
-    public double getScaleY()
-    {
+    public double getScaleY() {
         return scaleY;
     }
 
-    public void plotText( Graphics2D g2, double lat, double lon, String text )
-    {
+    public void plotText(Graphics2D g2, double lat, double lon, String text) {
         g2.drawString(text, (int) getX(lon) + 5, (int) getY(lat) + 5);
     }
 
-    public void plotEdge( Graphics2D g2, double lat, double lon, double lat2, double lon2, float width )
-    {
+    public void plotEdge(Graphics2D g2, double lat, double lon, double lat2, double lon2, float width) {
         g2.setStroke(new BasicStroke(width));
         g2.drawLine((int) getX(lon), (int) getY(lat), (int) getX(lon2), (int) getY(lat2));
     }
 
-    public void plotEdge( Graphics2D g2, double lat, double lon, double lat2, double lon2 )
-    {
+    public void plotEdge(Graphics2D g2, double lat, double lon, double lat2, double lon2) {
         plotEdge(g2, lat, lon, lat2, lon2, 1);
     }
 
-    public double getX( double lon )
-    {
+    public double getX(double lon) {
         return (lon + offsetX) / scaleX;
     }
 
-    public double getY( double lat )
-    {
+    public double getY(double lat) {
         return (90 - lat + offsetY) / scaleY;
     }
 
-    public double getLon( int x )
-    {
+    public double getLon(int x) {
         return x * scaleX - offsetX;
     }
 
-    public double getLat( int y )
-    {
+    public double getLat(int y) {
         return 90 - (y * scaleY - offsetY);
     }
 
-    public void plotNode( Graphics2D g2, int loc, Color c )
-    {
+    public void plotNode(Graphics2D g2, int loc, Color c) {
         double lat = na.getLatitude(loc);
         double lon = na.getLongitude(loc);
-        if (lat < bounds.minLat || lat > bounds.maxLat || lon < bounds.minLon || lon > bounds.maxLon)
-        {
+        if (lat < bounds.minLat || lat > bounds.maxLat || lon < bounds.minLon || lon > bounds.maxLon) {
             return;
         }
 
@@ -121,43 +103,36 @@ public void plotNode( Graphics2D g2, int loc, Color c )
         g2.setColor(old);
     }
 
-    public void plot( Graphics2D g2, double lat, double lon, int width )
-    {
+    public void plot(Graphics2D g2, double lat, double lon, int width) {
         double x = getX(lon);
         double y = getY(lat);
         g2.fillOval((int) x, (int) y, width, width);
     }
 
-    void scale( int x, int y, boolean zoomIn )
-    {
+    void scale(int x, int y, boolean zoomIn) {
         double tmpFactor = 0.5f;
-        if (!zoomIn)
-        {
+        if (!zoomIn) {
             tmpFactor = 2;
         }
 
         double oldScaleX = scaleX;
         double oldScaleY = scaleY;
         double resX = scaleX * tmpFactor;
-        if (resX > 0)
-        {
+        if (resX > 0) {
             scaleX = resX;
         }
 
         double resY = scaleY * tmpFactor;
-        if (resY > 0)
-        {
+        if (resY > 0) {
             scaleY = resY;
         }
 
         // respect mouse x,y when scaling
         // TODO minor bug: compute difference of lat,lon position for mouse before and after scaling
-        if (zoomIn)
-        {
+        if (zoomIn) {
             offsetX -= (offsetX + x) * scaleX;
             offsetY -= (offsetY + y) * scaleY;
-        } else
-        {
+        } else {
             offsetX += x * oldScaleX;
             offsetY += y * oldScaleY;
         }
@@ -166,14 +141,12 @@ void scale( int x, int y, boolean zoomIn )
                 + " " + scaleX + "," + scaleY);
     }
 
-    public void setNewOffset( int offX, int offY )
-    {
+    public void setNewOffset(int offX, int offY) {
         offsetX += offX * scaleX;
         offsetY += offY * scaleY;
     }
 
-    public BBox setBounds( int minX, int maxX, int minY, int maxY )
-    {
+    public BBox setBounds(int minX, int maxX, int minY, int maxY) {
         double minLon = getLon(minX);
         double maxLon = getLon(maxX);
 
diff --git a/tools/src/main/java/com/graphhopper/ui/LayeredPanel.java b/tools/src/main/java/com/graphhopper/ui/LayeredPanel.java
index c19c871187..f1a0cb5537 100755
--- a/tools/src/main/java/com/graphhopper/ui/LayeredPanel.java
+++ b/tools/src/main/java/com/graphhopper/ui/LayeredPanel.java
@@ -17,38 +17,32 @@
  */
 package com.graphhopper.ui;
 
+import javax.swing.*;
 import java.awt.*;
-import java.util.Collection;
 import java.awt.event.ComponentAdapter;
 import java.awt.event.ComponentEvent;
 import java.util.ArrayList;
-import javax.swing.JPanel;
+import java.util.Collection;
 
 /**
  * @author Peter Karich
  */
-public class LayeredPanel extends JPanel
-{
+public class LayeredPanel extends JPanel {
     private final Collection<MapLayer> layers;
 
-    public LayeredPanel()
-    {
+    public LayeredPanel() {
         this(new ArrayList<MapLayer>());
     }
 
-    public LayeredPanel( Collection<MapLayer> layer )
-    {
+    public LayeredPanel(Collection<MapLayer> layer) {
         this.layers = layer;
-        this.addComponentListener(new ComponentAdapter()
-        {
+        this.addComponentListener(new ComponentAdapter() {
             @Override
-            public void componentResized( ComponentEvent e )
-            {
+            public void componentResized(ComponentEvent e) {
                 int w = e.getComponent().getWidth();
                 int h = e.getComponent().getHeight();
                 System.out.println("mainResized:" + w + " " + h);
-                for (MapLayer ml : layers)
-                {
+                for (MapLayer ml : layers) {
                     ml.setBounds(new Rectangle(0, 0, w, h));
                 }
                 repaint();
@@ -56,22 +50,18 @@ public void componentResized( ComponentEvent e )
         });
     }
 
-    public void setBuffering( boolean enable )
-    {
-        for (MapLayer ml : layers)
-        {
+    public void setBuffering(boolean enable) {
+        for (MapLayer ml : layers) {
             ml.setBuffering(enable);
         }
     }
 
-    public void addLayer( MapLayer ml )
-    {
+    public void addLayer(MapLayer ml) {
         layers.add(ml);
     }
 
     @Override
-    protected void paintComponent( Graphics g )
-    {
+    protected void paintComponent(Graphics g) {
         super.paintComponent(g);
         Graphics2D g2 = (Graphics2D) g;
 //        StopWatch sw = new StopWatch();
@@ -81,8 +71,7 @@ protected void paintComponent( Graphics g )
 //        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
 //        g2.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED);
 //        int counter = 0;
-        for (MapLayer ml : layers)
-        {
+        for (MapLayer ml : layers) {
 //            sw.start();
             ml.paint(g2);
 //            System.out.println(++counter + " | mainRepaint took " + sw.stop().getSeconds() + " sec");
diff --git a/tools/src/main/java/com/graphhopper/ui/MapLayer.java b/tools/src/main/java/com/graphhopper/ui/MapLayer.java
index 67f752eca1..2d609c7895 100755
--- a/tools/src/main/java/com/graphhopper/ui/MapLayer.java
+++ b/tools/src/main/java/com/graphhopper/ui/MapLayer.java
@@ -17,22 +17,20 @@
  */
 package com.graphhopper.ui;
 
-import java.awt.Graphics2D;
-import java.awt.Rectangle;
+import java.awt.*;
 import java.io.Serializable;
 
 /**
  * @author Peter Karich
  */
-public interface MapLayer extends Serializable
-{
-    void setBounds( Rectangle r );
-
+public interface MapLayer extends Serializable {
     Rectangle getBounds();
 
-    void setBuffering( boolean enable );
+    void setBounds(Rectangle r);
+
+    void setBuffering(boolean enable);
 
     void repaint();
 
-    void paint( Graphics2D g );
+    void paint(Graphics2D g);
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 4efe773a9e..75e9ebe393 100755
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -21,7 +21,10 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndexTree;
@@ -30,14 +33,16 @@
 import com.graphhopper.util.Parameters.Algorithms;
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
+import javax.swing.*;
 import java.awt.*;
-import java.awt.event.*;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseWheelEvent;
+import java.awt.event.MouseWheelListener;
 import java.util.Random;
-import javax.swing.*;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * A rough graphical user interface for visualizing the OSM graph. Mainly for debugging algorithms
@@ -46,44 +51,40 @@
  * <p>
  * Use the web module for a better/faster/userfriendly/... alternative!
  * <p>
+ *
  * @author Peter Karich
  */
-public class MiniGraphUI
-{
-    public static void main( String[] strs ) throws Exception
-    {
-        CmdArgs args = CmdArgs.read(strs);
-        GraphHopper hopper = new GraphHopper().init(args).importOrLoad();
-        boolean debug = args.getBool("minigraphui.debug", false);
-        new MiniGraphUI(hopper, debug).visualize();
-    }
-
+public class MiniGraphUI {
+    private final Graph graph;
+    private final NodeAccess na;
+    private final MapLayer pathLayer;
+    private final Weighting weighting;
+    private final FlagEncoder encoder;
+    // for moving
+    int currentPosX;
+    int currentPosY;
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
     private RoutingAlgorithmFactory algoFactory;
-    private final Graph graph;
-    private final NodeAccess na;
     private LocationIndexTree index;
     private String latLon = "";
     private GraphicsWrapper mg;
     private JPanel infoPanel;
     private LayeredPanel mainPanel;
     private MapLayer roadsLayer;
-    private final MapLayer pathLayer;
     private boolean fastPaint = false;
-    private final Weighting weighting;
-    private final FlagEncoder encoder;
     private AlgorithmOptions algoOpts;
+    private QueryResult fromRes;
+    private QueryResult toRes;
 
-    public MiniGraphUI( GraphHopper hopper, boolean debug )
-    {
+    public MiniGraphUI(GraphHopper hopper, boolean debug) {
         this.graph = hopper.getGraphHopperStorage();
         this.na = graph.getNodeAccess();
         encoder = hopper.getEncodingManager().getEncoder("car");
         HintsMap map = new HintsMap("fastest");
         weighting = hopper.createWeighting(map, encoder);
         algoFactory = hopper.getAlgorithmFactory(map);
-        algoOpts = new AlgorithmOptions(Algorithms.DIJKSTRA_BI, encoder, weighting);
+        algoOpts = new AlgorithmOptions(Algorithms.DIJKSTRA_BI, weighting);
 
         logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
@@ -97,11 +98,9 @@ public MiniGraphUI( GraphHopper hopper, boolean debug )
 //        this.algo = new AStar(graph);
 //        this.algo = new DijkstraSimple(graph);
 //        this.algo = new DebugDijkstraSimple(graph, mg);
-        infoPanel = new JPanel()
-        {
+        infoPanel = new JPanel() {
             @Override
-            protected void paintComponent( Graphics g )
-            {
+            protected void paintComponent(Graphics g) {
                 g.setColor(Color.WHITE);
                 Rectangle b = infoPanel.getBounds();
                 g.fillRect(0, 0, b.width, b.height);
@@ -119,19 +118,16 @@ protected void paintComponent( Graphics g )
 
         // TODO make it correct with bitset-skipping too
         final GHBitSet bitset = new GHTBitSet(graph.getNodes());
-        mainPanel.addLayer(roadsLayer = new DefaultMapLayer()
-        {
+        mainPanel.addLayer(roadsLayer = new DefaultMapLayer() {
             Random rand = new Random();
 
             @Override
-            public void paintComponent( Graphics2D g2 )
-            {
+            public void paintComponent(Graphics2D g2) {
                 clearGraphics(g2);
                 int locs = graph.getNodes();
                 Rectangle d = getBounds();
                 BBox b = mg.setBounds(0, d.width, 0, d.height);
-                if (fastPaint)
-                {
+                if (fastPaint) {
                     rand.setSeed(0);
                     bitset.clear();
                 }
@@ -153,8 +149,7 @@ public void paintComponent( Graphics2D g2 )
                 EdgeExplorer explorer = graph.createEdgeExplorer(EdgeFilter.ALL_EDGES);
                 Color[] speedColors = generateColors(15);
 
-                for (int nodeIndex = 0; nodeIndex < locs; nodeIndex++)
-                {
+                for (int nodeIndex = 0; nodeIndex < locs; nodeIndex++) {
                     if (fastPaint && rand.nextInt(30) > 1)
                         continue;
                     double lat = na.getLatitude(nodeIndex);
@@ -165,12 +160,10 @@ public void paintComponent( Graphics2D g2 )
                         continue;
 
                     EdgeIterator edge = explorer.setBaseNode(nodeIndex);
-                    while (edge.next())
-                    {
+                    while (edge.next()) {
                         int nodeId = edge.getAdjNode();
                         int sum = nodeIndex + nodeId;
-                        if (fastPaint)
-                        {
+                        if (fastPaint) {
                             if (bitset.contains(sum))
                                 continue;
 
@@ -183,30 +176,22 @@ public void paintComponent( Graphics2D g2 )
                         //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
                         double speed = encoder.getSpeed(edge.getFlags());
                         Color color;
-                        if (speed >= 120)
-                        {
+                        if (speed >= 120) {
                             // red
                             color = speedColors[12];
-                        } else if (speed >= 100)
-                        {
+                        } else if (speed >= 100) {
                             color = speedColors[10];
-                        } else if (speed >= 80)
-                        {
+                        } else if (speed >= 80) {
                             color = speedColors[8];
-                        } else if (speed >= 60)
-                        {
+                        } else if (speed >= 60) {
                             color = speedColors[6];
-                        } else if (speed >= 50)
-                        {
+                        } else if (speed >= 50) {
                             color = speedColors[5];
-                        } else if (speed >= 40)
-                        {
+                        } else if (speed >= 40) {
                             color = speedColors[4];
-                        } else if (speed >= 30)
-                        {
+                        } else if (speed >= 30) {
                             color = Color.GRAY;
-                        } else
-                        {
+                        } else {
                             color = Color.LIGHT_GRAY;
                         }
 
@@ -217,8 +202,7 @@ public void paintComponent( Graphics2D g2 )
 
                 g2.setColor(Color.WHITE);
                 g2.fillRect(0, 0, 1000, 20);
-                for (int i = 4; i < speedColors.length; i++)
-                {
+                for (int i = 4; i < speedColors.length; i++) {
                     g2.setColor(speedColors[i]);
                     g2.drawString("" + (i * 10), i * 30 - 100, 10);
                 }
@@ -227,19 +211,16 @@ public void paintComponent( Graphics2D g2 )
             }
         });
 
-        mainPanel.addLayer(pathLayer = new DefaultMapLayer()
-        {
+        mainPanel.addLayer(pathLayer = new DefaultMapLayer() {
             @Override
-            public void paintComponent( Graphics2D g2 )
-            {
+            public void paintComponent(Graphics2D g2) {
                 if (fromRes == null || toRes == null)
                     return;
 
                 makeTransparent(g2);
                 QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
                 RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
-                if (algo instanceof DebugAlgo)
-                {
+                if (algo instanceof DebugAlgo) {
                     ((DebugAlgo) algo).setGraphics2D(g2);
                 }
 
@@ -264,8 +245,7 @@ public void paintComponent( Graphics2D g2 )
                 sw.stop();
 
                 // if directed edges
-                if (!path.isFound())
-                {
+                if (!path.isFound()) {
                     logger.warn("path not found! direction not valid?");
                     return;
                 }
@@ -277,8 +257,7 @@ public void paintComponent( Graphics2D g2 )
             }
         });
 
-        if (debug)
-        {
+        if (debug) {
             // disable double buffering for debugging drawing - nice! when do we need DebugGraphics then?
             RepaintManager repaintManager = RepaintManager.currentManager(mainPanel);
             repaintManager.setDoubleBufferingEnabled(false);
@@ -286,19 +265,23 @@ public void paintComponent( Graphics2D g2 )
         }
     }
 
-    public Color[] generateColors( int n )
-    {
+    public static void main(String[] strs) throws Exception {
+        CmdArgs args = CmdArgs.read(strs);
+        GraphHopper hopper = new GraphHopper().init(args).importOrLoad();
+        boolean debug = args.getBool("minigraphui.debug", false);
+        new MiniGraphUI(hopper, debug).visualize();
+    }
+
+    public Color[] generateColors(int n) {
         Color[] cols = new Color[n];
-        for (int i = 0; i < n; i++)
-        {
+        for (int i = 0; i < n; i++) {
             cols[i] = Color.getHSBColor((float) i / (float) n, 0.85f, 1.0f);
         }
         return cols;
     }
 
     // for debugging
-    private Path calcPath( RoutingAlgorithm algo )
-    {
+    private Path calcPath(RoutingAlgorithm algo) {
 //        int from = index.findID(50.042, 10.19);
 //        int to = index.findID(50.049, 10.23);
 //
@@ -310,17 +293,14 @@ private Path calcPath( RoutingAlgorithm algo )
         return algo.calcPath(162810, 35120);
     }
 
-    void plotNodeName( Graphics2D g2, int node )
-    {
+    void plotNodeName(Graphics2D g2, int node) {
         double lat = na.getLatitude(node);
         double lon = na.getLongitude(node);
         mg.plotText(g2, lat, lon, "" + node);
     }
 
-    private Path plotPath( Path tmpPath, Graphics2D g2, int w )
-    {
-        if (!tmpPath.isFound())
-        {
+    private Path plotPath(Path tmpPath, Graphics2D g2, int w) {
+        if (!tmpPath.isFound()) {
             logger.info("nothing found " + w);
             return tmpPath;
         }
@@ -329,23 +309,18 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
         double prevLon = Double.NaN;
         boolean plotNodes = false;
         TIntList nodes = tmpPath.calcNodes();
-        if (plotNodes)
-        {
-            for (int i = 0; i < nodes.size(); i++)
-            {
+        if (plotNodes) {
+            for (int i = 0; i < nodes.size(); i++) {
                 plotNodeName(g2, nodes.get(i));
             }
         }
         PointList list = tmpPath.calcPoints();
-        for (int i = 0; i < list.getSize(); i++)
-        {
+        for (int i = 0; i < list.getSize(); i++) {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (!Double.isNaN(prevLat))
-            {
+            if (!Double.isNaN(prevLat)) {
                 mg.plotEdge(g2, prevLat, prevLon, lat, lon, w);
-            } else
-            {
+            } else {
                 mg.plot(g2, lat, lon, w);
             }
             prevLat = lat;
@@ -355,18 +330,11 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
         return tmpPath;
     }
 
-    private QueryResult fromRes;
-    private QueryResult toRes;
-
-    public void visualize()
-    {
-        try
-        {
-            SwingUtilities.invokeAndWait(new Runnable()
-            {
+    public void visualize() {
+        try {
+            SwingUtilities.invokeAndWait(new Runnable() {
                 @Override
-                public void run()
-                {
+                public void run() {
                     int frameHeight = 800;
                     int frameWidth = 1200;
                     JFrame frame = new JFrame("GraphHopper UI - Small&Ugly ;)");
@@ -377,11 +345,9 @@ public void run()
                     infoPanel.setPreferredSize(new Dimension(300, 100));
 
                     // scale
-                    mainPanel.addMouseWheelListener(new MouseWheelListener()
-                    {
+                    mainPanel.addMouseWheelListener(new MouseWheelListener() {
                         @Override
-                        public void mouseWheelMoved( MouseWheelEvent e )
-                        {
+                        public void mouseWheelMoved(MouseWheelEvent e) {
                             mg.scale(e.getX(), e.getY(), e.getWheelRotation() < 0);
                             repaintRoads();
                         }
@@ -405,21 +371,18 @@ public void mouseWheelMoved( MouseWheelEvent e )
 //                            updateLatLon(e);
 //                        }
 //                    };
-                    MouseAdapter ml = new MouseAdapter()
-                    {
+                    MouseAdapter ml = new MouseAdapter() {
                         // for routing:
                         double fromLat, fromLon;
                         boolean fromDone = false;
+                        boolean dragging = false;
 
                         @Override
-                        public void mouseClicked( MouseEvent e )
-                        {
-                            if (!fromDone)
-                            {
+                        public void mouseClicked(MouseEvent e) {
+                            if (!fromDone) {
                                 fromLat = mg.getLat(e.getY());
                                 fromLon = mg.getLon(e.getX());
-                            } else
-                            {
+                            } else {
                                 double toLat = mg.getLat(e.getY());
                                 double toLon = mg.getLon(e.getX());
                                 StopWatch sw = new StopWatch().start();
@@ -436,11 +399,8 @@ public void mouseClicked( MouseEvent e )
                             fromDone = !fromDone;
                         }
 
-                        boolean dragging = false;
-
                         @Override
-                        public void mouseDragged( MouseEvent e )
-                        {
+                        public void mouseDragged(MouseEvent e) {
                             dragging = true;
                             fastPaint = true;
                             update(e);
@@ -448,10 +408,8 @@ public void mouseDragged( MouseEvent e )
                         }
 
                         @Override
-                        public void mouseReleased( MouseEvent e )
-                        {
-                            if (dragging)
-                            {
+                        public void mouseReleased(MouseEvent e) {
+                            if (dragging) {
                                 // update only if mouse release comes from dragging! (at the moment equal to fastPaint)
                                 dragging = false;
                                 fastPaint = false;
@@ -459,21 +417,18 @@ public void mouseReleased( MouseEvent e )
                             }
                         }
 
-                        public void update( MouseEvent e )
-                        {
+                        public void update(MouseEvent e) {
                             mg.setNewOffset(e.getX() - currentPosX, e.getY() - currentPosY);
                             repaintRoads();
                         }
 
                         @Override
-                        public void mouseMoved( MouseEvent e )
-                        {
+                        public void mouseMoved(MouseEvent e) {
                             updateLatLon(e);
                         }
 
                         @Override
-                        public void mousePressed( MouseEvent e )
-                        {
+                        public void mousePressed(MouseEvent e) {
                             updateLatLon(e);
                         }
                     };
@@ -501,32 +456,24 @@ public void mousePressed( MouseEvent e )
                     frame.setVisible(true);
                 }
             });
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    // for moving
-    int currentPosX;
-    int currentPosY;
-
-    void updateLatLon( MouseEvent e )
-    {
+    void updateLatLon(MouseEvent e) {
         latLon = mg.getLat(e.getY()) + "," + mg.getLon(e.getX());
         infoPanel.repaint();
         currentPosX = e.getX();
         currentPosY = e.getY();
     }
 
-    void repaintPaths()
-    {
+    void repaintPaths() {
         pathLayer.repaint();
         mainPanel.repaint();
     }
 
-    void repaintRoads()
-    {
+    void repaintRoads() {
         // avoid threading as there should be no updated to scale or offset while painting 
         // (would to lead to artifacts)
         StopWatch sw = new StopWatch().start();
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index 473be957fb..e0da9f5232 100755
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -20,16 +20,14 @@
 import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class QueryTortureTest
-{
+public class QueryTortureTest {
     @Test
-    public void testGetQuery()
-    {
+    public void testGetQuery() {
         Query result = Query.parse("2016-05-04 16:37:37,647 [qtp1604002113-823] INFO  com.graphhopper.http.GHBaseServlet - point=46.444481%2C11.306992&point=46.07847%2C11.178589&locale=en_US&vehicle=car&weighting=fastest&elevation=true 127.0.0.1 en_US Directions API 195.232.147.121 [46.456721,11.258966, 46.15583,11.153478, 46.067933,11.223352, 46.456721,11.258966], took:0.008627106, , fastest, car, alternatives: 1, distance0: 146967.68084669442, time0: 112min, points0: 1507, debugInfo: idLookup:0.004824006s; , algoInit:2.6879E-5s, dijkstrabiCH-routing:5.69366E-4s, extract time:9.987E-5;, algoInit:1.6976E-5s, dijkstrabiCH-routing:3.22521E-4s, extract time:5.9076E-5;, algoInit:1.6084E-5s, dijkstrabiCH-routing:6.75566E-4s, extract time:8.2527E-5;, algoInit:2.6879E-5s, dijkstrabiCH-routing:5.69366E-4s, extract time:9.987E-5;, algoInit:1.6976E-5s, dijkstrabiCH-routing:3.22521E-4s, extract time:5.9076E-5;, algoInit:1.6084E-5s, dijkstrabiCH-routing:6.75566E-4s, extract time:8.2527E-5, simplify (1903->1507)");
         assertEquals("point=46.444481%2C11.306992&point=46.07847%2C11.178589&elevation=true&locale=en_US&weighting=fastest&vehicle=car", result.createQueryString());
         assertEquals(46.444481, result.start.lat, 1e-5);
diff --git a/web/package.json b/web/package.json
index e9447c3d22..6e5d8588e2 100755
--- a/web/package.json
+++ b/web/package.json
@@ -25,14 +25,15 @@
     "browserify": "13.1.0",
     "browserify-swap": "0.2.2",
     "d3": "3.5.17",
-    "jquery": "3.1.0",
-    "leaflet": "0.7.7",
-    "leaflet-loading": "0.1.22",
-    "uglifyify": "3.0.2"
+    "jquery": "3.1.1",
+    "leaflet": "1.0.1",
+    "leaflet-contextmenu": "1.1.1",
+    "leaflet-loading": "0.1.23",
+    "uglifyify": "3.0.3"
   },
   "devDependencies": {
-    "jasmine": "2.4.1",
-    "jshint": "2.9.2",
+    "jasmine": "2.5.2",
+    "jshint": "2.9.3",
     "watchify": "3.7.0"
   }
 }
diff --git a/web/pom.xml b/web/pom.xml
index 444fced72e..7c45d8e416 100755
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,38 +6,38 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.9-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
-        
+
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.8-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.9-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>9.3.8.v20160314</jetty.version>
     </properties>
-    
+
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
-            <version>${project.parent.version}</version>            
+            <version>${project.parent.version}</version>
         </dependency>
-        
+
         <dependency>
             <groupId>org.json</groupId>
-            <artifactId>json</artifactId>            
+            <artifactId>json</artifactId>
             <version>${json.org.version}</version>
-        </dependency>    
-        
+        </dependency>
+
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
             <version>4.0</version>
         </dependency>
-        
+
         <!-- necessary to use guice ('@Inject') in servlets -->
         <dependency>
             <groupId>com.google.inject.extensions</groupId>
@@ -56,7 +56,7 @@
             <version>${slf4j.version}</version>
             <scope>runtime</scope>
         </dependency>
-        
+
         <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
@@ -69,7 +69,7 @@
             <artifactId>jetty-servlets</artifactId>
             <version>${jetty.version}</version>
         </dependency>
-        
+
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
             <artifactId>jetty-server</artifactId>
@@ -80,7 +80,7 @@
             <artifactId>jetty-servlet</artifactId>
             <version>${jetty.version}</version>
         </dependency>
-        
+
         <!-- for integration tests of service -->
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
@@ -88,14 +88,15 @@
             <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
-      
+
     </dependencies>
 
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>                
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
@@ -105,16 +106,27 @@
             <!-- create a jar file too, so others can use it more easily -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-war-plugin</artifactId>                
+                <artifactId>maven-war-plugin</artifactId>
+                <version>3.0.0</version>
                 <configuration>
 		    <webXml>src\main\webapp\WEB-INF\web.xml</webXml>
                     <attachClasses>true</attachClasses>
 		    <failOnMissingWebXml>false</failOnMissingWebXml>
                 </configuration>
-            </plugin>            
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
+                <!-- this is an old version but 2.6 fails with java 9
+                see: https://stackoverflow.com/questions/36583118/is-maven-ready-for-jdk9-->
+                <version>2.4.1</version>
+                <dependencies>
+                    <dependency>
+                        <groupId>org.codehaus.plexus</groupId>
+                        <artifactId>plexus-archiver</artifactId>
+                        <version>2.4.4</version>
+                    </dependency>
+                </dependencies>
                 <configuration>
                     <archive>
                         <manifest>
@@ -131,14 +143,14 @@
                     <execution>
                         <id>make-assembly</id>
                         <!-- bind to verify and not package to pass integration tests before creating assemblies -->
-                        <phase>integration-test</phase> 
+                        <phase>integration-test</phase>
                         <goals>
                             <goal>single</goal>
                         </goals>
                     </execution>
                 </executions>
             </plugin>
- 
+
         </plugins>
     </build>
 
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index 3588d5c021..e85258009b 100755
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -17,20 +17,17 @@
  */
 package com.graphhopper.http;
 
-import java.io.IOException;
 import javax.servlet.*;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
 
 /**
  * @author Peter Karich
  */
-public class CORSFilter implements Filter
-{
+public class CORSFilter implements Filter {
     @Override
-    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
-    {
-        if (!"jsonp".equals(request.getParameter("type")))
-        {
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+        if (!"jsonp".equals(request.getParameter("type"))) {
             HttpServletResponse rsp = (HttpServletResponse) response;
             rsp.setHeader("Access-Control-Allow-Methods", "GET, POST, HEAD, OPTIONS");
             rsp.setHeader("Access-Control-Allow-Headers", "Origin,Accept,X-Requested-With,"
@@ -42,12 +39,10 @@ public void doFilter( ServletRequest request, ServletResponse response, FilterCh
     }
 
     @Override
-    public void init( FilterConfig filterConfig ) throws ServletException
-    {
+    public void init(FilterConfig filterConfig) throws ServletException {
     }
 
     @Override
-    public void destroy()
-    {
+    public void destroy() {
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index 5f75b2a642..6d901eed9b 100755
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -29,19 +29,16 @@
 /**
  * @author Peter Karich
  */
-public class DefaultModule extends AbstractModule
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
+public class DefaultModule extends AbstractModule {
     protected final CmdArgs args;
+    private final Logger logger = LoggerFactory.getLogger(getClass());
     private GraphHopper graphHopper;
 
-    public DefaultModule( CmdArgs args )
-    {
+    public DefaultModule(CmdArgs args) {
         this.args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
     }
 
-    public GraphHopper getGraphHopper()
-    {
+    public GraphHopper getGraphHopper() {
         if (graphHopper == null)
             throw new IllegalStateException("createGraphHopper not called");
 
@@ -51,8 +48,7 @@ public GraphHopper getGraphHopper()
     /**
      * @return an initialized GraphHopper instance
      */
-    protected GraphHopper createGraphHopper( CmdArgs args )
-    {
+    protected GraphHopper createGraphHopper(CmdArgs args) {
         GraphHopper tmp = new GraphHopperOSM().forServer().init(args);
         tmp.importOrLoad();
         logger.info("loaded graph at:" + tmp.getGraphHopperLocation()
@@ -63,10 +59,8 @@ protected GraphHopper createGraphHopper( CmdArgs args )
     }
 
     @Override
-    protected void configure()
-    {
-        try
-        {
+    protected void configure() {
+        try {
             graphHopper = createGraphHopper(args);
             bind(GraphHopper.class).toInstance(graphHopper);
             bind(TranslationMap.class).toInstance(graphHopper.getTranslationMap());
@@ -80,8 +74,7 @@ protected void configure()
             bind(Boolean.class).annotatedWith(Names.named("jsonp_allowed")).toInstance(jsonpAllowed);
 
             bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraphHopperStorage().getBounds()));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new IllegalStateException("Couldn't load graph", ex);
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 855b593e2c..53b4fce9e7 100755
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -38,30 +38,25 @@
 /**
  * @author Peter Karich
  */
-public class GHBaseServlet extends HttpServlet
-{
+public class GHBaseServlet extends HttpServlet {
     protected static final Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonp_allowed")
     private boolean jsonpAllowed;
 
-    protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException, IOException
-    {
+    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JSONObject json) throws JSONException, IOException {
         String type = getParam(req, "type", "json");
         res.setCharacterEncoding("UTF-8");
         boolean debug = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
-        if ("jsonp".equals(type))
-        {
+        if ("jsonp".equals(type)) {
             res.setContentType("application/javascript");
-            if (!jsonpAllowed)
-            {
+            if (!jsonpAllowed) {
                 writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
-            if (callbackName == null)
-            {
+            if (callbackName == null) {
                 writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
@@ -71,8 +66,7 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
 
-        } else
-        {
+        } else {
             res.setContentType("application/json");
             if (debug)
                 writeResponse(res, json.toString(2));
@@ -81,31 +75,26 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
         }
     }
 
-    protected void writeError( HttpServletResponse res, int code, String message )
-    {
+    protected void writeError(HttpServletResponse res, int code, String message) {
         JSONObject json = new JSONObject();
         json.put("message", message);
         writeJsonError(res, code, json);
     }
 
-    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
-    {
-        try
-        {
+    protected void writeJsonError(HttpServletResponse res, int code, JSONObject json) {
+        try {
             // no type parameter check here as jsonp does not work if an error
             // also no debug parameter yet
             res.setContentType("application/json");
             res.setCharacterEncoding("UTF-8");
             res.setStatus(code);
             res.getWriter().append(json.toString(2));
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write error " + ex.getMessage());
         }
     }
 
-    protected String getParam( HttpServletRequest req, String key, String _default )
-    {
+    protected String getParam(HttpServletRequest req, String key, String _default) {
         String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
             return l[0];
@@ -113,24 +102,19 @@ protected String getParam( HttpServletRequest req, String key, String _default )
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String key )
-    {
+    protected String[] getParams(HttpServletRequest req, String key) {
         String[] l = req.getParameterMap().get(key);
-        if (l != null && l.length > 0)
-        {
+        if (l != null && l.length > 0) {
             return l;
         }
         return new String[0];
     }
 
-    protected List<Double> getDoubleParamList( HttpServletRequest req, String key )
-    {
+    protected List<Double> getDoubleParamList(HttpServletRequest req, String key) {
         String[] l = req.getParameterMap().get(key);
-        if (l != null && l.length > 0)
-        {
+        if (l != null && l.length > 0) {
             ArrayList<Double> doubleList = new ArrayList<Double>(l.length);
-            for (String s : l)
-            {
+            for (String s : l) {
                 doubleList.add(Double.valueOf(s));
             }
             return doubleList;
@@ -138,58 +122,43 @@ protected String getParam( HttpServletRequest req, String key, String _default )
         return Collections.emptyList();
     }
 
-    protected long getLongParam( HttpServletRequest req, String key, long _default )
-    {
-        try
-        {
+    protected long getLongParam(HttpServletRequest req, String key, long _default) {
+        try {
             return Long.parseLong(getParam(req, key, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
-    
-    protected int getIntParam( HttpServletRequest req, String key, int _default )
-    {
-        try
-        {
+
+    protected int getIntParam(HttpServletRequest req, String key, int _default) {
+        try {
             return Integer.parseInt(getParam(req, key, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String key, boolean _default )
-    {
-        try
-        {
+    protected boolean getBooleanParam(HttpServletRequest req, String key, boolean _default) {
+        try {
             return Boolean.parseBoolean(getParam(req, key, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String key, double _default )
-    {
-        try
-        {
+    protected double getDoubleParam(HttpServletRequest req, String key, double _default) {
+        try {
             return Double.parseDouble(getParam(req, key, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    public void writeResponse( HttpServletResponse res, String str )
-    {
-        try
-        {
+    public void writeResponse(HttpServletResponse res, String str) {
+        try {
             res.setStatus(SC_OK);
             res.getWriter().append(str);
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write message:" + str, ex);
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
index 38271bad20..742923b5fc 100755
--- a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
+++ b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
@@ -17,44 +17,44 @@
  */
 package com.graphhopper.http;
 
-import java.io.IOException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.ErrorHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
 /**
  * @author Peter Karich
  */
-public class GHErrorHandler extends ErrorHandler
-{
+public class GHErrorHandler extends ErrorHandler {
     private static final long serialVersionUID = 1L;
     private final Logger logger = LoggerFactory.getLogger(GHErrorHandler.class);
 
     @Override
-    public void handle( String str, Request req, HttpServletRequest httpReq, HttpServletResponse httpRes ) throws IOException
-    {
+    public void handle(String str, Request req, HttpServletRequest httpReq, HttpServletResponse httpRes) throws IOException {
         Throwable throwable = (Throwable) httpReq.getAttribute("javax.servlet.error.exception");
-        if (throwable != null)
-        {
+        String url = httpReq.getRequestURI();
+        if (httpReq.getQueryString() != null)
+            url += "?" + httpReq.getQueryString();
+
+        if (throwable != null) {
             String message = throwable.getMessage();
-            logger.error(message + ", via:" + httpReq.getRequestURL(), throwable);
-        } else
-        {
+            logger.error(message + "! Via:" + url, throwable);
+        } else {
             String message = (String) httpReq.getAttribute("javax.servlet.error.message");
-            if (message != null)
-            {
-                logger.error("Internal error " + message + "! Via:" + httpReq.getRequestURL());
-            } else
-            {
-                logger.error("Internal error " + str + ", throwable not known! Via:" + httpReq.getRequestURL());
+            if (httpRes.getStatus() / 100 == 4) {
+                logger.warn(message + ", via:" + url);
+            } else if (message != null) {
+                logger.error("Internal error " + message + "! Via:" + url);
+            } else {
+                logger.error("Internal error " + str + ", throwable unknown! Via:" + url);
             }
         }
 
         // you can't call sendError( 500, "Server Error" ) without triggering Jetty's DefaultErrorHandler
-        httpRes.setStatus(SC_INTERNAL_SERVER_ERROR);
+        httpRes.setStatus(httpRes.getStatus());
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index c488454cb3..f8f526e225 100755
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -23,53 +23,47 @@
 import com.google.inject.Module;
 import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
-
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpConnectionFactory;
 import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.servlet.ServletHolder;
-
-import java.util.EnumSet;
-import javax.servlet.DispatcherType;
-
-import org.eclipse.jetty.server.*;
+import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
 import org.eclipse.jetty.server.handler.gzip.GzipHandler;
 import org.eclipse.jetty.servlet.FilterHolder;
 import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.servlet.DispatcherType;
+import java.util.EnumSet;
+
 /**
  * Simple server similar to integration tests setup.
  */
-public class GHServer
-{
-    public static void main( String[] args ) throws Exception
-    {
-        new GHServer(CmdArgs.read(args)).start();
-    }
-
+public class GHServer {
     private final CmdArgs args;
-    private Server server;
     private final Logger logger = LoggerFactory.getLogger(getClass());
+    private Server server;
 
-    public GHServer( CmdArgs args )
-    {
+    public GHServer(CmdArgs args) {
         this.args = args;
     }
 
-    public void start() throws Exception
-    {
+    public static void main(String[] args) throws Exception {
+        new GHServer(CmdArgs.read(args)).start();
+    }
+
+    public void start() throws Exception {
         Injector injector = Guice.createInjector(createModule());
         start(injector);
     }
 
-    public void start( Injector injector ) throws Exception
-    {
+    public void start(Injector injector) throws Exception {
         ResourceHandler resHandler = new ResourceHandler();
         resHandler.setDirectoriesListed(false);
-        resHandler.setWelcomeFiles(new String[]
-        {
+        resHandler.setWelcomeFiles(new String[]{
             "index.html"
         });
         resHandler.setResourceBase(args.get("jetty.resourcebase", "./src/main/webapp"));
@@ -100,8 +94,7 @@ public void start( Injector injector ) throws Exception
         server.addConnector(connector0);
 
         HandlerList handlers = new HandlerList();
-        handlers.setHandlers(new Handler[]
-        {
+        handlers.setHandlers(new Handler[]{
             resHandler, servHandler
         });
 
@@ -117,13 +110,10 @@ public void start( Injector injector ) throws Exception
         logger.info("Started server at HTTP " + host + ":" + httpPort);
     }
 
-    protected Module createModule()
-    {
-        return new AbstractModule()
-        {
+    protected Module createModule() {
+        return new AbstractModule() {
             @Override
-            protected void configure()
-            {
+            protected void configure() {
                 binder().requireExplicitBindings();
 
                 install(new DefaultModule(args));
@@ -134,16 +124,13 @@ protected void configure()
         };
     }
 
-    public void stop()
-    {
+    public void stop() {
         if (server == null)
             return;
 
-        try
-        {
+        try {
             server.stop();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             logger.error("Cannot stop jetty", ex);
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index eaa1defb9f..1531a38fea 100755
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -20,20 +20,18 @@
 import com.google.inject.servlet.ServletModule;
 import com.graphhopper.util.CmdArgs;
 
+import javax.inject.Singleton;
 import java.util.HashMap;
 import java.util.Map;
-import javax.inject.Singleton;
 
 /**
  * @author Peter Karich
  */
-public class GHServletModule extends ServletModule
-{
-    protected Map<String, String> params = new HashMap<String, String>();
+public class GHServletModule extends ServletModule {
     protected final CmdArgs args;
+    protected Map<String, String> params = new HashMap<String, String>();
 
-    public GHServletModule( CmdArgs args )
-    {
+    public GHServletModule(CmdArgs args) {
         this.args = args;
         params.put("mimeTypes", "text/html,"
                 + "text/plain,"
@@ -48,10 +46,12 @@ public GHServletModule( CmdArgs args )
     }
 
     @Override
-    protected void configureServlets()
-    {
+    protected void configureServlets() {
+        filter("*").through(HeadFilter.class);
+        bind(HeadFilter.class).in(Singleton.class);
+        
         filter("*").through(CORSFilter.class, params);
-        bind(CORSFilter.class).in(Singleton.class);
+        bind(CORSFilter.class).in(Singleton.class);        
 
         filter("*").through(IPFilter.class);
         bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 0644ef0878..75f3518e9e 100755
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -17,10 +17,10 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.StopWatch;
@@ -54,16 +54,14 @@
  *
  * @author Peter Karich
  */
-public class GraphHopperServlet extends GHBaseServlet
-{
+public class GraphHopperServlet extends GHBaseServlet {
     @Inject
     private GraphHopper hopper;
     @Inject
     private RouteSerializer routeSerializer;
 
     @Override
-    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
-    {
+    public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throws ServletException, IOException {
         List<GHPoint> requestPoints = getPoints(httpReq, "point");
         GHResponse ghRsp = new GHResponse();
 
@@ -82,49 +80,38 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
 
         StopWatch sw = new StopWatch().start();
 
-        if (!ghRsp.hasErrors())
-        {
-            try
-            {
+        if (!ghRsp.hasErrors()) {
+            try {
                 List<Double> favoredHeadings = Collections.EMPTY_LIST;
-                try
-                {
+                try {
                     favoredHeadings = getDoubleParamList(httpReq, "heading");
 
-                } catch (NumberFormatException e)
-                {
+                } catch (NumberFormatException e) {
                     throw new IllegalArgumentException("heading list in from format: " + e.getMessage());
                 }
 
-                if (!hopper.getEncodingManager().supports(vehicleStr))
-                {
+                if (!hopper.getEncodingManager().supports(vehicleStr)) {
                     throw new IllegalArgumentException("Vehicle not supported: " + vehicleStr);
-                } else if (enableElevation && !hopper.hasElevation())
-                {
+                } else if (enableElevation && !hopper.hasElevation()) {
                     throw new IllegalArgumentException("Elevation not supported!");
-                } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
-                {
+                } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size()) {
                     throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
                             + "or equal to the number of points (" + requestPoints.size() + ")");
                 }
 
                 FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
                 GHRequest request;
-                if (favoredHeadings.size() > 0)
-                {
+                if (favoredHeadings.size() > 0) {
                     // if only one favored heading is specified take as start heading
-                    if (favoredHeadings.size() == 1)
-                    {
+                    if (favoredHeadings.size() == 1) {
                         List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(requestPoints.size(),
                                 Double.NaN));
                         paddedHeadings.set(0, favoredHeadings.get(0));
                         request = new GHRequest(requestPoints, paddedHeadings);
-                    } else
-                    {
+                    } else {
                         request = new GHRequest(requestPoints, favoredHeadings);
                     }
-                } else
-                {
+                } else {
                     request = new GHRequest(requestPoints);
                 }
 
@@ -139,8 +126,7 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
                         put("wayPointMaxDistance", minPathPrecision);
 
                 ghRsp = hopper.route(request);
-            } catch (IllegalArgumentException ex)
-            {
+            } catch (IllegalArgumentException ex) {
                 ghRsp.addError(ex);
             }
         }
@@ -155,11 +141,9 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
         if (writeGPX && alternatives > 1)
             ghRsp.addError(new IllegalArgumentException("Alternatives are currently not yet supported for GPX"));
 
-        if (ghRsp.hasErrors())
-        {
+        if (ghRsp.hasErrors()) {
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
-        } else
-        {
+        } else {
             PathWrapper altRsp0 = ghRsp.getBest();
             logger.info(logStr + ", alternatives: " + alternatives
                     + ", distance0: " + altRsp0.getDistance()
@@ -168,20 +152,16 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
                     + ", debugInfo: " + ghRsp.getDebugInfo());
         }
 
-        if (writeGPX)
-        {
-            if (ghRsp.hasErrors())
-            {
+        if (writeGPX) {
+            if (ghRsp.hasErrors()) {
                 httpRes.setStatus(SC_BAD_REQUEST);
                 httpRes.getWriter().append(errorsToXML(ghRsp.getErrors()));
-            } else
-            {
+            } else {
                 // no error => we can now safely call getFirst
                 String xml = createGPXString(httpReq, httpRes, ghRsp.getBest());
                 writeResponse(httpRes, xml);
             }
-        } else
-        {
+        } else {
             Map<String, Object> map = routeSerializer.toJSON(ghRsp, calcPoints, pointsEncoded,
                     enableElevation, enableInstructions);
 
@@ -196,8 +176,7 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
         }
     }
 
-    protected String createGPXString( HttpServletRequest req, HttpServletResponse res, PathWrapper rsp )
-    {
+    protected String createGPXString(HttpServletRequest req, HttpServletResponse res, PathWrapper rsp) {
         boolean includeElevation = getBooleanParam(req, "elevation", false);
         // default to false for the route part in next API version, see #437
         boolean withRoute = getBooleanParam(req, "gpx.route", true);
@@ -215,13 +194,11 @@ protected String createGPXString( HttpServletRequest req, HttpServletResponse re
         return rsp.getInstructions().createGPX(trackName, time, includeElevation, withRoute, withTrack, withWayPoints);
     }
 
-    protected String errorsToXML( Collection<Throwable> list )
-    {
+    protected String errorsToXML(Collection<Throwable> list) {
         if (list.isEmpty())
             throw new RuntimeException("errorsToXML should not be called with an empty list");
 
-        try
-        {
+        try {
             DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
             DocumentBuilder builder = factory.newDocumentBuilder();
             Document doc = builder.newDocument();
@@ -243,8 +220,7 @@ protected String errorsToXML( Collection<Throwable> list )
             Element hintsElement = doc.createElement("hints");
             extensionsElement.appendChild(hintsElement);
 
-            for (Throwable t : list)
-            {
+            for (Throwable t : list) {
                 Element error = doc.createElement("error");
                 hintsElement.appendChild(error);
                 error.setAttribute("message", t.getMessage());
@@ -255,21 +231,17 @@ protected String errorsToXML( Collection<Throwable> list )
             StringWriter writer = new StringWriter();
             transformer.transform(new DOMSource(doc), new StreamResult(writer));
             return writer.toString();
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
-    protected List<GHPoint> getPoints( HttpServletRequest req, String key )
-    {
+    protected List<GHPoint> getPoints(HttpServletRequest req, String key) {
         String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
-        for (String str : pointsAsStr)
-        {
+        for (String str : pointsAsStr) {
             String[] fromStrs = str.split(",");
-            if (fromStrs.length == 2)
-            {
+            if (fromStrs.length == 2) {
                 GHPoint point = GHPoint.parse(str);
                 if (point != null)
                     infoPoints.add(point);
@@ -279,11 +251,9 @@ protected String errorsToXML( Collection<Throwable> list )
         return infoPoints;
     }
 
-    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
-    {
+    protected void initHints(GHRequest request, Map<String, String[]> parameterMap) {
         HintsMap m = request.getHints();
-        for (Entry<String, String[]> e : parameterMap.entrySet())
-        {
+        for (Entry<String, String[]> e : parameterMap.entrySet()) {
             if (e.getValue().length == 1)
                 m.put(e.getKey(), e.getValue()[0]);
         }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 7069fc81a4..58bbda5140 100755
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -17,39 +17,45 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.*;
+import com.graphhopper.util.exceptions.ConnectionNotFoundException;
+import com.graphhopper.util.exceptions.DetailedIllegalArgumentException;
+import com.graphhopper.util.exceptions.DetailedRuntimeException;
+import com.graphhopper.util.exceptions.PointNotFoundException;
+import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
-
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-
-import org.json.JSONArray;
-import org.json.JSONObject;
+import org.json.JSONException;
 
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
  * <p>
+ *
  * @author Peter Karich
  */
-public class GraphHopperWeb implements GraphHopperAPI
-{
+public class GraphHopperWeb implements GraphHopperAPI {
+    private final Set<String> ignoreSet;
     private Downloader downloader = new Downloader("GraphHopper Java Client");
     private String routeServiceUrl = "https://graphhopper.com/api/1/route";
     private String key = "";
     private boolean instructions = true;
     private boolean calcPoints = true;
     private boolean elevation = false;
-    private final Set<String> ignoreSet;
 
-    public GraphHopperWeb()
-    {
+    public GraphHopperWeb() {
         // some parameters are supported directly via Java API so ignore them when writing the getHints map
         ignoreSet = new HashSet<String>();
         ignoreSet.add("calc_points");
@@ -70,149 +76,30 @@ public GraphHopperWeb()
         ignoreSet.add("type");
     }
 
-    public GraphHopperWeb setDownloader( Downloader downloader )
-    {
-        this.downloader = downloader;
-        return this;
-    }
-
-    @Override
-    public boolean load( String serviceUrl )
-    {
-        this.routeServiceUrl = serviceUrl;
-        return true;
-    }
-
-    public GraphHopperWeb setKey( String key )
-    {
-        if (key == null || key.isEmpty())
-            throw new IllegalStateException("Key cannot be empty");
-
-        this.key = key;
-        return this;
-    }
-
-    public GraphHopperWeb setCalcPoints( boolean calcPoints )
-    {
-        this.calcPoints = calcPoints;
-        return this;
-    }
-
-    public GraphHopperWeb setInstructions( boolean b )
-    {
-        instructions = b;
-        return this;
-    }
-
-    public GraphHopperWeb setElevation( boolean withElevation )
-    {
-        this.elevation = withElevation;
-        return this;
-    }
-
-    @Override
-    public GHResponse route( GHRequest request )
-    {
-        try
-        {
-            String places = "";
-            for (GHPoint p : request.getPoints())
-            {
-                places += "point=" + p.lat + "," + p.lon + "&";
-            }
-
-            boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
-            boolean tmpCalcPoints = request.getHints().getBool("calc_points", calcPoints);
-
-            if (tmpInstructions && !tmpCalcPoints)
-                throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
-                        + "Use calc_points=false and instructions=false to disable point and instruction calculation");
-
-            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
-
-            String url = routeServiceUrl
-                    + "?"
-                    + places
-                    + "&type=json"
-                    + "&instructions=" + tmpInstructions
-                    + "&points_encoded=true"
-                    + "&calc_points=" + tmpCalcPoints
-                    + "&algorithm=" + request.getAlgorithm()
-                    + "&locale=" + request.getLocale().toString()
-                    + "&elevation=" + tmpElevation;
-
-            if (!request.getVehicle().isEmpty())
-                url += "&vehicle=" + request.getVehicle();
-
-            if (!key.isEmpty())
-                url += "&key=" + key;
-
-            for (Entry<String, String> entry : request.getHints().toMap().entrySet())
-            {
-                String urlKey = entry.getKey();
-                String urlValue = entry.getValue();
-
-                // use lower case conversion for check only!
-                if (ignoreSet.contains(urlKey.toLowerCase()))
-                    continue;
-
-                if (urlValue != null && !urlValue.isEmpty())
-                    url += "&" + WebHelper.encodeURL(urlKey) + "=" + WebHelper.encodeURL(urlValue);
-            }
-
-            String str = downloader.downloadAsString(url, true);
-            JSONObject json = new JSONObject(str);
-
-            GHResponse res = new GHResponse();
-            res.addErrors(readErrors(json));
-            if (res.hasErrors())
-                return res;
-
-            JSONArray paths = json.getJSONArray("paths");
-            for (int index = 0; index < paths.length(); index++)
-            {
-                JSONObject path = paths.getJSONObject(index);
-                PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation);
-                res.add(altRsp);
-            }
-
-            return res;
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
-        }
-    }
-
-    public static PathWrapper createPathWrapper( JSONObject path,
-                                                 boolean tmpCalcPoints, boolean tmpInstructions, boolean tmpElevation )
-    {
+    public static PathWrapper createPathWrapper(JSONObject path,
+                                                boolean tmpCalcPoints, boolean tmpInstructions, boolean tmpElevation) {
         PathWrapper pathWrapper = new PathWrapper();
         pathWrapper.addErrors(readErrors(path));
         if (pathWrapper.hasErrors())
             return pathWrapper;
 
-        if (path.has("snapped_waypoints"))
-        {
+        if (path.has("snapped_waypoints")) {
             String snappedPointStr = path.getString("snapped_waypoints");
             PointList snappedPoints = WebHelper.decodePolyline(snappedPointStr, 5, tmpElevation);
             pathWrapper.setWaypoints(snappedPoints);
         }
 
-        if (tmpCalcPoints)
-        {
+        if (tmpCalcPoints) {
             String pointStr = path.getString("points");
             PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
             pathWrapper.setPoints(pointList);
 
-            if (tmpInstructions)
-            {
+            if (tmpInstructions) {
                 JSONArray instrArr = path.getJSONArray("instructions");
 
                 InstructionList il = new InstructionList(null);
                 int viaCount = 1;
-                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
-                {
+                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++) {
                     JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
                     double instDist = jsonObj.getDouble("distance");
                     String text = jsonObj.getString("text");
@@ -222,29 +109,24 @@ public static PathWrapper createPathWrapper( JSONObject path,
                     int from = iv.getInt(0);
                     int to = iv.getInt(1);
                     PointList instPL = new PointList(to - from, tmpElevation);
-                    for (int j = from; j <= to; j++)
-                    {
+                    for (int j = from; j <= to; j++) {
                         instPL.add(pointList, j);
                     }
 
                     InstructionAnnotation ia = InstructionAnnotation.EMPTY;
-                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
-                    {
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
                         ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
                     }
 
                     Instruction instr;
-                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
-                    {
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
                         RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
 
-                        if (jsonObj.has("exit_number"))
-                        {
+                        if (jsonObj.has("exit_number")) {
                             ri.setExitNumber(jsonObj.getInt("exit_number"));
                         }
 
-                        if (jsonObj.has("turn_angle"))
-                        {
+                        if (jsonObj.has("turn_angle")) {
                             // TODO provide setTurnAngle setter
                             double angle = jsonObj.getDouble("turn_angle");
                             ri.setDirOfRotation(angle);
@@ -252,17 +134,14 @@ public static PathWrapper createPathWrapper( JSONObject path,
                         }
 
                         instr = ri;
-                    } else if (sign == Instruction.REACHED_VIA)
-                    {
+                    } else if (sign == Instruction.REACHED_VIA) {
                         ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
                         tmpInstr.setViaCount(viaCount);
                         viaCount++;
                         instr = tmpInstr;
-                    } else if (sign == Instruction.FINISH)
-                    {
+                    } else if (sign == Instruction.FINISH) {
                         instr = new FinishInstruction(instPL, 0);
-                    } else
-                    {
+                    } else {
                         instr = new Instruction(sign, text, ia, instPL);
                     }
 
@@ -283,18 +162,42 @@ public static PathWrapper createPathWrapper( JSONObject path,
         return pathWrapper;
     }
 
-    public static List<Throwable> readErrors( JSONObject json )
-    {
-        List<Throwable> errors = new ArrayList<Throwable>();
+    // Credits to: http://stackoverflow.com/a/24012023/194609
+    private static Map<String, Object> toMap(JSONObject object) throws JSONException {
+        Map<String, Object> map = new HashMap<>(object.keySet().size());
+        for (String key : object.keySet()) {
+            Object value = object.get(key);
+            if (value instanceof JSONArray) {
+                value = toList((JSONArray) value);
+            } else if (value instanceof JSONObject) {
+                value = toMap((JSONObject) value);
+            }
+            map.put(key, value);
+        }
+        return map;
+    }
+
+    private static List<Object> toList(JSONArray array) throws JSONException {
+        List<Object> list = new ArrayList<>();
+        for (Object value : array) {
+            if (value instanceof JSONArray) {
+                value = toList((JSONArray) value);
+            } else if (value instanceof JSONObject) {
+                value = toMap((JSONObject) value);
+            }
+            list.add(value);
+        }
+        return list;
+    }
+
+    public static List<Throwable> readErrors(JSONObject json) {
+        List<Throwable> errors = new ArrayList<>();
         JSONArray errorJson;
 
-        if (json.has("message"))
-        {
-            if (json.has("hints"))
-            {
+        if (json.has("message")) {
+            if (json.has("hints")) {
                 errorJson = json.getJSONArray("hints");
-            } else
-            {
+            } else {
                 // should not happen
                 errors.add(new RuntimeException(json.getString("message")));
                 return errors;
@@ -302,8 +205,7 @@ public static PathWrapper createPathWrapper( JSONObject path,
         } else
             return errors;
 
-        for (int i = 0; i < errorJson.length(); i++)
-        {
+        for (int i = 0; i < errorJson.length(); i++) {
             JSONObject error = errorJson.getJSONObject(i);
             String exClass = "";
             if (error.has("details"))
@@ -316,13 +218,21 @@ public static PathWrapper createPathWrapper( JSONObject path,
             else if (exClass.equals(IllegalStateException.class.getName()))
                 errors.add(new IllegalStateException(exMessage));
             else if (exClass.equals(RuntimeException.class.getName()))
-                errors.add(new RuntimeException(exMessage));
+                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
             else if (exClass.equals(IllegalArgumentException.class.getName()))
-                errors.add(new IllegalArgumentException(exMessage));
-            else if (exClass.isEmpty())
-                errors.add(new RuntimeException(exMessage));
+                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(error)));
+            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
+                errors.add(new ConnectionNotFoundException(exMessage, toMap(error)));
+            } else if (exClass.equals(PointNotFoundException.class.getName())) {
+                int pointIndex = error.getInt("point_index");
+                errors.add(new PointNotFoundException(exMessage, pointIndex));
+            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
+                int pointIndex = error.getInt("point_index");
+                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
+            } else if (exClass.isEmpty())
+                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
             else
-                errors.add(new RuntimeException(exClass + " " + exMessage));
+                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(error)));
         }
 
         if (json.has("message") && errors.isEmpty())
@@ -330,4 +240,106 @@ else if (exClass.isEmpty())
 
         return errors;
     }
+
+    public GraphHopperWeb setDownloader(Downloader downloader) {
+        this.downloader = downloader;
+        return this;
+    }
+
+    @Override
+    public boolean load(String serviceUrl) {
+        this.routeServiceUrl = serviceUrl;
+        return true;
+    }
+
+    public GraphHopperWeb setKey(String key) {
+        if (key == null || key.isEmpty())
+            throw new IllegalStateException("Key cannot be empty");
+
+        this.key = key;
+        return this;
+    }
+
+    public GraphHopperWeb setCalcPoints(boolean calcPoints) {
+        this.calcPoints = calcPoints;
+        return this;
+    }
+
+    public GraphHopperWeb setInstructions(boolean b) {
+        instructions = b;
+        return this;
+    }
+
+    public GraphHopperWeb setElevation(boolean withElevation) {
+        this.elevation = withElevation;
+        return this;
+    }
+
+    @Override
+    public GHResponse route(GHRequest request) {
+        try {
+            String places = "";
+            for (GHPoint p : request.getPoints()) {
+                places += "point=" + p.lat + "," + p.lon + "&";
+            }
+
+            boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
+            boolean tmpCalcPoints = request.getHints().getBool("calc_points", calcPoints);
+
+            if (tmpInstructions && !tmpCalcPoints)
+                throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
+                        + "Use calc_points=false and instructions=false to disable point and instruction calculation");
+
+            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
+
+            String url = routeServiceUrl
+                    + "?"
+                    + places
+                    + "&type=json"
+                    + "&instructions=" + tmpInstructions
+                    + "&points_encoded=true"
+                    + "&calc_points=" + tmpCalcPoints
+                    + "&algorithm=" + request.getAlgorithm()
+                    + "&locale=" + request.getLocale().toString()
+                    + "&elevation=" + tmpElevation;
+
+            if (!request.getVehicle().isEmpty())
+                url += "&vehicle=" + request.getVehicle();
+
+            if (!key.isEmpty())
+                url += "&key=" + key;
+
+            for (Entry<String, String> entry : request.getHints().toMap().entrySet()) {
+                String urlKey = entry.getKey();
+                String urlValue = entry.getValue();
+
+                // use lower case conversion for check only!
+                if (ignoreSet.contains(urlKey.toLowerCase()))
+                    continue;
+
+                if (urlValue != null && !urlValue.isEmpty())
+                    url += "&" + WebHelper.encodeURL(urlKey) + "=" + WebHelper.encodeURL(urlValue);
+            }
+
+            String str = downloader.downloadAsString(url, true);
+            JSONObject json = new JSONObject(str);
+
+            GHResponse res = new GHResponse();
+            res.addErrors(readErrors(json));
+            if (res.hasErrors())
+                return res;
+
+            JSONArray paths = json.getJSONArray("paths");
+            for (int index = 0; index < paths.length(); index++) {
+                JSONObject path = paths.getJSONObject(index);
+                PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation);
+                res.add(altRsp);
+            }
+
+            return res;
+
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        }
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
index fbfc8555a0..e51d03f146 100755
--- a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
+++ b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
@@ -28,36 +28,30 @@
  * <p>
  * http://code.google.com/p/google-guice/wiki/ServletModule
  * <p>
+ *
  * @author Peter Karich
  */
-public class GuiceServletConfig extends GuiceServletContextListener
-{
+public class GuiceServletConfig extends GuiceServletContextListener {
     private final CmdArgs args;
 
-    public GuiceServletConfig()
-    {
-        try
-        {
+    public GuiceServletConfig() {
+        try {
             args = CmdArgs.readFromConfig("config.properties", "graphhopper.config");
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             throw new RuntimeException(ex);
         }
     }
 
     @Override
-    protected Injector getInjector()
-    {
+    protected Injector getInjector() {
         return Guice.createInjector(createDefaultModule(), createServletModule());
     }
 
-    protected Module createDefaultModule()
-    {
+    protected Module createDefaultModule() {
         return new DefaultModule(args);
     }
 
-    protected Module createServletModule()
-    {
+    protected Module createServletModule() {
         return new GHServletModule(args);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/HeadFilter.java b/web/src/main/java/com/graphhopper/http/HeadFilter.java
new file mode 100644
index 0000000000..0f24963501
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/HeadFilter.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import javax.servlet.*;
+import java.io.IOException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Throw proper error for HEAD requests
+ *
+ * @author Peter Karich
+ */
+public class HeadFilter implements Filter {
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+        String method = ((HttpServletRequest) request).getMethod();
+        if ("HEAD".equals(method))
+            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);
+        else
+            chain.doFilter(request, response);
+    }
+
+    @Override
+    public void init(FilterConfig filterConfig) throws ServletException {
+    }
+
+    @Override
+    public void destroy() {
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 67e95cd0e3..f8b655333a 100755
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -18,36 +18,32 @@
 package com.graphhopper.http;
 
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.Translation;
+import com.graphhopper.util.TranslationMap;
+import org.json.JSONObject;
 
-import java.io.IOException;
-import java.util.Locale;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-
-import org.json.JSONObject;
+import java.io.IOException;
+import java.util.Locale;
 
 /**
  * @author Peter Karich
  */
-public class I18NServlet extends GHBaseServlet
-{
+public class I18NServlet extends GHBaseServlet {
     @Inject
     private TranslationMap map;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
+    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
         String locale = "";
         String path = req.getPathInfo();
         if (!Helper.isEmpty(path) && path.startsWith("/"))
             locale = path.substring(1);
 
-        if (Helper.isEmpty(locale))
-        {
+        if (Helper.isEmpty(locale)) {
             // fall back to language specified in header e.g. via browser settings
             String acceptLang = req.getHeader("Accept-Language");
             if (!Helper.isEmpty(acceptLang))
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
index dc80597068..068e0b28eb 100755
--- a/web/src/main/java/com/graphhopper/http/IPFilter.java
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -17,14 +17,14 @@
  */
 package com.graphhopper.http;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.*;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
-import javax.servlet.*;
-import javax.servlet.http.HttpServletResponse;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
@@ -33,16 +33,15 @@
  * <p>
  * The internal ip filter from jetty did not work (NP exceptions)
  * <p>
+ *
  * @author Peter Karich
  */
-public class IPFilter implements Filter
-{
+public class IPFilter implements Filter {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final Set<String> whites;
     private final Set<String> blacks;
 
-    public IPFilter( String whiteList, String blackList )
-    {
+    public IPFilter(String whiteList, String blackList) {
         whites = createSet(whiteList.split(","));
         blacks = createSet(blackList.split(","));
         if (!whites.isEmpty())
@@ -55,28 +54,22 @@ public IPFilter( String whiteList, String blackList )
     }
 
     @Override
-    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
-    {
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
         String ip = request.getRemoteAddr();
-        if (accept(ip))
-        {
+        if (accept(ip)) {
             chain.doFilter(request, response);
-        } else
-        {
+        } else {
             logger.warn("Did not accept IP " + ip);
             ((HttpServletResponse) response).sendError(HttpServletResponse.SC_FORBIDDEN);
         }
     }
 
-    public boolean accept( String ip )
-    {
+    public boolean accept(String ip) {
         if (whites.isEmpty() && blacks.isEmpty())
             return true;
 
-        if (!whites.isEmpty())
-        {
-            for (String w : whites)
-            {
+        if (!whites.isEmpty()) {
+            for (String w : whites) {
                 if (simpleMatch(ip, w))
                     return true;
             }
@@ -86,8 +79,7 @@ public boolean accept( String ip )
         if (blacks.isEmpty())
             throw new IllegalStateException("cannot happen");
 
-        for (String b : blacks)
-        {
+        for (String b : blacks) {
             if (simpleMatch(ip, b))
                 return false;
         }
@@ -96,20 +88,16 @@ public boolean accept( String ip )
     }
 
     @Override
-    public void init( FilterConfig filterConfig ) throws ServletException
-    {
+    public void init(FilterConfig filterConfig) throws ServletException {
     }
 
     @Override
-    public void destroy()
-    {
+    public void destroy() {
     }
 
-    private Set<String> createSet( String[] split )
-    {
+    private Set<String> createSet(String[] split) {
         Set<String> set = new HashSet<String>(split.length);
-        for (String str : split)
-        {
+        for (String str : split) {
             str = str.trim();
             if (!str.isEmpty())
                 set.add(str);
@@ -117,11 +105,9 @@ public void destroy()
         return set;
     }
 
-    public boolean simpleMatch( String ip, String pattern )
-    {
+    public boolean simpleMatch(String ip, String pattern) {
         String[] ipParts = pattern.split("\\*");
-        for (String ipPart : ipParts)
-        {
+        for (String ipPart : ipParts) {
             int idx = ip.indexOf(ipPart);
             if (idx == -1)
                 return false;
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 1eb01cd6eb..524edb102b 100755
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -22,29 +22,25 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.BBox;
+import org.json.JSONObject;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-
-
-import org.json.JSONObject;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * @author Peter Karich
  */
-public class InfoServlet extends GHBaseServlet
-{
+public class InfoServlet extends GHBaseServlet {
     @Inject
     private GraphHopper hopper;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
+    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
         BBox bb = hopper.getGraphHopperStorage().getBounds();
         List<Double> list = new ArrayList<Double>(4);
         list.add(bb.minLon);
@@ -58,8 +54,7 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         String[] vehicles = hopper.getGraphHopperStorage().getEncodingManager().toString().split(",");
         json.put("supported_vehicles", vehicles);
         JSONObject features = new JSONObject();
-        for (String v : vehicles)
-        {
+        for (String v : vehicles) {
             JSONObject perVehicleJson = new JSONObject();
             perVehicleJson.put("elevation", hopper.hasElevation());
             features.put(v, perVehicleJson);
@@ -73,7 +68,7 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         json.put("import_date", props.get("datareader.import.date"));
 
         if (!Helper.isEmpty(props.get("datareader.data.date")))
-            json.put("data_date" , props.get("datareader.data.date"));
+            json.put("data_date", props.get("datareader.data.date"));
 
         if (!Helper.isEmpty(props.get("prepare.date")))
             json.put("prepare_date", props.get("prepare.date"));
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index 8de227530b..a047a3748f 100755
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -22,11 +22,9 @@
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 
-public class InvalidRequestServlet extends GHBaseServlet
-{
+public class InvalidRequestServlet extends GHBaseServlet {
     @Override
-    protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
+    protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
         JSONObject json = new JSONObject();
         json.put("message", "Not found");
         writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
index ccce8f033e..8aa0eec961 100755
--- a/web/src/main/java/com/graphhopper/http/NearestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -37,30 +37,25 @@
 /**
  * @author svantulden
  */
-public class NearestServlet extends GHBaseServlet
-{
+public class NearestServlet extends GHBaseServlet {
+    private final DistanceCalc calc = Helper.DIST_EARTH;
     @Inject
     private GraphHopper hopper;
-    private final DistanceCalc calc = Helper.DIST_EARTH;
 
     @Override
-    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
-    {
+    public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throws ServletException, IOException {
         String pointStr = getParam(httpReq, "point", null);
         boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
 
         JSONObject result = new JSONObject();
-        if (pointStr != null && !pointStr.equalsIgnoreCase(""))
-        {
+        if (pointStr != null && !pointStr.equalsIgnoreCase("")) {
             GHPoint place = GHPoint.parse(pointStr);
             LocationIndex index = hopper.getLocationIndex();
             QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
 
-            if (!qr.isValid())
-            {
+            if (!qr.isValid()) {
                 result.put("error", "Nearest point cannot be found!");
-            } else
-            {
+            } else {
                 GHPoint3D snappedPoint = qr.getSnappedPoint();
                 result.put("type", "Point");
 
@@ -76,8 +71,7 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
                 // Distance from input to snapped point in meters
                 result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
             }
-        } else
-        {
+        } else {
             result.put("error", "No lat/lon specified!");
         }
 
diff --git a/web/src/main/java/com/graphhopper/http/RouteSerializer.java b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
index fe2d80b2a7..8ef600dccb 100755
--- a/web/src/main/java/com/graphhopper/http/RouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
@@ -19,25 +19,26 @@
 
 import com.graphhopper.GHResponse;
 import com.graphhopper.util.PointList;
+
 import java.util.Map;
 
 /**
  * This interface speficies how the route should be transformed into JSON.
  * <p>
+ *
  * @author Peter Karich
  */
-public interface RouteSerializer
-{
+public interface RouteSerializer {
     /**
      * This method transforms the specified response into a JSON.
      */
-    Map<String, Object> toJSON( GHResponse response,
-                                boolean calcPoints, boolean pointsEncoded,
-                                boolean includeElevation, boolean enableInstructions );
+    Map<String, Object> toJSON(GHResponse response,
+                               boolean calcPoints, boolean pointsEncoded,
+                               boolean includeElevation, boolean enableInstructions);
 
     /**
      * This method returns either a Map containing the GeoJSON of the specified points OR the string
      * encoded polyline of it.
      */
-    Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation );
+    Object createPoints(PointList points, boolean pointsEncoded, boolean includeElevation);
 }
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
index 280989a7bc..f91a115110 100755
--- a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -17,29 +17,27 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
+import com.graphhopper.util.exceptions.GHException;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.*;
 
 /**
- *
  * @author Peter Karich
  */
-public class SimpleRouteSerializer implements RouteSerializer
-{
+public class SimpleRouteSerializer implements RouteSerializer {
     private final BBox maxBounds;
 
-    public SimpleRouteSerializer( BBox maxBounds )
-    {
+    public SimpleRouteSerializer(BBox maxBounds) {
         this.maxBounds = maxBounds;
     }
 
-    private String getMessage( Throwable t )
-    {
+    private String getMessage(Throwable t) {
         if (t.getMessage() == null)
             return t.getClass().getSimpleName();
         else
@@ -47,34 +45,34 @@ private String getMessage( Throwable t )
     }
 
     @Override
-    public Map<String, Object> toJSON( GHResponse rsp,
-                                       boolean calcPoints, boolean pointsEncoded,
-                                       boolean includeElevation, boolean enableInstructions )
-    {
+    public Map<String, Object> toJSON(GHResponse rsp,
+                                      boolean calcPoints, boolean pointsEncoded,
+                                      boolean includeElevation, boolean enableInstructions) {
         Map<String, Object> json = new HashMap<String, Object>();
 
-        if (rsp.hasErrors())
-        {
+        if (rsp.hasErrors()) {
             json.put("message", getMessage(rsp.getErrors().get(0)));
-            List<Map<String, String>> errorHintList = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
-            {
-                Map<String, String> map = new HashMap<String, String>();
+            List<Map<String, Object>> errorHintList = new ArrayList<>();
+            for (Throwable t : rsp.getErrors()) {
+                Map<String, Object> map = new HashMap<>();
                 map.put("message", getMessage(t));
                 map.put("details", t.getClass().getName());
+                if (t instanceof GHException) {
+                    map.putAll(((GHException) t).getDetails());
+                }
                 errorHintList.add(map);
             }
             json.put("hints", errorHintList);
-        } else
-        {
+        } else {
             Map<String, Object> jsonInfo = new HashMap<String, Object>();
             json.put("info", jsonInfo);
             json.put("hints", rsp.getHints().toMap());
+            // If you replace GraphHopper with your own brand name, this is fine. 
+            // Still it would be highly appreciated if you mention us in your about page!
             jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
 
             List<Map<String, Object>> jsonPathList = new ArrayList<Map<String, Object>>();
-            for (PathWrapper ar : rsp.getAll())
-            {
+            for (PathWrapper ar : rsp.getAll()) {
                 Map<String, Object> jsonPath = new HashMap<String, Object>();
                 jsonPath.put("distance", Helper.round(ar.getDistance(), 3));
                 jsonPath.put("weight", Helper.round6(ar.getRouteWeight()));
@@ -82,21 +80,18 @@ private String getMessage( Throwable t )
                 if (!ar.getDescription().isEmpty())
                     jsonPath.put("description", ar.getDescription());
 
-                if (calcPoints)
-                {
+                if (calcPoints) {
                     jsonPath.put("points_encoded", pointsEncoded);
 
                     PointList points = ar.getPoints();
-                    if (points.getSize() >= 2)
-                    {
+                    if (points.getSize() >= 2) {
                         BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
                         jsonPath.put("bbox", ar.calcRouteBBox(maxBounds2D).toGeoJson());
                     }
 
                     jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
-                    if (enableInstructions)
-                    {
+                    if (enableInstructions) {
                         InstructionList instructions = ar.getInstructions();
                         jsonPath.put("instructions", instructions.createJson());
                     }
@@ -115,8 +110,7 @@ private String getMessage( Throwable t )
     }
 
     @Override
-    public Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
+    public Object createPoints(PointList points, boolean pointsEncoded, boolean includeElevation) {
         if (pointsEncoded)
             return WebHelper.encodePolyline(points, includeElevation);
 
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 1dbd2417ef..4bc566a7be 100755
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -20,13 +20,13 @@
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+import org.json.JSONArray;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URLEncoder;
-import org.json.JSONArray;
 
 /**
  * Code which handles polyline encoding and other web stuff.
@@ -35,33 +35,27 @@
  * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
  * good explanation.
  * <p>
+ *
  * @author Peter Karich
  */
-public class WebHelper
-{
-    public static String encodeURL( String str )
-    {
-        try
-        {
+public class WebHelper {
+    public static String encodeURL(String str) {
+        try {
             return URLEncoder.encode(str, "UTF-8");
-        } catch (Exception _ignore)
-        {
+        } catch (Exception _ignore) {
             return str;
         }
     }
 
-    public static PointList decodePolyline( String encoded, int initCap, boolean is3D )
-    {
+    public static PointList decodePolyline(String encoded, int initCap, boolean is3D) {
         PointList poly = new PointList(initCap, is3D);
         int index = 0;
         int len = encoded.length();
         int lat = 0, lng = 0, ele = 0;
-        while (index < len)
-        {
+        while (index < len) {
             // latitude
             int b, shift = 0, result = 0;
-            do
-            {
+            do {
                 b = encoded.charAt(index++) - 63;
                 result |= (b & 0x1f) << shift;
                 shift += 5;
@@ -72,8 +66,7 @@ public static PointList decodePolyline( String encoded, int initCap, boolean is3
             // longitute
             shift = 0;
             result = 0;
-            do
-            {
+            do {
                 b = encoded.charAt(index++) - 63;
                 result |= (b & 0x1f) << shift;
                 shift += 5;
@@ -81,13 +74,11 @@ public static PointList decodePolyline( String encoded, int initCap, boolean is3
             int deltaLongitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
             lng += deltaLongitude;
 
-            if (is3D)
-            {
+            if (is3D) {
                 // elevation
                 shift = 0;
                 result = 0;
-                do
-                {
+                do {
                     b = encoded.charAt(index++) - 63;
                     result |= (b & 0x1f) << shift;
                     shift += 5;
@@ -101,31 +92,27 @@ public static PointList decodePolyline( String encoded, int initCap, boolean is3
         return poly;
     }
 
-    public static String encodePolyline( PointList poly )
-    {
+    public static String encodePolyline(PointList poly) {
         if (poly.isEmpty())
             return "";
 
         return encodePolyline(poly, poly.is3D());
     }
 
-    public static String encodePolyline( PointList poly, boolean includeElevation )
-    {
+    public static String encodePolyline(PointList poly, boolean includeElevation) {
         StringBuilder sb = new StringBuilder();
         int size = poly.getSize();
         int prevLat = 0;
         int prevLon = 0;
         int prevEle = 0;
-        for (int i = 0; i < size; i++)
-        {
+        for (int i = 0; i < size; i++) {
             int num = (int) Math.floor(poly.getLatitude(i) * 1e5);
             encodeNumber(sb, num - prevLat);
             prevLat = num;
             num = (int) Math.floor(poly.getLongitude(i) * 1e5);
             encodeNumber(sb, num - prevLon);
             prevLon = num;
-            if (includeElevation)
-            {
+            if (includeElevation) {
                 num = (int) Math.floor(poly.getElevation(i) * 100);
                 encodeNumber(sb, num - prevEle);
                 prevEle = num;
@@ -134,15 +121,12 @@ public static String encodePolyline( PointList poly, boolean includeElevation )
         return sb.toString();
     }
 
-    private static void encodeNumber( StringBuilder sb, int num )
-    {
+    private static void encodeNumber(StringBuilder sb, int num) {
         num = num << 1;
-        if (num < 0)
-        {
+        if (num < 0) {
             num = ~num;
         }
-        while (num >= 0x20)
-        {
+        while (num >= 0x20) {
             int nextValue = (0x20 | (num & 0x1f)) + 63;
             sb.append((char) (nextValue));
             num >>= 5;
@@ -151,30 +135,24 @@ private static void encodeNumber( StringBuilder sb, int num )
         sb.append((char) (num));
     }
 
-    public static String readString( InputStream inputStream ) throws IOException
-    {
+    public static String readString(InputStream inputStream) throws IOException {
         String encoding = "UTF-8";
         InputStream in = new BufferedInputStream(inputStream, 4096);
-        try
-        {
+        try {
             byte[] buffer = new byte[4096];
             ByteArrayOutputStream output = new ByteArrayOutputStream();
             int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
+            while ((numRead = in.read(buffer)) != -1) {
                 output.write(buffer, 0, numRead);
             }
             return output.toString(encoding);
-        } finally
-        {
+        } finally {
             in.close();
         }
     }
 
-    public static GHPoint toGHPoint( JSONArray point )
-    {
-        if (point.length() == 3 && !Double.isNaN(point.getDouble(2)))
-        {
+    public static GHPoint toGHPoint(JSONArray point) {
+        if (point.length() == 3 && !Double.isNaN(point.getDouble(2))) {
             return new GHPoint3D(point.getDouble(1), point.getDouble(0), point.getDouble(2));
         }
 
diff --git a/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css b/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css
deleted file mode 100755
index fe4fc2a013..0000000000
--- a/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css
+++ /dev/null
@@ -1,11 +0,0 @@
-.lime-theme .leaflet-control.elevation .background{background-color:rgba(156,194,34,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.lime-theme .leaflet-control.elevation .axis line,.lime-theme .leaflet-control.elevation .axis path{fill:none;stroke:#566b13;stroke-width:2}
-.lime-theme .leaflet-control.elevation .area{fill:#9cc222}.lime-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#101404}.lime-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.lime-theme .leaflet-control.elevation-collapsed .background{display:none}.lime-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}
-.lime-theme .leaflet-control.elevation .mouse-drag{fill:rgba(99,126,11,.4)}.lime-theme .leaflet-overlay-pane .height-focus{stroke:#9cc222;fill:#9cc222}.lime-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}.steelblue-theme .leaflet-control.elevation .background{background-color:rgba(70,130,180,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.steelblue-theme .leaflet-control.elevation .axis line,.steelblue-theme .leaflet-control.elevation .axis path{fill:none;stroke:#0d1821;stroke-width:2}.steelblue-theme .leaflet-control.elevation .area{fill:#4682b4}.steelblue-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.steelblue-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.steelblue-theme .leaflet-control.elevation-collapsed .background{display:none}.steelblue-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.steelblue-theme .leaflet-control.elevation .mouse-drag{fill:rgba(23,74,117,.4)}.steelblue-theme .leaflet-overlay-pane .height-focus{stroke:#4682b4;fill:#4682b4}.steelblue-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}.purple-theme .leaflet-control.elevation .background{background-color:rgba(115,44,123,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.purple-theme .leaflet-control.elevation .axis line,.purple-theme .leaflet-control.elevation .axis path{fill:none;stroke:#2d1130;stroke-width:2}.purple-theme .leaflet-control.elevation .area{fill:#732c7b}.purple-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#000}.purple-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.purple-theme .leaflet-control.elevation-collapsed .background{display:none}.purple-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.purple-theme .leaflet-control.elevation .mouse-drag{fill:rgba(74,14,80,.4)}.purple-theme .leaflet-overlay-pane .height-focus{stroke:#732c7b;fill:#732c7b}.purple-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}
-
-.white-theme .leaflet-control.elevation .background{background-color:rgba(250,250,250,.6);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.white-theme .leaflet-control.elevation .axis path,.white-theme .leaflet-control.elevation .axis line{fill:none;stroke:#0d1821;stroke-width:2}
-.white-theme .leaflet-control.elevation .area{fill:#00cc33; opacity: 0.8}.white-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.white-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.white-theme .leaflet-control.elevation-collapsed .background{display:none}.white-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.white-theme .leaflet-overlay-pane .height-focus{stroke:#4682b4;fill:#4682b4}.white-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}
-.white-theme .leaflet-control.elevation .mouse-drag{fill:#00cc33; opacity: 0.2}
-.white-theme .leaflet-control.elevation .axis text{ x: -10; }
-.text {
-    color:#00cc33
-}
\ No newline at end of file
diff --git a/web/src/main/webapp/css/images/layers-2x.png b/web/src/main/webapp/css/images/layers-2x.png
index a2cf7f9efe..200c333dca 100755
Binary files a/web/src/main/webapp/css/images/layers-2x.png and b/web/src/main/webapp/css/images/layers-2x.png differ
diff --git a/web/src/main/webapp/css/images/layers.png b/web/src/main/webapp/css/images/layers.png
index bca0a0e429..1a72e5784b 100755
Binary files a/web/src/main/webapp/css/images/layers.png and b/web/src/main/webapp/css/images/layers.png differ
diff --git a/web/src/main/webapp/css/images/marker-icon-2x.png b/web/src/main/webapp/css/images/marker-icon-2x.png
index 0015b6495f..e4abba3b51 100755
Binary files a/web/src/main/webapp/css/images/marker-icon-2x.png and b/web/src/main/webapp/css/images/marker-icon-2x.png differ
diff --git a/web/src/main/webapp/css/images/marker-icon.png b/web/src/main/webapp/css/images/marker-icon.png
index e2e9f757f5..950edf2467 100755
Binary files a/web/src/main/webapp/css/images/marker-icon.png and b/web/src/main/webapp/css/images/marker-icon.png differ
diff --git a/web/src/main/webapp/css/images/marker-shadow.png b/web/src/main/webapp/css/images/marker-shadow.png
index d1e773c715..9fd2979532 100755
Binary files a/web/src/main/webapp/css/images/marker-shadow.png and b/web/src/main/webapp/css/images/marker-shadow.png differ
diff --git a/web/src/main/webapp/css/leaflet.contextmenu.css b/web/src/main/webapp/css/leaflet.contextmenu.css
index cd83d4b2ab..0b5e2defca 100755
--- a/web/src/main/webapp/css/leaflet.contextmenu.css
+++ b/web/src/main/webapp/css/leaflet.contextmenu.css
@@ -28,10 +28,6 @@
     opacity: 0.5;
 }
 
-.leaflet-contextmenu a.leaflet-contextmenu-item-hidden {
-    display: none;
-}
-
 .leaflet-contextmenu a.leaflet-contextmenu-item.over {
     background-color: #f4f4f4;
     border-top: 1px solid #f0f0f0;
@@ -56,7 +52,3 @@
     border-bottom: 1px solid #ccc;
     margin: 5px 0;
 }
-
-.leaflet-contextmenu-separator-hidden {
-    display: none;
-}
\ No newline at end of file
diff --git a/web/src/main/webapp/css/leaflet.css b/web/src/main/webapp/css/leaflet.css
index 1232550253..82bbf8d047 100755
--- a/web/src/main/webapp/css/leaflet.css
+++ b/web/src/main/webapp/css/leaflet.css
@@ -1,16 +1,12 @@
 /* required styles */
 
-.leaflet-map-pane,
+.leaflet-pane,
 .leaflet-tile,
 .leaflet-marker-icon,
 .leaflet-marker-shadow,
-.leaflet-tile-pane,
 .leaflet-tile-container,
-.leaflet-overlay-pane,
-.leaflet-shadow-pane,
-.leaflet-marker-pane,
-.leaflet-popup-pane,
-.leaflet-overlay-pane svg,
+.leaflet-map-pane svg,
+.leaflet-map-pane canvas,
 .leaflet-zoom-box,
 .leaflet-image-layer,
 .leaflet-layer {
@@ -20,7 +16,6 @@
 	}
 .leaflet-container {
 	overflow: hidden;
-	-ms-touch-action: none;
 	}
 .leaflet-tile,
 .leaflet-marker-icon,
@@ -28,20 +23,42 @@
 	-webkit-user-select: none;
 	   -moz-user-select: none;
 	        user-select: none;
-	-webkit-user-drag: none;
+	  -webkit-user-drag: none;
+	}
+/* Safari renders non-retina tile on retina better with this, but Chrome is worse */
+.leaflet-safari .leaflet-tile {
+	image-rendering: -webkit-optimize-contrast;
+	}
+/* hack that prevents hw layers "stretching" when loading new tiles */
+.leaflet-safari .leaflet-tile-container {
+	width: 1600px;
+	height: 1600px;
+	-webkit-transform-origin: 0 0;
 	}
 .leaflet-marker-icon,
 .leaflet-marker-shadow {
 	display: block;
 	}
-/* map is broken in FF if you have max-width: 100% on tiles */
-.leaflet-container img {
+/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */
+/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */
+.leaflet-container .leaflet-overlay-pane svg,
+.leaflet-container .leaflet-marker-pane img,
+.leaflet-container .leaflet-tile-pane img,
+.leaflet-container img.leaflet-image-layer {
 	max-width: none !important;
 	}
-/* stupid Android 2 doesn't understand "max-width: none" properly */
-.leaflet-container img.leaflet-image-layer {
-	max-width: 15000px !important;
+
+.leaflet-container.leaflet-touch-zoom {
+	-ms-touch-action: pan-x pan-y;
+	touch-action: pan-x pan-y;
+	}
+.leaflet-container.leaflet-touch-drag {
+	-ms-touch-action: pinch-zoom;
 	}
+.leaflet-container.leaflet-touch-drag.leaflet-touch-drag {
+	-ms-touch-action: none;
+	touch-action: none;
+}
 .leaflet-tile {
 	filter: inherit;
 	visibility: hidden;
@@ -52,18 +69,26 @@
 .leaflet-zoom-box {
 	width: 0;
 	height: 0;
+	-moz-box-sizing: border-box;
+	     box-sizing: border-box;
+	z-index: 800;
 	}
 /* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
 .leaflet-overlay-pane svg {
 	-moz-user-select: none;
 	}
 
-.leaflet-tile-pane    { z-index: 2; }
-.leaflet-objects-pane { z-index: 3; }
-.leaflet-overlay-pane { z-index: 4; }
-.leaflet-shadow-pane  { z-index: 5; }
-.leaflet-marker-pane  { z-index: 6; }
-.leaflet-popup-pane   { z-index: 7; }
+.leaflet-pane         { z-index: 400; }
+
+.leaflet-tile-pane    { z-index: 200; }
+.leaflet-overlay-pane { z-index: 400; }
+.leaflet-shadow-pane  { z-index: 500; }
+.leaflet-marker-pane  { z-index: 600; }
+.leaflet-tooltip-pane   { z-index: 650; }
+.leaflet-popup-pane   { z-index: 700; }
+
+.leaflet-map-pane canvas { z-index: 100; }
+.leaflet-map-pane svg    { z-index: 200; }
 
 .leaflet-vml-shape {
 	width: 1px;
@@ -80,7 +105,8 @@
 
 .leaflet-control {
 	position: relative;
-	z-index: 7;
+	z-index: 800;
+	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
 	pointer-events: auto;
 	}
 .leaflet-top,
@@ -124,7 +150,9 @@
 
 /* zoom and fade animations */
 
-.leaflet-fade-anim .leaflet-tile,
+.leaflet-fade-anim .leaflet-tile {
+	will-change: opacity;
+	}
 .leaflet-fade-anim .leaflet-popup {
 	opacity: 0;
 	-webkit-transition: opacity 0.2s linear;
@@ -132,11 +160,17 @@
 	     -o-transition: opacity 0.2s linear;
 	        transition: opacity 0.2s linear;
 	}
-.leaflet-fade-anim .leaflet-tile-loaded,
 .leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
 	opacity: 1;
 	}
-
+.leaflet-zoom-animated {
+	-webkit-transform-origin: 0 0;
+	    -ms-transform-origin: 0 0;
+	        transform-origin: 0 0;
+	}
+.leaflet-zoom-anim .leaflet-zoom-animated {
+	will-change: transform;
+	}
 .leaflet-zoom-anim .leaflet-zoom-animated {
 	-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
 	   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
@@ -144,8 +178,7 @@
 	        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);
 	}
 .leaflet-zoom-anim .leaflet-tile,
-.leaflet-pan-anim .leaflet-tile,
-.leaflet-touching .leaflet-zoom-animated {
+.leaflet-pan-anim .leaflet-tile {
 	-webkit-transition: none;
 	   -moz-transition: none;
 	     -o-transition: none;
@@ -159,24 +192,44 @@
 
 /* cursors */
 
-.leaflet-clickable {
+.leaflet-interactive {
 	cursor: pointer;
 	}
-.leaflet-container {
+.leaflet-grab {
 	cursor: -webkit-grab;
 	cursor:    -moz-grab;
 	}
+.leaflet-crosshair,
+.leaflet-crosshair .leaflet-interactive {
+	cursor: crosshair;
+	}
 .leaflet-popup-pane,
 .leaflet-control {
 	cursor: auto;
 	}
-.leaflet-dragging .leaflet-container,
-.leaflet-dragging .leaflet-clickable {
+.leaflet-dragging .leaflet-grab,
+.leaflet-dragging .leaflet-grab .leaflet-interactive,
+.leaflet-dragging .leaflet-marker-draggable {
 	cursor: move;
 	cursor: -webkit-grabbing;
 	cursor:    -moz-grabbing;
 	}
 
+/* marker & overlays interactivity */
+.leaflet-marker-icon,
+.leaflet-marker-shadow,
+.leaflet-image-layer,
+.leaflet-pane > svg path,
+.leaflet-tile-container {
+	pointer-events: none;
+	}
+
+.leaflet-marker-icon.leaflet-interactive,
+.leaflet-image-layer.leaflet-interactive,
+.leaflet-pane > svg path.leaflet-interactive {
+	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
+	pointer-events: auto;
+	}
 
 /* visual tweaks */
 
@@ -303,6 +356,10 @@
 	color: #333;
 	background: #fff;
 	}
+.leaflet-control-layers-scrollbar {
+	overflow-y: scroll;
+	padding-right: 5px;
+	}
 .leaflet-control-layers-selector {
 	margin-top: 2px;
 	position: relative;
@@ -317,6 +374,11 @@
 	margin: 5px -10px 5px -6px;
 	}
 
+/* Default icon URLs */
+.leaflet-default-icon-path {
+	background-image: url(images/marker-icon.png);
+	}
+
 
 /* attribution and scale controls */
 
@@ -354,8 +416,8 @@
 	font-size: 11px;
 	white-space: nowrap;
 	overflow: hidden;
-	-moz-box-sizing: content-box;
-	     box-sizing: content-box;
+	-moz-box-sizing: border-box;
+	     box-sizing: border-box;
 
 	background: #fff;
 	background: rgba(255, 255, 255, 0.5);
@@ -386,6 +448,7 @@
 .leaflet-popup {
 	position: absolute;
 	text-align: center;
+	margin-bottom: 20px;
 	}
 .leaflet-popup-content-wrapper {
 	padding: 1px;
@@ -400,11 +463,13 @@
 	margin: 18px 0;
 	}
 .leaflet-popup-tip-container {
-	margin: 0 auto;
 	width: 40px;
 	height: 20px;
-	position: relative;
+	position: absolute;
+	left: 50%;
+	margin-left: -20px;
 	overflow: hidden;
+	pointer-events: none;
 	}
 .leaflet-popup-tip {
 	width: 17px;
@@ -422,7 +487,7 @@
 .leaflet-popup-content-wrapper,
 .leaflet-popup-tip {
 	background: white;
-
+	color: #333;
 	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
 	}
 .leaflet-container a.leaflet-popup-close-button {
@@ -430,6 +495,7 @@
 	top: 0;
 	right: 0;
 	padding: 4px 4px 0 0;
+	border: none;
 	text-align: center;
 	width: 18px;
 	height: 14px;
@@ -476,3 +542,82 @@
 	background: #fff;
 	border: 1px solid #666;
 	}
+
+
+/* Tooltip */
+/* Base styles for the element that has a tooltip */
+.leaflet-tooltip {
+	position: absolute;
+	padding: 6px;
+	background-color: #fff;
+	border: 1px solid #fff;
+	border-radius: 3px;
+	color: #222;
+	white-space: nowrap;
+	-webkit-user-select: none;
+	-moz-user-select: none;
+	-ms-user-select: none;
+	user-select: none;
+	pointer-events: none;
+	box-shadow: 0 1px 3px rgba(0,0,0,0.4);
+	}
+.leaflet-tooltip.leaflet-clickable {
+	cursor: pointer;
+	pointer-events: auto;
+	}
+.leaflet-tooltip-top:before,
+.leaflet-tooltip-bottom:before,
+.leaflet-tooltip-left:before,
+.leaflet-tooltip-right:before {
+	position: absolute;
+	pointer-events: none;
+	border: 6px solid transparent;
+	background: transparent;
+	content: "";
+	}
+
+/* Directions */
+
+.leaflet-tooltip-bottom {
+	margin-top: 6px;
+}
+.leaflet-tooltip-top {
+	margin-top: -6px;
+}
+.leaflet-tooltip-bottom:before,
+.leaflet-tooltip-top:before {
+	left: 50%;
+	margin-left: -6px;
+	}
+.leaflet-tooltip-top:before {
+	bottom: 0;
+	margin-bottom: -12px;
+	border-top-color: #fff;
+	}
+.leaflet-tooltip-bottom:before {
+	top: 0;
+	margin-top: -12px;
+	margin-left: -6px;
+	border-bottom-color: #fff;
+	}
+.leaflet-tooltip-left {
+	margin-left: -6px;
+}
+.leaflet-tooltip-right {
+	margin-left: 6px;
+}
+.leaflet-tooltip-left:before,
+.leaflet-tooltip-right:before {
+	top: 50%;
+	margin-top: -6px;
+	}
+.leaflet-tooltip-left:before {
+	right: 0;
+	margin-right: -12px;
+	border-left-color: #fff;
+	}
+.leaflet-tooltip-right:before {
+	left: 0;
+	margin-left: -12px;
+	border-right-color: #fff;
+	}
diff --git a/web/src/main/webapp/css/leaflet.elevation-0.0.4.css b/web/src/main/webapp/css/leaflet.elevation-0.0.4.css
new file mode 100644
index 0000000000..e41ce7da8c
--- /dev/null
+++ b/web/src/main/webapp/css/leaflet.elevation-0.0.4.css
@@ -0,0 +1,11 @@
+.lime-theme.leaflet-control.elevation .background{background-color:rgba(156,194,34,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.lime-theme.leaflet-control.elevation .axis line,.lime-theme.leaflet-control.elevation .axis path{fill:none;stroke:#566b13;stroke-width:2}
+.lime-theme.leaflet-control.elevation .area{fill:#9cc222}.lime-theme.leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#101404}.lime-theme.leaflet-control.elevation-collapsed .background{display:none}.lime-theme.leaflet-control.elevation-collapsed .elevation-toggle{display:block}.lime-theme.height-focus{stroke:#9cc222;fill:#9cc222}.lime-theme.height-focus.line{pointer-events:none;stroke-width:2}.steelblue-theme.leaflet-control.elevation .background{background-color:rgba(70,130,180,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.steelblue-theme.leaflet-control.elevation .axis line,.steelblue-theme.leaflet-control.elevation .axis path{fill:none;stroke:#0d1821;stroke-width:2}.steelblue-theme.leaflet-control.elevation .mouse-drag{fill:rgba(23,74,117,.4)}.steelblue-theme.leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background-color:#f8f8f9}.steelblue-theme.leaflet-control.elevation .elevation-toggle-icon{background:url(images/elevation-steelblue.png) no-repeat center center}.steelblue-theme.leaflet-control.elevation .area{fill:#4682b4}.steelblue-theme.leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.steelblue-theme.leaflet-control.elevation-collapsed .background{display:none}.steelblue-theme.leaflet-control.elevation-collapsed .elevation-toggle{display:block}.steelblue-theme.height-focus{stroke:#4682b4;fill:#4682b4}.steelblue-theme.height-focus.line{pointer-events:none;stroke-width:2}.purple-theme.leaflet-control.elevation .background{background-color:rgba(115,44,123,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.purple-theme.leaflet-control.elevation .axis line,.purple-theme.leaflet-control.elevation .axis path{fill:none;stroke:#2d1130;stroke-width:2}.purple-theme.leaflet-control.elevation .mouse-drag{fill:rgba(74,14,80,.4)}.purple-theme.leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background-color:#f8f8f9}.purple-theme.leaflet-control.elevation .elevation-toggle-icon{background:url(images/elevation-purple.png) no-repeat center center}.purple-theme.leaflet-control.elevation .area{fill:#732c7b}.purple-theme.leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#000}.purple-theme.leaflet-control.elevation-collapsed .background{display:none}.purple-theme.leaflet-control.elevation-collapsed .elevation-toggle{display:block}.purple-theme.height-focus{stroke:#732c7b;fill:#732c7b}.purple-theme.height-focus.line{pointer-events:none;stroke-width:2}
+.lime-theme.leaflet-control.elevation .mouse-drag{fill:rgba(99,126,11,.4)}.lime-theme.leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background-color:#f8f8f9}.lime-theme.leaflet-control.elevation .elevation-toggle-icon{background:url(images/elevation-lime.png) no-repeat center center}
+
+.white-theme.leaflet-control.elevation .background{background-color:rgba(250,250,250,.6);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.white-theme.leaflet-control.elevation .axis path,.white-theme.leaflet-control.elevation .axis line{fill:none;stroke:#0d1821;stroke-width:2}
+.white-theme.leaflet-control.elevation .area{fill:#00cc33; opacity: 0.8}.white-theme.leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.white-theme.leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.white-theme.leaflet-control.elevation-collapsed .background{display:none}.white-theme.leaflet-control.elevation-collapsed .elevation-toggle{display:block}.white-theme.leaflet-overlay-pane .height-focus{stroke:#4682b4;fill:#4682b4}.white-theme.leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}
+.white-theme.leaflet-control.elevation .mouse-drag{fill:#00cc33; opacity: 0.2}
+.white-theme.leaflet-control.elevation .axis text{ x: -10; }
+.text {
+    color:#00cc33
+}
diff --git a/web/src/main/webapp/css/style.css b/web/src/main/webapp/css/style.css
index 70fdd1d262..c573de2676 100755
--- a/web/src/main/webapp/css/style.css
+++ b/web/src/main/webapp/css/style.css
@@ -1,8 +1,7 @@
 body {
-    color: #000;
     font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
     line-height: 1.4;
-    color: #111111;
+    color: #111;
     background-color: white;
     margin: 0;
     min-width: 700px;
@@ -18,7 +17,7 @@ body {
     /*padding-right: 15px; */
 }
 
-#info {    
+#info {
     margin-top: 10px;
     display: none;
     padding: 5px;
@@ -28,7 +27,7 @@ body {
     padding-right: 5px;
 }
 
-.route_results {    
+.route_results {
     max-height: 40%;
 }
 
@@ -186,7 +185,7 @@ body {
 }
 #hosting {
     display: none;
-    /*    float: left;*/
+    /* float: left;*/
     padding-top: 4px;
     padding-bottom: 10px;
     /* color: #666666; */
@@ -221,7 +220,7 @@ tr.instruction {
     border-bottom: #dadada dashed thin;
 }
 
-.instructions {    
+.instructions {
     table-layout:fixed;
     border-collapse: collapse;
     padding-top: 10px;
@@ -302,7 +301,7 @@ td img.pic {
 .wikilink { float: right; }
 .wikilink img { max-width: 16px; }
 
-.nameseg { /*border-top: #dadada dashed thin;*/ }
+/* .nameseg { border-top: #dadada dashed thin; } */
 .cityseg { float: left; font-size: 10px; }
 .moreseg { float: right; font-size: 9px; }
 
@@ -310,7 +309,7 @@ td img.pic {
     width: 16px;
     height: 16px;
 }
-.pointFlag:hover { cursor: n-resize; }
+.pointFlag:hover { cursor: ns-resize; }
 .pointAdd {
     padding-left: 3px;
 }
@@ -321,7 +320,7 @@ td img.pic {
 .pointDelete:hover, .pointAdd:hover { cursor: pointer; }
 .pointDelete:disabled {
     background: red;
-} 
+}
 
 .expandDetails {
     color: gray;
@@ -331,21 +330,26 @@ td img.pic {
     width: 20px;
     height: 20px;
     height: 20px;
-    margin: 0px 10px;
-    padding: 0px;
+    margin: 0 10px;
+    padding: 0;
     background-image: linear-gradient(to bottom, white, #e7e7e7);
 }
 #moreButton {
     background-image: linear-gradient(to bottom, white, #e7e7e7);
 }
 
-.ui-dialog > .ui-widget-header{
-    padding:1em;    
+.ui-dialog {
+  /* Must be > 700, the z-index of .leaflet-popup-pane */
+  z-index: 1000;
+}
+
+.ui-dialog > .ui-widget-header {
+    padding: 1em;
     border: 1px solid black;
 }
 
 .ui-dialog .ui-dialog-content {
-    padding:1em
+    padding: 1em;
 }
 
 .ui-dialog .ui-widget-content {
@@ -367,8 +371,8 @@ td img.pic {
 }
 
 #route_result_tabs {
-    list-style: none; 
-    padding: 0; 
+    list-style: none;
+    padding: 0;
     margin: 0;
 }
 
@@ -392,7 +396,7 @@ td img.pic {
 }
 
 .route_result_tab.current {
-    display: block;    
+    display: block;
 }
 
 #donate_form {
@@ -402,8 +406,20 @@ td img.pic {
 #donate_form_button {
     background: none;
     border: none;
-    padding-left: 0px;
+    padding-left: 0;
     margin-top: 5px;
     cursor: pointer;
     float: left;
 }
+
+.gray {
+    color: gray;
+}
+
+.plain_text_button {
+    font-size: small;
+    padding: 0;
+    border: none;
+    background: none;
+    cursor: pointer;
+}
diff --git a/web/src/main/webapp/img/indicator.gif b/web/src/main/webapp/img/indicator.gif
index 7dfc4bf477..e192ca895c 100755
Binary files a/web/src/main/webapp/img/indicator.gif and b/web/src/main/webapp/img/indicator.gif differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index 97db45c0dc..d41d425eeb 100755
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -8,13 +8,13 @@
         <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
         <title>Driving Directions - GraphHopper Maps</title>
         <meta name="description" content="A fast route planner for biking, hiking and more! Based on OpenStreetMap including elevation data. Try out for free!"/>
-        <link rel="stylesheet" href="css/leaflet.css?v=0.7.3" />
-        <link rel="stylesheet" href="css/Leaflet.Elevation-0.0.2.css" />
+        <link rel="stylesheet" href="css/leaflet.css?v=1.0.1" />
+        <link rel="stylesheet" href="css/leaflet.elevation-0.0.4.css" />
         <link rel="stylesheet" href="css/leaflet_numbered_markers.css" />
         <link rel="stylesheet" href="css/leaflet.contextmenu.css" />
         <link rel="stylesheet" href="css/leaflet.loading.css" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui.min.css" />
-        <script type="text/javascript" src="js/main.js?v=0.7.0"></script>
+        <script type="text/javascript" src="js/main.js?v=0.8.0"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
     </head>
     <body>
diff --git a/web/src/main/webapp/js/gpxexport.js b/web/src/main/webapp/js/gpxexport.js
index 1f3c001488..40ddcc0082 100755
--- a/web/src/main/webapp/js/gpxexport.js
+++ b/web/src/main/webapp/js/gpxexport.js
@@ -10,8 +10,7 @@ var ensureOneCheckboxSelected = function () {
                 if (!$("#gpx_waypoints").is(':checked'))
                     $("#gpx_track").prop("disabled", true);
             }
-        }
-        else
+        } else
         {
             $("#gpx_track").prop("disabled", false);
             $("#gpx_waypoints").prop("disabled", false);
@@ -26,8 +25,7 @@ var ensureOneCheckboxSelected = function () {
                 if (!$("#gpx_waypoints").is(':checked'))
                     $("#gpx_route").prop("disabled", true);
             }
-        }
-        else
+        } else
         {
             $("#gpx_route").prop("disabled", false);
             $("#gpx_waypoints").prop("disabled", false);
@@ -42,8 +40,7 @@ var ensureOneCheckboxSelected = function () {
                 if (!$("#gpx_track").is(':checked'))
                     $("#gpx_route").prop("disabled", true);
             }
-        }
-        else
+        } else
         {
             $("#gpx_route").prop("disabled", false);
             $("#gpx_track").prop("disabled", false);
diff --git a/web/src/main/webapp/js/graphhopper/GHRequest.js b/web/src/main/webapp/js/graphhopper/GHRequest.js
index fcb0199a14..da385da5da 100755
--- a/web/src/main/webapp/js/graphhopper/GHRequest.js
+++ b/web/src/main/webapp/js/graphhopper/GHRequest.js
@@ -38,6 +38,7 @@ var GHRequest = function (host, api_key) {
     this.features = {};
 
     this.do_zoom = true;
+    this.useMiles = false;
     // use jsonp here if host allows CORS
     this.dataType = "json";
     this.api_params = {"locale": "en", "vehicle": "car", "weighting": "fastest", "elevation": false};
@@ -70,7 +71,7 @@ GHRequest.prototype.init = function (params) {
         else if (val === "true")
             val = true;
 
-        if (key === "point" || key === "mathRandom" || key === "do_zoom" || key === "layer")
+        if (key === "point" || key === "mathRandom" || key === "do_zoom" || key === "layer" || key === "use_miles")
             continue;
 
         this.api_params[key] = val;
@@ -79,6 +80,9 @@ GHRequest.prototype.init = function (params) {
     if ('do_zoom' in params)
         this.do_zoom = params.do_zoom;
 
+    if ('use_miles' in params)
+        this.useMiles = params.use_miles;
+
     // overwrite elevation e.g. important if not supported from feature set
     this.api_params.elevation = false;
     var featureSet = this.features[this.api_params.vehicle];
@@ -159,7 +163,7 @@ GHRequest.prototype.createGPXURL = function (withRoute, withTrack, withWayPoints
 };
 
 GHRequest.prototype.createHistoryURL = function () {
-    return this.createPath("?" + this.createPointParams(true));
+    return this.createPath("?" + this.createPointParams(true)) + "&use_miles=" + !!this.useMiles;
 };
 
 GHRequest.prototype.createPointParams = function (useRawInput) {
diff --git a/web/src/main/webapp/js/instructions.js b/web/src/main/webapp/js/instructions.js
index 631e041635..f64f3310b8 100755
--- a/web/src/main/webapp/js/instructions.js
+++ b/web/src/main/webapp/js/instructions.js
@@ -3,7 +3,7 @@ var messages = require('./messages.js');
 
 var routeSegmentPopup = null;
 
-function addInstruction(mapLayer, main, instr, instrIndex, lngLat) {
+function addInstruction(mapLayer, main, instr, instrIndex, lngLat, useMiles) {
     var sign = instr.sign;
     if (instrIndex === 0)
         sign = "marker-icon-green";
@@ -17,10 +17,13 @@ function addInstruction(mapLayer, main, instr, instrIndex, lngLat) {
             title = title + ", " + instr.annotation_text;
     }
 
+    var pathname = window.location.pathname;
+    var dirname = pathname.substring(0, pathname.lastIndexOf('/'));
+
     var instructionDiv = $("<tr class='instruction'/>");
     if (sign !== "continue") {
         var indiPic = "<img class='pic' style='vertical-align: middle' src='" +
-                window.location.pathname + "img/" + sign + ".png'/>";
+                dirname + "/img/" + sign + ".png'/>";
         instructionDiv.append("<td class='instr_pic'>" + indiPic + "</td>");
     } else
         instructionDiv.append("<td class='instr_pic'/>");
@@ -31,7 +34,7 @@ function addInstruction(mapLayer, main, instr, instrIndex, lngLat) {
     instructionDiv.append(tdVar);
     var distance = instr.distance;
     if (distance > 0) {
-        instructionDiv.append("<td class='instr_distance'><span>" + translate.createDistanceString(distance) + "<br/>" + translate.createTimeString(instr.time) + "</span></td>");
+        instructionDiv.append("<td class='instr_distance'><span>" + translate.createDistanceString(distance, useMiles) + "<br/>" + translate.createTimeString(instr.time) + "</span></td>");
     }
 
     if (lngLat) {
@@ -56,7 +59,7 @@ module.exports.create = function (mapLayer, path, urlForHistory, request) {
     for (var m = 0; m < len; m++) {
         var instr = path.instructions[m];
         var lngLat = path.points.coordinates[instr.interval[0]];
-        addInstruction(mapLayer, instructionsElement, instr, m, lngLat);
+        addInstruction(mapLayer, instructionsElement, instr, m, lngLat, request.useMiles);
     }
     var infoDiv = $("<div class='instructions_info'>");
     infoDiv.append(instructionsElement);
@@ -68,7 +71,7 @@ module.exports.create = function (mapLayer, path, urlForHistory, request) {
             for (var m = len; m < path.instructions.length; m++) {
                 var instr = path.instructions[m];
                 var lngLat = path.points.coordinates[instr.interval[0]];
-                addInstruction(mapLayer, instructionsElement, instr, m, lngLat);
+                addInstruction(mapLayer, instructionsElement, instr, m, lngLat, request.useMiles);
             }
         });
         instructionsElement.append(moreDiv);
diff --git a/web/src/main/webapp/js/lib/Leaflet.Elevation-0.0.2.min.js b/web/src/main/webapp/js/lib/Leaflet.Elevation-0.0.2.min.js
deleted file mode 100755
index 198bd29237..0000000000
--- a/web/src/main/webapp/js/lib/Leaflet.Elevation-0.0.2.min.js
+++ /dev/null
@@ -1,2 +0,0 @@
-/*! Leaflet.Elevation 05-03-2014 */
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1},onRemove:function(){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter,d3.select("body").classed(b.theme,!0);var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){return d(a.dist)}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(){return d3.mouse(h.select("g"))[0]}).y(function(){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle",a);b.href="#",b.title="Elevation",L.Browser.touch?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-36).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),b=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",a[0]).attr("y1",0).attr("x2",a[0]).attr("y2",this._height()).classed("hidden",!1);var c=(d3.bisector(function(a){return a.dist}).left,this._data[this._findItemForX(a[0])]),d=c.altitude,e=c.dist,f=c.latlng,g=b.hoverNumber.formatter(d,b.hoverNumber.decimalsY),h=b.hoverNumber.formatter(e,b.hoverNumber.decimalsX);this._focuslabelX.attr("x",a[0]).text(g+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",a[0]).text(h+" km");var i=this._map.latLngToLayerPoint(f);if(b.useHeightIndicator){if(!this._mouseHeightFocus){var j=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=j.append("svg:line").attr("class","height-focus line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0");var k=this._pointG=j.append("g");k.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class","height-focus circle-lower"),this._mouseHeightFocusLabel=j.append("svg:text").attr("class","height-focus-label").style("pointer-events","none")}var l=this._height()/this._maxElevation*d,m=i.y-l;this._mouseHeightFocus.attr("x1",i.x).attr("x2",i.x).attr("y1",i.y).attr("y2",m).style("visibility","visible"),this._pointG.attr("transform","translate("+i.x+","+i.y+")").style("visibility","visible"),this._mouseHeightFocusLabel.attr("x",i.x).attr("y",m).text(d+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(f):this._marker=new L.Marker(f).addTo(this._map)}},_addGeoJSONData:function(a){if(a){for(var b=this._data||[],c=this._dist||0,d=this._maxElevation||0,e=0;e<a.length;e++){var f=new L.LatLng(a[e][1],a[e][0]),g=new L.LatLng(a[e?e-1:0][1],a[e?e-1:0][0]),h=f.distanceTo(g);c+=Math.round(h/1e3*1e5)/1e5,d=d<a[e][2]?a[e][2]:d,b.push({dist:c,altitude:a[e][2],x:a[e][0],y:a[e][1],latlng:f})}this._dist=c,this._data=b,this._maxElevation=d}},_addGPXdata:function(a){if(a){for(var b=this._data||[],c=this._dist||0,d=this._maxElevation||0,e=0;e<a.length;e++){var f=a[e],g=a[e?e-1:0],h=f.distanceTo(g);c+=Math.round(h/1e3*1e5)/1e5,d=d<f.meta.ele?f.meta.ele:d,b.push({dist:c,altitude:f.meta.ele,x:f.lng,y:f.lat,latlng:f})}this._dist=c,this._data=b,this._maxElevation=d}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a){this._addData(a),this._container&&this._applyData()},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
diff --git a/web/src/main/webapp/js/lib/leaflet.contextmenu.js b/web/src/main/webapp/js/lib/leaflet.contextmenu.js
deleted file mode 100755
index 4cae713af9..0000000000
--- a/web/src/main/webapp/js/lib/leaflet.contextmenu.js
+++ /dev/null
@@ -1,618 +0,0 @@
-/*
-Leaflet.contextmenu, a context menu for Leaflet.
-(c) 2014, Adam Ratcliffe, GeoSmart Maps Limited
-contribute 2014, Roland Braband, NRC
- */
-L.Map.mergeOptions({
-    contextmenuItems : []
-});
-
-L.Map.ContextMenu = L.Handler.extend({
-
-        statics : {
-            BASE_CLS : 'leaflet-contextmenu'
-        },
-
-        initialize : function (map) {
-            L.Handler.prototype.initialize.call(this, map);
-
-            this._items = [];
-            this._sets = [];
-            this._state = 0;
-            this._defaultState = map.options.contextmenuDefaultState || 1;
-            this._activeState = map.options.contextmenuAtiveState || 1;
-            this._visible = false;
-
-            var container = this._container = L.DomUtil.create('div', L.Map.ContextMenu.BASE_CLS, map._container);
-            container.style.zIndex = 1e4;
-            container.style.position = 'absolute';
-
-            if (map.options.contextmenuWidth) {
-                container.style.width = map.options.contextmenuWidth + 'px';
-            }
-            if (map.options.contextmenuSets === undefined || map.options.contextmenuSets.length === 0) {
-                map.options.contextmenuSets = [{
-                        name : 'set_default',
-                        state : this._defaultState
-                    }
-                ];
-            }
-
-            this._createItems();
-            this._createSets();
-            this._changeState();
-            L.DomEvent
-            .on(container, 'click', L.DomEvent.stop)
-            .on(container, 'mousedown', L.DomEvent.stop)
-            .on(container, 'dblclick', L.DomEvent.stop)
-            .on(container, 'contextmenu', L.DomEvent.stop);
-        },
-
-        addHooks : function () {
-            L.DomEvent
-            .on(document, ((L.Browser.touch) ? 'touchstart' : 'mousedown'), this._onMouseDown, this)
-            .on(document, 'keydown', this._onKeyDown, this);
-
-            this._map.on({
-                contextmenu : this._show,
-                mouseout : this._hide,
-                mousedown : this._hide,
-                movestart : this._hide,
-                zoomstart : this._hide
-            }, this);
-        },
-
-        removeHooks : function () {
-            L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
-
-            this._map.off({
-                contextmenu : this._show,
-                mouseout : this._hide,
-                mousedown : this._hide,
-                movestart : this._hide,
-                zoomstart : this._hide
-            }, this);
-
-        },
-
-        showAt : function (point, data, state) {
-            if (point instanceof L.LatLng) {
-                point = this._map.latLngToContainerPoint(point);
-            }
-            this._showAtPoint(point, data, state);
-        },
-
-        hide : function () {
-            this._hide();
-        },
-
-        setState : function (state) {
-            return this._changeState(state);
-        },
-
-        setActiveState : function (state) {
-            var set,
-            state = (state !== undefined) ? state : this._activeState,
-            el,
-            i,
-            l;
-
-            for (i = 0, l = this._sets.length; i < l; i++) {
-                set = this._sets[i];
-                if (set.state === state) {
-                    this._activeState = state;
-                    break;
-                }
-            }
-            return set;
-        },
-
-        getState : function () {
-            return this._state;
-        },
-
-        addSet : function (options) {
-            return this.insertSet(options);
-        },
-
-        insertSet : function (options, id) {
-            var id = (id !== undefined) ? id : this._sets.length,
-            set = this._createSet(options, id);
-
-            this._sets.push(set);
-            return set;
-        },
-
-        addItem : function (options) {
-            return this.insertItem(options);
-        },
-
-        insertItem : function (options, index) {
-            var index = (index !== undefined) ? index : this._items.length,
-            item = this._createItem(this._container, options, index);
-
-            this._items.push(item);
-            this._sizeChanged = true;
-            this._map.fire('contextmenu.additem', {
-                contextmenu : this,
-                el : item.el,
-                index : index
-            });
-
-            return item.el;
-        },
-
-        removeItem : function (item) {
-            var container = this._container;
-
-            if (!isNaN(item)) {
-                item = container.children[item];
-            }
-
-            if (item !== undefined) {
-                this._removeItem(L.Util.stamp(item));
-
-                this._sizeChanged = true;
-
-                this._map.fire('contextmenu.removeitem', {
-                    contextmenu : this,
-                    el : item
-                });
-
-            }
-        },
-
-        removeAllItems : function () {
-            var item;
-            
-            while (this._container.children.length) {
-                item = this._container.children[0];
-                this._removeItem(L.Util.stamp(item));
-            }
-        },
-
-        setDisabled : function (item, disabled) {
-            var container = this._container,
-            itemCls = L.Map.ContextMenu.BASE_CLS + '-item';
-
-            if (!isNaN(item)) {
-                item = container.children[item];
-            }
-
-            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
-                if (disabled) {
-                    L.DomUtil.addClass(item, itemCls + '-disabled');
-                    this._map.fire('contextmenu.disableitem', {
-                        contextmenu : this,
-                        el : item
-                    });
-                } else {
-                    L.DomUtil.removeClass(item, itemCls + '-disabled');
-                    this._map.fire('contextmenu.enableitem', {
-                        contextmenu : this,
-                        el : item
-                    });
-                }
-            }
-        },
-
-        setHidden : function (item, hidden) {
-            var container = this._container,
-            itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
-            separatorCls = L.Map.ContextMenu.BASE_CLS + '-separator';
-
-            if (!isNaN(item)) {
-                item = container.children[item];
-            }
-            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
-                if (hidden) {
-                    L.DomUtil.addClass(item, itemCls + '-hidden');
-                    this._map.fire('contextmenu.hideitem', {
-                        contextmenu : this,
-                        el : item
-                    });
-
-                } else {
-                    L.DomUtil.removeClass(item, itemCls + '-hidden');
-                    this._map.fire('contextmenu.showitem', {
-                        contextmenu : this,
-                        el : item
-                    });
-                }
-            } else if (item !== undefined && L.DomUtil.hasClass(item, separatorCls)) {
-                if (hidden) {
-                    L.DomUtil.addClass(item, separatorCls + '-hidden');
-                } else {
-                    L.DomUtil.removeClass(item, separatorCls + '-hidden');
-                }
-            }
-        },
-
-        isVisible : function () {
-            return this._visible;
-        },
-
-        // private methods
-        _changeState : function (state) {
-            var set,
-            state = (state !== undefined) ? state : this._defaultState,
-            item,
-            el,
-            i,
-            l;
-            
-            if (state !== this._state) {
-                for (i = 0, l = this._sets.length; i < l; i++) {
-                    set = this._sets[i];
-                    if (set.state === state || (set.name === state && set.state !== this._state)) {
-                        this._map.fire('contextmenu.changestate', {
-                            contextmenu : this,
-                            set : set,
-                            state : state
-                        });
-                        for (i = 0, l = this._items.length; i < l; i++) {
-                            item = this._items[i];
-                            this.setHidden(this._items[i].el, (item.state.indexOf(set.state) === -1 && item.state.indexOf(set.name) === -1));
-                        }
-                        this._sizeChanged = true;
-                        this._state = state;
-                        break;
-                    }
-                }
-            }
-            return set;
-        },
-
-        _createSets : function () {
-            var setOptions = this._map.options.contextmenuSets,
-            set,
-            i,
-            l;
-
-            for (i = 0, l = setOptions.length; i < l; i++) {
-                this._sets.push(this._createSet(setOptions[i], this._sets.length));
-            }
-        },
-
-        _createSet : function (options, id) {
-            var name = (options.name !== undefined) ? options.name : 'set_' + id;
-            return {
-                id : id,
-                name : options.name,
-                state : options.state
-            };
-        },
-
-        _createItems : function () {
-            var itemOptions = this._map.options.contextmenuItems,
-            item,
-            i,
-            l;
-
-            for (i = 0, l = itemOptions.length; i < l; i++) {
-                this._items.push(this._createItem(this._container, itemOptions[i]));
-            }
-        },
-
-        _createItem : function (container, options, index) {
-            if (options.separator || options === '-') {
-                return this._createSeparator(container, index, options.state);
-            }
-
-            var itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
-            state = (options.state !== undefined) ? ((Array.isArray(options.state)) ? options.state : [options.state]) : [this._defaultState],
-            cls = (options.disabled) ? (itemCls + ' ' + itemCls + '-disabled') : ((options.hidden) ? (itemCls + ' ' + itemCls + '-hidden') : itemCls),
-            el = this._insertElementAt('a', cls, container, index),
-            callback = this._createEventHandler(el, options.callback, options.context, options.hideOnSelect),
-            html = '';
-
-            if (options.icon) {
-                html = '<img class="' + L.Map.ContextMenu.BASE_CLS + '-icon" src="' + options.icon + '"/>';
-            } else if (options.iconCls) {
-                html = '<span class="' + L.Map.ContextMenu.BASE_CLS + '- icon ' + options.iconCls + '"></span>';
-            }
-
-            el.innerHTML = html + options.text;
-            el.href = '#';
-            L.DomEvent
-            .on(el, 'mouseover', this._onItemMouseOver, this)
-            .on(el, 'mouseout', this._onItemMouseOut, this)
-            .on(el, 'mousedown', L.DomEvent.stopPropagation)
-            .on(el, 'click', callback);
-
-            return {
-                id : L.Util.stamp(el),
-                el : el,
-                callback : callback,
-                state : state
-            };
-        },
-
-        _removeItem : function (id) {
-            var item,
-            callback,
-            el,
-            i,
-            l;
-
-            for (i = 0, l = this._items.length; i < l; i++) {
-                item = this._items[i];
-
-                if (item.id === id) {
-                    el = item.el;
-                    callback = item.callback;
-
-                    if (callback) {
-                        L.DomEvent
-                        .off(el, 'mouseover', this._onItemMouseOver, this)
-                        .off(el, 'mouseover', this._onItemMouseOut, this)
-                        .off(el, 'mousedown', L.DomEvent.stopPropagation)
-                        .off(el, 'click', item.callback);
-
-                    }
-
-                    this._container.removeChild(el);
-                    this._items.splice(i, 1);
-                    return item;
-
-                }
-            }
-            return null;
-        },
-
-        _createSeparator : function (container, index, state) {
-            var el = this._insertElementAt('div', L.Map.ContextMenu.BASE_CLS + '-separator', container, index),
-            state = (state !== undefined) ? ((Array.isArray(state)) ? state : [state]) : [this._defaultState];
-
-            return {
-                id : L.Util.stamp(el),
-                el : el,
-                state : state
-            };
-        },
-
-        _createEventHandler : function (el, func, context, hideOnSelect) {
-            var me = this,
-            map = this._map,
-            disabledCls = L.Map.ContextMenu.BASE_CLS + '-item-disabled',
-            hideOnSelect = (hideOnSelect !== undefined) ? hideOnSelect : true;
-
-            return function (e) {
-                if (L.DomUtil.hasClass(el, disabledCls)) {
-                    return;
-
-                }
-
-                if (hideOnSelect) {
-                    me._hide();
-
-                }
-
-                if (func) {
-                    func.call(context || map, me._showLocation);
-                }
-
-                me._map.fire('contextmenu:select', {
-                    contextmenu : me,
-                    el : el
-                });
-            };
-        },
-
-        _insertElementAt : function (tagName, className, container, index) {
-            var refEl,
-            el = document.createElement(tagName);
-
-            el.className = className;
-
-            if (index !== undefined) {
-                refEl = container.children[index];
-            }
-
-            if (refEl) {
-                container.insertBefore(el, refEl);
-            } else {
-                container.appendChild(el);
-            }
-
-            return el;
-        },
-
-        _show : function (e) {
-            this._showAtPoint(e.containerPoint);
-        },
-
-        _showAtPoint : function (pt, data, state) {
-            if (this._items.length) {
-                var map = this._map,
-                layerPoint = map.containerPointToLayerPoint(pt),
-                latlng = map.layerPointToLatLng(layerPoint),
-                event = {
-                    contextmenu : this,
-                    state : state
-                },
-                state = (state !== undefined) ? state : this._activeState;
-
-                if (data) {
-                    event = L.extend(data, event);
-                }
-
-                this._showLocation = {
-                    state : state,
-                    target : (data) ? data.relatedTarget : null,
-                    latlng : latlng,
-                    layerPoint : layerPoint,
-                    containerPoint : pt
-                };
-
-                this._setPosition(pt);
-                this._changeState(state);
-                
-                if (!this._visible) {
-                    this._container.style.display = 'block';
-                    this._visible = true;
-                } else {
-                    this._setPosition(pt);
-                }
-                
-
-                this._map.fire('contextmenu.show', event);
-            }
-        },
-
-        _hide : function () {
-            if (this._visible) {
-                this.setState(this._defaultState);
-                this._visible = false;
-                this._container.style.display = 'none';
-                this._map.fire('contextmenu.hide', {
-                    contextmenu : this
-                });
-            }
-        },
-
-        _setPosition : function (pt) {
-            var mapSize = this._map.getSize(),
-            container = this._container,
-            containerSize = this._getElementSize(container),
-            anchor;
-
-            if (this._map.options.contextmenuAnchor) {
-                anchor = L.point(this._map.options.contextmenuAnchor);
-                pt = pt.add(anchor);
-            }
-
-            container._leaflet_pos = pt;
-
-            if (pt.x + containerSize.x > mapSize.x) {
-                container.style.left = 'auto';
-                container.style.right = Math.max(mapSize.x - pt.x, 0) + 'px';
-            } else {
-                container.style.left = Math.max(pt.x, 0) + 'px';
-                container.style.right = 'auto';
-            }
-
-            if (pt.y + containerSize.y > mapSize.y) {
-                container.style.top = 'auto';
-                container.style.bottom = Math.max(mapSize.y - pt.y, 0) + 'px';
-            } else {
-                container.style.top = Math.max(pt.y, 0) + 'px';
-                container.style.bottom = 'auto';
-            }
-        },
-
-        _getElementSize : function (el) {
-            var size = this._size,
-            initialDisplay = el.style.display;
-
-            if (!size || this._sizeChanged) {
-                size = {};
-
-                el.style.left = '-999999px';
-                el.style.right = 'auto';
-                el.style.display = 'block';
-
-                size.x = el.offsetWidth;
-                size.y = el.offsetHeight;
-
-                el.style.left = 'auto';
-                el.style.display = initialDisplay;
-
-                this._sizeChanged = false;
-            }
-
-            return size;
-        },
-
-        _onMouseDown : function (e) {
-            //console.log('_onMouseDown');
-            this._hide();
-        },
-
-        _onKeyDown : function (e) {
-            var key = e.keyCode;
-
-            // If ESC pressed and context menu is visible hide it
-            if (key === 27) {
-                this._hide();
-            }
-        },
-
-        _onItemMouseOver : function (e) {
-            L.DomUtil.addClass(e.target, 'over');
-        },
-
-        _onItemMouseOut : function (e) {
-            L.DomUtil.removeClass(e.target, 'over');
-        }
-    });
-
-L.Map.addInitHook('addHandler', 'contextmenu', L.Map.ContextMenu);
-L.Mixin.ContextMenu = {
-
-    // private methods
-    _initContextMenu : function () {
-        this._items = [];
-
-        this.on('contextmenu', this._showContextMenu, this);
-    },
-
-    _showContextMenu : function (e) {
-        var itemOptions,
-        pt,
-        i,
-        l;
-
-        if (this._map.contextmenu) {
-            pt = this._map.mouseEventToContainerPoint(e.originalEvent);
-
-            for (i = 0, l = this.options.contextmenuItems.length; i < l; i++) {
-                itemOptions = this.options.contextmenuItems[i];
-                this._items.push(this._map.contextmenu.insertItem(itemOptions, itemOptions.index));
-            }
-
-            this._map.once('contextmenu.hide', this._hideContextMenu, this);
-
-            this._map.contextmenu.showAt(pt, {
-                relatedTarget : this
-            },
-            this.options.contextmenuAtiveState);
-        }
-    },
-
-    _hideContextMenu : function () {
-        var i,
-        l;
-
-        for (i = 0, l = this._items.length; i < l; i++) {
-            this._map.contextmenu.removeItem(this._items[i]);
-        }
-        this._items.length = 0;
-    }
-};
-
-L.Marker.mergeOptions({
-    contextmenu : false,
-    contextmenuItems : []
-});
-
-L.Marker.addInitHook(function () {
-    if (this.options.contextmenu) {
-        this._initContextMenu();
-    }
-});
-
-L.Marker.include(L.Mixin.ContextMenu);
-
-L.Path.mergeOptions({
-    contextmenu : false,
-    contextmenuItems : []
-});
-
-L.Path.addInitHook(function () {
-    if (this.options.contextmenu) {
-        this._initContextMenu();
-    }
-});
-
-L.Path.include(L.Mixin.ContextMenu);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js b/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js
new file mode 100644
index 0000000000..0fc12c21b7
--- /dev/null
+++ b/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js
@@ -0,0 +1,2 @@
+/*! leaflet.elevation 02-03-2016 */
+L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(a){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter;var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){var b=d(a.dist);return a.xDiagCoord=b,b}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(f,b.theme),this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(a){return d3.mouse(h.select("g"))[0]}).y(function(a){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_findItemForLatLng:function(a){var b=null,c=1/0;return this._data.forEach(function(d){var e=a.distanceTo(d.latlng);c>e&&(c=e,b=d)}),b},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,a);b.href="#",b.title=this.options.controlButton.title,L.Browser.touch?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){var b=this.options;b.imperial?a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){var b=this.options;b.imperial?a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(a,b,c){if(this._data&&0!==this._data.length){var d=d3.mouse(this._background.node()),e=this.options,f=this._data[this._findItemForX(d[0])],g=f.altitude,h=f.dist,i=f.latlng,j=e.hoverNumber.formatter(g,e.hoverNumber.decimalsY);e.hoverNumber.formatter(h,e.hoverNumber.decimalsX);this._showDiagramIndicator(f,d[0]);var k=this._map.latLngToLayerPoint(i);if(e.useHeightIndicator){if(!this._mouseHeightFocus){var l=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=l.append("svg:line").attr("class",e.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var m=this._pointG=l.append("g");m.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",e.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=l.append("svg:text").attr("class",e.theme+" height-focus-label").style("pointer-events","none")}var n=this._height()/this._maxElevation*g,o=k.y-n;this._mouseHeightFocus.attr("x1",k.x).attr("x2",k.x).attr("y1",k.y).attr("y2",o).style("visibility","visible"),this._pointG.attr("transform","translate("+k.x+","+k.y+")").style("visibility","visible"),e.imperial?this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(i):this._marker=new L.Marker(i).addTo(this._map)}},_addGeoJSONData:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=new L.LatLng(a[f][1],a[f][0]),h=new L.LatLng(a[f?f-1:0][1],a[f?f-1:0][0]),i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<a[f][2]?a[f][2]:e,c.push({dist:d,altitude:b.imperial?a[f][2]*this.__footFactor:a[f][2],x:a[f][0],y:a[f][1],latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addGPXdata:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=a[f],h=a[f?f-1:0],i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<g.meta.ele?g.meta.ele:e,c.push({dist:d,altitude:b.imperial?g.meta.ele*this.__footFactor:g.meta.ele,x:g.lng,y:g.lat,latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a,b){this._addData(a),this._container&&this._applyData(),null===b&&a.on&&(b=a),b&&b.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(a){if(this._data&&0!==this._data.length){var b=a.latlng,c=this._findItemForLatLng(b);if(c){var d=c.xDiagCoord;this._showDiagramIndicator(c,d)}}},_showDiagramIndicator:function(a,b){var c=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",b).attr("y1",0).attr("x2",b).attr("y2",this._height()).classed("hidden",!1);var d=a.altitude,e=a.dist,f=(a.latlng,c.hoverNumber.formatter(d,c.hoverNumber.decimalsY)),g=c.hoverNumber.formatter(e,c.hoverNumber.decimalsX);c.imperial?(this._focuslabelX.attr("x",b).text(f+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" mi")):(this._focuslabelX.attr("x",b).text(f+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" km"))},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
diff --git a/web/src/main/webapp/js/main-template.js b/web/src/main/webapp/js/main-template.js
index 2298fef2e9..ecc8cd66d2 100755
--- a/web/src/main/webapp/js/main-template.js
+++ b/web/src/main/webapp/js/main-template.js
@@ -1,8 +1,8 @@
 global.d3 = require('d3');
 var L = require('leaflet');
+require('leaflet-contextmenu');
 require('leaflet-loading');
-require('./lib/leaflet.contextmenu.js');
-require('./lib/Leaflet.Elevation-0.0.2.min.js');
+require('./lib/leaflet.elevation-0.0.4.min.js');
 require('./lib/leaflet_numbered_markers.js');
 
 global.jQuery = require('jquery');
@@ -33,6 +33,7 @@ else
 
 var mapLayer = require('./map.js');
 var nominatim = require('./nominatim.js');
+var routeManipulation = require('./routeManipulation.js');
 var gpxExport = require('./gpxexport.js');
 var messages = require('./messages.js');
 var translate = require('./translate.js');
@@ -155,7 +156,7 @@ $(document).ready(function (e) {
                 }
                 metaVersionInfo = messages.extractMetaVersionInfo(json);
 
-                mapLayer.initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, urlParams.layer);
+                mapLayer.initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, urlParams.layer, urlParams.use_miles);
 
                 // execute query
                 initFromParams(urlParams, true);
@@ -172,7 +173,7 @@ $(document).ready(function (e) {
                     "maxLat": 90
                 };
                 nominatim.setBounds(bounds);
-                mapLayer.initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord);
+                mapLayer.initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, urlParams.layer, urlParams.use_miles);
             });
 
     $(window).resize(function () {
@@ -314,14 +315,14 @@ function checkInput() {
 }
 
 function setToStart(e) {
-    var latlng = e.target.getLatLng(),
+    var latlng = e.relatedTarget.getLatLng(),
             index = ghRequest.route.getIndexByCoord(latlng);
     ghRequest.route.move(index, 0);
     routeIfAllResolved();
 }
 
 function setToEnd(e) {
-    var latlng = e.target.getLatLng(),
+    var latlng = e.relatedTarget.getLatLng(),
             index = ghRequest.route.getIndexByCoord(latlng);
     ghRequest.route.move(index, -1);
     routeIfAllResolved();
@@ -334,14 +335,23 @@ function setStartCoord(e) {
 }
 
 function setIntermediateCoord(e) {
-    var index = ghRequest.route.size() - 1;
+    var routeLayers = mapLayer.getSubLayers("route");
+    var routeSegments = routeLayers.map(function(rl) {
+        return {
+            coordinates: rl.getLatLngs(),
+            wayPoints: rl.feature.properties.snapped_waypoints.coordinates.map(function(wp) {
+                return L.latLng(wp[1], wp[0]);
+            })
+        };
+    });
+    var index = routeManipulation.getIntermediatePointIndex(routeSegments, e.latlng);
     ghRequest.route.add(e.latlng.wrap(), index);
     resolveIndex(index);
     routeIfAllResolved();
 }
 
 function deleteCoord(e) {
-    var latlng = e.target.getLatLng();
+    var latlng = e.relatedTarget.getLatLng();
     ghRequest.route.removeSingle(latlng);
     mapLayer.clearLayers();
     routeLatLng(ghRequest, false);
@@ -383,11 +393,10 @@ function setFlag(coord, index) {
         var _tempItem = {
             text: translate.tr('set_start'),
             callback: setToStart,
-            index: 1,
-            state: 2
+            index: 1
         };
         if (toFrom === -1)
-            marker.options.contextmenuItems.push(_tempItem);// because the Mixin.ContextMenu isn't initialized
+            marker.options.contextmenuItems.push(_tempItem); // because the Mixin.ContextMenu isn't initialized
         marker.on('dragend', function (e) {
             mapLayer.clearLayers();
             // inconsistent leaflet API: event.target.getLatLng vs. mouseEvent.latlng?
@@ -492,7 +501,7 @@ function routeLatLng(request, doQuery) {
             return;
         }
 
-        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation) {
+        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation, useMiles) {
             return function () {
 
                 var currentGeoJson = geoJsons[currentLayerIndex];
@@ -511,7 +520,7 @@ function routeLatLng(request, doQuery) {
 
                 if (hasElevation) {
                     mapLayer.clearElevation();
-                    mapLayer.addElevation(currentGeoJson);
+                    mapLayer.addElevation(currentGeoJson, useMiles);
                 }
 
                 headerTabs.find("li").removeClass("current");
@@ -535,6 +544,16 @@ function routeLatLng(request, doQuery) {
         var geoJsons = [];
         var firstHeader;
 
+        // Create buttons to toggle between SI and imperial units.
+        var createUnitsChooserButtonClickHandler = function (useMiles) {
+            return function () {
+                mapLayer.updateScale(useMiles);
+                ghRequest.useMiles = useMiles;
+                resolveAll();
+                routeLatLng(ghRequest);
+            };
+        };
+
         for (var pathIndex = 0; pathIndex < json.paths.length; pathIndex++) {
             var tabHeader = $("<li>").append((pathIndex + 1) + "<img class='alt_route_img' src='img/alt_route.png'/>");
             if (pathIndex === 0)
@@ -547,25 +566,45 @@ function routeLatLng(request, doQuery) {
             var geojsonFeature = {
                 "type": "Feature",
                 "geometry": path.points,
-                "properties": {"style": style}
+                "properties": {
+                    "style": style,
+                    name: "route",
+                    snapped_waypoints: path.snapped_waypoints
+                }
             };
 
             geoJsons.push(geojsonFeature);
             mapLayer.addDataToRoutingLayer(geojsonFeature);
             var oneTab = $("<div class='route_result_tab'>");
             routeResultsDiv.append(oneTab);
-            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation()));
+            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation(), request.useMiles));
 
             var tmpTime = translate.createTimeString(path.time);
-            var tmpDist = translate.createDistanceString(path.distance);
+            var tmpDist = translate.createDistanceString(path.distance, request.useMiles);
             var routeInfo = $("<div class='route_description'>");
             if (path.description && path.description.length > 0) {
                 routeInfo.text(path.description);
                 routeInfo.append("<br/>");
             }
             routeInfo.append(translate.tr("route_info", [tmpDist, tmpTime]));
+
+            var kmButton = $("<button class='plain_text_button " + (request.useMiles ? "gray" : "") + "'>");
+            kmButton.text(translate.tr2("km_abbr"));
+            kmButton.click(createUnitsChooserButtonClickHandler(false));
+
+            var miButton = $("<button class='plain_text_button " + (request.useMiles ? "" : "gray") + "'>");
+            miButton.text(translate.tr2("mi_abbr"));
+            miButton.click(createUnitsChooserButtonClickHandler(true));
+
+            var buttons = $("<span style='float: right;'>");
+            buttons.append(kmButton);
+            buttons.append('|');
+            buttons.append(miButton);
+
+            routeInfo.append(buttons);
+
             if (request.hasElevation()) {
-                routeInfo.append(translate.createEleInfoString(path.ascend, path.descend));
+                routeInfo.append(translate.createEleInfoString(path.ascend, path.descend, request.useMiles));
             }
             oneTab.append(routeInfo);
 
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 72cfaa05bc..36761958e8 100755
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -1,96 +1,102 @@
 (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
-!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return n<t?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);r<i;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);r<i;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;e<r;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;e<r;e++)for(var i,u=n[e],o=0,a=u.length;o<a;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro=!("onselectstart"in e)&&x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(Po<0){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:n<0?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:n<-1?Fo:Math.acos(n)}function tn(n){return n>1?Io:n<-1?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:n<0&&(n+=360),n<60?u+(o-u)*n/60:n<180?o:n<240?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:t<0?0:t>1?1:t,e=e<0?0:e>1?1:e,o=e<=.5?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(n<=.00304?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return n<16?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=l<.5?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(t<e?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&l<1?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&t<300||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;r<2&&(t=0),r<3&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=n<0||0===n&&1/n<0?(n=-n,"-"):"-"===a?"":a;if(g<0){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(_<0){var w=m?n.lastIndexOf("e"):-1;w<0?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=S<f?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return t-e<r-t?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va((+n)),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;o<r;)e(o)%u||a.push(new Date((+o))),t(o,1);else for(;o<r;)a.push(new Date((+o))),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;a<l;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=n<0?"-":"",i=(r?-n:n)+"",u=i.length;return r+(u<e?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;a<t;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,(!0)),c=new Tt(e,null,l,(!1));l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,(!1)),c=new Tt(r,null,l,(!0)),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;a<c;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;a<c;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;a<l;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(u<-Uo||u<Uo&&ka<-Uo)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(s<0?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(M<0)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];S<w&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||E<Uo;if(!A&&N<k&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return t<-r?i|=1:t>r&&(i|=2),e<-r?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,g<0){if(u<h)return;u<p&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(u<0)){if(u/=g,g<0){if(u>p)return;u>h&&(h=u)}else if(g>0){if(u<h)return;u<p&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,v<0){if(u<h)return;u<p&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(u<0)){if(u/=v,v<0){if(u>p)return;u>h&&(h=u)}else if(v>0){if(u<h)return;u<p&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),p<1&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;i<e;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];o<l;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return n<=i&&i<=e&&t<=u&&u<=r}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){n<Ya&&(Ya=n),n>Va&&(Va=n),t<Za&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,
-t.lineEnd()}function l(){r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||a*p+l*g+c*v<o)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:n<-Fo?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:t<-Fo?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?i<u:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:f<u;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?t<-Io+Uo&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;i<t;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;f<s;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;o<l;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(d<o||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,r<-1||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(p<v){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||h<r||p<i)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(y<l){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;S<k;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;r<t;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;e<a;++e)r.push(Mr(n[e],t[e]));for(;e<u;++e)i[e]=n[e];for(;e<o;++e)i[e]=t[e];return function(n){for(e=0;e<a;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return t<=0?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(t<.5?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(n<=0)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(n<.5?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:u<-180&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:u<-180&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;e<u;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;o<c;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(v<d||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;o<c;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return i<0&&(e+=i/2,i=0),u<0&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return t<e?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return o<u&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return u<=.15?i*=10:u<=.35?i*=5:u<=.75&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(n<0?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;c<f;c++)for(var h=1;h<s;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return o*t<t-.5&&(o*=t),o<=r?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return t<0?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){if(!isNaN(n=+n))return t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),e<0?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=t<0?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){if(e<=e)return t[ao.bisect(n,e)]}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(y<0?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
-return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,t<=n?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(+o<r){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);if(u>=1)return v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),t<1?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return t<n?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),i<r&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),i<r&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;if(l)return u/l},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);if(o.length)return ao.quantile(o.sort(e),.5)},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));if(f>1)return l/(f-1)},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,u<2&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(r<0?0:r);e<r;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,e<0)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\0";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;e<r;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(i<3){if("string"!=typeof n){i<2&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(i<2){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;r<s;++r)g[r]=H(e[r]);for(;r<o;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;u<o;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;a<l;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;n<t;n++)for(var e=this[n],r=0,i=e.length;r<i;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(r<3){if("string"!=typeof n){r<2&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(r<2)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;i<u;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(h<jo)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;i<u;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(c-M<500){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;a<l;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;e<r;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&t<i&&(t=i),e&&e<i&&(e=i),r&&r<i&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;f<c;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("\t","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(n<0&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
-shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=n<0?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),t<s&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(c*g<v&&v<c*t)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(c*g<v&&v<c*t)){var m=-o[1]*Zo;m<s&&(s=m)}else e<s&&(s=e),e>p&&(p=e);d?t<g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(t<f&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,ka<0?(f=-(h=180),s=-(p=90)):m>Uo?p=90:m<-Uo&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];r<t;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];r<=t;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return i<jo&&(t=qa,e=Ta,r=Ra,Aa<Uo&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,i<jo)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?o:i>=.166&&i<.234&&r>=-.214&&r<-.115?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;t<o;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;t<o;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;p<g;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;p<g;++p){var b=+M(f=n[p],p),_=+x(f,p);b<v&&(v=b),_<d&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(a*a/y<l){if(l<v){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&l<v){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;r<w;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;l<i;++l)e[l]=[];for(l=0;l<c;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;t<i;++t)(r=M[t]).index=t,r.weight=0;for(t=0;t<c;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;t<i;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;t<c;++t)u[t]=+h.call(this,x[t],t);else for(t=0;t<c;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;t<c;++t)o[t]=+p.call(this,x[t],t);else for(t=0;t<c;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;t<i;++t)a[t]=+g.call(this,M[t],t);else for(t=0;t<i;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(s<0?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;g<y;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;p<h;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;t<r;++t)e=o[t],a<l?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;e<u;++e){for(t=0,r=0;t<i;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;e<u;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;e<h;++e){for(t=0,i=0;t<f;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];t<f;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);r<t;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,l<c&&(c=l)}for(e=0;e<h;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;e<u;++e){for(t=0,r=0;t<i;t++)r+=n[t][e][1];if(r)for(t=0;t<i;t++)n[t][e][1]/=r;else for(t=0;t<i;t++)n[t][e][1]=o}for(e=0;e<u;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;o<a;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(t<0?0:t),e.area=isNaN(r)||r<=0?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(e<u&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
-if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return e<2&&(t=1),e<1&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;e<n;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(c<n&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=n<c^p?0:1;var T=g,R=g;if(h<Fo){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;u<o;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;a<l;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(o<3){if("string"!=typeof n){o<2&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;l<c;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;f<s;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",q<0?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",q<0?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];if(C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),f<r?(i=r,r=f):i=f),v[0]!=r||v[1]!=i)return e?a=null:o=null,v[0]=r,v[1]=i,!0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),r<e&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),u<i&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),r<e&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),u<i&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();
+!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
+r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
+return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
+shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
+if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();
+
 },{}],2:[function(require,module,exports){
-!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";function n(e,t){t=t||Z;var n=t.createElement("script");n.text=e,t.head.appendChild(n).parentNode.removeChild(n)}function r(e){var t=!!e&&"length"in e&&e.length,n=pe.type(e);return"function"!==n&&!pe.isWindow(e)&&("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e)}function i(e,t,n){if(pe.isFunction(t))return pe.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return pe.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(Te.test(t))return pe.filter(t,e,n);t=pe.filter(t,e)}return pe.grep(e,function(e){return ie.call(t,e)>-1!==n&&1===e.nodeType})}function o(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function a(e){var t={};return pe.each(e.match(De)||[],function(e,n){t[n]=!0}),t}function s(e){return e}function u(e){throw e}function l(e,t,n){var r;try{e&&pe.isFunction(r=e.promise)?r.call(e).done(t).fail(n):e&&pe.isFunction(r=e.then)?r.call(e,t,n):t.call(void 0,e)}catch(e){n.call(void 0,e)}}function c(){Z.removeEventListener("DOMContentLoaded",c),e.removeEventListener("load",c),pe.ready()}function f(){this.expando=pe.expando+f.uid++}function p(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Pe,"-$&").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n||"false"!==n&&("null"===n?null:+n+""===n?+n:Oe.test(n)?JSON.parse(n):n)}catch(i){}Fe.set(e,t,n)}else n=void 0;return n}function d(e,t,n,r){var i,o=1,a=20,s=r?function(){return r.cur()}:function(){return pe.css(e,t,"")},u=s(),l=n&&n[3]||(pe.cssNumber[t]?"":"px"),c=(pe.cssNumber[t]||"px"!==l&&+u)&&Me.exec(pe.css(e,t));if(c&&c[3]!==l){l=l||c[3],n=n||[],c=+u||1;do o=o||".5",c/=o,pe.style(e,t,c+l);while(o!==(o=s()/u)&&1!==o&&--a)}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}function h(e){var t,n=e.ownerDocument,r=e.nodeName,i=Be[r];return i?i:(t=n.body.appendChild(n.createElement(r)),i=pe.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),Be[r]=i,i)}function g(e,t){for(var n,r,i=[],o=0,a=e.length;o<a;o++)r=e[o],r.style&&(n=r.style.display,t?("none"===n&&(i[o]=He.get(r,"display")||null,i[o]||(r.style.display="")),""===r.style.display&&We(r)&&(i[o]=h(r))):"none"!==n&&(i[o]="none",He.set(r,"display",n)));for(o=0;o<a;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}function m(e,t){var n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[];return void 0===t||t&&pe.nodeName(e,t)?pe.merge([e],n):n}function v(e,t){for(var n=0,r=e.length;n<r;n++)He.set(e[n],"globalEval",!t||He.get(t[n],"globalEval"))}function y(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if(o=e[d],o||0===o)if("object"===pe.type(o))pe.merge(p,o.nodeType?[o]:o);else if(Ve.test(o)){for(a=a||f.appendChild(t.createElement("div")),s=(ze.exec(o)||["",""])[1].toLowerCase(),u=Ue[s]||Ue._default,a.innerHTML=u[1]+pe.htmlPrefilter(o)+u[2],c=u[0];c--;)a=a.lastChild;pe.merge(p,a.childNodes),a=f.firstChild,a.textContent=""}else p.push(t.createTextNode(o));for(f.textContent="",d=0;o=p[d++];)if(r&&pe.inArray(o,r)>-1)i&&i.push(o);else if(l=pe.contains(o.ownerDocument,o),a=m(f.appendChild(o),"script"),l&&v(a),n)for(c=0;o=a[c++];)Xe.test(o.type||"")&&n.push(o);return f}function x(){return!0}function b(){return!1}function w(){try{return Z.activeElement}catch(e){}}function T(e,t,n,r,i,o){var a,s;if("object"==typeof t){"string"!=typeof n&&(r=r||n,n=void 0);for(s in t)T(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),i===!1)i=b;else if(!i)return e;return 1===o&&(a=i,i=function(e){return pe().off(e),a.apply(this,arguments)},i.guid=a.guid||(a.guid=pe.guid++)),e.each(function(){pe.event.add(this,t,i,r,n)})}function C(e,t){return pe.nodeName(e,"table")&&pe.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e:e}function k(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function E(e){var t=tt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function S(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(He.hasData(e)&&(o=He.access(e),a=He.set(t,o),l=o.events)){delete a.handle,a.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)pe.event.add(t,i,l[i][n])}Fe.hasData(e)&&(s=Fe.access(e),u=pe.extend({},s),Fe.set(t,u))}}function N(e,t){var n=t.nodeName.toLowerCase();"input"===n&&_e.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function D(e,t,r,i){t=ne.apply([],t);var o,a,s,u,l,c,f=0,p=e.length,d=p-1,h=t[0],g=pe.isFunction(h);if(g||p>1&&"string"==typeof h&&!ce.checkClone&&et.test(h))return e.each(function(n){var o=e.eq(n);g&&(t[0]=h.call(this,n,o.html())),D(o,t,r,i)});if(p&&(o=y(t,e[0].ownerDocument,!1,e,i),a=o.firstChild,1===o.childNodes.length&&(o=a),a||i)){for(s=pe.map(m(o,"script"),k),u=s.length;f<p;f++)l=o,f!==d&&(l=pe.clone(l,!0,!0),u&&pe.merge(s,m(l,"script"))),r.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,pe.map(s,E),f=0;f<u;f++)l=s[f],Xe.test(l.type||"")&&!He.access(l,"globalEval")&&pe.contains(c,l)&&(l.src?pe._evalUrl&&pe._evalUrl(l.src):n(l.textContent.replace(nt,""),c))}return e}function j(e,t,n){for(var r,i=t?pe.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||pe.cleanData(m(r)),r.parentNode&&(n&&pe.contains(r.ownerDocument,r)&&v(m(r,"script")),r.parentNode.removeChild(r));return e}function A(e,t,n){var r,i,o,a,s=e.style;return n=n||ot(e),n&&(a=n.getPropertyValue(t)||n[t],""!==a||pe.contains(e.ownerDocument,e)||(a=pe.style(e,t)),!ce.pixelMarginRight()&&it.test(a)&&rt.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function q(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function L(e){if(e in ct)return e;for(var t=e[0].toUpperCase()+e.slice(1),n=lt.length;n--;)if(e=lt[n]+t,e in ct)return e}function H(e,t,n){var r=Me.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function F(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;o<4;o+=2)"margin"===n&&(a+=pe.css(e,n+Ie[o],!0,i)),r?("content"===n&&(a-=pe.css(e,"padding"+Ie[o],!0,i)),"margin"!==n&&(a-=pe.css(e,"border"+Ie[o]+"Width",!0,i))):(a+=pe.css(e,"padding"+Ie[o],!0,i),"padding"!==n&&(a+=pe.css(e,"border"+Ie[o]+"Width",!0,i)));return a}function O(e,t,n){var r,i=!0,o=ot(e),a="border-box"===pe.css(e,"boxSizing",!1,o);if(e.getClientRects().length&&(r=e.getBoundingClientRect()[t]),r<=0||null==r){if(r=A(e,t,o),(r<0||null==r)&&(r=e.style[t]),it.test(r))return r;i=a&&(ce.boxSizingReliable()||r===e.style[t]),r=parseFloat(r)||0}return r+F(e,t,n||(a?"border":"content"),i,o)+"px"}function P(e,t,n,r,i){return new P.prototype.init(e,t,n,r,i)}function R(){pt&&(e.requestAnimationFrame(R),pe.fx.tick())}function M(){return e.setTimeout(function(){ft=void 0}),ft=pe.now()}function I(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)n=Ie[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function W(e,t,n){for(var r,i=(_.tweeners[t]||[]).concat(_.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function $(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,m=e.nodeType&&We(e),v=He.get(e,"fxshow");n.queue||(a=pe._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,pe.queue(e,"fx").length||a.empty.fire()})}));for(r in t)if(i=t[r],dt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(m?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;m=!0}d[r]=v&&v[r]||pe.style(e,r)}if(u=!pe.isEmptyObject(t),u||!pe.isEmptyObject(d)){f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],l=v&&v.display,null==l&&(l=He.get(e,"display")),c=pe.css(e,"display"),"none"===c&&(l?c=l:(g([e],!0),l=e.style.display||l,c=pe.css(e,"display"),g([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===pe.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1;for(r in d)u||(v?"hidden"in v&&(m=v.hidden):v=He.access(e,"fxshow",{display:l}),o&&(v.hidden=!m),m&&g([e],!0),p.done(function(){m||g([e]),He.remove(e,"fxshow");for(r in d)pe.style(e,r,d[r])})),u=W(m?v[r]:0,r,p),r in v||(v[r]=u.start,m&&(u.end=u.start,u.start=0))}}function B(e,t){var n,r,i,o,a;for(n in e)if(r=pe.camelCase(n),i=t[r],o=e[n],pe.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=pe.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function _(e,t,n){var r,i,o=0,a=_.prefilters.length,s=pe.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=ft||M(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;a<u;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),o<1&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:pe.extend({},t),opts:pe.extend(!0,{specialEasing:{},easing:pe.easing._default},n),originalProperties:t,originalOptions:n,startTime:ft||M(),duration:n.duration,tweens:[],createTween:function(t,n){var r=pe.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(B(c,l.opts.specialEasing);o<a;o++)if(r=_.prefilters[o].call(l,e,c,l.opts))return pe.isFunction(r.stop)&&(pe._queueHooks(l.elem,l.opts.queue).stop=pe.proxy(r.stop,r)),r;return pe.map(c,W,l),pe.isFunction(l.opts.start)&&l.opts.start.call(e,l),pe.fx.timer(pe.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function z(e){return e.getAttribute&&e.getAttribute("class")||""}function X(e,t,n,r){var i;if(pe.isArray(t))pe.each(t,function(t,i){n||St.test(e)?r(e,i):X(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,n,r)});else if(n||"object"!==pe.type(t))r(e,t);else for(i in t)X(e+"["+i+"]",t[i],n,r)}function U(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(De)||[];if(pe.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function V(e,t,n,r){function i(s){var u;return o[s]=!0,pe.each(e[s]||[],function(e,s){var l=s(t,n,r);return"string"!=typeof l||a||o[l]?a?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},a=e===Mt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function G(e,t){var n,r,i=pe.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&pe.extend(!0,e,r),e}function Y(e,t,n){for(var r,i,o,a,s=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}function Q(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(a=l[u+" "+o]||l["* "+o],!a)for(i in l)if(s=i.split(" "),s[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){a===!0?a=l[i]:l[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(f){return{state:"parsererror",error:a?f:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}function J(e){return pe.isWindow(e)?e:9===e.nodeType&&e.defaultView}var K=[],Z=e.document,ee=Object.getPrototypeOf,te=K.slice,ne=K.concat,re=K.push,ie=K.indexOf,oe={},ae=oe.toString,se=oe.hasOwnProperty,ue=se.toString,le=ue.call(Object),ce={},fe="3.1.0",pe=function(e,t){return new pe.fn.init(e,t)},de=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,he=/^-ms-/,ge=/-([a-z])/g,me=function(e,t){return t.toUpperCase()};pe.fn=pe.prototype={jquery:fe,constructor:pe,length:0,toArray:function(){return te.call(this)},get:function(e){return null!=e?e<0?this[e+this.length]:this[e]:te.call(this)},pushStack:function(e){var t=pe.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return pe.each(this,e)},map:function(e){return this.pushStack(pe.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(te.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:re,sort:K.sort,splice:K.splice},pe.extend=pe.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||pe.isFunction(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],r=e[t],a!==r&&(l&&r&&(pe.isPlainObject(r)||(i=pe.isArray(r)))?(i?(i=!1,o=n&&pe.isArray(n)?n:[]):o=n&&pe.isPlainObject(n)?n:{},a[t]=pe.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},pe.extend({expando:"jQuery"+(fe+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===pe.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){var t=pe.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==ae.call(e))&&(!(t=ee(e))||(n=se.call(t,"constructor")&&t.constructor,"function"==typeof n&&ue.call(n)===le))},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?oe[ae.call(e)]||"object":typeof e},globalEval:function(e){n(e)},camelCase:function(e){return e.replace(he,"ms-").replace(ge,me)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t){var n,i=0;if(r(e))for(n=e.length;i<n&&t.call(e[i],i,e[i])!==!1;i++);else for(i in e)if(t.call(e[i],i,e[i])===!1)break;return e},trim:function(e){return null==e?"":(e+"").replace(de,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(r(Object(e))?pe.merge(n,"string"==typeof e?[e]:e):re.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:ie.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,a=e.length,s=!n;o<a;o++)r=!t(e[o],o),r!==s&&i.push(e[o]);return i},map:function(e,t,n){var i,o,a=0,s=[];if(r(e))for(i=e.length;a<i;a++)o=t(e[a],a,n),null!=o&&s.push(o);else for(a in e)o=t(e[a],a,n),null!=o&&s.push(o);return ne.apply([],s)},guid:1,proxy:function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),pe.isFunction(e))return r=te.call(arguments,2),i=function(){return e.apply(t||this,r.concat(te.call(arguments)))},i.guid=e.guid=e.guid||pe.guid++,i},now:Date.now,support:ce}),"function"==typeof Symbol&&(pe.fn[Symbol.iterator]=K[Symbol.iterator]),pe.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){oe["[object "+t+"]"]=t.toLowerCase()});var ve=function(e){function t(e,t,n,r){var i,o,a,s,u,l,c,p=t&&t.ownerDocument,h=t?t.nodeType:9;if(n=n||[],"string"!=typeof e||!e||1!==h&&9!==h&&11!==h)return n;if(!r&&((t?t.ownerDocument||t:$)!==H&&L(t),t=t||H,O)){if(11!==h&&(u=ve.exec(e)))if(i=u[1]){if(9===h){if(!(a=t.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(p&&(a=p.getElementById(i))&&I(t,a)&&a.id===i)return n.push(a),n}else{if(u[2])return K.apply(n,t.getElementsByTagName(e)),n;if((i=u[3])&&T.getElementsByClassName&&t.getElementsByClassName)return K.apply(n,t.getElementsByClassName(i)),n}if(T.qsa&&!U[e+" "]&&(!P||!P.test(e))){if(1!==h)p=t,c=e;else if("object"!==t.nodeName.toLowerCase()){for((s=t.getAttribute("id"))?s=s.replace(we,Te):t.setAttribute("id",s=W),l=S(e),o=l.length;o--;)l[o]="#"+s+" "+d(l[o]);c=l.join(","),p=ye.test(e)&&f(t.parentNode)||t}if(c)try{return K.apply(n,p.querySelectorAll(c)),n}catch(g){}finally{s===W&&t.removeAttribute("id")}}}return D(e.replace(se,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>C.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=H.createElement("fieldset");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=n.length;r--;)C.attrHandle[n[r]]=t}function a(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function s(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return function(t){return"label"in t&&t.disabled===e||"form"in t&&t.disabled===e||"form"in t&&t.disabled===!1&&(t.isDisabled===e||t.isDisabled!==!e&&("label"in t||!ke(t))!==e)}}function c(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function f(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function p(){}function d(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&"parentNode"===o,s=_++;return t.first?function(t,n,i){for(;t=t[r];)if(1===t.nodeType||a)return e(t,n,i)}:function(t,n,u){var l,c,f,p=[B,s];if(u){for(;t=t[r];)if((1===t.nodeType||a)&&e(t,n,u))return!0}else for(;t=t[r];)if(1===t.nodeType||a)if(f=t[W]||(t[W]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===B&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function m(e,n,r){for(var i=0,o=n.length;i<o;i++)t(e,n[i],r);return r}function v(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function y(e,t,n,i,o,a){return i&&!i[W]&&(i=y(i)),o&&!o[W]&&(o=y(o,a)),r(function(r,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=r||m(t||"*",s.nodeType?[s]:s,[]),y=!e||!r&&t?g:v(g,p,e,s,u),x=n?o||(r?e:h||i)?[]:a:y;if(n&&n(y,x,s,u),i)for(l=v(x,d),i(l,[],s,u),c=l.length;c--;)(f=l[c])&&(x[d[c]]=!(y[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=x.length;c--;)(f=x[c])&&l.push(y[c]=f);o(null,x=[],l,u)}for(c=x.length;c--;)(f=x[c])&&(l=o?ee(r,f):p[c])>-1&&(r[l]=!(a[l]=f))}}else x=v(x===a?x.splice(h,x.length):x),o?o(null,a,x,u):K.apply(a,x)})}function x(e){for(var t,n,r,i=e.length,o=C.relative[e[0].type],a=o||C.relative[" "],s=o?1:0,u=h(function(e){return e===t},a,!0),l=h(function(e){return ee(t,e)>-1},a,!0),c=[function(e,n,r){var i=!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r));return t=null,i}];s<i;s++)if(n=C.relative[e[s].type])c=[h(g(c),n)];else{if(n=C.filter[e[s].type].apply(null,e[s].matches),n[W]){for(r=++s;r<i&&!C.relative[e[r].type];r++);return y(s>1&&g(c),s>1&&d(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(se,"$1"),n,s<r&&x(e.slice(s,r)),r<i&&x(e=e.slice(r)),r<i&&d(e))}c.push(n)}return g(c)}function b(e,n){var i=n.length>0,o=e.length>0,a=function(r,a,s,u,l){var c,f,p,d=0,h="0",g=r&&[],m=[],y=j,x=r||o&&C.find.TAG("*",l),b=B+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=a===H||a||l);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0,a||c.ownerDocument===H||(L(c),s=!O);p=e[f++];)if(p(c,a||H,s)){u.push(c);break}l&&(B=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,m,a,s);if(r){if(d>0)for(;h--;)g[h]||m[h]||(m[h]=Q.call(u));m=v(m)}K.apply(u,m),l&&!r&&m.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&(B=b,j=y),g};return i?r(a):a}var w,T,C,k,E,S,N,D,j,A,q,L,H,F,O,P,R,M,I,W="sizzle"+1*new Date,$=e.document,B=0,_=0,z=n(),X=n(),U=n(),V=function(e,t){return e===t&&(q=!0),0},G={}.hasOwnProperty,Y=[],Q=Y.pop,J=Y.push,K=Y.push,Z=Y.slice,ee=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},te="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",ne="[\\x20\\t\\r\\n\\f]",re="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",ie="\\["+ne+"*("+re+")(?:"+ne+"*([*^$|!~]?=)"+ne+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+re+"))|)"+ne+"*\\]",oe=":("+re+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+ie+")*)|.*)\\)|)",ae=new RegExp(ne+"+","g"),se=new RegExp("^"+ne+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ne+"+$","g"),ue=new RegExp("^"+ne+"*,"+ne+"*"),le=new RegExp("^"+ne+"*([>+~]|"+ne+")"+ne+"*"),ce=new RegExp("="+ne+"*([^\\]'\"]*?)"+ne+"*\\]","g"),fe=new RegExp(oe),pe=new RegExp("^"+re+"$"),de={ID:new RegExp("^#("+re+")"),CLASS:new RegExp("^\\.("+re+")"),TAG:new RegExp("^("+re+"|[*])"),ATTR:new RegExp("^"+ie),PSEUDO:new RegExp("^"+oe),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ne+"*(even|odd|(([+-]|)(\\d*)n|)"+ne+"*(?:([+-]|)"+ne+"*(\\d+)|))"+ne+"*\\)|)","i"),bool:new RegExp("^(?:"+te+")$","i"),needsContext:new RegExp("^"+ne+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ne+"*((?:-\\d)?\\d*)"+ne+"*\\)|)(?=[^-]|$)","i")},he=/^(?:input|select|textarea|button)$/i,ge=/^h\d$/i,me=/^[^{]+\{\s*\[native \w/,ve=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ye=/[+~]/,xe=new RegExp("\\\\([\\da-f]{1,6}"+ne+"?|("+ne+")|.)","ig"),be=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},we=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,Te=function(e,t){return t?"\0"===e?"�":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},Ce=function(){L()},ke=h(function(e){return e.disabled===!0},{dir:"parentNode",next:"legend"});try{K.apply(Y=Z.call($.childNodes),$.childNodes),Y[$.childNodes.length].nodeType}catch(Ee){K={apply:Y.length?function(e,t){J.apply(e,Z.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}T=t.support={},E=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},L=t.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:$;return r!==H&&9===r.nodeType&&r.documentElement?(H=r,F=H.documentElement,O=!E(H),$!==H&&(n=H.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",Ce,!1):n.attachEvent&&n.attachEvent("onunload",Ce)),T.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),T.getElementsByTagName=i(function(e){return e.appendChild(H.createComment("")),!e.getElementsByTagName("*").length}),T.getElementsByClassName=me.test(H.getElementsByClassName),T.getById=i(function(e){return F.appendChild(e).id=W,!H.getElementsByName||!H.getElementsByName(W).length}),T.getById?(C.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&O){var n=t.getElementById(e);return n?[n]:[]}},C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){return e.getAttribute("id")===t}}):(delete C.find.ID,C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){var n="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}}),C.find.TAG=T.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):T.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},C.find.CLASS=T.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&O)return t.getElementsByClassName(e)},R=[],P=[],(T.qsa=me.test(H.querySelectorAll))&&(i(function(e){F.appendChild(e).innerHTML="<a id='"+W+"'></a><select id='"+W+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&P.push("[*^$]="+ne+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||P.push("\\["+ne+"*(?:value|"+te+")"),e.querySelectorAll("[id~="+W+"-]").length||P.push("~="),e.querySelectorAll(":checked").length||P.push(":checked"),e.querySelectorAll("a#"+W+"+*").length||P.push(".#.+[+~]")}),i(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=H.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&P.push("name"+ne+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&P.push(":enabled",":disabled"),F.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&P.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),P.push(",.*:")})),(T.matchesSelector=me.test(M=F.matches||F.webkitMatchesSelector||F.mozMatchesSelector||F.oMatchesSelector||F.msMatchesSelector))&&i(function(e){T.disconnectedMatch=M.call(e,"*"),M.call(e,"[s!='']:x"),R.push("!=",oe)}),P=P.length&&new RegExp(P.join("|")),R=R.length&&new RegExp(R.join("|")),t=me.test(F.compareDocumentPosition),I=t||me.test(F.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},V=t?function(e,t){if(e===t)return q=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n?n:(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&n||!T.sortDetached&&t.compareDocumentPosition(e)===n?e===H||e.ownerDocument===$&&I($,e)?-1:t===H||t.ownerDocument===$&&I($,t)?1:A?ee(A,e)-ee(A,t):0:4&n?-1:1)}:function(e,t){if(e===t)return q=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,s=[e],u=[t];if(!i||!o)return e===H?-1:t===H?1:i?-1:o?1:A?ee(A,e)-ee(A,t):0;if(i===o)return a(e,t);for(n=e;n=n.parentNode;)s.unshift(n);for(n=t;n=n.parentNode;)u.unshift(n);for(;s[r]===u[r];)r++;return r?a(s[r],u[r]):s[r]===$?-1:u[r]===$?1:0},H):H},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==H&&L(e),n=n.replace(ce,"='$1']"),T.matchesSelector&&O&&!U[n+" "]&&(!R||!R.test(n))&&(!P||!P.test(n)))try{var r=M.call(e,n);if(r||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return t(n,H,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==H&&L(e),I(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==H&&L(e);var n=C.attrHandle[t.toLowerCase()],r=n&&G.call(C.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:T.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.escape=function(e){return(e+"").replace(we,Te)},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(q=!T.detectDuplicates,A=!T.sortStable&&e.slice(0),e.sort(V),q){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return A=null,e},k=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=k(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=k(t);return n},C=t.selectors={cacheLength:50,createPseudo:r,match:de,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(xe,be),e[3]=(e[3]||e[4]||e[5]||"").replace(xe,be),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return de.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&fe.test(n)&&(t=S(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(xe,be).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=z[e+" "];return t||(t=new RegExp("(^|"+ne+")"+e+"("+ne+"|$)"))&&z(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:!n||(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o.replace(ae," ")+" ").indexOf(r)>-1:"|="===n&&(o===r||o.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,v=s&&t.nodeName.toLowerCase(),y=!u&&!s,x=!1;if(m){if(o){for(;g;){for(p=t;p=p[g];)if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&y){for(p=m,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===B&&l[1],x=d&&l[2],p=d&&m.childNodes[d];p=++d&&p&&p[g]||(x=d=0)||h.pop();)if(1===p.nodeType&&++x&&p===t){c[e]=[B,d,x];break}}else if(y&&(p=t,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===B&&l[1],x=d),x===!1)for(;(p=++d&&p&&p[g]||(x=d=0)||h.pop())&&((s?p.nodeName.toLowerCase()!==v:1!==p.nodeType)||!++x||(y&&(f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),c[e]=[B,x]),p!==t)););return x-=i,x===r||x%r===0&&x/r>=0}}},PSEUDO:function(e,n){var i,o=C.pseudos[e]||C.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],C.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),a=i.length;a--;)r=ee(e,i[a]),e[r]=!(t[r]=i[a])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=N(e.replace(se,"$1"));return i[W]?r(function(e,t,n,r){for(var o,a=i(e,null,r,[]),s=e.length;s--;)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),t[0]=null,!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return e=e.replace(xe,be),function(t){return(t.textContent||t.innerText||k(t)).indexOf(e)>-1}}),lang:r(function(e){return pe.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(xe,be).toLowerCase(),function(t){var n;do if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===F},focus:function(e){return e===H.activeElement&&(!H.hasFocus||H.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:l(!1),disabled:l(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){
-for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!C.pseudos.empty(e)},header:function(e){return ge.test(e.nodeName)},input:function(e){return he.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:c(function(){return[0]}),last:c(function(e,t){return[t-1]}),eq:c(function(e,t,n){return[n<0?n+t:n]}),even:c(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:c(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:c(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:c(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},C.pseudos.nth=C.pseudos.eq;for(w in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})C.pseudos[w]=s(w);for(w in{submit:!0,reset:!0})C.pseudos[w]=u(w);return p.prototype=C.filters=C.pseudos,C.setFilters=new p,S=t.tokenize=function(e,n){var r,i,o,a,s,u,l,c=X[e+" "];if(c)return n?0:c.slice(0);for(s=e,u=[],l=C.preFilter;s;){r&&!(i=ue.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),r=!1,(i=le.exec(s))&&(r=i.shift(),o.push({value:r,type:i[0].replace(se," ")}),s=s.slice(r.length));for(a in C.filter)!(i=de[a].exec(s))||l[a]&&!(i=l[a](i))||(r=i.shift(),o.push({value:r,type:a,matches:i}),s=s.slice(r.length));if(!r)break}return n?s.length:s?t.error(e):X(e,u).slice(0)},N=t.compile=function(e,t){var n,r=[],i=[],o=U[e+" "];if(!o){for(t||(t=S(e)),n=t.length;n--;)o=x(t[n]),o[W]?r.push(o):i.push(o);o=U(e,b(i,r)),o.selector=e}return o},D=t.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&S(e=l.selector||e);if(n=n||[],1===c.length){if(o=c[0]=c[0].slice(0),o.length>2&&"ID"===(a=o[0]).type&&T.getById&&9===t.nodeType&&O&&C.relative[o[1].type]){if(t=(C.find.ID(a.matches[0].replace(xe,be),t)||[])[0],!t)return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}for(i=de.needsContext.test(e)?0:o.length;i--&&(a=o[i],!C.relative[s=a.type]);)if((u=C.find[s])&&(r=u(a.matches[0].replace(xe,be),ye.test(o[0].type)&&f(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&d(o),!e)return K.apply(n,r),n;break}}return(l||N(e,c))(r,t,!O,n,!t||ye.test(e)&&f(t.parentNode)||t),n},T.sortStable=W.split("").sort(V).join("")===W,T.detectDuplicates=!!q,L(),T.sortDetached=i(function(e){return 1&e.compareDocumentPosition(H.createElement("fieldset"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),T.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(te,function(e,t,n){var r;if(!n)return e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);pe.find=ve,pe.expr=ve.selectors,pe.expr[":"]=pe.expr.pseudos,pe.uniqueSort=pe.unique=ve.uniqueSort,pe.text=ve.getText,pe.isXMLDoc=ve.isXML,pe.contains=ve.contains,pe.escapeSelector=ve.escape;var ye=function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&pe(e).is(n))break;r.push(e)}return r},xe=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},be=pe.expr.match.needsContext,we=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,Te=/^.[^:#\[\.,]*$/;pe.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?pe.find.matchesSelector(r,e)?[r]:[]:pe.find.matches(e,pe.grep(t,function(e){return 1===e.nodeType}))},pe.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(pe(e).filter(function(){for(t=0;t<r;t++)if(pe.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)pe.find(e,i[t],n);return r>1?pe.uniqueSort(n):n},filter:function(e){return this.pushStack(i(this,e||[],!1))},not:function(e){return this.pushStack(i(this,e||[],!0))},is:function(e){return!!i(this,"string"==typeof e&&be.test(e)?pe(e):e||[],!1).length}});var Ce,ke=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,Ee=pe.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||Ce,"string"==typeof e){if(r="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:ke.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof pe?t[0]:t,pe.merge(this,pe.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:Z,!0)),we.test(r[1])&&pe.isPlainObject(t))for(r in t)pe.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=Z.getElementById(r[2]),i&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):pe.isFunction(e)?void 0!==n.ready?n.ready(e):e(pe):pe.makeArray(e,this)};Ee.prototype=pe.fn,Ce=pe(Z);var Se=/^(?:parents|prev(?:Until|All))/,Ne={children:!0,contents:!0,next:!0,prev:!0};pe.fn.extend({has:function(e){var t=pe(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(pe.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&pe(e);if(!be.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&pe.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?pe.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?ie.call(pe(e),this[0]):ie.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(pe.uniqueSort(pe.merge(this.get(),pe(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),pe.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return ye(e,"parentNode")},parentsUntil:function(e,t,n){return ye(e,"parentNode",n)},next:function(e){return o(e,"nextSibling")},prev:function(e){return o(e,"previousSibling")},nextAll:function(e){return ye(e,"nextSibling")},prevAll:function(e){return ye(e,"previousSibling")},nextUntil:function(e,t,n){return ye(e,"nextSibling",n)},prevUntil:function(e,t,n){return ye(e,"previousSibling",n)},siblings:function(e){return xe((e.parentNode||{}).firstChild,e)},children:function(e){return xe(e.firstChild)},contents:function(e){return e.contentDocument||pe.merge([],e.childNodes)}},function(e,t){pe.fn[e]=function(n,r){var i=pe.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=pe.filter(r,i)),this.length>1&&(Ne[e]||pe.uniqueSort(i),Se.test(e)&&i.reverse()),this.pushStack(i)}});var De=/\S+/g;pe.Callbacks=function(e){e="string"==typeof e?a(e):pe.extend({},e);var t,n,r,i,o=[],s=[],u=-1,l=function(){for(i=e.once,r=t=!0;s.length;u=-1)for(n=s.shift();++u<o.length;)o[u].apply(n[0],n[1])===!1&&e.stopOnFalse&&(u=o.length,n=!1);e.memory||(n=!1),t=!1,i&&(o=n?[]:"")},c={add:function(){return o&&(n&&!t&&(u=o.length-1,s.push(n)),function r(t){pe.each(t,function(t,n){pe.isFunction(n)?e.unique&&c.has(n)||o.push(n):n&&n.length&&"string"!==pe.type(n)&&r(n)})}(arguments),n&&!t&&l()),this},remove:function(){return pe.each(arguments,function(e,t){for(var n;(n=pe.inArray(t,o,n))>-1;)o.splice(n,1),n<=u&&u--}),this},has:function(e){return e?pe.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=s=[],o=n="",this},disabled:function(){return!o},lock:function(){return i=s=[],n||t||(o=n=""),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=n||[],n=[e,n.slice?n.slice():n],s.push(n),t||l()),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},pe.extend({Deferred:function(t){var n=[["notify","progress",pe.Callbacks("memory"),pe.Callbacks("memory"),2],["resolve","done",pe.Callbacks("once memory"),pe.Callbacks("once memory"),0,"resolved"],["reject","fail",pe.Callbacks("once memory"),pe.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},"catch":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return pe.Deferred(function(t){pe.each(n,function(n,r){var i=pe.isFunction(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&pe.isFunction(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){function o(t,n,r,i){return function(){var l=this,c=arguments,f=function(){var e,f;if(!(t<a)){if(e=r.apply(l,c),e===n.promise())throw new TypeError("Thenable self-resolution");f=e&&("object"==typeof e||"function"==typeof e)&&e.then,pe.isFunction(f)?i?f.call(e,o(a,n,s,i),o(a,n,u,i)):(a++,f.call(e,o(a,n,s,i),o(a,n,u,i),o(a,n,s,n.notifyWith))):(r!==s&&(l=void 0,c=[e]),(i||n.resolveWith)(l,c))}},p=i?f:function(){try{f()}catch(e){pe.Deferred.exceptionHook&&pe.Deferred.exceptionHook(e,p.stackTrace),t+1>=a&&(r!==u&&(l=void 0,c=[e]),n.rejectWith(l,c))}};t?p():(pe.Deferred.getStackHook&&(p.stackTrace=pe.Deferred.getStackHook()),e.setTimeout(p))}}var a=0;return pe.Deferred(function(e){n[0][3].add(o(0,e,pe.isFunction(i)?i:s,e.notifyWith)),n[1][3].add(o(0,e,pe.isFunction(t)?t:s)),n[2][3].add(o(0,e,pe.isFunction(r)?r:u))}).promise()},promise:function(e){return null!=e?pe.extend(e,i):i}},o={};return pe.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[0][2].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=te.call(arguments),o=pe.Deferred(),a=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?te.call(arguments):n,--t||o.resolveWith(r,i)}};if(t<=1&&(l(e,o.done(a(n)).resolve,o.reject),"pending"===o.state()||pe.isFunction(i[n]&&i[n].then)))return o.then();for(;n--;)l(i[n],a(n),o.reject);return o.promise()}});var je=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;pe.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&je.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,n)},pe.readyException=function(t){e.setTimeout(function(){throw t})};var Ae=pe.Deferred();pe.fn.ready=function(e){return Ae.then(e)["catch"](function(e){pe.readyException(e)}),this},pe.extend({isReady:!1,readyWait:1,holdReady:function(e){e?pe.readyWait++:pe.ready(!0)},ready:function(e){(e===!0?--pe.readyWait:pe.isReady)||(pe.isReady=!0,e!==!0&&--pe.readyWait>0||Ae.resolveWith(Z,[pe]))}}),pe.ready.then=Ae.then,"complete"===Z.readyState||"loading"!==Z.readyState&&!Z.documentElement.doScroll?e.setTimeout(pe.ready):(Z.addEventListener("DOMContentLoaded",c),e.addEventListener("load",c));var qe=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===pe.type(n)){i=!0;for(s in n)qe(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,pe.isFunction(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(pe(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},Le=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};f.uid=1,f.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Le(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[pe.camelCase(t)]=n;else for(r in t)i[pe.camelCase(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][pe.camelCase(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){pe.isArray(t)?t=t.map(pe.camelCase):(t=pe.camelCase(t),t=t in r?[t]:t.match(De)||[]),n=t.length;for(;n--;)delete r[t[n]]}(void 0===t||pe.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!pe.isEmptyObject(t)}};var He=new f,Fe=new f,Oe=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Pe=/[A-Z]/g;pe.extend({hasData:function(e){return Fe.hasData(e)||He.hasData(e)},data:function(e,t,n){return Fe.access(e,t,n)},removeData:function(e,t){Fe.remove(e,t)},_data:function(e,t,n){return He.access(e,t,n)},_removeData:function(e,t){He.remove(e,t)}}),pe.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=Fe.get(o),1===o.nodeType&&!He.get(o,"hasDataAttrs"))){for(n=a.length;n--;)a[n]&&(r=a[n].name,0===r.indexOf("data-")&&(r=pe.camelCase(r.slice(5)),p(o,r,i[r])));He.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){Fe.set(this,e)}):qe(this,function(t){var n;if(o&&void 0===t){if(n=Fe.get(o,e),void 0!==n)return n;if(n=p(o,e),void 0!==n)return n}else this.each(function(){Fe.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){Fe.remove(this,e)})}}),pe.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=He.get(e,t),n&&(!r||pe.isArray(n)?r=He.access(e,t,pe.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=pe.queue(e,t),r=n.length,i=n.shift(),o=pe._queueHooks(e,t),a=function(){pe.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return He.get(e,n)||He.access(e,n,{empty:pe.Callbacks("once memory").add(function(){He.remove(e,[t+"queue",n])})})}}),pe.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?pe.queue(this[0],e):void 0===t?this:this.each(function(){var n=pe.queue(this,e,t);pe._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&pe.dequeue(this,e)})},dequeue:function(e){return this.each(function(){pe.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=pe.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";a--;)n=He.get(o[a],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var Re=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Me=new RegExp("^(?:([+-])=|)("+Re+")([a-z%]*)$","i"),Ie=["Top","Right","Bottom","Left"],We=function(e,t){return e=t||e,"none"===e.style.display||""===e.style.display&&pe.contains(e.ownerDocument,e)&&"none"===pe.css(e,"display")},$e=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i},Be={};pe.fn.extend({show:function(){return g(this,!0)},hide:function(){return g(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){We(this)?pe(this).show():pe(this).hide()})}});var _e=/^(?:checkbox|radio)$/i,ze=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,Xe=/^$|\/(?:java|ecma)script/i,Ue={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Ue.optgroup=Ue.option,Ue.tbody=Ue.tfoot=Ue.colgroup=Ue.caption=Ue.thead,Ue.th=Ue.td;var Ve=/<|&#?\w+;/;!function(){var e=Z.createDocumentFragment(),t=e.appendChild(Z.createElement("div")),n=Z.createElement("input");n.setAttribute("type","radio"),n.setAttribute("checked","checked"),n.setAttribute("name","t"),t.appendChild(n),ce.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",ce.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var Ge=Z.documentElement,Ye=/^key/,Qe=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Je=/^([^.]*)(?:\.(.+)|)/;pe.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,m=He.get(e);if(m)for(n.handler&&(o=n,n=o.handler,i=o.selector),i&&pe.find.matchesSelector(Ge,i),n.guid||(n.guid=pe.guid++),(u=m.events)||(u=m.events={}),(a=m.handle)||(a=m.handle=function(t){return"undefined"!=typeof pe&&pe.event.triggered!==t.type?pe.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(De)||[""],l=t.length;l--;)s=Je.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d&&(f=pe.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=pe.event.special[d]||{},c=pe.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&pe.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,a)!==!1||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),pe.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,m=He.hasData(e)&&He.get(e);if(m&&(u=m.events)){for(t=(t||"").match(De)||[""],l=t.length;l--;)if(s=Je.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){for(f=pe.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&f.teardown.call(e,h,m.handle)!==!1||pe.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)pe.event.remove(e,d+t[l],n,r,!0);pe.isEmptyObject(u)&&He.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=pe.event.fix(e),u=new Array(arguments.length),l=(He.get(this,"events")||{})[s.type]||[],c=pe.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,s)!==!1){for(a=pe.event.handlers.call(this,s,l),t=0;(i=a[t++])&&!s.isPropagationStopped();)for(s.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!s.isImmediatePropagationStopped();)s.rnamespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,r=((pe.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u),void 0!==r&&(s.result=r)===!1&&(s.preventDefault(),s.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a=[],s=t.delegateCount,u=e.target;if(s&&u.nodeType&&("click"!==e.type||isNaN(e.button)||e.button<1))for(;u!==this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(r=[],n=0;n<s;n++)o=t[n],i=o.selector+" ",void 0===r[i]&&(r[i]=o.needsContext?pe(i,this).index(u)>-1:pe.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&a.push({elem:u,handlers:r})}return s<t.length&&a.push({elem:this,handlers:t.slice(s)}),a},addProp:function(e,t){Object.defineProperty(pe.Event.prototype,e,{enumerable:!0,configurable:!0,get:pe.isFunction(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[pe.expando]?e:new pe.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==w()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===w()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&pe.nodeName(this,"input"))return this.click(),!1},_default:function(e){return pe.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},pe.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},pe.Event=function(e,t){return this instanceof pe.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.returnValue===!1?x:b,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&pe.extend(this,t),this.timeStamp=e&&e.timeStamp||pe.now(),void(this[pe.expando]=!0)):new pe.Event(e,t)},pe.Event.prototype={constructor:pe.Event,isDefaultPrevented:b,isPropagationStopped:b,isImmediatePropagationStopped:b,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=x,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=x,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=x,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},pe.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Ye.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Qe.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},pe.event.addProp),pe.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){pe.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||pe.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),pe.fn.extend({on:function(e,t,n,r){return T(this,e,t,n,r)},one:function(e,t,n,r){return T(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,pe(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return t!==!1&&"function"!=typeof t||(n=t,t=void 0),n===!1&&(n=b),this.each(function(){pe.event.remove(this,e,n,t)})}});var Ke=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Ze=/<script|<style|<link/i,et=/checked\s*(?:[^=]|=\s*.checked.)/i,tt=/^true\/(.*)/,nt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;pe.extend({htmlPrefilter:function(e){return e.replace(Ke,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s=e.cloneNode(!0),u=pe.contains(e.ownerDocument,e);if(!(ce.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||pe.isXMLDoc(e)))for(a=m(s),o=m(e),r=0,i=o.length;r<i;r++)N(o[r],a[r]);if(t)if(n)for(o=o||m(e),a=a||m(s),r=0,i=o.length;r<i;r++)S(o[r],a[r]);else S(e,s);return a=m(s,"script"),a.length>0&&v(a,!u&&m(e,"script")),s},cleanData:function(e){for(var t,n,r,i=pe.event.special,o=0;void 0!==(n=e[o]);o++)if(Le(n)){if(t=n[He.expando]){if(t.events)for(r in t.events)i[r]?pe.event.remove(n,r):pe.removeEvent(n,r,t.handle);n[He.expando]=void 0}n[Fe.expando]&&(n[Fe.expando]=void 0)}}}),pe.fn.extend({detach:function(e){return j(this,e,!0)},remove:function(e){return j(this,e)},text:function(e){return qe(this,function(e){return void 0===e?pe.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return D(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=C(this,e);t.appendChild(e)}})},prepend:function(){return D(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=C(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return D(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return D(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(pe.cleanData(m(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return pe.clone(this,e,t)})},html:function(e){return qe(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ze.test(e)&&!Ue[(ze.exec(e)||["",""])[1].toLowerCase()]){e=pe.htmlPrefilter(e);try{for(;n<r;n++)t=this[n]||{},1===t.nodeType&&(pe.cleanData(m(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return D(this,arguments,function(t){var n=this.parentNode;pe.inArray(this,e)<0&&(pe.cleanData(m(this)),n&&n.replaceChild(t,this))},e)}}),pe.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){pe.fn[e]=function(e){for(var n,r=[],i=pe(e),o=i.length-1,a=0;a<=o;a++)n=a===o?this:this.clone(!0),pe(i[a])[t](n),re.apply(r,n.get());return this.pushStack(r)}});var rt=/^margin/,it=new RegExp("^("+Re+")(?!px)[a-z%]+$","i"),ot=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)};!function(){function t(){if(s){s.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",s.innerHTML="",Ge.appendChild(a);var t=e.getComputedStyle(s);n="1%"!==t.top,o="2px"===t.marginLeft,r="4px"===t.width,s.style.marginRight="50%",i="4px"===t.marginRight,Ge.removeChild(a),s=null}}var n,r,i,o,a=Z.createElement("div"),s=Z.createElement("div");s.style&&(s.style.backgroundClip="content-box",s.cloneNode(!0).style.backgroundClip="",ce.clearCloneStyle="content-box"===s.style.backgroundClip,a.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",a.appendChild(s),pe.extend(ce,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return t(),r},pixelMarginRight:function(){return t(),i},reliableMarginLeft:function(){return t(),o}}))}();var at=/^(none|table(?!-c[ea]).+)/,st={position:"absolute",visibility:"hidden",display:"block"},ut={letterSpacing:"0",fontWeight:"400"},lt=["Webkit","Moz","ms"],ct=Z.createElement("div").style;pe.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=A(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=pe.camelCase(t),u=e.style;return t=pe.cssProps[s]||(pe.cssProps[s]=L(s)||s),a=pe.cssHooks[t]||pe.cssHooks[s],void 0===n?a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:u[t]:(o=typeof n,"string"===o&&(i=Me.exec(n))&&i[1]&&(n=d(e,t,i),o="number"),null!=n&&n===n&&("number"===o&&(n+=i&&i[3]||(pe.cssNumber[s]?"":"px")),ce.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u[t]=n)),void 0)}},css:function(e,t,n,r){var i,o,a,s=pe.camelCase(t);return t=pe.cssProps[s]||(pe.cssProps[s]=L(s)||s),a=pe.cssHooks[t]||pe.cssHooks[s],a&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=A(e,t,r)),"normal"===i&&t in ut&&(i=ut[t]),""===n||n?(o=parseFloat(i),n===!0||isFinite(o)?o||0:i):i}}),pe.each(["height","width"],function(e,t){pe.cssHooks[t]={get:function(e,n,r){if(n)return!at.test(pe.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?O(e,t,r):$e(e,st,function(){return O(e,t,r)})},set:function(e,n,r){var i,o=r&&ot(e),a=r&&F(e,t,r,"border-box"===pe.css(e,"boxSizing",!1,o),o);return a&&(i=Me.exec(n))&&"px"!==(i[3]||"px")&&(e.style[t]=n,n=pe.css(e,t)),H(e,n,a)}}}),pe.cssHooks.marginLeft=q(ce.reliableMarginLeft,function(e,t){if(t)return(parseFloat(A(e,"marginLeft"))||e.getBoundingClientRect().left-$e(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),pe.each({margin:"",padding:"",border:"Width"},function(e,t){pe.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+Ie[r]+t]=o[r]||o[r-2]||o[0];return i}},rt.test(e)||(pe.cssHooks[e+t].set=H)}),pe.fn.extend({css:function(e,t){return qe(this,function(e,t,n){var r,i,o={},a=0;if(pe.isArray(t)){for(r=ot(e),i=t.length;a<i;a++)o[t[a]]=pe.css(e,t[a],!1,r);return o}return void 0!==n?pe.style(e,t,n):pe.css(e,t)},e,t,arguments.length>1)}}),pe.Tween=P,P.prototype={constructor:P,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||pe.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(pe.cssNumber[n]?"":"px")},cur:function(){var e=P.propHooks[this.prop];return e&&e.get?e.get(this):P.propHooks._default.get(this)},run:function(e){var t,n=P.propHooks[this.prop];return this.options.duration?this.pos=t=pe.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):P.propHooks._default.set(this),this}},P.prototype.init.prototype=P.prototype,P.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=pe.css(e.elem,e.prop,""),t&&"auto"!==t?t:0)},set:function(e){pe.fx.step[e.prop]?pe.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[pe.cssProps[e.prop]]&&!pe.cssHooks[e.prop]?e.elem[e.prop]=e.now:pe.style(e.elem,e.prop,e.now+e.unit)}}},P.propHooks.scrollTop=P.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},pe.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},pe.fx=P.prototype.init,pe.fx.step={};var ft,pt,dt=/^(?:toggle|show|hide)$/,ht=/queueHooks$/;pe.Animation=pe.extend(_,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return d(n.elem,e,Me.exec(t),n),n}]},tweener:function(e,t){pe.isFunction(e)?(t=e,e=["*"]):e=e.match(De);for(var n,r=0,i=e.length;r<i;r++)n=e[r],_.tweeners[n]=_.tweeners[n]||[],_.tweeners[n].unshift(t)},prefilters:[$],prefilter:function(e,t){t?_.prefilters.unshift(e):_.prefilters.push(e)}}),pe.speed=function(e,t,n){var r=e&&"object"==typeof e?pe.extend({},e):{complete:n||!n&&t||pe.isFunction(e)&&e,duration:e,easing:n&&t||t&&!pe.isFunction(t)&&t};return pe.fx.off||Z.hidden?r.duration=0:r.duration="number"==typeof r.duration?r.duration:r.duration in pe.fx.speeds?pe.fx.speeds[r.duration]:pe.fx.speeds._default,null!=r.queue&&r.queue!==!0||(r.queue="fx"),r.old=r.complete,r.complete=function(){pe.isFunction(r.old)&&r.old.call(this),r.queue&&pe.dequeue(this,r.queue)},r},pe.fn.extend({fadeTo:function(e,t,n,r){return this.filter(We).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=pe.isEmptyObject(e),o=pe.speed(t,n,r),a=function(){var t=_(this,pe.extend({},e),o);(i||He.get(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=pe.timers,a=He.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&ht.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||pe.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=He.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=pe.timers,a=r?r.length:0;for(n.finish=!0,pe.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),
-o.splice(t,1));for(t=0;t<a;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),pe.each(["toggle","show","hide"],function(e,t){var n=pe.fn[t];pe.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(I(t,!0),e,r,i)}}),pe.each({slideDown:I("show"),slideUp:I("hide"),slideToggle:I("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){pe.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),pe.timers=[],pe.fx.tick=function(){var e,t=0,n=pe.timers;for(ft=pe.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||pe.fx.stop(),ft=void 0},pe.fx.timer=function(e){pe.timers.push(e),e()?pe.fx.start():pe.timers.pop()},pe.fx.interval=13,pe.fx.start=function(){pt||(pt=e.requestAnimationFrame?e.requestAnimationFrame(R):e.setInterval(pe.fx.tick,pe.fx.interval))},pe.fx.stop=function(){e.cancelAnimationFrame?e.cancelAnimationFrame(pt):e.clearInterval(pt),pt=null},pe.fx.speeds={slow:600,fast:200,_default:400},pe.fn.delay=function(t,n){return t=pe.fx?pe.fx.speeds[t]||t:t,n=n||"fx",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=Z.createElement("input"),t=Z.createElement("select"),n=t.appendChild(Z.createElement("option"));e.type="checkbox",ce.checkOn=""!==e.value,ce.optSelected=n.selected,e=Z.createElement("input"),e.value="t",e.type="radio",ce.radioValue="t"===e.value}();var gt,mt=pe.expr.attrHandle;pe.fn.extend({attr:function(e,t){return qe(this,pe.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){pe.removeAttr(this,e)})}}),pe.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?pe.prop(e,t,n):(1===o&&pe.isXMLDoc(e)||(i=pe.attrHooks[t.toLowerCase()]||(pe.expr.match.bool.test(t)?gt:void 0)),void 0!==n?null===n?void pe.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:(r=pe.find.attr(e,t),null==r?void 0:r))},attrHooks:{type:{set:function(e,t){if(!ce.radioValue&&"radio"===t&&pe.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(De);if(i&&1===e.nodeType)for(;n=i[r++];)e.removeAttribute(n)}}),gt={set:function(e,t,n){return t===!1?pe.removeAttr(e,n):e.setAttribute(n,n),n}},pe.each(pe.expr.match.bool.source.match(/\w+/g),function(e,t){var n=mt[t]||pe.find.attr;mt[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=mt[a],mt[a]=i,i=null!=n(e,t,r)?a:null,mt[a]=o),i}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;pe.fn.extend({prop:function(e,t){return qe(this,pe.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[pe.propFix[e]||e]})}}),pe.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&pe.isXMLDoc(e)||(t=pe.propFix[t]||t,i=pe.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=pe.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),ce.optSelected||(pe.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),pe.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){pe.propFix[this.toLowerCase()]=this});var xt=/[\t\r\n\f]/g;pe.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(pe.isFunction(e))return this.each(function(t){pe(this).addClass(e.call(this,t,z(this)))});if("string"==typeof e&&e)for(t=e.match(De)||[];n=this[u++];)if(i=z(n),r=1===n.nodeType&&(" "+i+" ").replace(xt," ")){for(a=0;o=t[a++];)r.indexOf(" "+o+" ")<0&&(r+=o+" ");s=pe.trim(r),i!==s&&n.setAttribute("class",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(pe.isFunction(e))return this.each(function(t){pe(this).removeClass(e.call(this,t,z(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof e&&e)for(t=e.match(De)||[];n=this[u++];)if(i=z(n),r=1===n.nodeType&&(" "+i+" ").replace(xt," ")){for(a=0;o=t[a++];)for(;r.indexOf(" "+o+" ")>-1;)r=r.replace(" "+o+" "," ");s=pe.trim(r),i!==s&&n.setAttribute("class",s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):pe.isFunction(e)?this.each(function(n){pe(this).toggleClass(e.call(this,n,z(this),t),t)}):this.each(function(){var t,r,i,o;if("string"===n)for(r=0,i=pe(this),o=e.match(De)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else void 0!==e&&"boolean"!==n||(t=z(this),t&&He.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||e===!1?"":He.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;for(t=" "+e+" ";n=this[r++];)if(1===n.nodeType&&(" "+z(n)+" ").replace(xt," ").indexOf(t)>-1)return!0;return!1}});var bt=/\r/g,wt=/[\x20\t\r\n\f]+/g;pe.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=pe.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,pe(this).val()):e,null==i?i="":"number"==typeof i?i+="":pe.isArray(i)&&(i=pe.map(i,function(e){return null==e?"":e+""})),t=pe.valHooks[this.type]||pe.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return t=pe.valHooks[i.type]||pe.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(bt,""):null==n?"":n)}}}),pe.extend({valHooks:{option:{get:function(e){var t=pe.find.attr(e,"value");return null!=t?t:pe.trim(pe.text(e)).replace(wt," ")}},select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type,a=o?null:[],s=o?i+1:r.length,u=i<0?s:o?i:0;u<s;u++)if(n=r[u],(n.selected||u===i)&&!n.disabled&&(!n.parentNode.disabled||!pe.nodeName(n.parentNode,"optgroup"))){if(t=pe(n).val(),o)return t;a.push(t)}return a},set:function(e,t){for(var n,r,i=e.options,o=pe.makeArray(t),a=i.length;a--;)r=i[a],(r.selected=pe.inArray(pe.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),pe.each(["radio","checkbox"],function(){pe.valHooks[this]={set:function(e,t){if(pe.isArray(t))return e.checked=pe.inArray(pe(e).val(),t)>-1}},ce.checkOn||(pe.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Tt=/^(?:focusinfocus|focusoutblur)$/;pe.extend(pe.event,{trigger:function(t,n,r,i){var o,a,s,u,l,c,f,p=[r||Z],d=se.call(t,"type")?t.type:t,h=se.call(t,"namespace")?t.namespace.split("."):[];if(a=s=r=r||Z,3!==r.nodeType&&8!==r.nodeType&&!Tt.test(d+pe.event.triggered)&&(d.indexOf(".")>-1&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[pe.expando]?t:new pe.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:pe.makeArray(n,[t]),f=pe.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!pe.isWindow(r)){for(u=f.delegateType||d,Tt.test(u+d)||(a=a.parentNode);a;a=a.parentNode)p.push(a),s=a;s===(r.ownerDocument||Z)&&p.push(s.defaultView||s.parentWindow||e)}for(o=0;(a=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(He.get(a,"events")||{})[t.type]&&He.get(a,"handle"),c&&c.apply(a,n),c=l&&a[l],c&&c.apply&&Le(a)&&(t.result=c.apply(a,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!Le(r)||l&&pe.isFunction(r[d])&&!pe.isWindow(r)&&(s=r[l],s&&(r[l]=null),pe.event.triggered=d,r[d](),pe.event.triggered=void 0,s&&(r[l]=s)),t.result}},simulate:function(e,t,n){var r=pe.extend(new pe.Event,n,{type:e,isSimulated:!0});pe.event.trigger(r,null,t)}}),pe.fn.extend({trigger:function(e,t){return this.each(function(){pe.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return pe.event.trigger(e,t,n,!0)}}),pe.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){pe.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),pe.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),ce.focusin="onfocusin"in e,ce.focusin||pe.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){pe.event.simulate(t,e.target,pe.event.fix(e))};pe.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=He.access(r,t);i||r.addEventListener(e,n,!0),He.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=He.access(r,t)-1;i?He.access(r,t,i):(r.removeEventListener(e,n,!0),He.remove(r,t))}}});var Ct=e.location,kt=pe.now(),Et=/\?/;pe.parseXML=function(t){var n;if(!t||"string"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,"text/xml")}catch(r){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||pe.error("Invalid XML: "+t),n};var St=/\[\]$/,Nt=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;pe.param=function(e,t){var n,r=[],i=function(e,t){var n=pe.isFunction(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(pe.isArray(e)||e.jquery&&!pe.isPlainObject(e))pe.each(e,function(){i(this.name,this.value)});else for(n in e)X(n,e[n],t,i);return r.join("&")},pe.fn.extend({serialize:function(){return pe.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=pe.prop(this,"elements");return e?pe.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!pe(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!_e.test(e))}).map(function(e,t){var n=pe(this).val();return null==n?null:pe.isArray(n)?pe.map(n,function(e){return{name:t.name,value:e.replace(Nt,"\r\n")}}):{name:t.name,value:n.replace(Nt,"\r\n")}}).get()}});var At=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ft=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=Z.createElement("a");Wt.href=Ct.href,pe.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ct.href,type:"GET",isLocal:Ft.test(Ct.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":pe.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?G(G(e,pe.ajaxSettings),t):G(pe.ajaxSettings,e)},ajaxPrefilter:U(Rt),ajaxTransport:U(Mt),ajax:function(t,n){function r(t,n,r,s){var l,p,d,b,w,T=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||"",C.readyState=t>0?4:0,l=t>=200&&t<300||304===t,r&&(b=Y(h,C,r)),b=Q(h,b,C,l),l?(h.ifModified&&(w=C.getResponseHeader("Last-Modified"),w&&(pe.lastModified[o]=w),w=C.getResponseHeader("etag"),w&&(pe.etag[o]=w)),204===t||"HEAD"===h.type?T="nocontent":304===t?T="notmodified":(T=b.state,p=b.data,d=b.error,l=!d)):(d=T,!t&&T||(T="error",t<0&&(t=0))),C.status=t,C.statusText=(n||T)+"",l?v.resolveWith(g,[p,T,C]):v.rejectWith(g,[C,T,d]),C.statusCode(x),x=void 0,f&&m.trigger(l?"ajaxSuccess":"ajaxError",[C,h,l?p:d]),y.fireWith(g,[C,T]),f&&(m.trigger("ajaxComplete",[C,h]),--pe.active||pe.event.trigger("ajaxStop")))}"object"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=pe.ajaxSetup({},n),g=h.context||h,m=h.context&&(g.nodeType||g.jquery)?pe(g):pe.event,v=pe.Deferred(),y=pe.Callbacks("once memory"),x=h.statusCode||{},b={},w={},T="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s)for(s={};t=Ht.exec(a);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=w[e.toLowerCase()]=w[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)C.always(e[C.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||T;return i&&i.abort(t),r(0,t),this}};if(v.promise(C),h.url=((t||h.url||Ct.href)+"").replace(Pt,Ct.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(De)||[""],null==h.crossDomain){l=Z.createElement("a");try{l.href=h.url,l.href=l.href,h.crossDomain=Wt.protocol+"//"+Wt.host!=l.protocol+"//"+l.host}catch(k){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=pe.param(h.data,h.traditional)),V(Rt,h,n,C),c)return C;f=pe.event&&h.global,f&&0===pe.active++&&pe.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!Ot.test(h.type),o=h.url.replace(qt,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(At,"+")):(d=h.url.slice(o.length),h.data&&(o+=(Et.test(o)?"&":"?")+h.data,delete h.data),h.cache===!1&&(o=o.replace(Lt,""),d=(Et.test(o)?"&":"?")+"_="+kt++ +d),h.url=o+d),h.ifModified&&(pe.lastModified[o]&&C.setRequestHeader("If-Modified-Since",pe.lastModified[o]),pe.etag[o]&&C.setRequestHeader("If-None-Match",pe.etag[o])),(h.data&&h.hasContent&&h.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",h.contentType),C.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+It+"; q=0.01":""):h.accepts["*"]);for(p in h.headers)C.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(h.beforeSend.call(g,C,h)===!1||c))return C.abort();if(T="abort",y.add(h.complete),C.done(h.success),C.fail(h.error),i=V(Mt,h,n,C)){if(C.readyState=1,f&&m.trigger("ajaxSend",[C,h]),c)return C;h.async&&h.timeout>0&&(u=e.setTimeout(function(){C.abort("timeout")},h.timeout));try{c=!1,i.send(b,r)}catch(k){if(c)throw k;r(-1,k)}}else r(-1,"No Transport");return C},getJSON:function(e,t,n){return pe.get(e,t,n,"json")},getScript:function(e,t){return pe.get(e,void 0,t,"script")}}),pe.each(["get","post"],function(e,t){pe[t]=function(e,n,r,i){return pe.isFunction(n)&&(i=i||r,r=n,n=void 0),pe.ajax(pe.extend({url:e,type:t,dataType:i,data:n,success:r},pe.isPlainObject(e)&&e))}}),pe._evalUrl=function(e){return pe.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},pe.fn.extend({wrapAll:function(e){var t;return this[0]&&(pe.isFunction(e)&&(e=e.call(this[0])),t=pe(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return pe.isFunction(e)?this.each(function(t){pe(this).wrapInner(e.call(this,t))}):this.each(function(){var t=pe(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=pe.isFunction(e);return this.each(function(n){pe(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){pe(this).replaceWith(this.childNodes)}),this}}),pe.expr.pseudos.hidden=function(e){return!pe.expr.pseudos.visible(e)},pe.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},pe.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(t){}};var $t={0:200,1223:204},Bt=pe.ajaxSettings.xhr();ce.cors=!!Bt&&"withCredentials"in Bt,ce.ajax=Bt=!!Bt,pe.ajaxTransport(function(t){var n,r;if(ce.cors||Bt&&!t.crossDomain)return{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");for(a in i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o($t[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=n("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n("abort");try{s.send(t.hasContent&&t.data||null)}catch(u){if(n)throw u}},abort:function(){n&&n()}}}),pe.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),pe.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return pe.globalEval(e),e}}}),pe.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),pe.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=pe("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),Z.head.appendChild(t[0])},abort:function(){n&&n()}}}});var _t=[],zt=/(=)\?(?=&|$)|\?\?/;pe.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=_t.pop()||pe.expando+"_"+kt++;return this[e]=!0,e}}),pe.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,s=t.jsonp!==!1&&(zt.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&zt.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=pe.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(zt,"$1"+i):t.jsonp!==!1&&(t.url+=(Et.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||pe.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?pe(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,_t.push(i)),a&&pe.isFunction(o)&&o(a[0]),a=o=void 0}),"script"}),ce.createHTMLDocument=function(){var e=Z.implementation.createHTMLDocument("").body;return e.innerHTML="<form></form><form></form>",2===e.childNodes.length}(),pe.parseHTML=function(e,t,n){if("string"!=typeof e)return[];"boolean"==typeof t&&(n=t,t=!1);var r,i,o;return t||(ce.createHTMLDocument?(t=Z.implementation.createHTMLDocument(""),r=t.createElement("base"),r.href=Z.location.href,t.head.appendChild(r)):t=Z),i=we.exec(e),o=!n&&[],i?[t.createElement(i[1])]:(i=y([e],t,o),o&&o.length&&pe(o).remove(),pe.merge([],i.childNodes))},pe.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return s>-1&&(r=pe.trim(e.slice(s)),e=e.slice(0,s)),pe.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&pe.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?pe("<div>").append(pe.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},pe.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){pe.fn[t]=function(e){return this.on(t,e)}}),pe.expr.pseudos.animated=function(e){return pe.grep(pe.timers,function(t){return e===t.elem}).length},pe.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l,c=pe.css(e,"position"),f=pe(e),p={};"static"===c&&(e.style.position="relative"),s=f.offset(),o=pe.css(e,"top"),u=pe.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),a=r.top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),pe.isFunction(t)&&(t=t.call(e,n,pe.extend({},s))),null!=t.top&&(p.top=t.top-s.top+a),null!=t.left&&(p.left=t.left-s.left+i),"using"in t?t.using.call(e,p):f.css(p)}},pe.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){pe.offset.setOffset(this,e,t)});var t,n,r,i,o=this[0];if(o)return o.getClientRects().length?(r=o.getBoundingClientRect(),r.width||r.height?(i=o.ownerDocument,n=J(i),t=i.documentElement,{top:r.top+n.pageYOffset-t.clientTop,left:r.left+n.pageXOffset-t.clientLeft}):r):{top:0,left:0}},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===pe.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),pe.nodeName(e[0],"html")||(r=e.offset()),r={top:r.top+pe.css(e[0],"borderTopWidth",!0),left:r.left+pe.css(e[0],"borderLeftWidth",!0)}),{top:t.top-r.top-pe.css(n,"marginTop",!0),left:t.left-r.left-pe.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent;e&&"static"===pe.css(e,"position");)e=e.offsetParent;return e||Ge})}}),pe.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;pe.fn[e]=function(r){return qe(this,function(e,r,i){var o=J(e);return void 0===i?o?o[t]:e[r]:void(o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i)},e,r,arguments.length)}}),pe.each(["top","left"],function(e,t){pe.cssHooks[t]=q(ce.pixelPosition,function(e,n){if(n)return n=A(e,t),it.test(n)?pe(e).position()[t]+"px":n})}),pe.each({Height:"height",Width:"width"},function(e,t){pe.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){pe.fn[r]=function(i,o){var a=arguments.length&&(n||"boolean"!=typeof i),s=n||(i===!0||o===!0?"margin":"border");return qe(this,function(t,n,i){var o;return pe.isWindow(t)?0===r.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?pe.css(t,n,s):pe.style(t,n,i,s)},t,a?i:void 0,a)}})}),pe.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),pe.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return pe});var Xt=e.jQuery,Ut=e.$;return pe.noConflict=function(t){return e.$===pe&&(e.$=Ut),t&&e.jQuery===pe&&(e.jQuery=Xt),pe},t||(e.jQuery=e.$=pe),pe});
+!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";function n(e,t){t=t||te;var n=t.createElement("script");n.text=e,t.head.appendChild(n).parentNode.removeChild(n)}function r(e){var t=!!e&&"length"in e&&e.length,n=he.type(e);return"function"===n||he.isWindow(e)?!1:"array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e}function i(e,t,n){return he.isFunction(t)?he.grep(e,function(e,r){return!!t.call(e,r,e)!==n}):t.nodeType?he.grep(e,function(e){return e===t!==n}):"string"!=typeof t?he.grep(e,function(e){return ae.call(t,e)>-1!==n}):Ee.test(t)?he.filter(t,e,n):(t=he.filter(t,e),he.grep(e,function(e){return ae.call(t,e)>-1!==n&&1===e.nodeType}))}function o(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function a(e){var t={};return he.each(e.match(Ae)||[],function(e,n){t[n]=!0}),t}function s(e){return e}function u(e){throw e}function l(e,t,n){var r;try{e&&he.isFunction(r=e.promise)?r.call(e).done(t).fail(n):e&&he.isFunction(r=e.then)?r.call(e,t,n):t.call(void 0,e)}catch(e){n.call(void 0,e)}}function c(){te.removeEventListener("DOMContentLoaded",c),e.removeEventListener("load",c),he.ready()}function f(){this.expando=he.expando+f.uid++}function p(e){return"true"===e?!0:"false"===e?!1:"null"===e?null:e===+e+""?+e:Re.test(e)?JSON.parse(e):e}function d(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Me,"-$&").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n=p(n)}catch(i){}Pe.set(e,t,n)}else n=void 0;return n}function h(e,t,n,r){var i,o=1,a=20,s=r?function(){return r.cur()}:function(){return he.css(e,t,"")},u=s(),l=n&&n[3]||(he.cssNumber[t]?"":"px"),c=(he.cssNumber[t]||"px"!==l&&+u)&&We.exec(he.css(e,t));if(c&&c[3]!==l){l=l||c[3],n=n||[],c=+u||1;do o=o||".5",c/=o,he.style(e,t,c+l);while(o!==(o=s()/u)&&1!==o&&--a)}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}function g(e){var t,n=e.ownerDocument,r=e.nodeName,i=ze[r];return i?i:(t=n.body.appendChild(n.createElement(r)),i=he.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),ze[r]=i,i)}function v(e,t){for(var n,r,i=[],o=0,a=e.length;a>o;o++)r=e[o],r.style&&(n=r.style.display,t?("none"===n&&(i[o]=Oe.get(r,"display")||null,i[o]||(r.style.display="")),""===r.style.display&&Be(r)&&(i[o]=g(r))):"none"!==n&&(i[o]="none",Oe.set(r,"display",n)));for(o=0;a>o;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}function m(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&he.nodeName(e,t)?he.merge([e],n):n}function y(e,t){for(var n=0,r=e.length;r>n;n++)Oe.set(e[n],"globalEval",!t||Oe.get(t[n],"globalEval"))}function x(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;h>d;d++)if(o=e[d],o||0===o)if("object"===he.type(o))he.merge(p,o.nodeType?[o]:o);else if(Ye.test(o)){for(a=a||f.appendChild(t.createElement("div")),s=(Ue.exec(o)||["",""])[1].toLowerCase(),u=Ge[s]||Ge._default,a.innerHTML=u[1]+he.htmlPrefilter(o)+u[2],c=u[0];c--;)a=a.lastChild;he.merge(p,a.childNodes),a=f.firstChild,a.textContent=""}else p.push(t.createTextNode(o));for(f.textContent="",d=0;o=p[d++];)if(r&&he.inArray(o,r)>-1)i&&i.push(o);else if(l=he.contains(o.ownerDocument,o),a=m(f.appendChild(o),"script"),l&&y(a),n)for(c=0;o=a[c++];)Ve.test(o.type||"")&&n.push(o);return f}function b(){return!0}function w(){return!1}function T(){try{return te.activeElement}catch(e){}}function C(e,t,n,r,i,o){var a,s;if("object"==typeof t){"string"!=typeof n&&(r=r||n,n=void 0);for(s in t)C(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),i===!1)i=w;else if(!i)return e;return 1===o&&(a=i,i=function(e){return he().off(e),a.apply(this,arguments)},i.guid=a.guid||(a.guid=he.guid++)),e.each(function(){he.event.add(this,t,i,r,n)})}function E(e,t){return he.nodeName(e,"table")&&he.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e:e}function k(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function N(e){var t=rt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function S(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Oe.hasData(e)&&(o=Oe.access(e),a=Oe.set(t,o),l=o.events)){delete a.handle,a.events={};for(i in l)for(n=0,r=l[i].length;r>n;n++)he.event.add(t,i,l[i][n])}Pe.hasData(e)&&(s=Pe.access(e),u=he.extend({},s),Pe.set(t,u))}}function D(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Xe.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function j(e,t,r,i){t=ie.apply([],t);var o,a,s,u,l,c,f=0,p=e.length,d=p-1,h=t[0],g=he.isFunction(h);if(g||p>1&&"string"==typeof h&&!pe.checkClone&&nt.test(h))return e.each(function(n){var o=e.eq(n);g&&(t[0]=h.call(this,n,o.html())),j(o,t,r,i)});if(p&&(o=x(t,e[0].ownerDocument,!1,e,i),a=o.firstChild,1===o.childNodes.length&&(o=a),a||i)){for(s=he.map(m(o,"script"),k),u=s.length;p>f;f++)l=o,f!==d&&(l=he.clone(l,!0,!0),u&&he.merge(s,m(l,"script"))),r.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,he.map(s,N),f=0;u>f;f++)l=s[f],Ve.test(l.type||"")&&!Oe.access(l,"globalEval")&&he.contains(c,l)&&(l.src?he._evalUrl&&he._evalUrl(l.src):n(l.textContent.replace(it,""),c))}return e}function A(e,t,n){for(var r,i=t?he.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||he.cleanData(m(r)),r.parentNode&&(n&&he.contains(r.ownerDocument,r)&&y(m(r,"script")),r.parentNode.removeChild(r));return e}function q(e,t,n){var r,i,o,a,s=e.style;return n=n||st(e),n&&(a=n.getPropertyValue(t)||n[t],""!==a||he.contains(e.ownerDocument,e)||(a=he.style(e,t)),!pe.pixelMarginRight()&&at.test(a)&&ot.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function L(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function H(e){if(e in pt)return e;for(var t=e[0].toUpperCase()+e.slice(1),n=ft.length;n--;)if(e=ft[n]+t,e in pt)return e}function F(e,t,n){var r=We.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function O(e,t,n,r,i){var o,a=0;for(o=n===(r?"border":"content")?4:"width"===t?1:0;4>o;o+=2)"margin"===n&&(a+=he.css(e,n+$e[o],!0,i)),r?("content"===n&&(a-=he.css(e,"padding"+$e[o],!0,i)),"margin"!==n&&(a-=he.css(e,"border"+$e[o]+"Width",!0,i))):(a+=he.css(e,"padding"+$e[o],!0,i),"padding"!==n&&(a+=he.css(e,"border"+$e[o]+"Width",!0,i)));return a}function P(e,t,n){var r,i=!0,o=st(e),a="border-box"===he.css(e,"boxSizing",!1,o);if(e.getClientRects().length&&(r=e.getBoundingClientRect()[t]),0>=r||null==r){if(r=q(e,t,o),(0>r||null==r)&&(r=e.style[t]),at.test(r))return r;i=a&&(pe.boxSizingReliable()||r===e.style[t]),r=parseFloat(r)||0}return r+O(e,t,n||(a?"border":"content"),i,o)+"px"}function R(e,t,n,r,i){return new R.prototype.init(e,t,n,r,i)}function M(){ht&&(e.requestAnimationFrame(M),he.fx.tick())}function I(){return e.setTimeout(function(){dt=void 0}),dt=he.now()}function W(e,t){var n,r=0,i={height:e};for(t=t?1:0;4>r;r+=2-t)n=$e[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function $(e,t,n){for(var r,i=(z.tweeners[t]||[]).concat(z.tweeners["*"]),o=0,a=i.length;a>o;o++)if(r=i[o].call(n,t,e))return r}function B(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&Be(e),m=Oe.get(e,"fxshow");n.queue||(a=he._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,he.queue(e,"fx").length||a.empty.fire()})}));for(r in t)if(i=t[r],gt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!m||void 0===m[r])continue;g=!0}d[r]=m&&m[r]||he.style(e,r)}if(u=!he.isEmptyObject(t),u||!he.isEmptyObject(d)){f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],l=m&&m.display,null==l&&(l=Oe.get(e,"display")),c=he.css(e,"display"),"none"===c&&(l?c=l:(v([e],!0),l=e.style.display||l,c=he.css(e,"display"),v([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===he.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1;for(r in d)u||(m?"hidden"in m&&(g=m.hidden):m=Oe.access(e,"fxshow",{display:l}),o&&(m.hidden=!g),g&&v([e],!0),p.done(function(){g||v([e]),Oe.remove(e,"fxshow");for(r in d)he.style(e,r,d[r])})),u=$(g?m[r]:0,r,p),r in m||(m[r]=u.start,g&&(u.end=u.start,u.start=0))}}function _(e,t){var n,r,i,o,a;for(n in e)if(r=he.camelCase(n),i=t[r],o=e[n],he.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=he.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function z(e,t,n){var r,i,o=0,a=z.prefilters.length,s=he.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=dt||I(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:he.extend({},t),opts:he.extend(!0,{specialEasing:{},easing:he.easing._default},n),originalProperties:t,originalOptions:n,startTime:dt||I(),duration:n.duration,tweens:[],createTween:function(t,n){var r=he.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(_(c,l.opts.specialEasing);a>o;o++)if(r=z.prefilters[o].call(l,e,c,l.opts))return he.isFunction(r.stop)&&(he._queueHooks(l.elem,l.opts.queue).stop=he.proxy(r.stop,r)),r;return he.map(c,$,l),he.isFunction(l.opts.start)&&l.opts.start.call(e,l),he.fx.timer(he.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function X(e){var t=e.match(Ae)||[];return t.join(" ")}function U(e){return e.getAttribute&&e.getAttribute("class")||""}function V(e,t,n,r){var i;if(he.isArray(t))he.each(t,function(t,i){n||Nt.test(e)?r(e,i):V(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,n,r)});else if(n||"object"!==he.type(t))r(e,t);else for(i in t)V(e+"["+i+"]",t[i],n,r)}function G(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(Ae)||[];if(he.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function Y(e,t,n,r){function i(s){var u;return o[s]=!0,he.each(e[s]||[],function(e,s){var l=s(t,n,r);return"string"!=typeof l||a||o[l]?a?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},a=e===Mt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function Q(e,t){var n,r,i=he.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&he.extend(!0,e,r),e}function J(e,t,n){for(var r,i,o,a,s=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}return o?(o!==u[0]&&u.unshift(o),n[o]):void 0}function K(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(a=l[u+" "+o]||l["* "+o],!a)for(i in l)if(s=i.split(" "),s[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){a===!0?a=l[i]:l[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(f){return{state:"parsererror",error:a?f:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}function Z(e){return he.isWindow(e)?e:9===e.nodeType&&e.defaultView}var ee=[],te=e.document,ne=Object.getPrototypeOf,re=ee.slice,ie=ee.concat,oe=ee.push,ae=ee.indexOf,se={},ue=se.toString,le=se.hasOwnProperty,ce=le.toString,fe=ce.call(Object),pe={},de="3.1.1",he=function(e,t){return new he.fn.init(e,t)},ge=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,ve=/^-ms-/,me=/-([a-z])/g,ye=function(e,t){return t.toUpperCase()};he.fn=he.prototype={jquery:de,constructor:he,length:0,toArray:function(){return re.call(this)},get:function(e){return null==e?re.call(this):0>e?this[e+this.length]:this[e]},pushStack:function(e){var t=he.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return he.each(this,e)},map:function(e){return this.pushStack(he.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(re.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:oe,sort:ee.sort,splice:ee.splice},he.extend=he.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||he.isFunction(a)||(a={}),s===u&&(a=this,s--);u>s;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],r=e[t],a!==r&&(l&&r&&(he.isPlainObject(r)||(i=he.isArray(r)))?(i?(i=!1,o=n&&he.isArray(n)?n:[]):o=n&&he.isPlainObject(n)?n:{},a[t]=he.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},he.extend({expando:"jQuery"+(de+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===he.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){var t=he.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},isPlainObject:function(e){var t,n;return e&&"[object Object]"===ue.call(e)?(t=ne(e))?(n=le.call(t,"constructor")&&t.constructor,"function"==typeof n&&ce.call(n)===fe):!0:!1},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?se[ue.call(e)]||"object":typeof e},globalEval:function(e){n(e)},camelCase:function(e){return e.replace(ve,"ms-").replace(me,ye)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t){var n,i=0;if(r(e))for(n=e.length;n>i&&t.call(e[i],i,e[i])!==!1;i++);else for(i in e)if(t.call(e[i],i,e[i])===!1)break;return e},trim:function(e){return null==e?"":(e+"").replace(ge,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(r(Object(e))?he.merge(n,"string"==typeof e?[e]:e):oe.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:ae.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;n>r;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,a=e.length,s=!n;a>o;o++)r=!t(e[o],o),r!==s&&i.push(e[o]);return i},map:function(e,t,n){var i,o,a=0,s=[];if(r(e))for(i=e.length;i>a;a++)o=t(e[a],a,n),null!=o&&s.push(o);else for(a in e)o=t(e[a],a,n),null!=o&&s.push(o);return ie.apply([],s)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),he.isFunction(e)?(r=re.call(arguments,2),i=function(){return e.apply(t||this,r.concat(re.call(arguments)))},i.guid=e.guid=e.guid||he.guid++,i):void 0},now:Date.now,support:pe}),"function"==typeof Symbol&&(he.fn[Symbol.iterator]=ee[Symbol.iterator]),he.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){se["[object "+t+"]"]=t.toLowerCase()});var xe=function(e){function t(e,t,n,r){var i,o,a,s,u,l,c,p=t&&t.ownerDocument,h=t?t.nodeType:9;if(n=n||[],"string"!=typeof e||!e||1!==h&&9!==h&&11!==h)return n;if(!r&&((t?t.ownerDocument||t:$)!==H&&L(t),t=t||H,O)){if(11!==h&&(u=me.exec(e)))if(i=u[1]){if(9===h){if(!(a=t.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(p&&(a=p.getElementById(i))&&I(t,a)&&a.id===i)return n.push(a),n}else{if(u[2])return K.apply(n,t.getElementsByTagName(e)),n;if((i=u[3])&&T.getElementsByClassName&&t.getElementsByClassName)return K.apply(n,t.getElementsByClassName(i)),n}if(T.qsa&&!U[e+" "]&&(!P||!P.test(e))){if(1!==h)p=t,c=e;else if("object"!==t.nodeName.toLowerCase()){for((s=t.getAttribute("id"))?s=s.replace(we,Te):t.setAttribute("id",s=W),l=N(e),o=l.length;o--;)l[o]="#"+s+" "+d(l[o]);c=l.join(","),p=ye.test(e)&&f(t.parentNode)||t}if(c)try{return K.apply(n,p.querySelectorAll(c)),n}catch(g){}finally{s===W&&t.removeAttribute("id")}}}return D(e.replace(se,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>C.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=H.createElement("fieldset");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=n.length;r--;)C.attrHandle[n[r]]=t}function a(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function s(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return function(t){return"form"in t?t.parentNode&&t.disabled===!1?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&Ee(t)===e:t.disabled===e:"label"in t?t.disabled===e:!1}}function c(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function f(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function p(){}function d(e){for(var t=0,n=e.length,r="";n>t;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&"parentNode"===o,s=_++;return t.first?function(t,n,i){for(;t=t[r];)if(1===t.nodeType||a)return e(t,n,i);return!1}:function(t,n,u){var l,c,f,p=[B,s];if(u){for(;t=t[r];)if((1===t.nodeType||a)&&e(t,n,u))return!0}else for(;t=t[r];)if(1===t.nodeType||a)if(f=t[W]||(t[W]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===B&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}return!1}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function v(e,n,r){for(var i=0,o=n.length;o>i;i++)t(e,n[i],r);return r}function m(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;u>s;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function y(e,t,n,i,o,a){return i&&!i[W]&&(i=y(i)),o&&!o[W]&&(o=y(o,a)),r(function(r,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=r||v(t||"*",s.nodeType?[s]:s,[]),y=!e||!r&&t?g:m(g,p,e,s,u),x=n?o||(r?e:h||i)?[]:a:y;if(n&&n(y,x,s,u),i)for(l=m(x,d),i(l,[],s,u),c=l.length;c--;)(f=l[c])&&(x[d[c]]=!(y[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=x.length;c--;)(f=x[c])&&l.push(y[c]=f);o(null,x=[],l,u)}for(c=x.length;c--;)(f=x[c])&&(l=o?ee(r,f):p[c])>-1&&(r[l]=!(a[l]=f))}}else x=m(x===a?x.splice(h,x.length):x),o?o(null,a,x,u):K.apply(a,x)})}function x(e){for(var t,n,r,i=e.length,o=C.relative[e[0].type],a=o||C.relative[" "],s=o?1:0,u=h(function(e){return e===t},a,!0),l=h(function(e){return ee(t,e)>-1},a,!0),c=[function(e,n,r){var i=!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r));return t=null,i}];i>s;s++)if(n=C.relative[e[s].type])c=[h(g(c),n)];else{if(n=C.filter[e[s].type].apply(null,e[s].matches),n[W]){for(r=++s;i>r&&!C.relative[e[r].type];r++);return y(s>1&&g(c),s>1&&d(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(se,"$1"),n,r>s&&x(e.slice(s,r)),i>r&&x(e=e.slice(r)),i>r&&d(e))}c.push(n)}return g(c)}function b(e,n){var i=n.length>0,o=e.length>0,a=function(r,a,s,u,l){var c,f,p,d=0,h="0",g=r&&[],v=[],y=j,x=r||o&&C.find.TAG("*",l),b=B+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=a===H||a||l);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0,a||c.ownerDocument===H||(L(c),s=!O);p=e[f++];)if(p(c,a||H,s)){u.push(c);break}l&&(B=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,v,a,s);if(r){if(d>0)for(;h--;)g[h]||v[h]||(v[h]=Q.call(u));v=m(v)}K.apply(u,v),l&&!r&&v.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&(B=b,j=y),g};return i?r(a):a}var w,T,C,E,k,N,S,D,j,A,q,L,H,F,O,P,R,M,I,W="sizzle"+1*new Date,$=e.document,B=0,_=0,z=n(),X=n(),U=n(),V=function(e,t){return e===t&&(q=!0),0},G={}.hasOwnProperty,Y=[],Q=Y.pop,J=Y.push,K=Y.push,Z=Y.slice,ee=function(e,t){for(var n=0,r=e.length;r>n;n++)if(e[n]===t)return n;return-1},te="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",ne="[\\x20\\t\\r\\n\\f]",re="(?:\\\\.|[\\w-]|[^\x00-\\xa0])+",ie="\\["+ne+"*("+re+")(?:"+ne+"*([*^$|!~]?=)"+ne+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+re+"))|)"+ne+"*\\]",oe=":("+re+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+ie+")*)|.*)\\)|)",ae=new RegExp(ne+"+","g"),se=new RegExp("^"+ne+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ne+"+$","g"),ue=new RegExp("^"+ne+"*,"+ne+"*"),le=new RegExp("^"+ne+"*([>+~]|"+ne+")"+ne+"*"),ce=new RegExp("="+ne+"*([^\\]'\"]*?)"+ne+"*\\]","g"),fe=new RegExp(oe),pe=new RegExp("^"+re+"$"),de={ID:new RegExp("^#("+re+")"),CLASS:new RegExp("^\\.("+re+")"),TAG:new RegExp("^("+re+"|[*])"),ATTR:new RegExp("^"+ie),PSEUDO:new RegExp("^"+oe),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ne+"*(even|odd|(([+-]|)(\\d*)n|)"+ne+"*(?:([+-]|)"+ne+"*(\\d+)|))"+ne+"*\\)|)","i"),bool:new RegExp("^(?:"+te+")$","i"),needsContext:new RegExp("^"+ne+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ne+"*((?:-\\d)?\\d*)"+ne+"*\\)|)(?=[^-]|$)","i")},he=/^(?:input|select|textarea|button)$/i,ge=/^h\d$/i,ve=/^[^{]+\{\s*\[native \w/,me=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ye=/[+~]/,xe=new RegExp("\\\\([\\da-f]{1,6}"+ne+"?|("+ne+")|.)","ig"),be=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},we=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,Te=function(e,t){return t?"\x00"===e?"�":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},Ce=function(){L()},Ee=h(function(e){return e.disabled===!0&&("form"in e||"label"in e)},{dir:"parentNode",next:"legend"});try{K.apply(Y=Z.call($.childNodes),$.childNodes),Y[$.childNodes.length].nodeType}catch(ke){K={apply:Y.length?function(e,t){J.apply(e,Z.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}T=t.support={},k=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},L=t.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:$;return r!==H&&9===r.nodeType&&r.documentElement?(H=r,F=H.documentElement,O=!k(H),$!==H&&(n=H.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",Ce,!1):n.attachEvent&&n.attachEvent("onunload",Ce)),T.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),T.getElementsByTagName=i(function(e){return e.appendChild(H.createComment("")),!e.getElementsByTagName("*").length}),T.getElementsByClassName=ve.test(H.getElementsByClassName),T.getById=i(function(e){return F.appendChild(e).id=W,!H.getElementsByName||!H.getElementsByName(W).length}),T.getById?(C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){return e.getAttribute("id")===t}},C.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&O){var n=t.getElementById(e);return n?[n]:[]}}):(C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){var n="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},C.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&O){var n,r,i,o=t.getElementById(e);if(o){if(n=o.getAttributeNode("id"),n&&n.value===e)return[o];for(i=t.getElementsByName(e),r=0;o=i[r++];)if(n=o.getAttributeNode("id"),n&&n.value===e)return[o]}return[]}}),C.find.TAG=T.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):T.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},C.find.CLASS=T.getElementsByClassName&&function(e,t){return"undefined"!=typeof t.getElementsByClassName&&O?t.getElementsByClassName(e):void 0},R=[],P=[],(T.qsa=ve.test(H.querySelectorAll))&&(i(function(e){F.appendChild(e).innerHTML="<a id='"+W+"'></a><select id='"+W+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&P.push("[*^$]="+ne+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||P.push("\\["+ne+"*(?:value|"+te+")"),e.querySelectorAll("[id~="+W+"-]").length||P.push("~="),e.querySelectorAll(":checked").length||P.push(":checked"),e.querySelectorAll("a#"+W+"+*").length||P.push(".#.+[+~]")}),i(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=H.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&P.push("name"+ne+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&P.push(":enabled",":disabled"),F.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&P.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),P.push(",.*:")})),(T.matchesSelector=ve.test(M=F.matches||F.webkitMatchesSelector||F.mozMatchesSelector||F.oMatchesSelector||F.msMatchesSelector))&&i(function(e){T.disconnectedMatch=M.call(e,"*"),M.call(e,"[s!='']:x"),R.push("!=",oe)}),P=P.length&&new RegExp(P.join("|")),R=R.length&&new RegExp(R.join("|")),t=ve.test(F.compareDocumentPosition),I=t||ve.test(F.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},V=t?function(e,t){if(e===t)return q=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n?n:(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&n||!T.sortDetached&&t.compareDocumentPosition(e)===n?e===H||e.ownerDocument===$&&I($,e)?-1:t===H||t.ownerDocument===$&&I($,t)?1:A?ee(A,e)-ee(A,t):0:4&n?-1:1)}:function(e,t){if(e===t)return q=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,s=[e],u=[t];if(!i||!o)return e===H?-1:t===H?1:i?-1:o?1:A?ee(A,e)-ee(A,t):0;if(i===o)return a(e,t);for(n=e;n=n.parentNode;)s.unshift(n);for(n=t;n=n.parentNode;)u.unshift(n);for(;s[r]===u[r];)r++;return r?a(s[r],u[r]):s[r]===$?-1:u[r]===$?1:0},H):H},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==H&&L(e),n=n.replace(ce,"='$1']"),T.matchesSelector&&O&&!U[n+" "]&&(!R||!R.test(n))&&(!P||!P.test(n)))try{var r=M.call(e,n);if(r||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return t(n,H,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==H&&L(e),I(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==H&&L(e);var n=C.attrHandle[t.toLowerCase()],r=n&&G.call(C.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:T.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.escape=function(e){return(e+"").replace(we,Te)},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(q=!T.detectDuplicates,A=!T.sortStable&&e.slice(0),e.sort(V),q){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return A=null,e},E=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=E(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=E(t);return n},C=t.selectors={cacheLength:50,createPseudo:r,match:de,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(xe,be),e[3]=(e[3]||e[4]||e[5]||"").replace(xe,be),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return de.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&fe.test(n)&&(t=N(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(xe,be).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=z[e+" "];return t||(t=new RegExp("(^|"+ne+")"+e+"("+ne+"|$)"))&&z(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:n?(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o.replace(ae," ")+" ").indexOf(r)>-1:"|="===n?o===r||o.slice(0,r.length+1)===r+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",v=t.parentNode,m=s&&t.nodeName.toLowerCase(),y=!u&&!s,x=!1;if(v){if(o){for(;g;){for(p=t;p=p[g];)if(s?p.nodeName.toLowerCase()===m:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?v.firstChild:v.lastChild],a&&y){for(p=v,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===B&&l[1],x=d&&l[2],p=d&&v.childNodes[d];p=++d&&p&&p[g]||(x=d=0)||h.pop();)if(1===p.nodeType&&++x&&p===t){c[e]=[B,d,x];break}}else if(y&&(p=t,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===B&&l[1],x=d),x===!1)for(;(p=++d&&p&&p[g]||(x=d=0)||h.pop())&&((s?p.nodeName.toLowerCase()!==m:1!==p.nodeType)||!++x||(y&&(f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),c[e]=[B,x]),p!==t)););return x-=i,x===r||x%r===0&&x/r>=0}}},PSEUDO:function(e,n){var i,o=C.pseudos[e]||C.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],C.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),a=i.length;a--;)r=ee(e,i[a]),e[r]=!(t[r]=i[a])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=S(e.replace(se,"$1"));return i[W]?r(function(e,t,n,r){for(var o,a=i(e,null,r,[]),s=e.length;s--;)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),t[0]=null,!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return e=e.replace(xe,be),function(t){return(t.textContent||t.innerText||E(t)).indexOf(e)>-1}}),lang:r(function(e){return pe.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(xe,be).toLowerCase(),function(t){var n;do if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);
+return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===F},focus:function(e){return e===H.activeElement&&(!H.hasFocus||H.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:l(!1),disabled:l(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!C.pseudos.empty(e)},header:function(e){return ge.test(e.nodeName)},input:function(e){return he.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:c(function(){return[0]}),last:c(function(e,t){return[t-1]}),eq:c(function(e,t,n){return[0>n?n+t:n]}),even:c(function(e,t){for(var n=0;t>n;n+=2)e.push(n);return e}),odd:c(function(e,t){for(var n=1;t>n;n+=2)e.push(n);return e}),lt:c(function(e,t,n){for(var r=0>n?n+t:n;--r>=0;)e.push(r);return e}),gt:c(function(e,t,n){for(var r=0>n?n+t:n;++r<t;)e.push(r);return e})}},C.pseudos.nth=C.pseudos.eq;for(w in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})C.pseudos[w]=s(w);for(w in{submit:!0,reset:!0})C.pseudos[w]=u(w);return p.prototype=C.filters=C.pseudos,C.setFilters=new p,N=t.tokenize=function(e,n){var r,i,o,a,s,u,l,c=X[e+" "];if(c)return n?0:c.slice(0);for(s=e,u=[],l=C.preFilter;s;){r&&!(i=ue.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),r=!1,(i=le.exec(s))&&(r=i.shift(),o.push({value:r,type:i[0].replace(se," ")}),s=s.slice(r.length));for(a in C.filter)!(i=de[a].exec(s))||l[a]&&!(i=l[a](i))||(r=i.shift(),o.push({value:r,type:a,matches:i}),s=s.slice(r.length));if(!r)break}return n?s.length:s?t.error(e):X(e,u).slice(0)},S=t.compile=function(e,t){var n,r=[],i=[],o=U[e+" "];if(!o){for(t||(t=N(e)),n=t.length;n--;)o=x(t[n]),o[W]?r.push(o):i.push(o);o=U(e,b(i,r)),o.selector=e}return o},D=t.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&N(e=l.selector||e);if(n=n||[],1===c.length){if(o=c[0]=c[0].slice(0),o.length>2&&"ID"===(a=o[0]).type&&9===t.nodeType&&O&&C.relative[o[1].type]){if(t=(C.find.ID(a.matches[0].replace(xe,be),t)||[])[0],!t)return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}for(i=de.needsContext.test(e)?0:o.length;i--&&(a=o[i],!C.relative[s=a.type]);)if((u=C.find[s])&&(r=u(a.matches[0].replace(xe,be),ye.test(o[0].type)&&f(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&d(o),!e)return K.apply(n,r),n;break}}return(l||S(e,c))(r,t,!O,n,!t||ye.test(e)&&f(t.parentNode)||t),n},T.sortStable=W.split("").sort(V).join("")===W,T.detectDuplicates=!!q,L(),T.sortDetached=i(function(e){return 1&e.compareDocumentPosition(H.createElement("fieldset"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){return n?void 0:e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),T.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){return n||"input"!==e.nodeName.toLowerCase()?void 0:e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(te,function(e,t,n){var r;return n?void 0:e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);he.find=xe,he.expr=xe.selectors,he.expr[":"]=he.expr.pseudos,he.uniqueSort=he.unique=xe.uniqueSort,he.text=xe.getText,he.isXMLDoc=xe.isXML,he.contains=xe.contains,he.escapeSelector=xe.escape;var be=function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&he(e).is(n))break;r.push(e)}return r},we=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},Te=he.expr.match.needsContext,Ce=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,Ee=/^.[^:#\[\.,]*$/;he.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?he.find.matchesSelector(r,e)?[r]:[]:he.find.matches(e,he.grep(t,function(e){return 1===e.nodeType}))},he.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(he(e).filter(function(){for(t=0;r>t;t++)if(he.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;r>t;t++)he.find(e,i[t],n);return r>1?he.uniqueSort(n):n},filter:function(e){return this.pushStack(i(this,e||[],!1))},not:function(e){return this.pushStack(i(this,e||[],!0))},is:function(e){return!!i(this,"string"==typeof e&&Te.test(e)?he(e):e||[],!1).length}});var ke,Ne=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,Se=he.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||ke,"string"==typeof e){if(r="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:Ne.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof he?t[0]:t,he.merge(this,he.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:te,!0)),Ce.test(r[1])&&he.isPlainObject(t))for(r in t)he.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=te.getElementById(r[2]),i&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):he.isFunction(e)?void 0!==n.ready?n.ready(e):e(he):he.makeArray(e,this)};Se.prototype=he.fn,ke=he(te);var De=/^(?:parents|prev(?:Until|All))/,je={children:!0,contents:!0,next:!0,prev:!0};he.fn.extend({has:function(e){var t=he(e,this),n=t.length;return this.filter(function(){for(var e=0;n>e;e++)if(he.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&he(e);if(!Te.test(e))for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&he.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?he.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?ae.call(he(e),this[0]):ae.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(he.uniqueSort(he.merge(this.get(),he(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),he.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return be(e,"parentNode")},parentsUntil:function(e,t,n){return be(e,"parentNode",n)},next:function(e){return o(e,"nextSibling")},prev:function(e){return o(e,"previousSibling")},nextAll:function(e){return be(e,"nextSibling")},prevAll:function(e){return be(e,"previousSibling")},nextUntil:function(e,t,n){return be(e,"nextSibling",n)},prevUntil:function(e,t,n){return be(e,"previousSibling",n)},siblings:function(e){return we((e.parentNode||{}).firstChild,e)},children:function(e){return we(e.firstChild)},contents:function(e){return e.contentDocument||he.merge([],e.childNodes)}},function(e,t){he.fn[e]=function(n,r){var i=he.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=he.filter(r,i)),this.length>1&&(je[e]||he.uniqueSort(i),De.test(e)&&i.reverse()),this.pushStack(i)}});var Ae=/[^\x20\t\r\n\f]+/g;he.Callbacks=function(e){e="string"==typeof e?a(e):he.extend({},e);var t,n,r,i,o=[],s=[],u=-1,l=function(){for(i=e.once,r=t=!0;s.length;u=-1)for(n=s.shift();++u<o.length;)o[u].apply(n[0],n[1])===!1&&e.stopOnFalse&&(u=o.length,n=!1);e.memory||(n=!1),t=!1,i&&(o=n?[]:"")},c={add:function(){return o&&(n&&!t&&(u=o.length-1,s.push(n)),function r(t){he.each(t,function(t,n){he.isFunction(n)?e.unique&&c.has(n)||o.push(n):n&&n.length&&"string"!==he.type(n)&&r(n)})}(arguments),n&&!t&&l()),this},remove:function(){return he.each(arguments,function(e,t){for(var n;(n=he.inArray(t,o,n))>-1;)o.splice(n,1),u>=n&&u--}),this},has:function(e){return e?he.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=s=[],o=n="",this},disabled:function(){return!o},lock:function(){return i=s=[],n||t||(o=n=""),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=n||[],n=[e,n.slice?n.slice():n],s.push(n),t||l()),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},he.extend({Deferred:function(t){var n=[["notify","progress",he.Callbacks("memory"),he.Callbacks("memory"),2],["resolve","done",he.Callbacks("once memory"),he.Callbacks("once memory"),0,"resolved"],["reject","fail",he.Callbacks("once memory"),he.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},"catch":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return he.Deferred(function(t){he.each(n,function(n,r){var i=he.isFunction(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&he.isFunction(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){function o(t,n,r,i){return function(){var l=this,c=arguments,f=function(){var e,f;if(!(a>t)){if(e=r.apply(l,c),e===n.promise())throw new TypeError("Thenable self-resolution");f=e&&("object"==typeof e||"function"==typeof e)&&e.then,he.isFunction(f)?i?f.call(e,o(a,n,s,i),o(a,n,u,i)):(a++,f.call(e,o(a,n,s,i),o(a,n,u,i),o(a,n,s,n.notifyWith))):(r!==s&&(l=void 0,c=[e]),(i||n.resolveWith)(l,c))}},p=i?f:function(){try{f()}catch(e){he.Deferred.exceptionHook&&he.Deferred.exceptionHook(e,p.stackTrace),t+1>=a&&(r!==u&&(l=void 0,c=[e]),n.rejectWith(l,c))}};t?p():(he.Deferred.getStackHook&&(p.stackTrace=he.Deferred.getStackHook()),e.setTimeout(p))}}var a=0;return he.Deferred(function(e){n[0][3].add(o(0,e,he.isFunction(i)?i:s,e.notifyWith)),n[1][3].add(o(0,e,he.isFunction(t)?t:s)),n[2][3].add(o(0,e,he.isFunction(r)?r:u))}).promise()},promise:function(e){return null!=e?he.extend(e,i):i}},o={};return he.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[0][2].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=re.call(arguments),o=he.Deferred(),a=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?re.call(arguments):n,--t||o.resolveWith(r,i)}};if(1>=t&&(l(e,o.done(a(n)).resolve,o.reject),"pending"===o.state()||he.isFunction(i[n]&&i[n].then)))return o.then();for(;n--;)l(i[n],a(n),o.reject);return o.promise()}});var qe=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;he.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&qe.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,n)},he.readyException=function(t){e.setTimeout(function(){throw t})};var Le=he.Deferred();he.fn.ready=function(e){return Le.then(e)["catch"](function(e){he.readyException(e)}),this},he.extend({isReady:!1,readyWait:1,holdReady:function(e){e?he.readyWait++:he.ready(!0)},ready:function(e){(e===!0?--he.readyWait:he.isReady)||(he.isReady=!0,e!==!0&&--he.readyWait>0||Le.resolveWith(te,[he]))}}),he.ready.then=Le.then,"complete"===te.readyState||"loading"!==te.readyState&&!te.documentElement.doScroll?e.setTimeout(he.ready):(te.addEventListener("DOMContentLoaded",c),e.addEventListener("load",c));var He=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===he.type(n)){i=!0;for(s in n)He(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,he.isFunction(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(he(e),n)})),t))for(;u>s;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},Fe=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};f.uid=1,f.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Fe(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[he.camelCase(t)]=n;else for(r in t)i[he.camelCase(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][he.camelCase(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){he.isArray(t)?t=t.map(he.camelCase):(t=he.camelCase(t),t=t in r?[t]:t.match(Ae)||[]),n=t.length;for(;n--;)delete r[t[n]]}(void 0===t||he.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!he.isEmptyObject(t)}};var Oe=new f,Pe=new f,Re=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Me=/[A-Z]/g;he.extend({hasData:function(e){return Pe.hasData(e)||Oe.hasData(e)},data:function(e,t,n){return Pe.access(e,t,n)},removeData:function(e,t){Pe.remove(e,t)},_data:function(e,t,n){return Oe.access(e,t,n)},_removeData:function(e,t){Oe.remove(e,t)}}),he.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=Pe.get(o),1===o.nodeType&&!Oe.get(o,"hasDataAttrs"))){for(n=a.length;n--;)a[n]&&(r=a[n].name,0===r.indexOf("data-")&&(r=he.camelCase(r.slice(5)),d(o,r,i[r])));Oe.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){Pe.set(this,e)}):He(this,function(t){var n;if(o&&void 0===t){if(n=Pe.get(o,e),void 0!==n)return n;if(n=d(o,e),void 0!==n)return n}else this.each(function(){Pe.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){Pe.remove(this,e)})}}),he.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=Oe.get(e,t),n&&(!r||he.isArray(n)?r=Oe.access(e,t,he.makeArray(n)):r.push(n)),r||[]):void 0},dequeue:function(e,t){t=t||"fx";var n=he.queue(e,t),r=n.length,i=n.shift(),o=he._queueHooks(e,t),a=function(){he.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Oe.get(e,n)||Oe.access(e,n,{empty:he.Callbacks("once memory").add(function(){Oe.remove(e,[t+"queue",n])})})}}),he.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?he.queue(this[0],e):void 0===t?this:this.each(function(){var n=he.queue(this,e,t);he._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&he.dequeue(this,e)})},dequeue:function(e){return this.each(function(){he.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=he.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";a--;)n=Oe.get(o[a],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var Ie=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,We=new RegExp("^(?:([+-])=|)("+Ie+")([a-z%]*)$","i"),$e=["Top","Right","Bottom","Left"],Be=function(e,t){return e=t||e,"none"===e.style.display||""===e.style.display&&he.contains(e.ownerDocument,e)&&"none"===he.css(e,"display")},_e=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i},ze={};he.fn.extend({show:function(){return v(this,!0)},hide:function(){return v(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Be(this)?he(this).show():he(this).hide()})}});var Xe=/^(?:checkbox|radio)$/i,Ue=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,Ve=/^$|\/(?:java|ecma)script/i,Ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Ge.optgroup=Ge.option,Ge.tbody=Ge.tfoot=Ge.colgroup=Ge.caption=Ge.thead,Ge.th=Ge.td;var Ye=/<|&#?\w+;/;!function(){var e=te.createDocumentFragment(),t=e.appendChild(te.createElement("div")),n=te.createElement("input");n.setAttribute("type","radio"),n.setAttribute("checked","checked"),n.setAttribute("name","t"),t.appendChild(n),pe.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",pe.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var Qe=te.documentElement,Je=/^key/,Ke=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ze=/^([^.]*)(?:\.(.+)|)/;he.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Oe.get(e);if(v)for(n.handler&&(o=n,n=o.handler,i=o.selector),i&&he.find.matchesSelector(Qe,i),n.guid||(n.guid=he.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(t){return"undefined"!=typeof he&&he.event.triggered!==t.type?he.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(Ae)||[""],l=t.length;l--;)s=Ze.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d&&(f=he.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=he.event.special[d]||{},c=he.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&he.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,a)!==!1||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),he.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Oe.hasData(e)&&Oe.get(e);if(v&&(u=v.events)){for(t=(t||"").match(Ae)||[""],l=t.length;l--;)if(s=Ze.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){for(f=he.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&f.teardown.call(e,h,v.handle)!==!1||he.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)he.event.remove(e,d+t[l],n,r,!0);he.isEmptyObject(u)&&Oe.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=he.event.fix(e),u=new Array(arguments.length),l=(Oe.get(this,"events")||{})[s.type]||[],c=he.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,s)!==!1){for(a=he.event.handlers.call(this,s,l),t=0;(i=a[t++])&&!s.isPropagationStopped();)for(s.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!s.isImmediatePropagationStopped();)s.rnamespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,r=((he.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u),void 0!==r&&(s.result=r)===!1&&(s.preventDefault(),s.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&e.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||l.disabled!==!0)){for(o=[],a={},n=0;u>n;n++)r=t[n],i=r.selector+" ",void 0===a[i]&&(a[i]=r.needsContext?he(i,this).index(l)>-1:he.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(e,t){Object.defineProperty(he.Event.prototype,e,{enumerable:!0,configurable:!0,get:he.isFunction(t)?function(){return this.originalEvent?t(this.originalEvent):void 0}:function(){return this.originalEvent?this.originalEvent[e]:void 0},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[he.expando]?e:new he.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==T()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===T()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&he.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(e){return he.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},he.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},he.Event=function(e,t){return this instanceof he.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.returnValue===!1?b:w,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&he.extend(this,t),this.timeStamp=e&&e.timeStamp||he.now(),void(this[he.expando]=!0)):new he.Event(e,t)},he.Event.prototype={constructor:he.Event,isDefaultPrevented:w,isPropagationStopped:w,isImmediatePropagationStopped:w,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=b,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=b,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=b,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},he.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Je.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ke.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},he.event.addProp),he.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){he.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||he.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),he.fn.extend({on:function(e,t,n,r){return C(this,e,t,n,r)},one:function(e,t,n,r){return C(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,he(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return t!==!1&&"function"!=typeof t||(n=t,t=void 0),n===!1&&(n=w),this.each(function(){he.event.remove(this,e,n,t)})}});var et=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,tt=/<script|<style|<link/i,nt=/checked\s*(?:[^=]|=\s*.checked.)/i,rt=/^true\/(.*)/,it=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;he.extend({htmlPrefilter:function(e){return e.replace(et,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s=e.cloneNode(!0),u=he.contains(e.ownerDocument,e);if(!(pe.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||he.isXMLDoc(e)))for(a=m(s),o=m(e),r=0,i=o.length;i>r;r++)D(o[r],a[r]);if(t)if(n)for(o=o||m(e),a=a||m(s),r=0,i=o.length;i>r;r++)S(o[r],a[r]);else S(e,s);return a=m(s,"script"),a.length>0&&y(a,!u&&m(e,"script")),s},cleanData:function(e){for(var t,n,r,i=he.event.special,o=0;void 0!==(n=e[o]);o++)if(Fe(n)){if(t=n[Oe.expando]){if(t.events)for(r in t.events)i[r]?he.event.remove(n,r):he.removeEvent(n,r,t.handle);n[Oe.expando]=void 0}n[Pe.expando]&&(n[Pe.expando]=void 0)}}}),he.fn.extend({detach:function(e){return A(this,e,!0)},remove:function(e){return A(this,e)},text:function(e){return He(this,function(e){return void 0===e?he.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return j(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=E(this,e);t.appendChild(e)}})},prepend:function(){return j(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=E(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return j(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return j(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(he.cleanData(m(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return he.clone(this,e,t)})},html:function(e){return He(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!tt.test(e)&&!Ge[(Ue.exec(e)||["",""])[1].toLowerCase()]){e=he.htmlPrefilter(e);try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(he.cleanData(m(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return j(this,arguments,function(t){var n=this.parentNode;he.inArray(this,e)<0&&(he.cleanData(m(this)),n&&n.replaceChild(t,this))},e)}}),he.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){he.fn[e]=function(e){for(var n,r=[],i=he(e),o=i.length-1,a=0;o>=a;a++)n=a===o?this:this.clone(!0),he(i[a])[t](n),oe.apply(r,n.get());return this.pushStack(r)}});var ot=/^margin/,at=new RegExp("^("+Ie+")(?!px)[a-z%]+$","i"),st=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)};!function(){function t(){if(s){s.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",s.innerHTML="",Qe.appendChild(a);var t=e.getComputedStyle(s);n="1%"!==t.top,o="2px"===t.marginLeft,r="4px"===t.width,s.style.marginRight="50%",i="4px"===t.marginRight,Qe.removeChild(a),s=null}}var n,r,i,o,a=te.createElement("div"),s=te.createElement("div");s.style&&(s.style.backgroundClip="content-box",s.cloneNode(!0).style.backgroundClip="",pe.clearCloneStyle="content-box"===s.style.backgroundClip,a.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",a.appendChild(s),he.extend(pe,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return t(),r},pixelMarginRight:function(){return t(),i},reliableMarginLeft:function(){return t(),o}}))}();var ut=/^(none|table(?!-c[ea]).+)/,lt={position:"absolute",visibility:"hidden",display:"block"},ct={letterSpacing:"0",fontWeight:"400"},ft=["Webkit","Moz","ms"],pt=te.createElement("div").style;he.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=q(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=he.camelCase(t),u=e.style;return t=he.cssProps[s]||(he.cssProps[s]=H(s)||s),a=he.cssHooks[t]||he.cssHooks[s],void 0===n?a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:u[t]:(o=typeof n,"string"===o&&(i=We.exec(n))&&i[1]&&(n=h(e,t,i),o="number"),null!=n&&n===n&&("number"===o&&(n+=i&&i[3]||(he.cssNumber[s]?"":"px")),pe.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u[t]=n)),void 0)}},css:function(e,t,n,r){var i,o,a,s=he.camelCase(t);return t=he.cssProps[s]||(he.cssProps[s]=H(s)||s),a=he.cssHooks[t]||he.cssHooks[s],a&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=q(e,t,r)),"normal"===i&&t in ct&&(i=ct[t]),""===n||n?(o=parseFloat(i),n===!0||isFinite(o)?o||0:i):i}}),he.each(["height","width"],function(e,t){he.cssHooks[t]={get:function(e,n,r){return n?!ut.test(he.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?P(e,t,r):_e(e,lt,function(){return P(e,t,r)}):void 0},set:function(e,n,r){var i,o=r&&st(e),a=r&&O(e,t,r,"border-box"===he.css(e,"boxSizing",!1,o),o);return a&&(i=We.exec(n))&&"px"!==(i[3]||"px")&&(e.style[t]=n,n=he.css(e,t)),F(e,n,a)}}}),he.cssHooks.marginLeft=L(pe.reliableMarginLeft,function(e,t){return t?(parseFloat(q(e,"marginLeft"))||e.getBoundingClientRect().left-_e(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px":void 0}),he.each({margin:"",padding:"",border:"Width"},function(e,t){he.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];4>r;r++)i[e+$e[r]+t]=o[r]||o[r-2]||o[0];return i}},ot.test(e)||(he.cssHooks[e+t].set=F)}),he.fn.extend({css:function(e,t){return He(this,function(e,t,n){var r,i,o={},a=0;if(he.isArray(t)){for(r=st(e),i=t.length;i>a;a++)o[t[a]]=he.css(e,t[a],!1,r);return o}return void 0!==n?he.style(e,t,n):he.css(e,t)},e,t,arguments.length>1)}}),he.Tween=R,R.prototype={constructor:R,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||he.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(he.cssNumber[n]?"":"px")},cur:function(){var e=R.propHooks[this.prop];return e&&e.get?e.get(this):R.propHooks._default.get(this)},run:function(e){var t,n=R.propHooks[this.prop];return this.options.duration?this.pos=t=he.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):R.propHooks._default.set(this),this}},R.prototype.init.prototype=R.prototype,R.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=he.css(e.elem,e.prop,""),t&&"auto"!==t?t:0)},set:function(e){he.fx.step[e.prop]?he.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[he.cssProps[e.prop]]&&!he.cssHooks[e.prop]?e.elem[e.prop]=e.now:he.style(e.elem,e.prop,e.now+e.unit)}}},R.propHooks.scrollTop=R.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},he.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},he.fx=R.prototype.init,he.fx.step={};var dt,ht,gt=/^(?:toggle|show|hide)$/,vt=/queueHooks$/;he.Animation=he.extend(z,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return h(n.elem,e,We.exec(t),n),n}]},tweener:function(e,t){he.isFunction(e)?(t=e,e=["*"]):e=e.match(Ae);for(var n,r=0,i=e.length;i>r;r++)n=e[r],z.tweeners[n]=z.tweeners[n]||[],z.tweeners[n].unshift(t)},prefilters:[B],prefilter:function(e,t){t?z.prefilters.unshift(e):z.prefilters.push(e)}}),he.speed=function(e,t,n){var r=e&&"object"==typeof e?he.extend({},e):{complete:n||!n&&t||he.isFunction(e)&&e,duration:e,easing:n&&t||t&&!he.isFunction(t)&&t};return he.fx.off||te.hidden?r.duration=0:"number"!=typeof r.duration&&(r.duration in he.fx.speeds?r.duration=he.fx.speeds[r.duration]:r.duration=he.fx.speeds._default),null!=r.queue&&r.queue!==!0||(r.queue="fx"),r.old=r.complete,r.complete=function(){he.isFunction(r.old)&&r.old.call(this),r.queue&&he.dequeue(this,r.queue)},r},he.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Be).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=he.isEmptyObject(e),o=he.speed(t,n,r),a=function(){var t=z(this,he.extend({},e),o);(i||Oe.get(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),
+this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=he.timers,a=Oe.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&vt.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||he.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=Oe.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=he.timers,a=r?r.length:0;for(n.finish=!0,he.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),he.each(["toggle","show","hide"],function(e,t){var n=he.fn[t];he.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(W(t,!0),e,r,i)}}),he.each({slideDown:W("show"),slideUp:W("hide"),slideToggle:W("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){he.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),he.timers=[],he.fx.tick=function(){var e,t=0,n=he.timers;for(dt=he.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||he.fx.stop(),dt=void 0},he.fx.timer=function(e){he.timers.push(e),e()?he.fx.start():he.timers.pop()},he.fx.interval=13,he.fx.start=function(){ht||(ht=e.requestAnimationFrame?e.requestAnimationFrame(M):e.setInterval(he.fx.tick,he.fx.interval))},he.fx.stop=function(){e.cancelAnimationFrame?e.cancelAnimationFrame(ht):e.clearInterval(ht),ht=null},he.fx.speeds={slow:600,fast:200,_default:400},he.fn.delay=function(t,n){return t=he.fx?he.fx.speeds[t]||t:t,n=n||"fx",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=te.createElement("input"),t=te.createElement("select"),n=t.appendChild(te.createElement("option"));e.type="checkbox",pe.checkOn=""!==e.value,pe.optSelected=n.selected,e=te.createElement("input"),e.value="t",e.type="radio",pe.radioValue="t"===e.value}();var mt,yt=he.expr.attrHandle;he.fn.extend({attr:function(e,t){return He(this,he.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){he.removeAttr(this,e)})}}),he.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?he.prop(e,t,n):(1===o&&he.isXMLDoc(e)||(i=he.attrHooks[t.toLowerCase()]||(he.expr.match.bool.test(t)?mt:void 0)),void 0!==n?null===n?void he.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:(r=he.find.attr(e,t),null==r?void 0:r))},attrHooks:{type:{set:function(e,t){if(!pe.radioValue&&"radio"===t&&he.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(Ae);if(i&&1===e.nodeType)for(;n=i[r++];)e.removeAttribute(n)}}),mt={set:function(e,t,n){return t===!1?he.removeAttr(e,n):e.setAttribute(n,n),n}},he.each(he.expr.match.bool.source.match(/\w+/g),function(e,t){var n=yt[t]||he.find.attr;yt[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=yt[a],yt[a]=i,i=null!=n(e,t,r)?a:null,yt[a]=o),i}});var xt=/^(?:input|select|textarea|button)$/i,bt=/^(?:a|area)$/i;he.fn.extend({prop:function(e,t){return He(this,he.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[he.propFix[e]||e]})}}),he.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&he.isXMLDoc(e)||(t=he.propFix[t]||t,i=he.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=he.find.attr(e,"tabindex");return t?parseInt(t,10):xt.test(e.nodeName)||bt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),pe.optSelected||(he.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),he.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){he.propFix[this.toLowerCase()]=this}),he.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(he.isFunction(e))return this.each(function(t){he(this).addClass(e.call(this,t,U(this)))});if("string"==typeof e&&e)for(t=e.match(Ae)||[];n=this[u++];)if(i=U(n),r=1===n.nodeType&&" "+X(i)+" "){for(a=0;o=t[a++];)r.indexOf(" "+o+" ")<0&&(r+=o+" ");s=X(r),i!==s&&n.setAttribute("class",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(he.isFunction(e))return this.each(function(t){he(this).removeClass(e.call(this,t,U(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof e&&e)for(t=e.match(Ae)||[];n=this[u++];)if(i=U(n),r=1===n.nodeType&&" "+X(i)+" "){for(a=0;o=t[a++];)for(;r.indexOf(" "+o+" ")>-1;)r=r.replace(" "+o+" "," ");s=X(r),i!==s&&n.setAttribute("class",s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):he.isFunction(e)?this.each(function(n){he(this).toggleClass(e.call(this,n,U(this),t),t)}):this.each(function(){var t,r,i,o;if("string"===n)for(r=0,i=he(this),o=e.match(Ae)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else void 0!==e&&"boolean"!==n||(t=U(this),t&&Oe.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||e===!1?"":Oe.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;for(t=" "+e+" ";n=this[r++];)if(1===n.nodeType&&(" "+X(U(n))+" ").indexOf(t)>-1)return!0;return!1}});var wt=/\r/g;he.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=he.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,he(this).val()):e,null==i?i="":"number"==typeof i?i+="":he.isArray(i)&&(i=he.map(i,function(e){return null==e?"":e+""})),t=he.valHooks[this.type]||he.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return t=he.valHooks[i.type]||he.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(wt,""):null==n?"":n)}}}),he.extend({valHooks:{option:{get:function(e){var t=he.find.attr(e,"value");return null!=t?t:X(he.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=0>o?u:a?o:0;u>r;r++)if(n=i[r],(n.selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!he.nodeName(n.parentNode,"optgroup"))){if(t=he(n).val(),a)return t;s.push(t)}return s},set:function(e,t){for(var n,r,i=e.options,o=he.makeArray(t),a=i.length;a--;)r=i[a],(r.selected=he.inArray(he.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),he.each(["radio","checkbox"],function(){he.valHooks[this]={set:function(e,t){return he.isArray(t)?e.checked=he.inArray(he(e).val(),t)>-1:void 0}},pe.checkOn||(he.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Tt=/^(?:focusinfocus|focusoutblur)$/;he.extend(he.event,{trigger:function(t,n,r,i){var o,a,s,u,l,c,f,p=[r||te],d=le.call(t,"type")?t.type:t,h=le.call(t,"namespace")?t.namespace.split("."):[];if(a=s=r=r||te,3!==r.nodeType&&8!==r.nodeType&&!Tt.test(d+he.event.triggered)&&(d.indexOf(".")>-1&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[he.expando]?t:new he.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:he.makeArray(n,[t]),f=he.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!he.isWindow(r)){for(u=f.delegateType||d,Tt.test(u+d)||(a=a.parentNode);a;a=a.parentNode)p.push(a),s=a;s===(r.ownerDocument||te)&&p.push(s.defaultView||s.parentWindow||e)}for(o=0;(a=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(Oe.get(a,"events")||{})[t.type]&&Oe.get(a,"handle"),c&&c.apply(a,n),c=l&&a[l],c&&c.apply&&Fe(a)&&(t.result=c.apply(a,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!Fe(r)||l&&he.isFunction(r[d])&&!he.isWindow(r)&&(s=r[l],s&&(r[l]=null),he.event.triggered=d,r[d](),he.event.triggered=void 0,s&&(r[l]=s)),t.result}},simulate:function(e,t,n){var r=he.extend(new he.Event,n,{type:e,isSimulated:!0});he.event.trigger(r,null,t)}}),he.fn.extend({trigger:function(e,t){return this.each(function(){he.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?he.event.trigger(e,t,n,!0):void 0}}),he.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){he.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),he.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),pe.focusin="onfocusin"in e,pe.focusin||he.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){he.event.simulate(t,e.target,he.event.fix(e))};he.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=Oe.access(r,t);i||r.addEventListener(e,n,!0),Oe.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=Oe.access(r,t)-1;i?Oe.access(r,t,i):(r.removeEventListener(e,n,!0),Oe.remove(r,t))}}});var Ct=e.location,Et=he.now(),kt=/\?/;he.parseXML=function(t){var n;if(!t||"string"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,"text/xml")}catch(r){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||he.error("Invalid XML: "+t),n};var Nt=/\[\]$/,St=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;he.param=function(e,t){var n,r=[],i=function(e,t){var n=he.isFunction(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(he.isArray(e)||e.jquery&&!he.isPlainObject(e))he.each(e,function(){i(this.name,this.value)});else for(n in e)V(n,e[n],t,i);return r.join("&")},he.fn.extend({serialize:function(){return he.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=he.prop(this,"elements");return e?he.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!he(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!Xe.test(e))}).map(function(e,t){var n=he(this).val();return null==n?null:he.isArray(n)?he.map(n,function(e){return{name:t.name,value:e.replace(St,"\r\n")}}):{name:t.name,value:n.replace(St,"\r\n")}}).get()}});var At=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ft=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=te.createElement("a");Wt.href=Ct.href,he.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ct.href,type:"GET",isLocal:Ft.test(Ct.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":he.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Q(Q(e,he.ajaxSettings),t):Q(he.ajaxSettings,e)},ajaxPrefilter:G(Rt),ajaxTransport:G(Mt),ajax:function(t,n){function r(t,n,r,s){var l,p,d,b,w,T=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||"",C.readyState=t>0?4:0,l=t>=200&&300>t||304===t,r&&(b=J(h,C,r)),b=K(h,b,C,l),l?(h.ifModified&&(w=C.getResponseHeader("Last-Modified"),w&&(he.lastModified[o]=w),w=C.getResponseHeader("etag"),w&&(he.etag[o]=w)),204===t||"HEAD"===h.type?T="nocontent":304===t?T="notmodified":(T=b.state,p=b.data,d=b.error,l=!d)):(d=T,!t&&T||(T="error",0>t&&(t=0))),C.status=t,C.statusText=(n||T)+"",l?m.resolveWith(g,[p,T,C]):m.rejectWith(g,[C,T,d]),C.statusCode(x),x=void 0,f&&v.trigger(l?"ajaxSuccess":"ajaxError",[C,h,l?p:d]),y.fireWith(g,[C,T]),f&&(v.trigger("ajaxComplete",[C,h]),--he.active||he.event.trigger("ajaxStop")))}"object"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=he.ajaxSetup({},n),g=h.context||h,v=h.context&&(g.nodeType||g.jquery)?he(g):he.event,m=he.Deferred(),y=he.Callbacks("once memory"),x=h.statusCode||{},b={},w={},T="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s)for(s={};t=Ht.exec(a);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=w[e.toLowerCase()]=w[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)C.always(e[C.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||T;return i&&i.abort(t),r(0,t),this}};if(m.promise(C),h.url=((t||h.url||Ct.href)+"").replace(Pt,Ct.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(Ae)||[""],null==h.crossDomain){l=te.createElement("a");try{l.href=h.url,l.href=l.href,h.crossDomain=Wt.protocol+"//"+Wt.host!=l.protocol+"//"+l.host}catch(E){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=he.param(h.data,h.traditional)),Y(Rt,h,n,C),c)return C;f=he.event&&h.global,f&&0===he.active++&&he.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!Ot.test(h.type),o=h.url.replace(qt,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(At,"+")):(d=h.url.slice(o.length),h.data&&(o+=(kt.test(o)?"&":"?")+h.data,delete h.data),h.cache===!1&&(o=o.replace(Lt,"$1"),d=(kt.test(o)?"&":"?")+"_="+Et++ +d),h.url=o+d),h.ifModified&&(he.lastModified[o]&&C.setRequestHeader("If-Modified-Since",he.lastModified[o]),he.etag[o]&&C.setRequestHeader("If-None-Match",he.etag[o])),(h.data&&h.hasContent&&h.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",h.contentType),C.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+It+"; q=0.01":""):h.accepts["*"]);for(p in h.headers)C.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(h.beforeSend.call(g,C,h)===!1||c))return C.abort();if(T="abort",y.add(h.complete),C.done(h.success),C.fail(h.error),i=Y(Mt,h,n,C)){if(C.readyState=1,f&&v.trigger("ajaxSend",[C,h]),c)return C;h.async&&h.timeout>0&&(u=e.setTimeout(function(){C.abort("timeout")},h.timeout));try{c=!1,i.send(b,r)}catch(E){if(c)throw E;r(-1,E)}}else r(-1,"No Transport");return C},getJSON:function(e,t,n){return he.get(e,t,n,"json")},getScript:function(e,t){return he.get(e,void 0,t,"script")}}),he.each(["get","post"],function(e,t){he[t]=function(e,n,r,i){return he.isFunction(n)&&(i=i||r,r=n,n=void 0),he.ajax(he.extend({url:e,type:t,dataType:i,data:n,success:r},he.isPlainObject(e)&&e))}}),he._evalUrl=function(e){return he.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},he.fn.extend({wrapAll:function(e){var t;return this[0]&&(he.isFunction(e)&&(e=e.call(this[0])),t=he(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return he.isFunction(e)?this.each(function(t){he(this).wrapInner(e.call(this,t))}):this.each(function(){var t=he(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=he.isFunction(e);return this.each(function(n){he(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){he(this).replaceWith(this.childNodes)}),this}}),he.expr.pseudos.hidden=function(e){return!he.expr.pseudos.visible(e)},he.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},he.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(t){}};var $t={0:200,1223:204},Bt=he.ajaxSettings.xhr();pe.cors=!!Bt&&"withCredentials"in Bt,pe.ajax=Bt=!!Bt,he.ajaxTransport(function(t){var n,r;return pe.cors||Bt&&!t.crossDomain?{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");for(a in i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o($t[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=n("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n("abort");try{s.send(t.hasContent&&t.data||null)}catch(u){if(n)throw u}},abort:function(){n&&n()}}:void 0}),he.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),he.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return he.globalEval(e),e}}}),he.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),he.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=he("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),te.head.appendChild(t[0])},abort:function(){n&&n()}}}});var _t=[],zt=/(=)\?(?=&|$)|\?\?/;he.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=_t.pop()||he.expando+"_"+Et++;return this[e]=!0,e}}),he.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,s=t.jsonp!==!1&&(zt.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&zt.test(t.data)&&"data");return s||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=he.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(zt,"$1"+i):t.jsonp!==!1&&(t.url+=(kt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||he.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?he(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,_t.push(i)),a&&he.isFunction(o)&&o(a[0]),a=o=void 0}),"script"):void 0}),pe.createHTMLDocument=function(){var e=te.implementation.createHTMLDocument("").body;return e.innerHTML="<form></form><form></form>",2===e.childNodes.length}(),he.parseHTML=function(e,t,n){if("string"!=typeof e)return[];"boolean"==typeof t&&(n=t,t=!1);var r,i,o;return t||(pe.createHTMLDocument?(t=te.implementation.createHTMLDocument(""),r=t.createElement("base"),r.href=te.location.href,t.head.appendChild(r)):t=te),i=Ce.exec(e),o=!n&&[],i?[t.createElement(i[1])]:(i=x([e],t,o),o&&o.length&&he(o).remove(),he.merge([],i.childNodes))},he.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return s>-1&&(r=X(e.slice(s)),e=e.slice(0,s)),he.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&he.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?he("<div>").append(he.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},he.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){he.fn[t]=function(e){return this.on(t,e)}}),he.expr.pseudos.animated=function(e){return he.grep(he.timers,function(t){return e===t.elem}).length},he.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l,c=he.css(e,"position"),f=he(e),p={};"static"===c&&(e.style.position="relative"),s=f.offset(),o=he.css(e,"top"),u=he.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),a=r.top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),he.isFunction(t)&&(t=t.call(e,n,he.extend({},s))),null!=t.top&&(p.top=t.top-s.top+a),null!=t.left&&(p.left=t.left-s.left+i),"using"in t?t.using.call(e,p):f.css(p)}},he.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){he.offset.setOffset(this,e,t)});var t,n,r,i,o=this[0];if(o)return o.getClientRects().length?(r=o.getBoundingClientRect(),r.width||r.height?(i=o.ownerDocument,n=Z(i),t=i.documentElement,{top:r.top+n.pageYOffset-t.clientTop,left:r.left+n.pageXOffset-t.clientLeft}):r):{top:0,left:0}},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===he.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),he.nodeName(e[0],"html")||(r=e.offset()),r={top:r.top+he.css(e[0],"borderTopWidth",!0),left:r.left+he.css(e[0],"borderLeftWidth",!0)}),{top:t.top-r.top-he.css(n,"marginTop",!0),left:t.left-r.left-he.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent;e&&"static"===he.css(e,"position");)e=e.offsetParent;return e||Qe})}}),he.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;he.fn[e]=function(r){return He(this,function(e,r,i){var o=Z(e);return void 0===i?o?o[t]:e[r]:void(o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i)},e,r,arguments.length)}}),he.each(["top","left"],function(e,t){he.cssHooks[t]=L(pe.pixelPosition,function(e,n){return n?(n=q(e,t),at.test(n)?he(e).position()[t]+"px":n):void 0})}),he.each({Height:"height",Width:"width"},function(e,t){he.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){he.fn[r]=function(i,o){var a=arguments.length&&(n||"boolean"!=typeof i),s=n||(i===!0||o===!0?"margin":"border");return He(this,function(t,n,i){var o;return he.isWindow(t)?0===r.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?he.css(t,n,s):he.style(t,n,i,s)},t,a?i:void 0,a)}})}),he.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),he.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return he});var Xt=e.jQuery,Ut=e.$;return he.noConflict=function(t){return e.$===he&&(e.$=Ut),t&&e.jQuery===he&&(e.jQuery=Xt),he},t||(e.jQuery=e.$=he),he});
 
 },{}],3:[function(require,module,exports){
-!function(){function o(o){o.Control.Loading=o.Control.extend({options:{delayIndicator:null,position:"topleft",separate:!1,zoomControl:null,spinjs:!1,spin:{lines:7,length:3,width:3,radius:5,rotate:13,top:"83%"}},initialize:function(t){o.setOptions(this,t),this._dataLoaders={},null!==this.options.zoomControl&&(this.zoomControl=this.options.zoomControl)},onAdd:function(n){if(this.options.spinjs&&"function"!=typeof Spinner)return t.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");this._addLayerListeners(n),this._addMapListeners(n),this.options.separate||this.zoomControl||(n.zoomControl?this.zoomControl=n.zoomControl:n.zoomsliderControl&&(this.zoomControl=n.zoomsliderControl));var i,a="leaflet-control-loading";return this.zoomControl&&!this.options.separate?(i=this.zoomControl._container,a+=" leaflet-bar-part-bottom leaflet-bar-part last",o.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom")):i=o.DomUtil.create("div","leaflet-control-zoom leaflet-bar"),this._indicator=o.DomUtil.create("a",a,i),this.options.spinjs&&(this._spinner=new Spinner(this.options.spin).spin(),this._indicator.appendChild(this._spinner.el)),i},onRemove:function(o){this._removeLayerListeners(o),this._removeMapListeners(o)},removeFrom:function(t){return this.zoomControl&&!this.options.separate?(this._container.removeChild(this._indicator),this._map=null,this.onRemove(t),this):o.Control.prototype.removeFrom.call(this,t)},addLoader:function(o){if(this._dataLoaders[o]=!0,this.options.delayIndicator&&!this.delayIndicatorTimeout){var t=this;this.delayIndicatorTimeout=setTimeout(function(){t.updateIndicator(),t.delayIndicatorTimeout=null},this.options.delayIndicator)}else this.updateIndicator()},removeLoader:function(o){delete this._dataLoaders[o],this.updateIndicator(),this.options.delayIndicator&&this.delayIndicatorTimeout&&!this.isLoading()&&(clearTimeout(this.delayIndicatorTimeout),this.delayIndicatorTimeout=null)},updateIndicator:function(){this.isLoading()?this._showIndicator():this._hideIndicator()},isLoading:function(){return this._countLoaders()>0},_countLoaders:function(){var o,t=0;for(o in this._dataLoaders)this._dataLoaders.hasOwnProperty(o)&&t++;return t},_showIndicator:function(){o.DomUtil.addClass(this._indicator,"is-loading"),this.options.separate||(this.zoomControl instanceof o.Control.Zoom?o.DomUtil.removeClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof o.Control.Zoomslider&&this.zoomControl instanceof o.Control.Zoomslider&&o.DomUtil.removeClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_hideIndicator:function(){o.DomUtil.removeClass(this._indicator,"is-loading"),this.options.separate||(this.zoomControl instanceof o.Control.Zoom?o.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof o.Control.Zoomslider&&this.zoomControl instanceof o.Control.Zoomslider&&o.DomUtil.addClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_getLastControlButton:function(){for(var o=this.zoomControl._container,t=o.children.length-1;t>0;){var n=o.children[t];if(this._indicator!==n&&0!==n.offsetWidth&&0!==n.offsetHeight)break;t--}return o.children[t]},_handleLoading:function(o){this.addLoader(this.getEventId(o))},_handleBaseLayerChange:function(t){var n=this;t.layer&&t.layer.eachLayer&&"function"==typeof t.layer.eachLayer?t.layer.eachLayer(function(o){n._handleBaseLayerChange({layer:o})}):o.TileLayer.Canvas&&t.layer instanceof o.TileLayer.Canvas||n._handleLoading(t)},_handleLoad:function(o){this.removeLoader(this.getEventId(o))},getEventId:function(o){return o.id?o.id:o.layer?o.layer._leaflet_id:o.target._leaflet_id},_layerAdd:function(o){if(o.layer&&o.layer.on)try{o.layer.on({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){t.warn("L.Control.Loading: Tried and failed to add  event handlers to layer",o.layer),t.warn("L.Control.Loading: Full details",n)}},_layerRemove:function(o){if(o.layer&&o.layer.off)try{o.layer.off({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){t.warn("L.Control.Loading: Tried and failed to remove event handlers from layer",o.layer),t.warn("L.Control.Loading: Full details",n)}},_addLayerListeners:function(o){o.eachLayer(function(o){o.on&&o.on({loading:this._handleLoading,load:this._handleLoad},this)},this),o.on("layeradd",this._layerAdd,this),o.on("layerremove",this._layerRemove,this)},_removeLayerListeners:function(o){o.eachLayer(function(o){o.off&&o.off({loading:this._handleLoading,load:this._handleLoad},this)},this),o.off("layeradd",this._layerAdd,this),o.off("layerremove",this._layerRemove,this)},_addMapListeners:function(o){o.on({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)},_removeMapListeners:function(o){o.off({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)}}),o.Map.addInitHook(function(){this.options.loadingControl&&(this.loadingControl=new o.Control.Loading,this.addControl(this.loadingControl))}),o.Control.loading=function(t){return new o.Control.Loading(t)}}var t=window.console||{error:function(){},warn:function(){}};"function"==typeof define&&define.amd?define(["leaflet"],function(t){o(t)}):o(L)}();
+!function(t){var e;if("function"==typeof define&&define.amd)define(["leaflet"],t);else if("undefined"!=typeof module)e=require("leaflet"),module.exports=t(e);else{if("undefined"==typeof window.L)throw new Error("Leaflet must be loaded first");t(window.L)}}(function(t){t.Map.mergeOptions({contextmenuItems:[]}),t.Map.ContextMenu=t.Handler.extend({_touchstart:t.Browser.msPointer?"MSPointerDown":t.Browser.pointer?"pointerdown":"touchstart",statics:{BASE_CLS:"leaflet-contextmenu"},initialize:function(e){t.Handler.prototype.initialize.call(this,e),this._items=[],this._visible=!1;var n=this._container=t.DomUtil.create("div",t.Map.ContextMenu.BASE_CLS,e._container);n.style.zIndex=1e4,n.style.position="absolute",e.options.contextmenuWidth&&(n.style.width=e.options.contextmenuWidth+"px"),this._createItems(),t.DomEvent.on(n,"click",t.DomEvent.stop).on(n,"mousedown",t.DomEvent.stop).on(n,"dblclick",t.DomEvent.stop).on(n,"contextmenu",t.DomEvent.stop)},addHooks:function(){var e=this._map.getContainer();t.DomEvent.on(e,"mouseleave",this._hide,this).on(document,"keydown",this._onKeyDown,this),t.Browser.touch&&t.DomEvent.on(document,this._touchstart,this._hide,this),this._map.on({contextmenu:this._show,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},removeHooks:function(){var e=this._map.getContainer();t.DomEvent.off(e,"mouseleave",this._hide,this).off(document,"keydown",this._onKeyDown,this),t.Browser.touch&&t.DomEvent.off(document,this._touchstart,this._hide,this),this._map.off({contextmenu:this._show,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},showAt:function(e,n){e instanceof t.LatLng&&(e=this._map.latLngToContainerPoint(e)),this._showAtPoint(e,n)},hide:function(){this._hide()},addItem:function(t){return this.insertItem(t)},insertItem:function(t,e){e=void 0!==e?e:this._items.length;var n=this._createItem(this._container,t,e);return this._items.push(n),this._sizeChanged=!0,this._map.fire("contextmenu.additem",{contextmenu:this,el:n.el,index:e}),n.el},removeItem:function(e){var n=this._container;isNaN(e)||(e=n.children[e]),e&&(this._removeItem(t.Util.stamp(e)),this._sizeChanged=!0,this._map.fire("contextmenu.removeitem",{contextmenu:this,el:e}))},removeAllItems:function(){for(var e;this._container.children.length;)e=this._container.children[0],this._removeItem(t.Util.stamp(e))},hideAllItems:function(){var t,e,n;for(e=0,n=this._items.length;n>e;e++)t=this._items[e],t.el.style.display="none"},showAllItems:function(){var t,e,n;for(e=0,n=this._items.length;n>e;e++)t=this._items[e],t.el.style.display=""},setDisabled:function(e,n){var i=this._container,o=t.Map.ContextMenu.BASE_CLS+"-item";isNaN(e)||(e=i.children[e]),e&&t.DomUtil.hasClass(e,o)&&(n?(t.DomUtil.addClass(e,o+"-disabled"),this._map.fire("contextmenu.disableitem",{contextmenu:this,el:e})):(t.DomUtil.removeClass(e,o+"-disabled"),this._map.fire("contextmenu.enableitem",{contextmenu:this,el:e})))},isVisible:function(){return this._visible},_createItems:function(){var t,e,n=this._map.options.contextmenuItems;for(t=0,e=n.length;e>t;t++)this._items.push(this._createItem(this._container,n[t]))},_createItem:function(e,n,i){if(n.separator||"-"===n)return this._createSeparator(e,i);var o=t.Map.ContextMenu.BASE_CLS+"-item",s=n.disabled?o+" "+o+"-disabled":o,h=this._insertElementAt("a",s,e,i),a=this._createEventHandler(h,n.callback,n.context,n.hideOnSelect),m="";return n.icon?m='<img class="'+t.Map.ContextMenu.BASE_CLS+'-icon" src="'+n.icon+'"/>':n.iconCls&&(m='<span class="'+t.Map.ContextMenu.BASE_CLS+"-icon "+n.iconCls+'"></span>'),h.innerHTML=m+n.text,h.href="#",t.DomEvent.on(h,"mouseover",this._onItemMouseOver,this).on(h,"mouseout",this._onItemMouseOut,this).on(h,"mousedown",t.DomEvent.stopPropagation).on(h,"click",a),t.Browser.touch&&t.DomEvent.on(h,this._touchstart,t.DomEvent.stopPropagation),{id:t.Util.stamp(h),el:h,callback:a}},_removeItem:function(e){var n,i,o,s,h;for(o=0,s=this._items.length;s>o;o++)if(n=this._items[o],n.id===e)return i=n.el,h=n.callback,h&&(t.DomEvent.off(i,"mouseover",this._onItemMouseOver,this).off(i,"mouseover",this._onItemMouseOut,this).off(i,"mousedown",t.DomEvent.stopPropagation).off(i,"click",h),t.Browser.touch&&t.DomEvent.off(i,this._touchstart,t.DomEvent.stopPropagation)),this._container.removeChild(i),this._items.splice(o,1),n;return null},_createSeparator:function(e,n){var i=this._insertElementAt("div",t.Map.ContextMenu.BASE_CLS+"-separator",e,n);return{id:t.Util.stamp(i),el:i}},_createEventHandler:function(e,n,i,o){var s=this,h=this._map,a=t.Map.ContextMenu.BASE_CLS+"-item-disabled",o=void 0!==o?o:!0;return function(m){t.DomUtil.hasClass(e,a)||(o&&s._hide(),n&&n.call(i||h,s._showLocation),s._map.fire("contextmenu:select",{contextmenu:s,el:e}))}},_insertElementAt:function(t,e,n,i){var o,s=document.createElement(t);return s.className=e,void 0!==i&&(o=n.children[i]),o?n.insertBefore(s,o):n.appendChild(s),s},_show:function(t){this._showAtPoint(t.containerPoint,t)},_showAtPoint:function(e,n){if(this._items.length){var i=this._map,o=i.containerPointToLayerPoint(e),s=i.layerPointToLatLng(o),h=t.extend(n||{},{contextmenu:this});this._showLocation={latlng:s,layerPoint:o,containerPoint:e},n&&n.relatedTarget&&(this._showLocation.relatedTarget=n.relatedTarget),this._setPosition(e),this._visible?this._setPosition(e):(this._container.style.display="block",this._visible=!0),this._map.fire("contextmenu.show",h)}},_hide:function(){this._visible&&(this._visible=!1,this._container.style.display="none",this._map.fire("contextmenu.hide",{contextmenu:this}))},_setPosition:function(e){var n,i=this._map.getSize(),o=this._container,s=this._getElementSize(o);this._map.options.contextmenuAnchor&&(n=t.point(this._map.options.contextmenuAnchor),e=e.add(n)),o._leaflet_pos=e,e.x+s.x>i.x?(o.style.left="auto",o.style.right=Math.max(i.x-e.x,0)+"px"):(o.style.left=Math.max(e.x,0)+"px",o.style.right="auto"),e.y+s.y>i.y?(o.style.top="auto",o.style.bottom=Math.max(i.y-e.y,0)+"px"):(o.style.top=Math.max(e.y,0)+"px",o.style.bottom="auto")},_getElementSize:function(t){var e=this._size,n=t.style.display;return e&&!this._sizeChanged||(e={},t.style.left="-999999px",t.style.right="auto",t.style.display="block",e.x=t.offsetWidth,e.y=t.offsetHeight,t.style.left="auto",t.style.display=n,this._sizeChanged=!1),e},_onKeyDown:function(t){var e=t.keyCode;27===e&&this._hide()},_onItemMouseOver:function(e){t.DomUtil.addClass(e.target||e.srcElement,"over")},_onItemMouseOut:function(e){t.DomUtil.removeClass(e.target||e.srcElement,"over")}}),t.Map.addInitHook("addHandler","contextmenu",t.Map.ContextMenu),t.Mixin.ContextMenu={bindContextMenu:function(e){return t.setOptions(this,e),this._initContextMenu(),this},unbindContextMenu:function(){return this.off("contextmenu",this._showContextMenu,this),this},addContextMenuItem:function(t){this.options.contextmenuItems.push(t)},removeContextMenuItemWithIndex:function(t){for(var e=[],n=0;n<this.options.contextmenuItems.length;n++)this.options.contextmenuItems[n].index==t&&e.push(n);for(var i=e.pop();void 0!==i;)this.options.contextmenuItems.splice(i,1),i=e.pop()},replaceConextMenuItem:function(t){this.removeContextMenuItemWithIndex(t.index),this.addContextMenuItem(t)},_initContextMenu:function(){this._items=[],this.on("contextmenu",this._showContextMenu,this)},_showContextMenu:function(e){var n,i,o,s,h;if(this._map.contextmenu){for(i=t.extend({relatedTarget:this},e),o=this._map.mouseEventToContainerPoint(e.originalEvent),this.options.contextmenuInheritItems||this._map.contextmenu.hideAllItems(),s=0,h=this.options.contextmenuItems.length;h>s;s++)n=this.options.contextmenuItems[s],this._items.push(this._map.contextmenu.insertItem(n,n.index));this._map.once("contextmenu.hide",this._hideContextMenu,this),this._map.contextmenu.showAt(o,i)}},_hideContextMenu:function(){var t,e;for(t=0,e=this._items.length;e>t;t++)this._map.contextmenu.removeItem(this._items[t]);this._items.length=0,this.options.contextmenuInheritItems||this._map.contextmenu.showAllItems()}};var e,n,i,o=[t.Marker,t.Path],s={contextmenu:!1,contextmenuItems:[],contextmenuInheritItems:!0};for(n=0,i=o.length;i>n;n++)e=o[n],e.prototype.options?e.mergeOptions(s):e.prototype.options=s,e.addInitHook(function(){this.options.contextmenu&&this._initContextMenu()}),e.include(t.Mixin.ContextMenu);return t.Map.ContextMenu});
 
-},{}],4:[function(require,module,exports){
-!function(t,e,i){var n=t.L,o={};o.version="0.7.7","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;i<n;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&e.indexOf("?")!==-1?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;t<e;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;n<a;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;n<a;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;n<a;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;n<a;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=a.indexOf("webkit")!==-1,h=a.indexOf("chrome")!==-1,l=a.indexOf("phantom")!==-1,u=a.indexOf("android")!==-1,c=a.search("android [23]")!==-1,d=a.indexOf("gecko")!==-1,p=typeof orientation!=i+"",_=!t.PointerEvent&&t.MSPointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&(m||"ontouchstart"in t||t.DocumentTouch&&e instanceof t.DocumentTouch);o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();"none"===l&&"none"===u||(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;s<a;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(i<t||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return!!t&&(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast()))},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,(-1),0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n));s=e.maxZoom?Math.min(e.maxZoom,s):s;var a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return!!t&&o.stamp(t)in this._layers},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&s<=a);return u&&e?null:e?s:s-1},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;e<i;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,this.fire("viewreset",{hard:!i}),a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-(1/0),o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;i<n;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;t<e;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,
-transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,(-i),.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-(1/0));for(n=0,o=s.length;n<o;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;n<h;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=this._getTileSize(),o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;e.detectRetina&&o.Browser.retina?i.width=i.height=2*n:i.width=i.height=n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i="shadow"===e?o.point(n.shadowAnchor||n.iconAnchor):o.point(n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;t<i;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){return this._icon&&this._setPos(this._map.latLngToLayerPoint(this._latlng).round()),this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return n.html!==!1?i.innerHTML=n.html:i.innerHTML="",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t,t._source=this):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;e<i;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return!!t&&(t in this._layers||this.getLayerId(t)in this._layers)},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),"off"in t&&t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){!o.Browser.svg&&o.Browser.vml||o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this._map&&this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),
-this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:(this._popup&&!e||(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,i.dashArray?t.dashStyle=o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):t.dashStyle="",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this.fire("remove"),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color),t.lineCap&&(this._ctx.lineCap=t.lineCap),t.lineJoin&&(this._ctx.lineJoin=t.lineJoin)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;t<i;t++){for(e=0,n=this._parts[t].length;e<n;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill(e.fillRule||"evenodd")),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click dblclick contextmenu",this._fireMouseEvent,this))},_fireMouseEvent:function(t){this._containsPoint(t.layerPoint)&&this.fire(t.type,t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;a<n;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;a<=o-1;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;n<s;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return o<s-1&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;t<e;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";t<e;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;r<h;r++)for(var l=s[r],u=1,c=l.length;u<c;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);d<n&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;i<n;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";n<s;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;t<s-1;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),i[1]===n[t+1]&&t!==s-2||(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;i<n;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;n<l;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;a<4;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;n<l;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;e<i;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;t<i;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;e<n;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;i<n;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){i<n?t.setLatLngs(e[i++]):this.removeLayer(t)},this);i<n;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;i<a;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;n<r;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),h<=u))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;s<h;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;a<l;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;e<i;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;r<h;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;r<h;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;o<s;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;i<n;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;t<e;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){if(o.DomEvent._checkMouse(t,e))return a(e)},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&n<500||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!t.shiftKey&&(1===t.which||1===t.button||t.touches)&&(o.DomEvent.stopPropagation(t),!o.Draggable._disabled&&(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),!this._moving))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.Browser.touch&&Math.abs(s.x)+Math.abs(s.y)<3||(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget)))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&n<=u,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(e===-1)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],"function"==typeof n?s[a]=n.bind(h):s[a]=n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);
-case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){"mouse"!==t.pointerType&&t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(!e.options.bounceAtZoomLimits&&(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1)||(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t)))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta,!1,!0)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!(!t.shiftKey||1!==t.which&&1!==t.button)&&(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;t.tabIndex===-1&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;e<i;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;e<i;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;e<i;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;e<i;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;e<i;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;e<i;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),i.indexOf("bottom")!==-1?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){if(t)return this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this},removeAttribution:function(t){if(t)return this._attributions[t]&&(this._attributions[t]--,this._update()),this},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=e<1e3?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange,this).off("layerremove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;t<o;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,(!0))},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return!((e&&e.animate)!==!0&&!this.getSize().contains(i))&&(this.panBy(i,e),!0)}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;t<e?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return!(i.animate!==!0&&!this.getSize().contains(o))&&(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0)},_animateZoom:function(t,e,i,n,s,a,r){r||(this._animatingZoom=!0),o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),o.Util.requestAnimFrame(function(){this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a}),setTimeout(o.bind(this._onZoomTransitionEnd,this),250)},this)},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),o.Util.requestAnimFrame(function(){this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)},this))}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth);var i=this._map.getZoom();(i>this.options.maxZoom||i<this.options.minZoom)&&this._clearBgBuffer(),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&n<.5?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;e<i;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;e<i;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
+},{"leaflet":5}],4:[function(require,module,exports){
+!function(){function o(o){o.Control.Loading=o.Control.extend({options:{delayIndicator:null,position:"topleft",separate:!1,zoomControl:null,spinjs:!1,spin:{lines:7,length:3,width:3,radius:5,rotate:13,top:"83%"}},initialize:function(t){o.setOptions(this,t),this._dataLoaders={},null!==this.options.zoomControl&&(this.zoomControl=this.options.zoomControl)},onAdd:function(n){if(this.options.spinjs&&"function"!=typeof Spinner)return t.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");this._addLayerListeners(n),this._addMapListeners(n),this.options.separate||this.zoomControl||(n.zoomControl?this.zoomControl=n.zoomControl:n.zoomsliderControl&&(this.zoomControl=n.zoomsliderControl));var i,a="leaflet-control-loading";return this.zoomControl&&!this.options.separate?(i=this.zoomControl._container,a+=" leaflet-bar-part-bottom leaflet-bar-part last",o.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom")):i=o.DomUtil.create("div","leaflet-control-zoom leaflet-bar"),this._indicator=o.DomUtil.create("a",a,i),this.options.spinjs&&(this._spinner=new Spinner(this.options.spin).spin(),this._indicator.appendChild(this._spinner.el)),i},onRemove:function(o){this._removeLayerListeners(o),this._removeMapListeners(o)},removeFrom:function(t){return this.zoomControl&&!this.options.separate?(this._container.removeChild(this._indicator),this._map=null,this.onRemove(t),this):o.Control.prototype.removeFrom.call(this,t)},addLoader:function(o){if(this._dataLoaders[o]=!0,this.options.delayIndicator&&!this.delayIndicatorTimeout){var t=this;this.delayIndicatorTimeout=setTimeout(function(){t.updateIndicator(),t.delayIndicatorTimeout=null},this.options.delayIndicator)}else this.updateIndicator()},removeLoader:function(o){delete this._dataLoaders[o],this.updateIndicator(),this.options.delayIndicator&&this.delayIndicatorTimeout&&!this.isLoading()&&(clearTimeout(this.delayIndicatorTimeout),this.delayIndicatorTimeout=null)},updateIndicator:function(){this.isLoading()?this._showIndicator():this._hideIndicator()},isLoading:function(){return this._countLoaders()>0},_countLoaders:function(){var o,t=0;for(o in this._dataLoaders)this._dataLoaders.hasOwnProperty(o)&&t++;return t},_showIndicator:function(){o.DomUtil.addClass(this._indicator,"is-loading"),this.options.separate||(this.zoomControl instanceof o.Control.Zoom?o.DomUtil.removeClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof o.Control.Zoomslider&&this.zoomControl instanceof o.Control.Zoomslider&&o.DomUtil.removeClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_hideIndicator:function(){o.DomUtil.removeClass(this._indicator,"is-loading"),this.options.separate||(this.zoomControl instanceof o.Control.Zoom?o.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof o.Control.Zoomslider&&this.zoomControl instanceof o.Control.Zoomslider&&o.DomUtil.addClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_getLastControlButton:function(){for(var o=this.zoomControl._container,t=o.children.length-1;t>0;){var n=o.children[t];if(this._indicator!==n&&0!==n.offsetWidth&&0!==n.offsetHeight)break;t--}return o.children[t]},_handleLoading:function(o){this.addLoader(this.getEventId(o))},_handleBaseLayerChange:function(t){var n=this;t.layer&&t.layer.eachLayer&&"function"==typeof t.layer.eachLayer?t.layer.eachLayer(function(o){n._handleBaseLayerChange({layer:o})}):o.TileLayer.Canvas&&t.layer instanceof o.TileLayer.Canvas||n._handleLoading(t)},_handleLoad:function(o){this.removeLoader(this.getEventId(o))},getEventId:function(o){return o.id?o.id:o.layer?o.layer._leaflet_id:o.target._leaflet_id},_layerAdd:function(o){if(o.layer&&o.layer.on)try{o.layer.on({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){t.warn("L.Control.Loading: Tried and failed to add  event handlers to layer",o.layer),t.warn("L.Control.Loading: Full details",n)}},_layerRemove:function(o){if(o.layer&&o.layer.off)try{o.layer.off({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){t.warn("L.Control.Loading: Tried and failed to remove event handlers from layer",o.layer),t.warn("L.Control.Loading: Full details",n)}},_addLayerListeners:function(o){o.eachLayer(function(o){o.on&&o.on({loading:this._handleLoading,load:this._handleLoad},this)},this),o.on("layeradd",this._layerAdd,this),o.on("layerremove",this._layerRemove,this)},_removeLayerListeners:function(o){o.eachLayer(function(o){o.off&&o.off({loading:this._handleLoading,load:this._handleLoad},this)},this),o.off("layeradd",this._layerAdd,this),o.off("layerremove",this._layerRemove,this)},_addMapListeners:function(o){o.on({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)},_removeMapListeners:function(o){o.off({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)}}),o.Map.addInitHook(function(){this.options.loadingControl&&(this.loadingControl=new o.Control.Loading,this.addControl(this.loadingControl))}),o.Control.loading=function(t){return new o.Control.Loading(t)}}var t=window.console||{error:function(){},warn:function(){}};"function"==typeof define&&define.amd?define(["leaflet"],function(t){o(t)}):o(L)}();
 
 },{}],5:[function(require,module,exports){
+!function(t,e,i){function n(){var e=t.L;o.noConflict=function(){return t.L=e,this},t.L=o}var o={version:"1.0.1"};"object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),"undefined"!=typeof t&&n(),o.Util={extend:function(t){var e,i,n,o;for(i=1,n=arguments.length;n>i;i++){o=arguments[i];for(e in o)t[e]=o[e]}return t},create:Object.create||function(){function t(){}return function(e){return t.prototype=e,new t}}(),bind:function(t,e){var i=Array.prototype.slice;if(t.bind)return t.bind.apply(t,i.call(arguments,1));var n=i.call(arguments,2);return function(){return t.apply(e,n.length?n.concat(i.call(arguments)):arguments)}},stamp:function(t){return t._leaflet_id=t._leaflet_id||++o.Util.lastId,t._leaflet_id},lastId:0,throttle:function(t,e,i){var n,o,s,r;return r=function(){n=!1,o&&(s.apply(i,o),o=!1)},s=function(){n?o=arguments:(t.apply(i,arguments),setTimeout(r,e),n=!0)}},wrapNum:function(t,e,i){var n=e[1],o=e[0],s=n-o;return t===n&&i?t:((t-o)%s+s)%s+o},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){t.hasOwnProperty("options")||(t.options=t.options?o.Util.create(t.options):{});for(var i in e)t.options[i]=e[i];return t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(o.Util.templateRe,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},templateRe:/\{ *([\w_\-]+) *\}/g,isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},indexOf:function(t,e){for(var i=0;i<t.length;i++)if(t[i]===e)return i;return-1},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){return t["webkit"+e]||t["moz"+e]||t["ms"+e]}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,r=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,r){return r&&s===i?void e.call(n):s.call(t,o.bind(e,n))},o.Util.cancelAnimFrame=function(e){e&&r.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()},i=e.__super__=this.prototype,n=o.Util.create(i);n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);return t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),n.options&&(t.options=o.Util.extend(o.Util.create(n.options),t.options)),o.extend(n,t),n._initHooks=[],n.callInitHooks=function(){if(!this._initHooksCalled){i.callInitHooks&&i.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){return o.extend(this.prototype,t),this},o.Class.mergeOptions=function(t){return o.extend(this.prototype.options,t),this},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i),this},o.Evented=o.Class.extend({on:function(t,e,i){if("object"==typeof t)for(var n in t)this._on(n,t[n],e);else{t=o.Util.splitWords(t);for(var s=0,r=t.length;r>s;s++)this._on(t[s],e,i)}return this},off:function(t,e,i){if(t)if("object"==typeof t)for(var n in t)this._off(n,t[n],e);else{t=o.Util.splitWords(t);for(var s=0,r=t.length;r>s;s++)this._off(t[s],e,i)}else delete this._events;return this},_on:function(t,e,n){this._events=this._events||{};var o=this._events[t];o||(o=[],this._events[t]=o),n===this&&(n=i);for(var s={fn:e,ctx:n},r=o,a=0,h=r.length;h>a;a++)if(r[a].fn===e&&r[a].ctx===n)return;r.push(s),o.count++},_off:function(t,e,n){var s,r,a;if(this._events&&(s=this._events[t])){if(!e){for(r=0,a=s.length;a>r;r++)s[r].fn=o.Util.falseFn;return void delete this._events[t]}if(n===this&&(n=i),s)for(r=0,a=s.length;a>r;r++){var h=s[r];if(h.ctx===n&&h.fn===e)return h.fn=o.Util.falseFn,this._firingCount&&(this._events[t]=s=s.slice()),void s.splice(r,1)}}},fire:function(t,e,i){if(!this.listens(t,i))return this;var n=o.Util.extend({},e,{type:t,target:this});if(this._events){var s=this._events[t];if(s){this._firingCount=this._firingCount+1||1;for(var r=0,a=s.length;a>r;r++){var h=s[r];h.fn.call(h.ctx||this,n)}this._firingCount--}}return i&&this._propagateEvent(n),this},listens:function(t,e){var i=this._events&&this._events[t];if(i&&i.length)return!0;if(e)for(var n in this._eventParents)if(this._eventParents[n].listens(t,e))return!0;return!1},once:function(t,e,i){if("object"==typeof t){for(var n in t)this.once(n,t[n],e);return this}var s=o.bind(function(){this.off(t,e,i).off(t,s,i)},this);return this.on(t,e,i).on(t,s,i)},addEventParent:function(t){return this._eventParents=this._eventParents||{},this._eventParents[o.stamp(t)]=t,this},removeEventParent:function(t){return this._eventParents&&delete this._eventParents[o.stamp(t)],this},_propagateEvent:function(t){for(var e in this._eventParents)this._eventParents[e].fire(t.type,o.extend({layer:t.target},t),!0)}});var s=o.Evented.prototype;s.addEventListener=s.on,s.removeEventListener=s.clearAllEventListeners=s.off,s.addOneTimeEventListener=s.once,s.fireEvent=s.fire,s.hasEventListeners=s.listens,o.Mixin={Events:s},function(){var i=navigator.userAgent.toLowerCase(),n=e.documentElement,s="ActiveXObject"in t,r=-1!==i.indexOf("webkit"),a=-1!==i.indexOf("phantom"),h=-1!==i.search("android [23]"),l=-1!==i.indexOf("chrome"),u=-1!==i.indexOf("gecko")&&!r&&!t.opera&&!s,c=0===navigator.platform.indexOf("Win"),d="undefined"!=typeof orientation||-1!==i.indexOf("mobile"),_=!t.PointerEvent&&t.MSPointerEvent,m=t.PointerEvent||_,p=s&&"transition"in n.style,f="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!h,g="MozPerspective"in n.style,v="OTransition"in n.style,y=!t.L_NO_TOUCH&&(m||"ontouchstart"in t||t.DocumentTouch&&e instanceof t.DocumentTouch);o.Browser={ie:s,ielt9:s&&!e.addEventListener,edge:"msLaunchUri"in navigator&&!("documentMode"in e),webkit:r,gecko:u,android:-1!==i.indexOf("android"),android23:h,chrome:l,safari:!l&&-1!==i.indexOf("safari"),win:c,ie3d:p,webkit3d:f,gecko3d:g,opera12:v,any3d:!t.L_DISABLE_3D&&(p||f||g)&&!v&&!a,mobile:d,mobileWebkit:d&&r,mobileWebkit3d:d&&f,mobileOpera:d&&t.opera,mobileGecko:d&&u,touch:!!y,msPointer:!!_,pointer:!!m,retina:(t.devicePixelRatio||t.screen.deviceXDPI/t.screen.logicalXDPI)>1}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},scaleBy:function(t){return new o.Point(this.x*t.x,this.y*t.y)},unscaleBy:function(t){return new o.Point(this.x/t.x,this.y/t.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:"object"==typeof t&&"x"in t&&"y"in t?new o.Point(t.x,t.y):new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,r=s.x>=e.x&&n.x<=i.x,a=s.y>=e.y&&n.y<=i.y;return r&&a},overlaps:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,r=s.x>e.x&&n.x<i.x,a=s.y>e.y&&n.y<i.y;return r&&a},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i]||t.currentStyle&&t.currentStyle[i];if((!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},create:function(t,i,n){var o=e.createElement(t);return o.className=i||"",n&&n.appendChild(o),o},remove:function(t){var e=t.parentNode;e&&e.removeChild(t)},empty:function(t){for(;t.firstChild;)t.removeChild(t.firstChild)},toFront:function(t){t.parentNode.appendChild(t)},toBack:function(t){var e=t.parentNode;e.insertBefore(t,e.firstChild)},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil.getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,r=n.length;r>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var a=o.DomUtil.getClass(t);o.DomUtil.setClass(t,(a?a+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil.setClass(t,o.Util.trim((" "+o.DomUtil.getClass(t)+" ").replace(" "+e+" "," ")))},setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){"opacity"in t.style?t.style.opacity=e:"filter"in t.style&&o.DomUtil._setOpacityIE(t,e)},_setOpacityIE:function(t,e){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},setTransform:function(t,e,i){var n=e||new o.Point(0,0);t.style[o.DomUtil.TRANSFORM]=(o.Browser.ie3d?"translate("+n.x+"px,"+n.y+"px)":"translate3d("+n.x+"px,"+n.y+"px,0)")+(i?" scale("+i+")":"")},setPosition:function(t,e){t._leaflet_pos=e,o.Browser.any3d?o.DomUtil.setTransform(t,e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos||new o.Point(0,0)}},function(){o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]);var i=o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]);if(o.DomUtil.TRANSITION_END="webkitTransition"===i||"OTransition"===i?i+"End":"transitionend","onselectstart"in e)o.DomUtil.disableTextSelection=function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},o.DomUtil.enableTextSelection=function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)};else{var n=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.DomUtil.disableTextSelection=function(){if(n){var t=e.documentElement.style;this._userSelect=t[n],t[n]="none"}},o.DomUtil.enableTextSelection=function(){n&&(e.documentElement.style[n]=this._userSelect,delete this._userSelect)}}o.DomUtil.disableImageDrag=function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},o.DomUtil.enableImageDrag=function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)},o.DomUtil.preventOutline=function(e){for(;-1===e.tabIndex;)e=e.parentNode;e&&e.style&&(o.DomUtil.restoreOutline(),this._outlineElement=e,this._outlineStyle=e.style.outline,e.style.outline="none",o.DomEvent.on(t,"keydown",o.DomUtil.restoreOutline,this))},o.DomUtil.restoreOutline=function(){this._outlineElement&&(this._outlineElement.style.outline=this._outlineStyle,delete this._outlineElement,delete this._outlineStyle,o.DomEvent.off(t,"keydown",o.DomUtil.restoreOutline,this))}}(),o.LatLng=function(t,e,n){if(isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=+t,this.lng=+e,n!==i&&(this.alt=+n)},o.LatLng.prototype={equals:function(t,e){if(!t)return!1;t=o.latLng(t);var n=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return(e===i?1e-9:e)>=n},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){return o.CRS.Earth.distance(this,o.latLng(t))},wrap:function(){return o.CRS.Earth.wrapLatLng(this)},toBounds:function(t){var e=180*t/40075017,i=e/Math.cos(Math.PI/180*this.lat);return o.latLngBounds([this.lat-e,this.lng-i],[this.lat+e,this.lng+i])},clone:function(){return new o.LatLng(this.lat,this.lng,this.alt)}},o.latLng=function(t,e,n){return t instanceof o.LatLng?t:o.Util.isArray(t)&&"object"!=typeof t[0]?3===t.length?new o.LatLng(t[0],t[1],t[2]):2===t.length?new o.LatLng(t[0],t[1]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon,t.alt):e===i?null:new o.LatLng(t,e,n)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){var e,i,n=this._southWest,s=this._northEast;if(t instanceof o.LatLng)e=t,i=t;else{if(!(t instanceof o.LatLngBounds))return t?this.extend(o.latLng(t)||o.latLngBounds(t)):this;if(e=t._southWest,i=t._northEast,!e||!i)return this}return n||s?(n.lat=Math.min(e.lat,n.lat),n.lng=Math.min(e.lng,n.lng),s.lat=Math.max(i.lat,s.lat),s.lng=Math.max(i.lng,s.lng)):(this._southWest=new o.LatLng(e.lat,e.lng),this._northEast=new o.LatLng(i.lat,i.lng)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),r=s.lat>=e.lat&&n.lat<=i.lat,a=s.lng>=e.lng&&n.lng<=i.lng;return r&&a},overlaps:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),r=s.lat>e.lat&&n.lat<i.lat,a=s.lng>e.lng&&n.lng<i.lng;return r&&a},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)},bounds:o.bounds([-180,-90],[180,90])},o.Projection.SphericalMercator={R:6378137,MAX_LATITUDE:85.0511287798,project:function(t){var e=Math.PI/180,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=Math.sin(n*e);return new o.Point(this.R*t.lng*e,this.R*Math.log((1+s)/(1-s))/2)},unproject:function(t){var e=180/Math.PI;return new o.LatLng((2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*e,t.x*e/this.R)},bounds:function(){var t=6378137*Math.PI;return o.bounds([-t,-t],[t,t])}()},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},unproject:function(t){return this.projection.unproject(t)},scale:function(t){return 256*Math.pow(2,t)},zoom:function(t){return Math.log(t/256)/Math.LN2},getProjectedBounds:function(t){if(this.infinite)return null;var e=this.projection.bounds,i=this.scale(t),n=this.transformation.transform(e.min,i),s=this.transformation.transform(e.max,i);return o.bounds(n,s)},infinite:!1,wrapLatLng:function(t){var e=this.wrapLng?o.Util.wrapNum(t.lng,this.wrapLng,!0):t.lng,i=this.wrapLat?o.Util.wrapNum(t.lat,this.wrapLat,!0):t.lat,n=t.alt;return o.latLng(i,e,n)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)},zoom:function(t){return Math.log(t)/Math.LN2},distance:function(t,e){var i=e.lng-t.lng,n=e.lat-t.lat;return Math.sqrt(i*i+n*n)},infinite:!0}),o.CRS.Earth=o.extend({},o.CRS,{wrapLng:[-180,180],R:6371e3,distance:function(t,e){var i=Math.PI/180,n=t.lat*i,o=e.lat*i,s=Math.sin(n)*Math.sin(o)+Math.cos(n)*Math.cos(o)*Math.cos((e.lng-t.lng)*i);return this.R*Math.acos(Math.min(s,1))}}),o.CRS.EPSG3857=o.extend({},o.CRS.Earth,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:function(){var t=.5/(Math.PI*o.Projection.SphericalMercator.R);return new o.Transformation(t,.5,-t,.5)}()}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS.Earth,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/180,1,-1/180,.5)}),o.Map=o.Evented.extend({options:{crs:o.CRS.EPSG3857,center:i,zoom:i,minZoom:i,maxZoom:i,layers:[],maxBounds:i,renderer:i,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.zoom!==i&&(this._zoom=this._limitZoom(e.zoom)),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this.callInitHooks(),this._addLayers(this.options.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),e),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=t,this)},zoomIn:function(t,e){return t=t||(o.Browser.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom+t,e)},zoomOut:function(t,e){return t=t||(o.Browser.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom-t,e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),r=t instanceof o.Point?t:this.latLngToContainerPoint(t),a=r.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(a));return this.setView(h,e,{zoom:i})},_getBoundsCenterZoom:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n));s="number"==typeof e.maxZoom?Math.min(e.maxZoom,s):s;var r=n.subtract(i).divideBy(2),a=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(a.add(h).divideBy(2).add(r),s);return{center:l,zoom:s}},fitBounds:function(t,e){if(t=o.latLngBounds(t),!t.isValid())throw new Error("Bounds are not valid.");var i=this._getBoundsCenterZoom(t,e);return this.setView(i.center,i.zoom,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),t.isValid()?(this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this.options.maxBounds=t,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this.off("moveend",this._panInsideMaxBounds))},setMinZoom:function(t){return this.options.minZoom=t,this._loaded&&this.getZoom()<this.options.minZoom?this.setZoom(t):this},setMaxZoom:function(t){return this.options.maxZoom=t,this._loaded&&this.getZoom()>this.options.maxZoom?this.setZoom(t):this},panInsideBounds:function(t,e){this._enforcingBounds=!0;var i=this.getCenter(),n=this._limitCenter(i,this._zoom,o.latLngBounds(t));return i.equals(n)||this.panTo(n,e),this._enforcingBounds=!1,this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._lastCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),r=n.subtract(s);return r.x||r.y?(t.animate&&t.pan?this.panBy(r):(t.pan&&this._rawPanBy(r),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){if(this._initEvents(!0),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch(t){this._container._leaflet_id=i,this._containerId=i}o.DomUtil.remove(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this._loaded&&this.fire("unload");for(var e in this._layers)this._layers[e].remove();return this},createPane:function(t,e){var i="leaflet-pane"+(t?" leaflet-"+t.replace("Pane","")+"-pane":""),n=o.DomUtil.create("div",i,e||this._mapPane);return t&&(this._panes[t]=n),n},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t),i=o.point(i||[0,0]);var n=this.getZoom()||0,s=this.getMinZoom(),r=this.getMaxZoom(),a=t.getNorthWest(),h=t.getSouthEast(),l=this.getSize().subtract(i),u=this.project(h,n).subtract(this.project(a,n)),c=o.Browser.any3d?this.options.zoomSnap:1,d=Math.min(l.x/u.x,l.y/u.y);return n=this.getScaleZoom(d,n),c&&(n=Math.round(n/(c/100))*(c/100),n=e?Math.ceil(n/c)*c:Math.floor(n/c)*c),Math.max(s,Math.min(r,n))},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(t,e){var i=this._getTopLeftPoint(t,e);return new o.Bounds(i,i.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(t){return this.options.crs.getProjectedBounds(t===i?this.getZoom():t)},getPane:function(t){return"string"==typeof t?this._panes[t]:t},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t,e){var n=this.options.crs;return e=e===i?this._zoom:e,n.scale(t)/n.scale(e)},getScaleZoom:function(t,e){var n=this.options.crs;e=e===i?this._zoom:e;var o=n.zoom(t*n.scale(e));return isNaN(o)?1/0:o},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},wrapLatLng:function(t){return this.options.crs.wrapLatLng(o.latLng(t))},distance:function(t,e){return this.options.crs.distance(o.latLng(t),o.latLng(e))},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet_id)throw new Error("Map container is already initialized.");o.DomEvent.addListener(e,"scroll",this._onScroll,this),this._containerId=o.Util.stamp(e)},_initLayout:function(){var t=this._container;this._fadeAnimated=this.options.fadeAnimation&&o.Browser.any3d,o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(o.Browser.safari?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this.createPane("tilePane"),this.createPane("shadowPane"),this.createPane("overlayPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,"leaflet-zoom-hide"),o.DomUtil.addClass(t.shadowPane,"leaflet-zoom-hide"))},_resetView:function(t,e){o.DomUtil.setPosition(this._mapPane,new o.Point(0,0));var i=!this._loaded;this._loaded=!0,e=this._limitZoom(e),this.fire("viewprereset");var n=this._zoom!==e;this._moveStart(n)._move(t,e)._moveEnd(n),this.fire("viewreset"),i&&this.fire("load")},_moveStart:function(t){return t&&this.fire("zoomstart"),this.fire("movestart")},_move:function(t,e,n){e===i&&(e=this._zoom);var o=this._zoom!==e;return this._zoom=e,this._lastCenter=t,this._pixelOrigin=this._getNewPixelOrigin(t),(o||n&&n.pinch)&&this.fire("zoom",n),this.fire("move",n)},_moveEnd:function(t){return t&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return o.Util.cancelAnimFrame(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){this._targets={},this._targets[o.stamp(this._container)]=this;var i=e?"off":"on";o.DomEvent[i](this._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress",this._handleDOMEvent,this),this.options.trackResize&&o.DomEvent[i](t,"resize",this._onResize,this),o.Browser.any3d&&this.options.transform3DLimit&&this[i]("moveend",this._onMoveEnd)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var t=this._getMapPanePos();Math.max(Math.abs(t.x),Math.abs(t.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(t,e){for(var i,n=[],s="mouseout"===e||"mouseover"===e,r=t.target||t.srcElement,a=!1;r;){if(i=this._targets[o.stamp(r)],i&&("click"===e||"preclick"===e)&&!t._simulated&&this._draggableMoved(i)){a=!0;break}if(i&&i.listens(e,!0)){if(s&&!o.DomEvent._isExternalTarget(r,t))break;if(n.push(i),s)break}if(r===this._container)break;r=r.parentNode}return n.length||a||s||!o.DomEvent._isExternalTarget(r,t)||(n=[this]),n},_handleDOMEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e="keypress"===t.type&&13===t.keyCode?"click":t.type;"mousedown"===e&&o.DomUtil.preventOutline(t.target||t.srcElement),this._fireDOMEvent(t,e)}},_fireDOMEvent:function(t,e,i){if("click"===t.type){var n=o.Util.extend({},t);n.type="preclick",this._fireDOMEvent(n,n.type,i)}if(!t._stopped&&(i=(i||[]).concat(this._findEventTargets(t,e)),i.length)){var s=i[0];"contextmenu"===e&&s.listens(e,!0)&&o.DomEvent.preventDefault(t);var r={originalEvent:t};if("keypress"!==t.type){var a=s instanceof o.Marker;r.containerPoint=a?this.latLngToContainerPoint(s.getLatLng()):this.mouseEventToContainerPoint(t),r.layerPoint=this.containerPointToLayerPoint(r.containerPoint),r.latlng=a?s.getLatLng():this.layerPointToLatLng(r.layerPoint);
+}for(var h=0;h<i.length;h++)if(i[h].fire(e,r,!0),r.originalEvent._stopped||i[h].options.nonBubblingEvents&&-1!==o.Util.indexOf(i[h].options.nonBubblingEvents,e))return}},_draggableMoved:function(t){return t=t.dragging&&t.dragging.enabled()?t:this,t.dragging&&t.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,{target:this}):this.on("load",t,e),this},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)||new o.Point(0,0)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(t,e){var n=t&&e!==i?this._getNewPixelOrigin(t,e):this.getPixelOrigin();return n.subtract(this._getMapPanePos())},_getNewPixelOrigin:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewPixelOrigin(i,e);return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),r=new o.Bounds(n.subtract(s),n.add(s)),a=this._getBoundsOffset(r,i,e);return a.round().equals([0,0])?t:this.unproject(n.add(a),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=o.bounds(this.project(e.getNorthEast(),i),this.project(e.getSouthWest(),i)),s=n.min.subtract(t.min),r=n.max.subtract(t.max),a=this._rebound(s.x,-r.x),h=this._rebound(s.y,-r.y);return new o.Point(a,h)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom(),n=o.Browser.any3d?this.options.zoomSnap:1;return n&&(t=Math.round(t/n)*n),Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Layer=o.Evented.extend({options:{pane:"overlayPane",nonBubblingEvents:[]},addTo:function(t){return t.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(t){return t&&t.removeLayer(this),this},getPane:function(t){return this._map.getPane(t?this.options[t]||t:this.options.pane)},addInteractiveTarget:function(t){return this._map._targets[o.stamp(t)]=this,this},removeInteractiveTarget:function(t){return delete this._map._targets[o.stamp(t)],this},_layerAdd:function(t){var e=t.target;if(e.hasLayer(this)){if(this._map=e,this._zoomAnimated=e._zoomAnimated,this.getEvents){var i=this.getEvents();e.on(i,this),this.once("remove",function(){e.off(i,this)},this)}this.onAdd(e),this.getAttribution&&this._map.attributionControl&&this._map.attributionControl.addAttribution(this.getAttribution()),this.fire("add"),e.fire("layeradd",{layer:this})}}}),o.Map.include({addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,t._mapToAdd=this,t.beforeAdd&&t.beforeAdd(this),this.whenReady(t._layerAdd,t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),t.getAttribution&&this.attributionControl&&this.attributionControl.removeAttribution(t.getAttribution()),delete this._layers[e],this._loaded&&(this.fire("layerremove",{layer:t}),t.fire("remove")),t._map=t._mapToAdd=null,this):this},hasLayer:function(t){return!!t&&o.stamp(t)in this._layers},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_addZoomLimit:function(t){!isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[o.stamp(t)]=t,this._updateZoomLevels())},_removeZoomLimit:function(t){var e=o.stamp(t);this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels())},_updateZoomLevels:function(){var t=1/0,e=-(1/0),n=this._getZoomSpan();for(var o in this._zoomBoundLayers){var s=this._zoomBoundLayers[o].options;t=s.minZoom===i?t:Math.min(t,s.minZoom),e=s.maxZoom===i?e:Math.max(e,s.maxZoom)}this._layersMaxZoom=e===-(1/0)?i:e,this._layersMinZoom=t===1/0?i:t,n!==this._getZoomSpan()&&this.fire("zoomlevelschange")}}),o.Projection.Mercator={R:6378137,R_MINOR:6356752.314245179,bounds:o.bounds([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(t){var e=Math.PI/180,i=this.R,n=t.lat*e,s=this.R_MINOR/i,r=Math.sqrt(1-s*s),a=r*Math.sin(n),h=Math.tan(Math.PI/4-n/2)/Math.pow((1-a)/(1+a),r/2);return n=-i*Math.log(Math.max(h,1e-10)),new o.Point(t.lng*e*i,n)},unproject:function(t){for(var e,i=180/Math.PI,n=this.R,s=this.R_MINOR/n,r=Math.sqrt(1-s*s),a=Math.exp(-t.y/n),h=Math.PI/2-2*Math.atan(a),l=0,u=.1;15>l&&Math.abs(u)>1e-7;l++)e=r*Math.sin(h),e=Math.pow((1-e)/(1+e),r/2),u=Math.PI/2-2*Math.atan(a*e)-h,h+=u;return new o.LatLng(h*i,t.x*i/n)}},o.CRS.EPSG3395=o.extend({},o.CRS.Earth,{code:"EPSG:3395",projection:o.Projection.Mercator,transformation:function(){var t=.5/(Math.PI*o.Projection.Mercator.R);return new o.Transformation(t,.5,-t,.5)}()}),o.GridLayer=o.Layer.extend({options:{tileSize:256,opacity:1,updateWhenIdle:o.Browser.mobile,updateWhenZooming:!0,updateInterval:200,attribution:null,zIndex:1,bounds:null,minZoom:0,maxZoom:i,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(t){o.setOptions(this,t)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView(),this._update()},beforeAdd:function(t){t._addZoomLimit(this)},onRemove:function(t){this._removeAllTiles(),o.DomUtil.remove(this._container),t._removeZoomLimit(this),this._container=null,this._tileZoom=null},bringToFront:function(){return this._map&&(o.DomUtil.toFront(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(o.DomUtil.toBack(this._container),this._setAutoZIndex(Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){return this._map&&(this._removeAllTiles(),this._update()),this},getEvents:function(){var t={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=o.Util.throttle(this._onMoveEnd,this.options.updateInterval,this)),t.move=this._onMove),this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},createTile:function(){return e.createElement("div")},getTileSize:function(){var t=this.options.tileSize;return t instanceof o.Point?t:new o.Point(t,t)},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&null!==this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t){for(var e,i=this.getPane().children,n=-t(-(1/0),1/0),o=0,s=i.length;s>o;o++)e=i[o].style.zIndex,i[o]!==this._container&&e&&(n=t(n,+e));isFinite(n)&&(this.options.zIndex=n+t(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!o.Browser.ielt9){o.DomUtil.setOpacity(this._container,this.options.opacity);var t=+new Date,e=!1,i=!1;for(var n in this._tiles){var s=this._tiles[n];if(s.current&&s.loaded){var r=Math.min(1,(t-s.loaded)/200);o.DomUtil.setOpacity(s.el,r),1>r?e=!0:(s.active&&(i=!0),s.active=!0)}}i&&!this._noPrune&&this._pruneTiles(),e&&(o.Util.cancelAnimFrame(this._fadeFrame),this._fadeFrame=o.Util.requestAnimFrame(this._updateOpacity,this))}},_initContainer:function(){this._container||(this._container=o.DomUtil.create("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var t=this._tileZoom,e=this.options.maxZoom;if(t===i)return i;for(var n in this._levels)this._levels[n].el.children.length||n===t?this._levels[n].el.style.zIndex=e-Math.abs(t-n):(o.DomUtil.remove(this._levels[n].el),this._removeTilesAtZoom(n),delete this._levels[n]);var s=this._levels[t],r=this._map;return s||(s=this._levels[t]={},s.el=o.DomUtil.create("div","leaflet-tile-container leaflet-zoom-animated",this._container),s.el.style.zIndex=e,s.origin=r.project(r.unproject(r.getPixelOrigin()),t).round(),s.zoom=t,this._setZoomTransform(s,r.getCenter(),r.getZoom()),o.Util.falseFn(s.el.offsetWidth)),this._level=s,s},_pruneTiles:function(){if(this._map){var t,e,i=this._map.getZoom();if(i>this.options.maxZoom||i<this.options.minZoom)return void this._removeAllTiles();for(t in this._tiles)e=this._tiles[t],e.retain=e.current;for(t in this._tiles)if(e=this._tiles[t],e.current&&!e.active){var n=e.coords;this._retainParent(n.x,n.y,n.z,n.z-5)||this._retainChildren(n.x,n.y,n.z,n.z+2)}for(t in this._tiles)this._tiles[t].retain||this._removeTile(t)}},_removeTilesAtZoom:function(t){for(var e in this._tiles)this._tiles[e].coords.z===t&&this._removeTile(e)},_removeAllTiles:function(){for(var t in this._tiles)this._removeTile(t)},_invalidateAll:function(){for(var t in this._levels)o.DomUtil.remove(this._levels[t].el),delete this._levels[t];this._removeAllTiles(),this._tileZoom=null},_retainParent:function(t,e,i,n){var s=Math.floor(t/2),r=Math.floor(e/2),a=i-1,h=new o.Point(+s,+r);h.z=+a;var l=this._tileCoordsToKey(h),u=this._tiles[l];return u&&u.active?(u.retain=!0,!0):(u&&u.loaded&&(u.retain=!0),a>n?this._retainParent(s,r,a,n):!1)},_retainChildren:function(t,e,i,n){for(var s=2*t;2*t+2>s;s++)for(var r=2*e;2*e+2>r;r++){var a=new o.Point(s,r);a.z=i+1;var h=this._tileCoordsToKey(a),l=this._tiles[h];l&&l.active?l.retain=!0:(l&&l.loaded&&(l.retain=!0),n>i+1&&this._retainChildren(s,r,i+1,n))}},_resetView:function(t){var e=t&&(t.pinch||t.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),e,e)},_animateZoom:function(t){this._setView(t.center,t.zoom,!0,t.noUpdate)},_setView:function(t,e,n,o){var s=Math.round(e);(this.options.maxZoom!==i&&s>this.options.maxZoom||this.options.minZoom!==i&&s<this.options.minZoom)&&(s=i);var r=this.options.updateWhenZooming&&s!==this._tileZoom;o&&!r||(this._tileZoom=s,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),s!==i&&this._update(t),n||this._pruneTiles(),this._noPrune=!!n),this._setZoomTransforms(t,e)},_setZoomTransforms:function(t,e){for(var i in this._levels)this._setZoomTransform(this._levels[i],t,e)},_setZoomTransform:function(t,e,i){var n=this._map.getZoomScale(i,t.zoom),s=t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e,i)).round();o.Browser.any3d?o.DomUtil.setTransform(t.el,s,n):o.DomUtil.setPosition(t.el,s)},_resetGrid:function(){var t=this._map,e=t.options.crs,i=this._tileSize=this.getTileSize(),n=this._tileZoom,o=this._map.getPixelWorldBounds(this._tileZoom);o&&(this._globalTileRange=this._pxBoundsToTileRange(o)),this._wrapX=e.wrapLng&&!this.options.noWrap&&[Math.floor(t.project([0,e.wrapLng[0]],n).x/i.x),Math.ceil(t.project([0,e.wrapLng[1]],n).x/i.y)],this._wrapY=e.wrapLat&&!this.options.noWrap&&[Math.floor(t.project([e.wrapLat[0],0],n).y/i.x),Math.ceil(t.project([e.wrapLat[1],0],n).y/i.y)]},_onMoveEnd:function(){this._map&&!this._map._animatingZoom&&this._update()},_getTiledPixelBounds:function(t){var e=this._map,i=e._animatingZoom?Math.max(e._animateToZoom,e.getZoom()):e.getZoom(),n=e.getZoomScale(i,this._tileZoom),s=e.project(t,this._tileZoom).floor(),r=e.getSize().divideBy(2*n);return new o.Bounds(s.subtract(r),s.add(r))},_update:function(t){var n=this._map;if(n){var s=n.getZoom();if(t===i&&(t=n.getCenter()),this._tileZoom!==i){var r=this._getTiledPixelBounds(t),a=this._pxBoundsToTileRange(r),h=a.getCenter(),l=[],u=this.options.keepBuffer,c=new o.Bounds(a.getBottomLeft().subtract([u,-u]),a.getTopRight().add([u,-u]));for(var d in this._tiles){var _=this._tiles[d].coords;_.z===this._tileZoom&&c.contains(o.point(_.x,_.y))||(this._tiles[d].current=!1)}if(Math.abs(s-this._tileZoom)>1)return void this._setView(t,s);for(var m=a.min.y;m<=a.max.y;m++)for(var p=a.min.x;p<=a.max.x;p++){var f=new o.Point(p,m);if(f.z=this._tileZoom,this._isValidTile(f)){var g=this._tiles[this._tileCoordsToKey(f)];g?g.current=!0:l.push(f)}}if(l.sort(function(t,e){return t.distanceTo(h)-e.distanceTo(h)}),0!==l.length){this._loading||(this._loading=!0,this.fire("loading"));var v=e.createDocumentFragment();for(p=0;p<l.length;p++)this._addTile(l[p],v);this._level.el.appendChild(v)}}}},_isValidTile:function(t){var e=this._map.options.crs;if(!e.infinite){var i=this._globalTileRange;if(!e.wrapLng&&(t.x<i.min.x||t.x>i.max.x)||!e.wrapLat&&(t.y<i.min.y||t.y>i.max.y))return!1}if(!this.options.bounds)return!0;var n=this._tileCoordsToBounds(t);return o.latLngBounds(this.options.bounds).overlaps(n)},_keyToBounds:function(t){return this._tileCoordsToBounds(this._keyToTileCoords(t))},_tileCoordsToBounds:function(t){var e=this._map,i=this.getTileSize(),n=t.scaleBy(i),s=n.add(i),r=e.unproject(n,t.z),a=e.unproject(s,t.z);return this.options.noWrap||(r=e.wrapLatLng(r),a=e.wrapLatLng(a)),new o.LatLngBounds(r,a)},_tileCoordsToKey:function(t){return t.x+":"+t.y+":"+t.z},_keyToTileCoords:function(t){var e=t.split(":"),i=new o.Point(+e[0],+e[1]);return i.z=+e[2],i},_removeTile:function(t){var e=this._tiles[t];e&&(o.DomUtil.remove(e.el),delete this._tiles[t],this.fire("tileunload",{tile:e.el,coords:this._keyToTileCoords(t)}))},_initTile:function(t){o.DomUtil.addClass(t,"leaflet-tile");var e=this.getTileSize();t.style.width=e.x+"px",t.style.height=e.y+"px",t.onselectstart=o.Util.falseFn,t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity<1&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.android&&!o.Browser.android23&&(t.style.WebkitBackfaceVisibility="hidden")},_addTile:function(t,e){var i=this._getTilePos(t),n=this._tileCoordsToKey(t),s=this.createTile(this._wrapCoords(t),o.bind(this._tileReady,this,t));this._initTile(s),this.createTile.length<2&&o.Util.requestAnimFrame(o.bind(this._tileReady,this,t,null,s)),o.DomUtil.setPosition(s,i),this._tiles[n]={el:s,coords:t,current:!0},e.appendChild(s),this.fire("tileloadstart",{tile:s,coords:t})},_tileReady:function(t,e,i){if(this._map){e&&this.fire("tileerror",{error:e,tile:i,coords:t});var n=this._tileCoordsToKey(t);i=this._tiles[n],i&&(i.loaded=+new Date,this._map._fadeAnimated?(o.DomUtil.setOpacity(i.el,0),o.Util.cancelAnimFrame(this._fadeFrame),this._fadeFrame=o.Util.requestAnimFrame(this._updateOpacity,this)):(i.active=!0,this._pruneTiles()),e||(o.DomUtil.addClass(i.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:i.el,coords:t})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),o.Browser.ielt9||!this._map._fadeAnimated?o.Util.requestAnimFrame(this._pruneTiles,this):setTimeout(o.bind(this._pruneTiles,this),250)))}},_getTilePos:function(t){return t.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(t){var e=new o.Point(this._wrapX?o.Util.wrapNum(t.x,this._wrapX):t.x,this._wrapY?o.Util.wrapNum(t.y,this._wrapY):t.y);return e.z=t.z,e},_pxBoundsToTileRange:function(t){var e=this.getTileSize();return new o.Bounds(t.min.unscaleBy(e).floor(),t.max.unscaleBy(e).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var t in this._tiles)if(!this._tiles[t].loaded)return!1;return!0}}),o.gridLayer=function(t){return new o.GridLayer(t)},o.TileLayer=o.GridLayer.extend({options:{minZoom:0,maxZoom:18,maxNativeZoom:null,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1},initialize:function(t,e){this._url=t,e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomReverse?(e.zoomOffset--,e.minZoom++):(e.zoomOffset++,e.maxZoom--),e.minZoom=Math.max(0,e.minZoom)),"string"==typeof e.subdomains&&(e.subdomains=e.subdomains.split("")),o.Browser.android||this.on("tileunload",this._onTileRemove)},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},createTile:function(t,i){var n=e.createElement("img");return o.DomEvent.on(n,"load",o.bind(this._tileOnLoad,this,i,n)),o.DomEvent.on(n,"error",o.bind(this._tileOnError,this,i,n)),this.options.crossOrigin&&(n.crossOrigin=""),n.alt="",n.src=this.getTileUrl(t),n},getTileUrl:function(t){var e={r:o.Browser.retina?"@2x":"",s:this._getSubdomain(t),x:t.x,y:t.y,z:this._getZoomForUrl()};if(this._map&&!this._map.options.crs.infinite){var i=this._globalTileRange.max.y-t.y;this.options.tms&&(e.y=i),e["-y"]=i}return o.Util.template(this._url,o.extend(e,this.options))},_tileOnLoad:function(t,e){o.Browser.ielt9?setTimeout(o.bind(t,this,null,e),0):t(null,e)},_tileOnError:function(t,e,i){var n=this.options.errorTileUrl;n&&(e.src=n),t(i,e)},getTileSize:function(){var t=this._map,e=o.GridLayer.prototype.getTileSize.call(this),i=this._tileZoom+this.options.zoomOffset,n=this.options.maxNativeZoom;return null!==n&&i>n?e.divideBy(t.getZoomScale(n,i)).round():e},_onTileRemove:function(t){t.tile.onload=null},_getZoomForUrl:function(){var t=this.options,e=this._tileZoom;return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,null!==t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_abortLoading:function(){var t,e;for(t in this._tiles)this._tiles[t].coords.z!==this._tileZoom&&(e=this._tiles[t].el,e.onload=o.Util.falseFn,e.onerror=o.Util.falseFn,e.complete||(e.src=o.Util.emptyImageUrl,o.DomUtil.remove(e)))}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams);for(var n in e)n in this.options||(i[n]=e[n]);e=o.setOptions(this,e),i.width=i.height=e.tileSize*(e.detectRetina&&o.Browser.retina?2:1),this.wmsParams=i},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._tileCoordsToBounds(t),i=this._crs.project(e.getNorthWest()),n=this._crs.project(e.getSouthEast()),s=(this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[n.y,i.x,i.y,n.x]:[i.x,n.y,n.x,i.y]).join(","),r=o.TileLayer.prototype.getTileUrl.call(this,t);return r+o.Util.getParamString(this.wmsParams,r,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+s},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.ImageOverlay=o.Layer.extend({options:{opacity:1,alt:"",interactive:!1,attribution:null,crossOrigin:!1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(o.DomUtil.addClass(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){o.DomUtil.remove(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(t){return this.options.opacity=t,this._image&&this._updateOpacity(),this},setStyle:function(t){return t.opacity&&this.setOpacity(t.opacity),this},bringToFront:function(){return this._map&&o.DomUtil.toFront(this._image),this},bringToBack:function(){return this._map&&o.DomUtil.toBack(this._image),this},setUrl:function(t){return this._url=t,this._image&&(this._image.src=t),this},setBounds:function(t){return this._bounds=t,this._map&&this._reset(),this},getAttribution:function(){return this.options.attribution},getEvents:function(){var t={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var t=this._image=o.DomUtil.create("img","leaflet-image-layer "+(this._zoomAnimated?"leaflet-zoom-animated":""));t.onselectstart=o.Util.falseFn,t.onmousemove=o.Util.falseFn,t.onload=o.bind(this.fire,this,"load"),this.options.crossOrigin&&(t.crossOrigin=""),t.src=this._url,t.alt=this.options.alt},_animateZoom:function(t){var e=this._map.getZoomScale(t.zoom),i=this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(),t.zoom,t.center);o.DomUtil.setTransform(this._image,i,e)},_reset:function(){var t=this._image,e=new o.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),i=e.getSize();o.DomUtil.setPosition(t,e.min),t.style.width=i.x+"px",t.style.height=i.y+"px"},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n=this._createImg(i,e&&"IMG"===e.tagName?e:null);return this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i=this.options,n=i[e+"Size"];"number"==typeof n&&(n=[n,n]);var s=o.point(n),r=o.point("shadow"===e&&i.shadowAnchor||i.iconAnchor||s&&s.divideBy(2,!0));t.className="leaflet-marker-"+e+" "+(i.className||""),r&&(t.style.marginLeft=-r.x+"px",t.style.marginTop=-r.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]||this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(t){return o.Icon.Default.imagePath||(o.Icon.Default.imagePath=this._detectIconPath()),(this.options.imagePath||o.Icon.Default.imagePath)+o.Icon.prototype._getIconUrl.call(this,t)},_detectIconPath:function(){var t=o.DomUtil.create("div","leaflet-default-icon-path",e.body),i=o.DomUtil.getStyle(t,"background-image")||o.DomUtil.getStyle(t,"backgroundImage");return e.body.removeChild(t),0===i.indexOf("url")?i.replace(/^url\([\"\']?/,"").replace(/marker-icon\.png[\"\']?\)$/,""):""}}),o.Marker=o.Layer.extend({options:{icon:new o.Icon.Default,interactive:!0,draggable:!1,keyboard:!0,title:"",alt:"",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",nonBubblingEvents:["click","dblclick","mouseover","mouseout","contextmenu"]},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._zoomAnimated=this._zoomAnimated&&t.options.markerZoomAnimation,this._zoomAnimated&&t.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(t){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),this._zoomAnimated&&t.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(t){var e=this._latlng;return this._latlng=o.latLng(t),this.update(),this.fire("move",{oldLatLng:e,latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update()},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){if(this._icon){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,e="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),i=t.icon.createIcon(this._icon),n=!1;i!==this._icon&&(this._icon&&this._removeIcon(),n=!0,t.title&&(i.title=t.title),t.alt&&(i.alt=t.alt)),o.DomUtil.addClass(i,e),t.keyboard&&(i.tabIndex="0"),this._icon=i,t.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex});var s=t.icon.createShadow(this._shadow),r=!1;s!==this._shadow&&(this._removeShadow(),r=!0),s&&o.DomUtil.addClass(s,e),this._shadow=s,t.opacity<1&&this._updateOpacity(),n&&this.getPane().appendChild(this._icon),this._initInteraction(),s&&r&&this.getPane("shadowPane").appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),o.DomUtil.remove(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&o.DomUtil.remove(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.interactive&&(o.DomUtil.addClass(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),o.Handler.MarkerDrag)){var t=this.options.draggable;this.dragging&&(t=this.dragging.enabled(),this.dragging.disable()),this.dragging=new o.Handler.MarkerDrag(this),t&&this.dragging.enable()}},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var t=this.options.opacity;o.DomUtil.setOpacity(this._icon,t),this._shadow&&o.DomUtil.setOpacity(this._shadow,t)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;if(i.innerHTML=n.html!==!1?n.html:"",n.bgPos){var s=o.point(n.bgPos);i.style.backgroundPosition=-s.x+"px "+-s.y+"px"}return this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.DivOverlay=o.Layer.extend({options:{offset:[0,7],className:"",pane:"popupPane"},initialize:function(t,e){o.setOptions(this,t),this._source=e},onAdd:function(t){this._zoomAnimated=t._zoomAnimated,this._container||this._initLayout(),t._fadeAnimated&&o.DomUtil.setOpacity(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),t._fadeAnimated&&o.DomUtil.setOpacity(this._container,1),this.bringToFront()},onRemove:function(t){t._fadeAnimated?(o.DomUtil.setOpacity(this._container,0),this._removeTimeout=setTimeout(o.bind(o.DomUtil.remove,o.DomUtil,this._container),200)):o.DomUtil.remove(this._container)},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var t={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&o.DomUtil.toFront(this._container),this},bringToBack:function(){return this._map&&o.DomUtil.toBack(this._container),this},_updateContent:function(){if(this._content){var t=this._contentNode,e="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof e)t.innerHTML=e;else{for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(e)}this.fire("contentupdate")}},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=o.point(this.options.offset),i=this._getAnchor();this._zoomAnimated?o.DomUtil.setPosition(this._container,t.add(i)):e=e.add(t).add(i);var n=this._containerBottom=-e.y,s=this._containerLeft=-Math.round(this._containerWidth/2)+e.x;this._container.style.bottom=n+"px",this._container.style.left=s+"px"}},_getAnchor:function(){return[0,0]}}),o.Popup=o.DivOverlay.extend({options:{maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,className:""},openOn:function(t){return t.openPopup(this),this},onAdd:function(t){o.DivOverlay.prototype.onAdd.call(this,t),t.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof o.Path||this._source.on("preclick",o.DomEvent.stopPropagation))},onRemove:function(t){o.DivOverlay.prototype.onRemove.call(this,t),t.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof o.Path||this._source.off("preclick",o.DomEvent.stopPropagation))},getEvents:function(){var t=o.DivOverlay.prototype.getEvents.call(this);return("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t="leaflet-popup",e=this._container=o.DomUtil.create("div",t+" "+(this.options.className||"")+" leaflet-zoom-animated");if(this.options.closeButton){var i=this._closeButton=o.DomUtil.create("a",t+"-close-button",e);i.href="#close",i.innerHTML="&#215;",o.DomEvent.on(i,"click",this._onCloseButtonClick,this)}var n=this._wrapper=o.DomUtil.create("div",t+"-content-wrapper",e);this._contentNode=o.DomUtil.create("div",t+"-content",n),o.DomEvent.disableClickPropagation(n).disableScrollPropagation(this._contentNode).on(n,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",t+"-tip-container",e),this._tip=o.DomUtil.create("div",t+"-tip",this._tipContainer)},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,r="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,r)):o.DomUtil.removeClass(t,r),this._containerWidth=this._container.offsetWidth},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center),i=this._getAnchor();o.DomUtil.setPosition(this._container,e.add(i))},_adjustPan:function(){if(!(!this.options.autoPan||this._map._panAnim&&this._map._panAnim._inProgress)){var t=this._map,e=parseInt(o.DomUtil.getStyle(this._container,"marginBottom"),10)||0,i=this._container.offsetHeight+e,n=this._containerWidth,s=new o.Point(this._containerLeft,-i-this._containerBottom);s._add(o.DomUtil.getPosition(this._container));var r=t.layerPointToContainerPoint(s),a=o.point(this.options.autoPanPadding),h=o.point(this.options.autoPanPaddingTopLeft||a),l=o.point(this.options.autoPanPaddingBottomRight||a),u=t.getSize(),c=0,d=0;
+r.x+n+l.x>u.x&&(c=r.x+n-u.x+l.x),r.x-c-h.x<0&&(c=r.x-h.x),r.y+i+l.y>u.y&&(d=r.y+i-u.y+l.y),r.y-d-h.y<0&&(d=r.y-h.y),(c||d)&&t.fire("autopanstart").panBy([c,d])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)},_getAnchor:function(){return o.point(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Map.include({openPopup:function(t,e,i){return t instanceof o.Popup||(t=new o.Popup(i).setContent(t)),e&&t.setLatLng(e),this.hasLayer(t)?this:(this._popup&&this._popup.options.autoClose&&this.closePopup(),this._popup=t,this.addLayer(t))},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&this.removeLayer(t),this}}),o.Layer.include({bindPopup:function(t,e){return t instanceof o.Popup?(o.setOptions(t,e),this._popup=t,t._source=this):(this._popup&&!e||(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on({click:this._openPopup,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(t,e){if(t instanceof o.Layer||(e=t,t=this),t instanceof o.FeatureGroup)for(var i in this._layers){t=this._layers[i];break}return e||(e=t.getCenter?t.getCenter():t.getLatLng()),this._popup&&this._map&&(this._popup._source=t,this._popup.update(),this._map.openPopup(this._popup,e)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(t){return this._popup&&(this._popup._map?this.closePopup():this.openPopup(t)),this},isPopupOpen:function(){return this._popup.isOpen()},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},getPopup:function(){return this._popup},_openPopup:function(t){var e=t.layer||t.target;if(this._popup&&this._map)return o.DomEvent.stop(t),e instanceof o.Path?void this.openPopup(t.layer||t.target,t.latlng):void(this._map.hasLayer(this._popup)&&this._popup._source===e?this.closePopup():this.openPopup(e,t.latlng))},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.Marker.include({_getPopupAnchor:function(){return this.options.icon.options.popupAnchor||[0,0]}}),o.Tooltip=o.DivOverlay.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,interactive:!1,opacity:.9},onAdd:function(t){o.DivOverlay.prototype.onAdd.call(this,t),this.setOpacity(this.options.opacity),t.fire("tooltipopen",{tooltip:this}),this._source&&this._source.fire("tooltipopen",{tooltip:this},!0)},onRemove:function(t){o.DivOverlay.prototype.onRemove.call(this,t),t.fire("tooltipclose",{tooltip:this}),this._source&&this._source.fire("tooltipclose",{tooltip:this},!0)},getEvents:function(){var t=o.DivOverlay.prototype.getEvents.call(this);return o.Browser.touch&&!this.options.permanent&&(t.preclick=this._close),t},_close:function(){this._map&&this._map.closeTooltip(this)},_initLayout:function(){var t="leaflet-tooltip",e=t+" "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide");this._contentNode=this._container=o.DomUtil.create("div",e)},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(t){var e=this._map,i=this._container,n=e.latLngToContainerPoint(e.getCenter()),s=e.layerPointToContainerPoint(t),r=this.options.direction,a=i.offsetWidth,h=i.offsetHeight,l=o.point(this.options.offset),u=this._getAnchor();"top"===r?t=t.add(o.point(-a/2+l.x,-h+l.y+u.y)):"bottom"===r?t=t.subtract(o.point(a/2-l.x,-l.y)):"center"===r?t=t.subtract(o.point(a/2+l.x,h/2-u.y+l.y)):"right"===r||"auto"===r&&s.x<n.x?(r="right",t=t.add([l.x+u.x,u.y-h/2+l.y])):(r="left",t=t.subtract(o.point(a+u.x-l.x,h/2-u.y-l.y))),o.DomUtil.removeClass(i,"leaflet-tooltip-right"),o.DomUtil.removeClass(i,"leaflet-tooltip-left"),o.DomUtil.removeClass(i,"leaflet-tooltip-top"),o.DomUtil.removeClass(i,"leaflet-tooltip-bottom"),o.DomUtil.addClass(i,"leaflet-tooltip-"+r),o.DomUtil.setPosition(i,t)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},setOpacity:function(t){this.options.opacity=t,this._container&&o.DomUtil.setOpacity(this._container,t)},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPosition(e)},_getAnchor:function(){return o.point(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}}),o.tooltip=function(t,e){return new o.Tooltip(t,e)},o.Map.include({openTooltip:function(t,e,i){return t instanceof o.Tooltip||(t=new o.Tooltip(i).setContent(t)),e&&t.setLatLng(e),this.hasLayer(t)?this:this.addLayer(t)},closeTooltip:function(t){return t&&this.removeLayer(t),this}}),o.Layer.include({bindTooltip:function(t,e){return t instanceof o.Tooltip?(o.setOptions(t,e),this._tooltip=t,t._source=this):(this._tooltip&&!e||(this._tooltip=o.tooltip(e,this)),this._tooltip.setContent(t)),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(t){if(t||!this._tooltipHandlersAdded){var e=t?"off":"on",i={remove:this.closeTooltip,move:this._moveTooltip};this._tooltip.options.permanent?i.add=this._openTooltip:(i.mouseover=this._openTooltip,i.mouseout=this.closeTooltip,this._tooltip.options.sticky&&(i.mousemove=this._moveTooltip),o.Browser.touch&&(i.click=this._openTooltip)),this[e](i),this._tooltipHandlersAdded=!t}},openTooltip:function(t,e){if(t instanceof o.Layer||(e=t,t=this),t instanceof o.FeatureGroup)for(var i in this._layers){t=this._layers[i];break}return e||(e=t.getCenter?t.getCenter():t.getLatLng()),this._tooltip&&this._map&&(this._tooltip._source=t,this._tooltip.update(),this._map.openTooltip(this._tooltip,e),this._tooltip.options.interactive&&this._tooltip._container&&(o.DomUtil.addClass(this._tooltip._container,"leaflet-clickable"),this.addInteractiveTarget(this._tooltip._container))),this},closeTooltip:function(){return this._tooltip&&(this._tooltip._close(),this._tooltip.options.interactive&&this._tooltip._container&&(o.DomUtil.removeClass(this._tooltip._container,"leaflet-clickable"),this.removeInteractiveTarget(this._tooltip._container))),this},toggleTooltip:function(t){return this._tooltip&&(this._tooltip._map?this.closeTooltip():this.openTooltip(t)),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(t){return this._tooltip&&this._tooltip.setContent(t),this},getTooltip:function(){return this._tooltip},_openTooltip:function(t){var e=t.layer||t.target;this._tooltip&&this._map&&this.openTooltip(e,this._tooltip.options.sticky?t.latlng:i)},_moveTooltip:function(t){var e,i,n=t.latlng;this._tooltip.options.sticky&&t.originalEvent&&(e=this._map.mouseEventToContainerPoint(t.originalEvent),i=this._map.containerPointToLayerPoint(e),n=this._map.layerPointToLatLng(i)),this._tooltip.setLatLng(n)}}),o.Marker.include({_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor||[0,0]}}),o.LayerGroup=o.Layer.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return!!t&&(t in this._layers||this.getLayerId(t)in this._layers)},clearLayers:function(){for(var t in this._layers)this.removeLayer(this._layers[t]);return this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){for(var e in this._layers)t.addLayer(this._layers[e])},onRemove:function(t){for(var e in this._layers)t.removeLayer(this._layers[e])},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({addLayer:function(t){return this.hasLayer(t)?this:(t.addEventParent(this),o.LayerGroup.prototype.addLayer.call(this,t),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.removeEventParent(this),o.LayerGroup.prototype.removeLayer.call(this,t),this.fire("layerremove",{layer:t})):this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;for(var e in this._layers){var i=this._layers[e];t.extend(i.getBounds?i.getBounds():i.getLatLng())}return t}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Renderer=o.Layer.extend({options:{padding:.1},initialize:function(t){o.setOptions(this,t),o.stamp(this)},onAdd:function(){this._container||(this._initContainer(),this._zoomAnimated&&o.DomUtil.addClass(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update()},onRemove:function(){o.DomUtil.remove(this._container)},getEvents:function(){var t={viewreset:this._reset,zoom:this._onZoom,moveend:this._update};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t},_onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(t,e){var i=this._map.getZoomScale(e,this._zoom),n=o.DomUtil.getPosition(this._container),s=this._map.getSize().multiplyBy(.5+this.options.padding),r=this._map.project(this._center,e),a=this._map.project(t,e),h=a.subtract(r),l=s.multiplyBy(-i).add(n).add(s).subtract(h);o.Browser.any3d?o.DomUtil.setTransform(this._container,l,i):o.DomUtil.setPosition(this._container,l)},_reset:function(){this._update(),this._updateTransform(this._center,this._zoom)},_update:function(){var t=this.options.padding,e=this._map.getSize(),i=this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();this._bounds=new o.Bounds(i,i.add(e.multiplyBy(1+2*t)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),o.Map.include({getRenderer:function(t){var e=t.options.renderer||this._getPaneRenderer(t.options.pane)||this.options.renderer||this._renderer;return e||(e=this._renderer=this.options.preferCanvas&&o.canvas()||o.svg()),this.hasLayer(e)||this.addLayer(e),e},_getPaneRenderer:function(t){if("overlayPane"===t||t===i)return!1;var e=this._paneRenderers[t];return e===i&&(e=o.SVG&&o.svg({pane:t})||o.Canvas&&o.canvas({pane:t}),this._paneRenderers[t]=e),e}}),o.Path=o.Layer.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0},beforeAdd:function(t){this._renderer=t.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this),this._renderer.on("update",this._update,this)},onRemove:function(){this._renderer._removePath(this),this._renderer.off("update",this._update,this)},getEvents:function(){return{zoomend:this._project,viewreset:this._reset}},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(t){return o.setOptions(this,t),this._renderer&&this._renderer._updateStyle(this),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+(o.Browser.touch?10:0)}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var r,a=[];for(r=0;n>r;r++)s[r]&&a.push(t[r]);return a},_simplifyDPStep:function(t,e,i,n,o){var s,r,a,h=0;for(r=n+1;o-1>=r;r++)a=this._sqClosestPointOnSegment(t[r],t[n],t[o],!0),a>h&&(s=r,h=a);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n,o){var s,r,a,h=n?this._lastCode:this._getBitCode(t,i),l=this._getBitCode(e,i);for(this._lastCode=l;;){if(!(h|l))return[t,e];if(h&l)return!1;s=h||l,r=this._getEdgeIntersection(t,e,s,i,o),a=this._getBitCode(r,i),s===h?(t=r,h=a):(e=r,l=a)}},_getEdgeIntersection:function(t,e,i,n,s){var r,a,h=e.x-t.x,l=e.y-t.y,u=n.min,c=n.max;return 8&i?(r=t.x+h*(c.y-t.y)/l,a=c.y):4&i?(r=t.x+h*(u.y-t.y)/l,a=u.y):2&i?(r=c.x,a=t.y+l*(c.x-t.x)/h):1&i&&(r=u.x,a=t.y+l*(u.x-t.x)/h),new o.Point(r,a,s)},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,r=e.x,a=e.y,h=i.x-r,l=i.y-a,u=h*h+l*l;return u>0&&(s=((t.x-r)*h+(t.y-a)*l)/u,s>1?(r=i.x,a=i.y):s>0&&(r+=h*s,a+=l*s)),h=t.x-r,l=t.y-a,n?h*h+l*l:new o.Point(r,a)}},o.Polyline=o.Path.extend({options:{smoothFactor:1,noClip:!1},initialize:function(t,e){o.setOptions(this,e),this._setLatLngs(t)},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(t){for(var e,i,n=1/0,s=null,r=o.LineUtil._sqClosestPointOnSegment,a=0,h=this._parts.length;h>a;a++)for(var l=this._parts[a],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=r(t,e,i,!0);n>d&&(n=d,s=r(t,e,i))}return s&&(s.distance=Math.sqrt(n)),s},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,e,i,n,o,s,r,a=this._rings[0],h=a.length;if(!h)return null;for(t=0,e=0;h-1>t;t++)e+=a[t].distanceTo(a[t+1])/2;if(0===e)return this._map.layerPointToLatLng(a[0]);for(t=0,n=0;h-1>t;t++)if(o=a[t],s=a[t+1],i=o.distanceTo(s),n+=i,n>e)return r=(n-e)/i,this._map.layerPointToLatLng([s.x-r*(s.x-o.x),s.y-r*(s.y-o.y)])},getBounds:function(){return this._bounds},addLatLng:function(t,e){return e=e||this._defaultShape(),t=o.latLng(t),e.push(t),this._bounds.extend(t),this.redraw()},_setLatLngs:function(t){this._bounds=new o.LatLngBounds,this._latlngs=this._convertLatLngs(t)},_defaultShape:function(){return o.Polyline._flat(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(t){for(var e=[],i=o.Polyline._flat(t),n=0,s=t.length;s>n;n++)i?(e[n]=o.latLng(t[n]),this._bounds.extend(e[n])):e[n]=this._convertLatLngs(t[n]);return e},_project:function(){var t=new o.Bounds;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,t);var e=this._clickTolerance(),i=new o.Point(e,e);this._bounds.isValid()&&t.isValid()&&(t.min._subtract(i),t.max._add(i),this._pxBounds=t)},_projectLatlngs:function(t,e,i){var n,s,r=t[0]instanceof o.LatLng,a=t.length;if(r){for(s=[],n=0;a>n;n++)s[n]=this._map.latLngToLayerPoint(t[n]),i.extend(s[n]);e.push(s)}else for(n=0;a>n;n++)this._projectLatlngs(t[n],e,i)},_clipPoints:function(){var t=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t)){if(this.options.noClip)return void(this._parts=this._rings);var e,i,n,s,r,a,h,l=this._parts;for(e=0,n=0,s=this._rings.length;s>e;e++)for(h=this._rings[e],i=0,r=h.length;r-1>i;i++)a=o.LineUtil.clipSegment(h[i],h[i+1],t,i,!0),a&&(l[n]=l[n]||[],l[n].push(a[0]),a[1]===h[i+1]&&i!==r-2||(l[n].push(a[1]),n++))}},_simplifyPoints:function(){for(var t=this._parts,e=this.options.smoothFactor,i=0,n=t.length;n>i;i++)t[i]=o.LineUtil.simplify(t[i],e)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.Polyline._flat=function(t){return!o.Util.isArray(t[0])||"object"!=typeof t[0][0]&&"undefined"!=typeof t[0][0]},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e,i){var n,s,r,a,h,l,u,c,d,_=[1,4,2,8],m=o.LineUtil;for(s=0,u=t.length;u>s;s++)t[s]._code=m._getBitCode(t[s],e);for(a=0;4>a;a++){for(c=_[a],n=[],s=0,u=t.length,r=u-1;u>s;r=s++)h=t[s],l=t[r],h._code&c?l._code&c||(d=m._getEdgeIntersection(l,h,c,e,i),d._code=m._getBitCode(d,e),n.push(d)):(l._code&c&&(d=m._getEdgeIntersection(l,h,c,e,i),d._code=m._getBitCode(d,e),n.push(d)),n.push(h));t=n}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,e,i,n,o,s,r,a,h,l=this._rings[0],u=l.length;if(!u)return null;for(s=r=a=0,t=0,e=u-1;u>t;e=t++)i=l[t],n=l[e],o=i.y*n.x-n.y*i.x,r+=(i.x+n.x)*o,a+=(i.y+n.y)*o,s+=3*o;return h=0===s?l[0]:[r/s,a/s],this._map.layerPointToLatLng(h)},_convertLatLngs:function(t){var e=o.Polyline.prototype._convertLatLngs.call(this,t),i=e.length;return i>=2&&e[0]instanceof o.LatLng&&e[0].equals(e[i-1])&&e.pop(),e},_setLatLngs:function(t){o.Polyline.prototype._setLatLngs.call(this,t),o.Polyline._flat(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return o.Polyline._flat(this._latlngs[0])?this._latlngs[0]:this._latlngs[0][0]},_clipPoints:function(){var t=this._renderer._bounds,e=this.options.weight,i=new o.Point(e,e);if(t=new o.Bounds(t.min.subtract(i),t.max.add(i)),this._parts=[],this._pxBounds&&this._pxBounds.intersects(t)){if(this.options.noClip)return void(this._parts=this._rings);for(var n,s=0,r=this._rings.length;r>s;s++)n=o.PolyUtil.clipPolygon(this._rings[s],t,!0),n.length&&this._parts.push(n)}},_updatePath:function(){this._renderer._updatePoly(this,!0)}}),o.polygon=function(t,e){return new o.Polygon(t,e)},o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){return this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.CircleMarker=o.Path.extend({options:{fill:!0,radius:10},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t),this._radius=this.options.radius},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw(),this.fire("move",{latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius},setStyle:function(t){var e=t&&t.radius||this._radius;return o.Path.prototype.setStyle.call(this,t),this.setRadius(e),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var t=this._radius,e=this._radiusY||t,i=this._clickTolerance(),n=[t+i,e+i];this._pxBounds=new o.Bounds(this._point.subtract(n),this._point.add(n))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Circle=o.CircleMarker.extend({initialize:function(t,e,i){if("number"==typeof e&&(e=o.extend({},i,{radius:e})),o.setOptions(this,e),this._latlng=o.latLng(t),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(t){return this._mRadius=t,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var t=[this._radius,this._radiusY||this._radius];return new o.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))},setStyle:o.Path.prototype.setStyle,_project:function(){var t=this._latlng.lng,e=this._latlng.lat,i=this._map,n=i.options.crs;if(n.distance===o.CRS.Earth.distance){var s=Math.PI/180,r=this._mRadius/o.CRS.Earth.R/s,a=i.project([e+r,t]),h=i.project([e-r,t]),l=a.add(h).divideBy(2),u=i.unproject(l).lat,c=Math.acos((Math.cos(r*s)-Math.sin(e*s)*Math.sin(u*s))/(Math.cos(e*s)*Math.cos(u*s)))/s;(isNaN(c)||0===c)&&(c=r/Math.cos(Math.PI/180*e)),this._point=l.subtract(i.getPixelOrigin()),this._radius=isNaN(c)?0:Math.max(Math.round(l.x-i.project([u,t-c]).x),1),this._radiusY=Math.max(Math.round(l.y-a.y),1)}else{var d=n.unproject(n.project(this._latlng).subtract([this._mRadius,0]));this._point=i.latLngToLayerPoint(this._latlng),this._radius=this._point.x-i.latLngToLayerPoint(d).x}this._updateBounds()}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.SVG=o.Renderer.extend({getEvents:function(){var t=o.Renderer.prototype.getEvents.call(this);return t.zoomstart=this._onZoomStart,t},_initContainer:function(){this._container=o.SVG.create("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=o.SVG.create("g"),this._container.appendChild(this._rootGroup)},_onZoomStart:function(){this._update()},_update:function(){if(!this._map._animatingZoom||!this._bounds){o.Renderer.prototype._update.call(this);var t=this._bounds,e=t.getSize(),i=this._container;this._svgSize&&this._svgSize.equals(e)||(this._svgSize=e,i.setAttribute("width",e.x),i.setAttribute("height",e.y)),o.DomUtil.setPosition(i,t.min),i.setAttribute("viewBox",[t.min.x,t.min.y,e.x,e.y].join(" ")),this.fire("update")}},_initPath:function(t){var e=t._path=o.SVG.create("path");t.options.className&&o.DomUtil.addClass(e,t.options.className),t.options.interactive&&o.DomUtil.addClass(e,"leaflet-interactive"),this._updateStyle(t)},_addPath:function(t){this._rootGroup.appendChild(t._path),t.addInteractiveTarget(t._path)},_removePath:function(t){o.DomUtil.remove(t._path),t.removeInteractiveTarget(t._path)},_updatePath:function(t){t._project(),t._update()},_updateStyle:function(t){var e=t._path,i=t.options;e&&(i.stroke?(e.setAttribute("stroke",i.color),e.setAttribute("stroke-opacity",i.opacity),e.setAttribute("stroke-width",i.weight),e.setAttribute("stroke-linecap",i.lineCap),e.setAttribute("stroke-linejoin",i.lineJoin),i.dashArray?e.setAttribute("stroke-dasharray",i.dashArray):e.removeAttribute("stroke-dasharray"),i.dashOffset?e.setAttribute("stroke-dashoffset",i.dashOffset):e.removeAttribute("stroke-dashoffset")):e.setAttribute("stroke","none"),i.fill?(e.setAttribute("fill",i.fillColor||i.color),e.setAttribute("fill-opacity",i.fillOpacity),e.setAttribute("fill-rule",i.fillRule||"evenodd")):e.setAttribute("fill","none"))},_updatePoly:function(t,e){this._setPath(t,o.SVG.pointsToPath(t._parts,e))},_updateCircle:function(t){var e=t._point,i=t._radius,n=t._radiusY||i,o="a"+i+","+n+" 0 1,0 ",s=t._empty()?"M0 0":"M"+(e.x-i)+","+e.y+o+2*i+",0 "+o+2*-i+",0 ";this._setPath(t,s)},_setPath:function(t,e){t._path.setAttribute("d",e)},_bringToFront:function(t){o.DomUtil.toFront(t._path)},_bringToBack:function(t){o.DomUtil.toBack(t._path)}}),o.extend(o.SVG,{create:function(t){return e.createElementNS("http://www.w3.org/2000/svg",t)},pointsToPath:function(t,e){var i,n,s,r,a,h,l="";for(i=0,s=t.length;s>i;i++){for(a=t[i],n=0,r=a.length;r>n;n++)h=a[n],l+=(n?"L":"M")+h.x+" "+h.y;l+=e?o.Browser.svg?"z":"x":""}return l||"M0 0"}}),o.Browser.svg=!(!e.createElementNS||!o.SVG.create("svg").createSVGRect),o.svg=function(t){return o.Browser.svg||o.Browser.vml?new o.SVG(t):null},o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.SVG.include(o.Browser.vml?{_initContainer:function(){this._container=o.DomUtil.create("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(o.Renderer.prototype._update.call(this),this.fire("update"))},_initPath:function(t){var e=t._container=o.SVG.create("shape");o.DomUtil.addClass(e,"leaflet-vml-shape "+(this.options.className||"")),e.coordsize="1 1",t._path=o.SVG.create("path"),e.appendChild(t._path),this._updateStyle(t)},_addPath:function(t){var e=t._container;this._container.appendChild(e),t.options.interactive&&t.addInteractiveTarget(e)},_removePath:function(t){var e=t._container;o.DomUtil.remove(e),t.removeInteractiveTarget(e)},_updateStyle:function(t){var e=t._stroke,i=t._fill,n=t.options,s=t._container;s.stroked=!!n.stroke,s.filled=!!n.fill,n.stroke?(e||(e=t._stroke=o.SVG.create("stroke")),s.appendChild(e),e.weight=n.weight+"px",e.color=n.color,e.opacity=n.opacity,n.dashArray?e.dashStyle=o.Util.isArray(n.dashArray)?n.dashArray.join(" "):n.dashArray.replace(/( *, *)/g," "):e.dashStyle="",e.endcap=n.lineCap.replace("butt","flat"),e.joinstyle=n.lineJoin):e&&(s.removeChild(e),t._stroke=null),n.fill?(i||(i=t._fill=o.SVG.create("fill")),s.appendChild(i),i.color=n.fillColor||n.color,i.opacity=n.fillOpacity):i&&(s.removeChild(i),t._fill=null)},_updateCircle:function(t){var e=t._point.round(),i=Math.round(t._radius),n=Math.round(t._radiusY||i);this._setPath(t,t._empty()?"M0 0":"AL "+e.x+","+e.y+" "+i+","+n+" 0,23592600")},_setPath:function(t,e){t._path.v=e},_bringToFront:function(t){o.DomUtil.toFront(t._container)},_bringToBack:function(t){o.DomUtil.toBack(t._container)}}:{}),o.Browser.vml&&(o.SVG.create=function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}()),o.Canvas=o.Renderer.extend({onAdd:function(){o.Renderer.prototype.onAdd.call(this),this._layers=this._layers||{},this._draw()},_initContainer:function(){var t=this._container=e.createElement("canvas");o.DomEvent.on(t,"mousemove",o.Util.throttle(this._onMouseMove,32,this),this).on(t,"click dblclick mousedown mouseup contextmenu",this._onClick,this).on(t,"mouseout",this._handleMouseOut,this),this._ctx=t.getContext("2d")},_update:function(){if(!this._map._animatingZoom||!this._bounds){this._drawnLayers={},o.Renderer.prototype._update.call(this);var t=this._bounds,e=this._container,i=t.getSize(),n=o.Browser.retina?2:1;o.DomUtil.setPosition(e,t.min),e.width=n*i.x,e.height=n*i.y,e.style.width=i.x+"px",e.style.height=i.y+"px",o.Browser.retina&&this._ctx.scale(2,2),this._ctx.translate(-t.min.x,-t.min.y),this.fire("update")}},_initPath:function(t){this._updateDashArray(t),this._layers[o.stamp(t)]=t},_addPath:o.Util.falseFn,_removePath:function(t){t._removed=!0,this._requestRedraw(t)},_updatePath:function(t){this._redrawBounds=t._pxBounds,this._draw(!0),t._project(),t._update(),this._draw(),this._redrawBounds=null},_updateStyle:function(t){this._updateDashArray(t),this._requestRedraw(t)},_updateDashArray:function(t){if(t.options.dashArray){var e,i=t.options.dashArray.split(","),n=[];for(e=0;e<i.length;e++)n.push(Number(i[e]));t.options._dashArray=n}},_requestRedraw:function(t){if(this._map){var e=(t.options.weight||0)+1;this._redrawBounds=this._redrawBounds||new o.Bounds,this._redrawBounds.extend(t._pxBounds.min.subtract([e,e])),this._redrawBounds.extend(t._pxBounds.max.add([e,e])),this._redrawRequest=this._redrawRequest||o.Util.requestAnimFrame(this._redraw,this)}},_redraw:function(){this._redrawRequest=null,this._draw(!0),this._draw(),this._redrawBounds=null},_draw:function(t){this._clear=t;var e,i=this._redrawBounds;this._ctx.save(),i&&(this._ctx.beginPath(),this._ctx.rect(i.min.x,i.min.y,i.max.x-i.min.x,i.max.y-i.min.y),this._ctx.clip());for(var n in this._layers)e=this._layers[n],(!i||e._pxBounds&&e._pxBounds.intersects(i))&&e._updatePath(),t&&e._removed&&(delete e._removed,delete this._layers[n]);this._ctx.restore()},_updatePoly:function(t,e){var i,n,o,s,r=t._parts,a=r.length,h=this._ctx;if(a){for(this._drawnLayers[t._leaflet_id]=t,h.beginPath(),h.setLineDash&&h.setLineDash(t.options&&t.options._dashArray||[]),i=0;a>i;i++){for(n=0,o=r[i].length;o>n;n++)s=r[i][n],h[n?"lineTo":"moveTo"](s.x,s.y);e&&h.closePath()}this._fillStroke(h,t)}},_updateCircle:function(t){if(!t._empty()){var e=t._point,i=this._ctx,n=t._radius,o=(t._radiusY||n)/n;this._drawnLayers[t._leaflet_id]=t,1!==o&&(i.save(),i.scale(1,o)),i.beginPath(),i.arc(e.x,e.y/o,n,0,2*Math.PI,!1),1!==o&&i.restore(),this._fillStroke(i,t)}},_fillStroke:function(t,e){var i=this._clear,n=e.options;t.globalCompositeOperation=i?"destination-out":"source-over",n.fill&&(t.globalAlpha=i?1:n.fillOpacity,t.fillStyle=n.fillColor||n.color,t.fill(n.fillRule||"evenodd")),n.stroke&&0!==n.weight&&(t.globalAlpha=i?1:n.opacity,e._prevWeight=t.lineWidth=i?e._prevWeight+1:n.weight,t.strokeStyle=n.color,t.lineCap=n.lineCap,t.lineJoin=n.lineJoin,t.stroke())},_onClick:function(t){var e,i=this._map.mouseEventToLayerPoint(t),n=[];for(var s in this._layers)e=this._layers[s],e.options.interactive&&e._containsPoint(i)&&!this._map._draggableMoved(e)&&(o.DomEvent._fakeStop(t),n.push(e));n.length&&this._fireEvent(n,t)},_onMouseMove:function(t){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var e=this._map.mouseEventToLayerPoint(t);this._handleMouseOut(t,e),this._handleMouseHover(t,e)}},_handleMouseOut:function(t,e){var i=this._hoveredLayer;!i||"mouseout"!==t.type&&i._containsPoint(e)||(o.DomUtil.removeClass(this._container,"leaflet-interactive"),this._fireEvent([i],t,"mouseout"),this._hoveredLayer=null)},_handleMouseHover:function(t,e){var i,n;for(i in this._drawnLayers)n=this._drawnLayers[i],n.options.interactive&&n._containsPoint(e)&&(o.DomUtil.addClass(this._container,"leaflet-interactive"),this._fireEvent([n],t,"mouseover"),this._hoveredLayer=n);this._hoveredLayer&&this._fireEvent([this._hoveredLayer],t)},_fireEvent:function(t,e,i){this._map._fireDOMEvent(e,i||e.type,t)},_bringToFront:o.Util.falseFn,_bringToBack:o.Util.falseFn}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.canvas=function(t){return o.Browser.canvas?new o.Canvas(t):null},o.Polyline.prototype._containsPoint=function(t,e){var i,n,s,r,a,h,l=this._clickTolerance();if(!this._pxBounds.contains(t))return!1;for(i=0,r=this._parts.length;r>i;i++)for(h=this._parts[i],n=0,a=h.length,s=a-1;a>n;s=n++)if((e||0!==n)&&o.LineUtil.pointToSegmentDistance(t,h[s],h[n])<=l)return!0;return!1},o.Polygon.prototype._containsPoint=function(t){var e,i,n,s,r,a,h,l,u=!1;if(!this._pxBounds.contains(t))return!1;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],r=0,l=e.length,a=l-1;l>r;a=r++)i=e[r],n=e[a],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u||o.Polyline.prototype._containsPoint.call(this,t,!0)},o.CircleMarker.prototype._containsPoint=function(t){return t.distanceTo(this._point)<=this._radius+this._clickTolerance()},o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(n);return this;
+}var r=this.options;if(r.filter&&!r.filter(t))return this;var a=o.GeoJSON.geometryToLayer(t,r);return a?(a.feature=o.GeoJSON.asFeature(t),a.defaultOptions=a.options,this.resetStyle(a),r.onEachFeature&&r.onEachFeature(t,a),this.addLayer(a)):this},resetStyle:function(t){return t.options=o.Util.extend({},t.defaultOptions),this._setLayerStyle(t,this.options.style),this},setStyle:function(t){return this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e){var i,n,s,r,a="Feature"===t.type?t.geometry:t,h=a?a.coordinates:null,l=[],u=e&&e.pointToLayer,c=e&&e.coordsToLatLng||this.coordsToLatLng;if(!h&&!a)return null;switch(a.type){case"Point":return i=c(h),u?u(t,i):new o.Marker(i);case"MultiPoint":for(s=0,r=h.length;r>s;s++)i=c(h[s]),l.push(u?u(t,i):new o.Marker(i));return new o.FeatureGroup(l);case"LineString":case"MultiLineString":return n=this.coordsToLatLngs(h,"LineString"===a.type?0:1,c),new o.Polyline(n,e);case"Polygon":case"MultiPolygon":return n=this.coordsToLatLngs(h,"Polygon"===a.type?1:2,c),new o.Polygon(n,e);case"GeometryCollection":for(s=0,r=a.geometries.length;r>s;s++){var d=this.geometryToLayer({geometry:a.geometries[s],type:"Feature",properties:t.properties},e);d&&l.push(d)}return new o.FeatureGroup(l);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){for(var n,o=[],s=0,r=t.length;r>s;s++)n=e?this.coordsToLatLngs(t[s],e-1,i):(i||this.coordsToLatLng)(t[s]),o.push(n);return o},latLngToCoords:function(t){return t.alt!==i?[t.lng,t.lat,t.alt]:[t.lng,t.lat]},latLngsToCoords:function(t,e,i){for(var n=[],s=0,r=t.length;r>s;s++)n.push(e?o.GeoJSON.latLngsToCoords(t[s],e-1,i):o.GeoJSON.latLngToCoords(t[s]));return!e&&i&&n.push(n[0]),n},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var r={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(r),o.Circle.include(r),o.CircleMarker.include(r),o.Polyline.prototype.toGeoJSON=function(){var t=!o.Polyline._flat(this._latlngs),e=o.GeoJSON.latLngsToCoords(this._latlngs,t?1:0);return o.GeoJSON.getFeature(this,{type:(t?"Multi":"")+"LineString",coordinates:e})},o.Polygon.prototype.toGeoJSON=function(){var t=!o.Polyline._flat(this._latlngs),e=t&&!o.Polyline._flat(this._latlngs[0]),i=o.GeoJSON.latLngsToCoords(this._latlngs,e?2:t?1:0,!0);return t||(i=[i]),o.GeoJSON.getFeature(this,{type:(e?"Multi":"")+"Polygon",coordinates:i})},o.LayerGroup.include({toMultiPoint:function(){var t=[];return this.eachLayer(function(e){t.push(e.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:"MultiPoint",coordinates:t})},toGeoJSON:function(){var t=this.feature&&this.feature.geometry&&this.feature.geometry.type;if("MultiPoint"===t)return this.toMultiPoint();var e="GeometryCollection"===t,i=[];return this.eachLayer(function(t){if(t.toGeoJSON){var n=t.toGeoJSON();i.push(e?n.geometry:o.GeoJSON.asFeature(n))}}),e?o.GeoJSON.getFeature(this,{geometries:i,type:"GeometryCollection"}):{type:"FeatureCollection",features:i}}}),o.geoJSON=function(t,e){return new o.GeoJSON(t,e)},o.geoJson=o.geoJSON;var a="_leaflet_events";o.DomEvent={on:function(t,e,i,n){if("object"==typeof e)for(var s in e)this._on(t,s,e[s],i);else{e=o.Util.splitWords(e);for(var r=0,a=e.length;a>r;r++)this._on(t,e[r],i,n)}return this},off:function(t,e,i,n){if("object"==typeof e)for(var s in e)this._off(t,s,e[s],i);else{e=o.Util.splitWords(e);for(var r=0,a=e.length;a>r;r++)this._off(t,e[r],i,n)}return this},_on:function(e,i,n,s){var r=i+o.stamp(n)+(s?"_"+o.stamp(s):"");if(e[a]&&e[a][r])return this;var h=function(i){return n.call(s||e,i||t.event)},l=h;return o.Browser.pointer&&0===i.indexOf("touch")?this.addPointerListener(e,i,h,r):o.Browser.touch&&"dblclick"===i&&this.addDoubleTapListener?this.addDoubleTapListener(e,h,r):"addEventListener"in e?"mousewheel"===i?e.addEventListener("onwheel"in e?"wheel":"mousewheel",h,!1):"mouseenter"===i||"mouseleave"===i?(h=function(i){i=i||t.event,o.DomEvent._isExternalTarget(e,i)&&l(i)},e.addEventListener("mouseenter"===i?"mouseover":"mouseout",h,!1)):("click"===i&&o.Browser.android&&(h=function(t){return o.DomEvent._filterClick(t,l)}),e.addEventListener(i,h,!1)):"attachEvent"in e&&e.attachEvent("on"+i,h),e[a]=e[a]||{},e[a][r]=h,this},_off:function(t,e,i,n){var s=e+o.stamp(i)+(n?"_"+o.stamp(n):""),r=t[a]&&t[a][s];return r?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,s):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,s):"removeEventListener"in t?"mousewheel"===e?t.removeEventListener("onwheel"in t?"wheel":"mousewheel",r,!1):t.removeEventListener("mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,r,!1):"detachEvent"in t&&t.detachEvent("on"+e,r),t[a][s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.originalEvent?t.originalEvent._stopped=!0:t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){return o.DomEvent.on(t,"mousewheel",o.DomEvent.stopPropagation)},disableClickPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,o.Draggable.START.join(" "),e),o.DomEvent.on(t,{click:o.DomEvent._fakeStop,dblclick:e})},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},_wheelPxFactor:o.Browser.win&&o.Browser.chrome?2:o.Browser.gecko?t.devicePixelRatio:1,getWheelDelta:function(t){return o.Browser.edge?t.wheelDeltaY/2:t.deltaY&&0===t.deltaMode?-t.deltaY/o.DomEvent._wheelPxFactor:t.deltaY&&1===t.deltaMode?20*-t.deltaY:t.deltaY&&2===t.deltaMode?60*-t.deltaY:t.deltaX||t.deltaZ?0:t.wheelDelta?(t.wheelDeltaY||t.wheelDelta)/2:t.detail&&Math.abs(t.detail)<32765?20*-t.detail:t.detail?t.detail/-32765*60:0},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_isExternalTarget:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent&&t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&500>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,void e(t))}},o.DomEvent.addListener=o.DomEvent.on,o.DomEvent.removeListener=o.DomEvent.off,o.Draggable=o.Evented.extend({options:{clickTolerance:3},statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e,i){this._element=t,this._dragStartTarget=e||t,this._preventOutline=i},enable:function(){this._enabled||(o.DomEvent.on(this._dragStartTarget,o.Draggable.START.join(" "),this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(o.DomEvent.off(this._dragStartTarget,o.Draggable.START.join(" "),this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(t){if(!t._simulated&&this._enabled&&(this._moved=!1,!o.DomUtil.hasClass(this._element,"leaflet-zoom-anim")&&!(o.Draggable._dragging||t.shiftKey||1!==t.which&&1!==t.button&&!t.touches)&&this._enabled&&(o.Draggable._dragging=!0,this._preventOutline&&o.DomUtil.preventOutline(this._element),o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),!this._moving))){this.fire("down");var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(i){if(!i._simulated&&this._enabled){if(i.touches&&i.touches.length>1)return void(this._moved=!0);var n=i.touches&&1===i.touches.length?i.touches[0]:i,s=new o.Point(n.clientX,n.clientY),r=s.subtract(this._startPoint);(r.x||r.y)&&(Math.abs(r.x)+Math.abs(r.y)<this.options.clickTolerance||(o.DomEvent.preventDefault(i),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(r),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=i.target||i.srcElement,t.SVGElementInstance&&this._lastTarget instanceof SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(r),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._lastEvent=i,this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0)))}},_updatePosition:function(){var t={originalEvent:this._lastEvent};this.fire("predrag",t),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag",t)},_onUp:function(t){if(!t._simulated&&this._enabled){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var i in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[i],this._onMove,this).off(e,o.Draggable.END[i],this._onUp,this);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1,o.Draggable._dragging=!1}}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){return this._enabled?this:(this._enabled=!0,this.addHooks(),this)},disable:function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({down:this._onDown,dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),t.on("zoomend",this._onZoomEnd,this),t.whenReady(this._onZoomEnd,this))}o.DomUtil.addClass(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){o.DomUtil.removeClass(this._map._container,"leaflet-grab"),o.DomUtil.removeClass(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDown:function(){this._map._stop()},_onDragStart:function(){var t=this._map;if(this._map.options.maxBounds&&this._map.options.maxBoundsViscosity){var e=o.latLngBounds(this._map.options.maxBounds);this._offsetLimit=o.bounds(this._map.latLngToContainerPoint(e.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(e.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))}else this._offsetLimit=null;t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(t){if(this._map.options.inertia){var e=this._lastTime=+new Date,i=this._lastPos=this._draggable._absPos||this._draggable._newPos;this._positions.push(i),this._times.push(e),e-this._times[0]>50&&(this._positions.shift(),this._times.shift())}this._map.fire("move",t).fire("drag",t)},_onZoomEnd:function(){var t=this._map.getSize().divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(t,e){return t-(t-e)*this._viscosity},_onPreDragLimit:function(){if(this._viscosity&&this._offsetLimit){var t=this._draggable._newPos.subtract(this._draggable._startPos),e=this._offsetLimit;t.x<e.min.x&&(t.x=this._viscousLimit(t.x,e.min.x)),t.y<e.min.y&&(t.y=this._viscousLimit(t.y,e.min.y)),t.x>e.max.x&&(t.x=this._viscousLimit(t.x,e.max.x)),t.y>e.max.y&&(t.y=this._viscousLimit(t.y,e.max.y)),this._draggable._newPos=this._draggable._startPos.add(t)}},_onPreDragWrap:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,r=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=r},_onDragEnd:function(t){var e=this._map,i=e.options,n=!i.inertia||this._times.length<2;if(e.fire("dragend",t),n)e.fire("moveend");else{var s=this._lastPos.subtract(this._positions[0]),r=(this._lastTime-this._times[0])/1e3,a=i.easeLinearity,h=s.multiplyBy(a/r),l=h.distanceTo([0,0]),u=Math.min(i.inertiaMaxSpeed,l),c=h.multiplyBy(u/l),d=u/(i.inertiaDeceleration*a),_=c.multiplyBy(-d/2).round();_.x||_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:d,easeLinearity:a,noMoveStart:!0,animate:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom(),n=e.options.zoomDelta,o=t.originalEvent.shiftKey?i-n:i+n;"center"===e.options.doubleClickZoom?e.setZoom(o):e.setZoomAround(t.containerPoint,o)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll,this)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t),i=this._map.options.wheelDebounceTime;this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var n=Math.max(i-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),n),o.DomEvent.stop(t)},_performZoom:function(){var t=this._map,e=t.getZoom(),i=this._map.options.zoomSnap||0;t._stop();var n=this._delta/(4*this._map.options.wheelPxPerZoomLevel),o=4*Math.log(2/(1+Math.exp(-Math.abs(n))))/Math.LN2,s=i?Math.ceil(o/i)*i:o,r=t._limitZoom(e+(this._delta>0?s:-s))-e;this._delta=0,this._startTime=null,r&&("center"===t.options.scrollWheelZoom?t.setZoom(e+r):t.setZoomAround(this._lastMousePos,e+r))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,e,i){function n(t){var e;if(e=o.Browser.pointer?o.DomEvent._pointersCount:t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);a=t.touches?t.touches[0]:t,h=n>0&&l>=n,r=i}}function s(){if(h&&!a.cancelBubble){if(o.Browser.pointer){var t,i,n={};for(i in a)t=a[i],n[i]=t&&t.bind?t.bind(a):t;a=n}a.type="dblclick",e(a),r=null}}var r,a,h=!1,l=250,u="_leaflet_",c=this._touchstart,d=this._touchend;return t[u+c+i]=n,t[u+d+i]=s,t[u+"dblclick"+i]=e,t.addEventListener(c,n,!1),t.addEventListener(d,s,!1),o.Browser.edge||t.addEventListener("dblclick",e,!1),this},removeDoubleTapListener:function(t,e){var i="_leaflet_",n=t[i+this._touchstart+e],s=t[i+this._touchend+e],r=t[i+"dblclick"+e];return t.removeEventListener(this._touchstart,n,!1),t.removeEventListener(this._touchend,s,!1),o.Browser.edge||t.removeEventListener("dblclick",r,!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",TAG_WHITE_LIST:["INPUT","SELECT","OPTION"],_pointers:{},_pointersCount:0,addPointerListener:function(t,e,i,n){return"touchstart"===e?this._addPointerStart(t,i,n):"touchmove"===e?this._addPointerMove(t,i,n):"touchend"===e&&this._addPointerEnd(t,i,n),this},removePointerListener:function(t,e,i){var n=t["_leaflet_"+e+i];return"touchstart"===e?t.removeEventListener(this.POINTER_DOWN,n,!1):"touchmove"===e?t.removeEventListener(this.POINTER_MOVE,n,!1):"touchend"===e&&(t.removeEventListener(this.POINTER_UP,n,!1),t.removeEventListener(this.POINTER_CANCEL,n,!1)),this},_addPointerStart:function(t,i,n){var s=o.bind(function(t){if("mouse"!==t.pointerType&&t.pointerType!==t.MSPOINTER_TYPE_MOUSE){if(!(this.TAG_WHITE_LIST.indexOf(t.target.tagName)<0))return;o.DomEvent.preventDefault(t)}this._handlePointer(t,i)},this);if(t["_leaflet_touchstart"+n]=s,t.addEventListener(this.POINTER_DOWN,s,!1),!this._pointerDocListener){var r=o.bind(this._globalPointerUp,this);e.documentElement.addEventListener(this.POINTER_DOWN,o.bind(this._globalPointerDown,this),!0),e.documentElement.addEventListener(this.POINTER_MOVE,o.bind(this._globalPointerMove,this),!0),e.documentElement.addEventListener(this.POINTER_UP,r,!0),e.documentElement.addEventListener(this.POINTER_CANCEL,r,!0),this._pointerDocListener=!0}},_globalPointerDown:function(t){this._pointers[t.pointerId]=t,this._pointersCount++},_globalPointerMove:function(t){this._pointers[t.pointerId]&&(this._pointers[t.pointerId]=t)},_globalPointerUp:function(t){delete this._pointers[t.pointerId],this._pointersCount--},_handlePointer:function(t,e){t.touches=[];for(var i in this._pointers)t.touches.push(this._pointers[i]);t.changedTouches=[t],e(t)},_addPointerMove:function(t,e,i){var n=o.bind(function(t){(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons)&&this._handlePointer(t,e)},this);t["_leaflet_touchmove"+i]=n,t.addEventListener(this.POINTER_MOVE,n,!1)},_addPointerEnd:function(t,e,i){var n=o.bind(function(t){this._handlePointer(t,e)},this);t["_leaflet_touchend"+i]=n,t.addEventListener(this.POINTER_UP,n,!1),t.addEventListener(this.POINTER_CANCEL,n,!1)}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomUtil.addClass(this._map._container,"leaflet-touch-zoom"),o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomUtil.removeClass(this._map._container,"leaflet-touch-zoom"),o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToContainerPoint(t.touches[0]),s=i.mouseEventToContainerPoint(t.touches[1]);this._centerPoint=i.getSize()._divideBy(2),this._startLatLng=i.containerPointToLatLng(this._centerPoint),"center"!==i.options.touchZoom&&(this._pinchStartLatLng=i.containerPointToLatLng(n.add(s)._divideBy(2))),this._startDist=n.distanceTo(s),this._startZoom=i.getZoom(),this._moved=!1,this._zooming=!0,i._stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){if(t.touches&&2===t.touches.length&&this._zooming){var e=this._map,i=e.mouseEventToContainerPoint(t.touches[0]),n=e.mouseEventToContainerPoint(t.touches[1]),s=i.distanceTo(n)/this._startDist;if(this._zoom=e.getScaleZoom(s,this._startZoom),!e.options.bounceAtZoomLimits&&(this._zoom<e.getMinZoom()&&1>s||this._zoom>e.getMaxZoom()&&s>1)&&(this._zoom=e._limitZoom(this._zoom)),"center"===e.options.touchZoom){if(this._center=this._startLatLng,1===s)return}else{var r=i._add(n)._divideBy(2)._subtract(this._centerPoint);if(1===s&&0===r.x&&0===r.y)return;this._center=e.unproject(e.project(this._pinchStartLatLng,this._zoom).subtract(r),this._zoom)}this._moved||(e._moveStart(!0),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest);var a=o.bind(e._move,e,this._center,this._zoom,{pinch:!0,round:!1});this._animRequest=o.Util.requestAnimFrame(a,this,!0),o.DomEvent.preventDefault(t)}},_onTouchEnd:function(){return this._moved&&this._zooming?(this._zooming=!1,o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd),void(this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom)))):void(this._zooming=!1)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),this._simulateEvent("mousedown",i),o.DomEvent.on(e,{touchmove:this._onMove,touchend:this._onUp},this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,{touchmove:this._onMove,touchend:this._onUp},this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._simulateEvent("mouseup",i),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY),this._simulateEvent("mousemove",e)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_resetState:function(){this._moved=!1},_onMouseDown:function(t){return!t.shiftKey||1!==t.which&&1!==t.button?!1:(this._resetState(),o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startPoint=this._map.mouseEventToContainerPoint(t),void o.DomEvent.on(e,{contextmenu:o.DomEvent.stop,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this))},_onMouseMove:function(t){this._moved||(this._moved=!0,this._box=o.DomUtil.create("div","leaflet-zoom-box",this._container),o.DomUtil.addClass(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(t);var e=new o.Bounds(this._point,this._startPoint),i=e.getSize();o.DomUtil.setPosition(this._box,e.min),this._box.style.width=i.x+"px",this._box.style.height=i.y+"px"},_finish:function(){this._moved&&(o.DomUtil.remove(this._box),o.DomUtil.removeClass(this._container,"leaflet-crosshair")),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,{contextmenu:o.DomEvent.stop,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(t){if((1===t.which||1===t.button)&&(this._finish(),this._moved)){setTimeout(o.bind(this._resetState,this),0);var e=new o.LatLngBounds(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));this._map.fitBounds(e).fire("boxzoomend",{boxZoomBounds:e})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanDelta:80}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(t){this._map=t,this._setPanDelta(t.options.keyboardPanDelta),this._setZoomDelta(t.options.zoomDelta)},addHooks:function(){var t=this._map._container;t.tabIndex<=0&&(t.tabIndex="0"),o.DomEvent.on(t,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),o.DomEvent.off(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomDelta:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var e,i=t.keyCode,n=this._map;if(i in this._panKeys){if(n._panAnim&&n._panAnim._inProgress)return;e=this._panKeys[i],t.shiftKey&&(e=o.point(e).multiplyBy(3)),n.panBy(e),n.options.maxBounds&&n.panInsideBounds(n.options.maxBounds)}else if(i in this._zoomKeys)n.setZoom(n.getZoom()+(t.shiftKey?3:1)*this._zoomKeys[i]);else{if(27!==i)return;n.closePopup()}o.DomEvent.stop(t)}}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t,!0)),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),o.DomUtil.addClass(t,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(t){var e=this._marker,i=e._shadow,n=o.DomUtil.getPosition(e._icon),s=e._map.layerPointToLatLng(n);i&&o.DomUtil.setPosition(i,n),e._latlng=s,t.latlng=s,t.oldLatLng=this._oldLatLng,e.fire("move",t).fire("drag",t)},_onDragEnd:function(t){delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this.remove(),this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},remove:function(){return this._map?(o.DomUtil.remove(this._container),this.onRemove&&this.onRemove(this._map),this._map=null,this):this},_refocusOnMap:function(t){this._map&&t&&t.screenX>0&&t.screenY>0&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.remove(),this},_initControlPos:function(){function t(t,s){var r=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",r,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){o.DomUtil.remove(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar"),n=this.options;return this._zoomInButton=this._createButton(n.zoomInText,n.zoomInTitle,e+"-in",i,this._zoomIn),this._zoomOutButton=this._createButton(n.zoomOutText,n.zoomOutTitle,e+"-out",i,this._zoomOut),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(t){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(t.shiftKey?3:1))},_zoomOut:function(t){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(t.shiftKey?3:1))},_createButton:function(t,e,i,n,s){var r=o.DomUtil.create("a",i,n);return r.innerHTML=t,r.href="#",r.title=e,o.DomEvent.on(r,"mousedown dblclick",o.DomEvent.stopPropagation).on(r,"click",o.DomEvent.stop).on(r,"click",s,this).on(r,"click",this._refocusOnMap,this),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),(this._disabled||t._zoom===t.getMinZoom())&&o.DomUtil.addClass(this._zoomOutButton,e),(this._disabled||t._zoom===t.getMaxZoom())&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){t.attributionControl=this,this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent&&o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());
+return this._update(),this._container},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):this},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):this},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(new o.Control.Attribution).addTo(this)}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(t){var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e+"-line",i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e,i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e,i))},_update:function(){var t=this._map,e=t.getSize().y/2,i=t.distance(t.containerPointToLatLng([0,e]),t.containerPointToLatLng([this.options.maxWidth,e]));this._updateScales(i)},_updateScales:function(t){this.options.metric&&t&&this._updateMetric(t),this.options.imperial&&t&&this._updateImperial(t)},_updateMetric:function(t){var e=this._getRoundNum(t),i=1e3>e?e+" m":e/1e3+" km";this._updateScale(this._mScale,i,e/t)},_updateImperial:function(t){var e,i,n,o=3.2808399*t;o>5280?(e=o/5280,i=this._getRoundNum(e),this._updateScale(this._iScale,i+" mi",i/e)):(n=this._getRoundNum(o),this._updateScale(this._iScale,n+" ft",n/o))},_updateScale:function(t,e,i){t.style.width=Math.round(this.options.maxWidth*i)+"px",t.innerHTML=e},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1},initialize:function(t,e,i){o.setOptions(this,i),this._layers=[],this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),this._map=t,t.on("zoomend",this._checkDisabledLayers,this),this._container},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var t=0;t<this._layers.length;t++)this._layers[t].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._map?this._update():this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._map?this._update():this},removeLayer:function(t){t.off("add remove",this._onLayerChange,this);var e=this._getLayer(o.stamp(t));return e&&this._layers.splice(this._layers.indexOf(e),1),this._map?this._update():this},expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded"),this._form.style.height=null;var t=this._map.getSize().y-(this._container.offsetTop+50);return t<this._form.clientHeight?(o.DomUtil.addClass(this._form,"leaflet-control-layers-scrollbar"),this._form.style.height=t+"px"):o.DomUtil.removeClass(this._form,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return o.DomUtil.removeClass(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.DomEvent.disableClickPropagation(e),o.Browser.touch||o.DomEvent.disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,{mouseenter:this.expand,mouseleave:this.collapse},this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this.expand,this):o.DomEvent.on(n,"focus",this.expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this.collapse,this)}else this.expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_getLayer:function(t){for(var e=0;e<this._layers.length;e++)if(this._layers[e]&&o.stamp(this._layers[e].layer)===t)return this._layers[e]},_addLayer:function(t,e,i){t.on("add remove",this._onLayerChange,this),this._layers.push({layer:t,name:e,overlay:i}),this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(!this._container)return this;o.DomUtil.empty(this._baseLayersList),o.DomUtil.empty(this._overlaysList);var t,e,i,n,s=0;for(i=0;i<this._layers.length;i++)n=this._layers[i],this._addItem(n),e=e||n.overlay,t=t||!n.overlay,s+=n.overlay?0:1;return this.options.hideSingleBase&&(t=t&&s>1,this._baseLayersList.style.display=t?"":"none"),this._separator.style.display=e&&t?"":"none",this},_onLayerChange:function(t){this._handlingClick||this._update();var e=this._getLayer(o.stamp(t.target)),i=e.overlay?"add"===t.type?"overlayadd":"overlayremove":"add"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"'+(i?' checked="checked"':"")+"/>",o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var r=e.createElement("span");r.innerHTML=" "+t.name;var a=e.createElement("div");n.appendChild(a),a.appendChild(i),a.appendChild(r);var h=t.overlay?this._overlaysList:this._baseLayersList;return h.appendChild(n),this._checkDisabledLayers(),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=[],s=[];this._handlingClick=!0;for(var r=n.length-1;r>=0;r--)t=n[r],e=this._getLayer(t.layerId).layer,i=this._map.hasLayer(e),t.checked&&!i?o.push(e):!t.checked&&i&&s.push(e);for(r=0;r<s.length;r++)this._map.removeLayer(s[r]);for(r=0;r<o.length;r++)this._map.addLayer(o[r]);this._handlingClick=!1,this._refocusOnMap()},_checkDisabledLayers:function(){for(var t,e,n=this._form.getElementsByTagName("input"),o=this._map.getZoom(),s=n.length-1;s>=0;s--)t=n[s],e=this._getLayer(t.layerId).layer,t.disabled=e.options.minZoom!==i&&o<e.options.minZoom||e.options.maxZoom!==i&&o>e.options.maxZoom},_expand:function(){return this.expand()},_collapse:function(){return this.collapse()}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Evented.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(t){var e=+new Date-this._startTime,i=1e3*this._duration;i>e?this._runFrame(this._easeOut(e/i),t):(this._runFrame(1),this._complete())},_runFrame:function(t,e){var i=this._startPos.add(this._offset.multiplyBy(t));e&&i._round(),o.DomUtil.setPosition(this._el,i),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate,duration:n.duration},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this.fire("moveend");if(e.animate!==!0&&!this.getSize().contains(t))return this._resetView(this.unproject(this.project(this.getCenter()).add(t)),this.getZoom()),this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t).round();this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4});var h=o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.mobileOpera;h&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),o.DomEvent.on(this._proxy,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this))}),o.Map.include(h?{_createAnimProxy:function(){var t=this._proxy=o.DomUtil.create("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(t),this.on("zoomanim",function(e){var i=o.DomUtil.TRANSFORM,n=t.style[i];o.DomUtil.setTransform(t,this.project(e.center,e.zoom),this.getZoomScale(e.zoom,1)),n===t.style[i]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",function(){var e=this.getCenter(),i=this.getZoom();o.DomUtil.setTransform(t,this.project(e,i),this.getZoomScale(i,1))},this)},_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),s=this._getCenterOffset(t)._divideBy(1-1/n);return i.animate===!0||this.getSize().contains(s)?(o.Util.requestAnimFrame(function(){this._moveStart(!0)._animateZoom(t,e,!0)},this),!0):!1},_animateZoom:function(t,e,i,n){i&&(this._animatingZoom=!0,this._animateToCenter=t,this._animateToZoom=e,o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:t,zoom:e,noUpdate:n}),setTimeout(o.bind(this._onZoomTransitionEnd,this),250)},_onZoomTransitionEnd:function(){this._animatingZoom&&(o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom),o.Util.requestAnimFrame(function(){this._moveEnd(!0)},this))}}:{}),o.Map.include({flyTo:function(t,e,n){function s(t){var e=t?-1:1,i=t?v:g,n=v*v-g*g+e*L*L*y*y,o=2*i*L*y,s=n/o,r=Math.sqrt(s*s+1)-s,a=1e-9>r?-18:Math.log(r);return a}function r(t){return(Math.exp(t)-Math.exp(-t))/2}function a(t){return(Math.exp(t)+Math.exp(-t))/2}function h(t){return r(t)/a(t)}function l(t){return g*(a(x)/a(x+P*t))}function u(t){return g*(a(x)*h(x+P*t)-r(x))/L}function c(t){return 1-Math.pow(1-t,1.5)}function d(){var i=(Date.now()-b)/T,n=c(i)*w;1>=i?(this._flyToFrame=o.Util.requestAnimFrame(d,this),this._move(this.unproject(_.add(m.subtract(_).multiplyBy(u(n)/y)),f),this.getScaleZoom(g/l(n),f),{flyTo:!0})):this._move(t,e)._moveEnd(!0)}if(n=n||{},n.animate===!1||!o.Browser.any3d)return this.setView(t,e,n);this._stop();var _=this.project(this.getCenter()),m=this.project(t),p=this.getSize(),f=this._zoom;t=o.latLng(t),e=e===i?f:e;var g=Math.max(p.x,p.y),v=g*this.getZoomScale(f,e),y=m.distanceTo(_)||1,P=1.42,L=P*P,x=s(0),b=Date.now(),w=(s(1)-x)/P,T=n.duration?1e3*n.duration:1e3*w*.8;return this._moveStart(!0),d.call(this),this},flyToBounds:function(t,e){var i=this._getBoundsCenterZoom(t,e);return this.flyTo(i.center,i.zoom,e)}}),o.Map.include({_defaultLocateOptions:{timeout:1e4,watch:!1},locate:function(t){if(t=this._locateOptions=o.extend({},this._defaultLocateOptions,t),!("geolocation"in navigator))return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=n.toBounds(t.coords.accuracy),r=this._locateOptions;if(r.setView){var a=this.getBoundsZoom(s);this.setView(n,r.maxZoom?Math.min(a,r.maxZoom):a)}var h={latlng:n,bounds:s,timestamp:t.timestamp};for(var l in t.coords)"number"==typeof t.coords[l]&&(h[l]=t.coords[l]);this.fire("locationfound",h)}})}(window,document);
+
+},{}],6:[function(require,module,exports){
 var formatTools=require("./tools/format.js"),GHInput=require("./graphhopper/GHInput.js"),GHRoute=require("./graphhopper/GHRoute.js"),mapLayer=require("./map.js"),dataToHtml=function(e,t){var o="";if(e.name)o+="<div class='nameseg'>"+formatTools.formatValue(e.name,t)+"</div>";else if(e.street){var a=e.street;e.housenumber&&(a=formatTools.insComma(a,e.housenumber)),o+="<div class='nameseg'>"+formatTools.formatValue(a,t)+"</div>"}var n="";return e.postcode&&(n=e.postcode),e.city&&(n=formatTools.insComma(n,e.city)),e.country&&(n=formatTools.insComma(n,e.country)),n&&(o+="<div class='cityseg'>"+formatTools.formatValue(n,t)+"</div>"),"highway"===e.osm_key,o+="place"===e.osm_key?"<span class='moreseg'>"+e.osm_value+"</span>":"<span class='moreseg'>"+e.osm_key+"</span>"},dataToText=function(e){var t="";return e.name?t=e.name:e.street&&(t=e.street,e.housenumber&&(t=formatTools.insComma(t,e.housenumber))),e.postcode&&(t=formatTools.insComma(t,e.postcode)),e.city&&t.indexOf(e.city)<0&&(t=formatTools.insComma(t,e.city)),e.country&&t.indexOf(e.country)<0&&(t=formatTools.insComma(t,e.country)),t},AutoComplete=function(e,t){this.host=e,this.key=t,this.dataType="json",this.api_params={locale:"en"}};AutoComplete.prototype.createPath=function(e){for(var t in this.api_params){var o=this.api_params[t];if(GHRoute.isArray(o))for(var a in o)e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o[a]);else e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o)}return e},AutoComplete.prototype.createGeocodeURL=function(e,t){var o=this.createPath(this.host+"/geocode?limit=6&type="+this.dataType+"&key="+this.key);if(t>=0&&t<e.route.size()){var a=e.route.getIndex(t);a.isResolved()&&(o+="&point="+a.lat+","+a.lng)}return o},AutoComplete.prototype.getAutoCompleteDiv=function(e){return $("#locationpoints > div.pointDiv").eq(e).find(".pointInput")},AutoComplete.prototype.hide=function(){$(':input[id$="_Input"]').autocomplete().hide()},AutoComplete.prototype.showListForIndex=function(e,t,o){var a=this.getAutoCompleteDiv(o),n=this.createGeocodeURL(e,o-1),r={containerClass:"autocomplete",timeout:1e3,deferRequestBy:5,minChars:2,maxHeight:510,noCache:!0,triggerSelectOnValidInput:!1,autoSelectFirst:!1,paramName:"q",dataType:e.dataType,onSearchStart:function(e){var t=new GHInput(e.q).lat;return void 0===t},serviceUrl:function(){return n},transformResult:function(e,t){if(e.suggestions=[],e.hits)for(var o=0;o<e.hits.length;o++){var a=e.hits[o];e.suggestions.push({value:dataToText(a),data:a})}return e},onSearchError:function(e,t,o,a,n){},formatResult:function(e,t){return dataToHtml(e.data,t)},onSelect:function(e){r.onPreSelect(e)},onPreSelect:function(n){var r=e.route.getIndex(o);a.autocomplete().disable();var s=n.data.point;r.setCoord(s.lat,s.lng),r.input=n.value,t(!0)||mapLayer.focus(r,15,o),a.autocomplete().enable()}};a.autocomplete(r)},AutoComplete.prototype.createStub=function(){return complete=new AutoComplete,complete.showListForIndex=function(){},complete.hide=function(){},complete},AutoComplete.prototype.setLocale=function(e){e&&(this.api_params.locale=e)},module.exports=AutoComplete;
 
-},{"./graphhopper/GHInput.js":9,"./graphhopper/GHRoute.js":11,"./map.js":21,"./tools/format.js":24}],6:[function(require,module,exports){
+},{"./graphhopper/GHInput.js":10,"./graphhopper/GHRoute.js":12,"./map.js":21,"./tools/format.js":25}],7:[function(require,module,exports){
 exports.options={environment:"development",routing:{host:"",api_key:""},geocoding:{host:"",api_key:""},thunderforest:{api_key:""}};
-
 },{}],7:[function(require,module,exports){
 var ghenv=require("./options.js").options,tfAddition="";ghenv.thunderforest.api_key&&(tfAddition="?apikey="+ghenv.thunderforest.api_key);var osmAttr='&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors',retinaTiles=L.Browser.retina,lyrk=L.tileLayer("https://tiles.lyrk.org/"+(retinaTiles?"lr":"ls")+"/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077",{attribution:osmAttr+', <a href="https://geodienste.lyrk.de/">Lyrk</a>'}),omniscale=L.tileLayer.wms("https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile",{layers:"osm",attribution:osmAttr+', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'}),openMapSurfer=L.tileLayer("http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}",{attribution:osmAttr+', <a href="http://korona.geog.uni-heidelberg.de/contact.html">GIScience Heidelberg</a>'}),sorbianLang=L.tileLayer("https://apis.mapmyindia.com/advancedmaps/v1/rtvymede8c97meh77cilsoc4xc9reyq5/still_map/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://www.mapmyindia.com/">&copy; MapMyIndia</a>'}),thunderTransport=L.tileLayer("https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>'}),thunderCycle=L.tileLayer("https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="http://www.thunderforest.com/opencyclemap/" target="_blank">Thunderforest Cycle</a>'}),thunderOutdoors=L.tileLayer("https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="http://www.thunderforest.com/outdoors/" target="_blank">Thunderforest Outdoors</a>'}),wrk=L.tileLayer("http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',subdomains:["topo4","topo","topo2","topo3"]}),osm=L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:osmAttr}),osmde=L.tileLayer("http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png",{attribution:osmAttr}),mapLink='<a href="http://www.esri.com/">Esri</a>',wholink="i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",esriAerial=L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",{attribution:"&copy; "+mapLink+", "+wholink,maxZoom:18}),availableTileLayers={Omniscale:omniscale,OpenStreetMap:osm,"Esri Aerial":esriAerial,"TF Transport":thunderTransport,"TF Cycle":thunderCycle,"TF Outdoors":thunderOutdoors,Lyrk:lyrk,WanderReitKarte:wrk,OpenMapSurfer:openMapSurfer,"MapMyIndia":sorbianLang,"OpenStreetMap.de":osmde};module.exports.activeLayerName="Omniscale",module.exports.defaultLayer=omniscale,module.exports.getAvailableTileLayers=function(){return availableTileLayers},module.exports.selectLayer=function(e){var t=availableTileLayers[e];return t||(t=module.exports.defaultLayer),t};
-
-},{"./options.js":6}],8:[function(require,module,exports){
+},{"./options.js":7}],9:[function(require,module,exports){
 var ensureOneCheckboxSelected=function(){$("#gpx_route").change(function(){$(this).is(":checked")?($("#gpx_track").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_track").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_track").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_track").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_waypoints").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_track").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_track").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_track").prop("disabled",!0)})};module.exports.addGpxExport=function(e){function p(p,o,i){return e.route.isResolved()&&window.open(e.createGPXURL(p,o,i)),!1}function o(){return p($("#gpx_route").is(":checked"),$("#gpx_track").is(":checked"),$("#gpx_waypoints").is(":checked")),i.dialog("close"),!1}var i;$(function(){i=$("#gpx_dialog").dialog({width:420,height:260,autoOpen:!1,resizable:!1,draggable:!1,buttons:{"Export GPX":o,Cancel:function(){$(this).dialog("close")}}}),ensureOneCheckboxSelected()}),$("#gpxExportButton a").click(function(e){e.preventDefault(),$("#gpx_dialog").dialog("open")})};
 
-},{}],9:[function(require,module,exports){
-function round(t,n){return void 0===n&&(n=1e6),Math.round(t*n)/n}var GHInput=function(t){this.set(t)};GHInput.isObject=function(t){var n=Object.prototype.toString.call(t);return"[object object]"===n.toLowerCase()},GHInput.isString=function(t){var n=Object.prototype.toString.call(t);return"[object string]"===n.toLowerCase()},GHInput.prototype.isResolved=function(){return!isNaN(this.lat)&&!isNaN(this.lng)},GHInput.prototype.setCoord=function(t,n){this.lat=round(t),this.lng=round(n),this.input=this.toString()},GHInput.prototype.setUnresolved=function(){this.lat=void 0,this.lng=void 0},GHInput.prototype.set=function(t){if(this.input=t,GHInput.isObject(t))this.setCoord(t.lat,t.lng);else if(GHInput.isString(t)){var n=t.indexOf(",");n>=0?(this.lat=round(parseFloat(t.substr(0,n))),this.lng=round(parseFloat(t.substr(n+1))),this.isResolved()?this.input=this.toString():this.setUnresolved()):this.setUnresolved()}},GHInput.prototype.toString=function(){if(void 0!==this.lat&&void 0!==this.lng)return this.lat+","+this.lng},module.exports=GHInput;
-
 },{}],10:[function(require,module,exports){
-var GHRoute=require("./GHRoute.js"),GHInput=require("./GHInput.js"),graphhopperTools=require("./tools.js");Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),o=this,i=function(){},s=function(){return o.apply(this instanceof i&&t?this:t,e.concat(Array.prototype.slice.call(arguments)))};return i.prototype=this.prototype,s.prototype=new i,s});var GHRequest=function(t,e){this.host=t,this.key=e,this.route=new GHRoute(new GHInput,new GHInput),this.from=this.route.first(),this.to=this.route.last(),this.features={},this.do_zoom=!0,this.dataType="json",this.api_params={locale:"en",vehicle:"car",weighting:"fastest",elevation:!1},this.route.addListener("route.add",function(t){this.to=this.route.last()}.bind(this)),this.route.addListener("route.remove",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.move",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.reverse",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this))};GHRequest.prototype.init=function(t){for(var e in t){var o=t[e];"false"===o?o=!1:"true"===o&&(o=!0),"point"!==e&&"mathRandom"!==e&&"do_zoom"!==e&&"layer"!==e&&(this.api_params[e]=o)}"do_zoom"in t&&(this.do_zoom=t.do_zoom),this.api_params.elevation=!1;var i=this.features[this.api_params.vehicle];if(i&&i.elevation&&("elevation"in t?this.api_params.elevation=t.elevation:this.api_params.elevation=!0),t.q){var s=t.q;t.point||(t.point=[]);var r=s.indexOf("from:"),a=s.indexOf("to:");if(r>=0&&a>=0)r<a?(t.point.push(s.substring(r+5,a).trim()),t.point.push(s.substring(a+3).trim())):(t.point.push(s.substring(a+3,r).trim()),t.point.push(s.substring(r+5).trim()));else for(var n=s.split("p:"),p=0;p<n.length;p++){var h=n[p].trim();0!==h.length&&t.point.push(h)}}},GHRequest.prototype.initVehicle=function(t){this.api_params.vehicle=t;var e=this.features[t];e&&e.elevation?this.api_params.elevation=!0:this.api_params.elevation=!1},GHRequest.prototype.hasElevation=function(){return this.api_params.elevation},GHRequest.prototype.getVehicle=function(){return this.api_params.vehicle},GHRequest.prototype.createGeocodeURL=function(t,e){var o=this.host;t&&(o=t);var i=this.createPath(o+"/geocode?limit=6&type="+this.dataType+"&key="+this.key);if(e>=0&&e<this.route.size()){var s=this.route.getIndex(e);s.isResolved()&&(i+="&point="+s.lat+","+s.lng)}return i},GHRequest.prototype.createURL=function(){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type="+this.dataType+"&key="+this.key)},GHRequest.prototype.createGPXURL=function(t,e,o){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type=gpx&key="+this.key+"&gpx.route="+t+"&gpx.track="+e+"&gpx.waypoints="+o)},GHRequest.prototype.createHistoryURL=function(){return this.createPath("?"+this.createPointParams(!0))},GHRequest.prototype.createPointParams=function(t){var e,o,i,s="";for(o=0,i=this.route.size();o<i;o++)e=this.route.getIndex(o),o>0&&(s+="&"),s+=t?"point="+encodeURIComponent(e.input):"point="+encodeURIComponent(e.toString());return s},GHRequest.prototype.createPath=function(t){for(var e in this.api_params){var o=this.api_params[e];if(GHRoute.isArray(o))for(var i in o)t+="&"+encodeURIComponent(e)+"="+encodeURIComponent(o[i]);else t+="&"+encodeURIComponent(e)+"="+encodeURIComponent(o)}return t},GHRequest.prototype.doRequest=function(t,e){var o=this;$.ajax({timeout:3e4,url:t,success:function(t){if(t.paths)for(var i=0;i<t.paths.length;i++){var s=t.paths[i];if(s.points_encoded){var r=graphhopperTools.decodePath(s.points,o.hasElevation());s.points={type:"LineString",coordinates:r};var a=graphhopperTools.decodePath(s.snapped_waypoints,o.hasElevation());s.snapped_waypoints={type:"MultiPoint",coordinates:a}}}e(t)},error:function(o){var i,s="API did not respond! ";if(o&&o.responseText&&o.responseText.indexOf("{")>=0)i=JSON.parse(o.responseText);else if(o&&o.statusText&&"OK"!==o.statusText){s+=o.statusText;var r="Error for "+t;i={message:s,hints:[{message:s,details:r}]}}console.log(s+" "+JSON.stringify(o)),e(i)},type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.getInfo=function(){var t=this.host+"/info?type="+this.dataType+"&key="+this.key;return $.ajax({url:t,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.setLocale=function(t){t&&(this.api_params.locale=t)},GHRequest.prototype.fetchTranslationMap=function(t){t||(t="");var e=this.host+"/i18n/"+t+"?type="+this.dataType+"&key="+this.key;return $.ajax({url:e,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},module.exports=GHRequest;
-
-},{"./GHInput.js":9,"./GHRoute.js":11,"./tools.js":12}],11:[function(require,module,exports){
-var GHInput=require("./GHInput.js"),GHroute=function(){var t=Object.create(Array.prototype);return t=Array.apply(t,arguments)||t,GHroute.injectClassMethods(t),t._listeners={},t};GHroute.injectClassMethods=function(t){for(var e in GHroute.prototype)GHroute.prototype.hasOwnProperty(e)&&(t[e]=GHroute.prototype[e]);return t},GHroute.fromArray=function(t){var e=GHroute.apply(null,t);return e},GHroute.isArray=function(t){var e=Object.prototype.toString.call(t);return"[object array]"===e.toLowerCase()},GHroute.prototype={first:function(){return this.getIndex(0)},last:function(){return this.getIndex(this.length-1)},getIndex:function(t){return t=isNaN(t)?0:t,this[t]instanceof GHInput&&this[t]},getIndexByCoord:function(t){var e,r,i,n=!1,o=new GHInput(t);for(r=0,i=this.length;r<i;r++)if(e=this[r],e.toString()===o.toString()){n=r;break}return n},getIndexFromCoord:function(t){return this.getIndex(this.getIndexByCoord(t))},size:function(){return this.length},add:function(t,e){if(GHroute.isArray(t)){for(var r=0;r<t.length;r++)Array.prototype.push.call(this,t[r]instanceof GHInput?t[r]:new GHInput(t[r])),void 0!==e?(this.move(-1,e,!0),e++):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e});return this}return Array.prototype.push.call(this,t instanceof GHInput?t:new GHInput(t)),void 0!==e?this.move(-1,e,!0):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e}),this[e]},removeSingle:function(t){var e=!1;return isNaN(t)||t>=this.length||void 0===this[t]?(t instanceof GHInput&&(t=t.toString()),e=this.getIndexByCoord(t)):e=t,e!==!1&&this.remove(e),this},remove:function(t,e){var r=e||1;return Array.prototype.splice.call(this,t,r),1===this.length&&Array.prototype.push.call(this,new GHInput),this.fire("route.remove",{from:t,to:r}),this},addAll:function(){for(var t=0;t<arguments.length;t++)this.add(arguments[t]);return this},set:function(t,e,r){if(t instanceof GHInput)this[e]=t;else{if(!(this[e]instanceof GHInput))return!!r&&this.add(t,e);this[e].set(t)}return this.fire("route.set",{point:this[e],to:e}),this[e]},move:function(t,e,r){for(;t<0;)t+=this.length;for(;e<0;)e+=this.length;if(e>=this.length)for(var i=e-this.length;i--+1;)Array.prototype.push.call(this,void 0);return Array.prototype.splice.call(this,e,0,Array.prototype.splice.call(this,t,1)[0]),r||this.fire("route.move",{old_index:t,new_index:e}),this},reverse:function(){return Array.prototype.reverse.call(this),this.fire("route.reverse",{}),this},isResolved:function(){for(var t=0,e=this.length;t<e;t++){var r=this[t];if(!r.isResolved())return!1}return!0},addListener:function(t,e){return"undefined"==typeof this._listeners[t]&&(this._listeners[t]=[]),this._listeners[t].push(e),this},fire:function(t,e){if("string"==typeof t&&(t={type:t}),"object"==typeof e)for(var r in e)t[r]=e[r];if(t.route||(t.route=this),!t.type)throw new Error("Event object missing 'type' property.");if(this._listeners[t.type]instanceof Array)for(var i=this._listeners[t.type],n=0,o=i.length;n<o;n++)i[n].call(this,t)},removeListener:function(t,e){if(this._listeners[t]instanceof Array)for(var r=this._listeners[t],i=0,n=r.length;i<n;i++)if(r[i]===e){r.splice(i,1);break}}},module.exports=GHroute;
-},{"./GHInput.js":9}],12:[function(require,module,exports){
-var decodePath=function(e,d){for(var o=e.length,r=0,a=[],h=0,t=0,c=0;r<o;){var l,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var u=1&i?~(i>>1):i>>1;h+=u,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var n=1&i?~(i>>1):i>>1;if(t+=n,d){v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var s=1&i?~(i>>1):i>>1;c+=s,a.push([1e-5*t,1e-5*h,c/100])}else a.push([1e-5*t,1e-5*h])}return a};module.exports.decodePath=decodePath;
-},{}],13:[function(require,module,exports){
-function addInstruction(t,e,n,a,r){var o=n.sign;o=0===a?"marker-icon-green":messages.getSignName(o);var i=n.text;n.annotation_text&&(i=i?i+", "+n.annotation_text:n.annotation_text);var s=$("<tr class='instruction'/>");if("continue"!==o){var p="<img class='pic' style='vertical-align: middle' src='"+window.location.pathname+"img/"+o+".png'/>";s.append("<td class='instr_pic'>"+p+"</td>")}else s.append("<td class='instr_pic'/>");var c=$("<td class='instr_title'>");c.text(i),s.append(c);var d=n.distance;d>0&&s.append("<td class='instr_distance'><span>"+translate.createDistanceString(d)+"<br/>"+translate.createTimeString(n.time)+"</span></td>"),r&&s.click(function(){routeSegmentPopup&&t.removeLayerFromMap(routeSegmentPopup),routeSegmentPopup=L.popup().setLatLng([r[1],r[0]]).setContent(i).openOn(t.getMap())}),e.append(s)}var translate=require("./translate.js"),messages=require("./messages.js"),routeSegmentPopup=null;module.exports.create=function(t,e,n,a){for(var r=$("<table class='instructions'>"),o=e.instructions.length>100,i=Math.min(e.instructions.length,100),s=0;s<i;s++){var p=e.instructions[s],c=e.points.coordinates[p.interval[0]];addInstruction(t,r,p,s,c)}var d=$("<div class='instructions_info'>");if(d.append(r),o){var l=$("<button id='moreButton'>"+translate.tr("more_button")+"…</button>");l.click(function(){l.remove();for(var n=i;n<e.instructions.length;n++){var a=e.instructions[n],o=e.points.coordinates[a.interval[0]];addInstruction(t,r,a,n,o)}}),r.append(l)}var g=$("<div id='routeDetails'/>");g.hide();var u=$("<button class='expandDetails'>+</button>");u.click(function(){g.toggle()}),d.append(u);var m="points: "+e.points.coordinates.length;g.append("<span>"+m+"</span>");var v=$("#export-link a");v.attr("href",n);var f=$("<br/><a>view on OSM</a>"),h="bicycle";"FOOT"===a.getVehicle().toUpperCase()&&(h="foot"),f.attr("href","http://www.openstreetmap.org/directions?engine=graphhopper_"+h+"&route="+encodeURIComponent(a.from.lat+","+a.from.lng+";"+a.to.lat+","+a.to.lng)),g.append(f);var b=$("<a>OSRM</a>");b.attr("href","http://map.project-osrm.org/?loc="+a.from+"&loc="+a.to),g.append("<br/><span>Compare with: </span>"),g.append(b);var w=$("<a>Google</a> "),x="",_="";"FOOT"===a.getVehicle().toUpperCase()?(x="&dirflg=w",_="&mode=W"):(a.getVehicle().toUpperCase().indexOf("BIKE")>=0||"MTB"===a.getVehicle().toUpperCase())&&(x="&dirflg=b"),w.attr("href","https://maps.google.com/?saddr="+a.from+"&daddr="+a.to+x),g.append(w);var S=$("<a>Bing</a> ");return S.attr("href","https://www.bing.com/maps/default.aspx?rtp=adr."+a.from+"~adr."+a.to+_),g.append(S),metaVersionInfo&&g.append(metaVersionInfo),d.append(g),d};
-},{"./messages.js":22,"./translate.js":28}],14:[function(require,module,exports){
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1},onRemove:function(){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter,d3.select("body").classed(i.theme,!0);var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),n=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){return a(t.dist)}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));this._initToggle();var r=d3.select(n);r.attr("width",i.width);var o=r.append("svg");o.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(){return d3.mouse(o.select("g"))[0]}).y(function(){return this._height()});var d=d3.select(this._container).select("svg").select("g");this._areapath=d.append("path").attr("class","area");var l=this._background=d.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(l.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(l.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=d.append("g"),this._yaxisgraphicnode=d.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=d.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),n},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle",t);i.href="#",i.title="Elevation",L.Browser.touch?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a;a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"";var s=a.split(".");if(s[1]){for(var n=i-s[1].length;n>0;n--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-36).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(){if(this._data&&0!==this._data.length){var t=d3.mouse(this._background.node()),i=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",t[0]).attr("y1",0).attr("x2",t[0]).attr("y2",this._height()).classed("hidden",!1);var e=(d3.bisector(function(t){return t.dist}).left,this._data[this._findItemForX(t[0])]),a=e.altitude,s=e.dist,n=e.latlng,r=i.hoverNumber.formatter(a,i.hoverNumber.decimalsY),o=i.hoverNumber.formatter(s,i.hoverNumber.decimalsX);this._focuslabelX.attr("x",t[0]).text(r+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",t[0]).text(o+" km");var h=this._map.latLngToLayerPoint(n);if(i.useHeightIndicator){if(!this._mouseHeightFocus){var d=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=d.append("svg:line").attr("class","height-focus line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0");var l=this._pointG=d.append("g");l.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class","height-focus circle-lower"),this._mouseHeightFocusLabel=d.append("svg:text").attr("class","height-focus-label").style("pointer-events","none")}var c=this._height()/this._maxElevation*a,_=h.y-c;this._mouseHeightFocus.attr("x1",h.x).attr("x2",h.x).attr("y1",h.y).attr("y2",_).style("visibility","visible"),this._pointG.attr("transform","translate("+h.x+","+h.y+")").style("visibility","visible"),this._mouseHeightFocusLabel.attr("x",h.x).attr("y",_).text(a+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(n):this._marker=new L.Marker(n).addTo(this._map)}},_addGeoJSONData:function(t){if(t){for(var i=this._data||[],e=this._dist||0,a=this._maxElevation||0,s=0;s<t.length;s++){var n=new L.LatLng(t[s][1],t[s][0]),r=new L.LatLng(t[s?s-1:0][1],t[s?s-1:0][0]),o=n.distanceTo(r);e+=Math.round(o/1e3*1e5)/1e5,a=a<t[s][2]?t[s][2]:a,i.push({dist:e,altitude:t[s][2],x:t[s][0],y:t[s][1],latlng:n})}this._dist=e,this._data=i,this._maxElevation=a}},_addGPXdata:function(t){if(t){for(var i=this._data||[],e=this._dist||0,a=this._maxElevation||0,s=0;s<t.length;s++){var n=t[s],r=t[s?s-1:0],o=n.distanceTo(r);e+=Math.round(o/1e3*1e5)/1e5,a=a<n.meta.ele?n.meta.ele:a,i.push({dist:e,altitude:n.meta.ele,x:n.lng,y:n.lat,latlng:n})}this._dist=e,this._data=i,this._maxElevation=a}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}var a=t&&"FeatureCollection"===t.type;if(a)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t){this._addData(t),this._container&&this._applyData()},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
-
-},{}],15:[function(require,module,exports){
-!function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)}(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}t.ui=t.ui||{},t.ui.version="1.12.0";var i=0,s=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,o,n;for(n=0;null!=(o=i[n]);n++)try{s=t._data(o,"events"),s&&s.remove&&t(o).triggerHandler("remove")}catch(r){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var o,n,r,h={},a=e.split(".")[0];e=e.split(".")[1];var l=a+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[a]=t[a]||{},o=t[a][e],n=t[a][e]=function(t,e){return this._createWidget?void(arguments.length&&this._createWidget(t,e)):new n(t,e)},t.extend(n,o,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),r=new i,r.options=t.widget.extend({},r.options),t.each(s,function(e,s){return t.isFunction(s)?void(h[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,n=this._superApply;return this._super=t,this._superApply=o,e=s.apply(this,arguments),this._super=i,this._superApply=n,e}}()):void(h[e]=s)}),n.prototype=t.widget.extend(r,{widgetEventPrefix:o?r.widgetEventPrefix||e:e},h,{constructor:n,namespace:a,widgetName:e,widgetFullName:l}),o?(t.each(o._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,n,i._proto)}),delete o._childConstructors):i._childConstructors.push(n),t.widget.bridge(e,n),n},t.widget.extend=function(e){for(var i,o,n=s.call(arguments,1),r=0,h=n.length;h>r;r++)for(i in n[r])o=n[r][i],n[r].hasOwnProperty(i)&&void 0!==o&&(e[i]=t.isPlainObject(o)?t.isPlainObject(e[i])?t.widget.extend({},e[i],o):t.widget.extend({},o):o);return e},t.widget.bridge=function(e,i){var o=i.prototype.widgetFullName||e;t.fn[e]=function(n){var r="string"==typeof n,h=s.call(arguments,1),a=this;return r?this.each(function(){var i,s=t.data(this,o);return"instance"===n?(a=s,!1):s?t.isFunction(s[n])&&"_"!==n.charAt(0)?(i=s[n].apply(s,h),i!==s&&void 0!==i?(a=i&&i.jquery?a.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; attempted to call method '"+n+"'")}):(h.length&&(n=t.widget.extend.apply(null,[n].concat(h))),this.each(function(){var e=t.data(this,o);e?(e.option(n||{}),e._init&&e._init()):t.data(this,o,new i(n,this))})),a}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,o,n,r=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(r={},s=e.split("."),e=s.shift(),s.length){for(o=r[e]=t.widget.extend({},this.options[e]),n=0;s.length-1>n;n++)o[s[n]]=o[s[n]]||{},o=o[s[n]];if(e=s.pop(),1===arguments.length)return void 0===o[e]?null:o[e];o[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];r[e]=i}return this._setOptions(r),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,o;for(i in e)o=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&o&&o.length&&(s=t(o.get()),this._removeClass(o,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,n){var r,h;for(h=0;i.length>h;h++)r=o.classesElementLookup[i[h]]||t(),r=t(e.add?t.unique(r.get().concat(e.element.get())):r.not(e.element).get()),o.classesElementLookup[i[h]]=r,s.push(i[h]),n&&e.classes[i[h]]&&s.push(e.classes[i[h]])}var s=[],o=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var o="string"==typeof t||null===t,n={extra:o?e:i,keys:o?t:e,element:o?this.element:t,add:s};return n.element.toggleClass(this._classes(n),s),this},_on:function(e,i,s){var o,n=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=o=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,o=this.widget()),t.each(s,function(s,r){function h(){return e||n.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof r?n[r]:r).apply(n,arguments):void 0}"string"!=typeof r&&(h.guid=r.guid=r.guid||h.guid||t.guid++);var a=s.match(/^([\w:-]*)\s*(.*)$/),l=a[1]+n.eventNamespace,c=a[2];c?o.on(l,c,h):i.on(l,h)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var o,n,r=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(o in n)o in i||(i[o]=n[o]);return this.element.trigger(i,s),!(t.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,o,n){"string"==typeof o&&(o={effect:o});var r,h=o?o===!0||"number"==typeof o?i:o.effect||i:e;o=o||{},"number"==typeof o&&(o={duration:o}),r=!t.isEmptyObject(o),o.complete=n,o.delay&&s.delay(o.delay),r&&t.effects&&t.effects.effect[h]?s[e](o):h!==e&&s[h]?s[h](o.duration,o.easing,n):s.queue(function(i){t(this)[e](),n&&n.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(d.test(t[0])?e/100:1),parseFloat(t[1])*(d.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var o,n,r=Math.max,h=Math.abs,a=Math.round,l=/left|center|right/,c=/top|center|bottom/,p=/[\+\-]\d+(\.[\d]+)?%?/,u=/^\w+/,d=/%$/,f=t.fn.position;n=function(){var e=t("<div>").css("position","absolute").appendTo("body").offset({top:1.5,left:1.5}),i=1.5===e.offset().top;return e.remove(),n=function(){return i},i},t.position={scrollbarWidth:function(){if(void 0!==o)return o;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),n=s.children()[0];return t("body").append(s),e=n.offsetWidth,s.css("overflow","scroll"),i=n.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),o=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),o="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,n="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:n?t.position.scrollbarWidth():0,height:o?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),o=!!i[0]&&9===i[0].nodeType,n=!s&&!o;return{element:i,isWindow:s,isDocument:o,offset:n?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(o){if(!o||!o.of)return f.apply(this,arguments);o=t.extend({},o);var d,g,m,_,v,b,w=t(o.of),y=t.position.getWithinInfo(o.within),P=t.position.getScrollInfo(y),x=(o.collision||"flip").split(" "),z={};return b=s(w),w[0].preventDefault&&(o.at="left top"),g=b.width,m=b.height,_=b.offset,v=t.extend({},_),t.each(["my","at"],function(){var t,e,i=(o[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):c.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=c.test(i[1])?i[1]:"center",t=p.exec(i[0]),e=p.exec(i[1]),z[this]=[t?t[0]:0,e?e[0]:0],o[this]=[u.exec(i[0])[0],u.exec(i[1])[0]]}),1===x.length&&(x[1]=x[0]),"right"===o.at[0]?v.left+=g:"center"===o.at[0]&&(v.left+=g/2),"bottom"===o.at[1]?v.top+=m:"center"===o.at[1]&&(v.top+=m/2),d=e(z.at,g,m),v.left+=d[0],v.top+=d[1],this.each(function(){var s,l,c=t(this),p=c.outerWidth(),u=c.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),C=p+f+i(this,"marginRight")+P.width,H=u+b+i(this,"marginBottom")+P.height,T=t.extend({},v),k=e(z.my,c.outerWidth(),c.outerHeight());"right"===o.my[0]?T.left-=p:"center"===o.my[0]&&(T.left-=p/2),"bottom"===o.my[1]?T.top-=u:"center"===o.my[1]&&(T.top-=u/2),T.left+=k[0],T.top+=k[1],n()||(T.left=a(T.left),T.top=a(T.top)),s={marginLeft:f,marginTop:b},t.each(["left","top"],function(e,i){t.ui.position[x[e]]&&t.ui.position[x[e]][i](T,{targetWidth:g,targetHeight:m,elemWidth:p,elemHeight:u,collisionPosition:s,collisionWidth:C,collisionHeight:H,offset:[d[0]+k[0],d[1]+k[1]],my:o.my,at:o.at,within:y,elem:c})}),o.using&&(l=function(t){var e=_.left-T.left,i=e+g-p,s=_.top-T.top,n=s+m-u,a={target:{element:w,left:_.left,top:_.top,width:g,height:m},element:{element:c,left:T.left,top:T.top,width:p,height:u},horizontal:0>i?"left":e>0?"right":"center",vertical:0>n?"top":s>0?"bottom":"middle"};p>g&&g>h(e+i)&&(a.horizontal="center"),u>m&&m>h(s+n)&&(a.vertical="middle"),a.important=r(h(e),h(i))>r(h(s),h(n))?"horizontal":"vertical",o.using.call(this,t,a)}),c.offset(t.extend(T,{using:l}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollLeft:s.offset.left,n=s.width,h=t.left-e.collisionPosition.marginLeft,a=o-h,l=h+e.collisionWidth-n-o;e.collisionWidth>n?a>0&&0>=l?(i=t.left+a+e.collisionWidth-n-o,t.left+=a-i):t.left=l>0&&0>=a?o:a>l?o+n-e.collisionWidth:o:a>0?t.left+=a:l>0?t.left-=l:t.left=r(t.left-h,t.left)},top:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollTop:s.offset.top,n=e.within.height,h=t.top-e.collisionPosition.marginTop,a=o-h,l=h+e.collisionHeight-n-o;e.collisionHeight>n?a>0&&0>=l?(i=t.top+a+e.collisionHeight-n-o,t.top+=a-i):t.top=l>0&&0>=a?o:a>l?o+n-e.collisionHeight:o:a>0?t.top+=a:l>0?t.top-=l:t.top=r(t.top-h,t.top)}},flip:{left:function(t,e){var i,s,o=e.within,n=o.offset.left+o.scrollLeft,r=o.width,a=o.isWindow?o.scrollLeft:o.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-a,p=l+e.collisionWidth-r-a,u="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,d="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+u+d+f+e.collisionWidth-r-n,(0>i||h(c)>i)&&(t.left+=u+d+f)):p>0&&(s=t.left-e.collisionPosition.marginLeft+u+d+f-a,(s>0||p>h(s))&&(t.left+=u+d+f))},top:function(t,e){var i,s,o=e.within,n=o.offset.top+o.scrollTop,r=o.height,a=o.isWindow?o.scrollTop:o.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-a,p=l+e.collisionHeight-r-a,u="top"===e.my[1],d=u?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+d+f+g+e.collisionHeight-r-n,(0>s||h(c)>s)&&(t.top+=d+f+g)):p>0&&(i=t.top-e.collisionPosition.marginTop+d+f+g-a,(i>0||p>h(i))&&(t.top+=d+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}}),t.ui.focusable=function(i,s){var o,n,r,h,a,l=i.nodeName.toLowerCase();return"area"===l?(o=i.parentNode,n=o.name,!(!i.href||!n||"map"!==o.nodeName.toLowerCase())&&(r=t("img[usemap='#"+n+"']"),r.length>0&&r.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(l)?(h=!i.disabled,h&&(a=t(i).closest("fieldset")[0],a&&(h=!a.disabled))):h="a"===l?i.href||s:s,h&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,n){return t.each(o,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),n&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var o="Width"===i?["Left","Right"]:["Top","Bottom"],n=i.toLowerCase(),r={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?r["inner"+i].call(this):this.each(function(){t(this).css(n,s(this,e)+"px")})},t.fn["outer"+i]=function(e,o){return"number"!=typeof e?r["outer"+i].call(this,e):this.each(function(){t(this).css(n,s(this,e,!0,o)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,o,n;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(o=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),n=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",o=o.add(n.find(i).addBack(i))),this.pushStack(o))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,o=e?/(auto|scroll|hidden)/:/(auto|scroll)/,n=this.parents().filter(function(){var e=t(this);return(!s||"static"!==e.css("position"))&&o.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&n.length?n:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var o=!1;t(document).on("mouseup",function(){o=!1}),t.widget("ui.mouse",{version:"1.12.0",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!o){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n=!("string"!=typeof this.options.cancel||!e.target.nodeName)&&t(e.target).closest(this.options.cancel).length;return!(s&&!n&&this._mouseCapture(e))||(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),o=!0,!0))}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,o=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var o,n=t.ui[e].prototype;for(o in s)n.plugins[o]=n.plugins[o]||[],n.plugins[o].push([i,s[o]])},call:function(t,e,i,s){var o,n=t.plugins[e];if(n&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(o=0;n.length>o;o++)t.options[n[o][0]]&&n[o][1].apply(t.element,i)}},t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?void(this.destroyOnClear=!0):(this._removeHandleClassName(),void this._mouseDestroy())},_mouseCapture:function(e){var i=this.options;return this._blurActiveElement(e),!(this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0)&&(this.handle=this._getHandle(e),!!this.handle&&(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0))},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);this._getHandle(e)&&s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return!this.options.handle||!!t(e.target).closest(this.element.find(this.options.handle)).length},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),o=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return o.parents("body").length||o.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&o[0]===this.element[0]&&this._setPositionRelative(),o[0]===this.element[0]||/(fixed|absolute)/.test(o.css("position"))||o.css("position","absolute"),o},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options,n=this.document[0];return this.relativeContainer=null,o.containment?"window"===o.containment?void(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):"document"===o.containment?void(this.containment=[0,0,t(n).width()-this.helperProportions.width-this.margins.left,(t(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):o.containment.constructor===Array?void(this.containment=o.containment):("parent"===o.containment&&(o.containment=this.helper[0].parentNode),i=t(o.containment),s=i[0],void(s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i))):void(this.containment=null)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,o,n,r=this.options,h=this._isRootNode(this.scrollParent[0]),a=t.pageX,l=t.pageY;return h&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(a=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(a=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),r.grid&&(o=r.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/r.grid[1])*r.grid[1]:this.originalPageY,l=i?o-this.offset.click.top>=i[1]||o-this.offset.click.top>i[3]?o:o-this.offset.click.top>=i[1]?o-r.grid[1]:o+r.grid[1]:o,n=r.grid[0]?this.originalPageX+Math.round((a-this.originalPageX)/r.grid[0])*r.grid[0]:this.originalPageX,a=i?n-this.offset.click.left>=i[0]||n-this.offset.click.left>i[2]?n:n-this.offset.click.left>=i[0]?n-r.grid[0]:n+r.grid[0]:n),"y"===r.axis&&(a=this.originalPageX),"x"===r.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:h?0:this.offset.scroll.top),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:h?0:this.offset.scroll.left)
-}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var o=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,o))})},stop:function(e,i,s){var o=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,o))})},drag:function(e,i,s){t.each(s.sortables,function(){var o=!1,n=this;n.positionAbs=s.positionAbs,n.helperProportions=s.helperProportions,n.offset.click=s.offset.click,n._intersectsWith(n.containerCache)&&(o=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==n&&this._intersectsWith(this.containerCache)&&t.contains(n.element[0],this.element[0])&&(o=!1),o})),o?(n.isOver||(n.isOver=1,s._parent=i.helper.parent(),n.currentItem=i.helper.appendTo(n.element).data("ui-sortable-item",!0),n.options._helper=n.options.helper,n.options.helper=function(){return i.helper[0]},e.target=n.currentItem[0],n._mouseCapture(e,!0),n._mouseStart(e,!0,!0),n.offset.click.top=s.offset.click.top,n.offset.click.left=s.offset.click.left,n.offset.parent.left-=s.offset.parent.left-n.offset.parent.left,n.offset.parent.top-=s.offset.parent.top-n.offset.parent.top,s._trigger("toSortable",e),s.dropped=n.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,n.fromOutside=s),n.currentItem&&(n._mouseDrag(e),i.position=n.position)):n.isOver&&(n.isOver=0,n.cancelHelperRemoval=!0,n.options._revert=n.options.revert,n.options.revert=!1,n._trigger("out",e,n._uiHash(n)),n._mouseStop(e,!0),n.options.revert=n.options._revert,n.options.helper=n.options._helper,n.placeholder&&n.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var o=t("body"),n=s.options;o.css("cursor")&&(n._cursor=o.css("cursor")),o.css("cursor",n.cursor)},stop:function(e,i,s){var o=s.options;o._cursor&&t("body").css("cursor",o._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("opacity")&&(n._opacity=o.css("opacity")),o.css("opacity",n.opacity)},stop:function(e,i,s){var o=s.options;o._opacity&&t(i.helper).css("opacity",o._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var o=s.options,n=!1,r=s.scrollParentNotHidden[0],h=s.document[0];r!==h&&"HTML"!==r.tagName?(o.axis&&"x"===o.axis||(s.overflowOffset.top+r.offsetHeight-e.pageY<o.scrollSensitivity?r.scrollTop=n=r.scrollTop+o.scrollSpeed:e.pageY-s.overflowOffset.top<o.scrollSensitivity&&(r.scrollTop=n=r.scrollTop-o.scrollSpeed)),o.axis&&"y"===o.axis||(s.overflowOffset.left+r.offsetWidth-e.pageX<o.scrollSensitivity?r.scrollLeft=n=r.scrollLeft+o.scrollSpeed:e.pageX-s.overflowOffset.left<o.scrollSensitivity&&(r.scrollLeft=n=r.scrollLeft-o.scrollSpeed))):(o.axis&&"x"===o.axis||(e.pageY-t(h).scrollTop()<o.scrollSensitivity?n=t(h).scrollTop(t(h).scrollTop()-o.scrollSpeed):t(window).height()-(e.pageY-t(h).scrollTop())<o.scrollSensitivity&&(n=t(h).scrollTop(t(h).scrollTop()+o.scrollSpeed))),o.axis&&"y"===o.axis||(e.pageX-t(h).scrollLeft()<o.scrollSensitivity?n=t(h).scrollLeft(t(h).scrollLeft()-o.scrollSpeed):t(window).width()-(e.pageX-t(h).scrollLeft())<o.scrollSensitivity&&(n=t(h).scrollLeft(t(h).scrollLeft()+o.scrollSpeed)))),n!==!1&&t.ui.ddmanager&&!o.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var o=s.options;s.snapElements=[],t(o.snap.constructor!==String?o.snap.items||":data(ui-draggable)":o.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var o,n,r,h,a,l,c,p,u,d,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(u=s.snapElements.length-1;u>=0;u--)a=s.snapElements[u].left-s.margins.left,l=a+s.snapElements[u].width,c=s.snapElements[u].top-s.margins.top,p=c+s.snapElements[u].height,a-g>_||m>l+g||c-g>b||v>p+g||!t.contains(s.snapElements[u].item.ownerDocument,s.snapElements[u].item)?(s.snapElements[u].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=!1):("inner"!==f.snapMode&&(o=g>=Math.abs(c-b),n=g>=Math.abs(p-v),r=g>=Math.abs(a-_),h=g>=Math.abs(l-m),o&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a-s.helperProportions.width}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),d=o||n||r||h,"outer"!==f.snapMode&&(o=g>=Math.abs(c-v),n=g>=Math.abs(p-b),r=g>=Math.abs(a-m),h=g>=Math.abs(l-_),o&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p-s.helperProportions.height,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[u].snapping&&(o||n||r||h||d)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=o||n||r||h||d)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var o,n=s.options,r=t.makeArray(t(n.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});r.length&&(o=parseInt(t(r[0]).css("zIndex"),10)||0,t(r).each(function(e){t(this).css("zIndex",o+e)}),this.css("zIndex",o+r.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("zIndex")&&(n._zIndex=o.css("zIndex")),o.css("zIndex",n.zIndex)},stop:function(e,i,s){var o=s.options;o._zIndex&&t(i.helper).css("zIndex",o._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",o=!1;return e[s]>0||(e[s]=1,o=e[s]>0,e[s]=0,o)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles()}},_setupHandles:function(){var e,i,s,o,n,r=this.options,h=this;if(this.handles=r.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),o="ui-resizable-"+e,n=t("<div>"),this._addClass(n,"ui-resizable-handle "+o),n.css({zIndex:r.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(n);this._renderAxis=function(e){var i,s,o,n;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:h._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),n=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),o=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(o,n),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){h.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),h.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,o=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(o=!0);return!this.options.disabled&&o},_mouseStart:function(e){var i,s,o,n=this.options,r=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),n.containment&&(i+=t(n.containment).scrollLeft()||0,s+=t(n.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:r.width(),height:r.height()},this.originalSize=this._helper?{width:r.outerWidth(),height:r.outerHeight()}:{width:r.width(),height:r.height()},this.sizeDiff={width:r.outerWidth()-r.width(),height:r.outerHeight()-r.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof n.aspectRatio?n.aspectRatio:this.originalSize.width/this.originalSize.height||1,o=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===o?this.axis+"-resize":o),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,o=this.originalMousePosition,n=this.axis,r=e.pageX-o.left||0,h=e.pageY-o.top||0,a=this._change[n];return this._updatePrevProperties(),!!a&&(i=a.apply(this,[e,r,h]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1)},_mouseStop:function(e){this.resizing=!1;var i,s,o,n,r,h,a,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),o=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,n=s?0:c.sizeDiff.width,r={width:c.helper.width()-n,height:c.helper.height()-o},h=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,a=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(r,{top:a,left:h})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,o,n,r=this.options;n={minWidth:this._isNumber(r.minWidth)?r.minWidth:0,maxWidth:this._isNumber(r.maxWidth)?r.maxWidth:1/0,minHeight:this._isNumber(r.minHeight)?r.minHeight:0,maxHeight:this._isNumber(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||t)&&(e=n.minHeight*this.aspectRatio,s=n.minWidth/this.aspectRatio,i=n.maxHeight*this.aspectRatio,o=n.maxWidth/this.aspectRatio,e>n.minWidth&&(n.minWidth=e),s>n.minHeight&&(n.minHeight=s),n.maxWidth>i&&(n.maxWidth=i),n.maxHeight>o&&(n.maxHeight=o)),this._vBoundaries=n},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,o=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,n=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,r=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,h=this.originalPosition.left+this.originalSize.width,a=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return n&&(t.width=e.minWidth),r&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),o&&(t.height=e.maxHeight),n&&l&&(t.left=h-e.minWidth),s&&l&&(t.left=h-e.maxWidth),r&&c&&(t.top=a-e.minHeight),o&&c&&(t.top=a-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],o=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(o[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,o=this.originalPosition;return{top:o.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,o=i._proportionallyResizeElements,n=o.length&&/textarea/i.test(o[0].nodeName),r=n&&i._hasScroll(o[0],"left")?0:i.sizeDiff.height,h=n?0:i.sizeDiff.width,a={width:i.size.width-h,height:i.size.height-r},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(a,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};o&&o.length&&t(o[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,o,n,r,h,a=t(this).resizable("instance"),l=a.options,c=a.element,p=l.containment,u=p instanceof t?p.get(0):/parent/.test(p)?c.parent().get(0):p;u&&(a.containerElement=t(u),/document/.test(p)||p===document?(a.containerOffset={left:0,top:0},a.containerPosition={left:0,top:0},a.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(u),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=a._num(e.css("padding"+s))}),a.containerOffset=e.offset(),a.containerPosition=e.position(),a.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=a.containerOffset,o=a.containerSize.height,n=a.containerSize.width,r=a._hasScroll(u,"left")?u.scrollWidth:n,h=a._hasScroll(u)?u.scrollHeight:o,a.parentData={element:u,left:s.left,top:s.top,width:r,height:h}))},resize:function(e){var i,s,o,n,r=t(this).resizable("instance"),h=r.options,a=r.containerOffset,l=r.position,c=r._aspectRatio||e.shiftKey,p={top:0,left:0},u=r.containerElement,d=!0;u[0]!==document&&/static/.test(u.css("position"))&&(p=a),l.left<(r._helper?a.left:0)&&(r.size.width=r.size.width+(r._helper?r.position.left-a.left:r.position.left-p.left),c&&(r.size.height=r.size.width/r.aspectRatio,d=!1),r.position.left=h.helper?a.left:0),l.top<(r._helper?a.top:0)&&(r.size.height=r.size.height+(r._helper?r.position.top-a.top:r.position.top),c&&(r.size.width=r.size.height*r.aspectRatio,d=!1),r.position.top=r._helper?a.top:0),o=r.containerElement.get(0)===r.element.parent().get(0),n=/relative|absolute/.test(r.containerElement.css("position")),o&&n?(r.offset.left=r.parentData.left+r.position.left,r.offset.top=r.parentData.top+r.position.top):(r.offset.left=r.element.offset().left,r.offset.top=r.element.offset().top),i=Math.abs(r.sizeDiff.width+(r._helper?r.offset.left-p.left:r.offset.left-a.left)),s=Math.abs(r.sizeDiff.height+(r._helper?r.offset.top-p.top:r.offset.top-a.top)),i+r.size.width>=r.parentData.width&&(r.size.width=r.parentData.width-i,c&&(r.size.height=r.size.width/r.aspectRatio,d=!1)),s+r.size.height>=r.parentData.height&&(r.size.height=r.parentData.height-s,c&&(r.size.width=r.size.height*r.aspectRatio,d=!1)),d||(r.position.left=r.prevPosition.left,r.position.top=r.prevPosition.top,r.size.width=r.prevSize.width,r.size.height=r.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,o=e.containerPosition,n=e.containerElement,r=t(e.helper),h=r.offset(),a=r.outerWidth()-e.sizeDiff.width,l=r.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l}),e._helper&&!i.animate&&/static/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),o=s.options,n=s.originalSize,r=s.originalPosition,h={height:s.size.height-n.height||0,width:s.size.width-n.width||0,top:s.position.top-r.top||0,left:s.position.left-r.left||0};t(o.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),o={},n=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(n,function(t,e){var i=(s[e]||0)+(h[e]||0);i&&i>=0&&(o[e]=i||null)}),e.css(o)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,o=i.size,n=i.originalSize,r=i.originalPosition,h=i.axis,a="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=a[0]||1,c=a[1]||1,p=Math.round((o.width-n.width)/l)*l,u=Math.round((o.height-n.height)/c)*c,d=n.width+p,f=n.height+u,g=s.maxWidth&&d>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>d,v=s.minHeight&&s.minHeight>f;s.grid=a,_&&(d+=l),v&&(f+=c),g&&(d-=l),m&&(f-=c),/^(se|s|e)$/.test(h)?(i.size.width=d,i.size.height=f):/^(ne)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.top=r.top-u):/^(sw)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.left=r.left-p):((0>=f-c||0>=d-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=r.top-u):(f=c-e.height,i.size.height=f,i.position.top=r.top+n.height-f),d-l>0?(i.size.width=d,i.position.left=r.left-p):(d=l-e.width,i.size.width=d,i.position.left=r.left+n.width-d))}}),t.ui.resizable,t.widget("ui.sortable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,o=!1,n=this;return!this.reverting&&(!this.options.disabled&&"static"!==this.options.type&&(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,n.widgetName+"-item")===n?(s=t(this),!1):void 0}),t.data(e.target,n.widgetName+"-item")===n&&(s=t(e.target)),!!s&&(!(this.options.handle&&!i&&(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(o=!0)}),!o))&&(this.currentItem=s,this._removeCurrentsFromItems(),!0))))},_mouseStart:function(e,i,s){var o,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=t("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(o=this.containers.length-1;o>=0;o--)this.containers[o]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,o,n,r=this.options,h=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop+r.scrollSpeed:e.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft+r.scrollSpeed:e.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(e.pageY-this.document.scrollTop()<r.scrollSensitivity?h=this.document.scrollTop(this.document.scrollTop()-r.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<r.scrollSensitivity&&(h=this.document.scrollTop(this.document.scrollTop()+r.scrollSpeed)),e.pageX-this.document.scrollLeft()<r.scrollSensitivity?h=this.document.scrollLeft(this.document.scrollLeft()-r.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<r.scrollSensitivity&&(h=this.document.scrollLeft(this.document.scrollLeft()+r.scrollSpeed))),h!==!1&&t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],o=s.item[0],n=this._intersectsWithPointer(s),n&&s.instance===this.currentContainer&&o!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==o&&!t.contains(this.placeholder[0],o)&&("semi-dynamic"!==this.options.type||!t.contains(this.element[0],o))){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),
-this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,o=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=o.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=o.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,o=s+this.helperProportions.height,n=t.left,r=n+t.width,h=t.top,a=h+t.height,l=this.offset.click.top,c=this.offset.click.left,p="x"===this.options.axis||s+l>h&&a>s+l,u="y"===this.options.axis||e+c>n&&r>e+c,d=p&&u;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?d:e+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>h&&a>o-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),o="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),n=s&&o;return!!n&&(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1))},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return this.floating&&o?"right"===o&&i||"left"===o&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){h.push(this)}var s,o,n,r,h=[],a=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(n=t(l[s],this.document[0]),o=n.length-1;o>=0;o--)r=t.data(n[o],this.widgetFullName),r&&r!==this&&!r.options.disabled&&a.push([t.isFunction(r.options.items)?r.options.items.call(r.element):t(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(a.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=a.length-1;s>=0;s--)a[s][0].each(i);return t(h)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,o,n,r,h,a,l,c=this.items,p=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],u=this._connectWith();if(u&&this.ready)for(i=u.length-1;i>=0;i--)for(o=t(u[i],this.document[0]),s=o.length-1;s>=0;s--)n=t.data(o[s],this.widgetFullName),n&&n!==this&&!n.options.disabled&&(p.push([t.isFunction(n.options.items)?n.options.items.call(n.element[0],e,{item:this.currentItem}):t(n.options.items,n.element),n]),this.containers.push(n));for(i=p.length-1;i>=0;i--)for(r=p[i][1],h=p[i][0],s=0,l=h.length;l>s;s++)a=t(h[s]),a.data(this.widgetName+"-item",r),c.push({item:a,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=!!this.items.length&&("x"===this.options.axis||this._isFloating(this.items[0].item)),this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,o,n;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(o=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=o.outerWidth(),s.height=o.outerHeight()),n=o.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),o=t("<"+s+">",e.document[0]);return e._addClass(o,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(o,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(o)):"tr"===s?e._createTrPlaceholder(e.currentItem,o):"img"===s&&o.attr("src",e.currentItem.attr("src")),i||o.css("visibility","hidden"),o},update:function(t,o){(!i||s.forcePlaceholderSize)&&(o.height()||o.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),o.width()||o.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,o,n,r,h,a,l,c,p,u=null,d=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(u&&t.contains(this.containers[i].element[0],u.element[0]))continue;u=this.containers[i],d=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(u)if(1===this.containers.length)this.containers[d].containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1);else{for(o=1e4,n=null,c=u.floating||this._isFloating(this.currentItem),r=c?"left":"top",h=c?"width":"height",p=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[d].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(a=this.items[s].item.offset()[r],l=!1,e[p]-a>this.items[s][h]/2&&(l=!0),o>Math.abs(e[p]-a)&&(o=Math.abs(e[p]-a),n=this.items[s],this.direction=l?"up":"down"));if(!n&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[d])return void(this.currentContainer.containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1));n?this._rearrange(e,n,null,!0):this._rearrange(e,null,this.containers[d].element,!0),this._trigger("change",e,this._uiHash()),this.containers[d]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[d],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options;"parent"===o.containment&&(o.containment=this.helper[0].parentNode),("document"===o.containment||"window"===o.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===o.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===o.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(o.containment)||(e=t(o.containment)[0],i=t(o.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,o="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(o[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:o.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:o.scrollLeft())*s}},_generatePosition:function(e){var i,s,o=this.options,n=e.pageX,r=e.pageY,h="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(h[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),o.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/o.grid[1])*o.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-o.grid[1]:i+o.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/o.grid[0])*o.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-o.grid[0]:s+o.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:h.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:h.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var o=this.counter;this._delay(function(){o===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,o=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&o.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||o.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(o.push(function(t){this._trigger("remove",t,this._uiHash())}),o.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),o.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||o.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(o.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;o.length>s;s++)o[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}});var n=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.0",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,o){var n,r={};return o?"controlgroupLabel"===s?(n=e.element.find(o),n.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(n,null,"ui-widget ui-widget-content ui-state-default"),void(i=i.concat(n.get()))):void(t.fn[s]&&(e["_"+s+"Options"]&&(r=e["_"+s+"Options"]("middle")),e.element.find(o).each(function(){var o=t(this),n=o[s]("instance"),h=t.widget.extend({},r);if("button"!==s||!o.parent(".ui-spinner").length){n||(n=o[s]()[s]("instance")),n&&(h.classes=e._resolveClassesValues(h.classes,n)),o[s](h);var a=o[s]("widget");t.data(a[0],"ui-controlgroup-data",n?n:o[s]("instance")),i.push(a[0])}}))):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:!!e&&"auto",classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(t){var o=i.options.classes[t]||"";o=o.replace(n,"").trim(),s[t]=(o+" "+e[t]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?void this._callChildMethod(e?"disable":"enable"):void this.refresh()},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var o=e[s]().data("ui-controlgroup-data");if(o&&i["_"+o.widgetName+"Options"]){var n=i["_"+o.widgetName+"Options"](1===e.length?"only":s);n.classes=i._resolveClassesValues(n.classes,o),o.element[o.widgetName](n)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.0",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,o=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(o.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(o.disabled=e),o},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),void(this.element[0].disabled=e)):void this.refresh()):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){this.label.contents().not(this.element.add(this.icon).add(this.iconSpace)).remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.0",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,o=s?this.options.iconPosition:i,n="top"===o||"bottom"===o;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(o),n?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(o))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?void this._super("showLabel",e):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),void this._superApply(arguments))}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.widget("ui.dialog",{version:"1.12.0",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",
-at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,o=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),n=Math.max.apply(null,o);return n>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",n+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?void(this._moveToTop()&&this._focusTabbable()):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),void this._trigger("open"))},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),void this.close(e);if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),o=i.filter(":last");e.target!==o[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){o.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?void this._removeClass(this.uiDialog,"ui-dialog-buttons"):(t.each(i,function(i,s){var o,n;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),o=s.click,n={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,t("<button></button>",s).button(n).appendTo(e.uiButtonSet).on("click",function(){o.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),void this.uiDialogButtonPane.appendTo(this.uiDialog))},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,o){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(o))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(o,n){var r=n.offset.left-i.document.scrollLeft(),h=n.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",o,e(n))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,o=s.resizable,n=this.uiDialog.css("position"),r="string"==typeof o?o:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:r,start:function(s,o){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(o))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(o,n){var r=i.uiDialog.offset(),h=r.left-i.document.scrollLeft(),a=r.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(h>=0?"+":"")+h+" top"+(a>=0?"+":"")+a,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",o,e(n))}}).css("position",n)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,o={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(o[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",o)},_setOption:function(e,i){var s,o,n=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=n.is(":data(ui-draggable)"),s&&!i&&n.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(o=n.is(":data(ui-resizable)"),o&&!i&&n.resizable("destroy"),o&&"string"==typeof i&&n.resizable("option","handles",i),o||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return!!t(e.target).closest(".ui-dialog").length||!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog});
+function round(t,n){return void 0===n&&(n=1e6),Math.round(t*n)/n}var GHInput=function(t){this.set(t)};GHInput.isObject=function(t){var n=Object.prototype.toString.call(t);return"[object object]"===n.toLowerCase()},GHInput.isString=function(t){var n=Object.prototype.toString.call(t);return"[object string]"===n.toLowerCase()},GHInput.prototype.isResolved=function(){return!isNaN(this.lat)&&!isNaN(this.lng)},GHInput.prototype.setCoord=function(t,n){this.lat=round(t),this.lng=round(n),this.input=this.toString()},GHInput.prototype.setUnresolved=function(){this.lat=void 0,this.lng=void 0},GHInput.prototype.set=function(t){if(this.input=t,GHInput.isObject(t))this.setCoord(t.lat,t.lng);else if(GHInput.isString(t)){var n=t.indexOf(",");n>=0?(this.lat=round(parseFloat(t.substr(0,n))),this.lng=round(parseFloat(t.substr(n+1))),this.isResolved()?this.input=this.toString():this.setUnresolved()):this.setUnresolved()}},GHInput.prototype.toString=function(){return void 0!==this.lat&&void 0!==this.lng?this.lat+","+this.lng:void 0},module.exports=GHInput;
+
+},{}],11:[function(require,module,exports){
+var GHRoute=require("./GHRoute.js"),GHInput=require("./GHInput.js"),graphhopperTools=require("./tools.js");Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),i=this,o=function(){},s=function(){return i.apply(this instanceof o&&t?this:t,e.concat(Array.prototype.slice.call(arguments)))};return o.prototype=this.prototype,s.prototype=new o,s});var GHRequest=function(t,e){this.host=t,this.key=e,this.route=new GHRoute(new GHInput,new GHInput),this.from=this.route.first(),this.to=this.route.last(),this.features={},this.do_zoom=!0,this.useMiles=!1,this.dataType="json",this.api_params={locale:"en",vehicle:"car",weighting:"fastest",elevation:!1},this.route.addListener("route.add",function(t){this.to=this.route.last()}.bind(this)),this.route.addListener("route.remove",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.move",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.reverse",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this))};GHRequest.prototype.init=function(t){for(var e in t){var i=t[e];"false"===i?i=!1:"true"===i&&(i=!0),"point"!==e&&"mathRandom"!==e&&"do_zoom"!==e&&"layer"!==e&&"use_miles"!==e&&(this.api_params[e]=i)}"do_zoom"in t&&(this.do_zoom=t.do_zoom),"use_miles"in t&&(this.useMiles=t.use_miles),this.api_params.elevation=!1;var o=this.features[this.api_params.vehicle];if(o&&o.elevation&&("elevation"in t?this.api_params.elevation=t.elevation:this.api_params.elevation=!0),t.q){var s=t.q;t.point||(t.point=[]);var r=s.indexOf("from:"),a=s.indexOf("to:");if(r>=0&&a>=0)a>r?(t.point.push(s.substring(r+5,a).trim()),t.point.push(s.substring(a+3).trim())):(t.point.push(s.substring(a+3,r).trim()),t.point.push(s.substring(r+5).trim()));else for(var n=s.split("p:"),p=0;p<n.length;p++){var h=n[p].trim();0!==h.length&&t.point.push(h)}}},GHRequest.prototype.initVehicle=function(t){this.api_params.vehicle=t;var e=this.features[t];e&&e.elevation?this.api_params.elevation=!0:this.api_params.elevation=!1},GHRequest.prototype.hasElevation=function(){return this.api_params.elevation},GHRequest.prototype.getVehicle=function(){return this.api_params.vehicle},GHRequest.prototype.createGeocodeURL=function(t,e){var i=this.host;t&&(i=t);var o=this.createPath(i+"/geocode?limit=6&type="+this.dataType+"&key="+this.key);if(e>=0&&e<this.route.size()){var s=this.route.getIndex(e);s.isResolved()&&(o+="&point="+s.lat+","+s.lng)}return o},GHRequest.prototype.createURL=function(){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type="+this.dataType+"&key="+this.key)},GHRequest.prototype.createGPXURL=function(t,e,i){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type=gpx&key="+this.key+"&gpx.route="+t+"&gpx.track="+e+"&gpx.waypoints="+i)},GHRequest.prototype.createHistoryURL=function(){return this.createPath("?"+this.createPointParams(!0))+"&use_miles="+!!this.useMiles},GHRequest.prototype.createPointParams=function(t){var e,i,o,s="";for(i=0,o=this.route.size();o>i;i++)e=this.route.getIndex(i),i>0&&(s+="&"),s+=t?"point="+encodeURIComponent(e.input):"point="+encodeURIComponent(e.toString());return s},GHRequest.prototype.createPath=function(t){for(var e in this.api_params){var i=this.api_params[e];if(GHRoute.isArray(i))for(var o in i)t+="&"+encodeURIComponent(e)+"="+encodeURIComponent(i[o]);else t+="&"+encodeURIComponent(e)+"="+encodeURIComponent(i)}return t},GHRequest.prototype.doRequest=function(t,e){var i=this;$.ajax({timeout:3e4,url:t,success:function(t){if(t.paths)for(var o=0;o<t.paths.length;o++){var s=t.paths[o];if(s.points_encoded){var r=graphhopperTools.decodePath(s.points,i.hasElevation());s.points={type:"LineString",coordinates:r};var a=graphhopperTools.decodePath(s.snapped_waypoints,i.hasElevation());s.snapped_waypoints={type:"MultiPoint",coordinates:a}}}e(t)},error:function(i){var o,s="API did not respond! ";if(i&&i.responseText&&i.responseText.indexOf("{")>=0)o=JSON.parse(i.responseText);else if(i&&i.statusText&&"OK"!==i.statusText){s+=i.statusText;var r="Error for "+t;o={message:s,hints:[{message:s,details:r}]}}console.log(s+" "+JSON.stringify(i)),e(o)},type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.getInfo=function(){var t=this.host+"/info?type="+this.dataType+"&key="+this.key;return $.ajax({url:t,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.setLocale=function(t){t&&(this.api_params.locale=t)},GHRequest.prototype.fetchTranslationMap=function(t){t||(t="");var e=this.host+"/i18n/"+t+"?type="+this.dataType+"&key="+this.key;return $.ajax({url:e,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},module.exports=GHRequest;
+
+},{"./GHInput.js":10,"./GHRoute.js":12,"./tools.js":13}],12:[function(require,module,exports){
+var GHInput=require("./GHInput.js"),GHroute=function(){var t=Object.create(Array.prototype);return t=Array.apply(t,arguments)||t,GHroute.injectClassMethods(t),t._listeners={},t};GHroute.injectClassMethods=function(t){for(var e in GHroute.prototype)GHroute.prototype.hasOwnProperty(e)&&(t[e]=GHroute.prototype[e]);return t},GHroute.fromArray=function(t){var e=GHroute.apply(null,t);return e},GHroute.isArray=function(t){var e=Object.prototype.toString.call(t);return"[object array]"===e.toLowerCase()},GHroute.prototype={first:function(){return this.getIndex(0)},last:function(){return this.getIndex(this.length-1)},getIndex:function(t){return t=isNaN(t)?0:t,this[t]instanceof GHInput?this[t]:!1},getIndexByCoord:function(t){var e,r,i,n=!1,o=new GHInput(t);for(r=0,i=this.length;i>r;r++)if(e=this[r],e.toString()===o.toString()){n=r;break}return n},getIndexFromCoord:function(t){return this.getIndex(this.getIndexByCoord(t))},size:function(){return this.length},add:function(t,e){if(GHroute.isArray(t)){for(var r=0;r<t.length;r++)Array.prototype.push.call(this,t[r]instanceof GHInput?t[r]:new GHInput(t[r])),void 0!==e?(this.move(-1,e,!0),e++):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e});return this}return Array.prototype.push.call(this,t instanceof GHInput?t:new GHInput(t)),void 0!==e?this.move(-1,e,!0):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e}),this[e]},removeSingle:function(t){var e=!1;return isNaN(t)||t>=this.length||void 0===this[t]?(t instanceof GHInput&&(t=t.toString()),e=this.getIndexByCoord(t)):e=t,e!==!1&&this.remove(e),this},remove:function(t,e){var r=e||1;return Array.prototype.splice.call(this,t,r),1===this.length&&Array.prototype.push.call(this,new GHInput),this.fire("route.remove",{from:t,to:r}),this},addAll:function(){for(var t=0;t<arguments.length;t++)this.add(arguments[t]);return this},set:function(t,e,r){if(t instanceof GHInput)this[e]=t;else{if(!(this[e]instanceof GHInput))return r?this.add(t,e):!1;this[e].set(t)}return this.fire("route.set",{point:this[e],to:e}),this[e]},move:function(t,e,r){for(;0>t;)t+=this.length;for(;0>e;)e+=this.length;if(e>=this.length)for(var i=e-this.length;i--+1;)Array.prototype.push.call(this,void 0);return Array.prototype.splice.call(this,e,0,Array.prototype.splice.call(this,t,1)[0]),r||this.fire("route.move",{old_index:t,new_index:e}),this},reverse:function(){return Array.prototype.reverse.call(this),this.fire("route.reverse",{}),this},isResolved:function(){for(var t=0,e=this.length;e>t;t++){var r=this[t];if(!r.isResolved())return!1}return!0},addListener:function(t,e){return"undefined"==typeof this._listeners[t]&&(this._listeners[t]=[]),this._listeners[t].push(e),this},fire:function(t,e){if("string"==typeof t&&(t={type:t}),"object"==typeof e)for(var r in e)t[r]=e[r];if(t.route||(t.route=this),!t.type)throw new Error("Event object missing 'type' property.");if(this._listeners[t.type]instanceof Array)for(var i=this._listeners[t.type],n=0,o=i.length;o>n;n++)i[n].call(this,t)},removeListener:function(t,e){if(this._listeners[t]instanceof Array)for(var r=this._listeners[t],i=0,n=r.length;n>i;i++)if(r[i]===e){r.splice(i,1);break}}},module.exports=GHroute;
+
+},{"./GHInput.js":10}],13:[function(require,module,exports){
+var decodePath=function(e,d){for(var o=e.length,r=0,a=[],h=0,t=0,c=0;o>r;){var l,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var u=1&i?~(i>>1):i>>1;h+=u,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var n=1&i?~(i>>1):i>>1;if(t+=n,d){v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var s=1&i?~(i>>1):i>>1;c+=s,a.push([1e-5*t,1e-5*h,c/100])}else a.push([1e-5*t,1e-5*h])}return a};module.exports.decodePath=decodePath;
+
+},{}],14:[function(require,module,exports){
+function addInstruction(t,e,n,a,r,o){var s=n.sign;s=0===a?"marker-icon-green":messages.getSignName(s);var i=n.text;n.annotation_text&&(i=i?i+", "+n.annotation_text:n.annotation_text);var p=window.location.pathname,c=p.substring(0,p.lastIndexOf("/")),d=$("<tr class='instruction'/>");if("continue"!==s){var l="<img class='pic' style='vertical-align: middle' src='"+c+"/img/"+s+".png'/>";d.append("<td class='instr_pic'>"+l+"</td>")}else d.append("<td class='instr_pic'/>");var g=$("<td class='instr_title'>");g.text(i),d.append(g);var u=n.distance;u>0&&d.append("<td class='instr_distance'><span>"+translate.createDistanceString(u,o)+"<br/>"+translate.createTimeString(n.time)+"</span></td>"),r&&d.click(function(){routeSegmentPopup&&t.removeLayerFromMap(routeSegmentPopup),routeSegmentPopup=L.popup().setLatLng([r[1],r[0]]).setContent(i).openOn(t.getMap())}),e.append(d)}var translate=require("./translate.js"),messages=require("./messages.js"),routeSegmentPopup=null;module.exports.create=function(t,e,n,a){for(var r=$("<table class='instructions'>"),o=e.instructions.length>100,s=Math.min(e.instructions.length,100),i=0;s>i;i++){var p=e.instructions[i],c=e.points.coordinates[p.interval[0]];addInstruction(t,r,p,i,c,a.useMiles)}var d=$("<div class='instructions_info'>");if(d.append(r),o){var l=$("<button id='moreButton'>"+translate.tr("more_button")+"…</button>");l.click(function(){l.remove();for(var n=s;n<e.instructions.length;n++){var o=e.instructions[n],i=e.points.coordinates[o.interval[0]];addInstruction(t,r,o,n,i,a.useMiles)}}),r.append(l)}var g=$("<div id='routeDetails'/>");g.hide();var u=$("<button class='expandDetails'>+</button>");u.click(function(){g.toggle()}),d.append(u);var m="points: "+e.points.coordinates.length;g.append("<span>"+m+"</span>");var v=$("#export-link a");v.attr("href",n);var f=$("<br/><a>view on OSM</a>"),h="bicycle";"FOOT"===a.getVehicle().toUpperCase()&&(h="foot"),f.attr("href","http://www.openstreetmap.org/directions?engine=graphhopper_"+h+"&route="+encodeURIComponent(a.from.lat+","+a.from.lng+";"+a.to.lat+","+a.to.lng)),g.append(f);var b=$("<a>OSRM</a>");b.attr("href","http://map.project-osrm.org/?loc="+a.from+"&loc="+a.to),g.append("<br/><span>Compare with: </span>"),g.append(b);var w=$("<a>Google</a> "),x="",_="";"FOOT"===a.getVehicle().toUpperCase()?(x="&dirflg=w",_="&mode=W"):(a.getVehicle().toUpperCase().indexOf("BIKE")>=0||"MTB"===a.getVehicle().toUpperCase())&&(x="&dirflg=b"),w.attr("href","https://maps.google.com/?saddr="+a.from+"&daddr="+a.to+x),g.append(w);var O=$("<a>Bing</a> ");return O.attr("href","https://www.bing.com/maps/default.aspx?rtp=adr."+a.from+"~adr."+a.to+_),g.append(O),metaVersionInfo&&g.append(metaVersionInfo),d.append(g),d};
+
+},{"./messages.js":22,"./translate.js":29}],15:[function(require,module,exports){
+!function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)}(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}t.ui=t.ui||{},t.ui.version="1.12.0";var i=0,s=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,o,n;for(n=0;null!=(o=i[n]);n++)try{s=t._data(o,"events"),s&&s.remove&&t(o).triggerHandler("remove")}catch(r){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var o,n,r,h={},a=e.split(".")[0];e=e.split(".")[1];var l=a+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[a]=t[a]||{},o=t[a][e],n=t[a][e]=function(t,e){return this._createWidget?void(arguments.length&&this._createWidget(t,e)):new n(t,e)},t.extend(n,o,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),r=new i,r.options=t.widget.extend({},r.options),t.each(s,function(e,s){return t.isFunction(s)?void(h[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,n=this._superApply;return this._super=t,this._superApply=o,e=s.apply(this,arguments),this._super=i,this._superApply=n,e}}()):void(h[e]=s)}),n.prototype=t.widget.extend(r,{widgetEventPrefix:o?r.widgetEventPrefix||e:e},h,{constructor:n,namespace:a,widgetName:e,widgetFullName:l}),o?(t.each(o._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,n,i._proto)}),delete o._childConstructors):i._childConstructors.push(n),t.widget.bridge(e,n),n},t.widget.extend=function(e){for(var i,o,n=s.call(arguments,1),r=0,h=n.length;h>r;r++)for(i in n[r])o=n[r][i],n[r].hasOwnProperty(i)&&void 0!==o&&(e[i]=t.isPlainObject(o)?t.isPlainObject(e[i])?t.widget.extend({},e[i],o):t.widget.extend({},o):o);return e},t.widget.bridge=function(e,i){var o=i.prototype.widgetFullName||e;t.fn[e]=function(n){var r="string"==typeof n,h=s.call(arguments,1),a=this;return r?this.each(function(){var i,s=t.data(this,o);return"instance"===n?(a=s,!1):s?t.isFunction(s[n])&&"_"!==n.charAt(0)?(i=s[n].apply(s,h),i!==s&&void 0!==i?(a=i&&i.jquery?a.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; attempted to call method '"+n+"'")}):(h.length&&(n=t.widget.extend.apply(null,[n].concat(h))),this.each(function(){var e=t.data(this,o);e?(e.option(n||{}),e._init&&e._init()):t.data(this,o,new i(n,this))})),a}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,o,n,r=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(r={},s=e.split("."),e=s.shift(),s.length){for(o=r[e]=t.widget.extend({},this.options[e]),n=0;s.length-1>n;n++)o[s[n]]=o[s[n]]||{},o=o[s[n]];if(e=s.pop(),1===arguments.length)return void 0===o[e]?null:o[e];o[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];r[e]=i}return this._setOptions(r),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,o;for(i in e)o=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&o&&o.length&&(s=t(o.get()),this._removeClass(o,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,n){var r,h;for(h=0;i.length>h;h++)r=o.classesElementLookup[i[h]]||t(),r=t(e.add?t.unique(r.get().concat(e.element.get())):r.not(e.element).get()),o.classesElementLookup[i[h]]=r,s.push(i[h]),n&&e.classes[i[h]]&&s.push(e.classes[i[h]])}var s=[],o=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var o="string"==typeof t||null===t,n={extra:o?e:i,keys:o?t:e,element:o?this.element:t,add:s};return n.element.toggleClass(this._classes(n),s),this},_on:function(e,i,s){var o,n=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=o=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,o=this.widget()),t.each(s,function(s,r){function h(){return e||n.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof r?n[r]:r).apply(n,arguments):void 0}"string"!=typeof r&&(h.guid=r.guid=r.guid||h.guid||t.guid++);var a=s.match(/^([\w:-]*)\s*(.*)$/),l=a[1]+n.eventNamespace,c=a[2];c?o.on(l,c,h):i.on(l,h)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var o,n,r=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(o in n)o in i||(i[o]=n[o]);return this.element.trigger(i,s),!(t.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,o,n){"string"==typeof o&&(o={effect:o});var r,h=o?o===!0||"number"==typeof o?i:o.effect||i:e;o=o||{},"number"==typeof o&&(o={duration:o}),r=!t.isEmptyObject(o),o.complete=n,o.delay&&s.delay(o.delay),r&&t.effects&&t.effects.effect[h]?s[e](o):h!==e&&s[h]?s[h](o.duration,o.easing,n):s.queue(function(i){t(this)[e](),n&&n.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(d.test(t[0])?e/100:1),parseFloat(t[1])*(d.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var o,n,r=Math.max,h=Math.abs,a=Math.round,l=/left|center|right/,c=/top|center|bottom/,p=/[\+\-]\d+(\.[\d]+)?%?/,u=/^\w+/,d=/%$/,f=t.fn.position;n=function(){var e=t("<div>").css("position","absolute").appendTo("body").offset({top:1.5,left:1.5}),i=1.5===e.offset().top;return e.remove(),n=function(){return i},i},t.position={scrollbarWidth:function(){if(void 0!==o)return o;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),n=s.children()[0];return t("body").append(s),e=n.offsetWidth,s.css("overflow","scroll"),i=n.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),o=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),o="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,n="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:n?t.position.scrollbarWidth():0,height:o?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),o=!!i[0]&&9===i[0].nodeType,n=!s&&!o;return{element:i,isWindow:s,isDocument:o,offset:n?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(o){if(!o||!o.of)return f.apply(this,arguments);o=t.extend({},o);var d,g,m,_,v,b,w=t(o.of),y=t.position.getWithinInfo(o.within),P=t.position.getScrollInfo(y),x=(o.collision||"flip").split(" "),z={};return b=s(w),w[0].preventDefault&&(o.at="left top"),g=b.width,m=b.height,_=b.offset,v=t.extend({},_),t.each(["my","at"],function(){var t,e,i=(o[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):c.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=c.test(i[1])?i[1]:"center",t=p.exec(i[0]),e=p.exec(i[1]),z[this]=[t?t[0]:0,e?e[0]:0],o[this]=[u.exec(i[0])[0],u.exec(i[1])[0]]}),1===x.length&&(x[1]=x[0]),"right"===o.at[0]?v.left+=g:"center"===o.at[0]&&(v.left+=g/2),"bottom"===o.at[1]?v.top+=m:"center"===o.at[1]&&(v.top+=m/2),d=e(z.at,g,m),v.left+=d[0],v.top+=d[1],this.each(function(){var s,l,c=t(this),p=c.outerWidth(),u=c.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),C=p+f+i(this,"marginRight")+P.width,H=u+b+i(this,"marginBottom")+P.height,T=t.extend({},v),k=e(z.my,c.outerWidth(),c.outerHeight());"right"===o.my[0]?T.left-=p:"center"===o.my[0]&&(T.left-=p/2),"bottom"===o.my[1]?T.top-=u:"center"===o.my[1]&&(T.top-=u/2),T.left+=k[0],T.top+=k[1],n()||(T.left=a(T.left),T.top=a(T.top)),s={marginLeft:f,marginTop:b},t.each(["left","top"],function(e,i){t.ui.position[x[e]]&&t.ui.position[x[e]][i](T,{targetWidth:g,targetHeight:m,elemWidth:p,elemHeight:u,collisionPosition:s,collisionWidth:C,collisionHeight:H,offset:[d[0]+k[0],d[1]+k[1]],my:o.my,at:o.at,within:y,elem:c})}),o.using&&(l=function(t){var e=_.left-T.left,i=e+g-p,s=_.top-T.top,n=s+m-u,a={target:{element:w,left:_.left,top:_.top,width:g,height:m},element:{element:c,left:T.left,top:T.top,width:p,height:u},horizontal:0>i?"left":e>0?"right":"center",vertical:0>n?"top":s>0?"bottom":"middle"};p>g&&g>h(e+i)&&(a.horizontal="center"),u>m&&m>h(s+n)&&(a.vertical="middle"),a.important=r(h(e),h(i))>r(h(s),h(n))?"horizontal":"vertical",o.using.call(this,t,a)}),c.offset(t.extend(T,{using:l}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollLeft:s.offset.left,n=s.width,h=t.left-e.collisionPosition.marginLeft,a=o-h,l=h+e.collisionWidth-n-o;e.collisionWidth>n?a>0&&0>=l?(i=t.left+a+e.collisionWidth-n-o,t.left+=a-i):t.left=l>0&&0>=a?o:a>l?o+n-e.collisionWidth:o:a>0?t.left+=a:l>0?t.left-=l:t.left=r(t.left-h,t.left)},top:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollTop:s.offset.top,n=e.within.height,h=t.top-e.collisionPosition.marginTop,a=o-h,l=h+e.collisionHeight-n-o;e.collisionHeight>n?a>0&&0>=l?(i=t.top+a+e.collisionHeight-n-o,t.top+=a-i):t.top=l>0&&0>=a?o:a>l?o+n-e.collisionHeight:o:a>0?t.top+=a:l>0?t.top-=l:t.top=r(t.top-h,t.top)}},flip:{left:function(t,e){var i,s,o=e.within,n=o.offset.left+o.scrollLeft,r=o.width,a=o.isWindow?o.scrollLeft:o.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-a,p=l+e.collisionWidth-r-a,u="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,d="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+u+d+f+e.collisionWidth-r-n,(0>i||h(c)>i)&&(t.left+=u+d+f)):p>0&&(s=t.left-e.collisionPosition.marginLeft+u+d+f-a,(s>0||p>h(s))&&(t.left+=u+d+f))},top:function(t,e){var i,s,o=e.within,n=o.offset.top+o.scrollTop,r=o.height,a=o.isWindow?o.scrollTop:o.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-a,p=l+e.collisionHeight-r-a,u="top"===e.my[1],d=u?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+d+f+g+e.collisionHeight-r-n,(0>s||h(c)>s)&&(t.top+=d+f+g)):p>0&&(i=t.top-e.collisionPosition.marginTop+d+f+g-a,(i>0||p>h(i))&&(t.top+=d+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}}),t.ui.focusable=function(i,s){var o,n,r,h,a,l=i.nodeName.toLowerCase();return"area"===l?(o=i.parentNode,n=o.name,i.href&&n&&"map"===o.nodeName.toLowerCase()?(r=t("img[usemap='#"+n+"']"),r.length>0&&r.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(h=!i.disabled,h&&(a=t(i).closest("fieldset")[0],a&&(h=!a.disabled))):h="a"===l?i.href||s:s,h&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,n){return t.each(o,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),n&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var o="Width"===i?["Left","Right"]:["Top","Bottom"],n=i.toLowerCase(),r={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?r["inner"+i].call(this):this.each(function(){t(this).css(n,s(this,e)+"px")})},t.fn["outer"+i]=function(e,o){return"number"!=typeof e?r["outer"+i].call(this,e):this.each(function(){t(this).css(n,s(this,e,!0,o)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,o,n;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(o=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),n=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",o=o.add(n.find(i).addBack(i))),this.pushStack(o))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,o=e?/(auto|scroll|hidden)/:/(auto|scroll)/,n=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:o.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&n.length?n:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var o=!1;t(document).on("mouseup",function(){o=!1}),t.widget("ui.mouse",{version:"1.12.0",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!o){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),o=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,o=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var o,n=t.ui[e].prototype;for(o in s)n.plugins[o]=n.plugins[o]||[],n.plugins[o].push([i,s[o]])},call:function(t,e,i,s){var o,n=t.plugins[e];if(n&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(o=0;n.length>o;o++)t.options[n[o][0]]&&n[o][1].apply(t.element,i)}},t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?void(this.destroyOnClear=!0):(this._removeHandleClassName(),void this._mouseDestroy())},_mouseCapture:function(e){var i=this.options;return this._blurActiveElement(e),this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);this._getHandle(e)&&s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),o=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return o.parents("body").length||o.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&o[0]===this.element[0]&&this._setPositionRelative(),o[0]===this.element[0]||/(fixed|absolute)/.test(o.css("position"))||o.css("position","absolute"),o},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options,n=this.document[0];return this.relativeContainer=null,o.containment?"window"===o.containment?void(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):"document"===o.containment?void(this.containment=[0,0,t(n).width()-this.helperProportions.width-this.margins.left,(t(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):o.containment.constructor===Array?void(this.containment=o.containment):("parent"===o.containment&&(o.containment=this.helper[0].parentNode),i=t(o.containment),s=i[0],void(s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i))):void(this.containment=null)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,o,n,r=this.options,h=this._isRootNode(this.scrollParent[0]),a=t.pageX,l=t.pageY;return h&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(a=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(a=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),r.grid&&(o=r.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/r.grid[1])*r.grid[1]:this.originalPageY,l=i?o-this.offset.click.top>=i[1]||o-this.offset.click.top>i[3]?o:o-this.offset.click.top>=i[1]?o-r.grid[1]:o+r.grid[1]:o,n=r.grid[0]?this.originalPageX+Math.round((a-this.originalPageX)/r.grid[0])*r.grid[0]:this.originalPageX,a=i?n-this.offset.click.left>=i[0]||n-this.offset.click.left>i[2]?n:n-this.offset.click.left>=i[0]?n-r.grid[0]:n+r.grid[0]:n),"y"===r.axis&&(a=this.originalPageX),"x"===r.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:h?0:this.offset.scroll.top),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:h?0:this.offset.scroll.left)
+}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var o=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,o))})},stop:function(e,i,s){var o=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,o))})},drag:function(e,i,s){t.each(s.sortables,function(){var o=!1,n=this;n.positionAbs=s.positionAbs,n.helperProportions=s.helperProportions,n.offset.click=s.offset.click,n._intersectsWith(n.containerCache)&&(o=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==n&&this._intersectsWith(this.containerCache)&&t.contains(n.element[0],this.element[0])&&(o=!1),o})),o?(n.isOver||(n.isOver=1,s._parent=i.helper.parent(),n.currentItem=i.helper.appendTo(n.element).data("ui-sortable-item",!0),n.options._helper=n.options.helper,n.options.helper=function(){return i.helper[0]},e.target=n.currentItem[0],n._mouseCapture(e,!0),n._mouseStart(e,!0,!0),n.offset.click.top=s.offset.click.top,n.offset.click.left=s.offset.click.left,n.offset.parent.left-=s.offset.parent.left-n.offset.parent.left,n.offset.parent.top-=s.offset.parent.top-n.offset.parent.top,s._trigger("toSortable",e),s.dropped=n.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,n.fromOutside=s),n.currentItem&&(n._mouseDrag(e),i.position=n.position)):n.isOver&&(n.isOver=0,n.cancelHelperRemoval=!0,n.options._revert=n.options.revert,n.options.revert=!1,n._trigger("out",e,n._uiHash(n)),n._mouseStop(e,!0),n.options.revert=n.options._revert,n.options.helper=n.options._helper,n.placeholder&&n.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var o=t("body"),n=s.options;o.css("cursor")&&(n._cursor=o.css("cursor")),o.css("cursor",n.cursor)},stop:function(e,i,s){var o=s.options;o._cursor&&t("body").css("cursor",o._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("opacity")&&(n._opacity=o.css("opacity")),o.css("opacity",n.opacity)},stop:function(e,i,s){var o=s.options;o._opacity&&t(i.helper).css("opacity",o._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var o=s.options,n=!1,r=s.scrollParentNotHidden[0],h=s.document[0];r!==h&&"HTML"!==r.tagName?(o.axis&&"x"===o.axis||(s.overflowOffset.top+r.offsetHeight-e.pageY<o.scrollSensitivity?r.scrollTop=n=r.scrollTop+o.scrollSpeed:e.pageY-s.overflowOffset.top<o.scrollSensitivity&&(r.scrollTop=n=r.scrollTop-o.scrollSpeed)),o.axis&&"y"===o.axis||(s.overflowOffset.left+r.offsetWidth-e.pageX<o.scrollSensitivity?r.scrollLeft=n=r.scrollLeft+o.scrollSpeed:e.pageX-s.overflowOffset.left<o.scrollSensitivity&&(r.scrollLeft=n=r.scrollLeft-o.scrollSpeed))):(o.axis&&"x"===o.axis||(e.pageY-t(h).scrollTop()<o.scrollSensitivity?n=t(h).scrollTop(t(h).scrollTop()-o.scrollSpeed):t(window).height()-(e.pageY-t(h).scrollTop())<o.scrollSensitivity&&(n=t(h).scrollTop(t(h).scrollTop()+o.scrollSpeed))),o.axis&&"y"===o.axis||(e.pageX-t(h).scrollLeft()<o.scrollSensitivity?n=t(h).scrollLeft(t(h).scrollLeft()-o.scrollSpeed):t(window).width()-(e.pageX-t(h).scrollLeft())<o.scrollSensitivity&&(n=t(h).scrollLeft(t(h).scrollLeft()+o.scrollSpeed)))),n!==!1&&t.ui.ddmanager&&!o.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var o=s.options;s.snapElements=[],t(o.snap.constructor!==String?o.snap.items||":data(ui-draggable)":o.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var o,n,r,h,a,l,c,p,u,d,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(u=s.snapElements.length-1;u>=0;u--)a=s.snapElements[u].left-s.margins.left,l=a+s.snapElements[u].width,c=s.snapElements[u].top-s.margins.top,p=c+s.snapElements[u].height,a-g>_||m>l+g||c-g>b||v>p+g||!t.contains(s.snapElements[u].item.ownerDocument,s.snapElements[u].item)?(s.snapElements[u].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=!1):("inner"!==f.snapMode&&(o=g>=Math.abs(c-b),n=g>=Math.abs(p-v),r=g>=Math.abs(a-_),h=g>=Math.abs(l-m),o&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a-s.helperProportions.width}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),d=o||n||r||h,"outer"!==f.snapMode&&(o=g>=Math.abs(c-v),n=g>=Math.abs(p-b),r=g>=Math.abs(a-m),h=g>=Math.abs(l-_),o&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p-s.helperProportions.height,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[u].snapping&&(o||n||r||h||d)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=o||n||r||h||d)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var o,n=s.options,r=t.makeArray(t(n.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});r.length&&(o=parseInt(t(r[0]).css("zIndex"),10)||0,t(r).each(function(e){t(this).css("zIndex",o+e)}),this.css("zIndex",o+r.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("zIndex")&&(n._zIndex=o.css("zIndex")),o.css("zIndex",n.zIndex)},stop:function(e,i,s){var o=s.options;o._zIndex&&t(i.helper).css("zIndex",o._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",o=!1;return e[s]>0?!0:(e[s]=1,o=e[s]>0,e[s]=0,o)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles()}},_setupHandles:function(){var e,i,s,o,n,r=this.options,h=this;if(this.handles=r.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),o="ui-resizable-"+e,n=t("<div>"),this._addClass(n,"ui-resizable-handle "+o),n.css({zIndex:r.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(n);this._renderAxis=function(e){var i,s,o,n;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:h._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),n=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),o=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(o,n),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){h.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),h.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,o=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(o=!0);return!this.options.disabled&&o},_mouseStart:function(e){var i,s,o,n=this.options,r=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),n.containment&&(i+=t(n.containment).scrollLeft()||0,s+=t(n.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:r.width(),height:r.height()},this.originalSize=this._helper?{width:r.outerWidth(),height:r.outerHeight()}:{width:r.width(),height:r.height()},this.sizeDiff={width:r.outerWidth()-r.width(),height:r.outerHeight()-r.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof n.aspectRatio?n.aspectRatio:this.originalSize.width/this.originalSize.height||1,o=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===o?this.axis+"-resize":o),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,o=this.originalMousePosition,n=this.axis,r=e.pageX-o.left||0,h=e.pageY-o.top||0,a=this._change[n];return this._updatePrevProperties(),a?(i=a.apply(this,[e,r,h]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,o,n,r,h,a,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),o=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,n=s?0:c.sizeDiff.width,r={width:c.helper.width()-n,height:c.helper.height()-o},h=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,a=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(r,{top:a,left:h})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,o,n,r=this.options;n={minWidth:this._isNumber(r.minWidth)?r.minWidth:0,maxWidth:this._isNumber(r.maxWidth)?r.maxWidth:1/0,minHeight:this._isNumber(r.minHeight)?r.minHeight:0,maxHeight:this._isNumber(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||t)&&(e=n.minHeight*this.aspectRatio,s=n.minWidth/this.aspectRatio,i=n.maxHeight*this.aspectRatio,o=n.maxWidth/this.aspectRatio,e>n.minWidth&&(n.minWidth=e),s>n.minHeight&&(n.minHeight=s),n.maxWidth>i&&(n.maxWidth=i),n.maxHeight>o&&(n.maxHeight=o)),this._vBoundaries=n},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,o=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,n=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,r=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,h=this.originalPosition.left+this.originalSize.width,a=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return n&&(t.width=e.minWidth),r&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),o&&(t.height=e.maxHeight),n&&l&&(t.left=h-e.minWidth),s&&l&&(t.left=h-e.maxWidth),r&&c&&(t.top=a-e.minHeight),o&&c&&(t.top=a-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],o=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(o[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,o=this.originalPosition;return{top:o.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,o=i._proportionallyResizeElements,n=o.length&&/textarea/i.test(o[0].nodeName),r=n&&i._hasScroll(o[0],"left")?0:i.sizeDiff.height,h=n?0:i.sizeDiff.width,a={width:i.size.width-h,height:i.size.height-r},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(a,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};o&&o.length&&t(o[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,o,n,r,h,a=t(this).resizable("instance"),l=a.options,c=a.element,p=l.containment,u=p instanceof t?p.get(0):/parent/.test(p)?c.parent().get(0):p;u&&(a.containerElement=t(u),/document/.test(p)||p===document?(a.containerOffset={left:0,top:0},a.containerPosition={left:0,top:0},a.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(u),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=a._num(e.css("padding"+s))}),a.containerOffset=e.offset(),a.containerPosition=e.position(),a.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=a.containerOffset,o=a.containerSize.height,n=a.containerSize.width,r=a._hasScroll(u,"left")?u.scrollWidth:n,h=a._hasScroll(u)?u.scrollHeight:o,a.parentData={element:u,left:s.left,top:s.top,width:r,height:h}))},resize:function(e){var i,s,o,n,r=t(this).resizable("instance"),h=r.options,a=r.containerOffset,l=r.position,c=r._aspectRatio||e.shiftKey,p={top:0,left:0},u=r.containerElement,d=!0;u[0]!==document&&/static/.test(u.css("position"))&&(p=a),l.left<(r._helper?a.left:0)&&(r.size.width=r.size.width+(r._helper?r.position.left-a.left:r.position.left-p.left),c&&(r.size.height=r.size.width/r.aspectRatio,d=!1),r.position.left=h.helper?a.left:0),l.top<(r._helper?a.top:0)&&(r.size.height=r.size.height+(r._helper?r.position.top-a.top:r.position.top),c&&(r.size.width=r.size.height*r.aspectRatio,d=!1),r.position.top=r._helper?a.top:0),o=r.containerElement.get(0)===r.element.parent().get(0),n=/relative|absolute/.test(r.containerElement.css("position")),o&&n?(r.offset.left=r.parentData.left+r.position.left,r.offset.top=r.parentData.top+r.position.top):(r.offset.left=r.element.offset().left,r.offset.top=r.element.offset().top),i=Math.abs(r.sizeDiff.width+(r._helper?r.offset.left-p.left:r.offset.left-a.left)),s=Math.abs(r.sizeDiff.height+(r._helper?r.offset.top-p.top:r.offset.top-a.top)),i+r.size.width>=r.parentData.width&&(r.size.width=r.parentData.width-i,c&&(r.size.height=r.size.width/r.aspectRatio,d=!1)),s+r.size.height>=r.parentData.height&&(r.size.height=r.parentData.height-s,c&&(r.size.width=r.size.height*r.aspectRatio,d=!1)),d||(r.position.left=r.prevPosition.left,r.position.top=r.prevPosition.top,r.size.width=r.prevSize.width,r.size.height=r.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,o=e.containerPosition,n=e.containerElement,r=t(e.helper),h=r.offset(),a=r.outerWidth()-e.sizeDiff.width,l=r.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l}),e._helper&&!i.animate&&/static/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),o=s.options,n=s.originalSize,r=s.originalPosition,h={height:s.size.height-n.height||0,width:s.size.width-n.width||0,top:s.position.top-r.top||0,left:s.position.left-r.left||0};t(o.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),o={},n=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(n,function(t,e){var i=(s[e]||0)+(h[e]||0);i&&i>=0&&(o[e]=i||null)}),e.css(o)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,o=i.size,n=i.originalSize,r=i.originalPosition,h=i.axis,a="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=a[0]||1,c=a[1]||1,p=Math.round((o.width-n.width)/l)*l,u=Math.round((o.height-n.height)/c)*c,d=n.width+p,f=n.height+u,g=s.maxWidth&&d>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>d,v=s.minHeight&&s.minHeight>f;s.grid=a,_&&(d+=l),v&&(f+=c),g&&(d-=l),m&&(f-=c),/^(se|s|e)$/.test(h)?(i.size.width=d,i.size.height=f):/^(ne)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.top=r.top-u):/^(sw)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.left=r.left-p):((0>=f-c||0>=d-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=r.top-u):(f=c-e.height,i.size.height=f,i.position.top=r.top+n.height-f),d-l>0?(i.size.width=d,i.position.left=r.left-p):(d=l-e.width,i.size.width=d,i.position.left=r.left+n.width-d))}}),t.ui.resizable,t.widget("ui.sortable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,o=!1,n=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,n.widgetName+"-item")===n?(s=t(this),!1):void 0}),t.data(e.target,n.widgetName+"-item")===n&&(s=t(e.target)),s&&(!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(o=!0)}),o))?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1)},_mouseStart:function(e,i,s){var o,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=t("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(o=this.containers.length-1;o>=0;o--)this.containers[o]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,o,n,r=this.options,h=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop+r.scrollSpeed:e.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft+r.scrollSpeed:e.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(e.pageY-this.document.scrollTop()<r.scrollSensitivity?h=this.document.scrollTop(this.document.scrollTop()-r.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<r.scrollSensitivity&&(h=this.document.scrollTop(this.document.scrollTop()+r.scrollSpeed)),e.pageX-this.document.scrollLeft()<r.scrollSensitivity?h=this.document.scrollLeft(this.document.scrollLeft()-r.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<r.scrollSensitivity&&(h=this.document.scrollLeft(this.document.scrollLeft()+r.scrollSpeed))),h!==!1&&t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],o=s.item[0],n=this._intersectsWithPointer(s),n&&s.instance===this.currentContainer&&o!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==o&&!t.contains(this.placeholder[0],o)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],o):!0)){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),
+this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,o=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=o.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=o.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,o=s+this.helperProportions.height,n=t.left,r=n+t.width,h=t.top,a=h+t.height,l=this.offset.click.top,c=this.offset.click.left,p="x"===this.options.axis||s+l>h&&a>s+l,u="y"===this.options.axis||e+c>n&&r>e+c,d=p&&u;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?d:e+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>h&&a>o-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),o="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),n=s&&o;return n?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return this.floating&&o?"right"===o&&i||"left"===o&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){h.push(this)}var s,o,n,r,h=[],a=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(n=t(l[s],this.document[0]),o=n.length-1;o>=0;o--)r=t.data(n[o],this.widgetFullName),r&&r!==this&&!r.options.disabled&&a.push([t.isFunction(r.options.items)?r.options.items.call(r.element):t(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(a.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=a.length-1;s>=0;s--)a[s][0].each(i);return t(h)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,o,n,r,h,a,l,c=this.items,p=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],u=this._connectWith();if(u&&this.ready)for(i=u.length-1;i>=0;i--)for(o=t(u[i],this.document[0]),s=o.length-1;s>=0;s--)n=t.data(o[s],this.widgetFullName),n&&n!==this&&!n.options.disabled&&(p.push([t.isFunction(n.options.items)?n.options.items.call(n.element[0],e,{item:this.currentItem}):t(n.options.items,n.element),n]),this.containers.push(n));for(i=p.length-1;i>=0;i--)for(r=p[i][1],h=p[i][0],s=0,l=h.length;l>s;s++)a=t(h[s]),a.data(this.widgetName+"-item",r),c.push({item:a,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,o,n;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(o=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=o.outerWidth(),s.height=o.outerHeight()),n=o.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),o=t("<"+s+">",e.document[0]);return e._addClass(o,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(o,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(o)):"tr"===s?e._createTrPlaceholder(e.currentItem,o):"img"===s&&o.attr("src",e.currentItem.attr("src")),i||o.css("visibility","hidden"),o},update:function(t,o){(!i||s.forcePlaceholderSize)&&(o.height()||o.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),o.width()||o.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,o,n,r,h,a,l,c,p,u=null,d=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(u&&t.contains(this.containers[i].element[0],u.element[0]))continue;u=this.containers[i],d=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(u)if(1===this.containers.length)this.containers[d].containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1);else{for(o=1e4,n=null,c=u.floating||this._isFloating(this.currentItem),r=c?"left":"top",h=c?"width":"height",p=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[d].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(a=this.items[s].item.offset()[r],l=!1,e[p]-a>this.items[s][h]/2&&(l=!0),o>Math.abs(e[p]-a)&&(o=Math.abs(e[p]-a),n=this.items[s],this.direction=l?"up":"down"));if(!n&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[d])return void(this.currentContainer.containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1));n?this._rearrange(e,n,null,!0):this._rearrange(e,null,this.containers[d].element,!0),this._trigger("change",e,this._uiHash()),this.containers[d]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[d],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options;"parent"===o.containment&&(o.containment=this.helper[0].parentNode),("document"===o.containment||"window"===o.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===o.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===o.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(o.containment)||(e=t(o.containment)[0],i=t(o.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,o="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(o[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:o.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:o.scrollLeft())*s}},_generatePosition:function(e){var i,s,o=this.options,n=e.pageX,r=e.pageY,h="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(h[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),o.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/o.grid[1])*o.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-o.grid[1]:i+o.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/o.grid[0])*o.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-o.grid[0]:s+o.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:h.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:h.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var o=this.counter;this._delay(function(){o===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,o=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&o.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||o.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(o.push(function(t){this._trigger("remove",t,this._uiHash())}),o.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),o.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||o.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(o.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;o.length>s;s++)o[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}});var n=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.0",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,o){var n,r={};return o?"controlgroupLabel"===s?(n=e.element.find(o),n.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(n,null,"ui-widget ui-widget-content ui-state-default"),void(i=i.concat(n.get()))):void(t.fn[s]&&(e["_"+s+"Options"]&&(r=e["_"+s+"Options"]("middle")),e.element.find(o).each(function(){var o=t(this),n=o[s]("instance"),h=t.widget.extend({},r);if("button"!==s||!o.parent(".ui-spinner").length){n||(n=o[s]()[s]("instance")),n&&(h.classes=e._resolveClassesValues(h.classes,n)),o[s](h);var a=o[s]("widget");t.data(a[0],"ui-controlgroup-data",n?n:o[s]("instance")),i.push(a[0])}}))):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(t){var o=i.options.classes[t]||"";o=o.replace(n,"").trim(),s[t]=(o+" "+e[t]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?void this._callChildMethod(e?"disable":"enable"):void this.refresh()},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var o=e[s]().data("ui-controlgroup-data");if(o&&i["_"+o.widgetName+"Options"]){var n=i["_"+o.widgetName+"Options"](1===e.length?"only":s);n.classes=i._resolveClassesValues(n.classes,o),o.element[o.widgetName](n)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.0",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,o=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(o.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(o.disabled=e),o},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),void(this.element[0].disabled=e)):void this.refresh()):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){this.label.contents().not(this.element.add(this.icon).add(this.iconSpace)).remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.0",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,o=s?this.options.iconPosition:i,n="top"===o||"bottom"===o;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(o),n?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(o))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?void this._super("showLabel",e):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),void this._superApply(arguments))}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.widget("ui.dialog",{version:"1.12.0",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",
+at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,o=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),n=Math.max.apply(null,o);return n>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",n+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?void(this._moveToTop()&&this._focusTabbable()):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),void this._trigger("open"))},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),void this.close(e);if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),o=i.filter(":last");e.target!==o[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){o.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?void this._removeClass(this.uiDialog,"ui-dialog-buttons"):(t.each(i,function(i,s){var o,n;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),o=s.click,n={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,t("<button></button>",s).button(n).appendTo(e.uiButtonSet).on("click",function(){o.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),void this.uiDialogButtonPane.appendTo(this.uiDialog))},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,o){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(o))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(o,n){var r=n.offset.left-i.document.scrollLeft(),h=n.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",o,e(n))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,o=s.resizable,n=this.uiDialog.css("position"),r="string"==typeof o?o:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:r,start:function(s,o){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(o))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(o,n){var r=i.uiDialog.offset(),h=r.left-i.document.scrollLeft(),a=r.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(h>=0?"+":"")+h+" top"+(a>=0?"+":"")+a,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",o,e(n))}}).css("position",n)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,o={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(o[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",o)},_setOption:function(e,i){var s,o,n=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=n.is(":data(ui-draggable)"),s&&!i&&n.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(o=n.is(":data(ui-resizable)"),o&&!i&&n.resizable("destroy"),o&&"string"==typeof i&&n.resizable("option","handles",i),o||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog});
 
 },{}],16:[function(require,module,exports){
-!function(e){"use strict";"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)}(function(e){"use strict";function t(n,s){var i=function(){},o=this,l={autoSelectFirst:!1,appendTo:"body",serviceUrl:null,lookup:null,onSelect:null,width:"auto",minChars:1,maxHeight:300,deferRequestBy:0,params:{},formatResult:t.formatResult,onPreSelect:i,delimiter:null,zIndex:9999,type:"GET",noCache:!1,onSearchStart:i,onSearchComplete:i,onSearchError:i,containerClass:"autocomplete-suggestions",tabDisabled:!1,dataType:"text",currentRequest:null,triggerSelectOnValidInput:!0,lookupFilter:function(e,t,n){return e.value.toLowerCase().indexOf(n)!==-1},paramName:"query",transformResult:function(t){return"string"==typeof t?e.parseJSON(t):t}};o.element=n,o.el=e(n),o.suggestions=[],o.badQueries=[],o.selectedIndex=-1,o.currentValue=o.element.value,o.intervalId=0,o.cachedResponse={},o.onChangeInterval=null,o.onChange=null,o.isLocal=!1,o.suggestionsContainer=null,o.options=e.extend({},l,s),o.classes={selected:"autocomplete-selected",suggestion:"autocomplete-suggestion"},o.hint=null,o.hintValue="",o.selection=null,o.initialize(),o.setOptions(s)}var n=function(){return{escapeRegExChars:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},createNode:function(e){var t=document.createElement("div");return t.className=e,t.style.position="absolute",t.style.display="none",t.style.cursor="pointer",t}}}(),s={ESC:27,TAB:9,RETURN:13,LEFT:37,UP:38,RIGHT:39,DOWN:40};t.utils=n,e.Autocomplete=t,t.formatResult=function(e,t){var s="("+n.escapeRegExChars(t)+")";return e.value.replace(new RegExp(s,"gi"),"<strong>$1</strong>")},t.prototype={killerFn:null,initialize:function(){var n,s=this,i="."+s.classes.suggestion,o=(s.classes.selected,s.options);s.element.setAttribute("autocomplete","off"),s.killerFn=function(t){0===e(t.target).closest("."+s.options.containerClass).length&&(s.killSuggestions(),s.disableKillerFn())},s.suggestionsContainer=t.utils.createNode(o.containerClass),n=e(s.suggestionsContainer),n.appendTo(o.appendTo),"auto"!==o.width&&n.width(o.width),n.on("click.autocomplete",i,function(){s.select(e(this).data("index"))}),s.fixPosition(),s.fixPositionCapture=function(){s.visible&&s.fixPosition()},e(window).on("resize.autocomplete",s.fixPositionCapture),s.el.on("keydown.autocomplete",function(e){s.onKeyPress(e)}),s.el.on("keyup.autocomplete",function(e){s.onKeyUp(e)}),s.el.on("blur.autocomplete",function(){s.onBlur()}),s.el.on("focus.autocomplete",function(){s.onFocus()}),s.el.on("change.autocomplete",function(e){s.onKeyUp(e)})},onFocus:function(){var e=this;e.fixPosition(),e.options.minChars<=e.el.val().length},onBlur:function(){this.enableKillerFn()},setOptions:function(t){var n=this,s=n.options;e.extend(s,t),n.isLocal=e.isArray(s.lookup),n.isLocal&&(s.lookup=n.verifySuggestionsFormat(s.lookup)),e(n.suggestionsContainer).css({"max-height":s.maxHeight+"px",width:s.width+"px","z-index":s.zIndex})},clearCache:function(){this.cachedResponse={},this.badQueries=[]},clear:function(){this.clearCache(),this.currentValue="",this.suggestions=[]},disable:function(){var e=this;e.disabled=!0,e.currentRequest&&e.currentRequest.abort()},enable:function(){this.disabled=!1},fixPosition:function(){var t,n,s=this;"body"===s.options.appendTo&&(t=s.el.offset(),n={top:t.top+s.el.outerHeight()+"px",left:t.left+"px"},"auto"===s.options.width&&(n.width=s.el.outerWidth()-2+"px"),e(s.suggestionsContainer).css(n))},enableKillerFn:function(){var t=this;e(document).on("click.autocomplete",t.killerFn)},disableKillerFn:function(){var t=this;e(document).off("click.autocomplete",t.killerFn)},killSuggestions:function(){var e=this;e.stopKillSuggestions(),e.intervalId=window.setInterval(function(){e.hide(),e.stopKillSuggestions()},50)},stopKillSuggestions:function(){window.clearInterval(this.intervalId)},isCursorAtEnd:function(){var e,t=this,n=t.el.val().length,s=t.element.selectionStart;return"number"==typeof s?s===n:!document.selection||(e=document.selection.createRange(),e.moveStart("character",-n),n===e.text.length)},onKeyPress:function(e){var t=this;if(!t.disabled&&!t.visible&&e.which===s.DOWN&&t.currentValue)return void t.suggest();if(!t.disabled&&t.visible){switch(e.which){case s.ESC:t.el.val(t.currentValue),t.hide();break;case s.RIGHT:if(t.hint&&t.options.onHint&&t.isCursorAtEnd()){t.selectHint();break}return;case s.TAB:if(t.hint&&t.options.onHint)return void t.selectHint();case s.RETURN:if(t.selectedIndex===-1)return void t.hide();if(t.select(t.selectedIndex),e.which===s.TAB&&t.options.tabDisabled===!1)return;break;case s.UP:t.moveUp();break;case s.DOWN:t.moveDown();break;default:return}e.stopImmediatePropagation(),e.preventDefault()}},onKeyUp:function(e){var t=this;if(!t.disabled){switch(e.which){case s.UP:case s.DOWN:return}clearInterval(t.onChangeInterval),t.currentValue!==t.el.val()&&(t.findBestHint(),t.options.deferRequestBy>0?t.onChangeInterval=setInterval(function(){t.onValueChange()},t.options.deferRequestBy):t.onValueChange())}},onValueChange:function(){var t,n=this,s=n.options,i=n.el.val(),o=n.getQuery(i);return n.selection&&(n.selection=null,(s.onInvalidateSelection||e.noop).call(n.element)),clearInterval(n.onChangeInterval),n.currentValue=i,n.selectedIndex=-1,s.triggerSelectOnValidInput&&(t=n.findSuggestionIndex(o),t!==-1)?void n.select(t):void(o.length<s.minChars?n.hide():n.getSuggestions(o))},findSuggestionIndex:function(t){var n=this,s=-1,i=t.toLowerCase();return e.each(n.suggestions,function(e,t){if(t.value.toLowerCase()===i)return s=e,!1}),s},getQuery:function(t){var n,s=this.options.delimiter;return s?(n=t.split(s),e.trim(n[n.length-1])):t},getSuggestionsLocal:function(t){var n,s=this,i=s.options,o=t.toLowerCase(),l=i.lookupFilter,a=parseInt(i.lookupLimit,10);return n={suggestions:e.grep(i.lookup,function(e){return l(e,t,o)})},a&&n.suggestions.length>a&&(n.suggestions=n.suggestions.slice(0,a)),n},getSuggestions:function(t){var n,s,i,o=this,l=o.options,a=l.serviceUrl;if(l.params[l.paramName]=t,s=l.ignoreParams?null:l.params,o.isLocal?n=o.getSuggestionsLocal(t):(e.isFunction(a)&&(a=a.call(o.element,t)),i=a+"?"+e.param(s||{}),n=o.cachedResponse[i]),n&&e.isArray(n.suggestions))o.suggestions=n.suggestions,o.suggest();else if(!o.isBadQuery(t)){if(l.onSearchStart.call(o.element,l.params)===!1)return;o.currentRequest&&o.currentRequest.abort(),o.currentRequest=e.ajax({url:a,data:s,type:l.type,dataType:l.dataType}).done(function(e){o.currentRequest=null,o.processResponse(e,t,i),l.onSearchComplete.call(o.element,t)}).fail(function(e,n,s){l.onSearchError.call(o.element,t,e,n,s)})}},isBadQuery:function(e){for(var t=this.badQueries,n=t.length;n--;)if(0===e.indexOf(t[n]))return!0;return!1},hide:function(){var t=this;t.visible=!1,t.selectedIndex=-1,e(t.suggestionsContainer).hide(),t.signalHint(null)},suggest:function(){if(0===this.suggestions.length)return void this.hide();var t,n,s=this,i=s.options,o=i.formatResult,l=s.getQuery(s.currentValue),a=s.classes.suggestion,r=s.classes.selected,u=e(s.suggestionsContainer),c=i.beforeRender,g="";return i.triggerSelectOnValidInput&&(t=s.findSuggestionIndex(l),t!==-1)?void s.select(t):(e.each(s.suggestions,function(e,t){g+='<div class="'+a+'" data-index="'+e+'">'+o(t,l)+"</div>"}),"auto"===i.width&&(n=s.el.outerWidth()-2,u.width(n>0?n:300)),u.html(g),i.autoSelectFirst&&(s.selectedIndex=0,u.children().first().addClass(r)),e.isFunction(c)&&c.call(s.element,u),u.show(),s.visible=!0,void s.findBestHint())},findBestHint:function(){var t=this,n=t.el.val().toLowerCase(),s=null;n&&(e.each(t.suggestions,function(e,t){var i=0===t.value.toLowerCase().indexOf(n);return i&&(s=t),!i}),t.signalHint(s))},signalHint:function(t){var n="",s=this;t&&(n=s.currentValue+t.value.substr(s.currentValue.length)),s.hintValue!==n&&(s.hintValue=n,s.hint=t,(this.options.onHint||e.noop)(n))},verifySuggestionsFormat:function(t){return t.length&&"string"==typeof t[0]?e.map(t,function(e){return{value:e,data:null}}):t},processResponse:function(e,t,n){var s=this,i=s.options,o=i.transformResult(e,t);o.suggestions=s.verifySuggestionsFormat(o.suggestions),i.noCache||(s.cachedResponse[n]=o,0===o.suggestions.length&&s.badQueries.push(n)),t===s.getQuery(s.currentValue)&&(s.suggestions=o.suggestions,s.suggest())},activate:function(t){var n,s=this,i=s.classes.selected,o=e(s.suggestionsContainer),l=o.children();return s.selectedIndex===t?null:(o.children("."+i).removeClass(i),s.selectedIndex=t,s.selectedIndex!==-1&&l.length>s.selectedIndex?(n=l.get(s.selectedIndex),e(n).addClass(i),s.options.onPreSelect(s.suggestions[t],n),n):null)},selectHint:function(){var t=this,n=e.inArray(t.hint,t.suggestions);t.select(n)},select:function(e){var t=this;t.hide(),t.onSelect(e)},moveUp:function(){var t=this;if(t.selectedIndex!==-1)return 0===t.selectedIndex?(e(t.suggestionsContainer).children().first().removeClass(t.classes.selected),t.selectedIndex=-1,t.el.val(t.currentValue),void t.findBestHint()):void t.adjustScroll(t.selectedIndex-1)},moveDown:function(){var e=this;e.selectedIndex!==e.suggestions.length-1&&e.adjustScroll(e.selectedIndex+1)},adjustScroll:function(t){var n,s,i,o=this,l=o.activate(t),a=25;l&&(n=l.offsetTop,s=e(o.suggestionsContainer).scrollTop(),i=s+o.options.maxHeight-a,n<s?e(o.suggestionsContainer).scrollTop(n):n>i&&e(o.suggestionsContainer).scrollTop(n-o.options.maxHeight+a),o.el.val(o.getValue(o.suggestions[t].value)),o.signalHint(null))},onSelect:function(t){var n=this,s=n.options.onSelect,i=n.suggestions[t];n.currentValue=n.getValue(i.value),n.el.val(n.currentValue),n.signalHint(null),n.suggestions=[],n.selection=i,e.isFunction(s)&&s.call(n.element,i)},getValue:function(e){var t,n,s=this,i=s.options.delimiter;return i?(t=s.currentValue,n=t.split(i),1===n.length?e:t.substr(0,t.length-n[n.length-1].length)+e):e},dispose:function(){var t=this;t.el.off(".autocomplete").removeData("autocomplete"),t.disableKillerFn(),e(window).off("resize.autocomplete",t.fixPositionCapture),e(t.suggestionsContainer).remove()}},e.fn.autocomplete=function(n,s){var i="autocomplete";return 0===arguments.length?this.first().data(i):this.each(function(){var o=e(this),l=o.data(i);"string"==typeof n?l&&"function"==typeof l[n]&&l[n](s):(l&&l.dispose&&l.dispose(),l=new t(this,n),o.data(i,l))})}});
+!function(e){"use strict";"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)}(function(e){"use strict";function t(n,s){var i=function(){},o=this,l={autoSelectFirst:!1,appendTo:"body",serviceUrl:null,lookup:null,onSelect:null,width:"auto",minChars:1,maxHeight:300,deferRequestBy:0,params:{},formatResult:t.formatResult,onPreSelect:i,delimiter:null,zIndex:9999,type:"GET",noCache:!1,onSearchStart:i,onSearchComplete:i,onSearchError:i,containerClass:"autocomplete-suggestions",tabDisabled:!1,dataType:"text",currentRequest:null,triggerSelectOnValidInput:!0,lookupFilter:function(e,t,n){return-1!==e.value.toLowerCase().indexOf(n)},paramName:"query",transformResult:function(t){return"string"==typeof t?e.parseJSON(t):t}};o.element=n,o.el=e(n),o.suggestions=[],o.badQueries=[],o.selectedIndex=-1,o.currentValue=o.element.value,o.intervalId=0,o.cachedResponse={},o.onChangeInterval=null,o.onChange=null,o.isLocal=!1,o.suggestionsContainer=null,o.options=e.extend({},l,s),o.classes={selected:"autocomplete-selected",suggestion:"autocomplete-suggestion"},o.hint=null,o.hintValue="",o.selection=null,o.initialize(),o.setOptions(s)}var n=function(){return{escapeRegExChars:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},createNode:function(e){var t=document.createElement("div");return t.className=e,t.style.position="absolute",t.style.display="none",t.style.cursor="pointer",t}}}(),s={ESC:27,TAB:9,RETURN:13,LEFT:37,UP:38,RIGHT:39,DOWN:40};t.utils=n,e.Autocomplete=t,t.formatResult=function(e,t){var s="("+n.escapeRegExChars(t)+")";return e.value.replace(new RegExp(s,"gi"),"<strong>$1</strong>")},t.prototype={killerFn:null,initialize:function(){var n,s=this,i="."+s.classes.suggestion,o=(s.classes.selected,s.options);s.element.setAttribute("autocomplete","off"),s.killerFn=function(t){0===e(t.target).closest("."+s.options.containerClass).length&&(s.killSuggestions(),s.disableKillerFn())},s.suggestionsContainer=t.utils.createNode(o.containerClass),n=e(s.suggestionsContainer),n.appendTo(o.appendTo),"auto"!==o.width&&n.width(o.width),n.on("click.autocomplete",i,function(){s.select(e(this).data("index"))}),s.fixPosition(),s.fixPositionCapture=function(){s.visible&&s.fixPosition()},e(window).on("resize.autocomplete",s.fixPositionCapture),s.el.on("keydown.autocomplete",function(e){s.onKeyPress(e)}),s.el.on("keyup.autocomplete",function(e){s.onKeyUp(e)}),s.el.on("blur.autocomplete",function(){s.onBlur()}),s.el.on("focus.autocomplete",function(){s.onFocus()}),s.el.on("change.autocomplete",function(e){s.onKeyUp(e)})},onFocus:function(){var e=this;e.fixPosition(),e.options.minChars<=e.el.val().length},onBlur:function(){this.enableKillerFn()},setOptions:function(t){var n=this,s=n.options;e.extend(s,t),n.isLocal=e.isArray(s.lookup),n.isLocal&&(s.lookup=n.verifySuggestionsFormat(s.lookup)),e(n.suggestionsContainer).css({"max-height":s.maxHeight+"px",width:s.width+"px","z-index":s.zIndex})},clearCache:function(){this.cachedResponse={},this.badQueries=[]},clear:function(){this.clearCache(),this.currentValue="",this.suggestions=[]},disable:function(){var e=this;e.disabled=!0,e.currentRequest&&e.currentRequest.abort()},enable:function(){this.disabled=!1},fixPosition:function(){var t,n,s=this;"body"===s.options.appendTo&&(t=s.el.offset(),n={top:t.top+s.el.outerHeight()+"px",left:t.left+"px"},"auto"===s.options.width&&(n.width=s.el.outerWidth()-2+"px"),e(s.suggestionsContainer).css(n))},enableKillerFn:function(){var t=this;e(document).on("click.autocomplete",t.killerFn)},disableKillerFn:function(){var t=this;e(document).off("click.autocomplete",t.killerFn)},killSuggestions:function(){var e=this;e.stopKillSuggestions(),e.intervalId=window.setInterval(function(){e.hide(),e.stopKillSuggestions()},50)},stopKillSuggestions:function(){window.clearInterval(this.intervalId)},isCursorAtEnd:function(){var e,t=this,n=t.el.val().length,s=t.element.selectionStart;return"number"==typeof s?s===n:document.selection?(e=document.selection.createRange(),e.moveStart("character",-n),n===e.text.length):!0},onKeyPress:function(e){var t=this;if(!t.disabled&&!t.visible&&e.which===s.DOWN&&t.currentValue)return void t.suggest();if(!t.disabled&&t.visible){switch(e.which){case s.ESC:t.el.val(t.currentValue),t.hide();break;case s.RIGHT:if(t.hint&&t.options.onHint&&t.isCursorAtEnd()){t.selectHint();break}return;case s.TAB:if(t.hint&&t.options.onHint)return void t.selectHint();case s.RETURN:if(-1===t.selectedIndex)return void t.hide();if(t.select(t.selectedIndex),e.which===s.TAB&&t.options.tabDisabled===!1)return;break;case s.UP:t.moveUp();break;case s.DOWN:t.moveDown();break;default:return}e.stopImmediatePropagation(),e.preventDefault()}},onKeyUp:function(e){var t=this;if(!t.disabled){switch(e.which){case s.UP:case s.DOWN:return}clearInterval(t.onChangeInterval),t.currentValue!==t.el.val()&&(t.findBestHint(),t.options.deferRequestBy>0?t.onChangeInterval=setInterval(function(){t.onValueChange()},t.options.deferRequestBy):t.onValueChange())}},onValueChange:function(){var t,n=this,s=n.options,i=n.el.val(),o=n.getQuery(i);return n.selection&&(n.selection=null,(s.onInvalidateSelection||e.noop).call(n.element)),clearInterval(n.onChangeInterval),n.currentValue=i,n.selectedIndex=-1,s.triggerSelectOnValidInput&&(t=n.findSuggestionIndex(o),-1!==t)?void n.select(t):void(o.length<s.minChars?n.hide():n.getSuggestions(o))},findSuggestionIndex:function(t){var n=this,s=-1,i=t.toLowerCase();return e.each(n.suggestions,function(e,t){return t.value.toLowerCase()===i?(s=e,!1):void 0}),s},getQuery:function(t){var n,s=this.options.delimiter;return s?(n=t.split(s),e.trim(n[n.length-1])):t},getSuggestionsLocal:function(t){var n,s=this,i=s.options,o=t.toLowerCase(),l=i.lookupFilter,a=parseInt(i.lookupLimit,10);return n={suggestions:e.grep(i.lookup,function(e){return l(e,t,o)})},a&&n.suggestions.length>a&&(n.suggestions=n.suggestions.slice(0,a)),n},getSuggestions:function(t){var n,s,i,o=this,l=o.options,a=l.serviceUrl;if(l.params[l.paramName]=t,s=l.ignoreParams?null:l.params,o.isLocal?n=o.getSuggestionsLocal(t):(e.isFunction(a)&&(a=a.call(o.element,t)),i=a+"?"+e.param(s||{}),n=o.cachedResponse[i]),n&&e.isArray(n.suggestions))o.suggestions=n.suggestions,o.suggest();else if(!o.isBadQuery(t)){if(l.onSearchStart.call(o.element,l.params)===!1)return;o.currentRequest&&o.currentRequest.abort(),o.currentRequest=e.ajax({url:a,data:s,type:l.type,dataType:l.dataType}).done(function(e){o.currentRequest=null,o.processResponse(e,t,i),l.onSearchComplete.call(o.element,t)}).fail(function(e,n,s){l.onSearchError.call(o.element,t,e,n,s)})}},isBadQuery:function(e){for(var t=this.badQueries,n=t.length;n--;)if(0===e.indexOf(t[n]))return!0;return!1},hide:function(){var t=this;t.visible=!1,t.selectedIndex=-1,e(t.suggestionsContainer).hide(),t.signalHint(null)},suggest:function(){if(0===this.suggestions.length)return void this.hide();var t,n,s=this,i=s.options,o=i.formatResult,l=s.getQuery(s.currentValue),a=s.classes.suggestion,r=s.classes.selected,u=e(s.suggestionsContainer),c=i.beforeRender,g="";return i.triggerSelectOnValidInput&&(t=s.findSuggestionIndex(l),-1!==t)?void s.select(t):(e.each(s.suggestions,function(e,t){g+='<div class="'+a+'" data-index="'+e+'">'+o(t,l)+"</div>"}),"auto"===i.width&&(n=s.el.outerWidth()-2,u.width(n>0?n:300)),u.html(g),i.autoSelectFirst&&(s.selectedIndex=0,u.children().first().addClass(r)),e.isFunction(c)&&c.call(s.element,u),u.show(),s.visible=!0,void s.findBestHint())},findBestHint:function(){var t=this,n=t.el.val().toLowerCase(),s=null;n&&(e.each(t.suggestions,function(e,t){var i=0===t.value.toLowerCase().indexOf(n);return i&&(s=t),!i}),t.signalHint(s))},signalHint:function(t){var n="",s=this;t&&(n=s.currentValue+t.value.substr(s.currentValue.length)),s.hintValue!==n&&(s.hintValue=n,s.hint=t,(this.options.onHint||e.noop)(n))},verifySuggestionsFormat:function(t){return t.length&&"string"==typeof t[0]?e.map(t,function(e){return{value:e,data:null}}):t},processResponse:function(e,t,n){var s=this,i=s.options,o=i.transformResult(e,t);o.suggestions=s.verifySuggestionsFormat(o.suggestions),i.noCache||(s.cachedResponse[n]=o,0===o.suggestions.length&&s.badQueries.push(n)),t===s.getQuery(s.currentValue)&&(s.suggestions=o.suggestions,s.suggest())},activate:function(t){var n,s=this,i=s.classes.selected,o=e(s.suggestionsContainer),l=o.children();return s.selectedIndex===t?null:(o.children("."+i).removeClass(i),s.selectedIndex=t,-1!==s.selectedIndex&&l.length>s.selectedIndex?(n=l.get(s.selectedIndex),e(n).addClass(i),s.options.onPreSelect(s.suggestions[t],n),n):null)},selectHint:function(){var t=this,n=e.inArray(t.hint,t.suggestions);t.select(n)},select:function(e){var t=this;t.hide(),t.onSelect(e)},moveUp:function(){var t=this;if(-1!==t.selectedIndex)return 0===t.selectedIndex?(e(t.suggestionsContainer).children().first().removeClass(t.classes.selected),t.selectedIndex=-1,t.el.val(t.currentValue),void t.findBestHint()):void t.adjustScroll(t.selectedIndex-1)},moveDown:function(){var e=this;e.selectedIndex!==e.suggestions.length-1&&e.adjustScroll(e.selectedIndex+1)},adjustScroll:function(t){var n,s,i,o=this,l=o.activate(t),a=25;l&&(n=l.offsetTop,s=e(o.suggestionsContainer).scrollTop(),i=s+o.options.maxHeight-a,s>n?e(o.suggestionsContainer).scrollTop(n):n>i&&e(o.suggestionsContainer).scrollTop(n-o.options.maxHeight+a),o.el.val(o.getValue(o.suggestions[t].value)),o.signalHint(null))},onSelect:function(t){var n=this,s=n.options.onSelect,i=n.suggestions[t];n.currentValue=n.getValue(i.value),n.el.val(n.currentValue),n.signalHint(null),n.suggestions=[],n.selection=i,e.isFunction(s)&&s.call(n.element,i)},getValue:function(e){var t,n,s=this,i=s.options.delimiter;return i?(t=s.currentValue,n=t.split(i),1===n.length?e:t.substr(0,t.length-n[n.length-1].length)+e):e},dispose:function(){var t=this;t.el.off(".autocomplete").removeData("autocomplete"),t.disableKillerFn(),e(window).off("resize.autocomplete",t.fixPositionCapture),e(t.suggestionsContainer).remove()}},e.fn.autocomplete=function(n,s){var i="autocomplete";return 0===arguments.length?this.first().data(i):this.each(function(){var o=e(this),l=o.data(i);"string"==typeof n?l&&"function"==typeof l[n]&&l[n](s):(l&&l.dispose&&l.dispose(),l=new t(this,n),o.data(i,l))})}});
 
 },{}],17:[function(require,module,exports){
-!function(e,t){"use strict";var r=e.History=e.History||{},a=e.jQuery;if("undefined"!=typeof r.Adapter)throw new Error("History.js Adapter has already been loaded...");r.Adapter={bind:function(e,t,r){a(e).bind(t,r)},trigger:function(e,t,r){a(e).trigger(t,r)},extractEventData:function(e,r,a){var n=r&&r.originalEvent&&r.originalEvent[e]||a&&a[e]||t;return n},onDomLoad:function(e){a(e)}},"undefined"!=typeof r.init&&r.init()}(window),function(e,t){"use strict";var r=e.console||t,a=e.document,n=e.navigator,o=e.sessionStorage||!1,i=e.setTimeout,s=e.clearTimeout,u=e.setInterval,l=e.clearInterval,d=e.JSON,c=e.alert,p=e.History=e.History||{},f=e.history;try{o.setItem("TEST","1"),o.removeItem("TEST")}catch(g){o=!1}if(d.stringify=d.stringify||d.encode,d.parse=d.parse||d.decode,"undefined"!=typeof p.init)throw new Error("History.js Core has already been loaded...");p.init=function(e){return"undefined"!=typeof p.Adapter&&("undefined"!=typeof p.initCore&&p.initCore(),"undefined"!=typeof p.initHtml4&&p.initHtml4(),!0)},p.initCore=function(g){if("undefined"!=typeof p.initCore.initialized)return!1;if(p.initCore.initialized=!0,p.options=p.options||{},p.options.hashChangeInterval=p.options.hashChangeInterval||100,p.options.safariPollInterval=p.options.safariPollInterval||500,p.options.doubleCheckInterval=p.options.doubleCheckInterval||500,p.options.disableSuid=p.options.disableSuid||!1,p.options.storeInterval=p.options.storeInterval||1e3,p.options.busyDelay=p.options.busyDelay||250,p.options.debug=p.options.debug||!1,p.options.initialTitle=p.options.initialTitle||a.title,p.options.html4Mode=p.options.html4Mode||!1,p.options.delayInit=p.options.delayInit||!1,p.intervalList=[],p.clearAllIntervals=function(){var e,t=p.intervalList;if("undefined"!=typeof t&&null!==t){for(e=0;e<t.length;e++)l(t[e]);p.intervalList=null}},p.debug=function(){(p.options.debug||!1)&&p.log.apply(p,arguments)},p.log=function(){var e,t,n,o,i,s="undefined"!=typeof r&&"undefined"!=typeof r.log&&"undefined"!=typeof r.log.apply,u=a.getElementById("log");for(s?(o=Array.prototype.slice.call(arguments),e=o.shift(),"undefined"!=typeof r.debug?r.debug.apply(r,[e,o]):r.log.apply(r,[e,o])):e="\n"+arguments[0]+"\n",t=1,n=arguments.length;t<n;++t){if(i=arguments[t],"object"==typeof i&&"undefined"!=typeof d)try{i=d.stringify(i)}catch(l){}e+="\n"+i+"\n"}return u?(u.value+=e+"\n-----\n",u.scrollTop=u.scrollHeight-u.clientHeight):s||c(e),!0},p.getInternetExplorerMajorVersion=function(){var e=p.getInternetExplorerMajorVersion.cached="undefined"!=typeof p.getInternetExplorerMajorVersion.cached?p.getInternetExplorerMajorVersion.cached:function(){for(var e=3,t=a.createElement("div"),r=t.getElementsByTagName("i");(t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&r[0];);return e>4&&e}();return e},p.isInternetExplorer=function(){var e=p.isInternetExplorer.cached="undefined"!=typeof p.isInternetExplorer.cached?p.isInternetExplorer.cached:Boolean(p.getInternetExplorerMajorVersion());return e},p.options.html4Mode?p.emulated={pushState:!0,hashChange:!0}:p.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(n.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(n.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in a)||p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8)},p.enabled=!p.emulated.pushState,p.bugs={setHash:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),safariPoll:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),ieDoubleCheck:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<7)},p.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},p.cloneObject=function(e){var t,r;return e?(t=d.stringify(e),r=d.parse(t)):r={},r},p.getRootUrl=function(){var e=a.location.protocol+"//"+(a.location.hostname||a.location.host);return a.location.port&&(e+=":"+a.location.port),e+="/"},p.getBaseHref=function(){var e=a.getElementsByTagName("base"),t=null,r="";return 1===e.length&&(t=e[0],r=t.href.replace(/[^\/]+$/,"")),r=r.replace(/\/+$/,""),r&&(r+="/"),r},p.getBaseUrl=function(){var e=p.getBaseHref()||p.getBasePageUrl()||p.getRootUrl();return e},p.getPageUrl=function(){var e,t=p.getState(!1,!1),r=(t||{}).url||p.getLocationHref();return e=r.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,r){return/\./.test(e)?e:e+"/"})},p.getBasePageUrl=function(){var e=p.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,r){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},p.getFullUrl=function(e,t){var r=e,a=e.substring(0,1);return t="undefined"==typeof t||t,/[a-z]+\:\/\//.test(e)||(r="/"===a?p.getRootUrl()+e.replace(/^\/+/,""):"#"===a?p.getPageUrl().replace(/#.*/,"")+e:"?"===a?p.getPageUrl().replace(/[\?#].*/,"")+e:t?p.getBaseUrl()+e.replace(/^(\.\/)+/,""):p.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),r.replace(/\#$/,"")},p.getShortUrl=function(e){var t=e,r=p.getBaseUrl(),a=p.getRootUrl();return p.emulated.pushState&&(t=t.replace(r,"")),t=t.replace(a,"/"),p.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,"")},p.getLocationHref=function(e){return e=e||a,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},p.store={},p.idToState=p.idToState||{},p.stateToId=p.stateToId||{},p.urlToId=p.urlToId||{},p.storedStates=p.storedStates||[],p.savedStates=p.savedStates||[],p.normalizeStore=function(){p.store.idToState=p.store.idToState||{},p.store.urlToId=p.store.urlToId||{},p.store.stateToId=p.store.stateToId||{}},p.getState=function(e,t){"undefined"==typeof e&&(e=!0),"undefined"==typeof t&&(t=!0);var r=p.getLastSavedState();return!r&&t&&(r=p.createStateObject()),e&&(r=p.cloneObject(r),r.url=r.cleanUrl||r.url),r},p.getIdByState=function(e){var t,r=p.extractId(e.url);if(!r)if(t=p.getStateString(e),"undefined"!=typeof p.stateToId[t])r=p.stateToId[t];else if("undefined"!=typeof p.store.stateToId[t])r=p.store.stateToId[t];else{for(;r=(new Date).getTime()+String(Math.random()).replace(/\D/g,""),"undefined"!=typeof p.idToState[r]||"undefined"!=typeof p.store.idToState[r];);p.stateToId[t]=r,p.idToState[r]=e}return r},p.normalizeState=function(e){var t,r;return e&&"object"==typeof e||(e={}),"undefined"!=typeof e.normalized?e:(e.data&&"object"==typeof e.data||(e.data={}),t={},t.normalized=!0,t.title=e.title||"",t.url=p.getFullUrl(e.url?e.url:p.getLocationHref()),t.hash=p.getShortUrl(t.url),t.data=p.cloneObject(e.data),t.id=p.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,r=!p.isEmptyObject(t.data),(t.title||r)&&p.options.disableSuid!==!0&&(t.hash=p.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=p.getFullUrl(t.hash),(p.emulated.pushState||p.bugs.safariPoll)&&p.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t)},p.createStateObject=function(e,t,r){var a={data:e,title:t,url:r};return a=p.normalizeState(a)},p.getStateById=function(e){e=String(e);var r=p.idToState[e]||p.store.idToState[e]||t;return r},p.getStateString=function(e){var t,r,a;return t=p.normalizeState(e),r={data:t.data,title:e.title,url:e.url},a=d.stringify(r)},p.getStateId=function(e){var t,r;return t=p.normalizeState(e),r=t.id},p.getHashByState=function(e){var t,r;return t=p.normalizeState(e),r=t.hash},p.extractId=function(e){var t,r,a,n;return n=e.indexOf("#")!=-1?e.split("#")[0]:e,r=/(.*)\&_suid=([0-9]+)$/.exec(n),a=r?r[1]||e:e,t=r?String(r[2]||""):"",t||!1},p.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},p.extractState=function(e,t){var r,a,n=null;return t=t||!1,r=p.extractId(e),r&&(n=p.getStateById(r)),n||(a=p.getFullUrl(e),r=p.getIdByUrl(a)||!1,r&&(n=p.getStateById(r)),!n&&t&&!p.isTraditionalAnchor(e)&&(n=p.createStateObject(null,null,a))),n},p.getIdByUrl=function(e){var r=p.urlToId[e]||p.store.urlToId[e]||t;return r},p.getLastSavedState=function(){return p.savedStates[p.savedStates.length-1]||t},p.getLastStoredState=function(){return p.storedStates[p.storedStates.length-1]||t},p.hasUrlDuplicate=function(e){var t,r=!1;return t=p.extractState(e.url),r=t&&t.id!==e.id},p.storeState=function(e){return p.urlToId[e.url]=e.id,p.storedStates.push(p.cloneObject(e)),e},p.isLastSavedState=function(e){var t,r,a,n=!1;return p.savedStates.length&&(t=e.id,r=p.getLastSavedState(),a=r.id,n=t===a),n},p.saveState=function(e){return!p.isLastSavedState(e)&&(p.savedStates.push(p.cloneObject(e)),!0)},p.getStateByIndex=function(e){var t=null;return t="undefined"==typeof e?p.savedStates[p.savedStates.length-1]:e<0?p.savedStates[p.savedStates.length+e]:p.savedStates[e]},p.getCurrentIndex=function(){var e=null;return e=p.savedStates.length<1?0:p.savedStates.length-1},p.getHash=function(e){var t,r=p.getLocationHref(e);return t=p.getHashByUrl(r)},p.unescapeHash=function(e){var t=p.normalizeHash(e);return t=decodeURIComponent(t)},p.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},p.setHash=function(e,t){var r,n;return t!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.setHash,args:arguments,queue:t}),!1):(p.busy(!0),r=p.extractState(e,!0),r&&!p.emulated.pushState?p.pushState(r.data,r.title,r.url,!1):p.getHash()!==e&&(p.bugs.setHash?(n=p.getPageUrl(),p.pushState(null,null,n+"#"+e,!1)):a.location.hash=e),p)},p.escapeHash=function(t){var r=p.normalizeHash(t);return r=e.encodeURIComponent(r),p.bugs.hashEscape||(r=r.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),r},p.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=p.unescapeHash(t)},p.setTitle=function(e){var t,r=e.title;r||(t=p.getStateByIndex(0),t&&t.url===e.url&&(r=t.title||p.options.initialTitle));try{a.getElementsByTagName("title")[0].innerHTML=r.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(n){}return a.title=r,p},p.queues=[],p.busy=function(e){if("undefined"!=typeof e?p.busy.flag=e:"undefined"==typeof p.busy.flag&&(p.busy.flag=!1),!p.busy.flag){s(p.busy.timeout);var t=function(){var e,r,a;if(!p.busy.flag)for(e=p.queues.length-1;e>=0;--e)r=p.queues[e],0!==r.length&&(a=r.shift(),p.fireQueueItem(a),p.busy.timeout=i(t,p.options.busyDelay))};p.busy.timeout=i(t,p.options.busyDelay)}return p.busy.flag},p.busy.flag=!1,p.fireQueueItem=function(e){return e.callback.apply(e.scope||p,e.args||[])},p.pushQueue=function(e){return p.queues[e.queue||0]=p.queues[e.queue||0]||[],p.queues[e.queue||0].push(e),p},p.queue=function(e,t){return"function"==typeof e&&(e={callback:e}),"undefined"!=typeof t&&(e.queue=t),p.busy()?p.pushQueue(e):p.fireQueueItem(e),p},p.clearQueue=function(){return p.busy.flag=!1,p.queues=[],p},p.stateChanged=!1,p.doubleChecker=!1,p.doubleCheckComplete=function(){return p.stateChanged=!0,p.doubleCheckClear(),p},p.doubleCheckClear=function(){return p.doubleChecker&&(s(p.doubleChecker),p.doubleChecker=!1),p},p.doubleCheck=function(e){return p.stateChanged=!1,p.doubleCheckClear(),p.bugs.ieDoubleCheck&&(p.doubleChecker=i(function(){return p.doubleCheckClear(),p.stateChanged||e(),!0},p.options.doubleCheckInterval)),p},p.safariStatePoll=function(){var t,r=p.extractState(p.getLocationHref());if(!p.isLastSavedState(r))return t=r,t||(t=p.createStateObject()),p.Adapter.trigger(e,"popstate"),p},p.back=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.back,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.back(!1)}),f.go(-1),!0)},p.forward=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.forward,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.forward(!1)}),f.go(1),!0)},p.go=function(e,t){var r;if(e>0)for(r=1;r<=e;++r)p.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(r=-1;r>=e;--r)p.back(t)}return p},p.emulated.pushState){var h=function(){};p.pushState=p.pushState||h,p.replaceState=p.replaceState||h}else p.onPopState=function(t,r){var a,n,o=!1,i=!1;return p.doubleCheckComplete(),a=p.getHash(),a?(n=p.extractState(a||p.getLocationHref(),!0),n?p.replaceState(n.data,n.title,n.url,!1):(p.Adapter.trigger(e,"anchorchange"),p.busy(!1)),p.expectedStateId=!1,!1):(o=p.Adapter.extractEventData("state",t,r)||!1,i=o?p.getStateById(o):p.expectedStateId?p.getStateById(p.expectedStateId):p.extractState(p.getLocationHref()),i||(i=p.createStateObject(null,null,p.getLocationHref())),p.expectedStateId=!1,p.isLastSavedState(i)?(p.busy(!1),!1):(p.storeState(i),p.saveState(i),p.setTitle(i),p.Adapter.trigger(e,"statechange"),p.busy(!1),!0))},p.Adapter.bind(e,"popstate",p.onPopState),p.pushState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.pushState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.pushState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0},p.replaceState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.replaceState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.replaceState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0};if(o){try{p.store=d.parse(o.getItem("History.store"))||{}}catch(S){p.store={}}p.normalizeStore()}else p.store={},p.normalizeStore();p.Adapter.bind(e,"unload",p.clearAllIntervals),p.saveState(p.storeState(p.extractState(p.getLocationHref(),!0))),o&&(p.onUnload=function(){var e,t,r;try{e=d.parse(o.getItem("History.store"))||{}}catch(a){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in p.idToState)p.idToState.hasOwnProperty(t)&&(e.idToState[t]=p.idToState[t]);for(t in p.urlToId)p.urlToId.hasOwnProperty(t)&&(e.urlToId[t]=p.urlToId[t]);for(t in p.stateToId)p.stateToId.hasOwnProperty(t)&&(e.stateToId[t]=p.stateToId[t]);p.store=e,p.normalizeStore(),r=d.stringify(e);try{o.setItem("History.store",r)}catch(n){if(n.code!==DOMException.QUOTA_EXCEEDED_ERR)throw n;o.length&&(o.removeItem("History.store"),o.setItem("History.store",r))}},p.intervalList.push(u(p.onUnload,p.options.storeInterval)),p.Adapter.bind(e,"beforeunload",p.onUnload),p.Adapter.bind(e,"unload",p.onUnload)),p.emulated.pushState||(p.bugs.safariPoll&&p.intervalList.push(u(p.safariStatePoll,p.options.safariPollInterval)),"Apple Computer, Inc."!==n.vendor&&"Mozilla"!==(n.appCodeName||"")||(p.Adapter.bind(e,"hashchange",function(){p.Adapter.trigger(e,"popstate")}),p.getHash()&&p.Adapter.onDomLoad(function(){p.Adapter.trigger(e,"hashchange")})))},(!p.options||!p.options.delayInit)&&p.init()}(window);
+!function(e,t){"use strict";var r=e.History=e.History||{},a=e.jQuery;if("undefined"!=typeof r.Adapter)throw new Error("History.js Adapter has already been loaded...");r.Adapter={bind:function(e,t,r){a(e).bind(t,r)},trigger:function(e,t,r){a(e).trigger(t,r)},extractEventData:function(e,r,a){var n=r&&r.originalEvent&&r.originalEvent[e]||a&&a[e]||t;return n},onDomLoad:function(e){a(e)}},"undefined"!=typeof r.init&&r.init()}(window),function(e,t){"use strict";var r=e.console||t,a=e.document,n=e.navigator,o=e.sessionStorage||!1,i=e.setTimeout,s=e.clearTimeout,u=e.setInterval,l=e.clearInterval,d=e.JSON,c=e.alert,p=e.History=e.History||{},f=e.history;try{o.setItem("TEST","1"),o.removeItem("TEST")}catch(g){o=!1}if(d.stringify=d.stringify||d.encode,d.parse=d.parse||d.decode,"undefined"!=typeof p.init)throw new Error("History.js Core has already been loaded...");p.init=function(e){return"undefined"==typeof p.Adapter?!1:("undefined"!=typeof p.initCore&&p.initCore(),"undefined"!=typeof p.initHtml4&&p.initHtml4(),!0)},p.initCore=function(g){if("undefined"!=typeof p.initCore.initialized)return!1;if(p.initCore.initialized=!0,p.options=p.options||{},p.options.hashChangeInterval=p.options.hashChangeInterval||100,p.options.safariPollInterval=p.options.safariPollInterval||500,p.options.doubleCheckInterval=p.options.doubleCheckInterval||500,p.options.disableSuid=p.options.disableSuid||!1,p.options.storeInterval=p.options.storeInterval||1e3,p.options.busyDelay=p.options.busyDelay||250,p.options.debug=p.options.debug||!1,p.options.initialTitle=p.options.initialTitle||a.title,p.options.html4Mode=p.options.html4Mode||!1,p.options.delayInit=p.options.delayInit||!1,p.intervalList=[],p.clearAllIntervals=function(){var e,t=p.intervalList;if("undefined"!=typeof t&&null!==t){for(e=0;e<t.length;e++)l(t[e]);p.intervalList=null}},p.debug=function(){(p.options.debug||!1)&&p.log.apply(p,arguments)},p.log=function(){var e,t,n,o,i,s="undefined"!=typeof r&&"undefined"!=typeof r.log&&"undefined"!=typeof r.log.apply,u=a.getElementById("log");for(s?(o=Array.prototype.slice.call(arguments),e=o.shift(),"undefined"!=typeof r.debug?r.debug.apply(r,[e,o]):r.log.apply(r,[e,o])):e="\n"+arguments[0]+"\n",t=1,n=arguments.length;n>t;++t){if(i=arguments[t],"object"==typeof i&&"undefined"!=typeof d)try{i=d.stringify(i)}catch(l){}e+="\n"+i+"\n"}return u?(u.value+=e+"\n-----\n",u.scrollTop=u.scrollHeight-u.clientHeight):s||c(e),!0},p.getInternetExplorerMajorVersion=function(){var e=p.getInternetExplorerMajorVersion.cached="undefined"!=typeof p.getInternetExplorerMajorVersion.cached?p.getInternetExplorerMajorVersion.cached:function(){for(var e=3,t=a.createElement("div"),r=t.getElementsByTagName("i");(t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&r[0];);return e>4?e:!1}();return e},p.isInternetExplorer=function(){var e=p.isInternetExplorer.cached="undefined"!=typeof p.isInternetExplorer.cached?p.isInternetExplorer.cached:Boolean(p.getInternetExplorerMajorVersion());return e},p.options.html4Mode?p.emulated={pushState:!0,hashChange:!0}:p.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(n.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(n.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in a)||p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8)},p.enabled=!p.emulated.pushState,p.bugs={setHash:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),safariPoll:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),ieDoubleCheck:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<7)},p.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},p.cloneObject=function(e){var t,r;return e?(t=d.stringify(e),r=d.parse(t)):r={},r},p.getRootUrl=function(){var e=a.location.protocol+"//"+(a.location.hostname||a.location.host);return a.location.port&&(e+=":"+a.location.port),e+="/"},p.getBaseHref=function(){var e=a.getElementsByTagName("base"),t=null,r="";return 1===e.length&&(t=e[0],r=t.href.replace(/[^\/]+$/,"")),r=r.replace(/\/+$/,""),r&&(r+="/"),r},p.getBaseUrl=function(){var e=p.getBaseHref()||p.getBasePageUrl()||p.getRootUrl();return e},p.getPageUrl=function(){var e,t=p.getState(!1,!1),r=(t||{}).url||p.getLocationHref();return e=r.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,r){return/\./.test(e)?e:e+"/"})},p.getBasePageUrl=function(){var e=p.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,r){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},p.getFullUrl=function(e,t){var r=e,a=e.substring(0,1);return t="undefined"==typeof t?!0:t,/[a-z]+\:\/\//.test(e)||(r="/"===a?p.getRootUrl()+e.replace(/^\/+/,""):"#"===a?p.getPageUrl().replace(/#.*/,"")+e:"?"===a?p.getPageUrl().replace(/[\?#].*/,"")+e:t?p.getBaseUrl()+e.replace(/^(\.\/)+/,""):p.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),r.replace(/\#$/,"")},p.getShortUrl=function(e){var t=e,r=p.getBaseUrl(),a=p.getRootUrl();return p.emulated.pushState&&(t=t.replace(r,"")),t=t.replace(a,"/"),p.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,"")},p.getLocationHref=function(e){return e=e||a,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:-1==e.URL.indexOf("#")&&-1!=e.location.href.indexOf("#")?e.location.href:e.URL||e.location.href},p.store={},p.idToState=p.idToState||{},p.stateToId=p.stateToId||{},p.urlToId=p.urlToId||{},p.storedStates=p.storedStates||[],p.savedStates=p.savedStates||[],p.normalizeStore=function(){p.store.idToState=p.store.idToState||{},p.store.urlToId=p.store.urlToId||{},p.store.stateToId=p.store.stateToId||{}},p.getState=function(e,t){"undefined"==typeof e&&(e=!0),"undefined"==typeof t&&(t=!0);var r=p.getLastSavedState();return!r&&t&&(r=p.createStateObject()),e&&(r=p.cloneObject(r),r.url=r.cleanUrl||r.url),r},p.getIdByState=function(e){var t,r=p.extractId(e.url);if(!r)if(t=p.getStateString(e),"undefined"!=typeof p.stateToId[t])r=p.stateToId[t];else if("undefined"!=typeof p.store.stateToId[t])r=p.store.stateToId[t];else{for(;r=(new Date).getTime()+String(Math.random()).replace(/\D/g,""),"undefined"!=typeof p.idToState[r]||"undefined"!=typeof p.store.idToState[r];);p.stateToId[t]=r,p.idToState[r]=e}return r},p.normalizeState=function(e){var t,r;return e&&"object"==typeof e||(e={}),"undefined"!=typeof e.normalized?e:(e.data&&"object"==typeof e.data||(e.data={}),t={},t.normalized=!0,t.title=e.title||"",t.url=p.getFullUrl(e.url?e.url:p.getLocationHref()),t.hash=p.getShortUrl(t.url),t.data=p.cloneObject(e.data),t.id=p.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,r=!p.isEmptyObject(t.data),(t.title||r)&&p.options.disableSuid!==!0&&(t.hash=p.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=p.getFullUrl(t.hash),(p.emulated.pushState||p.bugs.safariPoll)&&p.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t)},p.createStateObject=function(e,t,r){var a={data:e,title:t,url:r};return a=p.normalizeState(a)},p.getStateById=function(e){e=String(e);var r=p.idToState[e]||p.store.idToState[e]||t;return r},p.getStateString=function(e){var t,r,a;return t=p.normalizeState(e),r={data:t.data,title:e.title,url:e.url},a=d.stringify(r)},p.getStateId=function(e){var t,r;return t=p.normalizeState(e),r=t.id},p.getHashByState=function(e){var t,r;return t=p.normalizeState(e),r=t.hash},p.extractId=function(e){var t,r,a,n;return n=-1!=e.indexOf("#")?e.split("#")[0]:e,r=/(.*)\&_suid=([0-9]+)$/.exec(n),a=r?r[1]||e:e,t=r?String(r[2]||""):"",t||!1},p.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},p.extractState=function(e,t){var r,a,n=null;return t=t||!1,r=p.extractId(e),r&&(n=p.getStateById(r)),n||(a=p.getFullUrl(e),r=p.getIdByUrl(a)||!1,r&&(n=p.getStateById(r)),!n&&t&&!p.isTraditionalAnchor(e)&&(n=p.createStateObject(null,null,a))),n},p.getIdByUrl=function(e){var r=p.urlToId[e]||p.store.urlToId[e]||t;return r},p.getLastSavedState=function(){return p.savedStates[p.savedStates.length-1]||t},p.getLastStoredState=function(){return p.storedStates[p.storedStates.length-1]||t},p.hasUrlDuplicate=function(e){var t,r=!1;return t=p.extractState(e.url),r=t&&t.id!==e.id},p.storeState=function(e){return p.urlToId[e.url]=e.id,p.storedStates.push(p.cloneObject(e)),e},p.isLastSavedState=function(e){var t,r,a,n=!1;return p.savedStates.length&&(t=e.id,r=p.getLastSavedState(),a=r.id,n=t===a),n},p.saveState=function(e){return p.isLastSavedState(e)?!1:(p.savedStates.push(p.cloneObject(e)),!0)},p.getStateByIndex=function(e){var t=null;return t="undefined"==typeof e?p.savedStates[p.savedStates.length-1]:0>e?p.savedStates[p.savedStates.length+e]:p.savedStates[e]},p.getCurrentIndex=function(){var e=null;return e=p.savedStates.length<1?0:p.savedStates.length-1},p.getHash=function(e){var t,r=p.getLocationHref(e);return t=p.getHashByUrl(r)},p.unescapeHash=function(e){var t=p.normalizeHash(e);return t=decodeURIComponent(t)},p.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},p.setHash=function(e,t){var r,n;return t!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.setHash,args:arguments,queue:t}),!1):(p.busy(!0),r=p.extractState(e,!0),r&&!p.emulated.pushState?p.pushState(r.data,r.title,r.url,!1):p.getHash()!==e&&(p.bugs.setHash?(n=p.getPageUrl(),p.pushState(null,null,n+"#"+e,!1)):a.location.hash=e),p)},p.escapeHash=function(t){var r=p.normalizeHash(t);return r=e.encodeURIComponent(r),p.bugs.hashEscape||(r=r.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),r},p.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=p.unescapeHash(t)},p.setTitle=function(e){var t,r=e.title;r||(t=p.getStateByIndex(0),t&&t.url===e.url&&(r=t.title||p.options.initialTitle));try{a.getElementsByTagName("title")[0].innerHTML=r.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(n){}return a.title=r,p},p.queues=[],p.busy=function(e){if("undefined"!=typeof e?p.busy.flag=e:"undefined"==typeof p.busy.flag&&(p.busy.flag=!1),!p.busy.flag){s(p.busy.timeout);var t=function(){var e,r,a;if(!p.busy.flag)for(e=p.queues.length-1;e>=0;--e)r=p.queues[e],0!==r.length&&(a=r.shift(),p.fireQueueItem(a),p.busy.timeout=i(t,p.options.busyDelay))};p.busy.timeout=i(t,p.options.busyDelay)}return p.busy.flag},p.busy.flag=!1,p.fireQueueItem=function(e){return e.callback.apply(e.scope||p,e.args||[])},p.pushQueue=function(e){return p.queues[e.queue||0]=p.queues[e.queue||0]||[],p.queues[e.queue||0].push(e),p},p.queue=function(e,t){return"function"==typeof e&&(e={callback:e}),"undefined"!=typeof t&&(e.queue=t),p.busy()?p.pushQueue(e):p.fireQueueItem(e),p},p.clearQueue=function(){return p.busy.flag=!1,p.queues=[],p},p.stateChanged=!1,p.doubleChecker=!1,p.doubleCheckComplete=function(){return p.stateChanged=!0,p.doubleCheckClear(),p},p.doubleCheckClear=function(){return p.doubleChecker&&(s(p.doubleChecker),p.doubleChecker=!1),p},p.doubleCheck=function(e){return p.stateChanged=!1,p.doubleCheckClear(),p.bugs.ieDoubleCheck&&(p.doubleChecker=i(function(){return p.doubleCheckClear(),p.stateChanged||e(),!0},p.options.doubleCheckInterval)),p},p.safariStatePoll=function(){var t,r=p.extractState(p.getLocationHref());return p.isLastSavedState(r)?void 0:(t=r,t||(t=p.createStateObject()),p.Adapter.trigger(e,"popstate"),p)},p.back=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.back,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.back(!1)}),f.go(-1),!0)},p.forward=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.forward,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.forward(!1)}),f.go(1),!0)},p.go=function(e,t){var r;if(e>0)for(r=1;e>=r;++r)p.forward(t);else{if(!(0>e))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(r=-1;r>=e;--r)p.back(t)}return p},p.emulated.pushState){var h=function(){};p.pushState=p.pushState||h,p.replaceState=p.replaceState||h}else p.onPopState=function(t,r){var a,n,o=!1,i=!1;return p.doubleCheckComplete(),a=p.getHash(),a?(n=p.extractState(a||p.getLocationHref(),!0),n?p.replaceState(n.data,n.title,n.url,!1):(p.Adapter.trigger(e,"anchorchange"),p.busy(!1)),p.expectedStateId=!1,!1):(o=p.Adapter.extractEventData("state",t,r)||!1,i=o?p.getStateById(o):p.expectedStateId?p.getStateById(p.expectedStateId):p.extractState(p.getLocationHref()),i||(i=p.createStateObject(null,null,p.getLocationHref())),p.expectedStateId=!1,p.isLastSavedState(i)?(p.busy(!1),!1):(p.storeState(i),p.saveState(i),p.setTitle(i),p.Adapter.trigger(e,"statechange"),p.busy(!1),!0))},p.Adapter.bind(e,"popstate",p.onPopState),p.pushState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.pushState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.pushState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0},p.replaceState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.replaceState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.replaceState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0};if(o){try{p.store=d.parse(o.getItem("History.store"))||{}}catch(S){p.store={}}p.normalizeStore()}else p.store={},p.normalizeStore();p.Adapter.bind(e,"unload",p.clearAllIntervals),p.saveState(p.storeState(p.extractState(p.getLocationHref(),!0))),o&&(p.onUnload=function(){var e,t,r;try{e=d.parse(o.getItem("History.store"))||{}}catch(a){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in p.idToState)p.idToState.hasOwnProperty(t)&&(e.idToState[t]=p.idToState[t]);for(t in p.urlToId)p.urlToId.hasOwnProperty(t)&&(e.urlToId[t]=p.urlToId[t]);for(t in p.stateToId)p.stateToId.hasOwnProperty(t)&&(e.stateToId[t]=p.stateToId[t]);p.store=e,p.normalizeStore(),r=d.stringify(e);try{o.setItem("History.store",r)}catch(n){if(n.code!==DOMException.QUOTA_EXCEEDED_ERR)throw n;o.length&&(o.removeItem("History.store"),o.setItem("History.store",r))}},p.intervalList.push(u(p.onUnload,p.options.storeInterval)),p.Adapter.bind(e,"beforeunload",p.onUnload),p.Adapter.bind(e,"unload",p.onUnload)),p.emulated.pushState||(p.bugs.safariPoll&&p.intervalList.push(u(p.safariStatePoll,p.options.safariPollInterval)),"Apple Computer, Inc."!==n.vendor&&"Mozilla"!==(n.appCodeName||"")||(p.Adapter.bind(e,"hashchange",function(){p.Adapter.trigger(e,"popstate")}),p.getHash()&&p.Adapter.onDomLoad(function(){p.Adapter.trigger(e,"hashchange")})))},(!p.options||!p.options.delayInit)&&p.init()}(window);
 
 },{}],18:[function(require,module,exports){
-L.Map.mergeOptions({contextmenuItems:[]}),L.Map.ContextMenu=L.Handler.extend({statics:{BASE_CLS:"leaflet-contextmenu"},initialize:function(t){L.Handler.prototype.initialize.call(this,t),this._items=[],this._sets=[],this._state=0,this._defaultState=t.options.contextmenuDefaultState||1,this._activeState=t.options.contextmenuAtiveState||1,this._visible=!1;var e=this._container=L.DomUtil.create("div",L.Map.ContextMenu.BASE_CLS,t._container);e.style.zIndex=1e4,e.style.position="absolute",t.options.contextmenuWidth&&(e.style.width=t.options.contextmenuWidth+"px"),void 0!==t.options.contextmenuSets&&0!==t.options.contextmenuSets.length||(t.options.contextmenuSets=[{name:"set_default",state:this._defaultState}]),this._createItems(),this._createSets(),this._changeState(),L.DomEvent.on(e,"click",L.DomEvent.stop).on(e,"mousedown",L.DomEvent.stop).on(e,"dblclick",L.DomEvent.stop).on(e,"contextmenu",L.DomEvent.stop)},addHooks:function(){L.DomEvent.on(document,L.Browser.touch?"touchstart":"mousedown",this._onMouseDown,this).on(document,"keydown",this._onKeyDown,this),this._map.on({contextmenu:this._show,mouseout:this._hide,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},removeHooks:function(){L.DomEvent.off(document,"keydown",this._onKeyDown,this),this._map.off({contextmenu:this._show,mouseout:this._hide,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},showAt:function(t,e,i){t instanceof L.LatLng&&(t=this._map.latLngToContainerPoint(t)),this._showAtPoint(t,e,i)},hide:function(){this._hide()},setState:function(t){return this._changeState(t)},setActiveState:function(t){var e,i,n,t=void 0!==t?t:this._activeState;for(i=0,n=this._sets.length;i<n;i++)if(e=this._sets[i],e.state===t){this._activeState=t;break}return e},getState:function(){return this._state},addSet:function(t){return this.insertSet(t)},insertSet:function(t,e){var e=void 0!==e?e:this._sets.length,i=this._createSet(t,e);return this._sets.push(i),i},addItem:function(t){return this.insertItem(t)},insertItem:function(t,e){var e=void 0!==e?e:this._items.length,i=this._createItem(this._container,t,e);return this._items.push(i),this._sizeChanged=!0,this._map.fire("contextmenu.additem",{contextmenu:this,el:i.el,index:e}),i.el},removeItem:function(t){var e=this._container;isNaN(t)||(t=e.children[t]),void 0!==t&&(this._removeItem(L.Util.stamp(t)),this._sizeChanged=!0,this._map.fire("contextmenu.removeitem",{contextmenu:this,el:t}))},removeAllItems:function(){for(var t;this._container.children.length;)t=this._container.children[0],this._removeItem(L.Util.stamp(t))},setDisabled:function(t,e){var i=this._container,n=L.Map.ContextMenu.BASE_CLS+"-item";isNaN(t)||(t=i.children[t]),void 0!==t&&L.DomUtil.hasClass(t,n)&&(e?(L.DomUtil.addClass(t,n+"-disabled"),this._map.fire("contextmenu.disableitem",{contextmenu:this,el:t})):(L.DomUtil.removeClass(t,n+"-disabled"),this._map.fire("contextmenu.enableitem",{contextmenu:this,el:t})))},setHidden:function(t,e){var i=this._container,n=L.Map.ContextMenu.BASE_CLS+"-item",s=L.Map.ContextMenu.BASE_CLS+"-separator";isNaN(t)||(t=i.children[t]),void 0!==t&&L.DomUtil.hasClass(t,n)?e?(L.DomUtil.addClass(t,n+"-hidden"),this._map.fire("contextmenu.hideitem",{contextmenu:this,el:t})):(L.DomUtil.removeClass(t,n+"-hidden"),this._map.fire("contextmenu.showitem",{contextmenu:this,el:t})):void 0!==t&&L.DomUtil.hasClass(t,s)&&(e?L.DomUtil.addClass(t,s+"-hidden"):L.DomUtil.removeClass(t,s+"-hidden"))},isVisible:function(){return this._visible},_changeState:function(t){var e,i,n,s,t=void 0!==t?t:this._defaultState;if(t!==this._state)for(n=0,s=this._sets.length;n<s;n++)if(e=this._sets[n],e.state===t||e.name===t&&e.state!==this._state){for(this._map.fire("contextmenu.changestate",{contextmenu:this,set:e,state:t}),n=0,s=this._items.length;n<s;n++)i=this._items[n],this.setHidden(this._items[n].el,i.state.indexOf(e.state)===-1&&i.state.indexOf(e.name)===-1);this._sizeChanged=!0,this._state=t;break}return e},_createSets:function(){var t,e,i=this._map.options.contextmenuSets;for(t=0,e=i.length;t<e;t++)this._sets.push(this._createSet(i[t],this._sets.length))},_createSet:function(t,e){void 0!==t.name?t.name:"set_"+e;return{id:e,name:t.name,state:t.state}},_createItems:function(){var t,e,i=this._map.options.contextmenuItems;for(t=0,e=i.length;t<e;t++)this._items.push(this._createItem(this._container,i[t]))},_createItem:function(t,e,i){if(e.separator||"-"===e)return this._createSeparator(t,i,e.state);var n=L.Map.ContextMenu.BASE_CLS+"-item",s=void 0!==e.state?Array.isArray(e.state)?e.state:[e.state]:[this._defaultState],o=e.disabled?n+" "+n+"-disabled":e.hidden?n+" "+n+"-hidden":n,a=this._insertElementAt("a",o,t,i),h=this._createEventHandler(a,e.callback,e.context,e.hideOnSelect),m="";return e.icon?m='<img class="'+L.Map.ContextMenu.BASE_CLS+'-icon" src="'+e.icon+'"/>':e.iconCls&&(m='<span class="'+L.Map.ContextMenu.BASE_CLS+"- icon "+e.iconCls+'"></span>'),a.innerHTML=m+e.text,a.href="#",L.DomEvent.on(a,"mouseover",this._onItemMouseOver,this).on(a,"mouseout",this._onItemMouseOut,this).on(a,"mousedown",L.DomEvent.stopPropagation).on(a,"click",h),{id:L.Util.stamp(a),el:a,callback:h,state:s}},_removeItem:function(t){var e,i,n,s,o;for(s=0,o=this._items.length;s<o;s++)if(e=this._items[s],e.id===t)return n=e.el,i=e.callback,i&&L.DomEvent.off(n,"mouseover",this._onItemMouseOver,this).off(n,"mouseover",this._onItemMouseOut,this).off(n,"mousedown",L.DomEvent.stopPropagation).off(n,"click",e.callback),this._container.removeChild(n),this._items.splice(s,1),e;return null},_createSeparator:function(t,e,i){var n=this._insertElementAt("div",L.Map.ContextMenu.BASE_CLS+"-separator",t,e),i=void 0!==i?Array.isArray(i)?i:[i]:[this._defaultState];return{id:L.Util.stamp(n),el:n,state:i}},_createEventHandler:function(t,e,i,n){var s=this,o=this._map,a=L.Map.ContextMenu.BASE_CLS+"-item-disabled",n=void 0===n||n;return function(h){L.DomUtil.hasClass(t,a)||(n&&s._hide(),e&&e.call(i||o,s._showLocation),s._map.fire("contextmenu:select",{contextmenu:s,el:t}))}},_insertElementAt:function(t,e,i,n){var s,o=document.createElement(t);return o.className=e,void 0!==n&&(s=i.children[n]),s?i.insertBefore(o,s):i.appendChild(o),o},_show:function(t){this._showAtPoint(t.containerPoint)},_showAtPoint:function(t,e,i){if(this._items.length){var n=this._map,s=n.containerPointToLayerPoint(t),o=n.layerPointToLatLng(s),a={contextmenu:this,state:i},i=void 0!==i?i:this._activeState;e&&(a=L.extend(e,a)),this._showLocation={state:i,target:e?e.relatedTarget:null,latlng:o,layerPoint:s,containerPoint:t},this._setPosition(t),this._changeState(i),this._visible?this._setPosition(t):(this._container.style.display="block",this._visible=!0),this._map.fire("contextmenu.show",a)}},_hide:function(){this._visible&&(this.setState(this._defaultState),this._visible=!1,this._container.style.display="none",this._map.fire("contextmenu.hide",{contextmenu:this}))},_setPosition:function(t){var e,i=this._map.getSize(),n=this._container,s=this._getElementSize(n);this._map.options.contextmenuAnchor&&(e=L.point(this._map.options.contextmenuAnchor),t=t.add(e)),n._leaflet_pos=t,t.x+s.x>i.x?(n.style.left="auto",n.style.right=Math.max(i.x-t.x,0)+"px"):(n.style.left=Math.max(t.x,0)+"px",n.style.right="auto"),t.y+s.y>i.y?(n.style.top="auto",n.style.bottom=Math.max(i.y-t.y,0)+"px"):(n.style.top=Math.max(t.y,0)+"px",n.style.bottom="auto")},_getElementSize:function(t){var e=this._size,i=t.style.display;return e&&!this._sizeChanged||(e={},t.style.left="-999999px",t.style.right="auto",t.style.display="block",e.x=t.offsetWidth,e.y=t.offsetHeight,t.style.left="auto",t.style.display=i,this._sizeChanged=!1),e},_onMouseDown:function(t){this._hide()},_onKeyDown:function(t){var e=t.keyCode;27===e&&this._hide()},_onItemMouseOver:function(t){L.DomUtil.addClass(t.target,"over")},_onItemMouseOut:function(t){L.DomUtil.removeClass(t.target,"over")}}),L.Map.addInitHook("addHandler","contextmenu",L.Map.ContextMenu),L.Mixin.ContextMenu={_initContextMenu:function(){this._items=[],this.on("contextmenu",this._showContextMenu,this)},_showContextMenu:function(t){var e,i,n,s;if(this._map.contextmenu){for(i=this._map.mouseEventToContainerPoint(t.originalEvent),n=0,s=this.options.contextmenuItems.length;n<s;n++)e=this.options.contextmenuItems[n],this._items.push(this._map.contextmenu.insertItem(e,e.index));this._map.once("contextmenu.hide",this._hideContextMenu,this),this._map.contextmenu.showAt(i,{relatedTarget:this},this.options.contextmenuAtiveState)}},_hideContextMenu:function(){var t,e;for(t=0,e=this._items.length;t<e;t++)this._map.contextmenu.removeItem(this._items[t]);this._items.length=0}},L.Marker.mergeOptions({contextmenu:!1,contextmenuItems:[]}),L.Marker.addInitHook(function(){this.options.contextmenu&&this._initContextMenu()}),L.Marker.include(L.Mixin.ContextMenu),L.Path.mergeOptions({contextmenu:!1,contextmenuItems:[]}),L.Path.addInitHook(function(){this.options.contextmenu&&this._initContextMenu()}),L.Path.include(L.Mixin.ContextMenu);
+L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(t){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter;var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),o=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){var i=a(t.dist);return t.xDiagCoord=i,i}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(o,i.theme),this._initToggle();var r=d3.select(o);r.attr("width",i.width);var n=r.append("svg");n.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(t){return d3.mouse(n.select("g"))[0]}).y(function(t){return this._height()});var l=d3.select(this._container).select("svg").select("g");this._areapath=l.append("path").attr("class","area");var d=this._background=l.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(d.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(d.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=l.append("g"),this._yaxisgraphicnode=l.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=l.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),o},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_findItemForLatLng:function(t){var i=null,e=1/0;return this._data.forEach(function(a){var s=t.distanceTo(a.latlng);e>s&&(e=s,i=a)}),i},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,t);i.href="#",i.title=this.options.controlButton.title,L.Browser.touch?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a;a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"";var s=a.split(".");if(s[1]){for(var o=i-s[1].length;o>0;o--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){var i=this.options;i.imperial?t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){var i=this.options;i.imperial?t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(t,i,e){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),s=this.options,o=this._data[this._findItemForX(a[0])],r=o.altitude,n=o.dist,h=o.latlng,l=s.hoverNumber.formatter(r,s.hoverNumber.decimalsY);s.hoverNumber.formatter(n,s.hoverNumber.decimalsX),this._showDiagramIndicator(o,a[0]);var d=this._map.latLngToLayerPoint(h);if(s.useHeightIndicator){if(!this._mouseHeightFocus){var c=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=c.append("svg:line").attr("class",s.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var _=this._pointG=c.append("g");_.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",s.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=c.append("svg:text").attr("class",s.theme+" height-focus-label").style("pointer-events","none")}var u=this._height()/this._maxElevation*r,g=d.y-u;this._mouseHeightFocus.attr("x1",d.x).attr("x2",d.x).attr("y1",d.y).attr("y2",g).style("visibility","visible"),this._pointG.attr("transform","translate("+d.x+","+d.y+")").style("visibility","visible"),s.imperial?this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(h):this._marker=new L.Marker(h).addTo(this._map)}},_addGeoJSONData:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=new L.LatLng(t[o][1],t[o][0]),n=new L.LatLng(t[o?o-1:0][1],t[o?o-1:0][0]),h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<t[o][2]?t[o][2]:s,e.push({dist:a,altitude:i.imperial?t[o][2]*this.__footFactor:t[o][2],x:t[o][0],y:t[o][1],latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addGPXdata:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=t[o],n=t[o?o-1:0],h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<r.meta.ele?r.meta.ele:s,e.push({dist:a,altitude:i.imperial?r.meta.ele*this.__footFactor:r.meta.ele,x:r.lng,y:r.lat,latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}var a=t&&"FeatureCollection"===t.type;if(a)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t,i){this._addData(t),this._container&&this._applyData(),null===i&&t.on&&(i=t),i&&i.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(t){if(this._data&&0!==this._data.length){var i=t.latlng,e=this._findItemForLatLng(i);if(e){var a=e.xDiagCoord;this._showDiagramIndicator(e,a)}}},_showDiagramIndicator:function(t,i){var e=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",i).attr("y1",0).attr("x2",i).attr("y2",this._height()).classed("hidden",!1);var a=t.altitude,s=t.dist,o=(t.latlng,e.hoverNumber.formatter(a,e.hoverNumber.decimalsY)),r=e.hoverNumber.formatter(s,e.hoverNumber.decimalsX);e.imperial?(this._focuslabelX.attr("x",i).text(o+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" mi")):(this._focuslabelX.attr("x",i).text(o+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" km"))},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
 
 },{}],19:[function(require,module,exports){
-L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number:"",shadowUrl:null,iconSize:new L.Point(25,41),iconAnchor:new L.Point(12,40),popupAnchor:new L.Point(0,(-33)),shadowSize:new L.Point(50,(-64)),shadowAnchor:new L.Point(4,(-62)),className:"leaflet-div-icon"},createIcon:function(){var n=document.createElement("div"),e=this._createImg(this.options.iconUrl),o=document.createElement("div");return o.setAttribute("class","number"),o.innerHTML=this.options.number||"",n.appendChild(e),n.appendChild(o),this._setIconStyles(n,"icon"),n},createShadow:function(){return null}});
+L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number:"",shadowUrl:null,iconSize:new L.Point(25,41),iconAnchor:new L.Point(12,40),popupAnchor:new L.Point(0,-33),shadowSize:new L.Point(50,-64),shadowAnchor:new L.Point(4,-62),className:"leaflet-div-icon"},createIcon:function(){var n=document.createElement("div"),e=this._createImg(this.options.iconUrl),o=document.createElement("div");return o.setAttribute("class","number"),o.innerHTML=this.options.number||"",n.appendChild(e),n.appendChild(o),this._setIconStyles(n,"icon"),n},createShadow:function(){return null}});
 
 },{}],20:[function(require,module,exports){
 (function (global){
-function initFromParams(e,t){ghRequest.init(e);var o,r=0;if(e.point)for(var a=0;a<e.point.length;a++)""!==e.point[a]&&(r++,o=a);var n=e.point&&r>=2;n?resolveCoords(e.point,t):e.point&&1===r&&(ghRequest.route.set(e.point[o],o,!0),resolveIndex(o).done(function(){mapLayer.focus(ghRequest.route.getIndex(o),15,o)}))}function resolveCoords(e,t){for(var o=0,r=e.length;o<r;o++){var a=e[o],n=ghRequest.route.getIndex(o);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,o,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var o=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)},r=0;r<t;r++){var a=$("#locationpoints > div.pointDiv").eq(r);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:r})),a=$("#locationpoints > div.pointDiv").eq(r));var n=getToFrom(r);if(a.data("index",r),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(o).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,r),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===r?$(s).attr("placeholder",translate.tr("from_hint")):r===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.target.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,0),routeIfAllResolved()}function setToEnd(e){var t=e.target.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.add(e.latlng.wrap(),t),resolveIndex(t),routeIfAllResolved()}function deleteCoord(e){var t=e.target.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var o=getToFrom(t),r=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);r._openPopup=r.openPopup,r.openPopup=function(){var e,t=this.getLatLng(),o=ghRequest.route.getIndexFromCoord(t);if(o.resolvedList&&o.resolvedList[0]&&o.resolvedList[0].locationDetails){var r=o.resolvedList[0].locationDetails;e=format.formatAddress(r),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),callback:setToStart,index:1,state:2};o===-1&&r.options.contextmenuItems.push(a),r.on("dragend",function(e){mapLayer.clearLayers();var o=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(o.lat,o.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,o=ghRequest.route.size();t<o;t++)e[t]=resolveIndex(t);return e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var o=e.do_zoom;e.do_zoom=!0;var r=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var a=urlTools.parseUrl(r);return console.log(a),a.do_zoom=o,a.mathRandom=Math.random(),void History.pushState(a,messages.browserTitle,r)}var n=$("#info");n.empty(),n.show();var s=$("<div class='route_results'/>");n.append(s),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var i=e.createURL();s.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(i,function(t){function a(e,t,o,r,a){return function(){var n=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===n;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(n)),l.find("li").removeClass("current"),s.find("div").removeClass("current"),o.addClass("current"),r.addClass("current")}}if(s.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var i=0;i<t.hints.length;i++)s.append("<div class='error'>"+t.hints[i].message+"</div>");else s.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(s.append(l),s.append("<div class='clear'/>"));for(var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],h=0;h<t.paths.length;h++){var v=$("<li>").append(h+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===h&&(u=v),l.append(v);var m=t.paths[h],f=0===h?p:c,q={type:"Feature",geometry:m.points,properties:{style:f}};g.push(q),mapLayer.addDataToRoutingLayer(q);var R=$("<div class='route_result_tab'>");s.append(R),v.click(a(g,h,v,R,e.hasElevation()));var y=translate.createTimeString(m.time),b=translate.createDistanceString(m.distance),x=$("<div class='route_description'>");if(m.description&&m.description.length>0&&(x.text(m.description),x.append("<br/>")),x.append(translate.tr("route_info",[b,y])),e.hasElevation()&&x.append(translate.createEleInfoString(m.ascend,m.descend)),R.append(x),m.instructions){var I=require("./instructions.js");R.append(I.create(mapLayer,m,r,e))}}u.click(),mapLayer.adjustMapSize();var C=t.paths[0];if(C.bbox&&o){var w=C.bbox[0],_=C.bbox[1],j=C.bbox[2],F=C.bbox[3],T=new L.LatLngBounds(new L.LatLng(_,w),new L.LatLng(F,j));mapLayer.fitMapToBounds(T)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}})}function mySubmit(){var e,t,o,r=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val(),e!==translate.tr("from_hint")&&""!==e?r.push(e):a=!1):n===s-1?(t=$(this).val(),t!==translate.tr("to_hint")&&""!==t?r.push(t):a=!1):(o=$(this).val(),o!==translate.tr("via_hint")&&""!==o?r.push(o):a=!1)}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(r))}function isProduction(){return host.indexOf("graphhopper.com")>0}global.d3=require("d3");var L=require("leaflet");require("leaflet-loading"),require("./lib/leaflet.contextmenu.js"),require("./lib/Leaflet.Elevation-0.0.2.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else var autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);host += "/graphhopper-web-0.8-SNAPSHOT";var mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicle=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={},metaVersionInfo;global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var o=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(o.locale),ghRequest.getInfo()).then(function(e,t){function r(e,t){var o=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&o.hide(),o.attr("id",e),o.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),o.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),o}var a=e[0];autocomplete.setLocale(a.locale),ghRequest.setLocale(a.locale),translate.init(a);var n=t[0],s=n.bbox;bounds.initialized=!0,bounds.minLon=s[0],bounds.minLat=s[1],bounds.maxLon=s[2],bounds.maxLat=s[3],nominatim.setBounds(bounds);var i=$("#vehicles");if(n.features){ghRequest.features=n.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=o.vehicle&&(!l[o.vehicle]||l[o.vehicle]>3),p=vehicle.getSortedVehicleKeys(n.features,l);p.length>0&&ghRequest.initVehicle(p[0]);var d=[];for(var c in p){var g=r(p[c].toLowerCase(),!u&&c>2);i.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var h=$("<a id='more-vehicle-btn'> ...</a>").click(function(){h.hide();for(var e in d)d[e].show()});i.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),i.append(h)}}metaVersionInfo=messages.extractMetaVersionInfo(n),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer),initFromParams(o,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord)}),$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var o=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(o===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";module.exports.setFlag=setFlag;
+function initFromParams(e,t){ghRequest.init(e);var o,r=0;if(e.point)for(var a=0;a<e.point.length;a++)""!==e.point[a]&&(r++,o=a);var n=e.point&&r>=2;n?resolveCoords(e.point,t):e.point&&1===r&&(ghRequest.route.set(e.point[o],o,!0),resolveIndex(o).done(function(){mapLayer.focus(ghRequest.route.getIndex(o),15,o)}))}function resolveCoords(e,t){for(var o=0,r=e.length;r>o;o++){var a=e[o],n=ghRequest.route.getIndex(o);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,o,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var o=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)},r=0;t>r;r++){var a=$("#locationpoints > div.pointDiv").eq(r);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:r})),a=$("#locationpoints > div.pointDiv").eq(r));var n=getToFrom(r);if(a.data("index",r),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(o).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,r),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===r?$(s).attr("placeholder",translate.tr("from_hint")):r===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route"),o=t.map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(o,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return ghRequest.route.isResolved()?(routeLatLng(ghRequest,e),!0):!1}function setFlag(e,t){if(e.lat){var o=getToFrom(t),r=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);r._openPopup=r.openPopup,r.openPopup=function(){var e,t=this.getLatLng(),o=ghRequest.route.getIndexFromCoord(t);if(o.resolvedList&&o.resolvedList[0]&&o.resolvedList[0].locationDetails){var r=o.resolvedList[0].locationDetails;e=format.formatAddress(r),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),callback:setToStart,index:1};-1===o&&r.options.contextmenuItems.push(a),r.on("dragend",function(e){mapLayer.clearLayers();var o=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(o.lat,o.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,o=ghRequest.route.size();o>t;t++)e[t]=resolveIndex(t);return e}function flagAll(){for(var e=0,t=ghRequest.route.size();t>e;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var o=e.do_zoom;e.do_zoom=!0;var r=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var a=urlTools.parseUrl(r);return console.log(a),a.do_zoom=o,a.mathRandom=Math.random(),void History.pushState(a,messages.browserTitle,r)}var n=$("#info");n.empty(),n.show();var s=$("<div class='route_results'/>");n.append(s),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var i=e.createURL();s.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(i,function(t){function a(e,t,o,r,a,n){return function(){var i=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===i;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(i,n)),l.find("li").removeClass("current"),s.find("div").removeClass("current"),o.addClass("current"),r.addClass("current")}}if(s.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var i=0;i<t.hints.length;i++)s.append("<div class='error'>"+t.hints[i].message+"</div>");else s.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(s.append(l),s.append("<div class='clear'/>"));for(var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],h=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}},v=0;v<t.paths.length;v++){var m=$("<li>").append(v+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===v&&(u=m),l.append(m);var f=t.paths[v],q=0===v?p:c,y={type:"Feature",geometry:f.points,properties:{style:q,name:"route",snapped_waypoints:f.snapped_waypoints}};g.push(y),mapLayer.addDataToRoutingLayer(y);var b=$("<div class='route_result_tab'>");s.append(b),m.click(a(g,v,m,b,e.hasElevation(),e.useMiles));var R=translate.createTimeString(f.time),x=translate.createDistanceString(f.distance,e.useMiles),I=$("<div class='route_description'>");f.description&&f.description.length>0&&(I.text(f.description),I.append("<br/>")),I.append(translate.tr("route_info",[x,R]));var _=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");_.text(translate.tr2("km_abbr")),_.click(h(!1));var w=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");w.text(translate.tr2("mi_abbr")),w.click(h(!0));var C=$("<span style='float: right;'>");if(C.append(_),C.append("|"),C.append(w),I.append(C),e.hasElevation()&&I.append(translate.createEleInfoString(f.ascend,f.descend,e.useMiles)),b.append(I),f.instructions){var M=require("./instructions.js");b.append(M.create(mapLayer,f,r,e))}}u.click(),mapLayer.adjustMapSize();var j=t.paths[0];if(j.bbox&&o){var F=j.bbox[0],T=j.bbox[1],k=j.bbox[2],S=j.bbox[3],A=new L.LatLngBounds(new L.LatLng(T,F),new L.LatLng(S,k));mapLayer.fitMapToBounds(A)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}})}function mySubmit(){var e,t,o,r=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;return $.each(n,function(n){0===n?(e=$(this).val(),e!==translate.tr("from_hint")&&""!==e?r.push(e):a=!1):n===s-1?(t=$(this).val(),t!==translate.tr("to_hint")&&""!==t?r.push(t):a=!1):(o=$(this).val(),o!==translate.tr("via_hint")&&""!==o?r.push(o):a=!1)}),a&&e!==translate.tr("from_hint")?t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(r)):void 0}function isProduction(){return host.indexOf("graphhopper.com")>0}global.d3=require("d3");var L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading"),require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else var autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicle=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={},metaVersionInfo;global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var o=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(o.locale),ghRequest.getInfo()).then(function(e,t){function r(e,t){var o=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&o.hide(),o.attr("id",e),o.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),o.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),o}var a=e[0];autocomplete.setLocale(a.locale),ghRequest.setLocale(a.locale),translate.init(a);var n=t[0],s=n.bbox;bounds.initialized=!0,bounds.minLon=s[0],bounds.minLat=s[1],bounds.maxLon=s[2],bounds.maxLat=s[3],nominatim.setBounds(bounds);var i=$("#vehicles");if(n.features){ghRequest.features=n.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=o.vehicle&&(!l[o.vehicle]||l[o.vehicle]>3),p=vehicle.getSortedVehicleKeys(n.features,l);p.length>0&&ghRequest.initVehicle(p[0]);var d=[];for(var c in p){var g=r(p[c].toLowerCase(),!u&&c>2);i.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var h=$("<a id='more-vehicle-btn'> ...</a>").click(function(){h.hide();for(var e in d)d[e].show()});i.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),i.append(h)}}metaVersionInfo=messages.extractMetaVersionInfo(n),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles),initFromParams(o,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles)}),$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var o=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");return o===t?(ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1):void 0})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";module.exports.setFlag=setFlag;
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./autocomplete.js":5,"./config/options.js":6,"./config/tileLayers.js":7,"./gpxexport.js":8,"./graphhopper/GHInput.js":9,"./graphhopper/GHRequest.js":10,"./instructions.js":13,"./lib/Leaflet.Elevation-0.0.2.min.js":14,"./lib/jquery-ui-custom-1.12.0.min.js":15,"./lib/jquery.autocomplete.js":16,"./lib/jquery.history.js":17,"./lib/leaflet.contextmenu.js":18,"./lib/leaflet_numbered_markers.js":19,"./map.js":21,"./messages.js":22,"./nominatim.js":23,"./tools/format.js":24,"./tools/url.js":26,"./tools/vehicle.js":27,"./translate.js":28,"d3":1,"jquery":2,"leaflet":4,"leaflet-loading":3}],21:[function(require,module,exports){
-function adjustMapSize(){var t=$("#map"),e=$(window).width()-280;e<400?(e=400,t.attr("style","position: relative; float: right;")):t.attr("style","position: absolute; right: 0;");var a=$(window).height();a<500&&(a=500),t.width(e).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(t,e,a,n,o){adjustMapSize();var r=tileLayers.selectLayer(o);map=L.map("map",{layers:[r],contextmenu:!0,contextmenuWidth:150,contextmenuItems:[{separator:!0,index:3,state:["set_default"]},{text:translate.tr("show_coords"),callback:function(t){alert(t.latlng.lat+","+t.latlng.lng)},index:4,state:[1,2,3]},{text:translate.tr("center_map"),callback:function(t){map.panTo(t.latlng)},index:5,state:[1,2,3]}],zoomControl:!1,loadingControl:!1});var i={text:translate.tr("set_start"),callback:e,disabled:!1,index:0},l={text:translate.tr("set_intermediate"),callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),callback:n,disabled:!1,index:2};menuStart=map.contextmenu.insertItem(i,i.index),menuIntermediate=map.contextmenu.insertItem(l,l.index),menuEnd=map.contextmenu.insertItem(s,s.index);var m=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:m}).addTo(map),map.contextmenu.addSet({name:"markers",state:2}),map.contextmenu.addSet({name:"path",state:3}),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(t){t.name&&(tileLayers.activeLayerName=t.name,$("#export-link a").attr("href",function(t,e){return e.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),L.control.scale().addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(t.minLat,t.minLon),new L.LatLng(t.maxLat,t.maxLon))),map.attributionControl.setPrefix("");var d={color:"black",weight:2,opacity:.3},u={type:"Feature",geometry:{type:"LineString",coordinates:[[t.minLon,t.minLat],[t.maxLon,t.minLat],[t.maxLon,t.maxLat],[t.minLon,t.maxLat],[t.minLon,t.minLat]]}};t.initialized&&L.geoJson(u,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(t){return t.properties&&t.properties.style},contextmenu:!0,contextmenuItems:[{text:translate.tr("route")+" ",disabled:!0,index:0,state:3},{text:translate.tr("set_intermediate"),callback:a,index:1,state:3},{separator:!0,index:2,state:3}],contextmenuAtiveState:3}}function focus(t,e,a){t.lat&&t.lng&&(e||(e=11),routingLayer.clearLayers(),map.setView(new L.LatLng(t.lat,t.lng),e),mainTemplate.setFlag(t,a))}function getToFrom(t,e){return 0===t?FROM:t===e.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.addDataToRoutingLayer=function(t){routingLayer.addData(t)},module.exports.eachLayer=function(t){routingLayer.eachLayer(t)},module.exports.setDisabledForMapsContextMenu=function(t,e){"start"===t&&map.contextmenu.setDisabled(menuStart,e),"end"===t&&map.contextmenu.setDisabled(menuEnd,e),"intermediate"===t&&map.contextmenu.setDisabled(menuIntermediate,e)},module.exports.fitMapToBounds=function(t){map.fitBounds(t)},module.exports.removeLayerFromMap=function(t){map.removeLayer(t)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:50},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.addData(t)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(t,e,a,n,o,r){var i=getToFrom(t,r);return L.marker([e.lat,e.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:t}),draggable:!0,contextmenu:!0,contextmenuItems:[{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+t),disabled:!0,index:0,state:2},{text:translate.tr(i!==TO?"set_end":"set_start"),callback:i!==TO?a:n,index:2,state:2},{text:translate.tr("delete_from_route"),callback:o,index:3,state:2,disabled:i!==-1&&2===r.route.size()},{separator:!0,index:4,state:2}],contextmenuAtiveState:2}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+t)};
+},{"./autocomplete.js":6,"./config/options.js":7,"./config/tileLayers.js":8,"./gpxexport.js":9,"./graphhopper/GHInput.js":10,"./graphhopper/GHRequest.js":11,"./instructions.js":14,"./lib/jquery-ui-custom-1.12.0.min.js":15,"./lib/jquery.autocomplete.js":16,"./lib/jquery.history.js":17,"./lib/leaflet.elevation-0.0.4.min.js":18,"./lib/leaflet_numbered_markers.js":19,"./map.js":21,"./messages.js":22,"./nominatim.js":23,"./routeManipulation.js":24,"./tools/format.js":25,"./tools/url.js":27,"./tools/vehicle.js":28,"./translate.js":29,"d3":1,"jquery":2,"leaflet":5,"leaflet-contextmenu":3,"leaflet-loading":4}],21:[function(require,module,exports){
+function adjustMapSize(){var e=$("#map"),t=$(window).width()-280;400>t?(t=400,e.attr("style","position: relative; float: right;")):e.attr("style","position: absolute; right: 0;");var a=$(window).height();500>a&&(a=500),e.width(t).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(e,t,a,n,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuWidth:150,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),callback:t,index:0},m={text:translate.tr("set_intermediate"),callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),callback:n,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(m,m.index),menuEnd=map.contextmenu.insertItem(s,s.index);var u=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:u}).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={color:"black",weight:2,opacity:.3},c={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(c,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),callback:a,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,a){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,a))}function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null,defaultContextmenuItems;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){var t=routingLayer.getLayers();return t.filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,a,n,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),callback:i!==TO?a:n,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:-1!==i&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
 
-},{"./config/tileLayers.js":7,"./main-template.js":20,"./translate.js":28}],22:[function(require,module,exports){
-module.exports.extractMetaVersionInfo=function(r){return metaVersionInfo="",r.data_date&&(metaVersionInfo+="<br/>Data date: "+r.data_date),r.import_date&&(metaVersionInfo+="<br/>Import date: "+r.import_date),r.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+r.prepare_date),r.version&&(metaVersionInfo+="<br/>GH version: "+r.version),r.build_date&&(metaVersionInfo+="<br/>Jar date: "+r.build_date),metaVersionInfo},module.exports.getSignName=function(r){if(r===-3)return"sharp_left";if(r===-2)return"left";if(r===-1)return"slight_left";if(0===r)return"continue";if(1===r)return"slight_right";if(2===r)return"right";if(3===r)return"sharp_right";if(4===r)return"marker-icon-red";if(5===r)return"marker-icon-blue";if(6===r)return"roundabout";throw"did not find sign "+r},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
+},{"./config/tileLayers.js":8,"./main-template.js":20,"./translate.js":29}],22:[function(require,module,exports){
+module.exports.extractMetaVersionInfo=function(r){return metaVersionInfo="",r.data_date&&(metaVersionInfo+="<br/>Data date: "+r.data_date),r.import_date&&(metaVersionInfo+="<br/>Import date: "+r.import_date),r.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+r.prepare_date),r.version&&(metaVersionInfo+="<br/>GH version: "+r.version),r.build_date&&(metaVersionInfo+="<br/>Jar date: "+r.build_date),metaVersionInfo},module.exports.getSignName=function(r){if(-3===r)return"sharp_left";if(-2===r)return"left";if(-1===r)return"slight_left";if(0===r)return"continue";if(1===r)return"slight_right";if(2===r)return"right";if(3===r)return"sharp_right";if(4===r)return"marker-icon-red";if(5===r)return"marker-icon-blue";if(6===r)return"roundabout";throw"did not find sign "+r},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
 
 },{}],23:[function(require,module,exports){
 function createAmbiguityList(o){o.error="",o.resolvedList=[];var n=3e3;if(o.isResolved()){var r=$.Deferred();return r.resolve([o]),r}if(o.lat&&o.lng){var t=nominatimReverseURL+"?lat="+o.lat+"&lon="+o.lng+"&format=json&zoom=16";return $.ajax({url:t,type:"GET",dataType:"json",timeout:n}).then(function(n){if(!n)return o.error="No description found for coordinate",[o];var r=n.address,t={};return t.lat=o.lat,t.lng=o.lng,t.bbox=n.boundingbox,t.positionType=n.type,t.locationDetails=format.formatLocationEntry(r),o.resolvedList.push(t),[o]},function(n){return console.log("[nominatim_reverse] Error while looking up coordinate lat="+o.lat+"&lon="+o.lng),o.error="Problem while looking up location.",[o]})}return doGeoCoding(o.input,10,n).then(function(n){if(!n||0===n.length)return o.error="No area description found",[o];var r,t=n[0].importance;for(var e in n){var i=n[e];if(t-i.importance>.4)break;if(!r||JSON.stringify(r)!==JSON.stringify(i.address)){r=i.address,t=i.importance;var a={};a.lat=mathTools.round(i.lat),a.lng=mathTools.round(i.lon),a.locationDetails=format.formatLocationEntry(r),a.bbox=i.boundingbox,a.positionType=i.type,o.resolvedList.push(a)}}if(0===o.resolvedList.length)return o.error="No area description found",[o];var s=o.resolvedList;return o.lat=s[0].lat,o.lng=s[0].lng,[o]},function(){return o.error="Problem while looking up address",[o]})}function doGeoCoding(o,n,r){n||(n=10);var t=nominatimURL+"?format=json&addressdetails=1&q="+encodeURIComponent(o)+"&limit="+n;return bounds.initialized&&(t+="&bounded=1&viewbox="+bounds.minLon+","+bounds.maxLat+","+bounds.maxLon+","+bounds.minLat),$.ajax({url:t,type:"GET",dataType:"json",timeout:r}).fail(createCallback("[nominatim] Problem while looking up location "+o))}function createCallback(o){return function(n){console.log(o+" "+JSON.stringify(n))}}function resolve(o,n){var r=$("#locationpoints > div.pointDiv").eq(o);return $(r).find(".pointFlag").hide(),$(r).find(".pointIndicator").show(),$(r).find(".pointInput").val(n.input),createAmbiguityList(n).always(function(){var o=$(r).find(".pointResolveError");return o.empty(),n.error&&(o.show(),o.text(n.error).fadeOut(5e3),n.error=""),$(r).find(".pointIndicator").hide(),$(r).find(".pointFlag").show(),n})}var nominatimURL="https://nominatim.openstreetmap.org/search",nominatimReverseURL="https://nominatim.openstreetmap.org/reverse",bounds,mathTools=require("./tools/math.js"),format=require("./tools/format.js");module.exports.resolve=resolve,module.exports.setBounds=function(o){bounds=o};
 
-},{"./tools/format.js":24,"./tools/math.js":25}],24:[function(require,module,exports){
-function insComma(o,t){return o.length>0?o+", "+t:t}function formatLocationEntry(o){var t={},n="";return o?(o.road&&(n=o.road,o.house_number&&(n.length>0&&(n+=" "),n+=o.house_number),t.road=n),o.postcode&&(t.postcode=o.postcode),t.country=o.country,(o.city||o.suburb||o.town||o.village||o.hamlet||o.locality)&&(n="",o.locality&&(n=insComma(n,o.locality)),o.hamlet&&(n=insComma(n,o.hamlet)),o.village&&(n=insComma(n,o.village)),o.suburb&&(n=insComma(n,o.suburb)),o.city&&(n=insComma(n,o.city)),o.town&&(n=insComma(n,o.town)),t.city=n),n="",o.state&&(n+=o.state),o.continent&&(n=insComma(n,o.continent)),t.more=n,t):t}module.exports.formatLocationEntry=formatLocationEntry,module.exports.formatAddress=function(o){return(o.road?o.road+", ":"")+(o.postcode?o.postcode+", ":"")+(o.city?o.city+", ":"")+(o.country?o.country:"")},module.exports.insComma=insComma,module.exports.formatValue=function(o,t){var n="("+$.Autocomplete.utils.escapeRegExChars(t)+")";return o.replace(/[<>]/g,"_").replace(new RegExp(n,"gi"),"<strong>$1</strong>")};
+},{"./tools/format.js":25,"./tools/math.js":26}],24:[function(require,module,exports){
+var L=require("leaflet");module.exports.getIntermediatePointIndex=function(e,n){for(var t=0,r=e[0].wayPoints,a=[],i=0;i<e.length;++i)for(var o=e[i].coordinates,d=0;d<o.length;++d)o[d].equals(r[t],1e-5)&&t++,a.push({distance:o[d].distanceTo(n),nextWayPointIndex:t===r.length?t-1:t});var s=a.reduce(function(e,n){return n.distance-e.distance<1e-6?n:e}).nextWayPointIndex;return s=s>0&&s<r.length?s:1};
 
-},{}],25:[function(require,module,exports){
-module.exports.getCenter=function(n){var o={lat:0,lng:0};return n.initialized&&(o.lat=(n.minLat+n.maxLat)/2,o.lng=(n.minLon+n.maxLon)/2),o},module.exports.floor=function(n,o){return o||(o=1e6),Math.floor(n*o)/o},module.exports.round=function(n,o){return void 0===o&&(o=1e6),Math.round(n*o)/o};
+},{"leaflet":5}],25:[function(require,module,exports){
+function insComma(o,t){return o.length>0?o+", "+t:t}function formatLocationEntry(o){var t={},n="";return o?(o.road&&(n=o.road,o.house_number&&(n.length>0&&(n+=" "),n+=o.house_number),t.road=n),o.postcode&&(t.postcode=o.postcode),t.country=o.country,(o.city||o.suburb||o.town||o.village||o.hamlet||o.locality)&&(n="",o.locality&&(n=insComma(n,o.locality)),o.hamlet&&(n=insComma(n,o.hamlet)),o.village&&(n=insComma(n,o.village)),o.suburb&&(n=insComma(n,o.suburb)),o.city&&(n=insComma(n,o.city)),o.town&&(n=insComma(n,o.town)),t.city=n),n="",o.state&&(n+=o.state),o.continent&&(n=insComma(n,o.continent)),t.more=n,t):t}module.exports.formatLocationEntry=formatLocationEntry,module.exports.formatAddress=function(o){return(o.road?o.road+", ":"")+(o.postcode?o.postcode+", ":"")+(o.city?o.city+", ":"")+(o.country?o.country:"")},module.exports.insComma=insComma,module.exports.formatValue=function(o,t){var n="("+$.Autocomplete.utils.escapeRegExChars(t)+")";return o.replace(/[<>]/g,"_").replace(new RegExp(n,"gi"),"<strong>$1</strong>")};
 
 },{}],26:[function(require,module,exports){
-function parseUrlWithHisto(){return parseUrl(window.location.hash?window.location.hash:window.location.search)}function parseUrl(r){var e=r.indexOf("?");e>=0&&(r=r.substring(e+1));for(var t={},o=r.split("&"),a=0;a<o.length;a++){var i=o[a].indexOf("=");if(!(i<0)){var n=o[a].substring(0,i),s=o[a].substring(i+1);if(s=decodeURIComponent(s.replace(/\+/g," ")),"undefined"==typeof t[n]&&"heading"!==n&&"point"!==n)"true"===s?s=!0:"false"===s&&(s=!1),t[n]=s;else{var l=t[n];isArray(l)?l.push(s):l?t[n]=[l,s]:t[n]=[s]}}}return t}var isArray=function(r){var e=Object.prototype.toString.call(r);return"[object array]"===e.toLowerCase()};module.exports.parseUrl=parseUrl,module.exports.parseUrlWithHisto=parseUrlWithHisto;
+module.exports.getCenter=function(n){var o={lat:0,lng:0};return n.initialized&&(o.lat=(n.minLat+n.maxLat)/2,o.lng=(n.minLon+n.maxLon)/2),o},module.exports.floor=function(n,o){return o||(o=1e6),Math.floor(n*o)/o},module.exports.round=function(n,o){return void 0===o&&(o=1e6),Math.round(n*o)/o};
 
 },{}],27:[function(require,module,exports){
-module.exports.getSortedVehicleKeys=function(e,r){var t=Object.keys(e);return t.sort(function(e,t){var o=r[e],n=r[t];return o||n?(o||(o=4),n||(n=4),o-n):e.localeCompare(t)}),t};
+function parseUrlWithHisto(){return parseUrl(window.location.hash?window.location.hash:window.location.search)}function parseUrl(r){var e=r.indexOf("?");e>=0&&(r=r.substring(e+1));for(var t={},o=r.split("&"),a=0;a<o.length;a++){var i=o[a].indexOf("=");if(!(0>i)){var n=o[a].substring(0,i),s=o[a].substring(i+1);if(s=decodeURIComponent(s.replace(/\+/g," ")),"undefined"==typeof t[n]&&"heading"!==n&&"point"!==n)"true"===s?s=!0:"false"===s&&(s=!1),t[n]=s;else{var l=t[n];isArray(l)?l.push(s):l?t[n]=[l,s]:t[n]=[s]}}}return t}var isArray=function(r){var e=Object.prototype.toString.call(r);return"[object array]"===e.toLowerCase()};module.exports.parseUrl=parseUrl,module.exports.parseUrlWithHisto=parseUrlWithHisto;
 
 },{}],28:[function(require,module,exports){
+module.exports.getSortedVehicleKeys=function(e,r){var t=Object.keys(e);return t.sort(function(e,t){var o=r[e],n=r[t];return o||n?(o||(o=4),n||(n=4),o-n):e.localeCompare(t)}),t};
+
+},{}],29:[function(require,module,exports){
 (function (global){
-function tr2(t,n){if(null===t)return console.log("ERROR: key was null?"),"";if(null===defaultTranslationMap)return console.log("ERROR: defaultTranslationMap was not initialized?"),t;t=t.toLowerCase();var r=defaultTranslationMap[t];return!r&&enTranslationMap&&(r=enTranslationMap[t]),r?stringFormat(r,n):t}function tr(t,n){return t!==t.toLowerCase()&&console.log("key "+t+" has to be lower case"),tr2("web."+t,n)}function stringFormat(t,n){if("string"==typeof n&&(n=[n]),t.indexOf("%1$s")>=0)return t.replace(/\%(\d+)\$s/g,function(t,r){return r--,"undefined"!=typeof n[r]?n[r]:t});var r=0;return t.replace(/\%s/g,function(t){var o="undefined"!=typeof n[r]?n[r]:t;return r++,o})}function initI18N(){if(global.$){$("#searchButton").attr("value",tr("search_button"));var t=$("#locationpoints > div.pointDiv > input.pointInput"),n=t.size;$(t).each(function(t){0===t?$(this).attr("placeholder",tr("from_hint")):t===n-1?$(this).attr("placeholder",tr("to_hint")):$(this).attr("placeholder",tr("via_hint"))}),$(".pointDelete").each(function(){$(this).attr("title",tr("delete_from_route"))}),$("#export-link").attr("title",tr("staticlink")),$("#gpxExportButton").attr("title",tr("gpx_export_button"))}}var defaultTranslationMap=null,enTranslationMap=null,i18nIsInitialized,mathTools=require("./tools/math.js");module.exports.createDistanceString=function(t){return t<900?mathTools.round(t,1)+tr2("m_abbr"):(t=mathTools.round(t/1e3,100),t>100&&(t=mathTools.round(t,1)),t+tr2("km_abbr"))},module.exports.createEleInfoString=function(t,n){var r="";return(t>0||n>0)&&(r="<br/> ",t>0&&(r+="&#8599;"+mathTools.round(t,1)+tr2("m_abbr")),n>0&&(r+=" &#8600;"+mathTools.round(n,1)+tr2("m_abbr"))),r},module.exports.createTimeString=function(t){var n,r=mathTools.round(t/60/1e3,1e3);return r>60?r/60>24?(n=mathTools.floor(r/60/24,1)+tr2("day_abbr"),r=mathTools.floor(r/60%24,1),r>0&&(n+=" "+r+tr2("hour_abbr"))):(n=mathTools.floor(r/60,1)+tr2("hour_abbr"),r=mathTools.floor(r%60,1),r>0&&(n+=" "+r+tr2("min_abbr"))):n=mathTools.round(r%60,1)+tr2("min_abbr"),n},module.exports.tr=tr,module.exports.nanoTemplate=function(t,n){return t.replace(/\{([\w\.]*)\}/g,function(t,r){var o=r.split("."),e=n[o.shift()];for(i=0,l=o.length;i<l;_i++)e=e[this];return"undefined"!=typeof e&&null!==e?e:""})},module.exports.init=function(t){defaultTranslationMap=t["default"],enTranslationMap=t.en,defaultTranslationMap||(defaultTranslationMap=enTranslationMap),i18nIsInitialized=!0,initI18N()},module.exports.isI18nIsInitialized=function(){return i18nIsInitialized};
+function tr2(t,r){if(null===t)return console.log("ERROR: key was null?"),"";if(null===defaultTranslationMap)return console.log("ERROR: defaultTranslationMap was not initialized?"),t;t=t.toLowerCase();var o=defaultTranslationMap[t];return!o&&enTranslationMap&&(o=enTranslationMap[t]),o?stringFormat(o,r):t}function tr(t,r){return t!==t.toLowerCase()&&console.log("key "+t+" has to be lower case"),tr2("web."+t,r)}function stringFormat(t,r){if("string"==typeof r&&(r=[r]),t.indexOf("%1$s")>=0)return t.replace(/\%(\d+)\$s/g,function(t,o){return o--,"undefined"!=typeof r[o]?r[o]:t});var o=0;return t.replace(/\%s/g,function(t){var n="undefined"!=typeof r[o]?r[o]:t;return o++,n})}function initI18N(){if(global.$){$("#searchButton").attr("value",tr("search_button"));var t=$("#locationpoints > div.pointDiv > input.pointInput"),r=t.size;$(t).each(function(t){0===t?$(this).attr("placeholder",tr("from_hint")):t===r-1?$(this).attr("placeholder",tr("to_hint")):$(this).attr("placeholder",tr("via_hint"))}),$(".pointFlag").each(function(){$(this).attr("title",tr("drag_to_reorder"))}),$(".pointDelete").each(function(){$(this).attr("title",tr("delete_from_route"))}),$("#export-link").attr("title",tr("staticlink")),$("#gpxExportButton").attr("title",tr("gpx_export_button"))}}function mToKm(t){return t/1e3}function mToFt(t){return t/.3048}function mToMi(t){return t/1609.344}var defaultTranslationMap=null,enTranslationMap=null,i18nIsInitialized,mathTools=require("./tools/math.js");module.exports.createDistanceString=function(t,r){return r?152>t?mathTools.round(mToFt(t),1)+tr2("ft_abbr"):(t=mathTools.round(mToMi(t),100),t>100&&(t=mathTools.round(t,1)),t+tr2("mi_abbr")):900>t?mathTools.round(t,1)+tr2("m_abbr"):(t=mathTools.round(mToKm(t),100),t>100&&(t=mathTools.round(t,1)),t+tr2("km_abbr"))},module.exports.createEleInfoString=function(t,r,o){var n="";return(t>0||r>0)&&(n="<br/> ",t>0&&(n+=o?"&#8599;"+mathTools.round(mToFt(t),1)+tr2("ft_abbr"):"&#8599;"+mathTools.round(t,1)+tr2("m_abbr")),r>0&&(n+=o?" &#8600;"+mathTools.round(mToFt(r),1)+tr2("ft_abbr"):" &#8600;"+mathTools.round(r,1)+tr2("m_abbr"))),n},module.exports.createTimeString=function(t){var r,o=mathTools.round(t/60/1e3,1e3);return o>60?o/60>24?(r=mathTools.floor(o/60/24,1)+tr2("day_abbr"),o=mathTools.floor(o/60%24,1),o>0&&(r+=" "+o+tr2("hour_abbr"))):(r=mathTools.floor(o/60,1)+tr2("hour_abbr"),o=mathTools.floor(o%60,1),o>0&&(r+=" "+o+tr2("min_abbr"))):r=mathTools.round(o%60,1)+tr2("min_abbr"),r},module.exports.tr=tr,module.exports.tr2=tr2,module.exports.nanoTemplate=function(t,r){return t.replace(/\{([\w\.]*)\}/g,function(t,o){var n=o.split("."),a=r[n.shift()];for(i=0,l=n.length;i<l;_i++)a=a[this];return"undefined"!=typeof a&&null!==a?a:""})},module.exports.init=function(t){defaultTranslationMap=t["default"],enTranslationMap=t.en,defaultTranslationMap||(defaultTranslationMap=enTranslationMap),i18nIsInitialized=!0,initI18N()},module.exports.isI18nIsInitialized=function(){return i18nIsInitialized};
 
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./tools/math.js":25}]},{},[20]);
+},{"./tools/math.js":26}]},{},[20]);
diff --git a/web/src/main/webapp/js/map.js b/web/src/main/webapp/js/map.js
index 044a0f828b..675db7dfa7 100755
--- a/web/src/main/webapp/js/map.js
+++ b/web/src/main/webapp/js/map.js
@@ -9,6 +9,9 @@ var menuIntermediate;
 var menuEnd;
 var elevationControl = null;
 
+// Items added in every contextmenu.
+var defaultContextmenuItems;
+
 // called if window changes or before map is created
 function adjustMapSize() {
     var mapDiv = $("#map");
@@ -29,9 +32,9 @@ function adjustMapSize() {
     // console.log("adjustMapSize " + height + "x" + width);
 
     // reduce info size depending on how heigh the input_header is and reserve space for footer
-    var instructionInfoMaxHeight = height - 60
-            - $("#input_header").height() - $("#footer").height() - $(".route_description").height();
-    var tabHeight = $("#route_result_tabs li").height()
+    var instructionInfoMaxHeight = height - 60 -
+            $("#input_header").height() - $("#footer").height() - $(".route_description").height();
+    var tabHeight = $("#route_result_tabs li").height();
     if (!isNaN(tabHeight))
         instructionInfoMaxHeight -= tabHeight;
     $(".instructions_info").css("max-height", instructionInfoMaxHeight);
@@ -40,45 +43,44 @@ function adjustMapSize() {
     // $("#info").css("height", height - $("#input_header").height() - 100);
 }
 
-function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selectLayer) {
+function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selectLayer, useMiles) {
     adjustMapSize();
     // console.log("init map at " + JSON.stringify(bounds));
 
     var defaultLayer = tileLayers.selectLayer(selectLayer);
 
+    defaultContextmenuItems = [{
+        separator: true,
+        index: 10
+    }, {
+        text: translate.tr('show_coords'),
+        callback: function (e) {
+            alert(e.latlng.lat + "," + e.latlng.lng);
+        },
+        index: 11
+    }, {
+        text: translate.tr('center_map'),
+        callback: function (e) {
+            map.panTo(e.latlng);
+        },
+        index: 12
+    }];
+
     // default
     map = L.map('map', {
         layers: [defaultLayer],
+        minZoom: 2,
+        // zoomSnap: 0,  // allow fractional zoom levels
         contextmenu: true,
         contextmenuWidth: 150,
-        contextmenuItems: [{
-                separator: true,
-                index: 3,
-                state: ['set_default']
-            }, {
-                text: translate.tr('show_coords'),
-                callback: function (e) {
-                    alert(e.latlng.lat + "," + e.latlng.lng);
-                },
-                index: 4,
-                state: [1, 2, 3]
-            }, {
-                text: translate.tr('center_map'),
-                callback: function (e) {
-                    map.panTo(e.latlng);
-                },
-                index: 5,
-                state: [1, 2, 3]
-            }],
+        contextmenuItems: defaultContextmenuItems,
         zoomControl: false,
         loadingControl: false
     });
 
-
     var _startItem = {
         text: translate.tr('set_start'),
         callback: setStartCoord,
-        disabled: false,
         index: 0
     };
     var _intItem = {
@@ -90,7 +92,6 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
     var _endItem = {
         text: translate.tr('set_end'),
         callback: setEndCoord,
-        disabled: false,
         index: 2
     };
     menuStart = map.contextmenu.insertItem(_startItem, _startItem.index);
@@ -107,16 +108,6 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
         zoomControl: zoomControl
     }).addTo(map);
 
-    map.contextmenu.addSet({
-        name: 'markers',
-        state: 2
-    });
-
-    map.contextmenu.addSet({
-        name: 'path',
-        state: 3
-    });
-
     L.control.layers(tileLayers.getAvailableTileLayers()/*, overlays*/).addTo(map);
 
     map.on('baselayerchange', function (a) {
@@ -128,7 +119,11 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
         }
     });
 
-    L.control.scale().addTo(map);
+    scaleControl = L.control.scale(useMiles ? {
+        metric: false
+    } : {
+        imperial: false
+    }).addTo(map);
 
     map.fitBounds(new L.LatLngBounds(new L.LatLng(bounds.minLat, bounds.minLon),
             new L.LatLng(bounds.maxLat, bounds.maxLon)));
@@ -136,29 +131,30 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
     //if (isProduction())
     //    map.setView(new L.LatLng(0, 0), 2);
 
-    map.attributionControl.setPrefix('');
+    map.attributionControl.setPrefix(false);
 
     var myStyle = {
-        "color": 'black',
-        "weight": 2,
-        "opacity": 0.3
+        color: 'black',
+        weight: 2,
+        opacity: 0.3
     };
     var geoJson = {
-        "type": "Feature",
-        "geometry": {
-            "type": "LineString",
-            "coordinates": [
+        type: "Feature",
+        geometry: {
+            type: "LineString",
+            coordinates: [
                 [bounds.minLon, bounds.minLat],
                 [bounds.maxLon, bounds.minLat],
                 [bounds.maxLon, bounds.maxLat],
                 [bounds.minLon, bounds.maxLat],
-                [bounds.minLon, bounds.minLat]]
+                [bounds.minLon, bounds.minLat]
+            ]
         }
     };
 
     if (bounds.initialized)
         L.geoJson(geoJson, {
-            "style": myStyle
+            style: myStyle
         }).addTo(map);
 
     routingLayer = L.geoJson().addTo(map);
@@ -169,22 +165,16 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
             return feature.properties && feature.properties.style;
         },
         contextmenu: true,
-        contextmenuItems: [{
-                text: translate.tr('route') + ' ',
+        contextmenuItems: defaultContextmenuItems.concat([{
+                text: translate.tr('route'),
                 disabled: true,
-                index: 0,
-                state: 3
+                index: 0
             }, {
                 text: translate.tr('set_intermediate'),
                 callback: setIntermediateCoord,
-                index: 1,
-                state: 3
-            }, {
-                separator: true,
-                index: 2,
-                state: 3
-            }],
-        contextmenuAtiveState: 3
+                index: 1
+            }]),
+        contextmenuInheritItems: false
     };
 }
 
@@ -206,6 +196,13 @@ module.exports.getRoutingLayer = function () {
     return routingLayer;
 };
 
+module.exports.getSubLayers = function(name) {
+    var subLayers = routingLayer.getLayers();
+    return subLayers.filter(function(sl) {
+        return sl.feature && sl.feature.properties && sl.feature.properties.name === name;
+    });
+};
+
 module.exports.addDataToRoutingLayer = function (geoJsonFeature) {
     routingLayer.addData(geoJsonFeature);
 };
@@ -224,7 +221,9 @@ module.exports.setDisabledForMapsContextMenu = function (entry, value) {
 };
 
 module.exports.fitMapToBounds = function (bounds) {
-    map.fitBounds(bounds);
+    map.fitBounds(bounds, {
+        padding: [42, 42]
+    });
 };
 
 module.exports.removeLayerFromMap = function (layer) {
@@ -235,7 +234,7 @@ module.exports.focus = focus;
 module.exports.initMap = initMap;
 module.exports.adjustMapSize = adjustMapSize;
 
-module.exports.addElevation = function (geoJsonFeature) {
+module.exports.addElevation = function (geoJsonFeature, useMiles) {
     if (elevationControl === null) {
         elevationControl = L.control.elevation({
             position: "bottomright",
@@ -246,13 +245,13 @@ module.exports.addElevation = function (geoJsonFeature) {
                 top: 10,
                 right: 20,
                 bottom: 30,
-                left: 50
+                left: 60
             },
             useHeightIndicator: true, //if false a marker is drawn at map position
             interpolation: "linear", //see https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-area_interpolate
             hoverNumber: {
-                decimalsX: 2, //decimals on distance (always in km)
-                decimalsY: 0, //decimals on height (always in m)
+                decimalsX: 2, //decimals on distance (in km or mi)
+                decimalsY: 0, //decimals on height (in m or ft)
                 formatter: undefined //custom formatter function may be injected
             },
             xTicks: undefined, //number of ticks in x axis, calculated by default according to width
@@ -261,7 +260,7 @@ module.exports.addElevation = function (geoJsonFeature) {
         });
         elevationControl.addTo(map);
     }
-
+    elevationControl.options.imperial = useMiles;
     elevationControl.addData(geoJsonFeature);
 };
 
@@ -274,6 +273,15 @@ module.exports.getMap = function () {
     return map;
 };
 
+module.exports.updateScale = function (useMiles) {
+    if (scaleControl === null) {
+        return;
+    }
+    scaleControl.remove();
+    var options = useMiles ? {metric: false} : {imperial: false};
+    scaleControl = L.control.scale(options).addTo(map);
+};
+
 var FROM = 'from', TO = 'to';
 function getToFrom(index, ghRequest) {
     if (index === 0)
@@ -303,30 +311,23 @@ module.exports.createMarker = function (index, coord, setToEnd, setToStart, dele
         icon: ((toFrom === FROM) ? iconFrom : ((toFrom === TO) ? iconTo : new L.NumberedDivIcon({number: index}))),
         draggable: true,
         contextmenu: true,
-        contextmenuItems: [{
+        contextmenuItems: defaultContextmenuItems.concat([{
                 text: translate.tr("marker") + ' ' + ((toFrom === FROM) ?
                         translate.tr("start_label") : ((toFrom === TO) ?
                         translate.tr("end_label") : translate.tr("intermediate_label") + ' ' + index)),
                 disabled: true,
-                index: 0,
-                state: 2
+                index: 0
             }, {
                 text: translate.tr((toFrom !== TO) ? "set_end" : "set_start"),
                 callback: (toFrom !== TO) ? setToEnd : setToStart,
-                index: 2,
-                state: 2
+                index: 2
             }, {
                 text: translate.tr("delete_from_route"),
                 callback: deleteCoord,
-                index: 3,
-                state: 2,
-                disabled: (toFrom !== -1 && ghRequest.route.size() === 2) ? true : false // prevent to and from
-            }, {
-                separator: true,
-                index: 4,
-                state: 2
-            }],
-        contextmenuAtiveState: 2
+                disabled: (toFrom !== -1 && ghRequest.route.size() === 2) ? true : false, // prevent to and from
+                index: 3
+            }]),
+        contextmenuInheritItems: false
     }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
             translate.tr("start_label") : ((toFrom === TO) ?
             translate.tr("end_label") : translate.tr("intermediate_label") + ' ' + index)));
diff --git a/web/src/main/webapp/js/routeManipulation.js b/web/src/main/webapp/js/routeManipulation.js
new file mode 100644
index 0000000000..dfd6eab693
--- /dev/null
+++ b/web/src/main/webapp/js/routeManipulation.js
@@ -0,0 +1,31 @@
+var L = require('leaflet');
+
+module.exports.getIntermediatePointIndex = function(routeSegments, clickedLocation) {
+    // for each point of the route determine its distance to the clicked location and the index
+    // of the waypoint that comes next if we keep following the route
+    var nextWayPointIndex = 0;
+    var wayPoints = routeSegments[0].wayPoints;
+    var distancesAndNextWayPointIndices = [];
+    for(var i=0; i<routeSegments.length; ++i) {
+        var routeCoords = routeSegments[i].coordinates;
+        for(var j=0; j<routeCoords.length; ++j) {
+            // whenever we hit a waypoint we start looking for the next one
+            if (routeCoords[j].equals(wayPoints[nextWayPointIndex], 1.e-5)) {
+                nextWayPointIndex++;
+            }
+            distancesAndNextWayPointIndices.push({
+                distance: routeCoords[j].distanceTo(clickedLocation),
+                nextWayPointIndex: nextWayPointIndex === wayPoints.length ? nextWayPointIndex-1 : nextWayPointIndex
+            });
+        }
+    }
+
+    // get the waypoint index for the point closest to the clicked location, if two distances are
+    // equal prefer the point further down the route for a slightly nicer user experience
+    var result = distancesAndNextWayPointIndices.reduce(function(prev, curr) {
+       return (curr.distance - prev.distance) < 1.e-6 ? curr : prev;
+    }).nextWayPointIndex;
+
+    result = (result > 0 && result < wayPoints.length) ? result : 1; //just for safety
+    return result;
+};
diff --git a/web/src/main/webapp/js/translate.js b/web/src/main/webapp/js/translate.js
index bc75abfdbb..1d382cbe5e 100755
--- a/web/src/main/webapp/js/translate.js
+++ b/web/src/main/webapp/js/translate.js
@@ -64,6 +64,9 @@ function initI18N() {
             else
                 $(this).attr("placeholder", tr("via_hint"));
         });
+        $('.pointFlag').each(function () {
+            $(this).attr('title', tr('drag_to_reorder'));
+        });
         $('.pointDelete').each(function () {
             $(this).attr("title", tr("delete_from_route"));
         });
@@ -72,25 +75,55 @@ function initI18N() {
     }
 }
 
-module.exports.createDistanceString = function (dist) {
-    if (dist < 900)
-        return mathTools.round(dist, 1) + tr2("m_abbr");
+function mToKm(m) {
+    return m / 1000;
+}
+
+function mToFt(m) {
+    return m / 0.3048;
+}
+
+function mToMi(m) {
+    return m / 1609.344;
+}
+
+module.exports.createDistanceString = function (dist, useMiles) {
+    if (!useMiles) {
+        if (dist < 900)
+            return mathTools.round(dist, 1) + tr2("m_abbr");
 
-    dist = mathTools.round(dist / 1000, 100);
-    if (dist > 100)
-        dist = mathTools.round(dist, 1);
-    return dist + tr2("km_abbr");
+        dist = mathTools.round(mToKm(dist), 100);
+        if (dist > 100)
+            dist = mathTools.round(dist, 1);
+        return dist + tr2("km_abbr");
+    } else {
+        if (dist < 152)
+            return mathTools.round(mToFt(dist), 1) + tr2("ft_abbr");
+
+        dist = mathTools.round(mToMi(dist), 100);
+        if (dist > 100)
+            dist = mathTools.round(dist, 1);
+        return dist + tr2("mi_abbr");
+    }
 };
 
-module.exports.createEleInfoString = function (ascend, descend) {
+module.exports.createEleInfoString = function (ascend, descend, useMiles) {
     var str = "";
     if (ascend > 0 || descend > 0) {
         str = "<br/> ";
-        if (ascend > 0)
-            str += "&#8599;" + mathTools.round(ascend, 1) + tr2("m_abbr");
+        if (ascend > 0) {
+            if (!useMiles)
+                str += "&#8599;" + mathTools.round(ascend, 1) + tr2("m_abbr");
+            else
+                str += "&#8599;" + mathTools.round(mToFt(ascend), 1) + tr2("ft_abbr");
+        }
 
-        if (descend > 0)
-            str += " &#8600;" + mathTools.round(descend, 1) + tr2("m_abbr");
+        if (descend > 0) {
+            if (!useMiles)
+                str += " &#8600;" + mathTools.round(descend, 1) + tr2("m_abbr");
+            else
+                str += " &#8600;" + mathTools.round(mToFt(descend), 1) + tr2("ft_abbr");
+        }
     }
 
     return str;
@@ -117,6 +150,7 @@ module.exports.createTimeString = function (time) {
 };
 
 module.exports.tr = tr;
+module.exports.tr2 = tr2;
 
 module.exports.nanoTemplate = function (template, data) {
     return template.replace(/\{([\w\.]*)\}/g, function (str, key) {
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index 021b5d5e1b..38fd117865 100755
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -34,31 +34,39 @@
 /**
  * @author Peter Karich
  */
-public class BaseServletTester
-{
-    private static GHServer server;
+public class BaseServletTester {
     protected static final Logger logger = LoggerFactory.getLogger(BaseServletTester.class);
     protected static int port;
+    private static GHServer server;
     protected Injector injector;
 
-    public void setUpGuice( Module... modules )
-    {
+    public static void shutdownJetty(boolean force) {
+        // this is too slow so allow force == false. Then on setUpJetty a new server is created on a different port
+        if (force && server != null)
+            try {
+                server.stop();
+            } catch (Exception ex) {
+                logger.error("Cannot stop jetty", ex);
+            }
+
+        server = null;
+    }
+
+    public void setUpGuice(Module... modules) {
         injector = Guice.createInjector(/*Stage.DEVELOPMENT,*/modules);
     }
 
     /**
      * This method will start jetty with andorra area loaded as OSM.
      */
-    public void setUpJetty( CmdArgs args )
-    {
+    public void setUpJetty(CmdArgs args) {
         if (injector != null)
             throw new UnsupportedOperationException("do not call guice before");
 
         bootJetty(args, 3);
     }
 
-    private void bootJetty( CmdArgs args, int retryCount )
-    {
+    private void bootJetty(CmdArgs args, int retryCount) {
         if (server != null)
             return;
 
@@ -67,56 +75,34 @@ private void bootJetty( CmdArgs args, int retryCount )
         if (injector == null)
             setUpGuice(new DefaultModule(args), new GHServletModule(args));
 
-        for (int i = 0; i < retryCount; i++)
-        {
+        for (int i = 0; i < retryCount; i++) {
             port = 18080 + i;
             args.put("jetty.port", "" + port);
-            try
-            {
+            try {
                 logger.info("Trying to start jetty at port " + port);
                 server.start(injector);
 //                server.join();
                 break;
-            } catch (Exception ex)
-            {
+            } catch (Exception ex) {
                 server = null;
                 logger.error("Cannot start jetty at port " + port + " " + ex.getMessage());
             }
         }
     }
 
-    public static void shutdownJetty( boolean force )
-    {
-        // this is too slow so allow force == false. Then on setUpJetty a new server is created on a different port
-        if (force && server != null)
-            try
-            {
-                server.stop();
-            } catch (Exception ex)
-            {
-                logger.error("Cannot stop jetty", ex);
-            }
-
-        server = null;
-    }
-
-    protected String getTestRouteAPIUrl()
-    {
+    protected String getTestRouteAPIUrl() {
         String host = "localhost";
         return "http://" + host + ":" + port + "/route";
     }
 
-    protected String getTestNearestAPIUrl()
-    {
+    protected String getTestNearestAPIUrl() {
         String host = "localhost";
         return "http://" + host + ":" + port + "/nearest";
     }
 
-    protected String queryString( String query, int code ) throws Exception
-    {
+    protected String queryString(String query, int code) throws Exception {
         String resQuery = "";
-        for (String q : query.split("\\&"))
-        {
+        for (String q : query.split("\\&")) {
             int index = q.indexOf("=");
             if (index > 0)
                 resQuery += q.substring(0, index + 1) + WebHelper.encodeURL(q.substring(index + 1));
@@ -133,16 +119,13 @@ protected String queryString( String query, int code ) throws Exception
         return Helper.isToString(downloader.fetch(conn, true));
     }
 
-    protected JSONObject query( String query, int code ) throws Exception
-    {
+    protected JSONObject query(String query, int code) throws Exception {
         return new JSONObject(queryString(query, code));
     }
 
-    protected JSONObject nearestQuery( String query ) throws Exception
-    {
+    protected JSONObject nearestQuery(String query) throws Exception {
         String resQuery = "";
-        for (String q : query.split("\\&"))
-        {
+        for (String q : query.split("\\&")) {
             int index = q.indexOf("=");
             if (index > 0)
                 resQuery += q.substring(0, index + 1) + WebHelper.encodeURL(q.substring(index + 1));
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 4969a6e77f..5516358324 100755
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -17,12 +17,13 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
 import org.json.JSONObject;
 import org.junit.AfterClass;
@@ -38,20 +39,17 @@
 /**
  * @author Peter Karich
  */
-public class GraphHopperServletIT extends BaseServletTester
-{
+public class GraphHopperServletIT extends BaseServletTester {
     private static final String DIR = "./target/andorra-gh/";
 
     @AfterClass
-    public static void cleanUp()
-    {
+    public static void cleanUp() {
         Helper.removeDir(new File(DIR));
         shutdownJetty(true);
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         CmdArgs args = new CmdArgs().
                 put("config", "../config-example.properties").
                 put("datareader.file", "../core/files/andorra.osm.pbf").
@@ -60,8 +58,7 @@ public void setUp()
     }
 
     @Test
-    public void testBasicQuery() throws Exception
-    {
+    public void testBasicQuery() throws Exception {
         JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
@@ -72,8 +69,7 @@ public void testBasicQuery() throws Exception
     }
 
     @Test
-    public void testQueryWithDirections() throws Exception
-    {
+    public void testQueryWithDirections() throws Exception {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
         JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240&ch.force_heading=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
@@ -85,8 +81,7 @@ public void testQueryWithDirections() throws Exception
     }
 
     @Test
-    public void testQueryWithStraightVia() throws Exception
-    {
+    public void testQueryWithStraightVia() throws Exception {
         // Note, in general specifying straightvia does not work with CH, but this is an example where it works
         JSONObject json = query(
                 "point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true", 200);
@@ -99,16 +94,14 @@ public void testQueryWithStraightVia() throws Exception
     }
 
     @Test
-    public void testJsonRounding() throws Exception
-    {
+    public void testJsonRounding() throws Exception {
         JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
         assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
 
     @Test
-    public void testFailIfElevationRequestedButNotIncluded() throws Exception
-    {
+    public void testFailIfElevationRequestedButNotIncluded() throws Exception {
         JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
         assertTrue(json.has("message"));
         assertEquals("Elevation not supported!", json.get("message"));
@@ -116,8 +109,7 @@ public void testFailIfElevationRequestedButNotIncluded() throws Exception
     }
 
     @Test
-    public void testGraphHopperWeb() throws Exception
-    {
+    public void testGraphHopperWeb() throws Exception {
         GraphHopperAPI hopper = new GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
@@ -144,8 +136,7 @@ public void testGraphHopperWeb() throws Exception
     }
 
     @Test
-    public void testGraphHopperWebRealExceptions()
-    {
+    public void testGraphHopperWebRealExceptions() {
         GraphHopperAPI hopper = new GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
 
@@ -161,9 +152,10 @@ public void testGraphHopperWebRealExceptions()
         rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
         assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
 
-        ex = rsp.getErrors().get(0);
-        assertTrue("Wrong exception found: " + ex.getClass().getName()
-                + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+        List<Throwable> errs = rsp.getErrors();
+        for (int i = 0; i < errs.size(); i++) {
+            assertEquals(((PointOutOfBoundsException) errs.get(i)).getPointIndex(), i);
+        }
 
         // IllegalArgumentException (Vehicle not supported)
         rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128).setVehicle("SPACE-SHUTTLE"));
@@ -175,8 +167,7 @@ public void testGraphHopperWebRealExceptions()
     }
 
     @Test
-    public void testGPX() throws Exception
-    {
+    public void testGPX() throws Exception {
         String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx", 200);
         // For backward compatibility we currently export route and track.
         assertTrue(str.contains("<gh:distance>115.1</gh:distance>"));
@@ -185,8 +176,7 @@ public void testGPX() throws Exception
     }
 
     @Test
-    public void testGPXWithExcludedRouteSelection() throws Exception
-    {
+    public void testGPXWithExcludedRouteSelection() throws Exception {
         String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx&gpx.route=false&gpx.waypoints=false", 200);
         assertFalse(str.contains("<gh:distance>115.1</gh:distance>"));
         assertFalse(str.contains("<wpt lat=\"42.51003\" lon=\"1.548188\"> <name>Finish!</name></wpt>"));
@@ -194,8 +184,7 @@ public void testGPXWithExcludedRouteSelection() throws Exception
     }
 
     @Test
-    public void testGPXWithTrackAndWaypointsSelection() throws Exception
-    {
+    public void testGPXWithTrackAndWaypointsSelection() throws Exception {
         String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx&gpx.track=true&gpx.route=false&gpx.waypoints=true", 200);
         assertFalse(str.contains("<gh:distance>115.1</gh:distance>"));
         assertTrue(str.contains("<wpt lat=\"42.51003\" lon=\"1.548188\"> <name>Finish!</name></wpt>"));
@@ -203,8 +192,7 @@ public void testGPXWithTrackAndWaypointsSelection() throws Exception
     }
 
     @Test
-    public void testGPXWithError() throws Exception
-    {
+    public void testGPXWithError() throws Exception {
         String str = queryString("point=42.554851,1.536198&type=gpx", 400);
         assertFalse(str, str.contains("<html>"));
         assertFalse(str, str.contains("{"));
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index 409879770c..4f6d81065d 100755
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -19,33 +19,29 @@
 
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-
-import java.io.File;
-
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.File;
+
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class GraphHopperServletWithEleIT extends BaseServletTester
-{
+public class GraphHopperServletWithEleIT extends BaseServletTester {
     private static final String dir = "./target/monaco-gh/";
 
     @AfterClass
-    public static void cleanUp()
-    {
+    public static void cleanUp() {
         Helper.removeDir(new File(dir));
         shutdownJetty(true);
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         CmdArgs args = new CmdArgs().
                 put("graph.elevation.provider", "srtm").
                 put("graph.elevation.cachedir", "../core/files/").
@@ -58,8 +54,7 @@ public void setUp()
     }
 
     @Test
-    public void testElevation() throws Exception
-    {
+    public void testElevation() throws Exception {
         JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
@@ -77,8 +72,7 @@ public void testElevation() throws Exception
     }
 
     @Test
-    public void testNoElevation() throws Exception
-    {
+    public void testNoElevation() throws Exception {
         // default is elevation=false
         JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
         JSONObject infoJson = json.getJSONObject("info");
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index 423b0e1424..0b54f07b14 100755
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -17,35 +17,30 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.PathWrapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 
-import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class GraphHopperWebTest
-{
+public class GraphHopperWebTest {
     // see also GraphHopperServletIT.testGraphHopperWeb for real routes against local jetty service    
 
     @Test
-    public void testReadEncoded() throws Exception
-    {
-        Downloader downloader = new Downloader("GraphHopper Test")
-        {
+    public void testReadEncoded() throws Exception {
+        Downloader downloader = new Downloader("GraphHopper Test") {
             @Override
-            public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
-            {
+            public InputStream fetch(HttpURLConnection conn, boolean readErrorStreamNoException) throws IOException {
                 return getClass().getResourceAsStream("test_encoded.json");
             }
         };
@@ -65,13 +60,10 @@ public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoExcep
     }
 
     @Test
-    public void testCreateURL() throws Exception
-    {
-        Downloader downloader = new Downloader("GraphHopper Test")
-        {
+    public void testCreateURL() throws Exception {
+        Downloader downloader = new Downloader("GraphHopper Test") {
             @Override
-            public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
-            {
+            public String downloadAsString(String url, boolean readErrorStreamNoException) throws IOException {
                 assertFalse(url.contains("xy"));
                 assertFalse(url.contains("algo1"));
                 assertTrue(url.contains("alternative_route.max_paths=4"));
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
index a5a61bcb3d..f415387144 100755
--- a/web/src/test/java/com/graphhopper/http/IPFilterTest.java
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -19,16 +19,15 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
-public class IPFilterTest
-{
+public class IPFilterTest {
     @Test
-    public void testAcceptWhite()
-    {
+    public void testAcceptWhite() {
         IPFilter instance = new IPFilter("1.2.3.4, 4.5.67.1", "");
         assertTrue(instance.accept("1.2.3.4"));
         assertTrue(instance.accept("4.5.67.1"));
@@ -45,8 +44,7 @@ public void testAcceptWhite()
     }
 
     @Test
-    public void testAcceptBlack()
-    {
+    public void testAcceptBlack() {
         IPFilter instance = new IPFilter("", "1.2.3.4, 4.5.67.1");
 
         assertFalse(instance.accept("1.2.3.4"));
@@ -55,17 +53,14 @@ public void testAcceptBlack()
     }
 
     @Test
-    public void testFilterSpecialCases()
-    {
+    public void testFilterSpecialCases() {
         IPFilter instance = new IPFilter("", "");
         assertTrue(instance.accept("1.2.3.4"));
 
-        try
-        {
+        try {
             new IPFilter("1.2.3.4, 4.5.67.1", "8.9.7.3");
             assertFalse("black and white", true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
 
         }
     }
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
index f73156f2d6..1cdd7c6f57 100755
--- a/web/src/test/java/com/graphhopper/http/NearestServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -17,38 +17,33 @@
  */
 package com.graphhopper.http;
 
-import static com.graphhopper.http.BaseServletTester.shutdownJetty;
-
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-
-import java.io.File;
-
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.io.File;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author svantulden
  */
-public class NearestServletIT extends BaseServletTester
-{
+public class NearestServletIT extends BaseServletTester {
     private static final String dir = "./target/andorra-gh/";
 
     @AfterClass
-    public static void cleanUp()
-    {
+    public static void cleanUp() {
         Helper.removeDir(new File(dir));
         shutdownJetty(true);
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         CmdArgs args = new CmdArgs().
                 put("config", "../config-example.properties").
                 put("datareader.file", "../core/files/andorra.osm.pbf").
@@ -57,8 +52,7 @@ public void setUp()
     }
 
     @Test
-    public void testBasicNearestQuery() throws Exception
-    {
+    public void testBasicNearestQuery() throws Exception {
         JSONObject json = nearestQuery("point=42.554851,1.536198");
         assertFalse(json.has("error"));
         JSONArray point = json.getJSONArray("coordinates");
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
index 5eb838c897..9bd1d4b9c4 100755
--- a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -17,38 +17,33 @@
  */
 package com.graphhopper.http;
 
-import static com.graphhopper.http.BaseServletTester.shutdownJetty;
-
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-
-import java.io.File;
-
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.io.File;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author svantulden
  */
-public class NearestServletWithEleIT extends BaseServletTester
-{
+public class NearestServletWithEleIT extends BaseServletTester {
     private static final String dir = "./target/monaco-gh/";
 
     @AfterClass
-    public static void cleanUp()
-    {
+    public static void cleanUp() {
         Helper.removeDir(new File(dir));
         shutdownJetty(true);
     }
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         CmdArgs args = new CmdArgs().
                 put("graph.elevation.provider", "srtm").
                 put("graph.elevation.cachedir", "../core/files/").
@@ -61,8 +56,7 @@ public void setUp()
     }
 
     @Test
-    public void testWithEleQuery() throws Exception
-    {
+    public void testWithEleQuery() throws Exception {
         JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=true");
         assertFalse(json.has("error"));
         JSONArray point = json.getJSONArray("coordinates");
@@ -74,8 +68,7 @@ public void testWithEleQuery() throws Exception
     }
 
     @Test
-    public void testWithoutEleQuery() throws Exception
-    {
+    public void testWithoutEleQuery() throws Exception {
         JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=false");
         assertFalse(json.has("error"));
         JSONArray point = json.getJSONArray("coordinates");
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
index a3885815b9..1d526b6fcc 100755
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -21,16 +21,14 @@
 import com.graphhopper.util.PointList;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
-public class WebHelperTest
-{
+public class WebHelperTest {
     @Test
-    public void testDecode() throws Exception
-    {
+    public void testDecode() throws Exception {
         PointList list = WebHelper.decodePolyline("_p~iF~ps|U", 1, false);
         assertEquals(Helper.createPointList(38.5, -120.2), list);
 
@@ -39,8 +37,7 @@ public void testDecode() throws Exception
     }
 
     @Test
-    public void testEncode() throws Exception
-    {
+    public void testEncode() throws Exception {
         assertEquals("_p~iF~ps|U", WebHelper.encodePolyline(
                 Helper.createPointList(38.5, -120.2)));
 
@@ -49,8 +46,7 @@ public void testEncode() throws Exception
     }
 
     @Test
-    public void testBoth() throws Exception
-    {
+    public void testBoth() throws Exception {
         PointList list = Helper.createPointList(38.5, -120.2, 43.252, -126.453,
                 40.7, -120.95, 50.3139, 10.61279, 50.04303, 9.49768);
         String str = WebHelper.encodePolyline(list);
@@ -63,8 +59,7 @@ public void testBoth() throws Exception
     }
 
     @Test
-    public void testDecode3D() throws Exception
-    {
+    public void testDecode3D() throws Exception {
         PointList list = WebHelper.decodePolyline("_p~iF~ps|Uo}@", 1, true);
         assertEquals(Helper.createPointList3D(38.5, -120.2, 10), list);
 
@@ -73,8 +68,7 @@ public void testDecode3D() throws Exception
     }
 
     @Test
-    public void testEncode3D() throws Exception
-    {
+    public void testEncode3D() throws Exception {
         assertEquals("_p~iF~ps|Uo}@", WebHelper.encodePolyline(Helper.createPointList3D(38.5, -120.2, 10)));
         assertEquals("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", WebHelper.encodePolyline(
                 Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234)));
diff --git a/web/src/test/webapp/spec/routeManipulationSpec.js b/web/src/test/webapp/spec/routeManipulationSpec.js
new file mode 100644
index 0000000000..b089f54dc3
--- /dev/null
+++ b/web/src/test/webapp/spec/routeManipulationSpec.js
@@ -0,0 +1,110 @@
+// Because leaflet-src.js requires window, document, and navigator we need to
+// provide these variables.
+global.window = {
+    screen: {}
+};
+global.document = {
+    documentElement: {
+        style: {}
+    },
+    getElementsByTagName: function() { return []; },
+    createElement: function() { return {}; }
+};
+global.navigator = {
+    platform: 'nodejs',
+    userAgent: 'nodejs'
+};
+
+var L = require('leaflet');
+var routeManipulation = requireFile('./routeManipulation.js');
+
+/*some test data with url parameters:
+ ?point=52.550,13.352&point=52.547,13.358&point=52.541,13.368&point=52.542,13.376&point=52.542,13.383
+ &point=52.545,13.391&point=52.542,13.408&point=52.539,13.424&point=52.533,13.441&point=52.527,13.447
+ &point=52.533,13.476&point=52.561,13.457&point=52.581,13.397 */
+var a  = L.latLng(52.5500, 13.3520);
+var x1 = L.latLng(52.5470, 13.3580);
+var x2 = L.latLng(52.5410, 13.3680);
+var x3 = L.latLng(52.5420, 13.3760);
+var b  = L.latLng(52.5420, 13.3830);
+var x4 = L.latLng(52.5450, 13.3910);
+var x5 = L.latLng(52.5420, 13.4080);
+var c  = L.latLng(52.5390, 13.4240);
+var x6 = L.latLng(52.5330, 13.4410);
+var x7 = L.latLng(52.5270, 13.4470);
+var d  = L.latLng(52.5330, 13.4760);
+var x8 = L.latLng(52.5610, 13.4570);
+var x9 = L.latLng(52.5810, 13.3970);
+
+var clickLocations = [
+    { latlng: L.latLng(52.567,13.342), expectedIndex: 1},
+    { latlng: L.latLng(52.540,13.378), expectedIndex: 1},
+    { latlng: L.latLng(52.542,13.396), expectedIndex: 2},
+    { latlng: L.latLng(52.526,13.463), expectedIndex: 3},
+    { latlng: L.latLng(52.526,13.519), expectedIndex: 3}
+];
+
+describe('getIntermediatePointIndex', function () {
+    it('should work', function () {
+        var routeSegments =  [{
+            coordinates: [a, x1, x2, x3, b, x4, x5, c, x6, x7, d],
+            wayPoints: [a, b, c, d]
+        }];
+
+        for(var i=0; i < clickLocations.length; ++i) {
+            expect(routeManipulation.getIntermediatePointIndex(routeSegments, clickLocations[i].latlng))
+                    .toEqual(clickLocations[i].expectedIndex);
+        }
+    });
+});
+
+describe('getIntermediatePointIndex', function () {
+    it('should work for round trips', function () {
+        var routeSegments =  [{
+            coordinates: [a, x1, x2, x3, b, x4, x5, c, x6, x7, d, x8, x9, a],
+            wayPoints: [a, b, c, d, a]
+        }];
+
+        var clickLocation = L.latLng(52.568,13.389);
+
+        expect(routeManipulation.getIntermediatePointIndex(routeSegments, clickLocation))
+                .toEqual(4);
+    });
+});
+
+describe('getIntermediaPointIndex', function() {
+    it('should yield a nice order if some parts of the route are crossed twice', function() {
+        // let 'a' be chosen as start and end point and 'b' as the first intermediate point. assume
+        // that the route a->b is (partly) the same as b->a. if we add a second intermediate point
+        // close to a road that is used on both ways we expect it to be inserted after 'b',
+        // and not before 'b'.
+        var routeSegments =[{
+                coordinates: [a, x1, x2, x3, b, x3, x2, x1, a],
+                wayPoints: [a, b, a]
+        }];
+        var clickLocation = L.latLng(52.540,13.376);
+        expect(routeManipulation.getIntermediatePointIndex(routeSegments, clickLocation))
+                .toEqual(2);
+    });
+});
+
+describe('getIntermediatePointIndex', function () {
+    it('should work when using alternative routes', function () {
+        var wayPoints = [a, b, c, d];
+        var routeSegments =  [{
+            coordinates: [a, x1, x2, x3, b],
+            wayPoints: wayPoints
+        }, {
+            coordinates: [b, x4, x5, c],
+            wayPoints: wayPoints
+        }, {
+            coordinates: [c, x6, x7, d],
+            wayPoints: wayPoints
+        }];
+
+        for(var i=0; i < clickLocations.length; ++i) {
+            expect(routeManipulation.getIntermediatePointIndex(routeSegments, clickLocations[i].latlng))
+                    .toEqual(clickLocations[i].expectedIndex);
+        }
+    });
+});
diff --git a/web/src/test/webapp/spec/translateSpec.js b/web/src/test/webapp/spec/translateSpec.js
index c8ce1c9a1c..6b45f53f81 100755
--- a/web/src/test/webapp/spec/translateSpec.js
+++ b/web/src/test/webapp/spec/translateSpec.js
@@ -1,13 +1,46 @@
 var translate = requireFile('./translate.js');
 
 describe('translation', function () {
+    it("should format distance string correctly", function () {
+        var defaultTranslationMap = {};
+        defaultTranslationMap["m_abbr"] = 'm';
+        defaultTranslationMap["km_abbr"] = 'km';
+        defaultTranslationMap["ft_abbr"] = 'ft';
+        defaultTranslationMap["mi_abbr"] = 'mi';
+
+        translate.init({default: defaultTranslationMap});
+
+        expect(translate.createDistanceString(877.34)).toBe("877m");
+        expect(translate.createDistanceString(1877.34)).toBe("1.88km");
+        expect(translate.createDistanceString(100877.34)).toBe("101km");
+        expect(translate.createDistanceString(100877.34, false)).toBe("101km");
+
+        expect(translate.createDistanceString(151.96, true)).toBe("499ft")
+        expect(translate.createDistanceString(152.31, true)).toBe("0.09mi")
+        expect(translate.createDistanceString(4988.97, true)).toBe("3.1mi")
+        expect(translate.createDistanceString(4998.97, true)).toBe("3.11mi")
+        expect(translate.createDistanceString(162543.74, true)).toBe("101mi")
+    });
+
+    it("should format elevation string correctly", function () {
+        var defaultTranslationMap = {};
+        defaultTranslationMap["m_abbr"] = 'm';
+        defaultTranslationMap["ft_abbr"] = 'ft';
+
+        translate.init({default: defaultTranslationMap});
+
+        expect(translate.createEleInfoString(156.3, 324.6, true)).toBe("<br/> &#8599;513ft &#8600;1065ft");
+        expect(translate.createEleInfoString(156.3, 324.6, false)).toBe("<br/> &#8599;156m &#8600;325m");
+        expect(translate.createEleInfoString(156.3, 324.6)).toBe("<br/> &#8599;156m &#8600;325m");
+    });
+
     it("should format time string correctly", function () {
         var defaultTranslationMap = {};
         defaultTranslationMap["min_abbr"] = 'min';
         defaultTranslationMap["hour_abbr"] = 'h';
         defaultTranslationMap["day_abbr"] = 'd';
 
-        translate.init({ default: defaultTranslationMap });
+        translate.init({default: defaultTranslationMap});
 
         expect(translate.createTimeString(10773331)).toBe("2h 59min");
 
@@ -22,19 +55,19 @@ describe('translation', function () {
         // toBe, toBeTruthy, toBeFalsy
         var defaultTranslationMap = {};
         defaultTranslationMap["web.somekey1"] = "%s wow %s";
-        translate.init({ default: defaultTranslationMap });
+        translate.init({default: defaultTranslationMap});
         expect(translate.tr("somekey1", ["nice", "to"])).toBe("nice wow to");
 
         defaultTranslationMap["web.somekey2"] = "%2$s wow %1$s";
-        translate.init({ default: defaultTranslationMap });
+        translate.init({default: defaultTranslationMap});
         expect(translate.tr("somekey2", ["nice", "to"])).toBe("to wow nice");
 
         defaultTranslationMap["web.key"] = "it will take %1$s";
-        translate.init({ default: defaultTranslationMap });
+        translate.init({default: defaultTranslationMap});
         expect(translate.tr("key", "2min")).toBe("it will take 2min");
 
         defaultTranslationMap["web.key"] = "%1$s%2$s werden %3$s brauchen";
-        translate.init({ default: defaultTranslationMap });
+        translate.init({default: defaultTranslationMap});
         expect(translate.tr("key", [200, "km", "2min"])).toBe("200km werden 2min brauchen");
     });
 });
