diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 25b7559996..a119864bd2 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -107,6 +107,14 @@ protected void checkAlreadyRun() {
         return Collections.singletonList(calcPath(from, to));
     }
 
+    public List<Path> calcTDPaths(int from, int to, long at) {
+        return Collections.singletonList(calcTDPath(from, to, at));
+    }
+
+    public Path calcTDPath(int from, int to, long at) {
+        throw new RuntimeException("Unsupported. (Add algorithm=dijkstra to request?)");
+    }
+
     protected Path createEmptyPath() {
         return new Path(graph, weighting);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 8b342cd9ec..5d6f4bc4a3 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -186,6 +186,11 @@ public Path calcPath(int from, int to) {
         return calcPaths(from, to).get(0);
     }
 
+    @Override
+    public Path calcTDPath(int from, int to, long at) {
+        throw new RuntimeException();
+    }
+
     @Override
     public List<Path> calcPaths(int from, int to) {
         List<AlternativeInfo> alts = calcAlternatives(from, to);
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 93a5abb25b..e35a5c0cc9 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -20,6 +20,7 @@
 import com.carrotsearch.hppc.IntObjectMap;
 import com.graphhopper.coll.GHIntObjectHashMap;
 import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.TDWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
@@ -57,9 +58,25 @@ protected void initCollections(int size) {
 
     @Override
     public Path calcPath(int from, int to) {
+        if (weighting instanceof TDWeighting) throw new RuntimeException();
         checkAlreadyRun();
         this.to = to;
         currEdge = new SPTEntry(from, 0);
+        currEdge.time = 0;
+        if (!traversalMode.isEdgeBased()) {
+            fromMap.put(from, currEdge);
+        }
+        runAlgo();
+        return extractPath();
+    }
+
+    @Override
+    public Path calcTDPath(int from, int to, long at) {
+        if (!(weighting instanceof TDWeighting)) throw new RuntimeException();
+        checkAlreadyRun();
+        this.to = to;
+        currEdge = new SPTEntry(from, 0);
+        currEdge.time = at;
         if (!traversalMode.isEdgeBased()) {
             fromMap.put(from, currEdge);
         }
@@ -81,7 +98,12 @@ protected void runAlgo() {
                     continue;
 
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
+                double tmpWeight;
+                if (weighting instanceof TDWeighting) {
+                    tmpWeight = ((TDWeighting) weighting).calcTDWeight(iter, false, currEdge.edge, currEdge.time) + currEdge.weight;
+                } else {
+                    tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
+                }
                 if (Double.isInfinite(tmpWeight))
                     continue;
 
@@ -89,6 +111,9 @@ protected void runAlgo() {
                 if (nEdge == null) {
                     nEdge = new SPTEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
                     nEdge.parent = currEdge;
+                    if (weighting instanceof TDWeighting) {
+                        nEdge.time = ((TDWeighting) weighting).calcTDMillis(iter, false, currEdge.edge, currEdge.time) + currEdge.time;
+                    }
                     fromMap.put(traversalId, nEdge);
                     fromHeap.add(nEdge);
                 } else if (nEdge.weight > tmpWeight) {
@@ -96,6 +121,9 @@ protected void runAlgo() {
                     nEdge.edge = iter.getEdge();
                     nEdge.weight = tmpWeight;
                     nEdge.parent = currEdge;
+                    if (weighting instanceof TDWeighting) {
+                        nEdge.time = ((TDWeighting) weighting).calcTDMillis(iter, false, currEdge.edge, currEdge.time) + currEdge.time;
+                    }
                     fromHeap.add(nEdge);
                 } else
                     continue;
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 2315fb1a2e..4dfc0e5593 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -19,8 +19,8 @@
 
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.TDWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.IntsRef;
@@ -428,8 +428,13 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
         }
         double newDist = edge.getDistance();
         prevInstruction.setDistance(newDist + prevInstruction.getDistance());
-        prevInstruction.setTime(weighting.calcMillis(edge, false, EdgeIterator.NO_EDGE)
-                + prevInstruction.getTime());
+        if (weighting instanceof TDWeighting) {
+            prevInstruction.setTime(((TDWeighting) weighting).calcTDMillis(edge, false, EdgeIterator.NO_EDGE, prevInstruction.getTime())
+                    + prevInstruction.getTime());
+        } else {
+            prevInstruction.setTime(weighting.calcMillis(edge, false, EdgeIterator.NO_EDGE)
+                    + prevInstruction.getTime());
+        }
     }
 
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 2f32dcacf3..265b467bc5 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -22,6 +22,7 @@
 import com.graphhopper.coll.GHIntArrayList;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.TDWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
@@ -206,7 +207,9 @@ public Path extract() {
             processEdge(currEdge.edge, currEdge.adjNode, nextEdge);
             currEdge = currEdge.parent;
         }
-
+        if (weighting instanceof TDWeighting) {
+            time = sptEntry.time - currEdge.time;
+        }
         setFromNode(currEdge.adjNode);
         reverseOrder();
         extractSW.stop();
@@ -240,7 +243,9 @@ public String getDebugInfo() {
     protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
         distance += iter.getDistance();
-        time += weighting.calcMillis(iter, false, prevEdgeId);
+        if (!(weighting instanceof TDWeighting)) {
+            time += weighting.calcMillis(iter, false, prevEdgeId);
+        }
         addEdge(edgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index 619593b90e..d9ee50d185 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -36,6 +36,8 @@
      */
     Path calcPath(int from, int to);
 
+    Path calcTDPath(int from, int to, long at);
+
     /**
      * Calculates multiple possibilities for a path.
      *
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index 5ad1d7f2f4..189871ca71 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -22,6 +22,7 @@
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.TDWeighting;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIteratorState;
@@ -112,7 +113,16 @@ public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex l
             sw = new StopWatch().start();
 
             // calculate paths
-            List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            List<Path> tmpPathList;
+            if (algoOpts.getWeighting() instanceof TDWeighting) {
+                int departure_time = ghRequest.getHints().getInt("departure_time", -1);
+                if (departure_time == -1) {
+                    throw new RuntimeException("Must specify departure_time in request.");
+                }
+                tmpPathList = ((AbstractRoutingAlgorithm) algo).calcTDPaths(fromQResult.getClosestNode(), toQResult.getClosestNode(), departure_time * 1000);
+            } else {
+                tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            }
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s";
             if (tmpPathList.isEmpty())
                 throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/TDWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TDWeighting.java
new file mode 100644
index 0000000000..8803fc5135
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TDWeighting.java
@@ -0,0 +1,29 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public interface TDWeighting extends Weighting {
+
+    double calcTDWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, long linkEnterTime);
+
+    long calcTDMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, long linkEnterTime);
+
+}
+
diff --git a/core/src/main/java/com/graphhopper/storage/SPTEntry.java b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
index da8cc82e31..7af84c77bc 100644
--- a/core/src/main/java/com/graphhopper/storage/SPTEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
@@ -29,6 +29,7 @@
     public int edge;
     public int adjNode;
     public double weight;
+    public long time;
     public SPTEntry parent;
 
     public SPTEntry(int edgeId, int adjNode, double weight) {
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
index 03bb4fbb73..25b5120edc 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
@@ -23,7 +23,12 @@
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.lm.LandmarkStorage;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupHelper;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.swl.*;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
@@ -44,6 +49,13 @@
     private final GraphHopper graphHopper;
 
     public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
+        String linkSpeedFile = configuration.get("r5.link_speed_file", null);
+        final SpeedCalculator speedCalculator;
+        if (linkSpeedFile != null) {
+            speedCalculator = new FileSpeedCalculator(linkSpeedFile);
+        } else {
+            speedCalculator = new DefaultSpeedCalculator();
+        }
         String splitAreaLocation = configuration.get(Parameters.Landmark.PREPARE + "split_area_location", "");
         JsonFeatureCollection landmarkSplittingFeatureCollection;
         try (Reader reader = splitAreaLocation.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(splitAreaLocation), UTF_CS)) {
@@ -52,7 +64,16 @@ public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
             logger.error("Problem while reading border map GeoJSON. Skipping this.", e1);
             landmarkSplittingFeatureCollection = null;
         }
-        graphHopper = new GraphHopperOSM(landmarkSplittingFeatureCollection).forServer();
+        graphHopper = new GraphHopperOSM(landmarkSplittingFeatureCollection) {
+            @Override
+            public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
+                if (hintsMap.getWeighting().equals("td")) {
+                    return new FastestCarTDWeighting(encoder, speedCalculator, hintsMap);
+                } else {
+                    return super.createWeighting(hintsMap, encoder, graph);
+                }
+            }
+        }.forServer();
         String spatialRuleLocation = configuration.get("spatial_rules.location", "");
         if (!spatialRuleLocation.isEmpty()) {
             final BBox maxBounds = BBox.parseBBoxString(configuration.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
@@ -64,6 +85,7 @@ public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
             }
         }
         graphHopper.init(configuration);
+        graphHopper.setPathDetailsBuilderFactory(new PathDetailsBuilderFactoryWithEdgeKey());
     }
 
     @Override
@@ -75,7 +97,7 @@ public void start() {
                 + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
     }
 
-    GraphHopper getGraphHopper() {
+    public GraphHopper getGraphHopper() {
         return graphHopper;
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/DefaultSpeedCalculator.java b/web-bundle/src/main/java/com/graphhopper/swl/DefaultSpeedCalculator.java
new file mode 100644
index 0000000000..bbcf8da54f
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/DefaultSpeedCalculator.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.util.EdgeIteratorState;
+
+public class DefaultSpeedCalculator implements SpeedCalculator {
+
+    @Override
+    public double getSpeed(EdgeIteratorState edgeState, boolean reverse, int durationSeconds, FlagEncoder encoder) {
+
+        double decimal = encoder.getAverageSpeedEnc().getDecimal(reverse, edgeState.getFlags());
+
+        if (!edgeState.get(encoder.getAccessEnc()))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. ");
+
+
+        return decimal;
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeyDetails.java b/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeyDetails.java
new file mode 100644
index 0000000000..1800f4e454
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeyDetails.java
@@ -0,0 +1,46 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.details.AbstractPathDetailsBuilder;
+
+public class EdgeKeyDetails extends AbstractPathDetailsBuilder {
+    private int edgeKey;
+
+    public EdgeKeyDetails() {
+        super("edge_key");
+        edgeKey = -1;
+    }
+
+    @Override
+    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
+        int newEdgeKey = EdgeKeys.getEdgeKey(edge);
+        if (newEdgeKey != edgeKey) {
+            edgeKey = newEdgeKey;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public Object getCurrentValue() {
+        return this.edgeKey;
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeys.java b/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeys.java
new file mode 100644
index 0000000000..79e0ed0d02
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/EdgeKeys.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+
+public class EdgeKeys {
+
+    static int getEdgeKey(EdgeIteratorState edge) {
+        final int edgeIndex;
+        if (edge instanceof VirtualEdgeIteratorState) {
+            edgeIndex = GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalEdgeKey());
+        } else {
+            edgeIndex = edge.getEdge();
+        }
+        return edgeIndex * 2 + (!edge.get(EdgeIteratorState.REVERSE_STATE) ? 0 : 1);
+    }
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/FastestCarTDWeighting.java b/web-bundle/src/main/java/com/graphhopper/swl/FastestCarTDWeighting.java
new file mode 100644
index 0000000000..e5f8e621e4
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/FastestCarTDWeighting.java
@@ -0,0 +1,114 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.TDWeighting;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
+
+public class FastestCarTDWeighting implements TDWeighting {
+
+    protected static final double SPEED_CONV = 3.6D;
+
+    private final double maxSpeed;
+    private final FlagEncoder encoder;
+    private final SpeedCalculator speedCalculator;
+    private final long headingPenaltyMillis;
+    private final double headingPenalty;
+    private long initialTime;
+
+    public FastestCarTDWeighting(FlagEncoder encoder, SpeedCalculator speedCalculator, PMap map) {
+        this.encoder = encoder;
+        this.maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
+        this.speedCalculator = speedCalculator;
+
+        headingPenalty = map.getDouble(Parameters.Routing.HEADING_PENALTY, Parameters.Routing.DEFAULT_HEADING_PENALTY);
+        headingPenaltyMillis = Math.round(headingPenalty * 1000);
+    }
+
+    @Override
+    public double getMinWeight(double distance) {
+        return distance / this.maxSpeed;
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public long calcMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public double calcTDWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, long linkEnterTime) {
+        double speed = speedCalculator.getSpeed(edge, reverse, (int) (linkEnterTime / 1000), encoder);
+        if (speed == 0)
+            return Double.POSITIVE_INFINITY;
+
+        double time = edge.getDistance() / speed * SPEED_CONV;
+
+        // add direction penalties at start/stop/via points
+        boolean unfavoredEdge = edge.get(EdgeIteratorState.UNFAVORED_EDGE);
+        if (unfavoredEdge)
+            time += headingPenalty;
+
+        return time;
+    }
+
+    @Override
+    public long calcTDMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, long linkEnterTime) {
+        double speed = speedCalculator.getSpeed(edge, reverse, (int) (linkEnterTime / 1000), encoder);
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! " +
+                    "Should only occur for shortest path calculation. See #242.");
+        long time = (long) (edge.getDistance() * 3600 / speed);
+        boolean unfavoredEdge = edge.get(EdgeIteratorState.UNFAVORED_EDGE);
+        if (unfavoredEdge)
+            time += headingPenaltyMillis;
+        return time;
+    }
+
+    @Override
+    public FlagEncoder getFlagEncoder() {
+        return encoder;
+    }
+
+    @Override
+    public String getName() {
+        return "td";
+    }
+
+    @Override
+    public boolean matches(HintsMap reqMap) {
+        return getName().equals(reqMap.getWeighting())
+                && encoder.toString().equals(reqMap.getVehicle());
+    }
+
+    @Override
+    public String toString() {
+        return getName();
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/FileSpeedCalculator.java b/web-bundle/src/main/java/com/graphhopper/swl/FileSpeedCalculator.java
new file mode 100644
index 0000000000..04de10e8fb
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/FileSpeedCalculator.java
@@ -0,0 +1,106 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.csvreader.CsvReader;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.util.EdgeIteratorState;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+public class FileSpeedCalculator implements SpeedCalculator {
+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(FileSpeedCalculator.class);
+
+    private final SpeedCalculator delegateTravelTimeCalculator;
+
+    private Map<Integer, short[]> linkTravelTimes;
+
+    /**
+     *  The class behaves differently, depending on the value of the parameter.
+     *
+     *  If the parameter is a local path, then the file at that path is read into `linkTravelTimes`.
+     *
+     *  If the parameter is a GCS path, than the contents of the file (let's call it a "meta" file) is treated as a
+     *  path to a congestion file on GCS. The contents of the "meta" file is monitored, and whenever it is updated,
+     *  `linkTravelTimes` is updated with the contents of the new congestion file.
+     *
+     * @param path Either:
+     *             - path to the local file with congestion data.
+     *             - path on GCS to a text file, containing the path on GCS to a file with congestion data.
+     */
+    public FileSpeedCalculator(String path) {
+        linkTravelTimes = readTravelTimes(new File(path));
+        delegateTravelTimeCalculator = new DefaultSpeedCalculator();
+    }
+
+    @Override
+    public double getSpeed(EdgeIteratorState edgeState, boolean reverse, int currentTimeSeconds, FlagEncoder encoder) {
+        if (linkTravelTimes != null) {
+            short[] speeds = linkTravelTimes.get(EdgeKeys.getEdgeKey(edgeState));
+            if (speeds != null) {
+                int timebinIndex = (currentTimeSeconds / (60 * 15)) % (24 * 4);
+                double speedms = speeds[timebinIndex] / 3.6;
+                return speedms;
+            }
+        }
+        return delegateTravelTimeCalculator.getSpeed(edgeState, reverse, currentTimeSeconds, encoder);
+    }
+
+    private static Map<Integer, short[]> readTravelTimes(File file) {
+        Map<Integer, short[]> res = new HashMap<>();
+        LOG.warn("Processing {}", file.toString());
+        try (InputStream is = new FileInputStream(file)) {
+            CsvReader reader = new CsvReader(is, ',', Charset.forName("UTF-8"));
+            reader.readHeaders();
+            while (reader.readRecord()) {
+                int edgeId = Integer.parseInt(reader.get("edgeId"));
+                int[] speeds = IntStream.range(0, 24).mapToObj(Integer::toString).flatMap(hour -> {
+                    try {
+                        return Stream.of(Short.parseShort(reader.get(hour + "h_1")),
+                                Short.parseShort(reader.get(hour + "h_2")), Short.parseShort(reader.get(hour + "h_3")),
+                                Short.parseShort(reader.get(hour + "h_4")));
+                    } catch (IOException e) {
+                        throw new RuntimeException(e);
+                    }
+                }).mapToInt(v -> v).toArray();
+                // TODO(sindelar): temporary hack to decrease the memory footprint for congestion
+                short shortSpeeds[] = new short[speeds.length];
+                for (int i = 0; i < speeds.length; i++) {
+                    shortSpeeds[i] = (short) speeds[i];
+                }
+                res.put(edgeId, shortSpeeds);
+            }
+        } catch (IOException ex) {
+            throw new RuntimeException("Exception while loading travel times.");
+        }
+        LOG.warn("Done.");
+
+        return res;
+    }
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/PathDetailsBuilderFactoryWithEdgeKey.java b/web-bundle/src/main/java/com/graphhopper/swl/PathDetailsBuilderFactoryWithEdgeKey.java
new file mode 100644
index 0000000000..82d8e46a29
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/PathDetailsBuilderFactoryWithEdgeKey.java
@@ -0,0 +1,58 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.util.details.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.graphhopper.util.Parameters.DETAILS.*;
+
+public class PathDetailsBuilderFactoryWithEdgeKey extends PathDetailsBuilderFactory {
+
+    @Override
+    public List<PathDetailsBuilder> createPathDetailsBuilders(List<String> requestedPathDetails, FlagEncoder encoder, Weighting weighting) {
+        // request-scoped
+        List<PathDetailsBuilder> builders = new ArrayList<>();
+        if (requestedPathDetails.contains(AVERAGE_SPEED))
+            builders.add(new AverageSpeedDetails(encoder));
+
+        if (requestedPathDetails.contains(STREET_NAME))
+            builders.add(new StreetNameDetails());
+
+        if (requestedPathDetails.contains(EDGE_ID))
+            builders.add(new EdgeIdDetails());
+
+        if (requestedPathDetails.contains(TIME))
+            builders.add(new TimeDetails(weighting));
+
+        if (requestedPathDetails.contains("edge_key")) {
+            builders.add(new EdgeKeyDetails());
+        }
+
+        if (requestedPathDetails.size() != builders.size()) {
+            throw new IllegalArgumentException("You requested the details " + requestedPathDetails + " but we could only find " + builders);
+        }
+
+        return builders;
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/swl/SpeedCalculator.java b/web-bundle/src/main/java/com/graphhopper/swl/SpeedCalculator.java
new file mode 100644
index 0000000000..aa096337f1
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/swl/SpeedCalculator.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.util.EdgeIteratorState;
+
+public interface SpeedCalculator {
+    double getSpeed(EdgeIteratorState edgeState, boolean reverse, int durationSeconds, FlagEncoder encoder);
+
+}
diff --git a/web/files/r5_predicted_tt.csv b/web/files/r5_predicted_tt.csv
new file mode 100644
index 0000000000..e3bfc9a72e
--- /dev/null
+++ b/web/files/r5_predicted_tt.csv
@@ -0,0 +1,5 @@
+edgeId,geometry,streetName,speedLimit,0h_1,0h_2,0h_3,0h_4,1h_1,1h_2,1h_3,1h_4,2h_1,2h_2,2h_3,2h_4,3h_1,3h_2,3h_3,3h_4,4h_1,4h_2,4h_3,4h_4,5h_1,5h_2,5h_3,5h_4,6h_1,6h_2,6h_3,6h_4,7h_1,7h_2,7h_3,7h_4,8h_1,8h_2,8h_3,8h_4,9h_1,9h_2,9h_3,9h_4,10h_1,10h_2,10h_3,10h_4,11h_1,11h_2,11h_3,11h_4,12h_1,12h_2,12h_3,12h_4,13h_1,13h_2,13h_3,13h_4,14h_1,14h_2,14h_3,14h_4,15h_1,15h_2,15h_3,15h_4,16h_1,16h_2,16h_3,16h_4,17h_1,17h_2,17h_3,17h_4,18h_1,18h_2,18h_3,18h_4,19h_1,19h_2,19h_3,19h_4,20h_1,20h_2,20h_3,20h_4,21h_1,21h_2,21h_3,21h_4,22h_1,22h_2,22h_3,22h_4,23h_1,23h_2,23h_3,23h_4,freeFlow
+31,"LINESTRING (-79.3522707 43.7664455, -79.3471958 43.7666118, -79.3470149 43.7666163)",Highway 401 Collectors,100,100,100,100,106,106,106,106,110,110,110,110,109,109,109,109,105,105,105,105,101,101,101,101,108,108,108,108,62,62,62,62,17,17,17,17,44,44,44,44,20,20,20,20,8,8,8,8,54,54,54,54,50,50,50,50,85,85,85,85,35,35,35,35,52,52,52,52,19,19,19,19,7,7,7,7,52,52,52,52,64,64,64,64,94,94,94,94,101,101,101,101,97,97,97,97,103,103,103,103,98
+32,"LINESTRING (-79.3470149 43.7666163, -79.3471958 43.7666118, -79.3522707 43.7664455)",Highway 401 Collectors,100,100,100,100,116,116,116,116,100,100,100,100,108,108,108,108,109,109,109,109,104,104,104,104,105,105,105,105,105,105,105,105,99,99,99,99,61,61,61,61,89,89,89,89,103,103,103,103,101,101,101,101,101,101,101,101,101,101,101,101,94,94,94,94,66,66,66,66,44,44,44,44,70,70,70,70,65,65,65,65,102,102,102,102,98,98,98,98,105,105,105,105,105,105,105,105,110,110,110,110,98
+39,"LINESTRING (-79.3536635 43.7666169, -79.349396 43.7668285, -79.3471321 43.7669408, -79.3456764 43.7670294, -79.3413567 43.7672924, -79.3358035 43.7676209)",Highway 401 Express,100,100,100,100,106,106,106,106,110,110,110,110,109,109,109,109,105,105,105,105,101,101,101,101,108,108,108,108,62,62,62,62,17,17,17,17,44,44,44,44,20,20,20,20,8,8,8,8,54,54,54,54,50,50,50,50,85,85,85,85,35,35,35,35,52,52,52,52,19,19,19,19,7,7,7,7,52,52,52,52,64,64,64,64,94,94,94,94,101,101,101,101,97,97,97,97,103,103,103,103,98
+1038,"LINESTRING (-79.3358035 43.7676209, -79.3413567 43.7672924, -79.3456764 43.7670294, -79.3471321 43.7669408, -79.349396 43.7668285, -79.3536635 43.7666169)",Highway 401 Express,100,100,100,100,116,116,116,116,100,100,100,100,108,108,108,108,109,109,109,109,104,104,104,104,105,105,105,105,105,105,105,105,99,99,99,99,61,61,61,61,89,89,89,89,103,103,103,103,101,101,101,101,101,101,101,101,101,101,101,101,94,94,94,94,66,66,66,66,44,44,44,44,70,70,70,70,65,65,65,65,102,102,102,102,98,98,98,98,105,105,105,105,105,105,105,105,110,110,110,110,98
diff --git a/web/files/swl-andorra-r5-export/edges b/web/files/swl-andorra-r5-export/edges
new file mode 100644
index 0000000000..833276db4f
Binary files /dev/null and b/web/files/swl-andorra-r5-export/edges differ
diff --git a/web/files/swl-andorra-r5-export/geometry b/web/files/swl-andorra-r5-export/geometry
new file mode 100644
index 0000000000..c416959744
Binary files /dev/null and b/web/files/swl-andorra-r5-export/geometry differ
diff --git a/web/files/swl-andorra-r5-export/location_index b/web/files/swl-andorra-r5-export/location_index
new file mode 100644
index 0000000000..cf8602bc9e
Binary files /dev/null and b/web/files/swl-andorra-r5-export/location_index differ
diff --git a/web/files/swl-andorra-r5-export/names b/web/files/swl-andorra-r5-export/names
new file mode 100644
index 0000000000..06a098874e
Binary files /dev/null and b/web/files/swl-andorra-r5-export/names differ
diff --git a/web/files/swl-andorra-r5-export/nodes b/web/files/swl-andorra-r5-export/nodes
new file mode 100644
index 0000000000..af363aecb8
Binary files /dev/null and b/web/files/swl-andorra-r5-export/nodes differ
diff --git a/web/files/swl-andorra-r5-export/nodes_ch_fastest_bike_node b/web/files/swl-andorra-r5-export/nodes_ch_fastest_bike_node
new file mode 100644
index 0000000000..8387af0f7f
Binary files /dev/null and b/web/files/swl-andorra-r5-export/nodes_ch_fastest_bike_node differ
diff --git a/web/files/swl-andorra-r5-export/nodes_ch_fastest_car_node b/web/files/swl-andorra-r5-export/nodes_ch_fastest_car_node
new file mode 100644
index 0000000000..975a0c7e91
Binary files /dev/null and b/web/files/swl-andorra-r5-export/nodes_ch_fastest_car_node differ
diff --git a/web/files/swl-andorra-r5-export/nodes_ch_fastest_foot_node b/web/files/swl-andorra-r5-export/nodes_ch_fastest_foot_node
new file mode 100644
index 0000000000..850f8233a0
Binary files /dev/null and b/web/files/swl-andorra-r5-export/nodes_ch_fastest_foot_node differ
diff --git a/web/files/swl-andorra-r5-export/properties b/web/files/swl-andorra-r5-export/properties
new file mode 100644
index 0000000000..c660faf6f4
Binary files /dev/null and b/web/files/swl-andorra-r5-export/properties differ
diff --git a/web/files/swl-andorra-r5-export/shortcuts_fastest_bike_node b/web/files/swl-andorra-r5-export/shortcuts_fastest_bike_node
new file mode 100644
index 0000000000..18a83f1804
Binary files /dev/null and b/web/files/swl-andorra-r5-export/shortcuts_fastest_bike_node differ
diff --git a/web/files/swl-andorra-r5-export/shortcuts_fastest_car_node b/web/files/swl-andorra-r5-export/shortcuts_fastest_car_node
new file mode 100644
index 0000000000..341de03744
Binary files /dev/null and b/web/files/swl-andorra-r5-export/shortcuts_fastest_car_node differ
diff --git a/web/files/swl-andorra-r5-export/shortcuts_fastest_foot_node b/web/files/swl-andorra-r5-export/shortcuts_fastest_foot_node
new file mode 100644
index 0000000000..32efb3b54a
Binary files /dev/null and b/web/files/swl-andorra-r5-export/shortcuts_fastest_foot_node differ
diff --git a/web/pom.xml b/web/pom.xml
index 50a225ee9e..7d0406c391 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -46,6 +46,12 @@
             <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest-library</artifactId>
+            <version>1.3</version>
+            <scope>test</scope>
+        </dependency>
 
         <!-- for integration tests of service -->
         <dependency>
diff --git a/web/src/test/java/com/graphhopper/swl/TDNetworkIT.java b/web/src/test/java/com/graphhopper/swl/TDNetworkIT.java
new file mode 100644
index 0000000000..a1738c5157
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/swl/TDNetworkIT.java
@@ -0,0 +1,190 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.swl;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.http.GraphHopperManaged;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.details.PathDetail;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.hamcrest.Matchers.contains;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Integration test for time-dependent edge weights.
+ * Salvaged from a client project, that's why it uses a graph that's binary-committed to the repository.
+ * TODO: Change that
+ */
+public class TDNetworkIT {
+    private GraphHopper graphHopper;
+
+    @Before
+    public void setUp() {
+        String graphFile = "files/swl-andorra-r5-export";
+        CmdArgs configuration = new CmdArgs();
+        configuration.put("r5.link_speed_file", "files/r5_predicted_tt.csv");
+        configuration.put("graph.location", graphFile);
+        configuration.put("routing.ch.disabling_allowed", true);
+        GraphHopperManaged graphHopperService = new GraphHopperManaged(configuration, Jackson.newObjectMapper());
+        graphHopperService.start();
+        this.graphHopper = graphHopperService.getGraphHopper();
+    }
+
+    @Test
+    public void testAndorraCar() {
+        GHRequest request = new GHRequest(42.56819, 1.603231, 42.571034, 1.520662);
+        request.setPathDetails(Arrays.asList("time", "edge_key"));
+        GHResponse route = graphHopper.route(request);
+
+        final int EXPECTED_LINKS_IN_PATH = 52;
+        final long EXPECTED_TOTAL_TRAVEL_TIME = 1277122;
+
+        assertEquals(21474.0, route.getBest().getDistance(), 0.1);
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, route.getBest().getTime());
+
+        List<PathDetail> time = route.getBest().getPathDetails().get("time");
+        List<PathDetail> edgeIds = route.getBest().getPathDetails().get("edge_key");
+
+        assertEquals(EXPECTED_LINKS_IN_PATH, time.size());
+        assertEquals(EXPECTED_LINKS_IN_PATH, edgeIds.size());
+
+        // Assert that corresponding elements in the two sequences of path details
+        // describe the same intervals, i.e. the 'times' are link travel times.
+        for (int i=0; i<EXPECTED_LINKS_IN_PATH; i++) {
+            assertEquals(time.get(i).getFirst(), edgeIds.get(i).getFirst());
+            assertEquals(time.get(i).getLast(), edgeIds.get(i).getLast());
+        }
+
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, sumTimes(time));
+    }
+
+    @Test
+    public void testAndorraBike() {
+        GHRequest request = new GHRequest(42.56819, 1.603231, 42.571034, 1.520662);
+        request.setPathDetails(Arrays.asList("time", "edge_key"));
+        request.setVehicle("bike");
+        GHResponse route = graphHopper.route(request);
+
+        final int EXPECTED_LINKS_IN_PATH = 52;
+        final long EXPECTED_TOTAL_TRAVEL_TIME = 4294779;
+
+        assertEquals(21474.0, route.getBest().getDistance(), 0.1);
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, route.getBest().getTime());
+
+        List<PathDetail> time = route.getBest().getPathDetails().get("time");
+        List<PathDetail> edgeIds = route.getBest().getPathDetails().get("edge_key");
+
+        assertEquals(EXPECTED_LINKS_IN_PATH, time.size());
+        assertEquals(EXPECTED_LINKS_IN_PATH, edgeIds.size());
+
+        // Assert that corresponding elements in the two sequences of path details
+        // describe the same intervals, i.e. the 'times' are link travel times.
+        for (int i=0; i<EXPECTED_LINKS_IN_PATH; i++) {
+            assertEquals(time.get(i).getFirst(), edgeIds.get(i).getFirst());
+            assertEquals(time.get(i).getLast(), edgeIds.get(i).getLast());
+        }
+
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, sumTimes(time));
+    }
+
+    @Test
+    public void testAndorraFoot() {
+        GHRequest request = new GHRequest(42.56819, 1.603231, 42.571034, 1.520662);
+        request.setPathDetails(Arrays.asList("time", "edge_key"));
+        request.setVehicle("foot");
+        GHResponse route = graphHopper.route(request);
+
+        final int EXPECTED_LINKS_IN_PATH = 45;
+        final long EXPECTED_TOTAL_TRAVEL_TIME = 11768195;
+
+        assertEquals(16344.7, route.getBest().getDistance(), 0.1);
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, route.getBest().getTime());
+
+        List<PathDetail> time = route.getBest().getPathDetails().get("time");
+        List<PathDetail> edgeIds = route.getBest().getPathDetails().get("edge_key");
+
+        assertEquals(EXPECTED_LINKS_IN_PATH, time.size());
+        assertEquals(EXPECTED_LINKS_IN_PATH, edgeIds.size());
+
+        // Assert that corresponding elements in the two sequences of path details
+        // describe the same intervals, i.e. the 'times' are link travel times.
+        for (int i=0; i<EXPECTED_LINKS_IN_PATH; i++) {
+            assertEquals(time.get(i).getFirst(), edgeIds.get(i).getFirst());
+            assertEquals(time.get(i).getLast(), edgeIds.get(i).getLast());
+        }
+
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, sumTimes(time));
+    }
+
+    @Test
+    public void testAndorraTD() {
+        GHRequest request = new GHRequest(42.56819, 1.603231, 42.571034, 1.520662);
+        request.setAlgorithm("dijkstra");
+        request.setPathDetails(Arrays.asList("edge_key"));
+        request.getHints().put("ch.disable", true);
+        request.setWeighting("td");
+        request.getHints().put("departure_time", 58*60);
+        GHResponse route = graphHopper.route(request);
+        List<PathDetail> edgeIds = route.getBest().getPathDetails().get("edge_key");
+        final long EXPECTED_TOTAL_TRAVEL_TIME = 1292346;
+
+        List<Integer> actualEdgeIds = edgeIds.stream().map(pd -> ((Integer) pd.getValue())).collect(Collectors.toList());
+        assertThat(actualEdgeIds, contains(4340, 31, 32, 39, 1036, 1030, 1603, 1601, 1599, 71, 69, 4315, 1589, 1587, 1585, 1583, 1581, 1579, 1577, 1575, 1551, 1549, 1547, 1545, 2371, 3439, 3437, 3391, 1381, 1379, 1377, 581, 579, 577, 575, 573, 571, 569, 558, 560, 562, 552, 566, 540, 550, 2506, 1916, 1816, 1814, 1720, 1722, 1724));
+
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, route.getBest().getTime());
+    }
+
+    @Test
+    public void testAndorraTDLater() {
+        GHRequest request = new GHRequest(42.56819, 1.603231, 42.571034, 1.520662);
+        request.setAlgorithm("dijkstra");
+        request.setPathDetails(Arrays.asList("edge_key"));
+        request.getHints().put("ch.disable", true);
+        request.setWeighting("td");
+        request.getHints().put("departure_time", 8*60*60);
+        GHResponse route = graphHopper.route(request);
+        List<PathDetail> edgeIds = route.getBest().getPathDetails().get("edge_key");
+
+        // During the morning peak, we choose a different route (and it is slower)
+        final long EXPECTED_TOTAL_TRAVEL_TIME = 1386129;
+        List<Integer> actualEdgeIds = edgeIds.stream().map(pd -> ((Integer) pd.getValue())).collect(Collectors.toList());
+        assertThat(actualEdgeIds, contains(4340, 31, 32, 34, 1038, 1040, 1018, 1023, 1061, 1059, 1029, 5609, 1601, 1599, 71, 69, 4315, 1589, 1587, 1585, 1583, 1581, 1579, 1577, 1575, 1551, 1549, 1547, 1545, 2371, 3439, 3437, 3391, 1381, 1379, 1377, 581, 579, 577, 575, 573, 571, 569, 558, 560, 562, 552, 566, 540, 550, 2506, 1916, 1816, 1814, 1720, 1722, 1724));
+
+        assertEquals(EXPECTED_TOTAL_TRAVEL_TIME, route.getBest().getTime());
+    }
+
+
+    private long sumTimes(List<PathDetail> time) {
+        long sum = 0;
+        for (PathDetail pathDetail : time) {
+            sum += (long) pathDetail.getValue();
+        }
+        return sum;
+    }
+
+}
