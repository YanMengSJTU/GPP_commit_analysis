diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 539bfe05b4..d9b7a0edc5 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1055,6 +1055,10 @@ public GHResponse route( GHRequest request )
 
             sw = new StopWatch().start();
             Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
+
+            //Update time to profile of user
+            path.updateTime();
+
             if (path.getTime() < 0)
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
 
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 8cfe8ee8a5..a01fe3db18 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,7 +17,9 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.BikeGenericFlagEncoder;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.DynamicWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -29,6 +31,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.graphhopper.util.Helper.keepIn;
+
 /**
  * Stores the nodes for the found path of an algorithm. It additionally needs the edgeIds to make
  * edge determination faster and less complex as there could be several edges (u,v) especially for
@@ -239,6 +243,8 @@ protected long calcMillis( double distance, long flags, boolean revert )
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
                     + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
 
+        System.out.println(revert);
+
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
             throw new IllegalStateException("Invalid speed stored in edge! " + speed);
@@ -364,6 +370,71 @@ public void next( EdgeIteratorState eb, int index )
         return points;
     }
 
+    public void updateTime(){
+
+        time = 0;
+
+        forEveryEdge(new EdgeVisitor() {
+
+            @Override
+            public void next(EdgeIteratorState edgeBase, int index) {
+
+                double speed = encoder.getSpeed(edgeBase.getFlags());
+
+                if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+                    throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+
+                if (speed == 0)
+                    throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
+
+                speed = adjustSpeed(speed, edgeBase, false);
+
+                double edgeTime = edgeBase.getDistance() / speed * 3600;
+
+                // add direction penalties at start/stop/via points
+                boolean penalizeEdge = edgeBase.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, false);
+                if (penalizeEdge)
+                    edgeTime += 300; //pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
+
+                time += edgeTime;
+            }
+        });
+
+    }
+
+    private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean reverse) {
+
+        double incElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY) / 100;
+        double decElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY) / 100;
+        double incDistPercentage = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
+
+
+        double incDist2DSum = edgeState.getDistance() * incDistPercentage;
+        double decDist2DSum = edgeState.getDistance() - incDist2DSum;
+
+        double adjustedSpeed = speed;
+
+        if (!reverse)
+        {
+            // use weighted mean so that longer incline infuences speed more than shorter
+            double fwdFaster = 1 + 2 * keepIn(decElevation, 0, 0.2);
+            fwdFaster = fwdFaster * fwdFaster;
+            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
+            fwdSlower = fwdSlower * fwdSlower;
+            adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+        } else {
+            double fwdFaster = 1 + 2 * keepIn(incElevation, 0, 0.2);
+            fwdFaster = fwdFaster * fwdFaster;
+            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
+            fwdSlower = fwdSlower * fwdSlower;
+            adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+        }
+        System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation + ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage);
+
+        return adjustedSpeed;
+    }
+
     /**
      * @return the list of instructions for this path.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
index 3271a23a07..c9d1c714e8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
@@ -38,7 +38,7 @@
     /**
      * Reports wether this edge is unpaved.
      */
-    protected static final int PUSHING_SECTION_SPEED = 4;
+    public static final int PUSHING_SECTION_SPEED = 4;
     // Pushing section highways are parts where you need to get off your bike and push it (German: Schiebestrecke)
     protected final HashSet<String> pushingSections = new HashSet<String>();
     protected final HashSet<String> oppositeLanes = new HashSet<String>();
@@ -707,11 +707,14 @@ public void applyWayTags(OSMWay way, EdgeIteratorState edge) {
             // Then calculate a factor which decreases or increases the speed.
             // Do this via a simple quadratic equation where y(0)=1 and y(0.3)=1/4 for incline and y(0.3)=2 for decline
 
-            fwdIncline = incDist2DSum > 1 ? incEleSum / incDist2DSum : 0;
-            fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
+            fwdIncline = incDist2DSum > 1 ? (incEleSum / incDist2DSum) * 100 : 0;
+            fwdDecline = decDist2DSum > 1 ? (decEleSum / decDist2DSum) * 100 : 0;
             inclineDistancePercentage = keepIn(incDist2DSum / fullDist2D * 100, 0, 100);
         }
 
+        fwdIncline = fwdIncline > 40 ? 40 : fwdIncline;
+        fwdDecline = fwdDecline > 40 ? 40 : fwdDecline;
+
         flags = inclineSlopeEncoder.setDoubleValue(flags, fwdIncline);
         flags = declineSlopeEncoder.setDoubleValue(flags, fwdDecline);
         flags = inclineDistancePercentageEncoder.setDoubleValue(flags, inclineDistancePercentage);
diff --git a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
index e20cfcb930..c40ab54386 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
@@ -19,6 +19,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 
 import static com.graphhopper.util.Helper.keepIn;
@@ -83,11 +84,12 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
 
     private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean reverse) {
 
-        double incElevation = flagEncoder.getDouble(edgeState.getFlags(), INC_SLOPE_KEY);
-        double decElevation = flagEncoder.getDouble(edgeState.getFlags(), DEC_SLOPE_KEY);
-        double incDistPercentage = flagEncoder.getDouble(edgeState.getFlags(), INC_DIST_PERCENTAGE_KEY);
+        double incElevation = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY) / 100;
+        double decElevation = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY) / 100;
+        double incDistPercentage = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
 
-        double incDist2DSum = edgeState.getDistance() * incDistPercentage / 100;
+
+        double incDist2DSum = edgeState.getDistance() * incDistPercentage;
         double decDist2DSum = edgeState.getDistance() - incDist2DSum;
 
         double adjustedSpeed = speed;
@@ -95,19 +97,21 @@ private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean re
         if (!reverse)
         {
             // use weighted mean so that longer incline infuences speed more than shorter
-            double fwdFaster = 1 + 2 * keepIn(incElevation, 0, 0.4);
+            double fwdFaster = 1 + 2 * keepIn(decElevation, 0, 0.2);
             fwdFaster = fwdFaster * fwdFaster;
-            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.4);
+            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance();
+            adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         } else {
-            double fwdFaster = 1 + 2 * keepIn(decElevation, 0, 0.4);
+            double fwdFaster = 1 + 2 * keepIn(incElevation, 0, 0.2);
             fwdFaster = fwdFaster * fwdFaster;
-            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.4);
+            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance();
+            adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         }
 
+        System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation + ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage);
+
         return adjustedSpeed;
     }
 
