diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 5f190a8b43..e11a5f8c5f 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1100,7 +1100,7 @@ else if (Parameters.Algorithms.REAL_DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoSt
 					queryGraph = new QueryGraph(ghStorage.getGraph(CHGraph.class, weighting));
 					queryGraph.lookup(qResults);
 				} else {
-					checkNonChMaxWaypointDistance(points);
+					// checkNonChMaxWaypointDistance(points);
 					queryGraph = new QueryGraph(ghStorage);
 					queryGraph.lookup(qResults);
 					weighting = createWeighting(hints, encoder, queryGraph);
diff --git a/core/src/main/java/com/graphhopper/routing/template/OneToManyRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/OneToManyRoutingTemplate.java
index 74da3cea66..9cfb682bb3 100644
--- a/core/src/main/java/com/graphhopper/routing/template/OneToManyRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/OneToManyRoutingTemplate.java
@@ -71,6 +71,11 @@ public OneToManyRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationI
 			GHPoint point = points.get(placeIndex);
 			QueryResult res = cache.get(point);
 
+			// clear the cache before it gets too big
+			if (cache.size() > 100000) {
+				cache.clear();
+			}
+
 			if (res == null) {
 				res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
 				cache.put(point, res);
@@ -93,20 +98,32 @@ public OneToManyRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationI
 		for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
 			QueryResult toQResult = queryResults.get(placeIndex);
 
-			if (!toQResult.isValid())
-				continue;
-
-			List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
-			if (tmpPathList.isEmpty())
-				throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
-
-			int idx = 0;
-			for (Path path : tmpPathList) {
-				if (path.getTime() < 0)
-					throw new RuntimeException("Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + ghRequest);
-
+			if (toQResult.isValid()) {
+				try {
+					List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+					if (tmpPathList.isEmpty())
+						throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
+
+					int idx = 0;
+					for (Path path : tmpPathList) {
+						if (path.getTime() < 0)
+							throw new RuntimeException(
+									"Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + ghRequest);
+
+						pathList.add(path);
+						idx++;
+					}
+				} catch (Exception e) {
+					Path path = new Path(queryGraph, algoOpts.getWeighting());
+					path.setDistance(10000000);
+					path.setFound(true);
+					pathList.add(path);
+				}
+			} else {
+				Path path = new Path(queryGraph, algoOpts.getWeighting());
+				path.setDistance(10000000);
+				path.setFound(true);
 				pathList.add(path);
-				idx++;
 			}
 
 
