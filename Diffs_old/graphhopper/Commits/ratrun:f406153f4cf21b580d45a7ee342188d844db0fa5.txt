diff --git a/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java b/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java
deleted file mode 100644
index 941956737f..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wrapper class for the {@link Polygon}.
- */
-public class GeoJsonPolygon implements Geometry {
-
-    private List<Polygon> polygons = new ArrayList<>();
-
-    @Override
-    public String getType() {
-        return "Polygon";
-    }
-
-    @Override
-    public boolean isPoint() {
-        return false;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPointList() {
-        return false;
-    }
-
-    @Override
-    public PointList asPointList() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return true;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        return this;
-    }
-
-    public List<Polygon> getPolygons() {
-        return polygons;
-    }
-
-    public GeoJsonPolygon addPolygon(Polygon polygon) {
-        this.polygons.add(polygon);
-        return this;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java b/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
index 28ab5f7c10..1f0bc9c770 100644
--- a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
+++ b/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
@@ -17,7 +17,10 @@
  */
 package com.graphhopper.json.geo;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.util.shapes.BBox;
+import com.vividsolutions.jts.geom.Geometry;
 
 import java.util.Map;
 
@@ -33,7 +36,8 @@
     final Geometry geometry;
     final Map<String, Object> properties;
 
-    public JsonFeature(String id, String type, BBox bbox, Geometry geometry, Map<String, Object> properties) {
+    @JsonCreator
+    public JsonFeature(@JsonProperty("id") String id, @JsonProperty("type") String type, @JsonProperty("bbox") BBox bbox, @JsonProperty("geometry") Geometry geometry, @JsonProperty("properties") Map<String, Object> properties) {
         this.id = id;
         this.type = type;
         this.bbox = bbox;
diff --git a/core/src/main/java/com/graphhopper/json/geo/LineString.java b/core/src/main/java/com/graphhopper/json/geo/LineString.java
deleted file mode 100644
index 5fb69389b9..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/LineString.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * Wrapper to read a PointList easily from GeoJSON (type=LineString)
- *
- * @author Peter Karich
- */
-public class LineString extends PointList implements Geometry {
-    public LineString(int size, boolean is3D) {
-        super(size, is3D);
-    }
-
-    @Override
-    public String getType() {
-        return "LineString";
-    }
-
-    @Override
-    public boolean isPoint() {
-        return false;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPointList() {
-        return true;
-    }
-
-    @Override
-    public PointList asPointList() {
-        return this;
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return false;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/Point.java b/core/src/main/java/com/graphhopper/json/geo/Point.java
deleted file mode 100644
index ea75ca8c3b..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/Point.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
-
-/**
- * Wrapper to read a GHPoint3D easily from GeoJSON (type=Point)
- *
- * @author Peter Karich
- */
-public class Point extends GHPoint3D implements Geometry {
-    public Point(double lat, double lon) {
-        super(lat, lon, Double.NaN);
-    }
-
-    public Point(double lat, double lon, double ele) {
-        super(lat, lon, ele);
-    }
-
-    @Override
-    public String toString() {
-        return lat + ", " + lon;
-    }
-
-    @Override
-    public boolean isPoint() {
-        return true;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        return this;
-    }
-
-    @Override
-    public boolean isPointList() {
-        return false;
-    }
-
-    @Override
-    public PointList asPointList() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return false;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public String getType() {
-        return "Point";
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index 61fcdb49a4..b1c2ef20d2 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.coll.GHIntHashSet;
-import com.graphhopper.json.geo.Geometry;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.storage.index.LocationIndex;
@@ -34,6 +33,7 @@
 import com.graphhopper.util.shapes.Circle;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Shape;
+import com.vividsolutions.jts.geom.*;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -110,23 +110,21 @@ protected boolean checkAdjacent(EdgeIteratorState edge) {
      * This method fills the edgeIds hash with edgeIds found inside the specified geometry
      */
     public void fillEdgeIDs(GHIntHashSet edgeIds, Geometry geometry, EdgeFilter filter) {
-        if (geometry.isPoint()) {
-            GHPoint point = geometry.asPoint();
+        if (geometry instanceof Point) {
+            GHPoint point = GHPoint.from((Point) geometry);
             findClosestEdgeToPoint(edgeIds, point, filter);
-        } else if (geometry.isPointList()) {
-            PointList pl = geometry.asPointList();
-            if (geometry.getType().equals("LineString")) {
-                // TODO do map matching or routing
-                int lastIdx = pl.size() - 1;
-                if (pl.size() >= 2) {
-                    double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;
-                    double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;
-                    findClosestEdge(edgeIds, meanLat, meanLon, filter);
-                }
-            } else {
-                for (int i = 0; i < pl.size(); i++) {
-                    findClosestEdge(edgeIds, pl.getLatitude(i), pl.getLongitude(i), filter);
-                }
+        } else if (geometry instanceof LineString) {
+            PointList pl = PointList.from((LineString) geometry);
+            // TODO do map matching or routing
+            int lastIdx = pl.size() - 1;
+            if (pl.size() >= 2) {
+                double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;
+                double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;
+                findClosestEdge(edgeIds, meanLat, meanLon, filter);
+            }
+        } else if (geometry instanceof MultiPoint) {
+            for (Coordinate coordinate : geometry.getCoordinates()) {
+                findClosestEdge(edgeIds, coordinate.y, coordinate.x, filter);
             }
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 049bfbb46c..112c7cfac4 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.LineString;
 
 import java.util.*;
 
@@ -522,4 +524,12 @@ public void remove() {
             }
         };
     }
+
+    public static PointList from(LineString lineString) {
+        final PointList pointList = new PointList();
+        for (Coordinate coordinate : lineString.getCoordinates()) {
+            pointList.add(new GHPoint(coordinate.y, coordinate.x));
+        }
+        return pointList;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 6919569073..ec79a7c0bc 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
 
@@ -45,6 +46,11 @@
     public double minEle;
     public double maxEle;
 
+    @JsonCreator
+    public BBox(double[] coords) {
+        this(coords[0],coords[2],coords[1],coords[3]);
+    }
+
     public BBox(double minLon, double maxLon, double minLat, double maxLat) {
         this(minLon, maxLon, minLat, maxLat, Double.NaN, Double.NaN, false);
     }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index e51f9d4e73..9d2c2257ba 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.NumHelper;
+import com.vividsolutions.jts.geom.Point;
 
 /**
  * @author Peter Karich
@@ -99,4 +100,8 @@ public String toString() {
     public Double[] toGeoJson() {
         return new Double[]{lon, lat};
     }
+
+    public static GHPoint from(Point point) {
+        return new GHPoint(point.getY(), point.getX());
+    }
 }
diff --git a/reader-json/pom.xml b/reader-json/pom.xml
index ded5652871..e3288a3817 100644
--- a/reader-json/pom.xml
+++ b/reader-json/pom.xml
@@ -22,14 +22,15 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.google.code.gson</groupId>
-            <artifactId>gson</artifactId>
-            <version>2.8.0</version>
-            <!-- in the future make implementation optional
-                 <scope>provided</scope>
-            -->
-        </dependency> 
-        
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.bedatadriven</groupId>
+            <artifactId>jackson-datatype-jts</artifactId>
+            <version>2.4</version>
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
diff --git a/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java b/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java
deleted file mode 100644
index a0dd19c174..0000000000
--- a/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import com.graphhopper.json.geo.*;
-import com.google.gson.*;
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.shapes.BBox;
-
-import java.lang.reflect.Type;
-import java.util.Map;
-import java.util.UUID;
-
-/**
- * This class makes reading the different geometry types possible for Gson.
- *
- * @author Peter Karich
- */
-public class FeatureJsonDeserializer implements JsonDeserializer<JsonFeature> {
-    @Override
-    public JsonFeature deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException {
-        try {
-            JsonObject obj = json.getAsJsonObject();
-            String id, strType = null;
-            Map<String, Object> properties = null;
-            BBox bbox = null;
-            Geometry geometry = null;
-
-            // TODO ensure uniqueness
-            if (obj.has("id"))
-                id = obj.get("id").getAsString();
-            else
-                id = UUID.randomUUID().toString();
-
-            if (obj.has("properties")) {
-                properties = context.deserialize(obj.get("properties"), Map.class);
-            }
-
-            if (obj.has("bbox"))
-                bbox = parseBBox(obj.get("bbox").getAsJsonArray());
-
-            if (obj.has("geometry")) {
-                JsonObject geometryJson = obj.get("geometry").getAsJsonObject();
-
-                if (geometryJson.has("coordinates")) {
-                    if (!geometryJson.has("type"))
-                        throw new IllegalArgumentException("No type for non-empty coordinates specified");
-
-                    strType = context.deserialize(geometryJson.get("type"), String.class);
-                    if ("Point".equals(strType)) {
-                        JsonArray arr = geometryJson.get("coordinates").getAsJsonArray();
-                        double lon = arr.get(0).getAsDouble();
-                        double lat = arr.get(1).getAsDouble();
-                        if (arr.size() == 3)
-                            geometry = new Point(lat, lon, arr.get(2).getAsDouble());
-                        else
-                            geometry = new Point(lat, lon);
-
-                    } else if ("MultiPoint".equals(strType)) {
-                        geometry = parseLineString(geometryJson);
-
-                    } else if ("LineString".equals(strType)) {
-                        geometry = parseLineString(geometryJson);
-
-                    } else if ("Polygon".equals(strType)) {
-                        geometry = parsePolygonString(geometryJson);
-                    } else if ("MultiPolygon".equals(strType)) {
-                        geometry = parsePolygonString(geometryJson);
-                    } else {
-                        throw new IllegalArgumentException("Coordinates type " + strType + " not yet supported");
-                    }
-                }
-            }
-
-            return new JsonFeature(id, strType, bbox, geometry, properties);
-
-        } catch (Exception ex) {
-            throw new JsonParseException("Problem parsing JSON feature " + json, ex);
-        }
-    }
-
-    LineString parseLineString(JsonObject geometry) {
-        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
-        boolean is3D = arr.size() == 0 || arr.get(0).getAsJsonArray().size() == 3;
-        LineString lineString = new LineString(arr.size(), is3D);
-
-        for (int i = 0; i < arr.size(); i++) {
-            JsonArray pointArr = arr.get(i).getAsJsonArray();
-            double lon = pointArr.get(0).getAsDouble();
-            double lat = pointArr.get(1).getAsDouble();
-            if (pointArr.size() == 3)
-                lineString.add(lat, lon, pointArr.get(2).getAsDouble());
-            else
-                lineString.add(lat, lon);
-        }
-        return lineString;
-    }
-
-    GeoJsonPolygon parsePolygonString(JsonObject geometry) {
-        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
-        GeoJsonPolygon geoJsonPolygon = new GeoJsonPolygon();
-
-        if (geometry.get("type").getAsString().equals("Polygon")) {
-            geoJsonPolygon.addPolygon(parseSinglePolygonCoordinates(arr));
-        } else {
-            for (int i = 0; i < arr.size(); i++) {
-                geoJsonPolygon.addPolygon(parseSinglePolygonCoordinates(arr.get(i).getAsJsonArray()));
-            }
-        }
-        return geoJsonPolygon;
-    }
-
-    private Polygon parseSinglePolygonCoordinates(JsonArray arr) {
-        if (arr.size() == 0) {
-            throw new IllegalStateException("The passed Array should be of format: [[[coords1],[coords2],....[coordsN]]]");
-        }
-        /*
-         TODO We currently ignore holes/interior rings the spec defines:
-        For type "Polygon", the "coordinates" member must be an array of LinearRing coordinate arrays.
-        For Polygons with multiple rings, the first must be the exterior ring and any others must be
-        interior rings or holes.
-         */
-        JsonArray polygonArr = arr.get(0).getAsJsonArray();
-
-        double[] lats = new double[polygonArr.size()];
-        double[] lons = new double[polygonArr.size()];
-
-        for (int i = 0; i < polygonArr.size(); i++) {
-            JsonArray pointArr = polygonArr.get(i).getAsJsonArray();
-            lons[i] = pointArr.get(0).getAsDouble();
-            lats[i] = pointArr.get(1).getAsDouble();
-        }
-
-        return new Polygon(lats, lons);
-    }
-
-    private BBox parseBBox(JsonArray arr) {
-        // The value of the bbox member must be a 2*n array where n is the number of dimensions represented 
-        // in the contained geometries, with the lowest values for all axes followed by the highest values. 
-        // The axes order of a bbox follows the axes order of geometries => lon,lat,ele
-        if (arr.size() == 6) {
-            double minLon = arr.get(0).getAsDouble();
-            double minLat = arr.get(1).getAsDouble();
-            double minEle = arr.get(2).getAsDouble();
-
-            double maxLon = arr.get(3).getAsDouble();
-            double maxLat = arr.get(4).getAsDouble();
-            double maxEle = arr.get(5).getAsDouble();
-
-            return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle);
-
-        } else if (arr.size() == 4) {
-            double minLon = arr.get(0).getAsDouble();
-            double minLat = arr.get(1).getAsDouble();
-
-            double maxLon = arr.get(2).getAsDouble();
-            double maxLat = arr.get(3).getAsDouble();
-
-            return new BBox(minLon, maxLon, minLat, maxLat);
-        } else {
-            throw new IllegalArgumentException("Illegal array dimension (" + arr.size() + ") of bbox " + arr.toString());
-        }
-    }
-}
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java
deleted file mode 100644
index dcd28becda..0000000000
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import com.graphhopper.json.geo.JsonFeature;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-
-/**
- * This class wraps the creation of the specific GHJson implementation.
- *
- * @author Peter Karich
- */
-public class GHJsonBuilder {
-    public GHJson create() {
-        // for now always return Gson implementation        
-        Gson gson = new GsonBuilder()
-                .disableHtmlEscaping()
-                .registerTypeHierarchyAdapter(JsonFeature.class, new FeatureJsonDeserializer())
-                .create();
-        // for geojson we could rely on external libs instead of inventing our own:
-        // https://github.com/filosganga/geogson or https://github.com/3sidedcube/Android-GeoGson
-
-        return new GHJsonGson(gson);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/Geometry.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/json/geo/Geometry.java
rename to reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
index 474f44fd3d..ef265e4adb 100644
--- a/core/src/main/java/com/graphhopper/json/geo/Geometry.java
+++ b/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
@@ -15,29 +15,20 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.json.geo;
+package com.graphhopper.json;
 
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
+import com.bedatadriven.jackson.datatype.jts.JtsModule;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
 /**
- * This interface is used to define an area or location in geojson format.
+ * This class wraps the creation of the specific GHJson implementation.
  *
  * @author Peter Karich
  */
-public interface Geometry {
-    String getType();
-
-    boolean isPoint();
-
-    GHPoint asPoint();
-
-    boolean isPointList();
-
-    PointList asPointList();
-
-    boolean isPolygon();
-
-    GeoJsonPolygon asPolygon();
+public class GHJsonFactory {
+    public GHJson create() {
+        ObjectMapper gson = new ObjectMapper();
+        gson.registerModule(new JtsModule());
+        return new GHJsonJackson(gson);
+    }
 }
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
similarity index 73%
rename from reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java
rename to reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
index 3714e3341a..83f621d97b 100644
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java
+++ b/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
@@ -17,22 +17,24 @@
  */
 package com.graphhopper.json;
 
-import com.google.gson.Gson;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
+import java.io.IOException;
 import java.io.Reader;
 
-/**
- * @author Peter Karich
- */
-public class GHJsonGson implements GHJson {
-    private final Gson gson;
+class GHJsonJackson implements GHJson {
+    private final ObjectMapper gson;
 
-    public GHJsonGson(Gson gson) {
+    GHJsonJackson(ObjectMapper gson) {
         this.gson = gson;
     }
 
     @Override
     public <T> T fromJson(Reader source, Class<T> aClass) {
-        return gson.fromJson(source, aClass);
+        try {
+            return gson.readValue(source, aClass);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 }
diff --git a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
index 76e9610970..96f8738cb2 100644
--- a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
+++ b/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
@@ -18,8 +18,10 @@
 package com.graphhopper.json.geo;
 
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.vividsolutions.jts.geom.LineString;
 import org.junit.Test;
 
 import java.io.InputStreamReader;
@@ -32,7 +34,7 @@
  * @author Peter Karich
  */
 public class JsonFeatureCollectionTest {
-    private final GHJson ghson = new GHJsonBuilder().create();
+    private final GHJson ghson = new GHJsonFactory().create();
 
     @Test
     public void testDeserialization() {
@@ -42,17 +44,17 @@ public void testDeserialization() {
         JsonFeature f1 = data.getFeatures().get(0);
         assertEquals("1", f1.getId());
         assertEquals("value0", f1.getProperty("prop0"));
-        assertEquals(0.5, f1.getGeometry().asPoint().lat, .1);
-        assertEquals(102.0, f1.getGeometry().asPoint().lon, .1);
+        assertEquals(0.5, f1.getGeometry().getCoordinate().y, .1);
+        assertEquals(102.0, f1.getGeometry().getCoordinate().x, .1);
 
         JsonFeature f2 = data.getFeatures().get(1);
         // read as string despite the 2 (not a string) in json
         assertEquals("2", f2.getId());
-        assertEquals(4, f2.getGeometry().asPointList().size());
-        assertEquals(0.0, f2.getGeometry().asPointList().getLat(0), .1);
-        assertEquals(102.0, f2.getGeometry().asPointList().getLon(0), .1);
-        assertEquals(1.0, f2.getGeometry().asPointList().getLat(1), .1);
-        assertEquals(103.0, f2.getGeometry().asPointList().getLon(1), .1);
+        assertEquals(4, f2.getGeometry().getNumPoints());
+        assertEquals(0.0, PointList.from((LineString) f2.getGeometry()).getLat(0), .1);
+        assertEquals(102.0, PointList.from((LineString) f2.getGeometry()).getLon(0), .1);
+        assertEquals(1.0, PointList.from((LineString) f2.getGeometry()).getLat(1), .1);
+        assertEquals(103.0, PointList.from((LineString) f2.getGeometry()).getLon(1), .1);
 
         JsonFeature f3 = data.getFeatures().get(2);
         assertEquals("0.0,102.0,1.0,103.0", f3.getBBox().toString());
diff --git a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index 5e786563e4..a3d9bade0a 100644
--- a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -1,7 +1,7 @@
 package com.graphhopper.storage.change;
 
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.JsonFeatureConverter;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.AllEdgesIterator;
@@ -34,7 +34,7 @@
     public void setUp() {
         encodingManager = new EncodingManager("car");
         graph = new GraphBuilder(encodingManager).create();
-        ghson = new GHJsonBuilder().create();
+        ghson = new GHJsonFactory().create();
     }
 
     @Test
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index bc2c3db0d2..e317a7f85d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -24,7 +24,7 @@
 import com.graphhopper.spatialrules.CountriesSpatialRuleFactory;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.lm.LandmarkStorage;
@@ -66,7 +66,7 @@ public GraphHopperModule(CmdArgs args) {
     @Override
     protected void configure() {
         install(new CmdArgsModule(args));
-        bind(GHJson.class).toInstance(new GHJsonBuilder().create());
+        bind(GHJson.class).toInstance(new GHJsonFactory().create());
         bind(GraphHopperAPI.class).to(GraphHopper.class);
     }
 
@@ -82,7 +82,7 @@ protected void loadOrPrepareLM() {
                 try {
                     String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
                     Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
-                    JsonFeatureCollection jsonFeatureCollection = new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class);
+                    JsonFeatureCollection jsonFeatureCollection = new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
                     if (!jsonFeatureCollection.getFeatures().isEmpty()) {
                         SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "country", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
                             @Override
@@ -115,7 +115,7 @@ public String getId() {
             try {
                 final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
                 final FileReader reader = new FileReader(spatialRuleLocation);
-                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), maxBounds);
+                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), maxBounds);
                 logger.info("Set spatial rule lookup with " + index.size() + " rules");
                 final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
                 graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
diff --git a/web/src/main/java/com/graphhopper/http/PtModule.java b/web/src/main/java/com/graphhopper/http/PtModule.java
index 2f33966b9d..3eac109084 100644
--- a/web/src/main/java/com/graphhopper/http/PtModule.java
+++ b/web/src/main/java/com/graphhopper/http/PtModule.java
@@ -4,7 +4,7 @@
 import com.google.inject.Provides;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
@@ -32,7 +32,7 @@ public PtModule(CmdArgs args) {
     @Override
     protected void configure() {
         install(new CmdArgsModule(args));
-        bind(GHJson.class).toInstance(new GHJsonBuilder().create());
+        bind(GHJson.class).toInstance(new GHJsonFactory().create());
     }
 
     @Provides
diff --git a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
index cccb0a3d5a..a0d387b164 100644
--- a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
+++ b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
@@ -40,7 +40,10 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
         List<SpatialRule> spatialRules = new ArrayList<>();
         for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
             String id = (String) jsonFeature.getProperty(jsonIdField);
-            List<Polygon> borders = jsonFeature.getGeometry().asPolygon().getPolygons();
+            List<Polygon> borders = new ArrayList<>();
+            for (int i=0; i<jsonFeature.getGeometry().getNumGeometries(); i++) {
+                borders.add(ghPolygonFromJTS((com.vividsolutions.jts.geom.Polygon) jsonFeature.getGeometry().getGeometryN(i)));
+            }
             SpatialRule spatialRule = spatialRuleFactory.createSpatialRule(id, borders);
             if (spatialRule != SpatialRule.EMPTY) {
                 spatialRules.add(spatialRule);
@@ -74,4 +77,14 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
         return buildIndex(jsonFeatureCollection, jsonIdField, spatialRuleFactory, new BBox(-180, 180, -90, 90));
     }
 
+    private static Polygon ghPolygonFromJTS(com.vividsolutions.jts.geom.Polygon polygon) {
+        double[] lats = new double[polygon.getNumPoints()];
+        double[] lons = new double[polygon.getNumPoints()];
+        for (int i=0; i<polygon.getNumPoints(); i++) {
+            lats[i] = polygon.getCoordinates()[i].y;
+            lons[i] = polygon.getCoordinates()[i].x;
+        }
+        return new Polygon(lats, lons);
+    }
+
 }
diff --git a/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java b/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
index 8cbe1076fe..5524771b1c 100644
--- a/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
@@ -66,17 +66,17 @@ public void testBlockAccessViaPoint() throws Exception {
 
         // block road
         String geoJson = "{"
-                + "'type': 'FeatureCollection',"
-                + "'features': [{"
-                + "  'type': 'Feature',"
-                + "  'geometry': {"
-                + "    'type': 'Point',"
-                + "    'coordinates': [1.521692, 42.522969]"
+                + "\"type\": \"FeatureCollection\","
+                + "\"features\": [{"
+                + "  \"type\": \"Feature\","
+                + "  \"geometry\": {"
+                + "    \"type\": \"Point\","
+                + "    \"coordinates\": [1.521692, 42.522969]"
                 + "  },"
-                + "  'properties': {"
-                + "    'vehicles': ['car'],"
-                + "    'access': false"
-                + "  }}]}".replaceAll("'", "\"");
+                + "  \"properties\": {"
+                + "    \"vehicles\": [\"car\"],"
+                + "    \"access\": false"
+                + "  }}]}";
         String res = post("/change", 200, geoJson);
         JsonNode jsonObj = objectMapper.readTree(res);
         assertEquals(1, jsonObj.get("updates").asInt());
diff --git a/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
index 78bbd010ba..24f2fef903 100644
--- a/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
+++ b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.spatialrules;
 
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.util.spatialrules.AccessValue;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
@@ -41,7 +41,7 @@
     @Test
     public void testIndex() {
         Reader reader = new InputStreamReader(CountriesSpatialRuleFactory.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
 
         // Berlin
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
@@ -60,7 +60,7 @@ public void testIndex() {
     @Test
     public void testBounds() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, 180, -90, 90));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, 180, -90, 90));
         BBox almostWorldWide = new BBox(-179, 179, -89, 89);
 
         // Might fail if a polygon is defined outside the above coordinates
@@ -74,14 +74,14 @@ public void testIntersection() {
              So the BBox should not contain a Point lying somewhere close in Germany.
           */
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(9, 10, 51, 52));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(9, 10, 51, 52));
         assertFalse("BBox seems to be incorrectly contracted", spatialRuleLookup.getBounds().contains(49.9, 8.9));
     }
 
     @Test
     public void testNoIntersection() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, -179, -90, -89));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, -179, -90, -89));
         assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
 
