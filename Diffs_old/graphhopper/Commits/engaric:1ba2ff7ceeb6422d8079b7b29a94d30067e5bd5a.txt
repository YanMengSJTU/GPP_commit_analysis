diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
index 7dfd9d4a00..c23f4b43c2 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
@@ -32,8 +32,12 @@
 import com.graphhopper.reader.RelationMember;
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
+import com.graphhopper.reader.Way;
 import com.graphhopper.reader.osgb.AbstractOsReader;
 import com.graphhopper.reader.osgb.itn.OSITNTurnRelation;
+import com.graphhopper.routing.util.EncoderDecorator;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.DistanceCalc;
@@ -356,7 +360,7 @@ void processWay(OsDpnWay way) {
         long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
         if (wayFlags == 0)
             return;
-
+       
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         // look for barriers along the way
         final int size = osmNodeIds.size();
@@ -414,10 +418,33 @@ void processWay(OsDpnWay way) {
             createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
         }
 
-        for (EdgeIteratorState edge : createdEdges) {
+        long configureEdgeAvoidance = configureEdgeAvoidance(way);
+        applyAvoidanceAttributes(way, createdEdges, configureEdgeAvoidance);
+    }
+
+	private void applyAvoidanceAttributes(OsDpnWay way, List<EdgeIteratorState> createdEdges,
+			long configureEdgeAvoidance) {
+		for (EdgeIteratorState edge : createdEdges) {
             encodingManager.applyWayTags(way, edge);
+            if(0<configureEdgeAvoidance) {
+            	AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension)graphStorage.getExtension();
+            	avoidanceExtension.addEdgeInfo(edge.getEdge(), edge.getAdjNode(), configureEdgeAvoidance);
+            }
         }
-    }
+	}
+
+	private long configureEdgeAvoidance(Way way) {
+		 GraphExtension extendedStorage = graphStorage.getExtension();
+		 long handleWayTags=0;
+         if (extendedStorage instanceof AvoidanceAttributeExtension)
+         {
+        	 List<EncoderDecorator> decorators = encodingManager.getDecorators();
+        	 for (EncoderDecorator encoderDecorator : decorators) {
+        		 handleWayTags += encoderDecorator.handleWayTags(way);
+        	 }
+         }
+         return handleWayTags;
+	}
 
     public void processRelation(Relation relation) throws XMLStreamException {
         // if (relation.hasTag("type", "restriction")) {
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 793fc153c2..4158f43850 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -21,10 +21,13 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
+
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -54,6 +57,7 @@
     private TIntList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
+	private GraphExtension extraInfo;
 
     public Path( Graph graph, FlagEncoder encoder )
     {
@@ -62,6 +66,7 @@ public Path( Graph graph, FlagEncoder encoder )
         this.nodeAccess = graph.getNodeAccess();
         this.encoder = encoder;
         this.edgeIds = new TIntArrayList();
+        this.extraInfo = graph.getExtension();
     }
 
     /**
@@ -415,13 +420,17 @@ public void next( EdgeIteratorState edge, int index )
                 // we will skip zero length edges. Unfortunately there is a loss
                 // of precision in Lat/Lon calculations in GHNodeAccess so we
                 // have to handle <=0.1 as zero length.
-//                if (edge.getDistance() > 0.1) {
+                if (edge.getDistance() > 0.1) {
                     // baseNode is the current node and adjNode is the next
                     int adjNode = edge.getAdjNode();
                     int baseNode = edge.getBaseNode();
+                    
                     long flags = edge.getFlags();
                     double adjLat = nodeAccess.getLatitude(adjNode);
                     double adjLon = nodeAccess.getLongitude(adjNode);
+                    if(nodeAccess.getDimension()==1) {
+                    	
+                    }
                     double latitude, longitude;
 
                     PointList wayGeo = edge.fetchWayGeometry(3);
@@ -438,8 +447,18 @@ public void next( EdgeIteratorState edge, int index )
                     }
 
                     name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-
+                    
+                    try {
+                    	if(graph.getExtension().isRequireEdgeField()) {
+                    		int additionalField = edge.getAdditionalField();
+                    		annotation = encoder.getAnnotation(flags, tr, additionalField, extraInfo);
+                    	}
+                    	else {
+                    		annotation = encoder.getAnnotation(flags, tr);
+                    	}
+                    } catch (UnsupportedOperationException uoe) {
+                    	annotation = encoder.getAnnotation(flags, tr);
+                    }
                     if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                     {
                         int sign = Instruction.CONTINUE_ON_STREET;
@@ -590,7 +609,7 @@ public void next( EdgeIteratorState edge, int index )
                         }
                         ways.add(new FinishInstruction(nodeAccess, adjNode));
                     }
-//                }
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 883554e47f..df429d01b3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -33,6 +33,8 @@
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
 import com.graphhopper.reader.Way;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeExplorer;
@@ -51,10 +53,8 @@
  * @author Nop
  * @see EncodingManager
  */
-public abstract class AbstractFlagEncoder implements FlagEncoder,
-		TurnCostEncoder {
-	private final static Logger logger = LoggerFactory
-			.getLogger(AbstractFlagEncoder.class);
+public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder {
+	private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
 	private final static int K_FORWARD = 0, K_BACKWARD = 1;
 	/* Edge Flag Encoder fields */
 	private long nodeBitMask;
@@ -68,8 +68,9 @@
 	// bit to signal that way is accepted
 	protected long acceptBit;
 	protected long ferryBit;
-	
-	// This value determines the maximal possible speed of any road regardless the maxspeed value
+
+	// This value determines the maximal possible speed of any road regardless
+	// the maxspeed value
 	// lower values allow more compact representation of the routing graph
 	protected int maxPossibleSpeed;
 
@@ -95,10 +96,8 @@
 	/**
 	 * Used to hold type exclusions
 	 */
-	protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(
-			5);
-	protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(
-			5);
+	protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(5);
+	protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(5);
 	private boolean blockByDefault = true;
 	private boolean blockFords = true;
 	protected final int speedBits;
@@ -116,8 +115,7 @@
 	 *            is reached a turn is forbidden and results in costs of
 	 *            positive infinity.
 	 */
-	protected AbstractFlagEncoder(int speedBits, double speedFactor,
-			int maxTurnCosts) {
+	protected AbstractFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
 		this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
 		this.speedBits = speedBits;
 		this.speedFactor = speedFactor;
@@ -162,6 +160,14 @@ public boolean isBlockFords() {
 		return blockFords;
 	}
 
+	public List<EncoderDecorator> getEncoderDecorators() {
+		return encoderDecorators;
+	}
+
+	public void setEncoderDecorators(List<EncoderDecorator> encoderDecorators) {
+		this.encoderDecorators = encoderDecorators;
+	}
+
 	/**
 	 * Defines the bits for the node flags, which are currently used for
 	 * barriers only.
@@ -184,9 +190,8 @@ public int defineNodeBits(int index, int shift) {
 	 */
 	public int defineWayBits(int index, int shift) {
 		if (forwardBit != 0)
-			throw new IllegalStateException(
-					"You must not register a FlagEncoder (" + toString()
-							+ ") twice!");
+			throw new IllegalStateException("You must not register a FlagEncoder (" + toString()
+					+ ") twice!");
 
 		// define the first 2 speedBits in flags for routing
 		forwardBit = 1L << shift;
@@ -225,8 +230,7 @@ public int defineRelationBits(int index, int shift) {
 	 * determine the useful relation tags.
 	 * <p/>
 	 */
-	public abstract long handleRelationTags(Relation relation,
-			long oldRelationFlags);
+	public abstract long handleRelationTags(Relation relation, long oldRelationFlags);
 
 	/**
 	 * Decide whether a way is routable for a given mode of travel. This skips
@@ -242,18 +246,7 @@ public abstract long handleRelationTags(Relation relation,
 	 * Analyze properties of a way and create the routing flags. This method is
 	 * called in the second parsing step.
 	 */
-	public abstract long handleWayTags( Way way, long allowed, long relationFlags );
-	
-	
-	public long handleWayTagsDecorators(Way way) {
-		long flags = 0;
-		if (null != encoderDecorators) {
-			for (EncoderDecorator decorator : encoderDecorators) {
-				flags |= decorator.handleWayTags(way);
-			}
-		}
-		return flags;
-	};
+	public abstract long handleWayTags(Way way, long allowed, long relationFlags);
 
 	/**
 	 * Parse tags on nodes. Node tags can add to speed (like traffic_signals)
@@ -284,8 +277,7 @@ public long handleNodeTags(Node node) {
 				return directionBitMask;
 		}
 
-		if (blockFords
-				&& (node.hasTag("highway", "ford") || node.hasTag("ford"))
+		if (blockFords && (node.hasTag("highway", "ford") || node.hasTag("ford"))
 				&& !node.hasTag(restrictions, intendedValues))
 			return directionBitMask;
 
@@ -294,15 +286,22 @@ public long handleNodeTags(Node node) {
 
 	@Override
 	public InstructionAnnotation getAnnotation(long flags, Translation tr) {
-		if (null != encoderDecorators) {
+		return InstructionAnnotation.EMPTY;
+	}
+
+	@Override
+	public InstructionAnnotation getAnnotation(long flags, Translation tr, int extraField, GraphExtension extraInfo) {
+		//TODO composite annotations (Raise importance to highest value, append message if newest message is higher importance prepend)
+		if (extraField > -1 && null != encoderDecorators) {
+			long avoidanceFlags = ((AvoidanceAttributeExtension)extraInfo).getAvoidanceFlags(extraField);
 			for (EncoderDecorator decorator : encoderDecorators) {
-				InstructionAnnotation anno = decorator.getAnnotation(flags, tr);
+				InstructionAnnotation anno = decorator.getAnnotation(avoidanceFlags, tr);
 				if (!anno.isEmpty()) {
 					return anno;
 				}
 			}
 		}
-		return InstructionAnnotation.EMPTY;
+		return getAnnotation(flags, tr);
 	}
 
 	/**
@@ -335,8 +334,8 @@ public long setAccess(long flags, boolean forward, boolean backward) {
 	@Override
 	public long setSpeed(long flags, double speed) {
 		if (speed < 0)
-			throw new IllegalArgumentException("Speed cannot be negative: "
-					+ speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+			throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:"
+					+ BitUtil.LITTLE.toBitString(flags));
 
 		if (speed > getMaxSpeed())
 			speed = getMaxSpeed();
@@ -512,8 +511,8 @@ public void applyWayTags(Way way, EdgeIteratorState edge) {
 	/**
 	 * Special handling for ferry ways.
 	 */
-	protected long handleFerryTags(Way way, double unknownSpeed,
-			double shortTripsSpeed, double longTripsSpeed) {
+	protected long handleFerryTags(Way way, double unknownSpeed, double shortTripsSpeed,
+			double longTripsSpeed) {
 		// to hours
 		double durationInHours = parseDuration(way.getTag("duration")) / 60d;
 		if (durationInHours > 0)
@@ -591,8 +590,7 @@ else if (maxTurnCosts == 1) {
 		}
 
 		int turnBits = Helper.countBitValue(maxTurnCosts);
-		turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0,
-				maxTurnCosts) {
+		turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts) {
 			// override to avoid expensive Math.round
 			@Override
 			public final long getValue(long flags) {
@@ -622,8 +620,7 @@ public double getTurnCost(long flags) {
 			return 0;
 
 		else if (maxTurnCosts == 1)
-			return ((flags & turnRestrictionBit) == 0) ? 0
-					: Double.POSITIVE_INFINITY;
+			return ((flags & turnRestrictionBit) == 0) ? 0 : Double.POSITIVE_INFINITY;
 
 		long cost = turnCostEncoder.getValue(flags);
 		if (cost == maxTurnCosts)
@@ -639,8 +636,7 @@ public long getTurnFlags(boolean restricted, double costs) {
 
 		else if (maxTurnCosts == 1) {
 			if (costs != 0)
-				throw new IllegalArgumentException(
-						"Only restrictions are supported");
+				throw new IllegalArgumentException("Only restrictions are supported");
 
 			return restricted ? turnRestrictionBit : 0;
 		}
@@ -663,8 +659,8 @@ else if (maxTurnCosts == 1) {
 		return turnCostEncoder.setValue(0L, (int) costs);
 	}
 
-	public Collection<ITurnCostTableEntry> analyzeTurnRelation(
-			TurnRelation turnRelation, DataReader osmReader) {
+	public Collection<ITurnCostTableEntry> analyzeTurnRelation(TurnRelation turnRelation,
+			DataReader osmReader) {
 		if (!supports(TurnWeighting.class))
 			return Collections.emptyList();
 
@@ -674,8 +670,8 @@ else if (maxTurnCosts == 1) {
 			edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(
 					new DefaultEdgeFilter(this, true, false));
 		}
-		return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer,
-				edgeInExplorer, osmReader);
+		return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer,
+				osmReader);
 	}
 
 	protected boolean isFerry(long internalFlags) {
@@ -699,15 +695,14 @@ public boolean isForward(long flags) {
 	@Override
 	public long setBool(long flags, int key, boolean value) {
 		switch (key) {
-		case K_FORWARD:
-			return value ? flags | forwardBit : flags & ~forwardBit;
-		case K_BACKWARD:
-			return value ? flags | backwardBit : flags & ~backwardBit;
-		case K_ROUNDABOUT:
-			return value ? flags | roundaboutBit : flags & ~roundaboutBit;
-		default:
-			throw new IllegalArgumentException("Unknown key " + key
-					+ " for boolean value");
+			case K_FORWARD:
+				return value ? flags | forwardBit : flags & ~forwardBit;
+			case K_BACKWARD:
+				return value ? flags | backwardBit : flags & ~backwardBit;
+			case K_ROUNDABOUT:
+				return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+			default:
+				throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
 		}
 	}
 
@@ -715,41 +710,37 @@ public long setBool(long flags, int key, boolean value) {
 	public boolean isBool(long flags, int key) {
 		switch (key) {
 
-		case K_FORWARD:
-			return isForward(flags);
-		case K_BACKWARD:
-			return isBackward(flags);
-		case K_ROUNDABOUT:
-			return (flags & roundaboutBit) != 0;
-		default:
-			throw new IllegalArgumentException("Unknown key " + key
-					+ " for boolean value");
+			case K_FORWARD:
+				return isForward(flags);
+			case K_BACKWARD:
+				return isBackward(flags);
+			case K_ROUNDABOUT:
+				return (flags & roundaboutBit) != 0;
+			default:
+				throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
 		}
 	}
 
 	@Override
 	public long setLong(long flags, int key, long value) {
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for long value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
 	}
 
 	@Override
 	public long getLong(long flags, int key) {
-        if(null!=encoderDecorators) {
-            for (EncoderDecorator decorator : encoderDecorators) {
-                if (decorator.supports(key)) {
-                    return decorator.getLong(flags);
-                }
-            }
-        }
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for long value.");
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
+				if (decorator.supports(key)) {
+					return decorator.getLong(flags);
+				}
+			}
+		}
+		throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
 	}
 
 	@Override
 	public long setDouble(long flags, int key, double value) {
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for double value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
 	}
 
 	@Override
@@ -759,8 +750,7 @@ public double getDouble(long flags, int key) {
 				return decorator.getDouble(flags);
 			}
 		}
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for double value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
 	}
 
 	protected static double parseDouble(String str, String key, double defaultD) {
@@ -777,8 +767,7 @@ protected static long parseLong(String str, String key, long defaultL) {
 		return Long.parseLong(val);
 	}
 
-	protected static boolean parseBoolean(String str, String key,
-			boolean defaultB) {
+	protected static boolean parseBoolean(String str, String key, boolean defaultB) {
 		String val = getStr(str, key);
 		if (val.isEmpty())
 			return defaultB;
@@ -817,8 +806,8 @@ protected double applyMaxSpeed(Way way, double speed, boolean force) {
 	}
 
 	protected String getPropertiesString() {
-		return "speedFactor=" + speedFactor + "|speedBits=" + speedBits
-				+ "|turnCosts=" + (maxTurnCosts > 0);
+		return "speedFactor=" + speedFactor + "|speedBits=" + speedBits + "|turnCosts="
+				+ (maxTurnCosts > 0);
 	}
 
 	@Override
@@ -837,8 +826,7 @@ public boolean supports(Class<?> feature) {
 	 * @return
 	 */
 	public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
-		if (routingElement.hasTag(vehicleQualifierTypeInclusions,
-				intendedValues)) {
+		if (routingElement.hasTag(vehicleQualifierTypeInclusions, intendedValues)) {
 			// It is specifically included
 			return true;
 		}
@@ -853,8 +841,7 @@ public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
 	 * @return
 	 */
 	public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
-		if (routingElement.hasTag(vehicleQualifierTypeExclusions,
-				excludedValues)) {
+		if (routingElement.hasTag(vehicleQualifierTypeExclusions, excludedValues)) {
 			// It is specifically excluded
 			return true;
 		}
@@ -866,7 +853,7 @@ public long getBitMask(String[] attributes, int key) {
 		long bitMask = 0;
 		if (null != encoderDecorators) {// BIT SHIFT FIRST
 			for (EncoderDecorator decorator : encoderDecorators) {
-				if(decorator.supports(key)) {
+				if (decorator.supports(key)) {
 					return decorator.getBitMask(attributes);
 				}
 			}
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 2b908b2a07..3d73ad867b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -369,8 +369,7 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
             encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
             encoded |= directionBitMask;
         }
-        long anno = super.handleWayTagsDecorators(way);
-        return encoded |= anno;
+        return encoded;
     }
 
     public String getWayInfo(Way way )
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
index f2cca8dfe2..0ed49d2d6f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
@@ -1,13 +1,17 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class FastestWithAvoidancesWeighting extends FastestWeighting {
 
 	private long bitMask;
+	private AvoidanceAttributeExtension extension;
 
-	public FastestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+
+	public FastestWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super(encoder);
+		this.extension = extension;
 		configureAvoidances(avoidances);
 	}
 
@@ -18,11 +22,15 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 7d4076b851..4c3d8edfcf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
 
@@ -121,6 +122,9 @@
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
     InstructionAnnotation getAnnotation( long flags, Translation tr );
+    InstructionAnnotation getAnnotation(long flags, Translation tr, int additionalField, GraphExtension extraInfo);
+
 
 	long getBitMask(String[] avoidances, int key);
-}
+
+	}
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 0ad02dd6f2..7bb00295b6 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -295,9 +295,8 @@ public long handleWayTags(Way way, long allowed, long relationFlags) {
             encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             encoded |= directionBitMask;
         }
-        long anno = super.handleWayTagsDecorators(way);
 
-        return encoded |= anno;
+        return encoded;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
index 11946aefba..5c8a941c77 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
@@ -28,4 +28,12 @@ private void setOsAvoidanceDecorator() {
 			}
 			encoderDecorators.add(new OsAvoidanceDecorator());
 		}
+		
+		@Override
+		public boolean supports(Class<?> feature) {
+			 if (super.supports(feature))
+		            return true;
+			 
+			 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+		}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
index c192d8b539..8e09019e3a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
@@ -25,5 +25,13 @@ private void setOsAvoidanceDecorator() {
 		}
 		encoderDecorators.add(new OsVehicleAvoidanceDecorator());
 	}
+	
+	@Override
+	public boolean supports(Class<?> feature) {
+		 if (super.supports(feature))
+	            return true;
+		 
+		 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
index f4ade0b8a7..17185abfc0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
@@ -27,5 +27,13 @@ private void setOsAvoidanceDecorator() {
 		}
 		encoderDecorators.add(new OsAvoidanceDecorator());
 	}
+	
+	@Override
+	public boolean supports(Class<?> feature) {
+		 if (super.supports(feature))
+	            return true;
+		 
+		 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
index b621e7474b..e7cefcf704 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
@@ -1,13 +1,16 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class PriorityWithAvoidancesWeighting extends PriorityWeighting {
 
 	private long bitMask;
+	private AvoidanceAttributeExtension extension;
 
-	public PriorityWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+	public PriorityWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super(encoder);
+		this.extension = extension;
 		configureAvoidances(avoidances);
 	}
 
@@ -18,11 +21,16 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
+		
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
index 74bfed8399..dd317cea79 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
@@ -1,14 +1,17 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class ShortestWithAvoidancesWeighting extends ShortestWeighting {
 
 	private long bitMask;
 	private FlagEncoder encoder;
+	private AvoidanceAttributeExtension extension;
 
-	public ShortestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+	public ShortestWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super();
+		this.extension = extension;
 		this.encoder = encoder;
 		configureAvoidances(avoidances);
 	}
@@ -20,11 +23,15 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java b/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java
index 474d3add82..119504eb27 100644
--- a/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java
@@ -146,28 +146,19 @@ private int createNewEntry(EdgeIteratorState edgeProps) {
 	private void setAttributeEntry(long attributeFlag, int newEntryIndex) {
 		avoidanceFlags.setInt(newEntryIndex, (int)attributeFlag);
 	}
-
-    /**
-     * @return avoidance flags of the specified node and edge properties.
-     */
-    public long getAvoidanceFlags( int edgeId, int adjNode)
-    {
-        if (edgeId == EdgeIterator.NO_EDGE)
-            throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
-        if (adjNode < 0)
-            throw new IllegalArgumentException("via node cannot be negative");
-
-        return nextCostFlags(edgeId, adjNode);
-    }
+    
+    public long getAvoidanceFlags(long extensionPointer) {
+    	if (extensionPointer > NO_TURN_ENTRY) {
+        	return avoidanceFlags.getInt(extensionPointer);
+        }
+        return EMPTY_FLAGS;
+	}
 
     private long nextCostFlags( int edgeId, int adjNode)
     {
     	EdgeIteratorState edgeProps = graph.getEdgeProps(edgeId, adjNode);
-        int flagIndex = edgeProps.getAdditionalField();
-        if (flagIndex > NO_TURN_ENTRY) {
-        	return avoidanceFlags.getInt(flagIndex);
-        }
-        return EMPTY_FLAGS;
+        int extensionPointer = edgeProps.getAdditionalField();
+        return getAvoidanceFlags(extensionPointer);
     }
 
     private void ensureAttributeIndex( int nodeIndex )
@@ -232,4 +223,5 @@ public String toString()
     {
         return "avoidance";
     }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
index 81b5e30c5a..b92196497a 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class FastestWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -90,5 +95,9 @@ private void configureSpeeds() {
 		when(encoder.getMaxSpeed()).thenReturn(100D);
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
index c6e303c645..f39dc09163 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class PriorityWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -92,5 +97,10 @@ private void configureSpeedsAndPriority() {
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 		when(encoder.getDouble(anyLong(), eq(101))).thenReturn(10D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
+	
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
index 6cd618de38..ac48627677 100644
--- a/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class ShortestWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -91,5 +96,9 @@ private void configureSpeeds() {
 		when(encoder.getMaxSpeed()).thenReturn(100D);
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
 
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java b/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java
index f42d676b25..0d3424919c 100644
--- a/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java
+++ b/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java
@@ -46,8 +46,8 @@ public void testAddEdgeInfo() {
 		extension.create(4);
 		extension.addEdgeInfo(0, 1, 100);
 		extension.addEdgeInfo(1, 5, 200);
-		assertEquals("Retrieved value should match stored", 200, extension.getAvoidanceFlags(1, 5));
-		assertEquals("Retrieved value should match stored", 100, extension.getAvoidanceFlags(0, 1));
+		assertEquals("Retrieved value should match stored", 200, extension.getAvoidanceFlags(edgeTwo.getAdditionalField()));
+		assertEquals("Retrieved value should match stored", 100, extension.getAvoidanceFlags(edgeOne.getAdditionalField()));
 		extension.close();
 	}
 
