diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 4a64fe9b04..fa12469ddd 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -150,8 +150,9 @@ protected GraphHopper loadGraph(GraphHopperStorage g) {
      * @return the first flag encoder of the encoding manager
      */
     FlagEncoder getDefaultVehicle() {
-        if (encodingManager == null)
+        if (encodingManager == null) {
             throw new IllegalStateException("No encoding manager specified or loaded");
+        }
 
         return encodingManager.fetchEdgeEncoders().get(0);
     }
@@ -167,8 +168,9 @@ public EncodingManager getEncodingManager() {
     public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
-        if (em.needsTurnCostsSupport())
+        if (em.needsTurnCostsSupport()) {
             traversalMode = TraversalMode.EDGE_BASED;
+        }
 
         return this;
     }
@@ -178,10 +180,11 @@ public ElevationProvider getElevationProvider() {
     }
 
     public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+        if (eleProvider == null || eleProvider == ElevationProvider.NOOP) {
             setElevation(false);
-        else
+        } else {
             setElevation(true);
+        }
         this.eleProvider = eleProvider;
         return this;
     }
@@ -292,10 +295,11 @@ private GraphHopper setInMemory() {
      */
     public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
         ensureNotLoaded();
-        if (storeOnFlush)
+        if (storeOnFlush) {
             dataAccessType = DAType.RAM_STORE;
-        else
+        } else {
             dataAccessType = DAType.RAM;
+        }
         return this;
     }
 
@@ -392,8 +396,9 @@ public String getGraphHopperLocation() {
      */
     public GraphHopper setGraphHopperLocation(String ghLocation) {
         ensureNotLoaded();
-        if (ghLocation == null)
+        if (ghLocation == null) {
             throw new IllegalArgumentException("graphhopper location cannot be null");
+        }
 
         this.ghLocation = ghLocation;
         return this;
@@ -409,8 +414,9 @@ public String getDataReaderFile() {
      */
     public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
-        if (isEmpty(dataReaderFileStr))
+        if (isEmpty(dataReaderFileStr)) {
             throw new IllegalArgumentException("Data reader file cannot be empty.");
+        }
 
         dataReaderFile = dataReaderFileStr;
         return this;
@@ -422,8 +428,9 @@ public GraphHopper setDataReaderFile(String dataReaderFileStr) {
      * @throws IllegalStateException if graph is not instantiated.
      */
     public GraphHopperStorage getGraphHopperStorage() {
-        if (ghStorage == null)
+        if (ghStorage == null) {
             throw new IllegalStateException("GraphHopper storage not initialized");
+        }
 
         return ghStorage;
     }
@@ -439,8 +446,9 @@ public void setGraphHopperStorage(GraphHopperStorage ghStorage) {
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex() {
-        if (locationIndex == null)
+        if (locationIndex == null) {
             throw new IllegalStateException("Location index not initialized");
+        }
 
         return locationIndex;
     }
@@ -504,17 +512,20 @@ public GraphHopper setTagParserFactory(TagParserFactory factory) {
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
-        if (args.has("osmreader.osm"))
+        if (args.has("osmreader.osm")) {
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
+        }
 
         String tmpOsmFile = args.get("datareader.file", "");
-        if (!isEmpty(tmpOsmFile))
+        if (!isEmpty(tmpOsmFile)) {
             dataReaderFile = tmpOsmFile;
+        }
 
         String graphHopperFolder = args.get("graph.location", "");
         if (isEmpty(graphHopperFolder) && isEmpty(ghLocation)) {
-            if (isEmpty(dataReaderFile))
+            if (isEmpty(dataReaderFile)) {
                 throw new IllegalArgumentException("If no graph.location is provided you need to specify an OSM file.");
+            }
 
             graphHopperFolder = pruneFileEnd(dataReaderFile) + "-gh";
         }
@@ -533,20 +544,23 @@ public GraphHopper init(CmdArgs args) {
         String flagEncodersStr = args.get("graph.flag_encoders", "");
         String encodedValueStr = args.get("graph.encoded_values", "");
         if (!flagEncodersStr.isEmpty() || !encodedValueStr.isEmpty()) {
-            if (!encodedValueStr.isEmpty())
+            if (!encodedValueStr.isEmpty()) {
                 emBuilder.addAll(tagParserFactory, encodedValueStr);
-            if (!flagEncodersStr.isEmpty())
+            }
+            if (!flagEncodersStr.isEmpty()) {
                 emBuilder.addAll(flagEncoderFactory, flagEncodersStr);
+            }
             emBuilder.setEnableInstructions(args.getBool("datareader.instructions", true));
             emBuilder.setPreferredLanguage(args.get("datareader.preferred_language", ""));
             // overwrite EncodingManager object from configuration file
             setEncodingManager(emBuilder.build());
         }
 
-        if (args.get("graph.locktype", "native").equals("simple"))
+        if (args.get("graph.locktype", "native").equals("simple")) {
             lockFactory = new SimpleFSLockFactory();
-        else
+        } else {
             lockFactory = new NativeFSLockFactory();
+        }
 
         // elevation
         String eleProviderStr = toLowerCase(args.get("graph.elevation.provider", "noop"));
@@ -554,16 +568,18 @@ public GraphHopper init(CmdArgs args) {
 
         // keep fallback until 0.8
         boolean eleCalcMean = args.has("graph.elevation.calcmean")
-                ? args.getBool("graph.elevation.calcmean", false)
-                : args.getBool("graph.elevation.calc_mean", false);
+                              ? args.getBool("graph.elevation.calcmean", false)
+                              : args.getBool("graph.elevation.calc_mean", false);
 
         String cacheDirStr = args.get("graph.elevation.cache_dir", "");
-        if (cacheDirStr.isEmpty())
+        if (cacheDirStr.isEmpty()) {
             cacheDirStr = args.get("graph.elevation.cachedir", "");
+        }
 
         String baseURL = args.get("graph.elevation.base_url", "");
-        if (baseURL.isEmpty())
+        if (baseURL.isEmpty()) {
             args.get("graph.elevation.baseurl", "");
+        }
 
         boolean removeTempElevationFiles = args.getBool("graph.elevation.cgiar.clear", true);
         removeTempElevationFiles = args.getBool("graph.elevation.clear", removeTempElevationFiles);
@@ -584,8 +600,9 @@ public GraphHopper init(CmdArgs args) {
 
         tmpProvider.setAutoRemoveTemporaryFiles(removeTempElevationFiles);
         tmpProvider.setCalcMean(eleCalcMean);
-        if (!baseURL.isEmpty())
+        if (!baseURL.isEmpty()) {
             tmpProvider.setBaseURL(baseURL);
+        }
         tmpProvider.setDAType(elevationDAType);
         setElevationProvider(tmpProvider);
 
@@ -617,8 +634,9 @@ public GraphHopper init(CmdArgs args) {
 
     private void printInfo() {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (ghStorage != null)
+        if (ghStorage != null) {
             logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
+        }
     }
 
     /**
@@ -646,16 +664,18 @@ private GraphHopper process(String graphHopperLocation) {
             if (ghStorage.getDirectory().getDefaultType().isStoring()) {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock())
+                if (!lock.tryLock()) {
                     throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
+                }
             }
 
             try {
                 DataReader reader = importData();
                 DateFormat f = createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
-                if (reader.getDataDate() != null)
+                if (reader.getDataDate() != null) {
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
+                }
             } catch (IOException ex) {
                 throw new RuntimeException("Cannot read file " + getDataReaderFile(), ex);
             }
@@ -663,20 +683,23 @@ private GraphHopper process(String graphHopperLocation) {
             postProcessing();
             flush();
         } finally {
-            if (lock != null)
+            if (lock != null) {
                 lock.release();
+            }
         }
         return this;
     }
 
     protected DataReader importData() throws IOException {
         ensureWriteAccess();
-        if (ghStorage == null)
+        if (ghStorage == null) {
             throw new IllegalStateException("Load graph before importing OSM data");
+        }
 
-        if (dataReaderFile == null)
+        if (dataReaderFile == null) {
             throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot use file for DataReader as it wasn't specified!");
+                                            + " but also cannot use file for DataReader as it wasn't specified!");
+        }
 
         DataReader reader = createReader(ghStorage);
         logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
@@ -686,12 +709,13 @@ protected DataReader importData() throws IOException {
 
     protected DataReader createReader(GraphHopperStorage ghStorage) {
         throw new UnsupportedOperationException("Cannot create DataReader. Solutions: avoid import via calling load directly, "
-                + "provide a DataReader or use e.g. GraphHopperOSM or a different subclass");
+                                                + "provide a DataReader or use e.g. GraphHopperOSM or a different subclass");
     }
 
     protected DataReader initDataReader(DataReader reader) {
-        if (dataReaderFile == null)
+        if (dataReaderFile == null) {
             throw new IllegalArgumentException("No file for DataReader specified");
+        }
 
         logger.info("start creating graph from " + dataReaderFile);
         return reader.setFile(new File(dataReaderFile)).
@@ -709,11 +733,13 @@ protected DataReader initDataReader(DataReader reader) {
      */
     @Override
     public boolean load(String graphHopperFolder) {
-        if (isEmpty(graphHopperFolder))
+        if (isEmpty(graphHopperFolder)) {
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
+        }
 
-        if (fullyLoaded)
+        if (fullyLoaded) {
             throw new IllegalStateException("graph is already successfully loaded");
+        }
 
         File tmpFileOrFolder = new File(graphHopperFolder);
 
@@ -726,38 +752,42 @@ public boolean load(String graphHopperFolder) {
                     new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
                 } catch (IOException ex) {
                     throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
-                            + " to " + graphHopperFolder, ex);
+                                               + " to " + graphHopperFolder, ex);
                 }
             }
         }
 
         setGraphHopperLocation(graphHopperFolder);
 
-        if (encodingManager == null)
+        if (encodingManager == null) {
             setEncodingManager(EncodingManager.create(encodedValueFactory, flagEncoderFactory, ghLocation));
+        }
 
-        if (!allowWrites && dataAccessType.isMMap())
+        if (!allowWrites && dataAccessType.isMMap()) {
             dataAccessType = DAType.MMAP_RO;
+        }
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         GraphExtension ext = encodingManager.needsTurnCostsSupport()
-                ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
+                             ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
 
-        if (lmFactoryDecorator.isEnabled())
+        if (lmFactoryDecorator.isEnabled()) {
             initLMAlgoFactoryDecorator();
+        }
 
         if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
             ghStorage = new GraphHopperStorage(chFactoryDecorator.getNodeBasedWeightings(), chFactoryDecorator.getEdgeBasedWeightings(),
-                    dir, encodingManager, hasElevation(), ext);
+                                               dir, encodingManager, hasElevation(), ext);
         } else {
             ghStorage = new GraphHopperStorage(dir, encodingManager, hasElevation(), ext);
         }
 
         ghStorage.setSegmentSize(defaultSegmentSize);
 
-        if (!new File(graphHopperFolder).exists())
+        if (!new File(graphHopperFolder).exists()) {
             return false;
+        }
 
         GHLock lock = null;
         try {
@@ -766,35 +796,40 @@ public boolean load(String graphHopperFolder) {
             if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock())
+                if (!lock.tryLock()) {
                     throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
+                }
             }
 
-            if (!ghStorage.loadExisting())
+            if (!ghStorage.loadExisting()) {
                 return false;
+            }
 
             postProcessing();
             fullyLoaded = true;
             return true;
         } finally {
-            if (lock != null)
+            if (lock != null) {
                 lock.release();
+            }
         }
     }
 
     public RoutingAlgorithmFactory getAlgorithmFactory(HintsMap map) {
         RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
         for (RoutingAlgorithmFactoryDecorator decorator : algoDecorators) {
-            if (decorator.isEnabled())
+            if (decorator.isEnabled()) {
                 routingAlgorithmFactory = decorator.getDecoratedAlgorithmFactory(routingAlgorithmFactory, map);
+            }
         }
 
         return routingAlgorithmFactory;
     }
 
     public GraphHopper addAlgorithmFactoryDecorator(RoutingAlgorithmFactoryDecorator algoFactoryDecorator) {
-        if (!algoDecorators.add(algoFactoryDecorator))
+        if (!algoDecorators.add(algoFactoryDecorator)) {
             throw new IllegalArgumentException("Decorator was already added " + algoFactoryDecorator.getClass());
+        }
 
         return this;
     }
@@ -825,8 +860,9 @@ public final LMAlgoFactoryDecorator getLMFactoryDecorator() {
     }
 
     private void initLMAlgoFactoryDecorator() {
-        if (lmFactoryDecorator.hasWeightings())
+        if (lmFactoryDecorator.hasWeightings()) {
             return;
+        }
 
         for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
             for (String lmWeightingStr : lmFactoryDecorator.getWeightingsAsStrings()) {
@@ -844,8 +880,9 @@ public void postProcessing() {
         // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
 
         if (sortGraph) {
-            if (ghStorage.isCHPossible() && isCHPrepared())
+            if (ghStorage.isCHPossible() && isCHPrepared()) {
                 throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
+            }
 
             GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
             GHUtility.sortDFS(ghStorage, newGraph);
@@ -859,13 +896,16 @@ public void postProcessing() {
 
         initLocationIndex();
 
-        if (chFactoryDecorator.isEnabled())
+        if (chFactoryDecorator.isEnabled()) {
             chFactoryDecorator.createPreparations(ghStorage);
-        if (!isCHPrepared())
+        }
+        if (!isCHPrepared()) {
             prepareCH();
+        }
 
-        if (lmFactoryDecorator.isEnabled())
+        if (lmFactoryDecorator.isEnabled()) {
             lmFactoryDecorator.createPreparations(ghStorage, locationIndex);
+        }
         loadOrPrepareLM();
     }
 
@@ -909,20 +949,23 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         } else if ("shortest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortestWeighting(encoder);
         } else if ("fastest".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {
-            if (encoder.supports(PriorityWeighting.class))
+            if (encoder.supports(PriorityWeighting.class)) {
                 weighting = new PriorityWeighting(encoder, hintsMap);
-            else
+            } else {
                 weighting = new FastestWeighting(encoder, hintsMap);
+            }
         } else if ("curvature".equalsIgnoreCase(weightingStr)) {
-            if (encoder.supports(CurvatureWeighting.class))
+            if (encoder.supports(CurvatureWeighting.class)) {
                 weighting = new CurvatureWeighting(encoder, hintsMap);
+            }
 
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
         }
 
-        if (weighting == null)
+        if (weighting == null) {
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
+        }
 
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
@@ -939,8 +982,9 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
      */
     private Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
         FlagEncoder encoder = weighting.getFlagEncoder();
-        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased())
+        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased()) {
             return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
+        }
         return weighting;
     }
 
@@ -965,8 +1009,9 @@ public GHResponse route(GHRequest request) {
         HintsMap hints = request.getHints();
         String tModeStr = hints.get("traversal_mode", traversalMode.toString());
         TraversalMode tMode = TraversalMode.fromString(tModeStr);
-        if (hints.has(Routing.EDGE_BASED))
+        if (hints.has(Routing.EDGE_BASED)) {
             tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
+        }
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
 
         boolean disableCH = hints.getBool(CH.DISABLE, false);
@@ -980,8 +1025,9 @@ public GHResponse route(GHRequest request) {
         }
 
         String algoStr = request.getAlgorithm();
-        if (algoStr.isEmpty())
+        if (algoStr.isEmpty()) {
             algoStr = isCHUsageGranted(disableCH) ? DIJKSTRA_BI : ASTAR_BI;
+        }
 
         List<GHPoint> points = request.getPoints();
         Polygon polygon = request.getPolygon();
@@ -994,62 +1040,63 @@ public GHResponse route(GHRequest request) {
 
         RoutingTemplate routingTemplate = buildRoutingTemplate(request, ghRsp, algoStr);
 
-        try {
-            List<Path> altPaths = null;
-            int maxRetries = routingTemplate.getMaxRetries();
-            Locale locale = request.getLocale();
-            Translation tr = trMap.getWithFallBack(locale);
-            for (int i = 0; i < maxRetries; i++) {
-                StopWatch sw = new StopWatch().start();
-                List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
-                ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
-                if (ghRsp.hasErrors())
-                    return Collections.emptyList();
-
-                RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
-
-                Weighting weighting;
-                QueryGraph queryGraph;
-                BuilderForWeightingAndQueryGraph builderForWeightingAndQueryGraph = new BuilderForWeightingAndQueryGraph(request, ghRsp, hints, encoder, disableCH, points, qResults, tmpAlgoFactory).invoke();
-                if (builderForWeightingAndQueryGraph.is())
-                    return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
-                weighting = builderForWeightingAndQueryGraph.getWeighting();
-                queryGraph = builderForWeightingAndQueryGraph.getQueryGraph();
-                ghRsp.addDebugInfo("tmode:" + tMode.toString());
-
-                int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
-                if (failOnMaxVisitedNodesForRequestExceedsLimit(maxVisitedNodesForRequest))
-                    return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
-
-                weighting = createTurnWeighting(queryGraph, weighting, tMode);
-
-                AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
-
-                // do the actual route calculation !
-                altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
-
-                boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
-                boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
-                double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
-
-                DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-                PathMerger pathMerger = buildPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
-
-                if (request.hasFavoredHeading(0))
-                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
-
-                if (routingTemplate.isReady(pathMerger, tr))
-                    break;
+        List<Path> altPaths = null;
+        int maxRetries = routingTemplate.getMaxRetries();
+        Locale locale = request.getLocale();
+        Translation tr = trMap.getWithFallBack(locale);
+        for (int i = 0; i < maxRetries; i++) {
+            StopWatch sw = new StopWatch().start();
+            List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
+            ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
+            if (ghRsp.hasErrors()) {
+                return Collections.emptyList();
             }
 
-            return altPaths;
+            RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
 
-        } catch (IllegalArgumentException ex) {
-            ghRsp.addError(ex);
-            return Collections.emptyList();
-        } finally {
-            readLock.unlock();
+            Weighting weighting;
+            QueryGraph queryGraph;
+            BuilderForWeightingAndQueryGraph builderForWeightingAndQueryGraph =
+                    new BuilderForWeightingAndQueryGraph(request, ghRsp, hints, encoder, disableCH, points, qResults, tmpAlgoFactory).invoke();
+            if (builderForWeightingAndQueryGraph.is()) {
+                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
+            }
+            weighting = builderForWeightingAndQueryGraph.getWeighting();
+            queryGraph = builderForWeightingAndQueryGraph.getQueryGraph();
+            ghRsp.addDebugInfo("tmode:" + tMode.toString());
+
+            int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
+            if (failOnMaxVisitedNodesForRequestExceedsLimit(maxVisitedNodesForRequest)) {
+                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
+            }
+
+            weighting = createTurnWeighting(queryGraph, weighting, tMode);
+
+            AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
+
+            // do the actual route calculation !
+            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+
+            boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
+            boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
+            double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
+
+            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+            PathMerger pathMerger = buildPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
+
+            if (request.hasFavoredHeading(0)) {
+                pathMerger.setFavoredHeading(request.getFavoredHeading(0));
+            }
+
+            if (routingTemplate.isReady(pathMerger, tr)) {
+                break;
+            }
         }
+
+        readLock.unlock();
+        return altPaths;
+
+
     }
 
     private boolean isCHUsageGranted(boolean disableCH) {
@@ -1072,17 +1119,20 @@ private String buildVehicle(GHRequest request) {
             vehicle = getDefaultVehicle().toString();
             request.setVehicle(vehicle);
         }
-        if (!encodingManager.hasEncoder(vehicle))
+        if (!encodingManager.hasEncoder(vehicle)) {
             throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
+        }
         return vehicle;
     }
 
     private void failOnIllegalStorageStates() {
-        if (ghStorage == null || !fullyLoaded)
+        if (ghStorage == null || !fullyLoaded) {
             throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
+        }
 
-        if (ghStorage.isClosed())
+        if (ghStorage.isClosed()) {
             throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+        }
     }
 
     private PathMerger buildPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
@@ -1104,12 +1154,13 @@ private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMo
 
     private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
         RoutingTemplate routingTemplate;
-        if (ROUND_TRIP.equalsIgnoreCase(algoStr))
+        if (ROUND_TRIP.equalsIgnoreCase(algoStr)) {
             routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, encodingManager, maxRoundTripRetries);
-        else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
+        } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        else
+        } else {
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
+        }
         return routingTemplate;
     }
 
@@ -1120,8 +1171,9 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
      */
     public ChangeGraphResponse changeGraph(Collection<JsonFeature> collection) {
         // TODO allow calling this method if called before CH preparation
-        if (getCHFactoryDecorator().isEnabled())
+        if (getCHFactoryDecorator().isEnabled()) {
             throw new IllegalArgumentException("To use the changeGraph API you need to turn off CH");
+        }
 
         Lock writeLock = readWriteLock.writeLock();
         writeLock.lock();
@@ -1164,16 +1216,17 @@ protected LocationIndex createLocationIndex(Directory dir) {
      * Initializes the location index after the import is done.
      */
     private void initLocationIndex() {
-        if (locationIndex != null)
+        if (locationIndex != null) {
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
+        }
 
         locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
 
     private boolean isCHPrepared() {
         return "true".equals(ghStorage.getProperties().get(CH.PREPARE + "done"))
-                // remove old property in >0.9
-                || "true".equals(ghStorage.getProperties().get("prepare.done"));
+               // remove old property in >0.9
+               || "true".equals(ghStorage.getProperties().get("prepare.done"));
     }
 
     private boolean isLMPrepared() {
@@ -1199,8 +1252,9 @@ protected void loadOrPrepareLM() {
         if (tmpPrepare) {
             ensureWriteAccess();
             ghStorage.freeze();
-            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties()))
+            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties())) {
                 ghStorage.getProperties().put(Landmark.PREPARE + "done", true);
+            }
         }
     }
 
@@ -1215,14 +1269,14 @@ protected void cleanUp() {
         preparation.doWork();
         int currNodeCount = ghStorage.getNodes();
         logger.info("edges: " + Helper.nf(ghStorage.getAllEdges().length()) + ", nodes " + Helper.nf(currNodeCount)
-                + ", there were " + Helper.nf(preparation.getMaxSubnetworks())
-                + " subnetworks. removed them => " + Helper.nf(prevNodeCount - currNodeCount)
-                + " less nodes");
+                    + ", there were " + Helper.nf(preparation.getMaxSubnetworks())
+                    + " subnetworks. removed them => " + Helper.nf(prevNodeCount - currNodeCount)
+                    + " less nodes");
     }
 
     protected void flush() {
         logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
-                + getMemInfo() + ")");
+                    + getMemInfo() + ")");
         ghStorage.flush();
         logger.info("flushed graph " + getMemInfo() + ")");
         fullyLoaded = true;
@@ -1233,11 +1287,13 @@ protected void flush() {
      * remove the files created in graphhopperLocation you have to call clean().
      */
     public void close() {
-        if (ghStorage != null)
+        if (ghStorage != null) {
             ghStorage.close();
+        }
 
-        if (locationIndex != null)
+        if (locationIndex != null) {
             locationIndex.close();
+        }
 
         try {
             lockFactory.forceRemove(fileLockName, true);
@@ -1251,21 +1307,24 @@ public void close() {
      * load
      */
     public void clean() {
-        if (getGraphHopperLocation().isEmpty())
+        if (getGraphHopperLocation().isEmpty()) {
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+        }
 
         File folder = new File(getGraphHopperLocation());
         removeDir(folder);
     }
 
     private void ensureNotLoaded() {
-        if (fullyLoaded)
+        if (fullyLoaded) {
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
+        }
     }
 
     private void ensureWriteAccess() {
-        if (!allowWrites)
+        if (!allowWrites) {
             throw new IllegalStateException("Writes are not allowed!");
+        }
     }
 
     public void setNonChMaxWaypointDistance(int nonChMaxWaypointDistance) {
@@ -1311,13 +1370,15 @@ BuilderForQueryGraphAndWeightingWithCHEnabled invoke() {
 
             // if LM is enabled we have the LMFactory with the CH algo!
             RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
-            if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
+            if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory) {
                 chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
+            }
 
-            if (chAlgoFactory instanceof PrepareContractionHierarchies)
+            if (chAlgoFactory instanceof PrepareContractionHierarchies) {
                 weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
-            else
+            } else {
                 throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
+            }
 
             queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
             queryGraph.lookup(qResults);
@@ -1418,7 +1479,8 @@ QueryGraph getQueryGraph() {
 
         BuilderForWeightingAndQueryGraph invoke() {
             if (isCHUsageGranted(disableCH)) {
-                BuilderForQueryGraphAndWeightingWithCHEnabled builderForQueryGraphAndWeightingWithCHEnabled = new BuilderForQueryGraphAndWeightingWithCHEnabled(request, ghRsp, hints, qResults, tmpAlgoFactory).invoke();
+                BuilderForQueryGraphAndWeightingWithCHEnabled builderForQueryGraphAndWeightingWithCHEnabled =
+                        new BuilderForQueryGraphAndWeightingWithCHEnabled(request, ghRsp, hints, qResults, tmpAlgoFactory).invoke();
                 if (builderForQueryGraphAndWeightingWithCHEnabled.is()) {
                     myResult = true;
                     return this;
@@ -1426,7 +1488,8 @@ BuilderForWeightingAndQueryGraph invoke() {
                 weighting = builderForQueryGraphAndWeightingWithCHEnabled.getWeighting();
                 queryGraph = builderForQueryGraphAndWeightingWithCHEnabled.getQueryGraph();
             } else {
-                BuilderForQueryGraphAndWeightingWithCHDisabled builderForQueryGraphAndWeightingWithCHDisabled = new BuilderForQueryGraphAndWeightingWithCHDisabled(hints, encoder, points, qResults).invoke();
+                BuilderForQueryGraphAndWeightingWithCHDisabled builderForQueryGraphAndWeightingWithCHDisabled =
+                        new BuilderForQueryGraphAndWeightingWithCHDisabled(hints, encoder, points, qResults).invoke();
                 weighting = builderForQueryGraphAndWeightingWithCHDisabled.getWeighting();
                 queryGraph = builderForQueryGraphAndWeightingWithCHDisabled.getQueryGraph();
             }
