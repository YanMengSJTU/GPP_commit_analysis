diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index 619593b90e..cd681a4e8d 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.util.NotThreadSafe;
 
 import java.util.List;
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
new file mode 100644
index 0000000000..802d25694d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
@@ -0,0 +1,69 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.template.RoutingTemplate;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ManyToManyRouting {
+    private final List<Integer> nodesToConsiderForRouting;
+    private final List<Integer> nodesToBuildRoutesWith;
+    private final List<Path> allFoundPaths;
+    private final QueryGraph queryGraph;
+    private final RoutingAlgorithmFactory routingAlgorithmFactory;
+    private final AlgorithmOptions algorithmOptions;
+
+    public ManyToManyRouting(final List<Integer> nodesToConsiderForRouting, final List<Integer> nodesToBuildRoutesWith,
+                             Graph graph, RoutingAlgorithmFactory routingAlgorithmFactory, AlgorithmOptions algorithmOptions) {
+        this.nodesToConsiderForRouting = nodesToConsiderForRouting;
+        this.nodesToBuildRoutesWith = nodesToBuildRoutesWith;
+        this.allFoundPaths = new ArrayList<>(nodesToBuildRoutesWith.size() * nodesToBuildRoutesWith.size());
+        this.queryGraph = new QueryGraph(graph);
+        this.routingAlgorithmFactory = routingAlgorithmFactory;
+        this.algorithmOptions = algorithmOptions;
+    }
+
+    public void lookup(RoutingTemplate routingTemplate, NodeAccess nodeAccess, FlagEncoder flagEncoder) {
+        List<GHPoint> pointsOfNodes = allNodeIDsToGHPoints(nodeAccess);
+        addLookupResultsToQueryGraph(routingTemplate, flagEncoder, pointsOfNodes);
+    }
+
+    private List<GHPoint> allNodeIDsToGHPoints(NodeAccess nodeAccess) {
+        final List<GHPoint> pointsOfNodes = new ArrayList<>(this.nodesToBuildRoutesWith.size());
+
+        for (final int nodeId : this.nodesToBuildRoutesWith) {
+            pointsOfNodes.add(new GHPoint(nodeAccess.getLatitude(nodeId), nodeAccess.getLongitude(nodeId)));
+        }
+        return pointsOfNodes;
+    }
+
+    private void addLookupResultsToQueryGraph(RoutingTemplate routingTemplate, FlagEncoder flagEncoder, List<GHPoint> pointsOfNodes) {
+        final List<QueryResult> queryResults = routingTemplate.lookup(pointsOfNodes, flagEncoder);
+        this.queryGraph.lookup(queryResults);
+    }
+
+    public void findAllPathsBetweenEntryExitPoints() {
+        if (allFoundPaths.size() > 0) {
+            throw new IllegalStateException("The algorithm was already run. Retrieve results with getAllPaths() or invoke clear first");
+        }
+
+        for (int fromNode : nodesToBuildRoutesWith) {
+            final OneToManyRouting oneToManyRouting = new OneToManyRouting(fromNode, this.nodesToBuildRoutesWith, nodesToConsiderForRouting, this.queryGraph, this.routingAlgorithmFactory, this.algorithmOptions);
+            oneToManyRouting.calcAllPaths();
+            this.allFoundPaths.addAll(oneToManyRouting.getAllFoundPaths());
+        }
+    }
+
+    public void clear() {
+        this.allFoundPaths.clear();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
new file mode 100644
index 0000000000..7cced25caf
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -0,0 +1,82 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.template.RoutingTemplate;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class OneToManyRouting {
+    private final int fromNode;
+    private final List<Integer> toNodes;
+    private final List<Integer> nodesToConsiderForRouting;
+    private final QueryGraph queryGraph;
+    private final RoutingAlgorithmFactory routingAlgorithmFactory;
+    private final AlgorithmOptions algorithmOptions;
+    private final List<Path> allFoundPaths;
+
+    public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<Integer> nodesToConsiderForRouting, final QueryGraph queryGraph,
+                            final RoutingAlgorithmFactory routingAlgorithmFactory, final AlgorithmOptions algorithmOptions) {
+        this.fromNode = fromNode;
+        this.toNodes = toNodes;
+        this.allFoundPaths = new ArrayList<>(toNodes.size());
+        this.nodesToConsiderForRouting = nodesToConsiderForRouting;
+        this.queryGraph = queryGraph;
+        this.routingAlgorithmFactory = routingAlgorithmFactory;
+        this.algorithmOptions = algorithmOptions;
+    }
+
+    public void calcAllPaths() {
+        for (final int toNode : toNodes) {
+            final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
+            final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
+            this.allFoundPaths.add(path);
+        }
+    }
+
+    private RoutingAlgorithm buildRoutingAlgorithmForFromToPair(int toNode) {
+        final AbstractRoutingAlgorithm routingAlgorithm = (AbstractRoutingAlgorithm) routingAlgorithmFactory.createAlgo(queryGraph, algorithmOptions);
+        final EdgeFilter considerableNodesEdgeFilter = new NodesToConsiderEdgeFilter(this.nodesToConsiderForRouting, fromNode, toNode);
+        routingAlgorithm.setEdgeFilter(considerableNodesEdgeFilter);
+        return routingAlgorithm;
+    }
+
+    public List<Path> getAllFoundPaths() {
+        return this.getAllFoundPaths();
+    }
+
+    private class NodesToConsiderEdgeFilter implements EdgeFilter {
+        List<Integer> nodesToConsiderInclusiveStartEndPoint;
+
+        public NodesToConsiderEdgeFilter(final List<Integer> nodesToConsiderForRouting, final int fromNode, final int toNode) {
+            prepareConsiderableNodesList(nodesToConsiderForRouting, fromNode, toNode);
+        }
+
+        private void prepareConsiderableNodesList(List<Integer> nodesToConsiderForRouting, int fromNode, int toNode) {
+            this.nodesToConsiderInclusiveStartEndPoint = new ArrayList<>(nodesToConsiderForRouting.size() + 2);
+            this.nodesToConsiderInclusiveStartEndPoint.addAll(nodesToConsiderForRouting);
+            this.nodesToConsiderInclusiveStartEndPoint.add(fromNode);
+            this.nodesToConsiderInclusiveStartEndPoint.add(toNode);
+        }
+
+        @Override
+        public boolean accept(EdgeIteratorState edgeState) {
+            final int fromNode = edgeState.getBaseNode();
+            final int toNode = edgeState.getAdjNode();
+
+            return areBothNodesConsiderable(fromNode, toNode);
+        }
+
+        private boolean areBothNodesConsiderable(int fromNode, int toNode) {
+            return this.nodesToConsiderInclusiveStartEndPoint.contains(fromNode) && this.nodesToConsiderInclusiveStartEndPoint.contains(toNode);
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
index fb38b456b2..242cef130c 100644
--- a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
@@ -28,8 +28,7 @@ public void quickStartingTest() {
         final RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.testGraph.locationIndex, this.testGraph.nodeAccess, this.testGraph.graph,
                                                                             this.testGraph.encodingManager);
         final RoutingAlgorithmFactory algorithmFactory = new RoutingAlgorithmFactorySimple();
-        final AlgorithmOptions algorithmOptions = buildAlgorithmOptions(testGraph.algorithmHints, this.testGraph.traversalMode, this.testGraph.algorithmName,
-                                                                       this.testGraph.weighting, maxVisitedNodes);
+        final AlgorithmOptions algorithmOptions = testGraph.algorithmOptions;
         final QueryGraph queryGraph = createQueryGraph(request, routingTemplate);
 
         List<Path> paths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algorithmOptions);
@@ -57,14 +56,6 @@ public void showAllEdgesWithIDs() {
         }
     }
 
-    private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
-        return AlgorithmOptions.start().
-                algorithm(algoStr).traversalMode(tMode).weighting(weighting).
-                maxVisitedNodes(maxVisitedNodesForRequest).
-                hints(hints).
-                build();
-    }
-
     private GHRequest buildRequest(GHPoint... startViaEndPoints) {
         List<GHPoint> startViaEndPointList = convertPointsToListFormat(startViaEndPoints);
         String vehicleStr = "car";
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
new file mode 100644
index 0000000000..9886af55fc
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
@@ -0,0 +1,97 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static junit.framework.TestCase.assertTrue;
+
+public class OneToManyRoutingTest {
+    private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
+    private final QueryGraph queryGraph = new QueryGraph(graphMocker.graph);
+    private OneToManyRouting oneToManyRouting;
+
+    @Before
+    public void setupOneToManyRouting() {
+        final int fromNode = 28;
+        final List<Integer> toNodes = prepareToNodes();
+        final List<Integer> nodesToConsiderForRouting = prepareInteriorGraph();
+        final RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
+        final AlgorithmOptions algorithmOptions = this.graphMocker.algorithmOptions;
+
+        this.prepareQueryGraph(fromNode, toNodes);
+        this.oneToManyRouting = new OneToManyRouting(fromNode, toNodes, nodesToConsiderForRouting, queryGraph, routingAlgorithmFactory, algorithmOptions);
+        this.oneToManyRouting.calcAllPaths();
+    }
+
+    private List<Integer> prepareToNodes() {
+        final Integer[] toNodesArray = new Integer[] {32, 40, 45};
+        return new ArrayList<>(Arrays.asList(toNodesArray));
+    }
+
+    private List<Integer> prepareInteriorGraph() {
+        final Integer[] nodesToConsiderForRoutingArray = new Integer[] {46 ,47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57};
+        return new ArrayList<>(Arrays.asList(nodesToConsiderForRoutingArray));
+    }
+
+    private void prepareQueryGraph(final int fromNode, final List<Integer> toNodes) {
+        List<Integer> allNodes = prepareAllNodesList(fromNode, toNodes);
+
+        List<QueryResult> queryResults = getQueryResults( allNodes);
+        this.queryGraph.lookup(queryResults);
+    }
+
+    private List<Integer> prepareAllNodesList(int fromNode, List<Integer> toNodes) {
+        final List<Integer> allNodes = new ArrayList<>(toNodes.size() + 1);
+        allNodes.add(fromNode);
+        allNodes.addAll(toNodes);
+        return allNodes;
+    }
+
+    private List<QueryResult> getQueryResults(List<Integer> allNodes) {
+        final List <QueryResult> queryResults = new ArrayList<>(allNodes.size());
+
+        for (final int node : allNodes) {
+            final double latitude = this.graphMocker.nodeAccess.getLatitude(node);
+            final double longitude = this.graphMocker.nodeAccess.getLongitude(node);
+
+            QueryResult queryResult = new QueryResult(latitude, longitude);
+            queryResult.setClosestNode(node);
+            queryResults.add(queryResult);
+        }
+        return queryResults;
+    }
+
+    @Test
+    public void validateFirstPath() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(0);
+
+        final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 48, 49,32}));
+        final List<Integer> secondPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 55, 49,32}));
+
+        assertTrue(nodesInPathOrder.equals(firstPathOption) || nodesInPathOrder.equals(secondPathOption));
+    }
+
+    @Test
+    public void validateSecondPath() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(1);
+
+    }
+
+    @Test
+    public void validateThirdPath() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(2);
+
+    }
+
+    private List<Integer> retrieveFoundPathsNode(final int index) {
+        return this.oneToManyRouting.getAllFoundPaths().get(index).getNodesInPathOrder();
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
index 1f14960f4b..fa531c4775 100644
--- a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
+++ b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
@@ -1,6 +1,7 @@
 package com.graphhopper.routing.template.util;
 
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
@@ -15,6 +16,8 @@
 import com.graphhopper.util.shapes.Polygon;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
+import static com.graphhopper.util.Parameters.Routing.MAX_VISITED_NODES;
+
 public class PolygonRoutingTestGraph {
     private final TurnCostExtension turnCostExtension;
     private Node[] nodes;
@@ -29,6 +32,7 @@
     public String algorithmName;
     public HintsMap algorithmHints;
     public Weighting weighting;
+    public AlgorithmOptions algorithmOptions;
 
     public PolygonRoutingTestGraph() {
         this.turnCostExtension = new TurnCostExtension();
@@ -42,6 +46,7 @@ public PolygonRoutingTestGraph() {
         this.setAlgorithmName();
         this.buildHintsMap();
         this.setWeighting();
+        this.setAlgorithmOptions();
     }
 
     private GraphHopperStorage createPolygonTestGraph() {
@@ -460,4 +465,13 @@ private void buildHintsMap() {
     private void setWeighting() {
         this.weighting = new FastestWeighting(this.flagEncoder, this.algorithmHints);
     }
+
+    private void setAlgorithmOptions() {
+        final int maxVisitedNodes = this.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
+        this.algorithmOptions =  AlgorithmOptions.start().
+                algorithm(algorithmName).traversalMode(traversalMode).weighting(weighting).
+                maxVisitedNodes(maxVisitedNodes).
+                hints(algorithmHints).
+                build();
+    }
 }
