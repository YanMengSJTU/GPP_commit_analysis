diff --git a/config-example.properties b/config-example.properties
index b906cb8c6f..5d91a61255 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -18,7 +18,7 @@ prepare.chShortcuts=fastest
 # prepare.updates.periodic=3
 # prepare.updates.lazy=10
 # prepare.updates.neighbor=20
-
+# prepare.minOnewayNetworkSize=200
 
 # increase from 1 to 5, to reduce way geometry e.g. for android
 osmreader.wayPointMaxDistance=1
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index ac06263d1d..8b94827eae 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -82,6 +82,7 @@ public static void main( String[] strs ) throws Exception
     private boolean searchRegion = true;
     // for prepare
     private int minNetworkSize = 200;
+    private int minOnewayNetworkSize = 0;
     // for CH prepare
     private AlgorithmPreparation prepare;
     private boolean doPrepare = true;
@@ -521,6 +522,7 @@ public GraphHopper init( CmdArgs args )
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
@@ -981,6 +983,7 @@ protected void cleanUp()
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
+        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 009db0927c..592f889b21 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -23,6 +23,7 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.XFirstSearch;
 import java.util.*;
 import java.util.Map.Entry;
@@ -43,8 +44,10 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
+    private int minOnewayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
+    private final EncodingManager encodingManager;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
@@ -55,6 +58,7 @@ else if (em.getVehicleCount() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
             edgeFilter = new DefaultEdgeFilter(em.getSingle());
+        this.encodingManager = em;
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -62,13 +66,24 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         this.minNetworkSize = minNetworkSize;
         return this;
     }
+    public PrepareRoutingSubnetworks setMinOnewayNetworkSize( int minOnewayNetworkSize )
+    {
+        this.minOnewayNetworkSize = minOnewayNetworkSize;
+        return this;
+    }
 
     public void doWork()
     {
         int del = removeZeroDegreeNodes();
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
+
+        int unvisitedDeadEnds = 0;
+        if ((this.minOnewayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(g, this.encodingManager.getSingle(), this.minOnewayNetworkSize, logger);
+
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
+                + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
                 + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
         g.optimize();
         subNetworks = map.size();
@@ -80,12 +95,21 @@ public int getSubNetworks()
     }
 
     public Map<Integer, Integer> findSubnetworks()
+    {
+        return findSubnetworks(g, g.createEdgeExplorer(edgeFilter), maxEdgesPerNode);
+    }
+    
+    private static Map<Integer, Integer> findSubnetworks(final GraphStorage g, final EdgeExplorer explorer)
+    {
+        return findSubnetworks(g, explorer, new AtomicInteger(0));
+    }
+
+    private static Map<Integer, Integer> findSubnetworks(final GraphStorage g, final EdgeExplorer explorer, final AtomicInteger maxEdgesPerNode)
     {
         final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
         final AtomicInteger integ = new AtomicInteger(0);
         int locs = g.getNodes();
         final GHBitSet bs = new GHBitSetImpl(locs);
-        EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
         for (int start = 0; start < locs; start++)
         {
             if (g.isNodeRemoved(start) || bs.contains(start))
@@ -209,4 +233,96 @@ int removeZeroDegreeNodes()
         }
         return removed;
     }
+    
+    /**
+     * Clean small networks that will be never be visited by this explorer
+     * See #86
+     * For example, small areas like parkings are sometimes connected to the whole network through one-way road
+     * This is clearly an error - but is causes the routing to fail when point get connected to this small area
+     * This routines removed all these points from the graph
+     * The algorithm is to through the graph, build the network map and for each small map remove the network
+     * <p/>
+     * @return removed nodes;
+     */
+    public static int removeDeadEndUnvisitedNetworks(final GraphStorage g, final FlagEncoder encoder, final int minOnewayNetworkSize, final Logger logger)
+    {
+        int removed = 0;
+
+        StopWatch sw = new StopWatch().start();
+        logger.info("removeDeadEndUnvisitedNetworks: searching forward");
+        removed += removeDeadEndUnvisitedNetworks(g, g.createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false)), minOnewayNetworkSize, logger);
+        logger.info("removeDeadEndUnvisitedNetworks: forward search completed in " + sw.stop().getSeconds() + "s");
+        
+        sw.start();
+        logger.info("removeDeadEndUnvisitedNetworks: searching backward");
+        removed += removeDeadEndUnvisitedNetworks(g, g.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true)), minOnewayNetworkSize, logger);
+        logger.info("removeDeadEndUnvisitedNetworks: backward search completed in " + sw.stop().getSeconds() + "s");
+
+        return removed;
+    }
+    
+    private static <K, V extends Comparable<V>> Map<K, V> sortByValues(final Map<K, V> map)
+    {
+        Comparator<K> valueComparator =  new Comparator<K>() {
+            public int compare(K k1, K k2)
+            {
+                int compare = map.get(k2).compareTo(map.get(k1));
+                if (compare == 0) return 1;
+                else return compare;
+            }
+        };
+        Map<K, V> sortedByValues = new TreeMap<K, V>(valueComparator);
+        sortedByValues.putAll(map);
+        return sortedByValues;
+    }
+    
+    public static int removeDeadEndUnvisitedNetworks(final GraphStorage g, final EdgeExplorer explorer, final int minOnewayNetworkSize, final Logger logger)
+    {
+        final AtomicInteger removed = new AtomicInteger(0);
+        
+        // Lest find subnetworks according to this explorer
+        // Sort the map by largest networks first
+        Map<Integer, Integer> map = sortByValues(findSubnetworks(g, explorer));
+        if (map.size() < 2)
+            return 0;
+        
+        //  big networks will populate bs first so these nodes won't be deleted
+        final GHBitSetImpl bs = new GHBitSetImpl(g.getNodes());
+        boolean first = true;
+        for (Entry<Integer, Integer> e : map.entrySet())
+        {
+            int mapStart = e.getKey();
+            int subnetSize = e.getValue();
+            
+            final boolean removeNetwork = (!first) && (subnetSize < minOnewayNetworkSize);
+            if (first)
+                first = false;
+            
+            if (removeNetwork)
+                logger.debug("Removing dead-end network: " + subnetSize  + " nodes starting from nodeid=" + mapStart);
+
+            new XFirstSearch()
+            {
+                @Override
+                protected GHBitSet createBitSet()
+                {
+                    return bs;
+                }
+
+                @Override
+                protected final boolean goFurther(int nodeId)
+                {
+                    if (removeNetwork)
+                    {
+                        // This remaining node is member of a small disconnected network
+                        g.markNodeRemoved(nodeId);
+                        removed.incrementAndGet();
+                    }
+                    return super.goFurther(nodeId);
+                }
+            }.start(explorer, mapStart, false);
+        }
+
+        return removed.get();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 14bae49835..f205e39bf7 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -450,9 +450,12 @@ public void testPrepareOnly()
     public void testVia()
     {
         instance = new GraphHopper().setInMemory(true).
-                setEncodingManager(new EncodingManager("CAR")).
-                setGraphHopperLocation(ghLoc).
-                setOSMFile(testOsm3);
+                init(
+                new CmdArgs().
+                put("prepare.minNetworkSize", "1").
+                put("osmreader.acceptWay", "CAR").
+                put("osmreader.osm", testOsm3)).
+                setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
         // A -> B -> C
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index f172436b74..8e4fbb93af 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -17,16 +17,17 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
 import java.util.Arrays;
 import java.util.Map;
+import static javax.swing.text.html.HTML.Tag.I;
 import org.junit.*;
 import static org.junit.Assert.*;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  *
@@ -148,4 +149,51 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         g.optimize();
         assertEquals(7, g.getNodes());
     }
+
+    GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
+    {
+        GraphStorage g = createGraph(em);
+        // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(5, 4, 1, false);
+        g.edge(5, 6, 1, true);
+
+        // 7 -> 8 <-> 9 <-> 10
+        g.edge(7, 8, 1, false);
+        g.edge(8, 9, 1, true);
+        g.edge(9, 10, 1, true);
+        return g;
+    }
+
+    @Test
+    public void testRemoveDeadEndUnvisitedNetworksOneWay()
+    {
+        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        Logger logger = LoggerFactory.getLogger(getClass());
+        FlagEncoder encoder = new EncodingManager("CAR").getSingle();
+
+        EdgeExplorer explorer = g.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+        int removed = PrepareRoutingSubnetworks.removeDeadEndUnvisitedNetworks(g, explorer, 3, logger);
+        assertEquals(2, removed);
+
+        g.optimize();
+        assertEquals(9, g.getNodes());
+    }
+
+    @Test
+    public void testRemoveDeadEndUnvisitedNetworks()
+    {
+        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        Logger logger = LoggerFactory.getLogger(getClass());
+        FlagEncoder encoder = new EncodingManager("CAR").getSingle();
+
+        int removed = PrepareRoutingSubnetworks.removeDeadEndUnvisitedNetworks(g, encoder, 3, logger);
+        assertEquals(3, removed);
+
+        g.optimize();
+        assertEquals(8, g.getNodes());
+    }
 }
