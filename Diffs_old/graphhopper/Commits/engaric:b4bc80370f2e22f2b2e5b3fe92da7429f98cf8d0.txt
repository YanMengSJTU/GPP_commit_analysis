diff --git a/tools/src/main/java/com/graphhopper/tools/routeExtractor/AbstractProblemRouteExtractor.java b/tools/src/main/java/com/graphhopper/tools/routeExtractor/AbstractProblemRouteExtractor.java
new file mode 100644
index 0000000000..f56c9a9b69
--- /dev/null
+++ b/tools/src/main/java/com/graphhopper/tools/routeExtractor/AbstractProblemRouteExtractor.java
@@ -0,0 +1,339 @@
+package com.graphhopper.tools.routeExtractor;
+
+import gnu.trove.TLongCollection;
+import gnu.trove.list.TLongList;
+import gnu.trove.list.array.TLongArrayList;
+import gnu.trove.procedure.TLongProcedure;
+import gnu.trove.set.TLongSet;
+import gnu.trove.set.hash.TLongHashSet;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+import javax.xml.xpath.XPathExpressionException;
+
+import org.opengis.geometry.MismatchedDimensionException;
+import org.opengis.referencing.FactoryException;
+import org.opengis.referencing.operation.TransformException;
+import org.xml.sax.SAXException;
+
+import com.graphhopper.reader.OSMElement;
+import com.graphhopper.reader.Relation;
+import com.graphhopper.reader.RelationMember;
+import com.graphhopper.reader.RoutingElement;
+import com.graphhopper.reader.Way;
+import com.graphhopper.reader.osgb.OsItnInputFile;
+import com.graphhopper.util.Helper;
+//import com.graphhopper.tools.OsITNProblemRouteExtractor.ProcessFileVisitor;
+//import com.graphhopper.tools.OsITNProblemRouteExtractor.ProcessVisitor;
+//import com.graphhopper.tools.OsITNProblemRouteExtractor.WayNodeProcess;
+
+abstract public class AbstractProblemRouteExtractor {
+    private OsItnInputFile file;
+    protected String workingStore;
+    protected TLongSet testNodeSet = new TLongHashSet(30);
+    protected TLongCollection fullWayList = new TLongArrayList(100);
+    protected TLongCollection fullNodeList = new TLongArrayList(200);
+    protected final TLongCollection otherEndOfWayNodeList = new TLongArrayList(200);
+    protected final TLongCollection roadFidList = new TLongHashSet(200);
+    protected Set<String> notHighwaySet = new HashSet<String>();
+
+    protected abstract class WayNodeProcess implements TLongProcedure {
+        protected final long end;
+        protected final RoutingElement item;
+        protected final long start;
+
+        public WayNodeProcess(final long end, final RoutingElement item, final long start) {
+            this.end = end;
+            this.item = item;
+            this.start = start;
+        }
+
+    }
+
+    public abstract class ProcessVisitor<T> {
+        abstract void processVisitor(T element) throws XMLStreamException, IOException, ParserConfigurationException, SAXException, TransformerConfigurationException, TransformerException, XPathExpressionException, MismatchedDimensionException, FactoryException, TransformException;
+    }
+
+    protected abstract class ProcessFileVisitor<T> extends ProcessVisitor<File> {
+        protected ProcessVisitor<T> innerProcess;
+
+        void setInnerProcess(final ProcessVisitor<T> process) {
+            innerProcess = process;
+        }
+    }
+    
+  
+
+    protected  ProcessFileVisitor<RoutingElement> fileProcessProcessor = new ProcessFileVisitor<RoutingElement>() {
+
+        @Override
+        void processVisitor(final File file) throws XMLStreamException, IOException, TransformerConfigurationException, ParserConfigurationException, SAXException, TransformerException, XPathExpressionException, MismatchedDimensionException, FactoryException, TransformException {
+            OsItnInputFile in = null;
+            try {
+                in = new OsItnInputFile(file).setWorkerThreads(1).open();
+                RoutingElement item;
+                while ((item = in.getNext()) != null) {
+                    innerProcess.processVisitor(item);
+                }
+            } finally {
+                Helper.close(in);
+            }
+        }
+    };
+
+
+    protected final ProcessVisitor<RoutingElement> extractNodeIds = new ProcessVisitor<RoutingElement>() {
+
+        @Override
+        void processVisitor(final RoutingElement item) {
+            if (item.isType(OSMElement.WAY)) {
+                final Way way = (Way) item;
+                if (item.hasTag("nothighway")) {
+                    notHighwaySet.add(item.getTag("nothighway"));
+                }
+                if (fullWayList.contains(way.getId())) {
+                    final TLongList nodes = way.getNodes();
+                    final long startNode = nodes.get(0);
+                    final long endNode = nodes.get(nodes.size() - 1);
+                    // System.out.println("Add start: " + startNode + " end: " +
+                    // endNode);
+                    fullNodeList.add(startNode);
+                    fullNodeList.add(endNode);
+                }
+            }
+        }
+    };
+
+    private final ProcessVisitor<RoutingElement> extractWayIdLinkedToNodes = new ProcessVisitor<RoutingElement>() {
+        @Override
+        void processVisitor(final RoutingElement item) {
+            if (item.isType(OSMElement.WAY)) {
+                final Way way = (Way) item;
+                final TLongList nodes = way.getNodes();
+                final long start = nodes.get(0);
+                final long end = nodes.get(nodes.size() - 1);
+                final TLongProcedure addWayIfNodeExists = new WayNodeProcess(end, item, start) {
+                    @Override
+                    public boolean execute(final long testNode) {
+                        if ((testNode == start) || (testNode == end)) {
+                            // ADD THE OTHER END IN TO OUR new collection
+                            final long otherEnd = testNode == start ? end : start;
+                            otherEndOfWayNodeList.add(otherEnd);
+
+                            fullWayList.add(item.getId());
+
+                            return false;
+                        }
+                        return true;
+                    }
+                };
+                origFullNodeList.forEach(addWayIfNodeExists);
+            }
+        }
+    };
+
+    private final ProcessVisitor<RoutingElement> extractRelationsAtJunctionOfBothRoads = new ProcessVisitor<RoutingElement>() {
+        @Override
+        void processVisitor(final RoutingElement item) {
+            if (item.isType(OSMElement.RELATION)) {
+                final Relation rel = (Relation) item;
+                final ArrayList<? extends RelationMember> links = rel.getMembers();
+                final long start = links.get(0).ref();
+                final long end = links.get(links.size() - 1).ref();
+                final TLongProcedure addRelIfWayExists = new WayNodeProcess(end, item, start) {
+                    @Override
+                    public boolean execute(final long testNode) {
+                        if ((testNode == start) || (testNode == end)) {
+                            relationList.add(rel.getId());
+                            return false;
+                        }
+                        return true;
+                    }
+                };
+                fullWayList.forEach(addRelIfWayExists);
+            }
+        }
+    };
+
+    protected final ProcessVisitor<File> extractProcessor = new ProcessVisitor<File>() {
+        @Override
+        void processVisitor(final File element) throws XMLStreamException, IOException, ParserConfigurationException, SAXException, TransformerException, XPathExpressionException {
+            final OsItnInputFile itn = new OsItnInputFile(element);
+            final InputStream bis = itn.getInputStream();
+            final TLongArrayList fidList = new TLongArrayList(relationList);
+            System.out.println("Output " + fullWayList.size() + " ways ");
+            fidList.addAll(fullWayList);
+            System.out.println("Output " + origFullNodeList.size() + " nodes ");
+            fidList.addAll(origFullNodeList);
+            // ADD IN OUR ADDITIONAL NODE LIST HERE
+            System.out.println("Output " + otherEndOfWayNodeList.size() + " otherEndOfWayNodeList nodes ");
+            fidList.addAll(otherEndOfWayNodeList);
+            System.out.println("Output " + roadFidList.size() + " roads ");
+            roadFidList.forEach(new TLongProcedure(){
+
+                @Override
+                public boolean execute(long value) {
+                    System.out.println("Fid is " + value);
+                    return true;
+                }});           
+            fidList.addAll(roadFidList);
+
+            outputListedFids(fidList, bis);
+        };
+
+        private void outputListedFids(final TLongArrayList fidList, final InputStream bis) throws XMLStreamException, NumberFormatException, IOException {
+            boolean output = false;
+
+            final BufferedReader bir = new BufferedReader(new InputStreamReader(bis));
+            String lastLine = "";
+            while (bir.ready()) {
+                final String line = bir.readLine();
+
+                if (output) {
+                    outputWriter.println(line);
+                    if (isEndBlock(line)) {
+                        output = false;
+                        outputWriter.flush();
+                    }
+                }
+                if (!output && line.contains("fid='osgb")) {
+                    final String idStr = line.substring(line.indexOf("fid='osgb") + 9, line.lastIndexOf('\''));
+                    final long checkFid = Long.parseLong(idStr);
+                    if (fidList.contains(checkFid)) {
+                        output = true;
+                        outputWriter.println(lastLine);
+                        outputWriter.println(line);
+                    }
+                }
+                lastLine = line;
+            }
+        }
+
+        private boolean isEndBlock(final String curLine) {
+            boolean endBlock = false;
+            switch (curLine) {
+            case "</osgb:networkMember>":
+            case "</osgb:roadInformationMember>":
+            case "</osgb:roadMember>": {
+                endBlock = true;
+                break;
+            }
+            }
+            return endBlock;
+        }
+    };
+
+    protected TLongCollection origFullNodeList;
+    protected TLongCollection origFullWayList;
+    protected TLongProcedure nodeOutput;
+    protected TLongProcedure wayOutput;
+    protected TLongArrayList relationList;
+    protected TLongProcedure relOutput;
+    protected PrintWriter outputWriter;
+
+    public AbstractProblemRouteExtractor(String fileOrDirName) {
+        workingStore = fileOrDirName;
+    }
+    abstract public void process(final String outputFileName) throws TransformerException, ParserConfigurationException, SAXException, XPathExpressionException, XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException;
+
+    protected void prepareOutputMethods() {
+        nodeOutput = new TLongProcedure() {
+            @Override
+            public boolean execute(final long arg0) {
+                System.err.println("node:" + arg0);
+                return true;
+            }
+        };
+
+        wayOutput = new TLongProcedure() {
+            @Override
+            public boolean execute(final long arg0) {
+                System.err.println("way:" + arg0);
+                return true;
+            }
+        };
+
+        relOutput = new TLongProcedure() {
+            @Override
+            public boolean execute(final long arg0) {
+                System.err.println("rel:" + arg0);
+                return true;
+            }
+        };
+    }
+
+
+
+    protected void findRelationsAtJunctionOfBothRoads(final File itnFile) {
+        System.out.println("findRelationsAtJunctionOfBothRoads");
+        relationList = new TLongArrayList(30);
+        fileProcessProcessor.setInnerProcess(extractRelationsAtJunctionOfBothRoads);
+        process(itnFile, fileProcessProcessor);
+    }
+
+    protected void findWaysLinkedAtJunctionOfBothRoads(final File itnFile) {
+        System.out.println("findWaysLinkedAtJunctionOfBothRoads");
+        fullWayList = new TLongArrayList(30);
+        fullNodeList = origFullNodeList;
+        fileProcessProcessor.setInnerProcess(extractWayIdLinkedToNodes);
+        process(itnFile, fileProcessProcessor);
+    }
+
+    protected void findNodesOnBothWays(final File itnFile) {
+        System.err.println("STAGE FOUR - findNodesOnBothWays");
+        fileProcessProcessor.setInnerProcess(extractNodeIds);
+        process(itnFile, fileProcessProcessor);
+        origFullNodeList.retainAll(fullNodeList);
+    }
+
+    protected void process(final File itnFile, final ProcessVisitor<File> processVisitor) {
+        try {
+            processDirOrFile(itnFile, processVisitor);
+        } catch (final Exception ex) {
+            throw new RuntimeException("Problem while parsing file", ex);
+        }
+    }
+
+    protected void processDirOrFile(final File osmFile, final ProcessVisitor<File> processVisitor) throws XMLStreamException, IOException, TransformerConfigurationException, ParserConfigurationException, SAXException, TransformerException, XPathExpressionException, MismatchedDimensionException, FactoryException, TransformException {
+        if (osmFile.isDirectory()) {
+            final String absolutePath = osmFile.getAbsolutePath();
+            final String[] list = osmFile.list();
+            for (final String file : list) {
+                final File nextFile = new File(absolutePath + File.separator + file);
+                processDirOrFile(nextFile, processVisitor);
+            }
+        } else {
+            processSingleFile(osmFile, processVisitor);
+        }
+    }
+
+    private void processSingleFile(final File osmFile, final ProcessVisitor<File> processVisitor) throws XMLStreamException, IOException, TransformerConfigurationException, ParserConfigurationException, SAXException, TransformerException, XPathExpressionException, MismatchedDimensionException, FactoryException, TransformException {
+        processVisitor.processVisitor(osmFile);
+    }
+
+    protected void prepareNameRelation(final Relation relation, final TLongCollection wayList) {
+        final ArrayList<? extends RelationMember> members = relation.getMembers();
+        for (final RelationMember relationMember : members) {
+            // System.out.println("\t Add way member: " + relationMember.ref());
+            wayList.add(relationMember.ref());
+        }
+    }
+
+    private void prepareWaysWithRelationInfo(final Relation relation) {
+        // TODO Auto-generated method stub
+
+    }
+
+}
diff --git a/tools/src/main/java/com/graphhopper/tools/routeExtractor/NodeListRouteExtractor.java b/tools/src/main/java/com/graphhopper/tools/routeExtractor/NodeListRouteExtractor.java
new file mode 100644
index 0000000000..d1406ac71d
--- /dev/null
+++ b/tools/src/main/java/com/graphhopper/tools/routeExtractor/NodeListRouteExtractor.java
@@ -0,0 +1,227 @@
+package com.graphhopper.tools.routeExtractor;
+
+import gnu.trove.list.TLongList;
+import gnu.trove.list.array.TLongArrayList;
+import gnu.trove.procedure.TLongProcedure;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.TransformerException;
+import javax.xml.xpath.XPathExpressionException;
+
+import org.opengis.geometry.MismatchedDimensionException;
+import org.opengis.referencing.FactoryException;
+import org.opengis.referencing.operation.TransformException;
+import org.xml.sax.SAXException;
+
+import com.graphhopper.reader.OSMElement;
+import com.graphhopper.reader.Relation;
+import com.graphhopper.reader.RelationMember;
+import com.graphhopper.reader.RoutingElement;
+import com.graphhopper.reader.Way;
+
+public class NodeListRouteExtractor extends AbstractProblemRouteExtractor {
+
+    private String nodeListString;
+
+    // private TLongSet nodeList = null;
+
+    // private final ProcessVisitor<RoutingElement> extractWayIdLinkedToNodeList
+    // = new ProcessVisitor<RoutingElement>() {
+    // @Override
+    // void processVisitor(final RoutingElement item) {
+    // if (item.isType(OSMElement.WAY)) {
+    // final Way way = (Way) item;
+    // final TLongList nodes = way.getNodes();
+    // final long start = nodes.get(0);
+    // final long end = nodes.get(nodes.size() - 1);
+    // final TLongProcedure addWayIfNodeExists = new WayNodeProcess(end, item,
+    // start) {
+    // @Override
+    // public boolean execute(final long testNode) {
+    // if ((testNode == start) || (testNode == end)) {
+    // // ADD THE OTHER END IN TO OUR new collection
+    // final long otherEnd = testNode == start ? end : start;
+    // otherEndOfWayNodeList.add(otherEnd);
+    //
+    // fullWayList.add(item.getId());
+    //
+    // return false;
+    // }
+    // return true;
+    // }
+    // };
+    // nodeList.forEach(addWayIfNodeExists);
+    // }
+    // }
+    // };
+
+    protected abstract class NodeIdListProcedure implements TLongProcedure {
+        protected final TLongList nodeIds;
+        protected final RoutingElement item;
+
+        public NodeIdListProcedure(final TLongList nodeIds, final RoutingElement item) {
+            this.nodeIds = nodeIds;
+            this.item = item;
+        }
+    }
+
+    protected abstract class RoutingElementProcedure implements TLongProcedure {
+        protected final RoutingElement item;
+
+        public RoutingElementProcedure(final RoutingElement item) {
+            this.item = item;
+        }
+    }
+
+    private final ProcessVisitor<RoutingElement> extractWayIds = new ProcessVisitor<RoutingElement>() {
+        @Override
+        void processVisitor(final RoutingElement someitem) {
+
+            final TLongProcedure addWayIfNodeExists = new RoutingElementProcedure(someitem) {
+                @Override
+                public boolean execute(final long testNode) {
+                    if (item.isType(OSMElement.WAY)) {
+                        final Way way = (Way) item;
+                        if (way.getNodes().contains(testNode)) {
+                            System.out.println("\tWay found joining one of our nodes. Id: " + item.getId());
+                            // Add the way to our list of ways
+                            fullWayList.add(item.getId());
+
+                            return false;
+                        }
+                    }
+                    return true;
+                }
+            };
+            origFullNodeList.forEach(addWayIfNodeExists);
+
+        }
+    };
+    private final ProcessVisitor<RoutingElement> extractRoadLinksProcessVisitor = new ProcessVisitor<RoutingElement>() {
+        @Override
+        void processVisitor(final RoutingElement someitem) {
+
+            final TLongProcedure addWayIfNodeExists = new RoutingElementProcedure(someitem) {
+                @Override
+                public boolean execute(final long testWayId) {
+                    if (item.isType(OSMElement.RELATION)) {
+                        final Relation relation = (Relation) item;
+
+                        ArrayList<? extends RelationMember> members = relation.getMembers();
+                        for (RelationMember relationMember : members) {
+                            if (relationMember.ref() == testWayId) {
+                                System.out.println("\tRelation found for way "+testWayId+". Add the relation Id: " + relation.getId());
+                                roadFidList.add(relation.getId());
+                                return false;
+                            }
+                        }
+
+                    }
+                    return true;
+                }
+            };
+//            System.out.println("Iterate over " + origFullNodeList.size());
+            fullWayList.forEach(addWayIfNodeExists);
+
+        }
+    };
+
+    public NodeListRouteExtractor(String fileOrDirName, String nodeListString) {
+        super(fileOrDirName);
+        this.nodeListString = nodeListString;
+    }
+
+    @Override
+    public void process(String outputFileName) throws TransformerException, ParserConfigurationException, SAXException, XPathExpressionException, XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+        prepareOutputMethods();
+
+        final File itnFile = new File(workingStore);
+        // Add the specified nodes to our list
+        addRoadNodes();
+        // findWaysOnRoad(itnFile);
+
+        // findWaysLinkedAtSpecifiedNodes(itnFile);
+        findWaysLinkedAtJunctionOfBothRoads(itnFile);
+        findRelationsAtJunctionOfBothRoads(itnFile);
+        // addRoadLinksWithDirectedNodeFids(itnFile);
+        //
+        // addRoadRouteInformationForRoadLinkFids(itnFile);
+        //
+        // addRoadsWithNetworkMemberRoadLinkFids(itnFile);
+        //
+        // findNodesOfRoad(itnFile);
+
+        // if (null != workingLinkRoad) {
+        findLinkedWayIDs(itnFile);
+        // Find the road links
+        findRoadLinksForWays(itnFile);
+        findNodesOnBothWays(itnFile);
+        origFullNodeList.forEach(nodeOutput);
+//         findWaysLinkedAtJunctionOfBothRoads(itnFile);
+        fullWayList.forEach(wayOutput);
+//         findRelationsAtJunctionOfBothRoads(itnFile);
+        relationList.forEach(relOutput);
+        // } else {
+        // fullNodeList.forEach(nodeOutput);
+        // fullWayList.forEach(wayOutput);
+        // }
+
+        outputWriter = new PrintWriter(outputFileName);
+
+        outputWriter.println("<?xml version='1.0' encoding='UTF-8'?>" + "<osgb:FeatureCollection " + "xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb' " + "xmlns:gml='http://www.opengis.net/gml' " + "xmlns:xlink='http://www.w3.org/1999/xlink' " + "xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " + "xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd' " + "fid='GDS-58096-1'>"
+                + "<gml:description>Ordnance Survey, (c) Crown Copyright. All rights reserved, 2009-07-30</gml:description>" + "<gml:boundedBy><gml:null>unknown</gml:null></gml:boundedBy>" + "<osgb:queryTime>2009-07-30T02:01:07</osgb:queryTime>" + "<osgb:queryExtent>" + "<osgb:Rectangle srsName='osgb:BNG'>" + "<gml:coordinates>291000.000,92000.000 293000.000,94000.000</gml:coordinates>" + "</osgb:Rectangle>" + "</osgb:queryExtent>");
+        outputWriter.flush();
+        processDirOrFile(itnFile, extractProcessor);
+        outputWriter.println("<osgb:boundedBy>" + "<gml:Box srsName='osgb:BNG'>" + "<gml:coordinates>290822.000,91912.000 293199.000,94222.000</gml:coordinates>" + "</gml:Box>" + "</osgb:boundedBy>" + "</osgb:FeatureCollection>");
+        outputWriter.flush();
+        outputWriter.close();
+    }
+
+    private void addRoadNodes() {
+        System.out.println("Add road nodes");
+        String[] nodeStrings = nodeListString.split(",");
+        origFullNodeList = new TLongArrayList(nodeStrings.length);
+        for (int i = 0; i < nodeStrings.length; i++) {
+            origFullNodeList.add(Long.parseLong(nodeStrings[i]));
+        }
+    }
+
+    private void findWaysOnRoad(final File itnFile) {
+        System.err.println("STAGE ONE - findWaysOnRoad");
+        fileProcessProcessor.setInnerProcess(extractWayIds);
+        process(itnFile, fileProcessProcessor);
+    }
+    private void findRoadLinksForWays(final File itnFile) {
+        System.err.println("STAGE TWOish - findRoadLinksForWays");
+        fileProcessProcessor.setInnerProcess(extractRoadLinksProcessVisitor);
+        process(itnFile, fileProcessProcessor);
+    }
+
+    private void findLinkedWayIDs(final File itnFile) {
+        System.err.println("STAGE THREE - findLinkedWayIDs");
+        origFullNodeList = fullNodeList;
+        origFullWayList = fullWayList;
+        fullNodeList = new TLongArrayList(200);
+        fullWayList = new TLongArrayList(100);
+        // workingRoadName = workingLinkRoad;
+        findWaysOnRoad(itnFile);
+    }
+
+    // protected void findWaysLinkedAtSpecifiedNodes(final File itnFile) {
+    // fullWayList = new TLongArrayList(30);
+    // fullNodeList = origFullNodeList;
+    // fileProcessProcessor.setInnerProcess(extractWayIdLinkedToNodeList);
+    // process(itnFile, fileProcessProcessor);
+    // }
+    // protected void findRelationsAtJunctionOfBothRoads(final File itnFile) {
+    // relationList = new TLongArrayList(30);
+    // fileProcessProcessor.setInnerProcess(extractRelationsAtJunctionOfBothRoads);
+    // process(itnFile, fileProcessProcessor);
+    // }
+}
diff --git a/tools/src/main/java/com/graphhopper/tools/routeExtractor/TwoRoadsRouteExtractor.java b/tools/src/main/java/com/graphhopper/tools/routeExtractor/TwoRoadsRouteExtractor.java
new file mode 100644
index 0000000000..1ed5436ff1
--- /dev/null
+++ b/tools/src/main/java/com/graphhopper/tools/routeExtractor/TwoRoadsRouteExtractor.java
@@ -0,0 +1,112 @@
+package com.graphhopper.tools.routeExtractor;
+
+import gnu.trove.list.array.TLongArrayList;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.TransformerException;
+import javax.xml.xpath.XPathExpressionException;
+
+import org.opengis.geometry.MismatchedDimensionException;
+import org.opengis.referencing.FactoryException;
+import org.opengis.referencing.operation.TransformException;
+import org.xml.sax.SAXException;
+
+import com.graphhopper.reader.OSMElement;
+import com.graphhopper.reader.Relation;
+import com.graphhopper.reader.RoutingElement;
+import com.graphhopper.reader.Way;
+
+public class TwoRoadsRouteExtractor extends AbstractProblemRouteExtractor {
+    protected String workingRoadName;
+    protected String workingLinkRoad;
+    public TwoRoadsRouteExtractor(String fileOrDirName, String namedRoad, String namedLinkRoad) {
+        super(fileOrDirName);
+        workingRoadName = namedRoad;
+        workingLinkRoad = namedLinkRoad;
+    }
+    public void process(final String outputFileName) throws TransformerException, ParserConfigurationException, SAXException, XPathExpressionException, XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+        prepareOutputMethods();
+
+        final File itnFile = new File(workingStore);
+        findWaysOnRoad(itnFile);
+        findNodesOfRoad(itnFile);
+
+        if (null != workingLinkRoad) {
+            findLinkedWayIDs(itnFile);
+            findNodesOnBothWays(itnFile);
+            origFullNodeList.forEach(nodeOutput);
+            findWaysLinkedAtJunctionOfBothRoads(itnFile);
+            fullWayList.forEach(wayOutput);
+            findRelationsAtJunctionOfBothRoads(itnFile);
+            relationList.forEach(relOutput);
+        } else {
+            fullNodeList.forEach(nodeOutput);
+            fullWayList.forEach(wayOutput);
+        }
+
+        outputWriter = new PrintWriter(outputFileName);
+
+        outputWriter.println("<?xml version='1.0' encoding='UTF-8'?>" + "<osgb:FeatureCollection " + "xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb' " + "xmlns:gml='http://www.opengis.net/gml' " + "xmlns:xlink='http://www.w3.org/1999/xlink' " + "xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " + "xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd' " + "fid='GDS-58096-1'>"
+                + "<gml:description>Ordnance Survey, (c) Crown Copyright. All rights reserved, 2009-07-30</gml:description>" + "<gml:boundedBy><gml:null>unknown</gml:null></gml:boundedBy>" + "<osgb:queryTime>2009-07-30T02:01:07</osgb:queryTime>" + "<osgb:queryExtent>" + "<osgb:Rectangle srsName='osgb:BNG'>" + "<gml:coordinates>291000.000,92000.000 293000.000,94000.000</gml:coordinates>" + "</osgb:Rectangle>" + "</osgb:queryExtent>");
+        outputWriter.flush();
+        processDirOrFile(itnFile, extractProcessor);
+        outputWriter.println("<osgb:boundedBy>" + "<gml:Box srsName='osgb:BNG'>" + "<gml:coordinates>290822.000,91912.000 293199.000,94222.000</gml:coordinates>" + "</gml:Box>" + "</osgb:boundedBy>" + "</osgb:FeatureCollection>");
+        outputWriter.flush();
+        outputWriter.close();
+    }
+
+    private void findWaysOnRoad(final File itnFile) {
+        System.err.println("STAGE ONE - findWaysOnRoad");
+        fileProcessProcessor.setInnerProcess(extractWayIds);
+        process(itnFile, fileProcessProcessor);
+    }
+    private void findNodesOfRoad(final File itnFile) {
+        System.err.println("STAGE TWO - findNodesOfRoad");
+        fileProcessProcessor.setInnerProcess(extractNodeIds);
+        process(itnFile, fileProcessProcessor);
+    }
+    private final ProcessVisitor<RoutingElement> extractWayIds = new ProcessVisitor<RoutingElement>() {
+        @Override
+        void processVisitor(final RoutingElement item) {
+            if (item.isType(OSMElement.WAY)) {
+                final Way way = (Way) item;
+                if (way.hasTag("name", workingRoadName)) {
+                    System.out.println("Way found on " + workingRoadName + " id is " + way.getId());
+                    fullWayList.add(way.getId());
+                }
+            }
+            if (item.isType(OSMElement.RELATION)) {
+                final Relation relation = (Relation) item;
+                // if (!relation.isMetaRelation()
+                // && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+                // prepareWaysWithRelationInfo(relation);
+                // System.out.println("\t\tCHECK OUT A RELATION " +
+                // relation.getId());
+                if (relation.isMetaRelation()) {
+                    System.out.println("\t\tADD IT TO my road fids");
+                }
+                if (relation.hasTag("name", workingRoadName)) {
+                    System.out.println("Relation found on " + workingRoadName + " id is " + relation.getId());
+                    prepareNameRelation(relation, fullWayList);
+                    roadFidList.add(relation.getId());
+                }
+            }
+        }
+    };
+    private void findLinkedWayIDs(final File itnFile) {
+        System.err.println("STAGE THREE - findLinkedWayIDs");
+        origFullNodeList = fullNodeList;
+        origFullWayList = fullWayList;
+        fullNodeList = new TLongArrayList(200);
+        fullWayList = new TLongArrayList(100);
+        workingRoadName = workingLinkRoad;
+        findWaysOnRoad(itnFile);
+    }
+
+
+}
