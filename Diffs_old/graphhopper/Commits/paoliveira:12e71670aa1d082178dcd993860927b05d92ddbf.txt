diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 9dcf0d482a..8bc8ffc674 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -34,6 +34,8 @@ keep in mind that this requires storing your Email there. The same applies if yo
 Note, our CLA does not influence your rights on your contribution but it makes sure for others that you agree to the Apache License, Version 2.
 After this you'll appear in the <a href="CONTRIBUTORS.md">contributors list</a> and your pull request can also be discussed technically.
 
+Read more in [this issue](https://github.com/graphhopper/graphhopper/pull/1129#issuecomment-375820168) why it is not that easy to make this CLA-signing process simpler for first-time contributors and maintainers.
+
 For companies that would like that their developers work for us, we need an additional [corporate CLA signed](https://graphhopper.com/agreements/corporate-cla.html).
 
 ## Code formatting
diff --git a/appveyor.yml b/appveyor.yml
index d8dd30d6e3..a55cd20df4 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -22,7 +22,7 @@ install:
   - cmd: mvn --version
   - cmd: java -version
 build_script:
-  - mvn clean package -DskipTest -B
+  - mvn clean install -DskipTests=true -B
 test_script:
   - mvn test verify -B && mvn checkstyle:check findbugs:check forbiddenapis:check -B
 cache:
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index e6b86e76f5..fd502326a5 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -33,12 +33,6 @@
         <version>0.11-SNAPSHOT</version>
     </parent>  
     
-    <properties>
-        <slf4j.version>1.7.21</slf4j.version>        
-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-    </properties>
-    
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
@@ -62,16 +56,13 @@
         <dependency>
             <groupId>com.fasterxml.jackson.core</groupId>
             <artifactId>jackson-databind</artifactId>
-            <!-- TODO how to sync with GH? -->
-            <version>2.8.4</version>
+            <version>${jackson.version}</version>
         </dependency>
-
         <dependency>
             <groupId>com.squareup.okhttp3</groupId>
             <artifactId>okhttp</artifactId>
             <version>3.8.0</version>
         </dependency>
-        
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
diff --git a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
index b444b75f63..c2ed446885 100644
--- a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
+++ b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
@@ -88,7 +88,7 @@ public void setDistanceRow(int row, int distanceRow[]) {
 
     public void setWeightRow(int row, double weightRow[]) {
         if (weights.length > 0) {
-            check(weights.length, toCount, "to weights");
+            check(weightRow.length, toCount, "to weights");
             weights[row] = weightRow;
         } else {
             throw new UnsupportedOperationException("Cannot call setWeightRow if weights are disabled");
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
index d324c6661c..b6e686a224 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
@@ -55,7 +55,8 @@ public ShortFastestWeighting(FlagEncoder encoder, double distanceFactor) {
 
     @Override
     public double getMinWeight(double distance) {
-        return super.getMinWeight(distance * distanceFactor);
+        // TODO: Should we add the [+ distance * distanceFactor]. It improves the heuristic of the A*.
+        return super.getMinWeight(distance) * timeFactor + distance * distanceFactor;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 1d812c022e..91661395d9 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -703,6 +703,9 @@ void inPlaceNodeRemove(int removeNodeCount) {
                 setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
 
+        // clear N_EDGE_REF
+        initNodeRefs((nodeCount - removeNodeCount) * nodeEntryBytes, nodeCount * nodeEntryBytes);
+
         if (removeNodeCount >= nodeCount)
             throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
 
diff --git a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
index 3e1e64f853..ed69d878a2 100644
--- a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
+++ b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
@@ -66,6 +66,9 @@ public void setLogging(boolean log) {
      * @return number of successfully applied edge changes
      */
     public long applyChanges(EncodingManager em, Collection<JsonFeature> features) {
+        if (em == null)
+            throw new NullPointerException("EncodingManager cannot be null to change existing graph");
+
         long updates = 0;
         for (JsonFeature jsonFeature : features) {
             if (!jsonFeature.hasProperties())
diff --git a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
index 6ba5d066f2..862fbb512b 100644
--- a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
@@ -23,11 +23,13 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -257,6 +259,26 @@ public void testRemoveDeadEndUnvisitedNetworks() {
         assertEquals(8, g.getNodes());
     }
 
+    @Test
+    public void testAddEdgesAfterwards() {
+        GraphHopperStorage g = createDeadEndUnvisitedNetworkStorage(em);
+        assertEquals(11, g.getNodes());
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+
+        assertEquals(3, removed);
+        instance.markNodesRemovedIfUnreachable();
+        g.optimize();
+
+        assertEquals(8, g.getNodes());
+
+        assertTrue(isConsistent(g));
+        g.edge(7,8);
+        assertTrue(isConsistent(g));
+    }
+
     @Test
     public void testTarjan() {
         GraphHopperStorage g = createSubnetworkTestStorage();
@@ -314,4 +336,39 @@ public void test481() {
         List<IntArrayList> components = instance.findSubnetworks(new PrepEdgeFilter(carFlagEncoder));
         assertEquals(1, components.size());
     }
+
+    public static boolean isConsistent(GraphHopperStorage storage) {
+        EdgeExplorer edgeExplorer = storage.createEdgeExplorer();
+        int nNodes = storage.getNodes();
+        for(int i=0; i<nNodes; i++) {
+            if(!check(storage, edgeExplorer, i)) return false;
+        }
+        return true;
+    }
+
+    public static boolean check(GraphHopperStorage storage, EdgeExplorer edgeExplorer, int node) {
+        List<Integer> toNodes = new ArrayList<>();
+        List<Integer> edges = new ArrayList<>();
+        EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
+        while(edgeIterator.next()) {
+            if (edgeIterator.getBaseNode() < 0 || edgeIterator.getAdjNode() < 0) {
+                return false;
+            }
+            toNodes.add(edgeIterator.getAdjNode());
+            edges.add(edgeIterator.getEdge());
+        }
+
+        for(int i=0;i<toNodes.size();i++) {
+            EdgeIteratorState edgeIteratorState = storage.getEdgeIteratorState(edges.get(i), toNodes.get(i));
+            if(edgeIteratorState == null) {
+                return false;
+            }
+            EdgeIteratorState edgeIteratorState2 = storage.getEdgeIteratorState(edges.get(i), node);
+            if(edgeIteratorState2 == null) {
+                return false;
+            }
+        }
+        return true;
+    }
+
 }
diff --git a/pom.xml b/pom.xml
index d4ffef9493..b9d8b76562 100644
--- a/pom.xml
+++ b/pom.xml
@@ -305,37 +305,6 @@
             </modules>
         </profile>
 
-        <profile>
-            <id>jdk8</id>
-            <activation>
-                <activeByDefault>true</activeByDefault>
-            </activation>
-            <properties />
-            <modules>
-                <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
-                Currently works for jdk8 only -->
-                <module>reader-shp</module>
-            </modules>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-failsafe-plugin</artifactId>
-                    </plugin>
-                    <plugin>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-
-        <profile>
-            <id>jdk9</id>
-            <activation>
-                <activeByDefault>false</activeByDefault>
-                <jdk>9</jdk>
-            </activation>
-            <!-- 1. reader-shp does not work yet with jdk9. 2. See #852 and #701 for possible compiler options -->
-        </profile>
     </profiles>
 
 </project>
diff --git a/reader-gtfs/files/sample-feed.zip b/reader-gtfs/files/sample-feed.zip
index 8f7d6876ab..8047a41b77 100644
Binary files a/reader-gtfs/files/sample-feed.zip and b/reader-gtfs/files/sample-feed.zip differ
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 45297518ac..a9cef56421 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -26,7 +26,6 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.PointList;
 
 import java.time.Instant;
 import java.time.ZoneId;
@@ -47,7 +46,6 @@
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
     private final PtTravelTimeWeighting weighting;
-    private final PointList extraNodes;
     private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
@@ -55,7 +53,7 @@
     private final boolean walkOnly;
 
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
+    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
         this.graph = graph;
         this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
         this.flagEncoder = flagEncoder;
@@ -63,7 +61,6 @@
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
-        this.extraNodes = extraNodes;
         this.extraEdges.addAll(extraEdges);
         for (VirtualEdgeIteratorState extraEdge : extraEdges) {
             if (extraEdge == null) {
@@ -125,8 +122,12 @@ public boolean isBlocked(EdgeIteratorState edge) {
         return realtimeFeed.isBlocked(edge.getEdge());
     }
 
-    public long getDelayFromAlightEdge(EdgeIteratorState edge, long instant) {
-        return realtimeFeed.getDelayForAlightEdge(edge, Instant.ofEpochMilli(instant));
+    public long getDelayFromBoardEdge(EdgeIteratorState edge, long currentTime) {
+        return realtimeFeed.getDelayForBoardEdge(edge, Instant.ofEpochMilli(currentTime));
+    }
+
+    public long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
+        return realtimeFeed.getDelayForAlightEdge(edge, Instant.ofEpochMilli(currentTime));
     }
 
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
@@ -147,7 +148,7 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
         if (edgeType == GtfsStorage.EdgeType.BOARD || edgeType == GtfsStorage.EdgeType.ALIGHT) {
             final int validityId = flagEncoder.getValidityId(edge.getFlags());
-            final GtfsStorage.Validity validity = gtfsStorage.getValidities().get(validityId);
+            final GtfsStorage.Validity validity = realtimeFeed.getValidity(validityId);
             final int trafficDay = (int) ChronoUnit.DAYS.between(validity.start, Instant.ofEpochMilli(instant).atZone(validity.zoneId).toLocalDate());
             return trafficDay >= 0 && validity.validity.get(trafficDay);
         } else {
@@ -196,12 +197,6 @@ public boolean test(EdgeIteratorState edgeIterator) {
             if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
                 if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
                     return false;
-                } else {
-                    if (foundEnteredTimeExpandedNetworkEdge) {
-                        return false;
-                    } else {
-                        foundEnteredTimeExpandedNetworkEdge = true;
-                    }
                 }
             } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
                 if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index cf91ea1b3c..631906adf0 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -98,7 +98,6 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final GHPoint exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
-        private final PointList extraNodes = new PointList();
         private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
@@ -120,7 +119,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
             maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 1000.0);
-            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, separateWalkQuery ? -1 : Double.MAX_VALUE);
+            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
             weighting = createPtTravelTimeWeighting(flagEncoder, arriveBy, walkSpeedKmH);
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
@@ -164,11 +163,8 @@ GHResponse route() {
         }
 
         private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), extraEdges, true);
-
-            extraNodes.add(ghPoint);
-
-            int nextNodeId = graphHopperStorage.getNodes() + 10000 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
+            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, extraEdges, true);
+            int nextNodeId = graphWithExtraEdges.getNodes() + 2 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
             int nextEdgeId = graphWithExtraEdges.getAllEdges().getMaxId() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
 
             final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
@@ -265,8 +261,8 @@ private int egressNode(Label solution) {
 
         private List<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false);
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
+            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false);
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, -1, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
             final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime);
             List<Label> solutions = labels
                     .filter(current -> destNode == current.adjNode)
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 0e1e59282d..adc7530b98 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -30,6 +30,7 @@
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
@@ -51,14 +52,20 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.Optional;
 import java.util.Set;
 import java.util.SortedSet;
+import java.util.Spliterators;
 import java.util.TreeSet;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
@@ -98,13 +105,6 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
 
     private static final Logger LOGGER = LoggerFactory.getLogger(GtfsReader.class);
 
-    private static final Frequency SINGLE_FREQUENCY = new Frequency();
-    static {
-        SINGLE_FREQUENCY.start_time = 0;
-        SINGLE_FREQUENCY.end_time = 1;
-        SINGLE_FREQUENCY.headway_secs = 1;
-    }
-
     private final Graph graph;
     private final LocationIndex walkNetworkIndex;
     private final GtfsStorageI gtfsStorage;
@@ -188,9 +188,13 @@ private void buildPtNetwork() {
             }
             ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trips.iterator().next().trip.route_id).agency_id).agency_timezone);
             Collection<Frequency> frequencies = feed.getFrequencies(trips.iterator().next().trip.trip_id);
-            for (Frequency frequency : (frequencies.isEmpty() ? Collections.singletonList(SINGLE_FREQUENCY) : frequencies)) {
-                for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
-                    addTrips(zoneId, trips, time);
+            if (frequencies.isEmpty()) {
+                addTrips(zoneId, trips, 0, false);
+            } else {
+                for (Frequency frequency : frequencies) {
+                    for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
+                        addTrips(zoneId, trips, time, true);
+                    }
                 }
             }
         });
@@ -233,6 +237,7 @@ void wireUpStops() {
                         EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode, 0.0, false);
                         setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
                         entryEdge.setName(stop.stop_name);
+                        gtfsStorage.getRoutes().put(entryEdge.getEdge(), routeId);
 
                         NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
                         wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
@@ -243,6 +248,137 @@ void wireUpStops() {
         insertTransfers();
     }
 
+    void wireUpAdditionalDepartures(ZoneId zoneId) {
+        for (Stop stop : feed.stops.values()) {
+            int stationNode = gtfsStorage.getStationNodes().get(stop.stop_id);
+            final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
+            departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                int platformNode = findPlatformEnterNode(stationNode, routeId);
+                if (platformNode != -1) {
+                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
+                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
+                    NavigableSet<Fun.Tuple2<Integer, Integer>> staticTimelineNodesForRoute = findDepartureTimelineNodesForRoute(stationNode, routeId).collect(Collectors.toCollection(TreeSet::new));
+                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
+                        SortedSet<Fun.Tuple2<Integer, Integer>> headSet = staticTimelineNodesForRoute.headSet(timelineNode);
+                        if(!headSet.isEmpty()) {
+                            Fun.Tuple2<Integer, Integer> before = headSet.last();
+                            EdgeIteratorState edge = graph.edge(before.b, timelineNode.b,0.0, false);
+                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
+                            edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a-before.a));
+                        }
+                        SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = staticTimelineNodesForRoute.tailSet(timelineNode);
+                        if (!tailSet.isEmpty()) {
+                            Fun.Tuple2<Integer, Integer> after = tailSet.first();
+                            EdgeIteratorState edge = graph.edge(timelineNode.b, after.b, 0.0, false);
+                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
+                            edge.setFlags(encoder.setTime(edge.getFlags(), after.a-timelineNode.a));
+
+//                            System.out.println(" "+ after);
+//                            EdgeIterator ei = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false)).setBaseNode(after.b);
+//                            while(ei.next()) {
+//                                if (encoder.getEdgeType(ei.getFlags()) == GtfsStorage.EdgeType.TRANSFER) {
+//                                    System.out.println("   "+ei+"   @"+Long.toString(after.a-encoder.getTime(ei.getFlags())));
+//                                }
+//                            }
+
+                        }
+
+                        EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b, 0.0, false);
+                        setEdgeType(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
+                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
+                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+                    });
+                } else {
+                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                    int stopEnterNode = i-1;
+                    nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
+                    EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode, 0.0, false);
+                    setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
+                    entryEdge.setName(stop.stop_name);
+                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
+                    wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
+                }
+            });
+            final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
+            arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                int platformNode = findPlatformExitNode(stationNode, routeId);
+                NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
+
+                if (platformNode != -1) {
+                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
+                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
+                        EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode, 0.0, false);
+                        setEdgeType(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
+                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
+                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+                    });
+                } else {
+                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                    int stopExitNode = i-1;
+                    nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
+                    EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode, 0.0, false);
+                    setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
+                    exitEdge.setName(stop.stop_name);
+                    wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
+                }
+                final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(stop.stop_id, routeId).stream().filter(t -> t.from_stop_id.equals(stop.stop_id)).findAny();
+                if (!withinStationTransfer.isPresent()) {
+                    insertOutboundTransfers(stop.stop_id, null, 0, timeNodes);
+                }
+                transfers.getTransfersFromStop(stop.stop_id, routeId).forEach(transfer -> {
+                    insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
+                });
+            });
+        }
+    }
+
+    private Stream<Fun.Tuple2<Integer, Integer>> findDepartureTimelineNodesForRoute(int stationNode, String routeId) {
+        int node = findPlatformEnterNode(stationNode, routeId);
+        if (node == -1) {
+            return Stream.empty();
+        }
+        return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
+            EdgeIterator edgeIterator = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true)).setBaseNode(node);
+            @Override
+            public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
+                if (edgeIterator.next()) {
+                    action.accept(edgeIterator);
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        }, false)
+                .filter(edge -> encoder.getEdgeType(edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK)
+                .map(edge -> new Fun.Tuple2<>((int) encoder.getTime(edge.getFlags()), edge.getAdjNode()));
+    }
+
+    private int findPlatformEnterNode(int stationNode, String routeId) {
+        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true)).setBaseNode(stationNode);
+        while (i.next()) {
+            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
+            if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
+                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
+                    return i.getAdjNode();
+                }
+            }
+        }
+        return -1;
+    }
+
+    private int findPlatformExitNode(int stationNode, String routeId) {
+        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false)).setBaseNode(stationNode);
+        while (i.next()) {
+            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
+            if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
+                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
+                    return i.getAdjNode();
+                }
+            }
+        }
+        return -1;
+    }
+
     private NavigableSet<Fun.Tuple2<Integer, Integer>> sorted(List<TimelineNodeIdWithTripId> timelineNodesWithTripId) {
         NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
         timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
@@ -264,35 +400,27 @@ void insertTransfers() {
                 });
             });
         });
-        if (graph.getBaseGraph() != null) {
-            arrivalTimelineNodes.asMap().forEach((fromStopId, timelineNodesWithTripId) -> {
-                Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = timelineNodesWithTripId.stream().collect(Collectors.groupingBy(t -> t.routeId));
-                arrivalTimelineNodesByRoute.forEach((fromRouteId, timelineNodesByRoute) -> {
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesByRoute);
-                    final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(fromStopId, fromRouteId).stream().filter(t -> t.from_stop_id.equals(fromStopId)).findAny();
-                    if (!withinStationTransfer.isPresent()) {
-                        insertOutboundTransfers(fromStopId, null, 0, timeNodes);
-                    }
-                    transfers.getTransfersFromStop(fromStopId, fromRouteId).forEach(transfer -> {
-                        insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
-                    });
-                });
-            });
-        }
     }
 
-    private void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
-        List<Integer> arrivalNodes = new ArrayList<>();
+    private void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time, boolean frequencyBased) {
+        List<TripWithStopTimeAndArrivalNode> arrivalNodes = new ArrayList<>();
         for (TripWithStopTimes trip : trips) {
-            GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder()
+            GtfsRealtime.TripDescriptor.Builder tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder()
                     .setTripId(trip.trip.trip_id)
-                    .setRouteId(trip.trip.route_id)
-                    .setStartTime(convertToGtfsTime(time)).build();
-            addTrip(zoneId, time, arrivalNodes, trip, tripDescriptor);
+                    .setRouteId(trip.trip.route_id);
+            if (frequencyBased) {
+                tripDescriptor = tripDescriptor.setStartTime(convertToGtfsTime(time));
+            }
+            addTrip(zoneId, time, arrivalNodes, trip, tripDescriptor.build());
         }
     }
 
-    void addTrip(ZoneId zoneId, int time, List<Integer> arrivalNodes, GtfsReader.TripWithStopTimes trip, GtfsRealtime.TripDescriptor tripDescriptor) {
+    private static class TripWithStopTimeAndArrivalNode {
+        TripWithStopTimes tripWithStopTimes;
+        int arrivalNode;
+    }
+
+    void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsReader.TripWithStopTimes trip, GtfsRealtime.TripDescriptor tripDescriptor) {
         IntArrayList boardEdges = new IntArrayList();
         IntArrayList alightEdges = new IntArrayList();
         StopTime prev = null;
@@ -387,13 +515,50 @@ void addTrip(ZoneId zoneId, int time, List<Integer> arrivalNodes, GtfsReader.Tri
             setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
             dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
             if (prev == null) {
-                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validityId);
+                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validOn, zoneId);
             }
             prev = stopTime;
         }
         gtfsStorage.getBoardEdgesForTrip().put(GtfsStorage.tripKey(tripDescriptor.getTripId(), tripDescriptor.getStartTime()), boardEdges.toArray());
         gtfsStorage.getAlightEdgesForTrip().put(GtfsStorage.tripKey(tripDescriptor.getTripId(), tripDescriptor.getStartTime()), alightEdges.toArray());
-        arrivalNodes.add(arrivalNode);
+        TripWithStopTimeAndArrivalNode tripWithStopTimeAndArrivalNode = new TripWithStopTimeAndArrivalNode();
+        tripWithStopTimeAndArrivalNode.tripWithStopTimes = trip;
+        tripWithStopTimeAndArrivalNode.arrivalNode = arrivalNode;
+        arrivalNodes.add(tripWithStopTimeAndArrivalNode);
+    }
+
+    int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescriptor, int stopSequence, int departureTime, int departureNode, BitSet validOnDay) {
+        Trip trip = feed.trips.get(tripDescriptor.getTripId());
+        final int departureTimelineNode = i++;
+        StopTime stopTime = feed.stop_times.get(new Fun.Tuple2(tripDescriptor.getTripId(), stopSequence));
+        Stop stop = feed.stops.get(stopTime.stop_id);
+        nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
+        nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+        times.put(departureTimelineNode, departureTime);
+        departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, tripDescriptor.getTripId(), trip.route_id));
+
+        int dayShift = departureTime / (24 * 60 * 60);
+        GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
+        int validityId;
+        if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
+            validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
+        } else {
+            validityId = gtfsStorage.getOperatingDayPatterns().size();
+            gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
+        }
+
+        EdgeIteratorState boardEdge = graph.edge(
+                departureTimelineNode,
+                departureNode,
+                0.0,
+                false);
+        boardEdge.setName(getRouteName(feed, trip));
+        setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+        gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopSequence);
+        gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
+        boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
+        boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
+        return boardEdge.getEdge();
     }
 
     private void wireUpAndAndConnectArrivalTimeline(Stop toStop, String routeId, int stopExitNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
@@ -456,31 +621,45 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
         }
     }
 
-    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, int validityId) {
+    private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
+        BitSet accumulatorValidity = new BitSet(validOn.validity.size());
+        accumulatorValidity.or(validOn.validity);
         EdgeIteratorState edge;
-        for (int lastTripArrivalNode : arrivalNodes) {
-            int dwellTime = times.get(departureNode) - times.get(lastTripArrivalNode);
-            if (dwellTime >= 0) {
+        ListIterator<TripWithStopTimeAndArrivalNode> li = arrivalNodes.listIterator(arrivalNodes.size());
+        while(li.hasPrevious() && accumulatorValidity.cardinality() > 0) {
+            TripWithStopTimeAndArrivalNode lastTrip = li.previous();
+            int dwellTime = times.get(departureNode) - times.get(lastTrip.arrivalNode);
+            if (dwellTime >= 0 && accumulatorValidity.intersects(lastTrip.tripWithStopTimes.validOnDay)) {
+                BitSet blockTransferValidity = new BitSet(validOn.validity.size());
+                blockTransferValidity.or(validOn.validity);
+                blockTransferValidity.and(accumulatorValidity);
+                GtfsStorage.Validity blockTransferValidOn = new GtfsStorage.Validity(blockTransferValidity, zoneId, startDate);
+                int blockTransferValidityId;
+                if (gtfsStorage.getOperatingDayPatterns().containsKey(blockTransferValidOn)) {
+                    blockTransferValidityId = gtfsStorage.getOperatingDayPatterns().get(blockTransferValidOn);
+                } else {
+                    blockTransferValidityId = gtfsStorage.getOperatingDayPatterns().size();
+                    gtfsStorage.getOperatingDayPatterns().put(blockTransferValidOn, blockTransferValidityId);
+                }
                 nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
                 nodeAccess.setAdditionalNodeField(i-1, NodeType.INTERNAL_PT.ordinal());
-
                 edge = graph.edge(
-                        lastTripArrivalNode,
+                        lastTrip.arrivalNode,
                         i-1,
                         0.0,
                         false);
                 setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
                 edge.setFlags(encoder.setTime(edge.getFlags(), dwellTime));
-
                 edge = graph.edge(
                         i-1,
                         departureNode,
                         0.0,
                         false);
                 setEdgeType(edge, GtfsStorage.EdgeType.BOARD);
-                edge.setFlags(encoder.setValidityId(edge.getFlags(), validityId));
+                edge.setFlags(encoder.setValidityId(edge.getFlags(), blockTransferValidityId));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
                 gtfsStorage.getTripDescriptors().put(edge.getEdge(), tripDescriptor.toByteArray());
+                accumulatorValidity.andNot(lastTrip.tripWithStopTimes.validOnDay);
             }
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index f5929ed25d..a35efade40 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -90,7 +90,6 @@ public int hashCode() {
 	private Map<String, GTFSFeed> gtfsFeeds = new HashMap<>();
 	private Map<String, Transfers> transfers = new HashMap<>();
 	private HTreeMap<Validity, Integer> operatingDayPatterns;
-	private Map<Integer, Validity> validities;
 	private Bind.MapWithModificationListener<FeedIdWithTimezone, Integer> timeZones;
 	private Map<Integer, FeedIdWithTimezone> readableTimeZones;
 	private Map<Integer, byte[]> tripDescriptors;
@@ -177,11 +176,6 @@ public GraphExtension create(long byteCount) {
     private void init() {
 		this.gtfsFeedIds = data.getHashSet("gtfsFeeds");
 		this.operatingDayPatterns = data.getHashMap("validities");
-		Map<Integer, Validity> reverseOperatingDayPatterns = new HashMap<>();
-		for (Map.Entry<Validity, Integer> entry : this.operatingDayPatterns.entrySet()) {
-			reverseOperatingDayPatterns.put(entry.getValue(), entry.getKey());
-		}
-		Bind.mapInverse(this.operatingDayPatterns, reverseOperatingDayPatterns);
 		this.timeZones = data.getHashMap("timeZones");
 		Map<Integer, FeedIdWithTimezone> readableTimeZones = new HashMap<>();
 		for (Map.Entry<FeedIdWithTimezone, Integer> entry : this.timeZones.entrySet()) {
@@ -189,7 +183,6 @@ private void init() {
 		}
 		Bind.mapInverse(this.timeZones, readableTimeZones);
 		this.readableTimeZones = Collections.unmodifiableMap(readableTimeZones);
-		this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
 		this.tripDescriptors = data.getTreeMap("tripDescriptors");
 		this.stopSequences = data.getTreeMap("stopSequences");
 		this.fares = data.getTreeMap("fares");
@@ -253,10 +246,6 @@ public long getCapacity() {
         return operatingDayPatterns;
     }
 
-	Map<Integer, Validity> getValidities() {
-		return validities;
-	}
-
 	Map<Integer, FeedIdWithTimezone> getTimeZones() {
 		return readableTimeZones;
 	}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 31f44ffdf6..b64bc94839 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -17,16 +17,20 @@
  */
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.HashMultimap;
-import com.google.common.collect.SetMultimap;
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.Multimap;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.PriorityQueue;
+import java.util.Spliterators;
 import java.util.function.Consumer;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
@@ -45,7 +49,7 @@
     private long startTime;
     private final PtFlagEncoder flagEncoder;
     private final PtTravelTimeWeighting weighting;
-    private final SetMultimap<Integer, Label> fromMap;
+    private final Multimap<Integer, Label> fromMap;
     private final PriorityQueue<Label> fromHeap;
     private final int maxVisitedNodes;
     private final boolean reverse;
@@ -73,7 +77,7 @@
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nWalkDistanceConstraintViolations))
                 .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0));
         fromHeap = new PriorityQueue<>(queueComparator);
-        fromMap = HashMultimap.create();
+        fromMap = ArrayListMultimap.create();
     }
 
     Stream<Label> calcLabels(int from, int to, Instant startTime) {
@@ -85,13 +89,15 @@
 
     private class MultiCriteriaLabelSettingSpliterator extends Spliterators.AbstractSpliterator<Label> {
 
+        private final int from;
         private final int to;
-        private final Set<Label> targetLabels;
+        private final Collection<Label> targetLabels;
 
         MultiCriteriaLabelSettingSpliterator(int from, int to) {
             super(0, 0);
+            this.from = from;
             this.to = to;
-            targetLabels = new HashSet<>();
+            targetLabels = new ArrayList<>();
             Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, 0,false,null);
             fromMap.put(from, label);
             fromHeap.add(label);
@@ -109,6 +115,9 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                 action.accept(label);
                 explorer.exploreEdgesAround(label).forEach(edge -> {
                     GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+                    if (edgeType == GtfsStorage.EdgeType.HIGHWAY && maxTransferDistancePerLeg <= 0.0) return;
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_PT && ((reverse?edge.getAdjNode():edge.getBaseNode()) != (reverse?to:from)) && maxTransferDistancePerLeg <= 0.0) return;
+                    if (edgeType == GtfsStorage.EdgeType.EXIT_PT && ((reverse?edge.getBaseNode():edge.getAdjNode()) != (reverse?from:to)) && maxTransferDistancePerLeg <= 0.0) return;
                     long nextTime;
                     if (reverse) {
                         nextTime = label.currentTime - explorer.calcTravelTimeMillis(edge, label.currentTime);
@@ -131,16 +140,21 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? nextTime - label.currentTime : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
                             isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
-                    Set<Label> sptEntries = fromMap.get(edge.getAdjNode());
+                    Collection<Label> sptEntries = fromMap.get(edge.getAdjNode());
                     boolean impossible = label.impossible
                             || explorer.isBlocked(edge)
                             || (!reverse) && edgeType == GtfsStorage.EdgeType.BOARD && label.residualDelay > 0
                             || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT && label.residualDelay < explorer.getDelayFromAlightEdge(edge, label.currentTime);
                     long residualDelay;
                     if (!reverse) {
-                        residualDelay = Math.max(0, label.residualDelay - explorer.calcTravelTimeMillis(edge, label.currentTime));
-                        if (edgeType == GtfsStorage.EdgeType.ALIGHT) {
-                            residualDelay = explorer.getDelayFromAlightEdge(edge, label.currentTime);
+                        if (edgeType == GtfsStorage.EdgeType.WAIT || edgeType == GtfsStorage.EdgeType.TRANSFER) {
+                            residualDelay = Math.max(0, label.residualDelay - explorer.calcTravelTimeMillis(edge, label.currentTime));
+                        } else if (edgeType == GtfsStorage.EdgeType.ALIGHT) {
+                            residualDelay = label.residualDelay + explorer.getDelayFromAlightEdge(edge, label.currentTime);
+                        } else if (edgeType == GtfsStorage.EdgeType.BOARD) {
+                            residualDelay = -explorer.getDelayFromBoardEdge(edge, label.currentTime);
+                        } else {
+                            residualDelay = label.residualDelay;
                         }
                     } else {
                         if (edgeType == GtfsStorage.EdgeType.WAIT || edgeType == GtfsStorage.EdgeType.TRANSFER) {
@@ -149,25 +163,38 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                             residualDelay = 0;
                         }
                     }
-                    Label nEdge = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
-                    if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
-                        removeDominated(nEdge, sptEntries);
-                        if (to == edge.getAdjNode()) {
-                            removeDominated(nEdge, targetLabels);
-                        }
-                        fromMap.put(edge.getAdjNode(), nEdge);
-                        if (to == edge.getAdjNode()) {
-                            targetLabels.add(nEdge);
-                        }
-                        fromHeap.add(nEdge);
+                    if (!reverse && edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && residualDelay > 0) {
+                        Label newImpossibleLabelForDelayedTrip = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, true, label);
+                        insertIfNotDominated(edge, sptEntries, newImpossibleLabelForDelayedTrip);
+                        nextTime += residualDelay;
+                        residualDelay = 0;
+                        Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
+                        insertIfNotDominated(edge, sptEntries, newLabel);
+                    } else {
+                        Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
+                        insertIfNotDominated(edge, sptEntries, newLabel);
                     }
                 });
                 return true;
             }
         }
+
+        private void insertIfNotDominated(EdgeIteratorState edge, Collection<Label> sptEntries, Label nEdge) {
+            if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
+                removeDominated(nEdge, sptEntries);
+                if (to == edge.getAdjNode()) {
+                    removeDominated(nEdge, targetLabels);
+                }
+                fromMap.put(edge.getAdjNode(), nEdge);
+                if (to == edge.getAdjNode()) {
+                    targetLabels.add(nEdge);
+                }
+                fromHeap.add(nEdge);
+            }
+        }
     }
 
-    private boolean isNotDominatedByAnyOf(Label me, Set<Label> sptEntries) {
+    private boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
         if (me.nWalkDistanceConstraintViolations > 0) {
             return false;
         }
@@ -180,7 +207,7 @@ private boolean isNotDominatedByAnyOf(Label me, Set<Label> sptEntries) {
     }
 
 
-    private void removeDominated(Label me, Set<Label> sptEntries) {
+    private void removeDominated(Label me, Collection<Label> sptEntries) {
         for (Iterator<Label> iterator = sptEntries.iterator(); iterator.hasNext();) {
             Label sptEntry = iterator.next();
             if (dominates(me, sptEntry)) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index abdaa20ff9..037303d486 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -44,6 +44,7 @@
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
+import java.time.LocalTime;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.temporal.ChronoUnit;
@@ -67,6 +68,7 @@
 public class RealtimeFeed {
     private static final Logger logger = LoggerFactory.getLogger(RealtimeFeed.class);
     private final IntHashSet blockedEdges;
+    private final IntLongHashMap delaysForBoardEdges;
     private final IntLongHashMap delaysForAlightEdges;
     private final List<VirtualEdgeIteratorState> additionalEdges;
     private final GtfsRealtime.FeedMessage feedMessage;
@@ -75,22 +77,29 @@
     private final GtfsStorage staticGtfs;
     private final Map<Integer, byte[]> additionalTripDescriptors;
     private final Map<Integer, Integer> stopSequences;
+    private final Map<Integer, GtfsStorage.Validity> validities;
 
     private RealtimeFeed(GtfsStorage staticGtfs, GTFSFeed feed, Agency agency, GtfsRealtime.FeedMessage feedMessage, IntHashSet blockedEdges,
-                         IntLongHashMap delaysForAlightEdges, List<VirtualEdgeIteratorState> additionalEdges, Map<Integer, byte[]> tripDescriptors, Map<Integer, Integer> stopSequences) {
+                         IntLongHashMap delaysForBoardEdges, IntLongHashMap delaysForAlightEdges, List<VirtualEdgeIteratorState> additionalEdges, Map<Integer, byte[]> tripDescriptors, Map<Integer, Integer> stopSequences, Map<GtfsStorage.Validity, Integer> operatingDayPatterns) {
         this.staticGtfs = staticGtfs;
         this.staticFeed = feed;
         this.agency = agency;
         this.feedMessage = feedMessage;
         this.blockedEdges = blockedEdges;
+        this.delaysForBoardEdges = delaysForBoardEdges;
         this.delaysForAlightEdges = delaysForAlightEdges;
         this.additionalEdges = additionalEdges;
         this.additionalTripDescriptors = tripDescriptors;
         this.stopSequences = stopSequences;
+        Map<Integer, GtfsStorage.Validity> reverseOperatingDayPatterns = new HashMap<>();
+        for (Map.Entry<GtfsStorage.Validity, Integer> entry : operatingDayPatterns.entrySet()) {
+            reverseOperatingDayPatterns.put(entry.getValue(), entry.getKey());
+        }
+        this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
     }
 
     public static RealtimeFeed empty(GtfsStorage staticGtfs) {
-        return new RealtimeFeed(staticGtfs, staticGtfs.getGtfsFeeds().get("gtfs_0"), null, null, new IntHashSet(), new IntLongHashMap(), Collections.emptyList(), Collections.emptyMap(), Collections.emptyMap());
+        return new RealtimeFeed(staticGtfs, staticGtfs.getGtfsFeeds().get("gtfs_0"), null, null, new IntHashSet(), new IntLongHashMap(), new IntLongHashMap(), Collections.emptyList(), Collections.emptyMap(), Collections.emptyMap(), staticGtfs.getOperatingDayPatterns());
     }
 
     public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
@@ -99,38 +108,8 @@ public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtF
         // TODO: Require configuration of feed and agency this realtime feed is for.
         Agency agency = feed.agency.values().iterator().next(); // Realtime feeds are always specific to an agency.
         final IntHashSet blockedEdges = new IntHashSet();
+        final IntLongHashMap delaysForBoardEdges = new IntLongHashMap();
         final IntLongHashMap delaysForAlightEdges = new IntLongHashMap();
-        feedMessage.getEntityList().stream()
-            .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
-            .map(GtfsRealtime.FeedEntity::getTripUpdate)
-            .filter(tripUpdate -> tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED)
-            .forEach(tripUpdate -> {
-                String key = GtfsStorage.tripKey(tripUpdate.getTrip().getTripId(), tripUpdate.getTrip().hasStartTime() ? tripUpdate.getTrip().getStartTime() : "00:00:00");
-                final int[] boardEdges = staticGtfs.getBoardEdgesForTrip().get(key);
-                final int[] leaveEdges = staticGtfs.getAlightEdgesForTrip().get(key);
-                if (boardEdges == null || leaveEdges == null) {
-                    logger.warn("Trip not found: {}", tripUpdate.getTrip());
-                    return;
-                }
-                tripUpdate.getStopTimeUpdateList().stream()
-                        .filter(stopTimeUpdate -> stopTimeUpdate.getScheduleRelationship() == SKIPPED)
-                        .mapToInt(GtfsRealtime.TripUpdate.StopTimeUpdate::getStopSequence)
-                        .forEach(skippedStopSequenceNumber -> {
-                            blockedEdges.add(boardEdges[skippedStopSequenceNumber]);
-                            blockedEdges.add(leaveEdges[skippedStopSequenceNumber]);
-                        });
-                GtfsReader.TripWithStopTimes tripWithStopTimes = toTripWithStopTimes(feed, agency, tripUpdate);
-                tripWithStopTimes.stopTimes.forEach(stopTime -> {
-                    final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTime.stop_sequence));
-                    int delay = stopTime.arrival_time - originalStopTime.arrival_time;
-                    if (stopTime.stop_sequence > leaveEdges.length-1) {
-                        logger.warn("Stop sequence number too high {} vs {}",stopTime.stop_sequence, leaveEdges.length);
-                        return;
-                    }
-                    delaysForAlightEdges.put(leaveEdges[stopTime.stop_sequence], delay * 1000);
-                });
-            });
-
         final LinkedList<VirtualEdgeIteratorState> additionalEdges = new LinkedList<>();
         final Graph overlayGraph = new Graph() {
             int nNodes = 0;
@@ -272,8 +251,7 @@ public GraphExtension getExtension() {
                 throw new RuntimeException();
             }
         };
-        Map<Integer, String> routes = new HashMap<>();
-        Map<GtfsStorage.Validity, Integer> operatingDayPatterns = new HashMap<>();
+        Map<GtfsStorage.Validity, Integer> operatingDayPatterns = new HashMap<>(staticGtfs.getOperatingDayPatterns());
         Map<Integer, byte[]> tripDescriptors = new HashMap<>();
         Map<Integer, Integer> stopSequences = new HashMap<>();
         Map<String, int[]> boardEdgesForTrip = new HashMap<>();
@@ -335,13 +313,53 @@ public GraphExtension getExtension() {
 
             @Override
             public Map<Integer, String> getRoutes() {
-                return routes;
+                return staticGtfs.getRoutes();
             }
         };
         final GtfsReader gtfsReader = new GtfsReader(feedKey, overlayGraph, gtfsStorage, encoder, null);
         Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
         LocalDate dateToChange = timestamp.atZone(ZoneId.of(agency.agency_timezone)).toLocalDate(); //FIXME
-
+        BitSet validOnDay = new BitSet();
+        LocalDate startDate = feed.calculateStats().getStartDate();
+        validOnDay.set((int) DAYS.between(startDate, dateToChange));
+        feedMessage.getEntityList().stream()
+                .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
+                .map(GtfsRealtime.FeedEntity::getTripUpdate)
+                .filter(tripUpdate -> tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED)
+                .forEach(tripUpdate -> {
+                    String key = GtfsStorage.tripKey(tripUpdate.getTrip().getTripId(), tripUpdate.getTrip().getStartTime());
+                    final int[] boardEdges = staticGtfs.getBoardEdgesForTrip().get(key);
+                    final int[] leaveEdges = staticGtfs.getAlightEdgesForTrip().get(key);
+                    if (boardEdges == null || leaveEdges == null) {
+                        logger.warn("Trip not found: {}", tripUpdate.getTrip());
+                        return;
+                    }
+                    tripUpdate.getStopTimeUpdateList().stream()
+                            .filter(stopTimeUpdate -> stopTimeUpdate.getScheduleRelationship() == SKIPPED)
+                            .mapToInt(GtfsRealtime.TripUpdate.StopTimeUpdate::getStopSequence)
+                            .forEach(skippedStopSequenceNumber -> {
+                                blockedEdges.add(boardEdges[skippedStopSequenceNumber]);
+                                blockedEdges.add(leaveEdges[skippedStopSequenceNumber]);
+                            });
+                    GtfsReader.TripWithStopTimes tripWithStopTimes = toTripWithStopTimes(feed, agency, tripUpdate);
+                    tripWithStopTimes.stopTimes.forEach(stopTime -> {
+                        if (stopTime.stop_sequence > leaveEdges.length-1) {
+                            logger.warn("Stop sequence number too high {} vs {}",stopTime.stop_sequence, leaveEdges.length);
+                            return;
+                        }
+                        final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTime.stop_sequence));
+                        int arrivalDelay = stopTime.arrival_time - originalStopTime.arrival_time;
+                        delaysForAlightEdges.put(leaveEdges[stopTime.stop_sequence], arrivalDelay * 1000);
+                        int departureDelay = stopTime.departure_time - originalStopTime.departure_time;
+                        if (departureDelay > 0) {
+                            int boardEdge = boardEdges[stopTime.stop_sequence];
+                            int departureNode = graph.getEdgeIteratorState(boardEdge, Integer.MIN_VALUE).getAdjNode();
+                            int timeOffset = tripUpdate.getTrip().hasStartTime() ? LocalTime.parse(tripUpdate.getTrip().getStartTime()).toSecondOfDay() : 0;
+                            int delayedBoardEdge = gtfsReader.addDelayedBoardEdge(ZoneId.of(agency.agency_timezone), tripUpdate.getTrip(), stopTime.stop_sequence, stopTime.departure_time + timeOffset, departureNode, validOnDay);
+                            delaysForBoardEdges.put(delayedBoardEdge, departureDelay * 1000);
+                        }
+                    });
+                });
         feedMessage.getEntityList().stream()
                 .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
                 .map(GtfsRealtime.FeedEntity::getTripUpdate)
@@ -363,14 +381,11 @@ public GraphExtension getExtension() {
                                 return stopTime;
                             })
                             .collect(Collectors.toList());
-                    BitSet validOnDay = new BitSet();
-                    LocalDate startDate = feed.calculateStats().getStartDate();
-                    validOnDay.set((int) DAYS.between(startDate, dateToChange));
                     GtfsReader.TripWithStopTimes tripWithStopTimes = new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                     gtfsReader.addTrip(ZoneId.of(agency.agency_timezone), 0, new ArrayList<>(), tripWithStopTimes, tripUpdate.getTrip());
                 });
-        gtfsReader.wireUpStops();
-        return new RealtimeFeed(staticGtfs, feed, agency, feedMessage, blockedEdges, delaysForAlightEdges, additionalEdges, tripDescriptors, stopSequences);
+        gtfsReader.wireUpAdditionalDepartures(ZoneId.of(agency.agency_timezone));
+        return new RealtimeFeed(staticGtfs, feed, agency, feedMessage, blockedEdges, delaysForBoardEdges, delaysForAlightEdges, additionalEdges, tripDescriptors, stopSequences, operatingDayPatterns);
     }
 
     boolean isBlocked(int edgeId) {
@@ -400,7 +415,7 @@ boolean isBlocked(int edgeId) {
     }
 
     public GtfsRealtime.TripDescriptor normalize(GtfsRealtime.TripDescriptor tripDescriptor) {
-        return GtfsRealtime.TripDescriptor.newBuilder(tripDescriptor).clearRouteId().clearStartTime().build();
+        return GtfsRealtime.TripDescriptor.newBuilder(tripDescriptor).clearRouteId().build();
     }
 
     public static GtfsReader.TripWithStopTimes toTripWithStopTimes(GTFSFeed feed, Agency agency, GtfsRealtime.TripUpdate tripUpdate) {
@@ -494,6 +509,13 @@ boolean isBlocked(int edgeId) {
         return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, cancelledArrivals, cancelledDepartures);
     }
 
+    public long getDelayForBoardEdge(EdgeIteratorState edge, Instant now) {
+        if (isThisRealtimeUpdateAboutThisLineRun(edge, now)) {
+            return delaysForBoardEdges.getOrDefault(edge.getEdge(), 0);
+        } else {
+            return 0;
+        }
+    }
 
     public long getDelayForAlightEdge(EdgeIteratorState edge, Instant now) {
         if (isThisRealtimeUpdateAboutThisLineRun(edge, now)) {
@@ -536,4 +558,8 @@ public StopTime getStopTime(GtfsRealtime.TripDescriptor tripDescriptor, Label.Tr
         }
     }
 
+    public GtfsStorage.Validity getValidity(int validityId) {
+        return validities.get(validityId);
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 131c5a03fb..131ebcf097 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -329,7 +329,6 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
         }
         if (GtfsStorage.EdgeType.ENTER_PT == path.get(1).edge.edgeType) {
             final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(path.get(1).edge.timeZoneId);
-            final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedIdWithTimezone.feedId);
             List<Trip.Leg> result = new ArrayList<>();
             long boardTime = -1;
             List<Label.Transition> partition = null;
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 6e62141181..05cc694d00 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -18,7 +18,6 @@
 
 package com.graphhopper;
 
-import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
@@ -26,8 +25,6 @@
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
@@ -318,7 +315,9 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
 
 
         GHResponse route = graphHopper.route(ghRequest);
-        Assert.assertTrue(route.getAll().isEmpty()); // No service on monday morning, and we cannot spend the night at stations yet
+        assertFalse(route.getAll().isEmpty());
+        // On Mondays, there is only a complicated evening trip.
+        assertEquals("Expected travel time == scheduled travel time", time(22, 0), route.getBest().getTime());
 
         ghRequest = new GHRequest(
                 FROM_LAT, FROM_LON,
@@ -350,6 +349,37 @@ public void testBlockTrips() {
         assertEquals("...and one alighting instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_END_TRIP).count());
     }
 
+    @Test
+    public void testBlockWithComplicatedValidityIntersections() {
+        final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
+        final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,18,0).atZone(zoneId).toInstant());
+        GHResponse response = graphHopper.route(ghRequest);
+        PathWrapper mondayTrip = response.getBest();
+        assertEquals("Monday trip has no transfers", 0, mondayTrip.getNumChanges());
+        assertEquals("Monday trip has 3 legs", 3, mondayTrip.getLegs().size());
+        assertEquals("FUNNY_BLOCK_AB1", (((Trip.PtLeg) mondayTrip.getLegs().get(0)).trip_id));
+        assertEquals("FUNNY_BLOCK_BFC1", (((Trip.PtLeg) mondayTrip.getLegs().get(1)).trip_id));
+        assertEquals("FUNNY_BLOCK_FCAMV1", (((Trip.PtLeg) mondayTrip.getLegs().get(2)).trip_id));
+
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,7,18,0).atZone(zoneId).toInstant());
+        response = graphHopper.route(ghRequest);
+        PathWrapper sundayTrip = response.getBest();
+        assertEquals("Sunday trip has no transfers", 0, sundayTrip.getNumChanges());
+        assertEquals("Sunday trip has 2 legs", 2, sundayTrip.getLegs().size());
+        assertEquals("FUNNY_BLOCK_AB1", (((Trip.PtLeg) sundayTrip.getLegs().get(0)).trip_id));
+        // On Sundays, the second trip of the block does not run. Here, it's okay if in the response
+        // it looks like we are teleporting -- this case is unlikely, but only revenue trips should be
+        // included in the response. The test case still demonstrates that these mechanics are working
+        // correctly, so I'm not sure we need a more realistic one. The more realistic case would
+        // have a _different_ revenue trip here in the middle instead of _none_.
+        assertEquals("FUNNY_BLOCK_FCAMV1", (((Trip.PtLeg) sundayTrip.getLegs().get(1)).trip_id));
+    }
+
     @Test
     public void testTransferRules() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
@@ -361,18 +391,8 @@ public void testTransferRules() {
                 TO1_LAT, TO1_LON
         );
         request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
-        request.getHints().put(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
 
         GHResponse response = graphHopper.route(request);
-        assertEquals("Ignoring transfer rules (free walking): Will be there at 9.", time(1, 30), response.getBest().getTime());
-
-        request = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO1_LAT, TO1_LON
-        );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
-
-        response = graphHopper.route(request);
         assertEquals("Transfer rule: 11 minutes. Will miss connection, and be there at 14.", time(6, 30), response.getBest().getTime());
 
         request = new GHRequest(
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index bde33b1e1d..5d8974c83e 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -30,6 +30,7 @@
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -98,7 +99,9 @@ public void testSkipDepartureStop() {
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
         feedMessageBuilder.addEntityBuilder()
                 .setId("1")
                 .getTripUpdateBuilder()
@@ -110,13 +113,85 @@ public void testSkipDepartureStop() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
-        assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), response.getBest().getTime(), 0.1);
+        PathWrapper possibleAlternative = response.getAll().get(0);
+        assertFalse(possibleAlternative.isImpossible());
+        assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
+        assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), possibleAlternative.getTime(), 0.1);
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
         assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
     }
 
+    @Test
+    public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // But the 6:00 departure of my line is going to be super-late :-(
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setScheduleRelationship(SCHEDULED)
+                .setStopSequence(3)
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(3600).build());
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(2, response.getAll().size());
+
+        assertEquals("It's better to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), response.getBest().getTime(), 0.1);
+
+        PathWrapper impossibleAlternative = response.getAll().get(1);
+        assertEquals("The impossible alternative is my planned 5-minute-trip", time(0, 5), impossibleAlternative.getTime(), 0.1);
+        assertTrue(impossibleAlternative.isImpossible());
+    }
+
+    @Test
+    public void testCanUseDelayedTripWhenIAmLateToo() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // But the 6:00 departure of my line is going to be super-late :-(
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setScheduleRelationship(SCHEDULED)
+                .setStopSequence(3)
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(120).build());
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+
+        assertEquals("I am two minutes late for my bus, but the bus is two minutes late, too, so I catch it!", time(0, 5), response.getBest().getTime(), 0.1);
+    }
+
     @Test
     public void testSkipArrivalStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -132,7 +207,9 @@ public void testSkipArrivalStop() {
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
         feedMessageBuilder.addEntityBuilder()
                 .setId("1")
                 .getTripUpdateBuilder()
@@ -166,7 +243,9 @@ public void testSkipTransferStop() {
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
         feedMessageBuilder.addEntityBuilder()
                 .setId("1")
                 .getTripUpdateBuilder()
@@ -245,6 +324,50 @@ public void testExtraTrip() {
         assertEquals("EXTRA0", ptLeg.trip_id);
     }
 
+    @Test
+    public void testExtraTripWorksOnlyOnSpecifiedDay() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:45, but tomorrow
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+        // Today, there is an extra trip right at 6:45, but that doesn't concern me.
+        final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
+                .setId("2")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setScheduleRelationship(ADDED).setTripId("EXTRA").setRouteId("CITY").setStartTime("06:45:00"));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(1)
+                .setStopId("NADAV")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(2)
+                .setStopId("BEATTY_AIRPORT")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
+
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, response.getAll().size());
+
+        assertEquals("There is an extra trip at 6:45 tomorrow, but that doesn't concern me today.", time(1, 5), response.getBest().getTime(), 0.1);
+    }
+
     @Test
     public void testZeroDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -375,7 +498,7 @@ public void testBlockTrips() {
         feedMessageBuilder.addEntityBuilder()
                 .setId("1")
                 .getTripUpdateBuilder()
-                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("AB1").setStartTime("00:00:00"))
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("AB1"))
                 .addStopTimeUpdateBuilder()
                 .setStopSequence(2)
                 .setScheduleRelationship(SKIPPED);
@@ -388,7 +511,9 @@ public void testBlockTrips() {
     @Test
     public void testBlockTripSkipsStop() {
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
         feedMessageBuilder.addEntityBuilder()
                 .setId("1")
                 .getTripUpdateBuilder()
@@ -407,8 +532,7 @@ public void testBlockTripSkipsStop() {
         GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertFalse(route.hasErrors());
-        assertEquals(2, route.getAll().size()); // I want to get the impossible route as well.
-        assertTrue(route.getAll().get(1).isImpossible());
+        assertTrue(route.getAll().get(route.getAll().size()-1).isImpossible());
 
         // Note that my stop (BULLFROG), which is skipped, is a switch of "block legs", so even though it looks like I (impossibly) transfer there,
         // this is not a real transfer. The bus drives through BULLFROG without stopping.
@@ -530,7 +654,7 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
         final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
                 .setId("2")
                 .getTripUpdateBuilder()
-                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setScheduleRelationship(ADDED).setTripId("EXTRA").setRouteId("CITY").setStartTime("06:45:00"));
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setScheduleRelationship(ADDED).setTripId("EXTRA").setRouteId("STBA").setStartTime("06:45:00"));
         extraTripUpdate
                 .addStopTimeUpdateBuilder()
                 .setStopSequence(1)
@@ -549,6 +673,8 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
     }
+    // TODO: Similar case, but where I need a new transfer edge for it to work
+    // TODO: Similar case, but where the departure of the second leg is later than all other departures on that day.
 
     @Test
     public void testMissedTransferBecauseOfDelayBackwards() {
@@ -598,7 +724,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
     }
 
     @Test
-    public void testDelayAtEnd() {
+    public void testDelayAtEndForNonFrequencyBasedTrip() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
         GHRequest ghRequest = new GHRequest(
@@ -623,7 +749,7 @@ public void testDelayAtEnd() {
 
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
-        assertEquals("Expected travel time == scheduled travel time", time(8, 10), route.getBest().getTime(), 0.1);
+        assertEquals("Travel time == predicted travel time", time(8, 15), route.getBest().getTime(), 0.1);
         assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
         assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(2)).trip_id));
         assertEquals("Delay at destination", LocalTime.parse("08:15"), LocalTime.from(((Trip.PtLeg) route.getBest().getLegs().get(2)).stops.get(1).predictedArrivalTime.toInstant().atZone(zoneId)));
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index af74d61b59..49de482350 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -27,13 +27,6 @@
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.46</version>
         </dependency>
-        <!-- 
-        <dependency>
-            <groupId>org.apache.commons</groupId>
-            <artifactId>commons-compress</artifactId>
-            <version>${commons-compress.version}</version>
-        </dependency>
-        -->
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
index 4d60ed95cc..237babd18c 100644
--- a/reader-shp/pom.xml
+++ b/reader-shp/pom.xml
@@ -10,7 +10,7 @@
     <name>GraphHopper Reader for Shapefile Data</name>
 	
     <properties>      
-        <geotools.version>15.2</geotools.version>
+        <geotools.version>19.0</geotools.version>
     </properties>
     	
     <parent>
