diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
index 802d25694d..a5ff3e42c4 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
@@ -4,12 +4,9 @@
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.routing.template.RoutingTemplate;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.template.util.QueryGraphCreator;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.shapes.GHPoint;
+
 
 import java.util.ArrayList;
 import java.util.List;
@@ -18,6 +15,7 @@
     private final List<Integer> nodesToConsiderForRouting;
     private final List<Integer> nodesToBuildRoutesWith;
     private final List<Path> allFoundPaths;
+    private final Graph graph;
     private final QueryGraph queryGraph;
     private final RoutingAlgorithmFactory routingAlgorithmFactory;
     private final AlgorithmOptions algorithmOptions;
@@ -27,28 +25,15 @@ public ManyToManyRouting(final List<Integer> nodesToConsiderForRouting, final Li
         this.nodesToConsiderForRouting = nodesToConsiderForRouting;
         this.nodesToBuildRoutesWith = nodesToBuildRoutesWith;
         this.allFoundPaths = new ArrayList<>(nodesToBuildRoutesWith.size() * nodesToBuildRoutesWith.size());
-        this.queryGraph = new QueryGraph(graph);
+        this.graph = graph;
+        this.queryGraph = prepareQueryGraph();
         this.routingAlgorithmFactory = routingAlgorithmFactory;
         this.algorithmOptions = algorithmOptions;
     }
 
-    public void lookup(RoutingTemplate routingTemplate, NodeAccess nodeAccess, FlagEncoder flagEncoder) {
-        List<GHPoint> pointsOfNodes = allNodeIDsToGHPoints(nodeAccess);
-        addLookupResultsToQueryGraph(routingTemplate, flagEncoder, pointsOfNodes);
-    }
-
-    private List<GHPoint> allNodeIDsToGHPoints(NodeAccess nodeAccess) {
-        final List<GHPoint> pointsOfNodes = new ArrayList<>(this.nodesToBuildRoutesWith.size());
-
-        for (final int nodeId : this.nodesToBuildRoutesWith) {
-            pointsOfNodes.add(new GHPoint(nodeAccess.getLatitude(nodeId), nodeAccess.getLongitude(nodeId)));
-        }
-        return pointsOfNodes;
-    }
-
-    private void addLookupResultsToQueryGraph(RoutingTemplate routingTemplate, FlagEncoder flagEncoder, List<GHPoint> pointsOfNodes) {
-        final List<QueryResult> queryResults = routingTemplate.lookup(pointsOfNodes, flagEncoder);
-        this.queryGraph.lookup(queryResults);
+    private QueryGraph prepareQueryGraph() {
+        final QueryGraphCreator queryGraphCreator = new QueryGraphCreator(this.graph, this.nodesToBuildRoutesWith);
+        return queryGraphCreator.createQueryGraph();
     }
 
     public void findAllPathsBetweenEntryExitPoints() {
@@ -66,4 +51,8 @@ public void findAllPathsBetweenEntryExitPoints() {
     public void clear() {
         this.allFoundPaths.clear();
     }
+
+    public List<Path> getAllFoundPaths() {
+        return this.allFoundPaths;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/util/QueryGraphCreator.java b/core/src/main/java/com/graphhopper/routing/template/util/QueryGraphCreator.java
new file mode 100644
index 0000000000..61a6282903
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/util/QueryGraphCreator.java
@@ -0,0 +1,60 @@
+package com.graphhopper.routing.template.util;
+
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc2D;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class QueryGraphCreator {
+    private final Graph graph;
+    private final List<Integer> nodesToLookup;
+
+    public QueryGraphCreator(final Graph graph, List<Integer> nodesToLookup) {
+        this.graph = graph;
+        this.nodesToLookup = nodesToLookup;
+    }
+
+    public QueryGraph createQueryGraph() {
+        final List<QueryResult> queryResults = this.getQueryResults();
+        final QueryGraph queryGraph = new QueryGraph(this.graph);
+
+        queryGraph.lookup(queryResults);
+
+        return queryGraph;
+    }
+
+    public List<QueryResult> getQueryResults() {
+        final List <QueryResult> queryResults = new ArrayList<>(this.nodesToLookup.size());
+
+        for (final int node : this.nodesToLookup) {
+            final double latitude = this.graph.getNodeAccess().getLatitude(node);
+            final double longitude = this.graph.getNodeAccess().getLongitude(node);
+
+            QueryResult queryResult = createQueryReult(node, latitude, longitude);
+            queryResults.add(queryResult);
+        }
+        return queryResults;
+    }
+
+    public QueryResult createQueryReult(int node, double latitude, double longitude) {
+        QueryResult queryResult = new QueryResult(latitude, longitude);
+        queryResult.setClosestNode(node);
+        queryResult.setWayIndex(0);
+        queryResult.setClosestEdge(findClosestEdge(node));
+        queryResult.calcSnappedPoint(new DistanceCalc2D());
+        return queryResult;
+    }
+
+    public EdgeIteratorState findClosestEdge(final int baseNode) {
+        EdgeExplorer edgeExplorer = this.graph.createEdgeExplorer();
+        EdgeIterator edgeIterator = edgeExplorer.setBaseNode(baseNode);
+        edgeIterator.next();
+        return edgeIterator;
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
index 5538328875..0ac7b551a9 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
@@ -1,4 +1,221 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 public class ManyToManyRoutingTest {
+    private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
+    private ManyToManyRouting manyToManyRouting;
+
+    @Before
+    public void setUp() {
+        final List<Integer> sourceDestinations = prepareSourceDestination();
+        final List<Integer> nodesToConsiderForRouting = OneToManyRoutingTest.prepareInteriorGraph();
+        final RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
+        final AlgorithmOptions algorithmOptions = this.graphMocker.algorithmOptions;
+
+        this.manyToManyRouting = new ManyToManyRouting(nodesToConsiderForRouting, sourceDestinations, this.graphMocker.graph, routingAlgorithmFactory, algorithmOptions);
+        this.manyToManyRouting.findAllPathsBetweenEntryExitPoints();
+    }
+
+    private List<Integer> prepareSourceDestination() {
+        return new ArrayList<>(Arrays.asList(new Integer[] {28, 29, 30, 32, 40}));
+    }
+
+    @Test
+    public void validate28To28() {
+        final List<Integer> firstPathOption = createPathCandidate(28);
+
+        validatePath(0, firstPathOption);
+    }
+
+    @Test
+    public void validate28to29() {
+        final List<Integer> firstPathOption = createPathCandidate(28, 29);
+
+        validatePath(1, firstPathOption);
+    }
+
+    @Test
+    public void validate28To30() {
+        final List<Integer> firstPathOption = createPathCandidate(28, 47, 30);
+
+        validatePath(2, firstPathOption);
+    }
+
+    @Test
+    public void validate28to32() {
+        final List<Integer> firstPathOption = createPathCandidate(28, 47, 48, 49, 32);
+        final List<Integer> secondPathOption = createPathCandidate(28, 47, 55, 49, 32);
+
+        validatePath(3, firstPathOption, secondPathOption);
+    }
+
+    @Test
+    public void validate28To40() {
+        final List<Integer> firstPathOption = createPathCandidate(28, 46, 53, 52, 40);
+
+        validatePath(4, firstPathOption);
+    }
+
+    @Test
+    public void validate29To28() {
+        final List<Integer> firstPathOption = createPathCandidate(29, 28);
+
+        validatePath(5, firstPathOption);
+    }
+
+    @Test
+    public void validate29To29() {
+        final List<Integer> firstPathOption = createPathCandidate(29);
+
+        validatePath(6, firstPathOption);
+    }
+
+    @Test
+    public void validate29To30() {
+        final List<Integer> firstPathOption = createPathCandidate(29, 30);
+
+        validatePath(7, firstPathOption);
+    }
+
+    @Test
+    public void validate29To32() {
+        final List<Integer> firstPathOption = createPathCandidate(29, 48, 49, 32);
+
+        validatePath(8, firstPathOption);
+    }
+
+    @Test
+    public void validate29To40() {
+        final List<Integer> firstPathOption = createPathCandidate(29, 48, 55, 57, 52, 40);
+
+        validatePath(9, firstPathOption);
+    }
+
+    @Test
+    public void validate30To28() {
+        final List<Integer> firstPathOption = createPathCandidate(30, 47, 28);
+
+        validatePath(10, firstPathOption);
+    }
+
+    @Test
+    public void validate30To29() {
+        final List<Integer> firstPathOption = createPathCandidate(30, 29);
+
+        validatePath(11, firstPathOption);
+    }
+
+    @Test
+    public void validate30To30() {
+        final List<Integer> firstPathOption = createPathCandidate(30);
+
+        validatePath(12, firstPathOption);
+    }
+
+    @Test
+    public void validate30To32() {
+        final List<Integer> firstPathOption = createPathCandidate(30, 48, 49, 32);
+
+        validatePath(13, firstPathOption);
+    }
+
+    @Test
+    public void validate30To40() {
+        final List<Integer> firstPathOption = createPathCandidate(30, 48, 55, 57, 52, 40);
+
+        validatePath(14, firstPathOption);
+    }
+
+    @Test
+    public void validate32To28() {
+        final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 47, 28);
+
+        validatePath(15, firstPathOption);
+    }
+
+    @Test
+    public void validate32To29() {
+        final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 29);
+
+        validatePath(16, firstPathOption);
+    }
+
+    @Test
+    public void validate32To30() {
+        final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 30);
+
+        validatePath(17, firstPathOption);
+    }
+
+    @Test
+    public void validate32To32() {
+        final List<Integer> firstPathOption = createPathCandidate(32);
+
+        validatePath(18, firstPathOption);
+    }
+
+    @Test
+    public void validate32To40() {
+        final List<Integer> firstPathOption = createPathCandidate(32, 49, 50, 51, 52, 40);
+
+        validatePath(19, firstPathOption);
+    }
+
+    @Test
+    public void validate40To28() {
+        final List<Integer> firstPathOption = createPathCandidate(40, 52, 53, 46, 28);
+
+        validatePath(20, firstPathOption);
+    }
+
+    @Test
+    public void validate40To29() {
+        final List<Integer> firstPathOption = createPathCandidate(40, 52, 57, 55, 48, 29);
+
+        validatePath(21, firstPathOption);
+    }
+
+    @Test
+    public void validate40To30() {
+        final List<Integer> firstPathOption = createPathCandidate(40, 52, 57, 55, 48, 30);
+
+        validatePath(22, firstPathOption);
+    }
+
+    @Test
+    public void validate40To32() {
+        final List<Integer> firstPathOption = createPathCandidate(40, 52, 51, 50, 49, 32);
+
+        validatePath(23, firstPathOption);
+    }
+
+    @Test
+    public void validate40To40() {
+        final List<Integer> firstPathOption = createPathCandidate(40);
+
+        validatePath(24, firstPathOption);
+    }
+
+    private void validatePath(final int pathIndex, List<Integer>... possiblePaths) {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(pathIndex);
+        OneToManyRoutingTest.validatePath(nodesInPathOrder, possiblePaths);
+    }
+
+    private List<Integer> retrieveFoundPathsNode(final int index) {
+        return this.manyToManyRouting.getAllFoundPaths().get(index).getNodesInPathOrder();
+    }
+
+    private List<Integer> createPathCandidate(Integer... nodeIdsOnPath) {
+        return new ArrayList<>(Arrays.asList(nodeIdsOnPath));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
index 278402af1b..b0554ef618 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
@@ -2,12 +2,7 @@
 
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalc2D;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.routing.template.util.QueryGraphCreator;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -19,7 +14,7 @@
 
 public class OneToManyRoutingTest {
     private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
-    private final QueryGraph queryGraph = new QueryGraph(graphMocker.graph);
+    private QueryGraph queryGraph;
     private OneToManyRouting oneToManyRouting;
 
     @Before
@@ -40,7 +35,7 @@ public void setupOneToManyRouting() {
         return new ArrayList<>(Arrays.asList(toNodesArray));
     }
 
-    private List<Integer> prepareInteriorGraph() {
+    static List<Integer> prepareInteriorGraph() {
         final Integer[] nodesToConsiderForRoutingArray = new Integer[] {46 ,47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57};
         return new ArrayList<>(Arrays.asList(nodesToConsiderForRoutingArray));
     }
@@ -48,8 +43,7 @@ public void setupOneToManyRouting() {
     private void prepareQueryGraph(final int fromNode, final List<Integer> toNodes) {
         List<Integer> allNodes = prepareAllNodesList(fromNode, toNodes);
 
-        List<QueryResult> queryResults = getQueryResults( allNodes);
-        this.queryGraph.lookup(queryResults);
+        this.queryGraph = new QueryGraphCreator(this.graphMocker.graph, allNodes).createQueryGraph();
     }
 
     private List<Integer> prepareAllNodesList(int fromNode, List<Integer> toNodes) {
@@ -59,35 +53,6 @@ private void prepareQueryGraph(final int fromNode, final List<Integer> toNodes)
         return allNodes;
     }
 
-    private List<QueryResult> getQueryResults(List<Integer> allNodes) {
-        final List <QueryResult> queryResults = new ArrayList<>(allNodes.size());
-
-        for (final int node : allNodes) {
-            final double latitude = this.graphMocker.nodeAccess.getLatitude(node);
-            final double longitude = this.graphMocker.nodeAccess.getLongitude(node);
-
-            QueryResult queryResult = createQueryReult(node, latitude, longitude);
-            queryResults.add(queryResult);
-        }
-        return queryResults;
-    }
-
-    private QueryResult createQueryReult(int node, double latitude, double longitude) {
-        QueryResult queryResult = new QueryResult(latitude, longitude);
-        queryResult.setClosestNode(node);
-        queryResult.setWayIndex(0);
-        queryResult.setClosestEdge(findClosestEdge(node));
-        queryResult.calcSnappedPoint(new DistanceCalc2D());
-        return queryResult;
-    }
-
-    private EdgeIteratorState findClosestEdge(final int baseNode) {
-        EdgeExplorer edgeExplorer = this.graphMocker.graph.createEdgeExplorer();
-        EdgeIterator edgeIterator = edgeExplorer.setBaseNode(baseNode);
-        edgeIterator.next();
-        return edgeIterator;
-    }
-
     @Test
     public void validateFirstPath() {
         final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(0);
@@ -100,6 +65,8 @@ public void validateFirstPath() {
     public void validateSecondPath() {
         final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(1);
         final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 30}));
+
+        validatePath(nodesInPathOrder, firstPathOption);
     }
 
     @Test
@@ -123,7 +90,7 @@ public void validateFourthPath() {
         return this.oneToManyRouting.getAllFoundPaths().get(index).getNodesInPathOrder();
     }
 
-    private void validatePath(final List<Integer> foundPath, final List<Integer>... possibleShortestPaths) {
+    static void validatePath(final List<Integer> foundPath, final List<Integer>... possibleShortestPaths) {
         boolean correctPathFound = false;
 
         for (final List<Integer> candidate : possibleShortestPaths) {
