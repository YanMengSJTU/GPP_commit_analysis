diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
index b1766ff3e8..49dd8579a4 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,7 +38,7 @@
 /**
  * Base class for all OSM objects
  * <p/>
- * 
+ *
  * @author Nop
  * @author Peter
  * @author phopkins
@@ -53,6 +53,7 @@
     public static final String TAG_KEY_ONEWAY_ORIENTATION = "oneway";
     public static final String TAG_KEY_NOENTRY_ORIENTATION = "noentry";
     public static final String TAG_KEY_RESTRICTION = "restriction";
+    public static final String TAG_KEY_CLASSIFICATION = "classification";
 
     public static final String TAG_VALUE_TYPE_ONEWAY = "oneway";
     public static final String TAG_VALUE_TYPE_NOENTRY = "noentry";
@@ -60,6 +61,10 @@
     public static final String TAG_VALUE_TYPE_ACCESS_PROHIBITED = "prohibited";
     public static final String TAG_VALUE_TYPE_RESTRICTION = "restriction";
 
+    public static final String TAG_VALUE_CLASSIFICATION_FORD = "ford";
+    public static final String TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING = "level crossing";
+    public static final String TAG_VALUE_CLASSIFICATION_GATE = "gate";
+
     private final int type;
     private final long id;
     private final Map<String, Object> properties = new HashMap<String, Object>(5);
@@ -115,6 +120,10 @@ protected void readTags(XMLStreamReader parser) throws XMLStreamException, Misma
                         event = handleDirectedLink(parser);
                         break;
                     }
+                    case "classification": {
+                        event = handleClassification(parser);
+                        break;
+                    }
                     case "instruction": {
                         // eg. Mandatory Turn, No Turn, One Way, No Entry
                         event = handleInstructionEnvironmentalQualifier(parser);
@@ -198,28 +207,28 @@ private String resolveHighway(String elementText) {
         case "Motorway":
         case "B Road":
         case "Minor Road":
-        // Pedestrianised Street is supported for walking so traversing will be controlled by speed in the flag encoders
+            // Pedestrianised Street is supported for walking so traversing will be controlled by speed in the flag encoders
         case "Pedestrianised Street":
         case "Private Road - Publicly Accessible":
-        // Alleys are not traversible
-        // case "Alley":
-        // Private Road - Restricted Access are not traversible
-        // case "Private Road - Restricted Access":
+            // Alleys are not traversible
+            // case "Alley":
+            // Private Road - Restricted Access are not traversible
+            // case "Private Road - Restricted Access":
         case "Local Street":
             return elementText;
         default:
             return null;
         }
-        
+
     }
 
     private String resolveNature(String elementText) {
         logger.info("OSITNElement.resolveNature( " + elementText + ")");
         switch (elementText) {
-            case "Single Carriageway":
-            case "Dual Carriageway":
-            case "Slip Road":
-                return elementText;
+        case "Single Carriageway":
+        case "Dual Carriageway":
+        case "Slip Road":
+            return elementText;
         }
         return null;
     }
@@ -227,9 +236,9 @@ private String resolveNature(String elementText) {
     /**
      * Process <code><osgb:instruction>One Way</osgb:instruction></code>
      * instructions within an environmentalQualifier element.
-     * 
+     *
      * It is either "One Way", "No Entry" or a turn restriction type
-     * 
+     *
      * @param parser
      * @return
      * @throws XMLStreamException
@@ -243,34 +252,19 @@ private int handleInstructionEnvironmentalQualifier(XMLStreamReader parser) thro
             setTag(TAG_KEY_ONEWAY_ORIENTATION, "-1");
             break;
         case "No Entry":
-            // We are processing a No Entry RoadRouteInformation element. Set
-            // the type to noentry
+            // We are processing a No Entry RoadRouteInformation element.
             setTag(TAG_KEY_TYPE, TAG_VALUE_TYPE_NOENTRY);
             // Default the orientation to -1. This could be changed when we
             // process the directedLink element later
             setTag(TAG_KEY_NOENTRY_ORIENTATION, "-1");
-            // We might need this?
-            setTag(TAG_KEY_RESTRICTION, elementText);
             break;
         case "Access Prohibited To":
-            // We are processing a No Entry RoadRouteInformation element. Set
-            // the type to noentry
+            // We are processing a Access Prohibited To RoadPartialLinkInformation (maybe a RoadRouteInformation???) element.
             setTag(TAG_KEY_TYPE, TAG_VALUE_TYPE_ACCESS_PROHIBITED);
-            // Default the orientation to -1. This could be changed when we
-            // process the directedLink element later
-            // setTag(TAG_KEY_NOENTRY_ORIENTATION, "-1");
-            // We might need this?
-            // setTag(TAG_KEY_RESTRICTION, elementText);
             break;
         case "Access Limited To":
-            // We are processing a No Entry RoadRouteInformation element. Set
-            // the type to noentry
+            // We are processing a Access Limited To RoadPartialLinkInformation (maybe a RoadRouteInformation???) element.
             setTag(TAG_KEY_TYPE, TAG_VALUE_TYPE_ACCESS_LIMITED);
-            // Default the orientation to -1. This could be changed when we
-            // process the directedLink element later
-            // setTag(TAG_KEY_NOENTRY_ORIENTATION, "-1");
-            // We might need this?
-            // setTag(TAG_KEY_RESTRICTION, elementText);
             break;
         default:
             // Handles Mandatory Turn and No Turn
@@ -320,10 +314,34 @@ private int handleUseVehicleQualifier(XMLStreamReader parser) throws XMLStreamEx
         return event;
     }
 
+    /**
+     * Handle classifications - Level Crossing, Ford, Gate
+     * @param parser
+     * @return
+     * @throws XMLStreamException
+     */
+    private int handleClassification(XMLStreamReader parser) throws XMLStreamException {
+        String elementText = parser.getElementText();
+        System.out.println("HANDLE CLASSIFICATION "  + elementText + " " + this.getClass().getName());
+        switch (elementText) {
+        case "Ford":
+            setTag(TAG_KEY_CLASSIFICATION, TAG_VALUE_CLASSIFICATION_FORD);
+            break;
+        case "Level Crossing":
+            setTag(TAG_KEY_CLASSIFICATION, TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
+            break;
+        case "Gate":
+            setTag(TAG_KEY_CLASSIFICATION, TAG_VALUE_CLASSIFICATION_GATE);
+            break;
+        }
+        int event = parser.getEventType();
+        return event;
+    }
+
     /**
      * process parsing of directedLink data. If this is a "oneway" OR "noentry"
      * we will change the -1 to true if the orientation on the link it "+"
-     * 
+     *
      * @param parser
      * @return
      * @throws XMLStreamException
@@ -406,6 +424,7 @@ private boolean exitElement(XMLStreamReader parser) {
         case "RoadNode":
         case "RoadLink":
         case "RoadRouteInformation":
+        case "RoadLinkInformation":
         case "Road":
         case "RouteLink":
         case "RouteNode":
@@ -440,10 +459,12 @@ public void setTags(Map<String, Object> newTags) {
             }
     }
 
+    @Override
     public boolean hasTags() {
         return !properties.isEmpty();
     }
 
+    @Override
     public String getTag(String name) {
         return (String) properties.get(name);
     }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNRelation.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNRelation.java
index daebc48031..fc1203470b 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNRelation.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,8 +29,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.reader.Relation;
 import com.graphhopper.reader.RelationMember;
@@ -38,185 +36,191 @@
 /**
  * Represents an OSM Relation
  * <p/>
- * 
+ *
  * @author Nop
  */
 public class OSITNRelation extends OSITNElement implements Relation {
 
-	private static final List<String> notInstructions;
-	private static final List<String> onlyInstructions;
-	protected final ArrayList<ITNMember> members = new ArrayList<ITNMember>(5);
-	private Type relationType;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OSITNRelation.class);
-	private String coords;
-	static {
-		notInstructions = new ArrayList<String>();
-		onlyInstructions = new ArrayList<String>();
-
-		notInstructions.add("No Turn");
-	}
-
-	public static OSITNRelation create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		OSITNRelation rel = new OSITNRelation(id);
-
-		parser.nextTag();
-		rel.readTags(parser);
-		return rel;
-	}
-
-	public OSITNRelation(long id) {
-		super(id, RELATION);
-	}
-
-	@Override
-	public String toString() {
-		return "Relation (" + getId() + ", " + members.size() + " members)";
-	}
-
-	public ArrayList<ITNMember> getMembers() {
-		return members;
-	}
-
-	public boolean isMetaRelation() {
-		for (ITNMember member : members) {
-			if (member.type() == RELATION) {
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public boolean isMixedRelation() {
-		boolean hasRel = false;
-		boolean hasOther = false;
-
-		for (ITNMember member : members) {
-			if (member.type() == RELATION) {
-				hasRel = true;
-			} else {
-				hasOther = true;
-			}
-
-			if (hasRel && hasOther) {
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public void removeRelations() {
-		for (int i = members.size() - 1; i >= 0; i--) {
-			if (members.get(i).type() == RELATION) {
-				members.remove(i);
-			}
-		}
-	}
-
-	public void add(ITNMember member) {
-		members.add(member);
-	}
-
-	/**
-	 * Container class for relation members
-	 */
-	public static class ITNMember implements RelationMember {
-		public static final int NODE = 0;
-		public static final int WAY = 1;
-		public static final int RELATION = 2;
-		private static final String typeDecode = "nwr";
-		private int type;
-		private long ref;
-		private String role;
-
-		public ITNMember(XMLStreamReader parser) {
-			String typeName = parser.getAttributeValue(null, "type");
-			type = typeDecode.indexOf(typeName.charAt(0));
-			ref = Long.parseLong(parser.getAttributeValue(null, "ref"));
-			role = parser.getAttributeValue(null, "role");
-		}
-
-		public ITNMember(ITNMember input) {
-			type = input.type;
-			ref = input.ref;
-			role = input.role;
-		}
-
-		public ITNMember(int type, long ref, String role) {
-			this.type = type;
-			this.ref = ref;
-			this.role = role;
-		}
-
-		public String toString() {
-			return "Member " + type + ":" + ref;
-		}
-
-		public int type() {
-			return type;
-		}
-
-		public String role() {
-			return role;
-		}
-
-		public long ref() {
-			return ref;
-		}
-	}
-
-	@Override
-	protected void parseCoords(String elementText) {
-	    this.coords = elementText;
-	}
-	
-
-	public String getCoordinates() {
+    private static final List<String> notInstructions;
+    private static final List<String> onlyInstructions;
+    protected final ArrayList<ITNMember> members = new ArrayList<ITNMember>(5);
+    private Type relationType;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OSITNRelation.class);
+    private String coords;
+    static {
+        notInstructions = new ArrayList<String>();
+        onlyInstructions = new ArrayList<String>();
+
+        notInstructions.add("No Turn");
+    }
+
+    public static OSITNRelation create(long id, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+        OSITNRelation rel = new OSITNRelation(id);
+
+        parser.nextTag();
+        rel.readTags(parser);
+        return rel;
+    }
+
+    public OSITNRelation(long id) {
+        super(id, RELATION);
+    }
+
+    @Override
+    public String toString() {
+        return "Relation (" + getId() + ", " + members.size() + " members)";
+    }
+
+    @Override
+    public ArrayList<ITNMember> getMembers() {
+        return members;
+    }
+
+    @Override
+    public boolean isMetaRelation() {
+        for (ITNMember member : members) {
+            if (member.type() == RELATION) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isMixedRelation() {
+        boolean hasRel = false;
+        boolean hasOther = false;
+
+        for (ITNMember member : members) {
+            if (member.type() == RELATION) {
+                hasRel = true;
+            } else {
+                hasOther = true;
+            }
+
+            if (hasRel && hasOther) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void removeRelations() {
+        for (int i = members.size() - 1; i >= 0; i--) {
+            if (members.get(i).type() == RELATION) {
+                members.remove(i);
+            }
+        }
+    }
+
+    public void add(ITNMember member) {
+        members.add(member);
+    }
+
+    /**
+     * Container class for relation members
+     */
+    public static class ITNMember implements RelationMember {
+        public static final int NODE = 0;
+        public static final int WAY = 1;
+        public static final int RELATION = 2;
+        private static final String typeDecode = "nwr";
+        private int type;
+        private long ref;
+        private String role;
+
+        public ITNMember(XMLStreamReader parser) {
+            String typeName = parser.getAttributeValue(null, "type");
+            type = typeDecode.indexOf(typeName.charAt(0));
+            ref = Long.parseLong(parser.getAttributeValue(null, "ref"));
+            role = parser.getAttributeValue(null, "role");
+        }
+
+        public ITNMember(ITNMember input) {
+            type = input.type;
+            ref = input.ref;
+            role = input.role;
+        }
+
+        public ITNMember(int type, long ref, String role) {
+            this.type = type;
+            this.ref = ref;
+            this.role = role;
+        }
+
+        @Override
+        public String toString() {
+            return "Member " + type + ":" + ref;
+        }
+
+        @Override
+        public int type() {
+            return type;
+        }
+
+        @Override
+        public String role() {
+            return role;
+        }
+
+        @Override
+        public long ref() {
+            return ref;
+        }
+    }
+
+    @Override
+    protected void parseCoords(String elementText) {
+        this.coords = elementText;
+    }
+
+
+    public String getCoordinates() {
         return coords;
     }
 
     @Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException();
-
-	}
-
-	@Override
-	protected void addDirectedNode(String nodeId, String grade,
-			String orientation) {
-		throw new UnsupportedOperationException();
-
-	}
-
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		if (logger.isDebugEnabled()) logger.debug("ADDING RELATION LINK:" + nodeId);
-		int size = members.size();
-		if (size > 1) {
-			ITNMember itnMember = members.get(members.size() - 1);
-			if ("to".equals(itnMember.role)) {
-				itnMember.role = "via";
-			}
-		}
-		if (size < 2 || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ONEWAY) || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED) || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)) {
-			String idStr = nodeId.substring(5);
-			ITNMember member = new ITNMember(WAY, Long.valueOf(idStr),
-					0 == size ? "from" : "to");
-			add(member);
-		}
-	}
-
-	@Override
-	protected void parseCoordinateString(String elementText,
-			String elementSeparator) {
-		throw new UnsupportedOperationException();
-		
-	}
-
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		throw new UnsupportedOperationException();
-		
-	}
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException();
+
+    }
+
+    @Override
+    protected void addDirectedNode(String nodeId, String grade,
+            String orientation) {
+        throw new UnsupportedOperationException();
+
+    }
+
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        if (logger.isDebugEnabled()) logger.debug("ADDING RELATION LINK:" + nodeId);
+        int size = members.size();
+        if (size > 1) {
+            ITNMember itnMember = members.get(members.size() - 1);
+            if ("to".equals(itnMember.role)) {
+                itnMember.role = "via";
+            }
+        }
+        if (size < 2 || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ONEWAY) || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED) || hasTag("type", OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)) {
+            String idStr = nodeId.substring(5);
+            ITNMember member = new ITNMember(WAY, Long.valueOf(idStr),
+                    0 == size ? "from" : "to");
+            add(member);
+        }
+    }
+
+    @Override
+    protected void parseCoordinateString(String elementText,
+            String elementSeparator) {
+        throw new UnsupportedOperationException();
+
+    }
+
+    @Override
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        throw new UnsupportedOperationException();
+
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java b/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
index 4b7ecc176d..d3f0b08446 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
@@ -212,6 +212,7 @@ private OSITNElement getNextXML() throws XMLStreamException,
                             return OSITNWay.create(id, parser);
                         }
 
+                        case "RoadLinkInformation": 
                         case "RoadRouteInformation": {
                             return OSITNRelation.create(id, parser);
                         }
@@ -219,8 +220,6 @@ private OSITNElement getNextXML() throws XMLStreamException,
                         case "Road": {
                             return OsItnMetaData.create(id, parser);
                         }
-                        case "RoadLinkInformation": {
-                        }
                         case "RoadNodeInformation": {
                         }
                         default: {
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
index 3d31a6b5ec..857b1d00aa 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
@@ -6,11 +6,13 @@
 import gnu.trove.map.TDoubleLongMap;
 import gnu.trove.map.TDoubleObjectMap;
 import gnu.trove.map.TIntLongMap;
+import gnu.trove.map.TLongIntMap;
 import gnu.trove.map.TLongLongMap;
 import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TDoubleLongHashMap;
 import gnu.trove.map.hash.TDoubleObjectHashMap;
 import gnu.trove.map.hash.TIntLongHashMap;
+import gnu.trove.map.hash.TLongIntHashMap;
 import gnu.trove.map.hash.TLongLongHashMap;
 import gnu.trove.map.hash.TLongObjectHashMap;
 import gnu.trove.procedure.TLongProcedure;
@@ -64,15 +66,15 @@
 
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -102,7 +104,7 @@
  * from the OSM tags. When creating an edge the pillar node information from the
  * intermediate datastructure will be stored in the way geometry of that edge.
  * <p/>
- * 
+ *
  * @author Peter Karich
  */
 
@@ -196,6 +198,11 @@ public void process(ProcessData processData, OsItnInputFile in)
     private final LongIntMap osmNodeIdToInternalNodeMap;
     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
     private TLongLongHashMap osmWayIdToRouteWeightMap;
+
+    private TLongIntHashMap osmWayIdToAttributeBitMaskMap;
+    private static final int ATTRIBUTE_BIT_GATE = 1;
+    private static final int ATTRIBUTE_BIT_LEVEL_CROSSING = 2;
+    private static final int ATTRIBUTE_BIT_FORD = 4;
     // stores osm way ids used by relations to identify which edge ids needs to
     // be mapped later
     private TLongHashSet osmIdStoreRequiredSet = new TLongHashSet();
@@ -224,10 +231,10 @@ public void process(ProcessData processData, OsItnInputFile in)
     private TLongObjectMap<TDoubleObjectMap<TDoubleLongMap>> edgeIdToXToYToNodeFlagsMap;
 
     // With this set to true additional tower nodes will be added after the start node and before the final node
-    // of a way. This is to overcome an issue when you are routing short distances and turn restrictions wouldn't 
+    // of a way. This is to overcome an issue when you are routing short distances and turn restrictions wouldn't
     // be recognised.
     private boolean addAdditionalTowerNodes;
-    
+
     public OsItnReader(GraphStorage storage) {
         this.graphStorage = storage;
         String addAdditionalTowerNodesString = graphStorage.getProperties().get("add.additional.tower.nodes");
@@ -238,7 +245,7 @@ public OsItnReader(GraphStorage storage) {
         else {
             addAdditionalTowerNodes = true;
         }
-        
+
         this.nodeAccess = graphStorage.getNodeAccess();
 
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
@@ -287,8 +294,8 @@ void preProcess(File itnFile) {
     }
 
     private void preProcessDirOrFile(File osmFile) throws XMLStreamException,
-            IOException, MismatchedDimensionException, FactoryException,
-            TransformException {
+    IOException, MismatchedDimensionException, FactoryException,
+    TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
@@ -302,8 +309,8 @@ private void preProcessDirOrFile(File osmFile) throws XMLStreamException,
     }
 
     private void preProcessSingleFile(File osmFile) throws XMLStreamException,
-            IOException, MismatchedDimensionException, FactoryException,
-            TransformException {
+    IOException, MismatchedDimensionException, FactoryException,
+    TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PREPROCESS_FORMAT, osmFile.getName());
@@ -347,16 +354,13 @@ private void preProcessSingleFile(OsItnInputFile in)
                 // logger.warn("RELATION :" + item.getClass() + " TYPE:" +
                 // item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
                 // relation.isMetaRelation());
-                if (!relation.isMetaRelation()
-                        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+                if (!relation.isMetaRelation() && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
                     prepareWaysWithRelationInfo(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-                        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
                     prepareRestrictionRelation(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-                        OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
                     prepareNoEntryRelation(relation);
                 }
 
@@ -379,10 +383,14 @@ private void preProcessSingleFile(OsItnInputFile in)
                     prepareRoadDirectionRelation(relation);
                 }
 
+                if (relation.hasTag(OSITNElement.TAG_KEY_CLASSIFICATION)) {
+                    convertRelationTagsToWayAttributeBits(relation);
+                }
+
                 if (++tmpRelationCounter % 50000 == 0) {
                     logger.info(nf(tmpRelationCounter)
                             + " (preprocess), osmWayMap:"
-                            + nf(getRelFlagsMap().size()) + " "
+                            + nf(getOsmWayIdToRouteWeightMap().size()) + " "
                             + Helper.getMemInfo());
                 }
 
@@ -398,6 +406,10 @@ private void prepareRestrictionRelation(Relation relation) {
         }
     }
 
+    /**
+     * Currently identical handling for access prohibited and access limited to
+     * @param relation
+     */
     private void prepareAccessProhibitedRelation(Relation relation) {
         if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
                 && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
@@ -452,10 +464,32 @@ private void prepareRoadDirectionRelation(Relation relation) {
             }
         }
     }
-
+    private void convertRelationTagsToWayAttributeBits(Relation relation) {
+        String classification = relation.getTag(OSITNElement.TAG_KEY_CLASSIFICATION);
+        TLongIntMap osmWayIdToAttributeBitMaskMap = getOsmWayIdToAttributeBitMaskMap();
+        int bitToSet = 0;
+        switch (classification) {
+        case OSITNElement.TAG_VALUE_CLASSIFICATION_FORD:
+            bitToSet = ATTRIBUTE_BIT_FORD;
+            break;
+        case OSITNElement.TAG_VALUE_CLASSIFICATION_GATE:
+            bitToSet = ATTRIBUTE_BIT_GATE;
+            break;
+        case OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING:
+            bitToSet = ATTRIBUTE_BIT_LEVEL_CROSSING;
+            break;
+        }
+        ArrayList<? extends RelationMember> members = relation.getMembers();
+        // There will be only one for a RoadLinkInformation classification
+        for (RelationMember relationMember : members) {
+            long wayId = relationMember.ref();
+            int wayAttributeBitMask = osmWayIdToAttributeBitMaskMap.get(wayId)|bitToSet;
+            osmWayIdToAttributeBitMaskMap.put(wayId, wayAttributeBitMask);
+        }
+    }
     /**
      * Handle "No Entry" instructions. Here we are going to store
-     * 
+     *
      * @param relation
      */
     private void prepareNoEntryRelation(Relation relation) {
@@ -551,6 +585,14 @@ private TLongSet getProhibitedWayIds() {
 
         return edgeRoadDirectionMap;
     }
+    private TLongIntMap getOsmWayIdToAttributeBitMaskMap() {
+        if (osmWayIdToAttributeBitMaskMap == null)
+            osmWayIdToAttributeBitMaskMap = new TLongIntHashMap();
+
+        return osmWayIdToAttributeBitMaskMap;
+    }
+
+
 
     private TLongObjectMap<TDoubleObjectMap<TDoubleLongMap>> getEdgeIdToXToYToNodeFlagsMap() {
         if (edgeIdToXToYToNodeFlagsMap == null)
@@ -565,7 +607,7 @@ private TLongSet getProhibitedWayIds() {
      * Filter ways but do not analyze properties wayNodes will be filled with
      * participating node ids.
      * <p/>
-     * 
+     *
      * @return true the current xml entry is a way entry and has nodes
      */
     boolean filterWay(OSITNWay way) {
@@ -641,8 +683,8 @@ public void process(ProcessData processData, OsItnInputFile in)
 
     private void writeOsm2GraphFromDirOrFile(File osmFile,
             ProcessData processData, ProcessVisitor processVisitor)
-            throws XMLStreamException, IOException,
-            MismatchedDimensionException, FactoryException, TransformException {
+                    throws XMLStreamException, IOException,
+                    MismatchedDimensionException, FactoryException, TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
@@ -658,8 +700,8 @@ private void writeOsm2GraphFromDirOrFile(File osmFile,
 
     private void writeOsm2GraphFromSingleFile(File osmFile,
             ProcessData processData, ProcessVisitor processVisitor)
-            throws XMLStreamException, IOException,
-            MismatchedDimensionException, FactoryException, TransformException {
+                    throws XMLStreamException, IOException,
+                    MismatchedDimensionException, FactoryException, TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PROCESS_FORMAT, osmFile.getName());
@@ -687,6 +729,7 @@ private void processStageOne(ProcessData processData, OsItnInputFile in)
                 logger.info(NODEITEMID_FORMAT, id);
                 if (nodeFilter.get(id) != -1) {
                     OSITNNode nodeItem = (OSITNNode) item;
+
                     processNode(nodeItem);
 
                     String strId = String.valueOf(id);
@@ -758,14 +801,14 @@ private void processStageThree(ProcessData processData, OsItnInputFile in)
         RoutingElement item;
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
-                case OSMElement.RELATION:
-                    if (processData.relationStart < 0) {
-                        logger.info(NOW_PARSING_RELATIONS_FORMAT,
-                                nf(processData.counter));
-                        processData.relationStart = processData.counter;
-                    }
-                    processRelation((Relation) item);
-                    break;
+            case OSMElement.RELATION:
+                if (processData.relationStart < 0) {
+                    logger.info(NOW_PARSING_RELATIONS_FORMAT,
+                            nf(processData.counter));
+                    processData.relationStart = processData.counter;
+                }
+                processRelation((Relation) item);
+                break;
             }
             if (++processData.counter % 5000000 == 0) {
                 logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
@@ -787,11 +830,11 @@ private void addGradeNodesIfRequired(OSITNNode item, String idStr,
         }
     }
 
-    
+
     /**
      * Process properties, encode flags and create edges for the way.
      */
-    void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
+    private void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
 
         if (way.getNodes().size() < 2) {
             return;
@@ -804,6 +847,23 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
 
         long wayOsmId = way.getId();
 
+        // Handle attributeBits
+        int attributeBits = getOsmWayIdToAttributeBitMaskMap().get(way.getId());
+        if (attributeBits!=getOsmWayIdToAttributeBitMaskMap().getNoEntryValue()) {
+            // We have at least one bit set so create tags for the set attributes
+            if ((attributeBits & ATTRIBUTE_BIT_FORD)!=0) {
+                way.setTag(OSITNElement.TAG_VALUE_CLASSIFICATION_FORD, "yes");
+            }
+            if ((attributeBits & ATTRIBUTE_BIT_GATE)!=0) {
+                way.setTag("barrier", OSITNElement.TAG_VALUE_CLASSIFICATION_GATE);
+            }
+            if ((attributeBits & ATTRIBUTE_BIT_LEVEL_CROSSING)!=0) {
+                way.setTag(OSITNElement.TAG_KEY_CLASSIFICATION, OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
+            }
+        }
+
+
+
         long includeWay = encodingManager.acceptWay(way);
         if (includeWay == 0) {
             return;
@@ -814,7 +874,7 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
             return;
         }
 
-        long relationFlags = getRelFlagsMap().get(way.getId());
+        long relationFlags = getOsmWayIdToRouteWeightMap().get(way.getId());
         logger.info(RELFLAGS_FORMAT, way.getId(), relationFlags);
         String wayName = getWayName(way.getId());
         if (null != wayName) {
@@ -868,9 +928,9 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
         // with a routing algorithm bug which prevents turn restrictions from
         // working when you start or finish on the
         // final edge of a way
-         if (addAdditionalTowerNodes) {
+        if (addAdditionalTowerNodes) {
             osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes, wayFlags, wayOsmId);
-         }
+        }
         // Process No Entry and then Barriers, and finally add the remaining way
         processNoEntry(way, wayNodes, osmNodeIds, wayFlags, wayOsmId);
 
@@ -895,17 +955,17 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
 
             // add way up to barrier shadow node
             long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
-                                                        // 2
+            // 2
             transfer[transfer.length - 1] = newNodeId;
             TLongList partIds = new TLongArrayList(transfer);
             Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
                     wayFlags, wayOsmId);
             // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
             startCreatedEdges.addAll(newWays);
-            
+
             // Set the 0th node id to be our new node id
             osmNodeIds.set(0, newNodeId);
-    
+
             for (EdgeIteratorState edge : startCreatedEdges) {
                 encodingManager.applyWayTags(way, edge);
             }
@@ -919,7 +979,7 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
      * OneWay. Once it has run out of NoEntry nodes to process it passes the
      * remainder on to processBarriers to check for barriers and construct the
      * remaining way
-     * 
+     *
      * @param way
      * @param wayNodes
      *            OSITNNode objects for the way nodes, ie not including the
@@ -954,7 +1014,7 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
                 long newNodeId = newNode.getId();
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
-                                                            // 2
+                // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
                 Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
@@ -981,17 +1041,17 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
             } else {
                 failedStartNoEntries++;
                 errors_logger
-                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-                                + nodeId
-                                + " on way "
-                                + way.getId()
-                                + " for START Node "
-                                + osmNodeIds.toString()
-                                + " ("
-                                + successfulStartNoEntries
-                                + " succeeded, "
-                                + failedStartNoEntries
-                                + " failed)");
+                .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                        + nodeId
+                        + " on way "
+                        + way.getId()
+                        + " for START Node "
+                        + osmNodeIds.toString()
+                        + " ("
+                        + successfulStartNoEntries
+                        + " succeeded, "
+                        + failedStartNoEntries
+                        + " failed)");
             }
         }
         // Process Way Nodes
@@ -1102,10 +1162,10 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
 
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(osmNodeIds.size() - 2, 2); // From
-                                                                                // 0
-                                                                                // for
-                                                                                // length
-                                                                                // 2
+                // 0
+                // for
+                // length
+                // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
                 Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
@@ -1133,17 +1193,17 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
                 // TODO Figure out why there are some end nodes that don't have
                 // internal node ids
                 errors_logger
-                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-                                + nodeId
-                                + " on way "
-                                + way.getId()
-                                + " for END Node "
-                                + osmNodeIds.toString()
-                                + " ("
-                                + successfulEndNoEntries
-                                + " succeeded, "
-                                + failedEndNoEntries
-                                + " failed)");
+                .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                        + nodeId
+                        + " on way "
+                        + way.getId()
+                        + " for END Node "
+                        + osmNodeIds.toString()
+                        + " ("
+                        + successfulEndNoEntries
+                        + " succeeded, "
+                        + failedEndNoEntries
+                        + " failed)");
             }
         }
 
@@ -1179,7 +1239,7 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
     }
 
     /**
-     * 
+     *
      * @param wayId
      * @param wayCoord
      * @return "true" for (+), "-1" for (-), null for not set
@@ -1229,7 +1289,7 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
      * same location and adds ways such that they are connected. The remaining
      * way once it has processed all barriers is just created as a series of
      * ways between the remaining nodes
-     * 
+     *
      * @param way
      *            Not really used much. Could be refactored so this parameter is
      *            not required.
@@ -1327,9 +1387,9 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
             long newNodeId = -1;
 
             int graphIndex = getNodeMap().get(lastNodeId);// -4 for wayOsmId 4000000025288017
-            
+
             // An index < TOWER_NODE means it is a tower node.
-            boolean doInsertAdditionalTowerNodes = addAdditionalTowerNodes && (graphIndex < TOWER_NODE); 
+            boolean doInsertAdditionalTowerNodes = addAdditionalTowerNodes && (graphIndex < TOWER_NODE);
 
             // add end tower here
             if (doInsertAdditionalTowerNodes) {
@@ -1371,8 +1431,8 @@ private String getWayRoadDirection(long id) {
     }
 
     /**
-     * Called at Stage 3
-     * 
+     * Called at Stage 3. This processes Mandatory Turn and No Turn
+     *
      * @param relation
      * @throws XMLStreamException
      */
@@ -1469,8 +1529,6 @@ private void processNode(OSITNNode node) {
         if (isInBounds(node)) {
             addNode(node);
 
-            // ADD HANDLING FOR NO ENTRY AT THE ENDS HERE
-
             // analyze node tags for barriers
             if (node.hasTags()) {
                 long nodeFlags = encodingManager.handleNodeTags(node);
@@ -1524,16 +1582,16 @@ void prepareWaysWithRelationInfo(Relation relation) {
                 continue;
             long osmId = member.ref();
             // logger.warn(ADDING_WAY_RELATION_TO_FORMAT, osmId);
-            long oldRelationFlags = getRelFlagsMap().get(osmId);
+            long oldRelationFlags = getOsmWayIdToRouteWeightMap().get(osmId);
 
-            // Check if our new relation data is better comparated to the the
+            // Check if our new relation data is better compared to the the
             // last one
             long newRelationFlags = encodingManager.handleRelationTags(
                     relation, oldRelationFlags);
             // logger.warn(APPLYING_RELATION_FORMAT, oldRelationFlags,
             // newRelationFlags);
             if (oldRelationFlags != newRelationFlags) {
-                getRelFlagsMap().put(osmId, newRelationFlags);
+                getOsmWayIdToRouteWeightMap().put(osmId, newRelationFlags);
             }
         }
     }
@@ -1620,7 +1678,7 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
                     throw new AssertionError(
                             "Mapped index not in correct bounds " + tmpNode
-                                    + ", " + osmId);
+                            + ", " + osmId);
 
                 if (tmpNode > -TOWER_NODE) {
                     boolean convertToTowerNode = i == 0 || i == lastIndex;
@@ -1661,7 +1719,7 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
         if (fromIndex < 0 || toIndex < 0)
             throw new AssertionError(
                     "to or from index is invalid for this edge " + fromIndex
-                            + "->" + toIndex + ", points:" + pointList);
+                    + "->" + toIndex + ", points:" + pointList);
         if (pointList.getDimension() != nodeAccess.getDimension())
             throw new AssertionError(
                     "Dimension does not match for pointList vs. nodeAccess "
@@ -1783,7 +1841,6 @@ protected void finishedReading() {
     private OSITNNode addBarrierNode(long nodeId) {
         OSITNNode newNode = null;
         int graphIndex = getNodeMap().get(nodeId);
-        // System.out.println("graphIndex BEFORE is " + graphIndex);
 
         if (graphIndex < TOWER_NODE) {
             graphIndex = -graphIndex - 3;
@@ -1843,7 +1900,7 @@ private long createNewNodeId() {
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
      * <p>
-     * 
+     *
      * @return the OSM turn relation, <code>null</code>, if unsupported turn
      *         relation
      */
@@ -1926,7 +1983,7 @@ protected TLongLongMap getNodeFlagsMap() {
         return osmNodeIdToNodeFlagsMap;
     }
 
-    TLongLongHashMap getRelFlagsMap() {
+    private TLongLongHashMap getOsmWayIdToRouteWeightMap() {
         return osmWayIdToRouteWeightMap;
     }
 
@@ -1975,7 +2032,7 @@ public OsItnReader setOSMFile(File osmFile) {
     private void printInfo(String str) {
         logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(),
                 getNodeMap().getSize(), getNodeMap().getMemoryUsage(),
-                getNodeFlagsMap().size(), getRelFlagsMap().size(),
+                getNodeFlagsMap().size(), getOsmWayIdToRouteWeightMap().size(),
                 Helper.getMemInfo());
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 95508cd5c6..5e44443b2b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -1,10 +1,10 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -125,7 +125,7 @@ protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
         acceptedRailways.add("razed");
         acceptedRailways.add("historic");
         acceptedRailways.add("obliterated");
-        
+
         intendedValues.add("true");
 
         excludedValues.add("false");
@@ -495,7 +495,7 @@ protected long handleFerryTags( Way way, double unknownSpeed, double shortTripsS
         double durationInHours = parseDuration(way.getTag("duration")) / 60d;
         if (durationInHours > 0)
             try
-            {
+        {
                 Number estimatedLength = way.getTag("estimated_distance", null);
                 if (estimatedLength != null)
                 {
@@ -508,9 +508,9 @@ protected long handleFerryTags( Way way, double unknownSpeed, double shortTripsS
                         shortTripsSpeed = getMaxSpeed();
                     longTripsSpeed = shortTripsSpeed;
                 }
-            } catch (Exception ex)
-            {
-            }
+        } catch (Exception ex)
+        {
+        }
 
         if (durationInHours == 0)
         {
@@ -570,7 +570,7 @@ public int defineTurnBits( int index, int shift )
         if (maxTurnCosts == 0)
             return shift;
 
-        // optimization for turn restrictions only 
+        // optimization for turn restrictions only
         else if (maxTurnCosts == 1)
         {
             turnRestrictionBit = 1L << shift;
@@ -587,7 +587,7 @@ public final long getValue( long flags )
                 // find value
                 flags &= mask;
                 flags >>= shift;
-                return flags;
+            return flags;
             }
         };
         return shift + turnBits;
@@ -681,14 +681,14 @@ public long setBool( long flags, int key, boolean value )
     {
         switch (key)
         {
-            case K_FORWARD:
-                return value ? flags | forwardBit : flags & ~forwardBit;
-            case K_BACKWARD:
-                return value ? flags | backwardBit : flags & ~backwardBit;
-            case K_ROUNDABOUT:
-                return value ? flags | roundaboutBit : flags & ~roundaboutBit;
-            default:
-                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        case K_FORWARD:
+            return value ? flags | forwardBit : flags & ~forwardBit;
+        case K_BACKWARD:
+            return value ? flags | backwardBit : flags & ~backwardBit;
+        case K_ROUNDABOUT:
+            return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+        default:
+            throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
         }
     }
 
@@ -697,14 +697,14 @@ public boolean isBool( long flags, int key )
     {
         switch (key)
         {
-            case K_FORWARD:
-                return (flags & forwardBit) != 0;
-            case K_BACKWARD:
-                return (flags & backwardBit) != 0;
-            case K_ROUNDABOUT:
-                return (flags & roundaboutBit) != 0;
-            default:
-                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        case K_FORWARD:
+            return (flags & forwardBit) != 0;
+        case K_BACKWARD:
+            return (flags & backwardBit) != 0;
+        case K_ROUNDABOUT:
+            return (flags & roundaboutBit) != 0;
+        default:
+            throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
         }
     }
 
@@ -800,7 +800,7 @@ public boolean supports( Class<?> feature )
         if (TurnWeighting.class.isAssignableFrom(feature))
             return maxTurnCosts > 0;
 
-        return false;
+            return false;
     }
 
     /**
@@ -810,11 +810,6 @@ public boolean supports( Class<?> feature )
      */
     public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
         if (routingElement.hasTag(vehicleQualifierTypeInclusions, intendedValues)) {
-//            for (String string : vehicleQualifierTypeExclusions) {
-//                if (routingElement.hasTag(string)) {
-//                    System.out.println("Found inclusion " + string + " with " + routingElement.getTag(string));
-//                }
-//            }
             // It is specifically included
             return true;
         }
@@ -827,12 +822,6 @@ public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
      */
     public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
         if (routingElement.hasTag(vehicleQualifierTypeExclusions, excludedValues)) {
-//            for (String string : vehicleQualifierTypeExclusions) {
-//                if (routingElement.hasTag(string)) {
-//                    System.out.println("Found exclusion " + string + " with " + routingElement.getTag(string));
-//                }
-//            }
-//            System.out.println();
             // It is specifically excluded
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 5d4f10da43..bf43feb858 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -1,10 +1,10 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -63,7 +63,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
         restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
-        
+
         restrictedValues.add("private");
         restrictedValues.add("agricultural");
         restrictedValues.add("forestry");
@@ -126,50 +126,50 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         defaultSpeedMap.put("road", 20);
         // forestry stuff
         defaultSpeedMap.put("track", 15);
-        
+
         defaultSpeedMap.put("Motorway", 100);
         defaultSpeedMap.put("A Road", 55);
         defaultSpeedMap.put("B Road", 35);
         defaultSpeedMap.put("Minor Road", 35);
         defaultSpeedMap.put("Local Street", 35);
-//        defaultSpeedMap.put("Alley", 35);
+        //        defaultSpeedMap.put("Alley", 35);
         defaultSpeedMap.put("A Road-Single Carriageway", 55);
         defaultSpeedMap.put("B Road", 35);
         defaultSpeedMap.put("Minor Road", 35);
         defaultSpeedMap.put("Local Street", 35);
-//        defaultSpeedMap.put("Alley", 35);
+        //        defaultSpeedMap.put("Alley", 35);
         defaultSpeedMap.put("Motorway", 100);
         defaultSpeedMap.put("A Road", 55);
         defaultSpeedMap.put("B Road", 35);
         defaultSpeedMap.put("Minor Road", 35);
         defaultSpeedMap.put("Local Street", 35);
-//        defaultSpeedMap.put("Alley", 35);
+        //        defaultSpeedMap.put("Alley", 35);
         defaultSpeedMap.put("A Road-Dual Carriageway", 55);
         defaultSpeedMap.put("B Road", 35);
         defaultSpeedMap.put("Minor Road", 35);
         defaultSpeedMap.put("Local Street", 35);
-//        defaultSpeedMap.put("Alley", 35);
+        //        defaultSpeedMap.put("Alley", 35);
         defaultSpeedMap.put("Motorway-Slip Road", 100);
         defaultSpeedMap.put("A Road-Slip Road", 55);
         defaultSpeedMap.put("B Road", 35);
         defaultSpeedMap.put("Minor Road", 35);
         defaultSpeedMap.put("Local Street", 35);
-//        defaultSpeedMap.put("Alley", 35);
+        //        defaultSpeedMap.put("Alley", 35);
         defaultSpeedMap.put("Motorway-Roundabout", 100);
         defaultSpeedMap.put("A Road-Roundabout", 55);
         defaultSpeedMap.put("B Road-Roundabout", 35);
         defaultSpeedMap.put("Minor Road-Roundabout", 35);
         defaultSpeedMap.put("Local Street-Roundabout", 35);
-        
+
         // You can not drive down a pedestrianised street
         defaultSpeedMap.put("Pedestrianised Street", 0);
         // Limit the speed to 0 so we are not routed down these ways but include them to remove a grade separation
         // issue when a Private Road - Restricted Access road passes over another road.
-//        defaultSpeedMap.put("Private Road - Restricted Access", 0);
+        //        defaultSpeedMap.put("Private Road - Restricted Access", 0);
         // Lower the speed to 10 so it ideally routes us another way.
         defaultSpeedMap.put("Private Road - Publicly Accessible", 10);
-//        defaultSpeedMap.put("Alley", 0);
-        
+        //        defaultSpeedMap.put("Alley", 0);
+
         // osgb:type
         vehicleQualifierTypeExclusions.add("Buses");
         vehicleQualifierTypeExclusions.add("Coaches");
@@ -194,9 +194,9 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual data
         vehicleQualifierTypeExclusions.add("Escorted Traffic");
         vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the actual data
-        
 
-        
+
+
         vehicleQualifierTypeInclusions.add("Motor Vehicles");
         vehicleQualifierTypeInclusions.add("All Vehicles");
 
@@ -260,6 +260,15 @@ public long acceptWay( Way way )
                 return 0;
         }
 
+        // absolute barriers always block
+        if (way.hasTag("barrier", absoluteBarriers))
+            return 0;
+
+        // movable barriers block always for cars
+        if (way.hasTag("barrier", potentialBarriers))
+            return 0;
+
+
         if (!defaultSpeedMap.containsKey(highwayValue))
             return 0;
 
@@ -268,7 +277,8 @@ public long acceptWay( Way way )
 
         // do not drive street cars into fords
         boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
+        boolean hasFordFlag = way.hasTag("ford");
+        if (isBlockFords() && ("ford".equals(highwayValue) || hasFordFlag) && !carsAllowed)
             return 0;
 
         // check access restrictions
@@ -277,8 +287,8 @@ public long acceptWay( Way way )
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
         if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
-            return 0;        
-        
+            return 0;
+
         return acceptBit;
     }
 
@@ -313,7 +323,7 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
                     encoded |= forwardBit;
             } else
                 encoded |= directionBitMask;
-            
+
         } else
         {
             encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
@@ -355,7 +365,7 @@ public String getWayInfo(Way way )
         else
             return "destination: " + str;
     }
-    
+
     @Override
     public String toString()
     {
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/AccessProhibitedTest.java b/core/src/test/java/com/graphhopper/reader/osgb/AccessProhibitedTest.java
index 2308175fb3..024b7aa113 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/AccessProhibitedTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/AccessProhibitedTest.java
@@ -11,15 +11,13 @@
 import org.junit.Test;
 
 import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
 
 public class AccessProhibitedTest extends AbstractOsItnReaderTest{
-    
+
     /**
      * Access Prohibited for everything except Buses (So motor vehicles can NOT access)
      * @throws IOException
@@ -52,9 +50,9 @@ public void testAccessProhibitedExceptMotorVehicleTrueFrom17To19() throws IOExce
     public void testAccessProhibitedExceptMotorVehicleFalseFrom17To19() throws IOException {
         runAccessProhibitedToNode19Test("./src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-false-crossroad.xml");
     }
-    
+
     private void checkAccessProhibitedNetwork(GraphHopperStorage graph, EdgeExplorer explorer) {
-        // Assert that our graph has 4 nodes. We have lost one because of our prohibited route 
+        // Assert that our graph has 4 nodes. We have lost one because of our prohibited route
         assertEquals(4, graph.getNodes());
 
         // Assert that there are four links/roads/edges that can be seen from
@@ -101,7 +99,7 @@ private void checkAccessProhibitedNetwork(GraphHopperStorage graph, EdgeExplorer
         evaluateRouting(iter, 0, true, true, true);
     }
     private void checkNonAccessProhibitedNetwork(GraphHopperStorage graph, EdgeExplorer explorer) {
-        // Assert that our graph has 4 nodes. We have lost one because of our prohibited route 
+        // Assert that our graph has 4 nodes. We have lost one because of our prohibited route
         assertEquals(5, graph.getNodes());
 
         // Assert that there are four links/roads/edges that can be seen from
@@ -181,11 +179,11 @@ private void runAccessProhibitedToNode19Test(String filename) throws IOException
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
         carOutExplorer = graph.createEdgeExplorer(carOutFilter);
-        
+
         checkAccessProhibitedNetwork(graph, carOutExplorer);
-        
+
     }
-    
+
     private void runNonAccessProhibitedToNode19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -214,7 +212,7 @@ private void runNonAccessProhibitedToNode19Test(String filename) throws IOExcept
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
         carOutExplorer = graph.createEdgeExplorer(carOutFilter);
-        
+
         checkNonAccessProhibitedNetwork(graph, carOutExplorer);
-    }    
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/ClassificationTest.java b/core/src/test/java/com/graphhopper/reader/osgb/ClassificationTest.java
new file mode 100644
index 0000000000..6d3ec9246a
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/osgb/ClassificationTest.java
@@ -0,0 +1,49 @@
+package com.graphhopper.reader.osgb;
+
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeExplorer;
+
+public class ClassificationTest extends AbstractOsItnReaderTest {
+
+    private GraphHopperStorage graph;
+
+    @Before
+    public void setupGraph() {
+        final boolean turnRestrictionsImport = true;
+        final boolean is3D = false;
+        graph = configureStorage(turnRestrictionsImport, is3D, true);
+    }
+
+    @Test
+    public void testFord() throws IOException {
+        final File file = new File("./src/test/resources/com/graphhopper/reader/os-itn-classification-ford.xml");
+        readGraphFile(graph, file);
+        final EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
+        printNodes(explorer, 3);
+        assertEquals(3, graph.getNodes());
+        assertEquals(1, count(explorer.setBaseNode(0)));
+        assertEquals(2, count(explorer.setBaseNode(1)));
+        assertEquals(1, count(explorer.setBaseNode(2)));
+    }
+
+    @Test
+    public void testGate() throws IOException {
+        final File file = new File("./src/test/resources/com/graphhopper/reader/os-itn-classification-gate.xml");
+        readGraphFile(graph, file);
+        final EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
+        printNodes(explorer, 6);
+        assertEquals(3, graph.getNodes());
+        assertEquals(1, count(explorer.setBaseNode(0)));
+        assertEquals(2, count(explorer.setBaseNode(1)));
+        assertEquals(1, count(explorer.setBaseNode(2)));
+    }
+}
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-false-crossroad.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-false-crossroad.xml
index 9b123a8854..cdadbe1f9e 100644
--- a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-false-crossroad.xml
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-false-crossroad.xml
@@ -214,7 +214,7 @@
 		</osgb:RoadLink>
 	</osgb:networkMember>
 	<osgb:roadInformationMember>
-		<osgb:RoadRouteInformation fid='osgb4000000025219970'>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
 			<osgb:version>2</osgb:version>
 			<osgb:versionDate>2005-09-13</osgb:versionDate>
 			<osgb:theme>Road Routing Information</osgb:theme>
@@ -231,7 +231,7 @@
 				<osgb:instruction>Access Prohibited To</osgb:instruction>
 			</osgb:environmentQualifier>
 			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288019'/>
-		</osgb:RoadRouteInformation>
+		</osgb:RoadLinkInformation>
 	</osgb:roadInformationMember>
 	<osgb:roadMember>
 		<osgb:Road fid='osgb4000000025366114'>
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-true-crossroad.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-true-crossroad.xml
index 9f2cc29433..87a5469f85 100644
--- a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-true-crossroad.xml
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-buses-true-crossroad.xml
@@ -214,7 +214,7 @@
 		</osgb:RoadLink>
 	</osgb:networkMember>
 	<osgb:roadInformationMember>
-		<osgb:RoadRouteInformation fid='osgb4000000025219970'>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
 			<osgb:version>2</osgb:version>
 			<osgb:versionDate>2005-09-13</osgb:versionDate>
 			<osgb:theme>Road Routing Information</osgb:theme>
@@ -231,7 +231,7 @@
 				<osgb:instruction>Access Prohibited To</osgb:instruction>
 			</osgb:environmentQualifier>
 			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288019'/>
-		</osgb:RoadRouteInformation>
+		</osgb:RoadLinkInformation>
 	</osgb:roadInformationMember>
 	<osgb:roadMember>
 		<osgb:Road fid='osgb4000000025366114'>
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-false-crossroad.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-false-crossroad.xml
index 9f4d3886e7..5e35d356a9 100644
--- a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-false-crossroad.xml
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-false-crossroad.xml
@@ -214,7 +214,7 @@
 		</osgb:RoadLink>
 	</osgb:networkMember>
 	<osgb:roadInformationMember>
-		<osgb:RoadRouteInformation fid='osgb4000000025219970'>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
 			<osgb:version>2</osgb:version>
 			<osgb:versionDate>2005-09-13</osgb:versionDate>
 			<osgb:theme>Road Routing Information</osgb:theme>
@@ -231,7 +231,7 @@
 				<osgb:instruction>Access Prohibited To</osgb:instruction>
 			</osgb:environmentQualifier>
 			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288019'/>
-		</osgb:RoadRouteInformation>
+		</osgb:RoadLinkInformation>
 	</osgb:roadInformationMember>
 	<osgb:roadMember>
 		<osgb:Road fid='osgb4000000025366114'>
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-true-crossroad.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-true-crossroad.xml
index 43d55227bc..4f2fd568eb 100644
--- a/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-true-crossroad.xml
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-access-prohibited-except-for-motor-vehicles-true-crossroad.xml
@@ -214,7 +214,7 @@
 		</osgb:RoadLink>
 	</osgb:networkMember>
 	<osgb:roadInformationMember>
-		<osgb:RoadRouteInformation fid='osgb4000000025219970'>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
 			<osgb:version>2</osgb:version>
 			<osgb:versionDate>2005-09-13</osgb:versionDate>
 			<osgb:theme>Road Routing Information</osgb:theme>
@@ -231,7 +231,7 @@
 				<osgb:instruction>Access Prohibited To</osgb:instruction>
 			</osgb:environmentQualifier>
 			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288019'/>
-		</osgb:RoadRouteInformation>
+		</osgb:RoadLinkInformation>
 	</osgb:roadInformationMember>
 	<osgb:roadMember>
 		<osgb:Road fid='osgb4000000025366114'>
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-classification-ford.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-classification-ford.xml
new file mode 100644
index 0000000000..761a55b8b1
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-classification-ford.xml
@@ -0,0 +1,188 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osgb:FeatureCollection xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb'
+	xmlns:gml='http://www.opengis.net/gml' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
+	xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd'
+	fid='GDS-58096-1'>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277880'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory> 
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>290000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277881'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>280000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277882'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>270000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	
+
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288017">
+			<osgb:version>4</osgb:version>
+			<osgb:versionDate>2006-02-03</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:descriptiveTerm>A Road</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>290000.000,90000.000 280000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277880" />
+<!-- 			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277881" /> -->
+			<osgb:directedNode orientation="+" gradeSeparation='1' xlink:href="#osgb4000000025277881" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288018">
+			<osgb:version>4</osgb:version>
+			<osgb:versionDate>2006-02-03</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:descriptiveTerm>A Road</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>280000.000,90000.000 270000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" gradeSeparation='1' xlink:href="#osgb4000000025277881" />
+<!-- 			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277881" /> -->
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277882" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639"></osgb:referenceToTopographicArea>
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:roadInformationMember>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Routing Information</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-12-04</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Routing Information</osgb:descriptiveGroup>
+			<osgb:environmentQualifier>
+				<osgb:classification>Ford</osgb:classification>
+			</osgb:environmentQualifier>
+			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288017'/>
+			<osgb:distanceFromStart>5000.0</osgb:distanceFromStart>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>285000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+		</osgb:RoadLinkInformation>
+	</osgb:roadInformationMember>
+	<osgb:roadMember>
+		<osgb:Road fid='osgb4000000025366114'>
+			<osgb:version>6</osgb:version>
+			<osgb:versionDate>2008-11-11</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-03-13</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2004-10-26</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-02-11</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-07-15</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-10-08</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Named Road</osgb:descriptiveGroup>
+			<osgb:roadName>BONHAY ROAD</osgb:roadName>
+			<osgb:networkMember xlink:href='#osgb4000000025277880' />
+			<osgb:networkMember xlink:href='#osgb4000000025277881' />
+			<osgb:networkMember xlink:href='#osgb4000000025277882' />
+			<osgb:boundedBy>
+				<gml:Box srsName='osgb:BNG'>
+					<gml:coordinates>290000.000,90000.000 270000.000,90000.000</gml:coordinates>
+				</gml:Box>
+			</osgb:boundedBy>
+		</osgb:Road>
+	</osgb:roadMember>
+	<osgb:boundedBy>
+		<gml:Box srsName='osgb:BNG'>
+			<gml:coordinates>290822.000,91912.000 293199.000,94222.000</gml:coordinates>
+		</gml:Box>
+	</osgb:boundedBy>
+</osgb:FeatureCollection>
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-classification-gate.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-classification-gate.xml
new file mode 100644
index 0000000000..ec9a631e20
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-classification-gate.xml
@@ -0,0 +1,188 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osgb:FeatureCollection xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb'
+	xmlns:gml='http://www.opengis.net/gml' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
+	xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd'
+	fid='GDS-58096-1'>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277880'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory> 
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>290000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277881'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>280000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277882'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-10-31</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>270000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	
+
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288017">
+			<osgb:version>4</osgb:version>
+			<osgb:versionDate>2006-02-03</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:descriptiveTerm>A Road</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>290000.000,90000.000 280000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277880" />
+<!-- 			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277881" /> -->
+			<osgb:directedNode orientation="+" gradeSeparation='1' xlink:href="#osgb4000000025277881" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288018">
+			<osgb:version>4</osgb:version>
+			<osgb:versionDate>2006-02-03</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-01-27</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>
+			<osgb:descriptiveTerm>A Road</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>280000.000,90000.000 270000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" gradeSeparation='1' xlink:href="#osgb4000000025277881" />
+<!-- 			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277881" /> -->
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277882" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639"></osgb:referenceToTopographicArea>
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:roadInformationMember>
+		<osgb:RoadLinkInformation fid='osgb4000000025219970'>
+			<osgb:version>2</osgb:version>
+			<osgb:versionDate>2005-09-13</osgb:versionDate>
+			<osgb:theme>Road Routing Information</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2002-12-04</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Road Routing Information</osgb:descriptiveGroup>
+			<osgb:environmentQualifier>
+				<osgb:classification>Gate</osgb:classification>
+			</osgb:environmentQualifier>
+			<osgb:referenceToRoadLink xlink:href='#osgb4000000025288017'/>
+			<osgb:distanceFromStart>5000.0</osgb:distanceFromStart>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>285000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+		</osgb:RoadLinkInformation>
+	</osgb:roadInformationMember>
+	<osgb:roadMember>
+		<osgb:Road fid='osgb4000000025366114'>
+			<osgb:version>6</osgb:version>
+			<osgb:versionDate>2008-11-11</osgb:versionDate>
+			<osgb:theme>Road Network</osgb:theme>
+			<osgb:changeHistory>
+				<osgb:changeDate>2003-03-13</osgb:changeDate>
+				<osgb:reasonForChange>New</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2004-10-26</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-02-11</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-07-15</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:changeHistory>
+				<osgb:changeDate>2008-10-08</osgb:changeDate>
+				<osgb:reasonForChange>Modified</osgb:reasonForChange>
+			</osgb:changeHistory>
+			<osgb:descriptiveGroup>Named Road</osgb:descriptiveGroup>
+			<osgb:roadName>BONHAY ROAD</osgb:roadName>
+			<osgb:networkMember xlink:href='#osgb4000000025277880' />
+			<osgb:networkMember xlink:href='#osgb4000000025277881' />
+			<osgb:networkMember xlink:href='#osgb4000000025277882' />
+			<osgb:boundedBy>
+				<gml:Box srsName='osgb:BNG'>
+					<gml:coordinates>290000.000,90000.000 270000.000,90000.000</gml:coordinates>
+				</gml:Box>
+			</osgb:boundedBy>
+		</osgb:Road>
+	</osgb:roadMember>
+	<osgb:boundedBy>
+		<gml:Box srsName='osgb:BNG'>
+			<gml:coordinates>290822.000,91912.000 293199.000,94222.000</gml:coordinates>
+		</gml:Box>
+	</osgb:boundedBy>
+</osgb:FeatureCollection>
