diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 317909fbd6..88bc212d3d 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -7,7 +7,7 @@ Most of the contributors are mentioned at Github as [Members](https://github.com
  * andreaswolf, flag encoder versioning and more
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
- * boldtrn, motorcycle and improvements like conditional tag parsing, round trips and a lot more
+ * boldtrn, motorcycle knowledge and many improvements like conditional tag parsing, round trips, ...
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * ChristianSeitzer, motorcycle improvements
  * daisy1754, fixed usage of graphhopper.sh script
@@ -19,13 +19,13 @@ Most of the contributors are mentioned at Github as [Members](https://github.com
  * dos65, bug fixes in routing algo
  * drnextgis, ru translation and JS fixes
  * duongnt, fixes in storage
- * fbonzon, UI improvements like #615
+ * fbonzon, several UI improvements like #615
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
  * HarelM, improvements regarding elevation
  * HelgeKrueger, modularization of javascript, #590
  * henningvs, doc improvements
- * highsource, more efficient geometry update, ui fixes
+ * highsource, more efficient geometry update, UI fixes
  * IsNull, improvements like #708
  * jansoe, many improvements regarding A* algorithm, forcing direction, roundabouts etc
  * jansonhanson, general host config
@@ -33,14 +33,14 @@ Most of the contributors are mentioned at Github as [Members](https://github.com
  * karussell, one of the core developers
  * khuebner, initial turn costs support
  * lmar, improved instructions
- * michaz, public transport
+ * michaz, one of the core developers
  * mprins, improvements for travis CI and regarding JDK9 #806
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
  * PGWelch, shapefile reader #874
  * ratrun, route relations, GPX information, bike handling etc
  * rajanski, script to do routing via PostGIS
- * rodneyodonnell, improved dead end removal and fords
+ * rodneyodonnell, improved dead end removal (PrepareRoutingSubnetworks) and fords
  * rodo, more descriptions
  * seeebiii, motorcycle improvements
  * stefanholder, Stefan Holder, BMW AG, refactored unfavoring of virtual edges #885
diff --git a/android/app/build.gradle b/android/app/build.gradle
index bfe23c58fc..a7f6b9ab26 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion 25
-    buildToolsVersion "25.0.2"
+    buildToolsVersion "25.0.3"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
diff --git a/android/build.gradle b/android/build.gradle
index 11a13c7c5b..e6298473b5 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -4,7 +4,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.3'
+        classpath 'com.android.tools.build:gradle:2.3.1'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index edad11c6f7..47522179d5 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Aug 16 13:14:49 EEST 2016
+#Fri Mar 03 12:50:23 EET 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/config-example.properties b/config-example.properties
index c7ff4b326f..e8e9dbc509 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -33,11 +33,11 @@ graph.flag_encoders=car
 
 # By default the speed mode with the 'fastest' weighting is used. Internally a graph preparation via
 # contraction hierarchies (CH) is done to speed routing up. This requires more RAM/disc space for holding the
-# graph but less for every request. You can also setup multiple weightings, by providing a coma separated list.
+# graph but less for every request. You can also setup multiple weightings, by providing a comma separated list.
 prepare.ch.weightings=fastest
 
 
-# Disable the speed mode. Should be use only with routing.max_visited_nodes or when the hybrid mode is enabled instead
+# Disable the speed mode. Should be used only with routing.max_visited_nodes or when the hybrid mode is enabled instead
 # prepare.ch.weightings=no
 
 
@@ -61,11 +61,12 @@ prepare.min_network_size=200
 prepare.min_one_way_network_size=200
 
 
+
 ##### Routing #####
 
 
 # You can define the maximum visited nodes when routing. This may result in not found connections if there is no
-# connection between two points wihtin the given visited nodes. The default is Integer.MAX_VALUE. Useful for flexibility mode
+# connection between two points within the given visited nodes. The default is Integer.MAX_VALUE. Useful for flexibility mode
 # routing.max_visited_nodes = 1000000
 
 
@@ -92,9 +93,11 @@ routing.non_ch.max_waypoint_distance = 1000000
 # block_area=lat1,lon1,lat2,lon2
 
 
+
 ##### Web #####
 
-# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for stronger security.
+
+# if you want to support jsonp response type you need to add it explicitly here. By default it is disabled for stronger security.
 # web.jsonp_allowed=true
 
 
@@ -112,3 +115,18 @@ graph.dataaccess=RAM_STORE
 
 # Sort the graph after import to make requests roughly ~10% faster. Note that this requires significantly more RAM on import.
 # graph.do_sort=true
+
+
+
+##### Spatial Rules #####
+# Spatial Rules require some configuration and only work with the DataFlagEncoder.
+
+
+# Spatial Rules require you to provide Polygons in which the rules are enforced
+# The line below contains the default location for these rules
+# spatial_rules.location=web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
+
+# You can define the maximum BBox for which spatial rules are loaded.
+# You might want to do this if you are only importing a small area and don't need rules for other countries.
+# Having less rules, might result in a smaller graph. The line below contains the world-wide bounding box, uncomment and adapt to your need.
+# spatial_rules.max_bbox=-180,180,-90,90
\ No newline at end of file
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index c66737605d..66a9f1cb02 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,6 @@
 0.9
+    remove war bundling support #297
+    rename of DefaultModule to GraphHopperModule and GHServletModule to GraphHopperServletModule
     EncodedValue uses Math.round(value/factor). This can change the retrieved values for EncodedValues #954
     EncodedDoubleValue and EncodedValue requires maxValue/factor to be a natural number #954
     default base algorithm for all modes is bidirectional A* (except speed mode)
diff --git a/core/pom.xml b/core/pom.xml
index 62f259761a..e0e51e3078 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -81,9 +81,9 @@
             <version>${jackson.version}</version>
         </dependency>
         <dependency>
-            <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>${json.org.version}</version>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index bfb9397bf7..586e15fcda 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -497,6 +497,10 @@ public GraphHopper setFlagEncoderFactory(FlagEncoderFactory factory) {
         return this;
     }
 
+    public FlagEncoderFactory getFlagEncoderFactory() {
+        return this.flagEncoderFactory;
+    }
+
     /**
      * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
      * args) ala CmdArgs.read(args) or via configuration file ala
@@ -979,13 +983,18 @@ public GHResponse route(GHRequest request) {
 
             FlagEncoder encoder = encodingManager.getEncoder(vehicle);
 
-            boolean forceFlexibleMode = hints.getBool(CH.DISABLE, false);
-            if (!chFactoryDecorator.isDisablingAllowed() && forceFlexibleMode)
-                throw new IllegalArgumentException("Flexible mode not enabled on the server-side");
+            boolean disableCH = hints.getBool(CH.DISABLE, false);
+            if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
+                throw new IllegalArgumentException("Disabling CH not allowed on the server-side");
+
+            boolean disableLM = hints.getBool(Landmark.DISABLE, false);
+            if (!lmFactoryDecorator.isDisablingAllowed() && disableLM)
+                throw new IllegalArgumentException("Disabling LM not allowed on the server-side");
+
             String algoStr = request.getAlgorithm();
             if (algoStr.isEmpty())
-                algoStr = chFactoryDecorator.isEnabled() && !forceFlexibleMode &&
-                        !(lmFactoryDecorator.isEnabled() && !hints.getBool(Landmark.DISABLE, false)) ? DIJKSTRA_BI : ASTAR_BI;
+                algoStr = chFactoryDecorator.isEnabled() && !disableCH &&
+                        !(lmFactoryDecorator.isEnabled() && !disableLM) ? DIJKSTRA_BI : ASTAR_BI;
 
             List<GHPoint> points = request.getPoints();
             // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
@@ -1014,7 +1023,7 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                 RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
                 Weighting weighting;
                 QueryGraph queryGraph;
-                if (chFactoryDecorator.isEnabled() && !forceFlexibleMode) {
+                if (chFactoryDecorator.isEnabled() && !disableCH) {
                     boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
                     if (!forceCHHeading && request.hasFavoredHeading(0))
                         throw new IllegalArgumentException("Heading is not (fully) supported for CHGraph. See issue #483");
diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index 3b535806bf..84e404915d 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -12,17 +12,20 @@
     public static abstract class Leg {
         public final String type;
         public final String departureLocation;
+        public final Date departureTime;
         public final List<EdgeIteratorState> edges;
         public final Geometry geometry;
-
         public final double distance;
+        public final Date arrivalTime;
 
-        public Leg(String type, String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance) {
+        public Leg(String type, String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, Date arrivalTime) {
             this.type = type;
             this.departureLocation = departureLocation;
             this.edges = edges;
             this.geometry = geometry;
             this.distance = distance;
+            this.departureTime = departureTime;
+            this.arrivalTime = arrivalTime;
         }
 
         public double getDistance() {
@@ -35,17 +38,22 @@ public double getDistance() {
         public final String name;
         public final Point geometry;
 
-        public Stop(String stop_id, String name, Point geometry) {
+        public final Date arrivalTime;
+        public final Date departureTime;
+
+        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date departureTime) {
             this.stop_id = stop_id;
             this.name = name;
             this.geometry = geometry;
+            this.arrivalTime = arrivalTime;
+            this.departureTime = departureTime;
         }
     }
     public static class WalkLeg extends Leg {
         public final InstructionList instructions;
 
-        public WalkLeg(String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions) {
-            super("walk", departureLocation, edges, geometry, distance);
+        public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
+            super("walk", departureLocation, departureTime, edges, geometry, distance, arrivalTime);
             this.instructions = instructions;
         }
     }
@@ -53,22 +61,20 @@ public WalkLeg(String departureLocation, List<EdgeIteratorState> edges, Geometry
         public final String feedId;
         public final boolean isInSameVehicleAsPrevious;
         public final String trip_headsign;
-        public final Date departureTime;  // TODO: Java 8: Should be LocalDateTime
         public final long travelTime;
         public final List<Stop> stops;
         public final Stop boardStop;
         public final String tripId;
         public final String routeId;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, Stop stop, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
-            super("pt", stop.name, edges, geometry, distance);
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, Stop stop, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
+            super("pt", stop.name, departureTime, edges, geometry, distance, arrivalTime);
             this.feedId = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
             this.boardStop = stop;
             this.tripId = tripId;
             this.routeId = routeId;
             this.trip_headsign = edges.get(0).getName();
-            this.departureTime = departureTime;
             this.travelTime = travelTime;
             this.stops = stops;
         }
diff --git a/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java b/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java
deleted file mode 100644
index 941956737f..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/GeoJsonPolygon.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wrapper class for the {@link Polygon}.
- */
-public class GeoJsonPolygon implements Geometry {
-
-    private List<Polygon> polygons = new ArrayList<>();
-
-    @Override
-    public String getType() {
-        return "Polygon";
-    }
-
-    @Override
-    public boolean isPoint() {
-        return false;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPointList() {
-        return false;
-    }
-
-    @Override
-    public PointList asPointList() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return true;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        return this;
-    }
-
-    public List<Polygon> getPolygons() {
-        return polygons;
-    }
-
-    public GeoJsonPolygon addPolygon(Polygon polygon) {
-        this.polygons.add(polygon);
-        return this;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java b/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
index 28ab5f7c10..1f0bc9c770 100644
--- a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
+++ b/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
@@ -17,7 +17,10 @@
  */
 package com.graphhopper.json.geo;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.util.shapes.BBox;
+import com.vividsolutions.jts.geom.Geometry;
 
 import java.util.Map;
 
@@ -33,7 +36,8 @@
     final Geometry geometry;
     final Map<String, Object> properties;
 
-    public JsonFeature(String id, String type, BBox bbox, Geometry geometry, Map<String, Object> properties) {
+    @JsonCreator
+    public JsonFeature(@JsonProperty("id") String id, @JsonProperty("type") String type, @JsonProperty("bbox") BBox bbox, @JsonProperty("geometry") Geometry geometry, @JsonProperty("properties") Map<String, Object> properties) {
         this.id = id;
         this.type = type;
         this.bbox = bbox;
diff --git a/core/src/main/java/com/graphhopper/json/geo/LineString.java b/core/src/main/java/com/graphhopper/json/geo/LineString.java
deleted file mode 100644
index 5fb69389b9..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/LineString.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * Wrapper to read a PointList easily from GeoJSON (type=LineString)
- *
- * @author Peter Karich
- */
-public class LineString extends PointList implements Geometry {
-    public LineString(int size, boolean is3D) {
-        super(size, is3D);
-    }
-
-    @Override
-    public String getType() {
-        return "LineString";
-    }
-
-    @Override
-    public boolean isPoint() {
-        return false;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPointList() {
-        return true;
-    }
-
-    @Override
-    public PointList asPointList() {
-        return this;
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return false;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/Point.java b/core/src/main/java/com/graphhopper/json/geo/Point.java
deleted file mode 100644
index ea75ca8c3b..0000000000
--- a/core/src/main/java/com/graphhopper/json/geo/Point.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
-
-/**
- * Wrapper to read a GHPoint3D easily from GeoJSON (type=Point)
- *
- * @author Peter Karich
- */
-public class Point extends GHPoint3D implements Geometry {
-    public Point(double lat, double lon) {
-        super(lat, lon, Double.NaN);
-    }
-
-    public Point(double lat, double lon, double ele) {
-        super(lat, lon, ele);
-    }
-
-    @Override
-    public String toString() {
-        return lat + ", " + lon;
-    }
-
-    @Override
-    public boolean isPoint() {
-        return true;
-    }
-
-    @Override
-    public GHPoint asPoint() {
-        return this;
-    }
-
-    @Override
-    public boolean isPointList() {
-        return false;
-    }
-
-    @Override
-    public PointList asPointList() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public boolean isPolygon() {
-        return false;
-    }
-
-    @Override
-    public GeoJsonPolygon asPolygon() {
-        throw new UnsupportedOperationException("Not supported");
-    }
-
-    @Override
-    public String getType() {
-        return "Point";
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 2225e5c956..85fc68c437 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -33,7 +33,7 @@
  * @author jan soe
  */
 public class InstructionsFromEdges implements Path.EdgeVisitor {
-    private final Graph graph;
+
     private final Weighting weighting;
     private final FlagEncoder encoder;
     private final NodeAccess nodeAccess;
@@ -74,7 +74,6 @@
     private EdgeExplorer crossingExplorer;
 
     public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder, NodeAccess nodeAccess, Translation tr, InstructionList ways) {
-        this.graph = graph;
         this.weighting = weighting;
         this.encoder = encoder;
         this.nodeAccess = nodeAccess;
@@ -280,19 +279,13 @@ private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjN
         In most cases this will be a simple follow the current street and we don't necessarily
         need a turn instruction
          */
-        int prevEdge = -1;
-        EdgeIterator flagIter = crossingExplorer.setBaseNode(baseNode);
-        while (flagIter.next()) {
-            if (flagIter.getAdjNode() == prevNode || flagIter.getBaseNode() == prevNode)
-                prevEdge = flagIter.getEdge();
-
-        }
-        if (prevEdge == -1) {
-            throw new IllegalStateException("Couldn't find the edges for " + prevNode + "-" + baseNode + "-" + adjNode);
+        if (prevEdge == null) {
+            // TODO Should we log this case?
+            return sign;
         }
 
         long flag = edge.getFlags();
-        long prevFlag = graph.getEdgeIteratorState(prevEdge, baseNode).getFlags();
+        long prevFlag = prevEdge.getFlags();
 
         boolean surroundingStreetsAreSlower = surroundingEdges.surroundingStreetsAreSlowerByFactor(1);
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index 617a7dd4a0..90cef22bc0 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -243,8 +243,8 @@ private String getDefaultWeighting() {
 
     @Override
     public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory defaultAlgoFactory, HintsMap map) {
-        boolean forceFlexMode = map.getBool(DISABLE, false);
-        if (!isEnabled() || forceFlexMode)
+        boolean disableCH = map.getBool(DISABLE, false);
+        if (!isEnabled() || disablingAllowed && disableCH)
             return defaultAlgoFactory;
 
         if (preparations.isEmpty())
@@ -286,19 +286,10 @@ public void prepare(final StorableProperties properties) {
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
-                    String errorKey = CH.PREPARE + "error." + name;
-                    try {
-                        // toString is not taken into account so we need to cheat, see http://stackoverflow.com/q/6113746/194609 for other options
-                        Thread.currentThread().setName(name);
-                        properties.put(errorKey, "CH preparation incomplete");
-                        prepare.doWork();
-                        properties.remove(errorKey);
-                        properties.put(CH.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
-                    } catch (Exception ex) {
-                        LOGGER.error("Problem while CH preparation " + name, ex);
-                        properties.put(errorKey, ex.getMessage());
-                        throw ex;
-                    }
+                    // toString is not taken into account so we need to cheat, see http://stackoverflow.com/q/6113746/194609 for other options
+                    Thread.currentThread().setName(name);
+                    prepare.doWork();
+                    properties.put(CH.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
                 }
             }, name);
 
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
index e0f8d31722..39165c2f54 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
@@ -216,8 +216,8 @@ public int size() {
 
     @Override
     public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFactory defaultAlgoFactory, HintsMap map) {
-        boolean forceFlexMode = map.getBool(DISABLE, false);
-        if (!isEnabled() || disablingAllowed && forceFlexMode)
+        boolean disableLM = map.getBool(DISABLE, false);
+        if (!isEnabled() || disablingAllowed && disableLM)
             return defaultAlgoFactory;
 
         if (preparations.isEmpty())
@@ -279,23 +279,16 @@ public boolean loadOrDoWork(final StorableProperties properties) {
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
-                    String errorKey = Landmark.PREPARE + "error." + name;
-                    try {
-                        Thread.currentThread().setName(name);
-                        properties.put(errorKey, "LM preparation incomplete");
-                        plm.doWork();
-                        properties.remove(errorKey);
-                        properties.put(Landmark.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
-                    } catch (Exception ex) {
-                        LOGGER.error("Problem while LM preparation " + name, ex);
-                        properties.put(errorKey, ex.getMessage());
-                    }
+                    Thread.currentThread().setName(name);
+                    plm.doWork();
+                    properties.put(Landmark.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
                 }
             }, name);
             submittedPreparations++;
         }
 
         threadPool.shutdown();
+
         try {
             for (int i = 0; i < submittedPreparations; i++) {
                 completionService.take().get();
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
index 8634b8a4c3..b4e13bb3b8 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
@@ -468,7 +468,7 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {
      * @return the weight from the landmark to the specified node. Where the landmark integer is not
      * a node ID but the internal index of the landmark array.
      */
-    public int getFromWeight(int landmarkIndex, int node) {
+    int getFromWeight(int landmarkIndex, int node) {
         int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + FROM_OFFSET)
                 & 0x0000FFFF;
         assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
@@ -484,9 +484,9 @@ public int getFromWeight(int landmarkIndex, int node) {
     }
 
     /**
-     * @return the weight from the specified node to the landmark (*as index*)
+     * @return the weight from the specified node to the landmark (specified *as index*)
      */
-    public int getToWeight(int landmarkIndex, int node) {
+    int getToWeight(int landmarkIndex, int node) {
         int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + TO_OFFSET)
                 & 0x0000FFFF;
         assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index 1bf8245db5..25bce3a67e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -19,11 +19,7 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import static com.graphhopper.routing.util.BikeCommonFlagEncoder.K_UNPAVED;
-import com.graphhopper.routing.util.spatialrules.AccessValue;
-import com.graphhopper.routing.util.spatialrules.SpatialRule;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.TransportationMode;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.routing.weighting.GenericWeighting;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -90,8 +86,7 @@
     private boolean storeWeight = false;
     private boolean storeWidth = false;
     private EncodedValue spatialEncoder;
-    private int spatialRules = 0;
-    private SpatialRuleLookup spatialRuleLookup;
+    private SpatialRuleLookup spatialRuleLookup = SpatialRuleLookup.EMPTY;
 
     public DataFlagEncoder() {
         this(5, 5, 0);
@@ -105,7 +100,6 @@ public DataFlagEncoder(PMap properties) {
         this.setStoreHeight(properties.getBool("store_height", false));
         this.setStoreWeight(properties.getBool("store_weight", false));
         this.setStoreWidth(properties.getBool("store_width", false));
-        this.setSpatialRules(properties.getInt("spatial_rules", 0));
     }
 
     public DataFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
@@ -217,12 +211,10 @@ public int defineWayBits(int index, int shift) {
         accessEncoder = new EncodedValue("access car", shift, 3, 1, 1, 4, true);
         shift += accessEncoder.getBits();
 
-        if (spatialRules > 0) {
-            int tmpMax = spatialRules + 1;
-            int bits = 32 - Integer.numberOfLeadingZeros(tmpMax);
-            spatialEncoder = new EncodedValue("spatial_location", shift, bits, 1, 1, tmpMax, true);
-            shift += spatialEncoder.getBits();
-        }
+        int tmpMax = spatialRuleLookup.size()-1;
+        int bits = 32 - Integer.numberOfLeadingZeros(tmpMax);
+        spatialEncoder = new EncodedValue("spatial_location", shift, bits, 1, 0, tmpMax, true);
+        shift += spatialEncoder.getBits();
 
         return shift;
     }
@@ -273,7 +265,7 @@ int getAccessValue(ReaderWay way) {
             }
         }
 
-        if (isSpatialRuleLookupEnabled() && accessValue == 0) {
+        if (accessValue == 0) {
             // TODO Fix transportation mode when adding other forms of transportation
             switch (getSpatialRule(way).getAccessValue(way.getTag("highway", ""), TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE)) {
                 case ACCESSIBLE:
@@ -325,7 +317,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
 
             // MAXSPEED
             double maxSpeed = parseSpeed(way.getTag("maxspeed"));
-            if (isSpatialRuleLookupEnabled() && maxSpeed < 0) {
+            if (maxSpeed < 0) {
                 // TODO What if no maxspeed is set, but only forward and backward, and both are higher than the usually allowed?
                 maxSpeed = getSpatialRule(way).getMaxSpeed(way.getTag("highway", ""), maxSpeed);
             }
@@ -412,13 +404,10 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
 
             flags = accessEncoder.setValue(flags, getAccessValue(way));
 
-
-            if (isSpatialRuleLookupEnabled()) {
-                GHPoint estimatedCenter = way.getTag("estimated_center", null);
-                if (estimatedCenter != null) {
-                    SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
-                    flags = spatialEncoder.setValue(flags, spatialRuleLookup.getSpatialId(rule));
-                }
+            GHPoint estimatedCenter = way.getTag("estimated_center", null);
+            if (estimatedCenter != null) {
+                SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
+                flags = spatialEncoder.setValue(flags, spatialRuleLookup.getSpatialId(rule));
             }
 
             return flags;
@@ -427,17 +416,6 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         }
     }
 
-    private boolean isSpatialRuleLookupEnabled() {
-        if (spatialRules > 0) {
-            if (spatialRuleLookup == null)
-                throw new IllegalStateException("This encoder was asked to store spatial IDs for every edge, " +
-                        "but no spatial lookup was specified");
-
-            return true;
-        }
-        return false;
-    }
-
     private SpatialRule getSpatialRule(ReaderWay way) {
         GHPoint estmCentre = way.getTag("estimated_center", null);
         if (estmCentre != null) {
@@ -832,16 +810,7 @@ public boolean isStoreWidth() {
     }
 
 
-    public DataFlagEncoder setSpatialRules(int rules) {
-        this.spatialRules = rules;
-        return this;
-    }
-
     public DataFlagEncoder setSpatialRuleLookup(SpatialRuleLookup spatialRuleLookup) {
-        if (spatialRuleLookup.size() != spatialRules)
-            throw new IllegalArgumentException("You have to configure the encoder to accept the identical amount of rules " +
-                    "that the spatial rule lookup has (" + spatialRuleLookup.size() + ") but it was " + spatialRules);
-
         this.spatialRuleLookup = spatialRuleLookup;
         return this;
     }
@@ -849,7 +818,7 @@ public DataFlagEncoder setSpatialRuleLookup(SpatialRuleLookup spatialRuleLookup)
     @Override
     public InstructionAnnotation getAnnotation(long flags, Translation tr) {
         if (isTransportModeFord(flags)) {
-            return new InstructionAnnotation(1, tr.tr("way_contains_ford"), 0, true);
+            return new InstructionAnnotation(1, tr.tr("way_contains_ford"),0, false);
         }
 
         return super.getAnnotation(flags, tr);
@@ -861,8 +830,7 @@ protected String getPropertiesString() {
         return super.getPropertiesString() +
                 "|store_height=" + storeHeight +
                 "|store_weight=" + storeWeight +
-                "|store_width=" + storeWidth +
-                "|spatial_rules=" + spatialRules;
+                "|store_width=" + storeWidth;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
similarity index 91%
rename from core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java
rename to core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
index 9d0fd60fad..b1b1b1bed8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
@@ -15,11 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util.spatialrules.countries;
-
-import com.graphhopper.routing.util.spatialrules.AbstractSpatialRule;
-import com.graphhopper.routing.util.spatialrules.AccessValue;
-import com.graphhopper.routing.util.spatialrules.TransportationMode;
+package com.graphhopper.routing.util.spatialrules;
 
 /**
  * Default implementation for the SpatialRule that contains the current default values
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
index 1ff54e349e..8d4bfc9c6d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
@@ -53,16 +53,6 @@
      */
     List<Polygon> getBorders();
 
-    /**
-     * Set the borders in which the SpatialRule is valid
-     */
-    SpatialRule setBorders(List<Polygon> borders);
-
-    /**
-     * Add a polygon to the borders in which the SpatialRule is valid
-     */
-    SpatialRule addBorder(Polygon polygon);
-
     /**
      * Returns the id for this rule, e.g. the ISO name of the country. The id has to be unique.
      */
@@ -81,7 +71,7 @@ public AccessValue getAccessValue(String highwayTag, TransportationMode transpor
 
         @Override
         public String getId() {
-            return "";
+            return "SpatialRule.EMPTY";
         }
 
         @Override
@@ -89,16 +79,6 @@ public String getId() {
             throw new IllegalArgumentException("Empty rule does not have borders");
         }
 
-        @Override
-        public SpatialRule setBorders(List<Polygon> borders) {
-            throw new IllegalArgumentException("Empty rule cannot have borders");
-        }
-
-        @Override
-        public SpatialRule addBorder(Polygon polygon) {
-            throw new IllegalArgumentException("Empty rule cannot have borders");
-        }
-
         @Override
         public String toString() {
             return "SpatialRule.EMPTY";
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
index 8b2a445dd4..29f8eba3de 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
@@ -26,7 +26,7 @@
  */
 class SpatialRuleContainer {
 
-    protected final Set<SpatialRule> rules = new LinkedHashSet<>();
+    final Set<SpatialRule> rules = new LinkedHashSet<>();
 
     public SpatialRuleContainer addRule(SpatialRule spatialRule) {
         rules.add(spatialRule);
@@ -38,7 +38,7 @@ public SpatialRuleContainer addRules(Collection<SpatialRule> rules) {
         return this;
     }
 
-    public Collection<SpatialRule> getRules() {
+    Collection<SpatialRule> getRules() {
         return rules;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
index 1d5aa162c4..4f66a68b31 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
@@ -43,24 +43,46 @@
      */
     SpatialRule lookupRule(GHPoint point);
 
-    /**
-     * Add a rule to the lookup.
-     */
-    void addRule(SpatialRule rule);
-
     /**
      * This method returns an identification number from 0 to size (exclusive) for the specified rule.
-     * The id is fix for a given set of SpatialRules. When the set of rules is modified, the id might change.
+     * The id is fix for a given set of SpatialRules.
      */
     int getSpatialId(SpatialRule rule);
 
     /**
-     * Returns the outer bounds of the spatial lookup.
+     * @return the number of rules added to this lookup.
      */
-    BBox getBounds();
+    int size();
 
     /**
-     * @return the number of rules added to this lookup.
+     * @return the bounds of the SpatialRuleLookup
      */
-    int size();
+    BBox getBounds();
+
+    SpatialRuleLookup EMPTY = new SpatialRuleLookup() {
+        @Override
+        public SpatialRule lookupRule(double lat, double lon) {
+            return SpatialRule.EMPTY;
+        }
+
+        @Override
+        public SpatialRule lookupRule(GHPoint point) {
+            return SpatialRule.EMPTY;
+        }
+
+        @Override
+        public int getSpatialId(SpatialRule rule) {
+            return 0;
+        }
+
+        @Override
+        public int size() {
+            return 1;
+        }
+
+        @Override
+        public BBox getBounds() {
+            return new BBox(-180, 180, -90, 90);
+        }
+    };
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
index 398a70bafb..c43771be9b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
@@ -28,7 +28,7 @@
  *
  * @author Robin Boldt
  */
-class SpatialRuleLookupArray implements SpatialRuleLookup {
+public class SpatialRuleLookupArray implements SpatialRuleLookup {
 
     // resolution in full decimal degrees
     private final double resolution;
@@ -44,19 +44,23 @@
     private final List<SpatialRule> singleRules = new ArrayList<>();
 
     /**
-     * @param bounds     the outer bounds for the Lookup
+     * @param spatialRules     the spatial rules
      * @param resolution of the array in decimal degrees, see: https://en.wikipedia.org/wiki/Decimal_degrees
      *                   The downside of using decimal degrees is that this is not fixed to a certain m range as
      * @param exact      if exact it will also perform a polygon contains for border tiles, might fail for small holes
      *                   in the Polygon that are not represented in the tile array.
+     * @param bounds create the SpatialRuleLookup for the given BBox
      */
-    SpatialRuleLookupArray(BBox bounds, double resolution, boolean exact) {
-        if (bounds == null)
-            throw new IllegalArgumentException("BBox cannot be null");
+    public SpatialRuleLookupArray(List<SpatialRule> spatialRules, double resolution, boolean exact, BBox bounds) {
+
+        if(!bounds.isValid())
+            throw new IllegalStateException("Bounds are not valid: "+bounds);
+
+        this.bounds = bounds;
+
         if (resolution < 1e-100)
             throw new IllegalArgumentException("resolution cannot be that high " + resolution);
 
-        this.bounds = bounds;
         this.resolution = resolution;
         this.checkDiff = (resolution / 2) - (resolution / 10);
         this.exact = exact;
@@ -78,6 +82,10 @@ public SpatialRuleContainer addRules(Collection<SpatialRule> rules) {
                 throw new IllegalArgumentException("Cannot add to empty rule container");
             }
         });
+
+        for (SpatialRule spatialRule : spatialRules) {
+            addRuleInternal(spatialRule);
+        }
     }
 
     private int getNumberOfYGrids() {
@@ -115,7 +123,7 @@ public SpatialRule lookupRule(double lat, double lon) {
         return SpatialRule.EMPTY;
     }
 
-    protected int getRuleContainerIndex(int xIndex, int yIndex) {
+    private int getRuleContainerIndex(int xIndex, int yIndex) {
         if (xIndex < 0 || xIndex >= lookupArray.length) {
             return EMPTY_RULE_INDEX;
         }
@@ -128,7 +136,7 @@ protected int getRuleContainerIndex(int xIndex, int yIndex) {
     /**
      * Might fail for small holes that do not occur in the array
      */
-    protected boolean isBorderTile(int xIndex, int yIndex, int ruleIndex) {
+    private boolean isBorderTile(int xIndex, int yIndex, int ruleIndex) {
         for (int i = -1; i < 2; i++) {
             for (int j = -1; j < 2; j++) {
                 if (i != xIndex && j != yIndex)
@@ -145,15 +153,18 @@ public SpatialRule lookupRule(GHPoint point) {
     }
 
     private int getXIndexForLon(double lon) {
+        if(lon < bounds.minLon)
+            return 0;
         return (int) Math.floor(Math.abs(lon - bounds.minLon) / resolution);
     }
 
     private int getYIndexForLat(double lat) {
+        if(lat < bounds.minLat)
+            return 0;
         return (int) Math.floor(Math.abs(lat - bounds.minLat) / resolution);
     }
 
-    @Override
-    public void addRule(SpatialRule rule) {
+    private void addRuleInternal(SpatialRule rule) {
         if (rule == null)
             throw new IllegalArgumentException("rule cannot be null");
 
@@ -201,7 +212,7 @@ private void addSingleRule(SpatialRule rule) {
         singleRules.add(rule);
     }
 
-    public SpatialRule getSpatialRule(int id) {
+    SpatialRule getSpatialRule(int id) {
         if (id < 0 || id >= ruleContainers.size())
             throw new IllegalArgumentException("SpatialRuleId " + id + " is illegal");
 
@@ -214,7 +225,7 @@ public SpatialRule getSpatialRule(int id) {
     /**
      * This method adds the container if no such rule container exists in this lookup and returns the index otherwise.
      */
-    int addRuleContainer(SpatialRuleContainer container) {
+    private int addRuleContainer(SpatialRuleContainer container) {
         int newIndex = this.ruleContainers.indexOf(container);
         if (newIndex >= 0)
             return newIndex;
@@ -261,4 +272,5 @@ public int size() {
     public BBox getBounds() {
         return bounds;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
deleted file mode 100644
index 9e347a32de..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util.spatialrules;
-
-import com.graphhopper.json.geo.Geometry;
-import com.graphhopper.json.geo.JsonFeature;
-import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.util.spatialrules.countries.DefaultSpatialRule;
-import com.graphhopper.util.shapes.BBox;
-
-import java.util.*;
-
-/**
- * Creates a SpatialRuleLookup for a certain set of predefined areas.
- *
- * @author Robin Boldt
- */
-public class SpatialRuleLookupBuilder {
-
-    public interface SpatialRuleFactory {
-        /**
-         * This method creates a SpatialRule out of the provided polygons indicating the 'border'.
-         */
-        SpatialRule createSpatialRule(String id, final List<Polygon> polygons);
-    }
-
-    public static class SpatialRuleListFactory implements SpatialRuleFactory {
-        private final Map<String, SpatialRule> ruleMap;
-
-        public SpatialRuleListFactory(SpatialRule... rules) {
-            this(Arrays.asList(rules));
-        }
-
-        public SpatialRuleListFactory(List<SpatialRule> rules) {
-            ruleMap = new HashMap<>(rules.size());
-            for (SpatialRule rule : rules) {
-                ruleMap.put(rule.getId(), rule);
-            }
-        }
-
-        @Override
-        public SpatialRule createSpatialRule(String id, final List<Polygon> polygons) {
-            if (id == null)
-                throw new IllegalArgumentException("ID cannot be null to find a SpatialRule");
-
-            SpatialRule spatialRule = ruleMap.get(id);
-            if (spatialRule != null) {
-                spatialRule.setBorders(polygons);
-                return spatialRule;
-            }
-            return SpatialRule.EMPTY;
-        }
-    }
-
-    public static class SpatialRuleDefaultFactory implements SpatialRuleFactory {
-        @Override
-        public SpatialRule createSpatialRule(final String id, final List<Polygon> polygons) {
-            return new DefaultSpatialRule() {
-                @Override
-                public String getId() {
-                    return id;
-                }
-            }.setBorders(polygons);
-        }
-    }
-
-    public SpatialRuleLookup build(List<SpatialRule> rules, JsonFeatureCollection jsonFeatureCollection,
-                                   BBox bounds, double resolution, boolean exact) {
-        return build("ISO_A3", new SpatialRuleListFactory(rules), jsonFeatureCollection, bounds, resolution, exact);
-    }
-
-    /**
-     * This method connects the rules with the jsonFeatureCollection via their ISO_A3 property and the rules its
-     * getId method.
-     *
-     * @param jsonProperty the key that should be used to fetch the ID that is passed to SpatialRuleFactory#createSpatialRule
-     * @return the index or null if the specified bounds does not intersect with the calculated ones from the rules.
-     */
-    public SpatialRuleLookup build(String jsonProperty, SpatialRuleFactory ruleFactory, JsonFeatureCollection jsonFeatureCollection,
-                                   BBox bounds, double resolution, boolean exact) {
-
-        // TODO filter out polyons that don't intersect with the given BBox, will be implicitly done later anyway
-        BBox polygonBounds = BBox.createInverse(false);
-        List<SpatialRule> rules = new ArrayList<>();
-        Set<String> ids = new HashSet<>();
-        int unknownCounter = 0;
-        for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
-            Geometry geometry = jsonFeature.getGeometry();
-            if (!geometry.isPolygon())
-                continue;
-
-            List<Polygon> borders = geometry.asPolygon().getPolygons();
-            String id = (String) jsonFeature.getProperty(jsonProperty);
-            if (id == null || id.isEmpty()) {
-                id = "_unknown_id_" + unknownCounter;
-                unknownCounter++;
-            }
-
-            if (ids.contains(id))
-                throw new RuntimeException("The id " + id + " was already used. Either leave the json property '" + jsonProperty + "' empty or use an unique id.");
-
-            ids.add(id);
-            SpatialRule spatialRule = ruleFactory.createSpatialRule(id, borders);
-            if (spatialRule == SpatialRule.EMPTY)
-                continue;
-
-            rules.add(spatialRule);
-
-            for (Polygon polygon : borders) {
-                polygonBounds.update(polygon.getMinLat(), polygon.getMinLon());
-                polygonBounds.update(polygon.getMaxLat(), polygon.getMaxLon());
-            }
-        }
-
-        if (rules.isEmpty())
-            return null;
-
-        if (!polygonBounds.isValid()) {
-            throw new IllegalStateException("No associated polygons found in JsonFeatureCollection for rules " + rules);
-        }
-
-        // Only create a SpatialRuleLookup if there are rules defined in the given bounds
-        BBox calculatedBounds = polygonBounds.calculateIntersection(bounds);
-        if (calculatedBounds == null)
-            return null;
-
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(calculatedBounds, resolution, exact);
-        for (SpatialRule spatialRule : rules) {
-            spatialRuleLookup.addRule(spatialRule);
-        }
-        return spatialRuleLookup;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
index 709a16af24..3af5b87f03 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util.spatialrules.countries;
 
 import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
index 8a9b344b90..210ab08706 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util.spatialrules.countries;
 
 import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index 61fcdb49a4..b1c2ef20d2 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.coll.GHIntHashSet;
-import com.graphhopper.json.geo.Geometry;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.storage.index.LocationIndex;
@@ -34,6 +33,7 @@
 import com.graphhopper.util.shapes.Circle;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Shape;
+import com.vividsolutions.jts.geom.*;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -110,23 +110,21 @@ protected boolean checkAdjacent(EdgeIteratorState edge) {
      * This method fills the edgeIds hash with edgeIds found inside the specified geometry
      */
     public void fillEdgeIDs(GHIntHashSet edgeIds, Geometry geometry, EdgeFilter filter) {
-        if (geometry.isPoint()) {
-            GHPoint point = geometry.asPoint();
+        if (geometry instanceof Point) {
+            GHPoint point = GHPoint.from((Point) geometry);
             findClosestEdgeToPoint(edgeIds, point, filter);
-        } else if (geometry.isPointList()) {
-            PointList pl = geometry.asPointList();
-            if (geometry.getType().equals("LineString")) {
-                // TODO do map matching or routing
-                int lastIdx = pl.size() - 1;
-                if (pl.size() >= 2) {
-                    double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;
-                    double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;
-                    findClosestEdge(edgeIds, meanLat, meanLon, filter);
-                }
-            } else {
-                for (int i = 0; i < pl.size(); i++) {
-                    findClosestEdge(edgeIds, pl.getLatitude(i), pl.getLongitude(i), filter);
-                }
+        } else if (geometry instanceof LineString) {
+            PointList pl = PointList.from((LineString) geometry);
+            // TODO do map matching or routing
+            int lastIdx = pl.size() - 1;
+            if (pl.size() >= 2) {
+                double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;
+                double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;
+                findClosestEdge(edgeIds, meanLat, meanLon, filter);
+            }
+        } else if (geometry instanceof MultiPoint) {
+            for (Coordinate coordinate : geometry.getCoordinates()) {
+                findClosestEdge(edgeIds, coordinate.y, coordinate.x, filter);
             }
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/Parameters.java b/core/src/main/java/com/graphhopper/util/Parameters.java
index daa7825804..4372e4097e 100644
--- a/core/src/main/java/com/graphhopper/util/Parameters.java
+++ b/core/src/main/java/com/graphhopper/util/Parameters.java
@@ -185,4 +185,14 @@
          */
         public static final String MAX_NON_CH_POINT_DISTANCE = ROUTING_INIT_PREFIX + NON_CH_PREFIX + "max_waypoint_distance";
     }
+
+    public static final class PT {
+        public static final String EARLIEST_DEPARTURE_TIME = "pt.earliest_departure_time";
+        public static final String RANGE_QUERY_END_TIME = "pt.range_query_end_time";
+        public static final String ARRIVE_BY = "pt.arrive_by";
+        public static final String IGNORE_TRANSFERS = "pt.ignore_transfers";
+        public static final String WALK_SPEED = "pt.walk_speed";
+        public static final String MAX_WALK_DISTANCE_PER_LEG = "pt.max_walk_distance_per_leg";
+        public static final String MAX_TRANSFER_DISTANCE_PER_LEG = "pt.max_transfer_distance_per_leg";
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 049bfbb46c..112c7cfac4 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.LineString;
 
 import java.util.*;
 
@@ -522,4 +524,12 @@ public void remove() {
             }
         };
     }
+
+    public static PointList from(LineString lineString) {
+        final PointList pointList = new PointList();
+        for (Coordinate coordinate : lineString.getCoordinates()) {
+            pointList.add(new GHPoint(coordinate.y, coordinate.x));
+        }
+        return pointList;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index a4e4523cc7..ec79a7c0bc 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
 
@@ -45,6 +46,11 @@
     public double minEle;
     public double maxEle;
 
+    @JsonCreator
+    public BBox(double[] coords) {
+        this(coords[0],coords[2],coords[1],coords[3]);
+    }
+
     public BBox(double minLon, double maxLon, double minLat, double maxLat) {
         this(minLon, maxLon, minLat, maxLat, Double.NaN, Double.NaN, false);
     }
@@ -122,7 +128,7 @@ public BBox calculateIntersection(BBox bBox) {
             return null;
 
         double minLon = Math.max(this.minLon, bBox.minLon);
-        double maxLon = Math.min(this.maxLat, bBox.maxLat);
+        double maxLon = Math.min(this.maxLon, bBox.maxLon);
         double minLat = Math.max(this.minLat, bBox.minLat);
         double maxLat = Math.min(this.maxLat, bBox.maxLat);
 
@@ -308,4 +314,23 @@ public static BBox parseTwoPoints(String objectAsString) {
 
         return new BBox(minLon, maxLon, minLat, maxLat);
     }
+
+    /**
+     * This method creates a BBox out of a string in format lon1,lon2,lat1,lat2
+     */
+    public static BBox parseBBoxString(String objectAsString) {
+        String[] splittedObject = objectAsString.split(",");
+
+        if (splittedObject.length != 4)
+            throw new IllegalArgumentException("BBox should have 4 parts but was " + objectAsString);
+
+        double minLon = Double.parseDouble(splittedObject[0]);
+        double maxLon = Double.parseDouble(splittedObject[1]);
+
+        double minLat = Double.parseDouble(splittedObject[2]);
+        double maxLat = Double.parseDouble(splittedObject[3]);
+
+        return new BBox(minLon, maxLon, minLat, maxLat);
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index e51f9d4e73..9d2c2257ba 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.NumHelper;
+import com.vividsolutions.jts.geom.Point;
 
 /**
  * @author Peter Karich
@@ -99,4 +100,8 @@ public String toString() {
     public Double[] toGeoJson() {
         return new Double[]{lon, lat};
     }
+
+    public static GHPoint from(Point point) {
+        return new GHPoint(point.getY(), point.getX());
+    }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index d94d7ef4e2..bc365cc984 100644
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -9,7 +9,7 @@ turn_slight_right=στρίψτε λοξά δεξιά
 turn_sharp_left=στρίψτε κλειστά αριστερά
 turn_sharp_right=στρίψτε κλειστά δεξιά
 turn_onto=%1$s στην %2$s
-unknown=
+unknown=άγνωστη οδηγία '%1$s'
 web.search_button=Αναζήτηση
 web.from_hint=Αφετηρία
 web.via_hint=Μέσω
@@ -17,8 +17,8 @@ web.to_hint=Προορισμός
 web.more_button=περισσότερα
 web.gpx_export_button=Εξαγωγή GPX
 web.route_info=%1$s σε %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=φτάνει στις %1$s με %2$s μεταβιβάσεις (%3$s)
+web.pt_route_info_walking=φτάνει στις %1$s απλά περπατώντας (%2$s)
 web.locations_not_found=Η δρομολόγηση δεν είναι δυνατή. Οι τοποθεσίες δεν βρέθηκαν στην περιοχή.
 web.bike=Ποδήλατο
 web.racingbike=Αγωνιστικό ποδήλατο
@@ -53,10 +53,10 @@ roundabout_exit=Στον κυκλικό κόμβο βγείτε στην έξο
 roundabout_exit_onto=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s στην %2$s
 total_ascend=%1$s συνολική ανάβαση
 total_descend=%1$s συνολική κατάβαση
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=υπάρχει πέρασμα στο δρόμο
+pt_start_trip=μπείτε στο %1$s
+pt_end_trip=αφήστε το %1$s
+pt_transfer_to=αλλάξτε στο %1$s
 web.start_label=Αφετηρία
 web.intermediate_label=Ενδιάμεσο σημείο
 web.end_label=Προορισμός
@@ -68,7 +68,7 @@ web.show_coords=Εμφάνιση συντεταγμένων
 web.create_poi=
 web.route=Διαδρομή
 web.delete_from_route=Αφαίρεση από διαδρομή
-web.marker=Δείκτης
+web.marker=Σημάδι
 web.gh_offline_info=GraphHopper API offline?
 web.refresh_button=Ανανέωση σελίδας
 web.server_status=Κατάσταση
diff --git a/core/src/main/resources/com/graphhopper/util/sl_SI.txt b/core/src/main/resources/com/graphhopper/util/sl_SI.txt
index f2952f28ba..ebd5770679 100644
--- a/core/src/main/resources/com/graphhopper/util/sl_SI.txt
+++ b/core/src/main/resources/com/graphhopper/util/sl_SI.txt
@@ -9,7 +9,7 @@ turn_slight_right=zavijte rahlo desno
 turn_sharp_left=zavijte ostro levo
 turn_sharp_right=zavijte ostro desno
 turn_onto=%1$s na %2$s
-unknown=
+unknown=znak neznanega navodila '%1$s'
 web.search_button=Išči
 web.from_hint=Od 
 web.via_hint=Preko
@@ -17,15 +17,15 @@ web.to_hint=Do
 web.more_button=več
 web.gpx_export_button=Izvozi GPX
 web.route_info=%1$s bo trajalo %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=prispe ob %1$s s/z %2$s-imi prestopi (%3$s)
+web.pt_route_info_walking=prispe ob %1$s s samo hojo (%3$s)
 web.locations_not_found=Usmerjanje ni mogoče. Lokacije ni bilo mogoče najti na tem območju.
 web.bike=Kolo
 web.racingbike=Cestno kolo
 web.mtb=Gorsko kolo
 web.car=Avto
-web.foot=Peš
-web.hike=Pešačenje
+web.foot=Hoja
+web.hike=Pohodništvo
 web.small_truck=Majhen tovornjak
 web.bus=Avtobus
 web.truck=Tovornjak
@@ -53,10 +53,10 @@ roundabout_exit=V krožišču izberite izhod %1$s
 roundabout_exit_onto=V krožišču izberite izhod %1$s na %2$s
 total_ascend=Skupni vzpon: %1$s
 total_descend=Skupni spust: %1$s
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=Na poti je pregaz
+pt_start_trip=Vstopite v/na %1$s
+pt_end_trip=Zapustite %1$s
+pt_transfer_to=Prestopite na %1$s
 web.start_label=Začetna točka
 web.intermediate_label=Vmesna točka
 web.end_label=Končna točka
@@ -68,7 +68,7 @@ web.show_coords=Prikaži koordinate
 web.route=Pot
 web.delete_from_route=Izbriši iz poti
 web.marker=Oznaka
-web.gh_offline_info=
+web.gh_offline_info=Je API GraphHopper morda izklopljen?
 web.refresh_button=Osveži stran
 web.server_status=Stanje
 web.zoom_in=Povečaj
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
index 451b0182cf..f0cbca58db 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
@@ -19,9 +19,9 @@
 
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.countries.DefaultSpatialRule;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
@@ -206,23 +206,19 @@ public SpatialRule lookupRule(GHPoint point) {
                 return lookupRule(point.lat, point.lon);
             }
 
-            @Override
-            public void addRule(SpatialRule rule) {
-            }
-
             @Override
             public int getSpatialId(SpatialRule rule) {
                 throw new IllegalStateException();
             }
 
             @Override
-            public BBox getBounds() {
-                throw new IllegalStateException();
+            public int size() {
+                return 2;
             }
 
             @Override
-            public int size() {
-                return 2;
+            public BBox getBounds() {
+                return new BBox(-180,180,-90,90);
             }
         };
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index 66032dba84..2db0b2f654 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -2,13 +2,10 @@
 
 import java.util.*;
 
-import com.graphhopper.json.geo.GeoJsonPolygon;
-import com.graphhopper.json.geo.Geometry;
-import com.graphhopper.json.geo.JsonFeature;
-import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
+import com.graphhopper.util.PMap;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
@@ -327,20 +324,46 @@ public void stringToTonsException() {
 
     @Test
     public void testSpatialId() {
-        List<SpatialRule> rules = Collections.<SpatialRule>singletonList(new GermanySpatialRule());
-        final BBox bbox = new BBox(0, 1, 0, 1);
-        JsonFeatureCollection jsonFeatures = new JsonFeatureCollection() {
+        final GermanySpatialRule germany = new GermanySpatialRule();
+        germany.setBorders(Collections.singletonList(new Polygon(new double[]{0, 0, 1, 1}, new double[]{0, 1, 1, 0})));
+
+        SpatialRuleLookup index = new SpatialRuleLookup() {
+            @Override
+            public SpatialRule lookupRule(double lat, double lon) {
+                for (Polygon polygon : germany.getBorders()) {
+                    if (polygon.contains(lat, lon)) {
+                        return germany;
+                    }
+                }
+                return SpatialRule.EMPTY;
+            }
+
+            @Override
+            public SpatialRule lookupRule(GHPoint point) {
+                return lookupRule(point.lat, point.lon);
+            }
+
+            @Override
+            public int getSpatialId(SpatialRule rule) {
+                if (germany.equals(rule)) {
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
+
             @Override
-            public List<JsonFeature> getFeatures() {
-                Geometry geometry = new GeoJsonPolygon().addPolygon(new Polygon(new double[]{0, 0, 1, 1}, new double[]{0, 1, 1, 0}));
-                Map<String, Object> properties = new HashMap<>();
-                properties.put("ISO_A3", "DEU");
-                return Collections.singletonList(new JsonFeature("x", "Polygon", bbox, geometry, properties));
+            public int size() {
+                return 2;
+            }
+
+            @Override
+            public BBox getBounds() {
+                return new BBox(-180, 180, -90, 90);
             }
         };
 
-        SpatialRuleLookup index = new SpatialRuleLookupBuilder().build(rules, jsonFeatures, bbox, 1, false);
-        DataFlagEncoder encoder = new DataFlagEncoder(new PMap().put("spatial_rules", index.size()));
+        DataFlagEncoder encoder = new DataFlagEncoder(new PMap());
         encoder.setSpatialRuleLookup(index);
         EncodingManager em = new EncodingManager(encoder);
 
@@ -385,4 +408,5 @@ public void testSpatialId() {
         assertEquals(5, encoder.getMaxspeed(e3, -1, false), .1);
         assertEquals(-1, encoder.getMaxspeed(e4, -1, false), .1);
     }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
index 97fee8c55e..86fcb38564 100644
--- a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
@@ -1,10 +1,12 @@
 package com.graphhopper.routing.util.spatialrules;
 
-import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
-import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
 import com.graphhopper.util.shapes.BBox;
+import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -15,14 +17,26 @@
 
     @Test
     public void testSpatialLookup() {
-        SpatialRuleLookupArray lookup = new SpatialRuleLookupArray(new BBox(1, 2, 1, 2), 1, false);
-        SpatialRule germanyRule = new GermanySpatialRule().addBorder(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}));
-        lookup.addRule(germanyRule);
-        SpatialRule austriaRule = new AustriaSpatialRule().addBorder(new Polygon(new double[]{5, 5, 6, 6}, new double[]{5, 6, 6, 5}));
-        lookup.addRule(austriaRule);
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        SpatialRule germany = new DefaultSpatialRule() {
+            @Override
+            public String getId() {
+                return "DEU";
+            }
+        }.addBorder(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}));
+        spatialRules.add(germany);
+        SpatialRule austria = new DefaultSpatialRule() {
+            @Override
+            public String getId() {
+                return "AUT";
+            }
+        }.addBorder(new Polygon(new double[]{5, 5, 6, 6}, new double[]{5, 6, 6, 5}));
+        spatialRules.add(austria);
+
+        SpatialRuleLookupArray lookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 2, 1, 2));
 
         SpatialRule rule = lookup.lookupRule(1.5, 1.5);
-        assertEquals(germanyRule, rule);
+        assertEquals(germany, rule);
         assertEquals("DEU", rule.getId());
         int id = lookup.getSpatialId(rule);
         assertTrue(id > 0);
@@ -31,23 +45,25 @@ public void testSpatialLookup() {
 
     @Test
     public void testSmallScenario() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, false);
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 4, 1, 4));
+
+        Assert.assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        // Not in the second Polygon anymore, but due to the resolution of 1, this should be still match the rule
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(3.9, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(2.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
     }
 
     @Test
     public void testExact() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, true);
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 4, 1, 4));
+
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         // Not in the second Polygon anymore
@@ -57,12 +73,20 @@ public void testExact() {
 
     @Test
     public void testExactCountry() {
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(new BBox(-180, 180, -90, 90), .1, true);
+        List<SpatialRule> spatialRules = new ArrayList<>();
 
         // Taken from here: https://github.com/johan/world.geo.json/blob/master/countries/DEU.geo.json
         String germanPolygonJson = "[9.921906,54.983104],[9.93958,54.596642],[10.950112,54.363607],[10.939467,54.008693],[11.956252,54.196486],[12.51844,54.470371],[13.647467,54.075511],[14.119686,53.757029],[14.353315,53.248171],[14.074521,52.981263],[14.4376,52.62485],[14.685026,52.089947],[14.607098,51.745188],[15.016996,51.106674],[14.570718,51.002339],[14.307013,51.117268],[14.056228,50.926918],[13.338132,50.733234],[12.966837,50.484076],[12.240111,50.266338],[12.415191,49.969121],[12.521024,49.547415],[13.031329,49.307068],[13.595946,48.877172],[13.243357,48.416115],[12.884103,48.289146],[13.025851,47.637584],[12.932627,47.467646],[12.62076,47.672388],[12.141357,47.703083],[11.426414,47.523766],[10.544504,47.566399],[10.402084,47.302488],[9.896068,47.580197],[9.594226,47.525058],[8.522612,47.830828],[8.317301,47.61358],[7.466759,47.620582],[7.593676,48.333019],[8.099279,49.017784],[6.65823,49.201958],[6.18632,49.463803],[6.242751,49.902226],[6.043073,50.128052],[6.156658,50.803721],[5.988658,51.851616],[6.589397,51.852029],[6.84287,52.22844],[7.092053,53.144043],[6.90514,53.482162],[7.100425,53.693932],[7.936239,53.748296],[8.121706,53.527792],[8.800734,54.020786],[8.572118,54.395646],[8.526229,54.962744],[9.282049,54.830865],[9.921906,54.983104]";
         Polygon germanPolygon = parsePolygonString(germanPolygonJson);
-        spatialRuleLookup.addRule(new GermanySpatialRule().addBorder(germanPolygon));
+
+        spatialRules.add(new DefaultSpatialRule(){
+            @Override
+            public String getId() {
+                return "DEU";
+            }
+        }.addBorder(germanPolygon));
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, .1, true, new BBox(-180, 180, -90, 90));
+
 
         // Far from the border of Germany, in Germany
         assertEquals("DEU", spatialRuleLookup.lookupRule(48.777106, 9.180769).getId());
@@ -70,9 +94,9 @@ public void testExactCountry() {
         assertEquals("DEU", spatialRuleLookup.lookupRule(50.636710, 12.514561).getId());
 
         // Far from the border of Germany, not in Germany
-        assertEquals("", spatialRuleLookup.lookupRule(48.029533, 7.250122).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(51.694467, 15.209218).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(47.283669, 11.167381).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(48.029533, 7.250122).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(51.694467, 15.209218).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(47.283669, 11.167381).getId());
 
         // Close to the border of Germany, in Germany - Whereas the borders are defined by the GeoJson above and do not strictly follow the acutal border
         assertEquals("DEU", spatialRuleLookup.lookupRule(50.017714, 12.356129).getId());
@@ -82,23 +106,32 @@ public void testExactCountry() {
         assertEquals("DEU", spatialRuleLookup.lookupRule(47.557166, 9.738343).getId());
 
         // Close to the border of Germany, not in Germany
-        assertEquals("", spatialRuleLookup.lookupRule(50.025342, 12.386262).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(49.932900, 6.174023).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(47.547463, 9.741948).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(50.025342, 12.386262).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(49.932900, 6.174023).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(47.547463, 9.741948).getId());
     }
 
     @Test
     public void testExactAdjacentBorder() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, true);
+        List<SpatialRule> spatialRules = new ArrayList<>();
         // Two rules that divide the tile in half
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 1.5, 1.5}, new double[]{1, 2, 2, 1}), "top"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "bottom"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 1.5, 1.5}, new double[]{1, 2, 2, 1}), "top"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "bottom"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 4, 1, 4));
 
         assertEquals("top", spatialRuleLookup.lookupRule(1.4, 1.5).getId());
         assertEquals("bottom", spatialRuleLookup.lookupRule(1.6, 1.5).getId());
     }
 
+    @Test
+    public void testSmallBoundsBigPolygon() {
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{-100, -100, 100, 100}, new double[]{-100, 100, 100, -100}), "big"));
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 2, 1, 2));
+        assertEquals("big", spatialRuleLookup.lookupRule(1.5, 1.5).getId());
+    }
+
     private Polygon parsePolygonString(String polygonString) {
         String[] germanPolygonArr = polygonString.split("\\],\\[");
         double[] lats = new double[germanPolygonArr.length];
@@ -116,7 +149,7 @@ private Polygon parsePolygonString(String polygonString) {
     }
 
     private SpatialRule getSpatialRule(Polygon p, final String name) {
-        SpatialRule rule = new AbstractSpatialRule() {
+        AbstractSpatialRule rule = new AbstractSpatialRule() {
             @Override
             public double getMaxSpeed(String highwayTag, double _default) {
                 return _default;
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 585006dbaf..827aed2e71 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.util;
 
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
@@ -28,7 +30,6 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.NodeAccess;
-import org.json.JSONObject;
 import org.junit.Before;
 import org.junit.Test;
 import org.xml.sax.SAXException;
@@ -352,7 +353,15 @@ public void testRoundaboutJsonIntegrity() {
         assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
         assertEquals("2", json.get("exit_number").toString());
         // assert that a valid JSON object can be written
-        assertNotNull(new JSONObject(json).toString());
+        assertNotNull(write(json));
+    }
+
+    private String write(Map<String, Object> json) {
+        try {
+            return new ObjectMapper().writeValueAsString(json);
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     // Roundabout with unknown dir of rotation
@@ -375,7 +384,7 @@ public void testRoundaboutJsonNaN() {
         assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
         assertNull(json.get("turn_angle"));
         // assert that a valid JSON object can be written
-        assertNotNull(new JSONObject(json).toString());
+        assertNotNull(write(json));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index a316f68243..22462771ed 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -97,6 +97,12 @@ public void testCalculateIntersection() {
         //No intersection
         b2 = new BBox(100, 200, 100, 200);
         assertNull(b1.calculateIntersection(b2));
+
+        //Real Example
+        b1 = new BBox(8.8591,9.9111,48.3145,48.8518);
+        b2 = new BBox(5.8524,17.1483,46.3786,55.0653);
+
+        assertEquals(b1, b1.calculateIntersection(b2));
     }
 
     @Test
@@ -146,4 +152,9 @@ public void testParseTwoPoints() {
         // stable parsing, i.e. if first point is in north or south it does not matter:
         assertEquals(new BBox(2, 4, 1, 3), BBox.parseTwoPoints("3,2,1,4"));
     }
+
+    @Test
+    public void testParseBBoxString() {
+        assertEquals(new BBox(2, 4, 1, 3), BBox.parseBBoxString("2,4,1,3"));
+    }
 }
diff --git a/docs/android/index.md b/docs/android/index.md
index 5d299f7644..6eba567455 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -1,8 +1,8 @@
 # Get Demo
 
-[Download GraphHopper Demo APK](http://graphhopper.com/#community)
+[Download GraphHopper Demo APK](../index.md#for-users)
 
-![simple routing](https://graphhopper.com/blog/wp-content/uploads/2016/10/android-demo-screenshot-2.png)
+![simple routing](https://www.graphhopper.com/wp-content/uploads/2016/10/android-demo-screenshot-2.png)
 
 # Set-up Development
 
diff --git a/docs/core/deploy.md b/docs/core/deploy.md
index 09e34c0d5f..cfd105a0f3 100644
--- a/docs/core/deploy.md
+++ b/docs/core/deploy.md
@@ -8,21 +8,17 @@ For simplicity you could just start jetty from maven and schedule it as backgrou
 `export GH_FOREGROUND=false && export JETTY_PORT=11111 && ./graphhopper.sh web europe_germany_berlin.pbf`. 
 Then the service will be accessible on port 11111.
 
-For production usage you can install the latest jetty (at least 9) as a service but we prefer to have it bundled as a 
-simple jar. Tomcat should work too. To create a war file do `mvn clean install war:war` and copy it from the target/ 
-folder to your jetty installation. Then copy web/config.properties also there and change this properties 
-file to point to the required graphhopper folder. Increase the Xmx/Xms values of your jetty server e.g. 
-for world wide coverage with a hierarchical graph do the following in bin/jetty.sh
+For production usage you have a jetty already bundled as a simple jar. Then copy web/config.properties also there and change this properties 
+file to point to the required graphhopper folder. Increase the -Xmx/-Xms values of your server server e.g. 
+for world wide coverage with a hierarchical graph do the following before calling graphhopper.sh:
+
 ```
-bash
-export JAVA=java-home/bin/java
-export JAVA_OPTIONS="-server -Xconcurrentio -Xmx17000m -Xms17000m"
+export JAVA_OPTS="-server -Xconcurrentio -Xmx17000m -Xms17000m"
 ```
 
 Notes:
 
- * jsonp support needs to be enabled in the config.properties
- * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/734)
+ * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/734) or use landmarks.
 
 ### API Tokens
 
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
index b38754cea3..9e0a8c5b7f 100644
--- a/docs/core/eclipse-setup.md
+++ b/docs/core/eclipse-setup.md
@@ -3,8 +3,7 @@ Getting started with GraphHopper in Eclipse
 This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
 Instructions for Android branch will be provided in future.
 
-The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. 
-Setting up Apache Tomcat server and configuring it to run GraphHopper is covered in [Setting up Apache Tomcat Server](./eclipse-tomcat-setup.md).
+This document covers configuring Eclipse for cloning and importing GraphHopper repository. 
 
 ###1. Download Eclipse
 
diff --git a/docs/core/eclipse-tomcat-setup.md b/docs/core/eclipse-tomcat-setup.md
deleted file mode 100644
index a74e883e82..0000000000
--- a/docs/core/eclipse-tomcat-setup.md
+++ /dev/null
@@ -1,148 +0,0 @@
-Setting up Apache Tomcat Server
-=========
-After ["Configuring Eclipse to get started with GraphHopper"](https://github.com/graphhopper/graphhopper/blob/master/docs/core/eclipse-setup.md), in this document we cover how to set up Apache Tomcat server and configure it to run GraphHopper.
-
-###1. Install Apache Tomcat Server
-
-To install Tomcat server, open Eclipse and choose a workspace you have already configured to work with GraphHopper. Details for configuring eclipse can be found in this ["document"](https://github.com/graphhopper/graphhopper/blob/master/docs/core/eclipse-setup.md).
-
- At first you have to make sure that “Dynamic Web Module” has been checked in the project: 
-
-* On Project explorer, right click on _graphhopper-web [graphhopper master]_ and go to "Properties". 
-
-* Choose "Project Facets" and make sure that "Dynamic Web Module" has been selected. If not, select it and then apply the changes.  
-
-![](./images/2.jpg)
-
-Now you are ready to add or create a new server:
-
-* If you do not see any tab called “Servers” , then go to _window -> Show view_ and then choose "Servers". Please note you may need to choose "Other..." and then "Servers".
-
-* If this is the first time you are creating a server, in the “Servers” area you will see a link as “No servers are available click this link to create a new server”. Click the link.
-
-![](./images/1.jpg)
-
-* “Define a New Server” window will be opened, In “Select the server type”. Open “Apache” and choose an appropriate Tomcat version. For this document we chose “Tomcat v8.0 Server”.
-
-* Leave “Server’s host name” as  _localhost_. You can give any name that you want to “Server name”. Then click “Next”. 
-
-![](./images/3.jpg)
-
-* In “Tomcat Server” page, you need to specify the installation directory for Tomcat. At first in “JRE” part, choose the jre you have installed in your system (e.g.  jre 1.8.0_31).
-
-* If this is the first time you are installing this version of Tomcat you have to click on “Download and Install” to automatically get and install Tomcat, otherwise choose the installation directory for Tomcat as shown in figure. 
-
-![](./images/5.jpg)
-
-* If this is the first time you are installing a specific version of Tomcat, then the feature license page appears for you. Review the license to decide whether to accept the terms of the agreement. After accepting the terms, choose the installation directory and click "Next".
-
-* In “Add and Remove” page add _graphhopper-web_ from “available:” column to “configured:”. Then click on “Finish”.  Please note that you should wait until the installation completes so that the current Window automatically be closed.
-
-![](./images/4.jpg)
-
-
-###2.	Basic Configurations
-After downloading and installing Tomcat, you need to change some of the default settings: 
-
-* In the "Overview" tab double click the name of the created server. Now in your dashboard you should be able to see the whole overview of the server.
-
-![](./images/18.jpg)
-
-* In “Timeouts” part, change _start_ and _stop times_ appropriately. Please note that when running GraphHopper for the first time, a new graph should be created and it may take some time. Therefore these times (specially the start time) should be increased to give enough time for creating the graph. Here we chose 200 for both times.
-
-![](./images/6.jpg)
-
-* In The “Ports” part you can choose any port you want for the server to work with. You can also leave the default settings as the below figure.
-
-![](./images/7.jpg)
-
-* On "Project explorer", right click on _graphhopper-web [graphhopper master]_ and go to “Build Path” -->”Configure build path” --> “Deployment Assembly”. 
-* Make sure in the “Web Deployment Assembly” "src/main/webapp" is added as below figure.
-
-![](./images/9.jpg)
-
-* If not added,select "Add" button.
- * In "Select Directive Type", choose _Folder_ and click "Next".
- * In "Folder" page, click _src_ , then choose _main_  and then select _webapp_. Click "Finish"
- 
-![](./images/15.jpg)
-###3.	VM Arguments Configuration
-At this step you need to include specific VM arguments corresponds to _map_ and _configuration_ files so that the GraphHopper works without any problem.  
-
-* First of all make sure that you have a configuration folder with _map_ and _configuration_ files. Therefore, create a folder (at any location in your system that you want) and copy the the appropriate _map_ and _configuration_ files to this folder as described below:
-
- * **Configuration file (config.properties)**: Is a file that contains GraphHopper's configurations. From the GraphHopper git repository, copy the file named “config-example.properties” into the configuration folder you created. Rename the file to “config.properties” ( or any name you want).
-
- * **Map file (map.osm)**:  Any .osm file can have the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. You can keep the default name. Get an .osm file and put it in the configuration folder and name it map.osm. Please note you can get an .osm file from ["OpenStreetMap site"](http://www.openstreetmap.org/#map=14/44.5763/-123.2788).
- 
- * **Graph folder**: This folder is created automatically based on defining the correct VM argument and upon running GraphHopper. Graph folder is used to keep the created graph by GraphHopper.
- 
-* Now to add VM arguments, go to “Overview” part and in “General information”, click on “Open launch configuration”.
-
-* In “(x)= Arguments”  tab,  and in “VM arguments” part, add the necessary arguments and their corresponding paths that are not included. You only need to add the below arguments and paths:
- * **1.-Dgraphhopper.config="_Path to config.properties file_"**: config.properties is a file that contains GraphHopper's configurations.
- * **2.-Dgraphhopper.graph.location="_Path to graph folder_"**: In _graph_ folder ( with any optional name) a graph would be created. Upon running GraphHopper a folder ( with the name defined in VM arguments) will be created to keep the graph. So do not worry about manually creating it in the configuration folder.
- * **3.-Dgraphhopper.datareader.file="_Path to map.osm or map.pbf file_"**:  *.osm file contains the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. 
-
-![](./images/8.jpg)
-
-
-
-* _-Xmx1G_  is optional and is used to restrict the maximum heap size for Java virtual machine. It should be configured based on the amount of RAM dedicated to run the server. Here we chose 1G. If you have enough RAM on your system, you can increase the number. For example change _-Xmx1G_ to _–Xmx4G_. Please consider that if you choose a wrong amount of RAM, you may face errors. You may also want to not add this optional argument. In this case a predefined heap size will be allocated for Java virtual machine.
-
-###4.  Configuring Web Modules
-To complete setting up the Tomcat server go through the below steps: 
-
-* Click the “Modules” tab to go to “Web Modules” .
-
-* Select “graphhopper-web” row. Then click “Edit”.
-
-* Edit the “path” from "_/graphhopper-web_" to "_/_". 
-
-![](./images/13.jpg)
-
-###5. Run Server
- After going through all the previous steps, you are ready to run GraphHopper using Apache Tomcat server in Eclipse. Right click on the name of you server and choose "Start". Or simply click on the green "start" icon.
- If you faced no error and the server started successfully, in your browser type the server address and port. In our example it is : http://localhost:8080/. 
- Congratulations! You have GraphHopper (with basic settings) running and ready for work!
- However it is possible that you face an error as **"NoClassDefFoundError"**. If so, please see the section "6. Configuring Classpath and Resolving Maven Dependencies Problem"
-  
- ![](./images/17.jpg)
- 
-
-###6. Configuring Classpath and Resolving Maven Dependencies Problem
-Depending on your Eclipse version or the _m2e_ that you use, _Maven_ may not set _Classpath_ for dependencies properly. Therefore, while running your Tomcat server you may face an error as **"NoClassDefFoundError"**. 
-If you faced such an error, at first please check the below websites for the additional plug-ins, instructions on changing pom.xml and solving the similar problem:
-
-* ["Maven not setting classpath for dependencies properly"](http://stackoverflow.com/questions/4687609/maven-not-setting-classpath-for-dependencies-properly)
-
-* ["How to configure Eclipse build path to use Maven dependencies?"](http://stackoverflow.com/questions/2037188/how-to-configure-eclipse-build-path-to-use-maven-dependencies)
-
-However your problem may still not be solved. We could not find any accurate solution for this problem but here is a workaround: 
-
-* In “Configure build path”--> “Java Build Path”, click on “Libraries” tab and choose “Maven Dependencies”. Take a look at all “.jar files". Be ready to find all these .jar files in your system, and to make a copy of them in a folder.
-
-![](./images/10.jpg)
-
-* You have to add all these files to “Classpath” as well. 
- On Project explorer, right click on _graphhopper-web [graphhopper master]_ and go to “Run As” --> “Run configuration…” then choose “Classpass” tab. Under “User Entries” , you see only a few “.jar files”. It should look like the below figure.
- 
- ![](./images/11.jpg)
- 
-* You have to find the location of each .jar file, you saw previously in "Build Path" and add them as an “External JARs” to the Classpath. Since there are lots of files, we suggest that you at first manually copy (not cut!) all the “.jar” files into a folder so that you can use them in future as well.  
-
-* Again go to “User Entries” on “Classpath” and click on “ External JARs…”.  In the “Jar Selection” Window go to the folder you already created with all the .Jar files and select all those files. Now your Classpath should look like below. 
-
-![](./images/12.jpg)
-
-* Finally you also have to add "graphhoper" Project to "Classpath". Click “User Entries” on “Classpath” and select "Add Projects...". Check "graphopper" and click "OK".
- 
- ![](./images/16.jpg)
- 
-The Problem should be resolved with this workaround.
- 
- 
- 
-
-
-
diff --git a/docs/core/spatial-rules.md b/docs/core/spatial-rules.md
new file mode 100644
index 0000000000..adf9d79712
--- /dev/null
+++ b/docs/core/spatial-rules.md
@@ -0,0 +1,22 @@
+# Spatial Rules
+
+Spatial rules allow you to create rules for certain areas. One example is that the default accessibility for 
+`highway=track` in Austria is `access=yes`, whereas the default accessibility is `access=destination` in Germany. Other 
+examples are different max speeds for different countries. More information on different road rules can be found in the 
+OSM wiki, different [accessibilities](https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Access-Restrictions) and 
+different [speeds](https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed#Motorcar).
+
+## Enabling Rules
+
+I you have a working GraphHopper setup it is easy to enable Spatial Rules, **but they only work with the DataFlagEncoder**.
+We provide a set of approximate country borders, within the GraphHopper repository. If you need exact borders you can
+get the exact borders from [here](https://github.com/datasets/geo-countries). Go to your `config.properties` and
+uncommend the line: `spatial_rules.location` and point it to where your rules are. You need to re-import your graph after 
+that.
+
+## Creating Rules
+
+Writing your own rules is simple. If you write a rule for a country that is not provided in GraphHopper yet, we'd love
+if you would contribute your rules. You can have a look at the [GermanySpatialRule](https://github.com/graphhopper/graphhopper/blob/master/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java).
+Create something similar for your country. After that you have to extend the [CountriesSpatialRuleFactory](https://github.com/graphhopper/graphhopper/blob/master/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java) 
+to match your country code. 
\ No newline at end of file
diff --git a/docs/index.md b/docs/index.md
index ddbf996516..c52b85c2f5 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -7,75 +7,82 @@ Try out our live demo called [GraphHopper Maps](https://graphhopper.com/maps)
  [![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
 [The Readme](../README.md#features) lists all features or [this list of slides](https://graphhopper.com/public/slides/).
-
-See [more users of GraphHopper](https://www.graphhopper.com/showcases/) or [Android apps](./android/index.md#apps) and let us know your application!
-
-Try the web demo 'GraphHopper Maps' with [this user guide](./web/quickstart.md) on your machine
-or the [Android demo](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk).
-
-Other links:
-
- * [Add GraphHopper Maps to your Browser](./web/open-search.md): Instructions how to setup GraphHopper as the standard search enginge in your browser.
- * [Embed GraphHopper on your website](https://github.com/karussell/graphhopper-embed-form): A small code snippet on how to integrate GraphHopper Maps in your web site like a contact form
+See [users of GraphHopper](https://www.graphhopper.com/showcases/) or [Android apps](./android/index.md#apps) and let us know your application!
 
 ## Contact
 
 For all questions regarding the GraphHopper routing engine please use [our forum](https://discuss.graphhopper.com). 
-
 For bugs see our contribute section below.
 
-## Web
+---
+
+## For Users
+
+Try the web demo 'GraphHopper Maps' with [this user guide](./web/quickstart.md) on your machine
+or the [Android demo](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk).
+
+#### Web
 
 The web module provides a web API for other programming languages as well as starts a simple user interface called GraphHopper Maps
 
  * [Routing API](./web/api-doc.md): Documentation of the Web API to communicate with any GraphHopper server via http.
- * [Deployment Guide](./core/deploy.md): Details about deploying GraphHopper
- * [Postgis query script](../core/files/postgis)
+ * [Deployment Guide](./core/deploy.md): Details about deploying GraphHopper 
  * There are official API clients in [Java](https://github.com/graphhopper/directions-api-java-client/) and [JavaScript](https://github.com/graphhopper/directions-api-js-client).
 
-### Configuration
+#### Configuration
 
 You can configure several aspects either programmatically or just via the [config.properties](../config-example.properties).
 
 The elevation configuration is separately documented [here](./core/elevation.md).
 
-## Developer
+---
+
+## For Developers
 
 [The quickstart](./core/quickstart-from-source.md) is an introduction for developers. Explains git checkout, IDE setup and commands for setting up a GraphHopper server.
 
 Find all changes in previous and current versions in the [changelogs](../core/files/changelogs.txt).
 
-### Contribute
+#### Contribute
 
 Read [here](../.github/CONTRIBUTING.md) on how to contribute as a developer and translator.
 
-### Technical
+#### Technical
 
 Various topics are explained in more detail separately:
 
  * [Technical overview](./core/technical.md): Technical details about how GraphHopper its calculations are working.
  * [Simple routing](./core/routing.md): Tutorial how to integrate GraphHopper in your Java application (or pick any JVM language)
  * [Create custom weighting](./core/weighting.md): Documentation about how to create a custom weighting class to influence the track calculation.
+ * [Import GTFS](../reader-gtfs): Simple steps to get GTFS import and routing done.
  * [LocationIndex](./core/location-index.md): Documentation about how to get the location index for getting i.e. the nearest edge. 
  * [Hybrid Mode](./core/landmarks.md): Details about speeding up the route calculation via A* and landmarks.
  * [Speed Mode](./core/ch.md): Details about speeding up the route calculations via [Contraction Hierarchies](http://en.wikipedia.org/wiki/Contraction_hierarchies).
  * [Low level API](./core/low-level-api.md): Instructions how to use GraphHopper as a Java library.
  * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
+ * [Spatial Rules](./core/spatial-rules.md): Instruction on how to use and create new SpatialRules. SpatialRules are used to enforce country-specific routing rules.
+ * [Postgis query script](../core/files/postgis)
+
+#### Other links
+
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md): Instructions how to setup GraphHopper as the standard search enginge in your browser.
+ * [Embed GraphHopper on your website](https://github.com/karussell/graphhopper-embed-form): A small code snippet on how to integrate GraphHopper Maps in your web site like a contact form
 
-### Android
+#### Android
 
  * [Android](./android/index.md): Instructions how to setup the demo project for GraphHopper on Android
  * [Android Studio Setup](./android/android-studio-setup.md)
 
-### iOS
+#### iOS
 
 Instructions on how to setup the GraphHopper-iOS clone for iOS development are [here](https://github.com/graphhopper/graphhopper-ios/)
 including a sample application.
 
-### Windows
+#### Windows
 
 Documentation about how to get an GraphHopper instance running on windows via cygwin is available [here](./core/windows-setup.md).
 
-### Eclipse
+#### Eclipse
 
-[Set up GraphHopper in Eclipse](./core/eclipse-setup.md) with maven and [tomcat](./core/eclipse-tomcat-setup.md).
+Setup in IntelliJ and NetBeans is just via open project. See [this document](./core/eclipse-setup.md) 
+to set up GraphHopper in Eclipse with maven.
diff --git a/graphhopper.sh b/graphhopper.sh
index ac517e6619..d751ee5193 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -111,17 +111,10 @@ function execMvn {
 }
 
 function packageCoreJar {
-  if [ ! -d "./target" ]; then
-    echo "## building parent"
-    execMvn --non-recursive install
-  fi
-  
   if [ ! -f "$JAR" ]; then
     echo "## building graphhopper jar: $JAR"
     echo "## using maven at $MAVEN_HOME"
-    
-    execMvn --projects tools,reader-gtfs -am -DskipTests=true install
-    execMvn --projects tools -DskipTests=true install assembly:single
+    execMvn --projects tools -am -DskipTests=true package
   else
     echo "## existing jar found $JAR"
   fi
@@ -145,9 +138,7 @@ elif [ "$ACTION" = "build" ]; then
  exit  
  
 elif [ "$ACTION" = "buildweb" ]; then
- packageCoreJar
- execMvn --projects web -am -DskipTests=true install
- execMvn --projects web -DskipTests=true install assembly:single
+ execMvn --projects web -am -DskipTests=true package
  exit
 
 elif [ "$ACTION" = "extract" ]; then
@@ -158,8 +149,7 @@ elif [ "$ACTION" = "extract" ]; then
  exit
  
 elif [ "$ACTION" = "android" ]; then
- packageCoreJar
- execMvn -P include-android --projects android/app install android:deploy android:run
+ execMvn -P include-android --projects android/app -am package android:deploy android:run
  exit
 fi
 
@@ -225,8 +215,7 @@ if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
   if [ ! -s "$WEB_JAR" ]; then
-    execMvn --projects web -am -DskipTests=true install
-    execMvn --projects web -DskipTests=true install assembly:single
+    execMvn --projects web -am -DskipTests=true package
   fi
 
   RC_BASE=./web/src/main/webapp
@@ -256,7 +245,7 @@ elif [ "$ACTION" = "torture" ]; then
 
 
 elif [ "$ACTION" = "miniui" ]; then
- execMvn --projects tools -DskipTests clean install assembly:single
+ execMvn --projects tools -am -DskipTests clean package
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI datareader.file="$OSM_FILE" config=$CONFIG \
               graph.location="$GRAPH"
@@ -272,8 +261,7 @@ elif [ "$ACTION" = "measurement" ]; then
  # IMPORT_TIME=$(($END - $START))
 
  function startMeasurement {
-    execMvn --projects core -DskipTests clean install
-    execMvn --projects tools -DskipTests install assembly:single
+    execMvn --projects tools -am -DskipTests clean package
     COUNT=5000
     commit_info=$(git log -n 1 --pretty=oneline)
     echo -e "\nperform measurement via jar=> $JAR and ARGS=> $ARGS"
diff --git a/pom.xml b/pom.xml
index 8826b849e6..317aabc30c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -17,7 +17,6 @@
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
         <slf4j.version>1.7.21</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
-        <json.org.version>20160810</json.org.version>
         <commons-compress.version>1.12</commons-compress.version>
         <jackson.version>2.8.4</jackson.version>
 
diff --git a/reader-gtfs/README.md b/reader-gtfs/README.md
index d1b9241f9a..286e85a338 100644
--- a/reader-gtfs/README.md
+++ b/reader-gtfs/README.md
@@ -13,8 +13,7 @@ cd graphhopper
 # download GTFS from Berlin & Brandenburg in Germany (VBB) and the 'surrounding' OpenStreetMap data for the walk network
 wget -O gtfs-vbb.zip http://transitfeeds.com/p/verkehrsverbund-berlin-brandenburg/213/latest/download
 wget http://download.geofabrik.de/europe/germany/brandenburg-latest.osm.pbf
-mvn install -DskipTests
-mvn --projects web install -DskipTests assembly:single
+./graphhopper.sh buildweb
 # The following process will take roughly 5 minutes on a modern laptop when it is executed for the first time.
 # It imports the previously downloaded OSM data of the Brandenburg area as well as the GTFS.
 java -Xmx5g -Xms5g -jar web/target/graphhopper-web-*-with-dep.jar datareader.file=brandenburg-latest.osm.pbf gtfs.file=gtfs-vbb.zip jetty.port=8989 jetty.resourcebase=./web/src/main/webapp graph.flag_encoders=pt prepare.ch.weightings=no graph.location=./graph-cache
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index 90fa652e58..1d8b80a3a0 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -15,13 +15,6 @@
         <version>0.9-SNAPSHOT</version>
     </parent>
 
-    <repositories>
-        <repository>
-            <id>jitpack.io</id>
-            <url>https://jitpack.io</url>
-        </repository>
-    </repositories>
-
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
@@ -34,9 +27,9 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.github.graphhopper</groupId>
+            <groupId>com.conveyal</groupId>
             <artifactId>gtfs-lib</artifactId>
-            <version>f955eec</version>
+            <version>2.1.0</version>
             <exclusions>
                 <exclusion> 
                     <groupId>org.slf4j</groupId>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/fare/FixedFareAttributeLoader.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/fare/FixedFareAttributeLoader.java
new file mode 100644
index 0000000000..0d823aa2b3
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/fare/FixedFareAttributeLoader.java
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.fare;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.Fare;
+import com.conveyal.gtfs.model.FareAttribute;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Workaround for an issue in gtfs-lib where a field (see below), if missing, is assumed set to be 0 while
+ * the (as I understand the spec) more appropriate interpretation would be "practically infinite".
+ *
+ */
+public class FixedFareAttributeLoader extends FareAttribute.Loader {
+    private final Map<String, Fare> fares;
+
+    public FixedFareAttributeLoader(GTFSFeed feed, Map<String, Fare> fares) {
+        super(feed, fares);
+        this.fares = fares;
+    }
+
+    @Override
+    public void loadOneRow() throws IOException {
+        super.loadOneRow();
+        String fareId = getStringField("fare_id", true);
+        final Fare fare = fares.get(fareId);
+        fare.fare_attribute.transfers = getIntField("transfers", false, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 1a57bd0cc5..233c76d791 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -24,6 +24,9 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.temporal.ChronoUnit;
 import java.util.Iterator;
 
 final class GraphExplorer {
@@ -33,10 +36,12 @@
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
+    private final PtTravelTimeWeighting weighting;
 
-    GraphExplorer(Graph graph, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse) {
+    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse) {
         this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
         this.flagEncoder = flagEncoder;
+        this.weighting = weighting;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
@@ -55,15 +60,14 @@
                     public boolean hasNext() {
                         while(edgeIterator.next()) {
                             final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-                            final int trafficDay = (int) (label.currentTime / (24 * 60 * 60));
-                            if (!isValidOn(edgeIterator, trafficDay)) {
+                            if (!isValidOn(edgeIterator, label.currentTime)) {
                                 continue;
                             }
                             if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
                                 continue;
                             }
                             if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                                if ((int) (label.currentTime) % (24 * 60 * 60) > flagEncoder.getTime(edgeIterator.getFlags())) {
+                                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
                                     continue;
                                 } else {
                                     if (foundEnteredTimeExpandedNetworkEdge) {
@@ -73,7 +77,7 @@ public boolean hasNext() {
                                     }
                                 }
                             } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                                if ((int) (label.currentTime) % (24 * 60 * 60) < flagEncoder.getTime(edgeIterator.getFlags())) {
+                                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
                                     continue;
                                 }
                             }
@@ -91,8 +95,47 @@ public EdgeIteratorState next() {
         };
     }
 
-    private boolean isValidOn(EdgeIteratorState edge, int trafficDay) {
-        return gtfsStorage.getValidities().get(flagEncoder.getValidityId(edge.getFlags())).get(trafficDay);
+    long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
+        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+        switch (edgeType) {
+            case HIGHWAY:
+                return weighting.calcMillis(edge, false, -1);
+            case ENTER_TIME_EXPANDED_NETWORK:
+                if (reverse) {
+                    return 0;
+                } else {
+                    return waitingTime(edge, earliestStartTime);
+                }
+            case LEAVE_TIME_EXPANDED_NETWORK:
+                if (reverse) {
+                    return -waitingTime(edge, earliestStartTime);
+                } else {
+                    return 0;
+                }
+            default:
+                return flagEncoder.getTime(edge.getFlags()) * 1000;
+        }
+    }
+
+    private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
+        return (flagEncoder.getTime(edge.getFlags()) - secondsOnTrafficDay(edge, earliestStartTime)) * 1000;
+    }
+
+    private int secondsOnTrafficDay(EdgeIteratorState edge, long instant) {
+        final ZoneId zoneId = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(edge.getFlags())).zoneId;
+        return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toSecondOfDay();
+    }
+
+    private boolean isValidOn(EdgeIteratorState edge, long instant) {
+        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+        if (edgeType == GtfsStorage.EdgeType.BOARD || edgeType == GtfsStorage.EdgeType.ALIGHT) {
+            final int validityId = flagEncoder.getValidityId(edge.getFlags());
+            final GtfsStorage.Validity validity = gtfsStorage.getValidities().get(validityId);
+            final int trafficDay = (int) ChronoUnit.DAYS.between(validity.start, Instant.ofEpochMilli(instant).atZone(validity.zoneId).toLocalDate());
+            return validity.validity.get(trafficDay);
+        } else {
+            return true;
+        }
     }
 
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index b6f2f32768..91d1f3a971 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -23,13 +23,11 @@
 import com.conveyal.gtfs.model.StopTime;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.*;
-import com.graphhopper.Trip;
-import com.graphhopper.gtfs.fare.*;
+import com.graphhopper.gtfs.fare.Fares;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
@@ -46,16 +44,16 @@
 import java.io.File;
 import java.io.IOException;
 import java.time.Duration;
+import java.time.Instant;
 import java.time.LocalDateTime;
-import java.time.ZoneId;
 import java.time.format.DateTimeParseException;
 import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 import java.util.zip.ZipFile;
 
 import static com.graphhopper.reader.gtfs.Label.reverseEdges;
+import static com.graphhopper.util.Parameters.PT.RANGE_QUERY_END_TIME;
 
 public final class GraphHopperGtfs implements GraphHopperAPI {
 
@@ -87,25 +85,18 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         return new Factory(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage);
     }
 
-    public static final String EARLIEST_DEPARTURE_TIME_HINT = "earliest_departure_time";
-    public static final String RANGE_QUERY_END_TIME = "range_query_end_time";
-    public static final String ARRIVE_BY = "arrive_by";
-    public static final String IGNORE_TRANSFERS = "ignore_transfers";
-    public static final String WALK_SPEED_KM_H = "walk_speed";
-    public static final String MAX_WALK_DISTANCE_PER_LEG = "max_walk_distance_per_leg";
-    public static final String MAX_TRANSFER_DISTANCE_PER_LEG = "max_transfer_distance_per_leg";
-
     private final TranslationMap translationMap;
     private final PtFlagEncoder flagEncoder;
     private final GraphHopperStorage graphHopperStorage;
     private final LocationIndex locationIndex;
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
 
     private class RequestHandler {
         private final int maxVisitedNodesForRequest;
-        private final long initialTime;
-        private final long rangeQueryEndTime;
+        private final Instant initialTime;
+        private final Instant rangeQueryEndTime;
         private final boolean arriveBy;
         private final boolean ignoreTransfers;
         private final double walkSpeedKmH;
@@ -121,19 +112,18 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
 
         RequestHandler(GHRequest request) {
             maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, Integer.MAX_VALUE);
-            final String departureTimeString = request.getHints().get(EARLIEST_DEPARTURE_TIME_HINT, "");
+            final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
             try {
-                final LocalDateTime earliestDepartureTime = LocalDateTime.parse(departureTimeString);
-                initialTime = Duration.between(gtfsStorage.getStartDate().atStartOfDay(), earliestDepartureTime).getSeconds();
+                initialTime = Instant.parse(departureTimeString);
             } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format("Illegal value for required parameter %s: [%s]", EARLIEST_DEPARTURE_TIME_HINT, departureTimeString));
+                throw new IllegalArgumentException(String.format("Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
             }
-            rangeQueryEndTime = request.getHints().has(RANGE_QUERY_END_TIME) ? Duration.between(gtfsStorage.getStartDate().atStartOfDay(), LocalDateTime.parse(request.getHints().get(RANGE_QUERY_END_TIME, ""))).getSeconds() : initialTime;
-            arriveBy = request.getHints().getBool(ARRIVE_BY, false);
-            ignoreTransfers = request.getHints().getBool(IGNORE_TRANSFERS, false);
-            walkSpeedKmH = request.getHints().getDouble(WALK_SPEED_KM_H, 5.0);
-            maxWalkDistancePerLeg = request.getHints().getDouble(MAX_WALK_DISTANCE_PER_LEG, Double.MAX_VALUE);
-            maxTransferDistancePerLeg = request.getHints().getDouble(MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
+            rangeQueryEndTime = request.getHints().has(Parameters.PT.RANGE_QUERY_END_TIME) ? Instant.parse(request.getHints().get(RANGE_QUERY_END_TIME, "")) : initialTime;
+            arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
+            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, false);
+            walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
+            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Double.MAX_VALUE);
+            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
             weighting = createPtTravelTimeWeighting(flagEncoder, arriveBy, walkSpeedKmH);
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
@@ -184,7 +174,7 @@ private void parseSolutionsAndAddToResponse(Set<Label> solutions, PointList wayp
 
         private Set<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            GraphExplorer graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, arriveBy);
+            GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy);
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, maxVisitedNodesForRequest);
             Set<Label> solutions = router.calcPaths(startNode, Collections.singleton(destNode), initialTime, rangeQueryEndTime);
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
@@ -250,12 +240,12 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                 FakeWalkNetworkBuilder.buildWalkNetwork(((GtfsStorage) graphHopperStorage.getExtension()).getGtfsFeeds().values(), graphHopperStorage, ptFlagEncoder, Helper.DIST_EARTH);
             }
             LocationIndex walkNetworkIndex;
-            if (graphHopperStorage.getNodes() > 0 ) {
+            if (graphHopperStorage.getNodes() > 0) {
                 walkNetworkIndex = new LocationIndexTree(graphHopperStorage, new RAMDirectory()).prepareIndex();
             } else {
                 walkNetworkIndex = new EmptyLocationIndex();
             }
-            for (int i=0;i<id;i++) {
+            for (int i = 0; i < id; i++) {
                 new GtfsReader("gtfs_" + i, graphHopperStorage, walkNetworkIndex).readGraph();
             }
             graphHopperStorage.flush();
@@ -289,39 +279,93 @@ private static PtTravelTimeWeighting createPtTravelTimeWeighting(PtFlagEncoder e
         return weighting;
     }
 
-    private PathWrapper parseSolutionIntoPath(long initialTime, boolean arriveBy, PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+    private PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
         PathWrapper path = new PathWrapper();
 
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
-            reverseEdges(solution, queryGraph, false)
+            reverseEdges(solution, queryGraph, encoder, false)
                     .forEach(transitions::add);
         } else {
-            reverseEdges(solution, queryGraph, true)
+            reverseEdges(solution, queryGraph, encoder, true)
                     .forEach(transitions::add);
             Collections.reverse(transitions);
         }
 
         path.setWaypoints(waypoints);
 
+        List<List<Label.Transition>> partitions = getPartitions(transitions);
+
+        final List<Trip.Leg> legs = getLegs(encoder, tr, queryGraph, weighting, partitions);
+        path.getLegs().addAll(legs);
+
+        final InstructionList instructions = getInstructions(tr, path.getLegs());
+        path.setInstructions(instructions);
+        PointList pointsList = new PointList();
+        for (Instruction instruction : instructions) {
+            pointsList.add(instruction.getPoints());
+        }
+        path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
+        path.setPoints(pointsList);
+        path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
+        path.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+        if (solution.firstPtDepartureTime != Long.MAX_VALUE) {
+            path.setFirstPtLegDeparture(solution.firstPtDepartureTime);
+        }
+        path.setNumChanges((int) path.getLegs().stream()
+                .filter(l -> l instanceof Trip.PtLeg)
+                .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
+                .count() - 1);
+        com.graphhopper.gtfs.fare.Trip faresTrip = new com.graphhopper.gtfs.fare.Trip();
+        path.getLegs().stream()
+                .filter(leg -> leg instanceof Trip.PtLeg)
+                .map(leg -> (Trip.PtLeg) leg)
+                .findFirst()
+                .ifPresent(firstPtLeg -> {
+                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
+                    path.getLegs().stream()
+                            .filter(leg -> leg instanceof Trip.PtLeg)
+                            .map(leg -> (Trip.PtLeg) leg)
+                            .map(ptLeg -> {
+                                final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feedId);
+                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.tripId).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.boardStop.stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
+                            })
+                            .forEach(faresTrip.segments::add);
+                    Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
+                            .ifPresent(amount -> path.setFare(amount.getAmount()));
+                });
+        return path;
+    }
+
+    private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
         List<List<Label.Transition>> partitions = new ArrayList<>();
-        for (Label.Transition transition : transitions) {
-            if (partitions.isEmpty() || encoder.getEdgeType(transition.edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK || encoder.getEdgeType(partitions.get(partitions.size()-1).get(partitions.get(partitions.size()-1).size()-1).edge.getFlags()) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
-                partitions.add(new ArrayList<>());
+        partitions.add(new ArrayList<>());
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        partitions.get(partitions.size()-1).add(iterator.next());
+        iterator.forEachRemaining(transition -> {
+            final List<Label.Transition> previous = partitions.get(partitions.size() - 1);
+            final Label.EdgeLabel previousEdge = previous.get(previous.size() - 1).edge;
+            if (previousEdge != null && (transition.edge.edgeType == GtfsStorage.EdgeType.ENTER_PT || previousEdge.edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
+                final ArrayList<Label.Transition> p = new ArrayList<>();
+                p.add(new Label.Transition(previous.get(previous.size()-1).label, null));
+                partitions.add(p);
             }
             partitions.get(partitions.size()-1).add(transition);
-        }
+        });
+        return partitions;
+    }
 
-        path.getLegs().addAll(partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, encoder, weighting, tr).stream()).collect(Collectors.toList()));
+    private List<Trip.Leg> getLegs(PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+        return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, encoder, weighting, tr).stream()).collect(Collectors.toList());
+    }
 
+    private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
         final InstructionList instructions = new InstructionList(tr);
-        for (int i=0; i<path.getLegs().size(); ++i) {
-            Trip.Leg leg = path.getLegs().get(i);
+        for (int i = 0; i< legs.size(); ++i) {
+            Trip.Leg leg = legs.get(i);
             if (leg instanceof Trip.WalkLeg) {
                 final Trip.WalkLeg walkLeg = ((Trip.WalkLeg) leg);
-                for (Instruction instruction : walkLeg.instructions.subList(0, i < path.getLegs().size()-1 ? walkLeg.instructions.size()-1 : walkLeg.instructions.size())) {
-                    instructions.add(instruction);
-                }
+                instructions.addAll(walkLeg.instructions.subList(0, i < legs.size() - 1 ? walkLeg.instructions.size() - 1 : walkLeg.instructions.size()));
             } else if (leg instanceof Trip.PtLeg) {
                 final Trip.PtLeg ptLeg = ((Trip.PtLeg) leg);
                 final PointList pl;
@@ -349,40 +393,7 @@ private PathWrapper parseSolutionIntoPath(long initialTime, boolean arriveBy, Pt
                 }
             }
         }
-
-        path.setInstructions(instructions);
-        PointList pointsList = new PointList();
-        for (Instruction instruction : path.getInstructions()) {
-            pointsList.add(instruction.getPoints());
-        }
-        path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
-        path.setPoints(pointsList);
-        path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((solution.currentTime - initialTime) * 1000 * (arriveBy ? -1 : 1));
-        path.setFirstPtLegDeparture(solution.firstPtDepartureTime);
-        path.setNumChanges((int) path.getLegs().stream()
-                .filter(l->l instanceof Trip.PtLeg)
-                .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
-                .count() - 1);
-        com.graphhopper.gtfs.fare.Trip faresTrip = new com.graphhopper.gtfs.fare.Trip();
-        path.getLegs().stream()
-                .filter(leg -> leg instanceof Trip.PtLeg)
-                .map(leg -> (Trip.PtLeg) leg)
-                .findFirst()
-                .ifPresent(firstPtLeg -> {
-                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
-                    path.getLegs().stream()
-                            .filter(leg -> leg instanceof Trip.PtLeg)
-                            .map(leg -> (Trip.PtLeg) leg)
-                            .map(ptLeg -> {
-                                final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feedId);
-                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.tripId).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.boardStop.stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
-                            })
-                            .forEach(faresTrip.segments::add);
-                    Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
-                            .ifPresent(amount -> path.setFare(amount.getAmount()));
-                });
-        return path;
+        return instructions;
     }
 
     private PointList pointListFrom(List<QueryResult> queryResults) {
@@ -398,47 +409,44 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
     private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, PtFlagEncoder encoder, Weighting weighting, Translation tr) {
-        GeometryFactory geometryFactory = new GeometryFactory();
-        if (GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK == encoder.getEdgeType(path.get(0).edge.getFlags())) {
-            String feedId = gtfsStorage.getExtraStrings().get(path.get(0).edge.getEdge());
-            final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
+        if (GtfsStorage.EdgeType.ENTER_PT == path.get(1).edge.edgeType) {
+            final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(path.get(1).edge.timeZoneId);
+            final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedIdWithTimezone.feedId);
             List<Trip.Leg> result = new ArrayList<>();
-            LocalDateTime boardTime = null;
-            List<EdgeIteratorState> partition = null;
-            for (int i=1; i<path.size(); i++) {
+            long boardTime = -1;
+            List<Label.Transition> partition = null;
+            for (int i = 1; i < path.size(); i++) {
                 Label.Transition transition = path.get(i);
-                LocalDateTime time = gtfsStorage.getStartDate().atStartOfDay().plusSeconds(transition.label.currentTime);
-
-                EdgeIteratorState edge = path.get(i).edge;
-                GtfsStorage.EdgeType edgeType = encoder.getEdgeType(edge.getFlags());
-                if (edgeType == GtfsStorage.EdgeType.BOARD) {
-                    boardTime = time;
+                Label.EdgeLabel edge = path.get(i).edge;
+                if (edge.edgeType == GtfsStorage.EdgeType.BOARD) {
+                    boardTime = transition.label.currentTime;
                     partition = new ArrayList<>();
                 }
                 if (partition != null) {
-                    partition.add(edge);
+                    partition.add(path.get(i));
                 }
-                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edgeType)) {
-                    Geometry lineString = lineStringFromEdges(geometryFactory, partition);
-                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).getEdge());
-                    List<EdgeIteratorState> edges = partition.stream()
-                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD).contains(encoder.getEdgeType(e.getFlags())))
-                            .collect(Collectors.toList());
-                    List<Trip.Stop> stops = edges.stream()
-                            .map(e -> stopFromHopEdge(geometryFactory, feedId, tripId, gtfsStorage.getStopSequences().get(e.getEdge())))
-                            .collect(Collectors.toList());
+                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
+                    Geometry lineString = lineStringFromEdges(partition);
+                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
+                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
+                    partition.stream()
+                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
+                            .forEach(stopsFromBoardHopDwellEdges::next);
+                    stopsFromBoardHopDwellEdges.finish();
+                    List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
+
                     com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
                     result.add(new Trip.PtLeg(
-                            feedId,
-                            encoder.getTransfers(partition.get(0).getFlags()) == 0,
+                            feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
                             stops.get(0),
                             tripId,
                             trip.route_id,
-                            partition,
-                            Date.from(boardTime.atZone(ZoneId.systemDefault()).toInstant()),
+                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                            new Date(boardTime),
                             stops,
-                            partition.stream().mapToDouble(EdgeIteratorState::getDistance).sum(),
-                            Duration.between(boardTime, time).toMillis(),
+                            partition.stream().mapToDouble(t -> t.edge.distance).sum(),
+                            path.get(i-1).label.currentTime - boardTime,
+                            new Date(path.get(i-1).label.currentTime),
                             lineString));
                     partition = null;
                 }
@@ -446,37 +454,97 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(0).edge.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
-            for (int i=0; i<path.size(); i++) {
-                EdgeIteratorState edge = path.get(i).edge;
+            for (int i=1; i<path.size(); i++) {
+                EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
                 instructionsFromEdges.next(edge, i, prevEdgeId);
                 prevEdgeId = edge.getEdge();
             }
             instructionsFromEdges.finish();
+            final Instant departureTime = Instant.ofEpochMilli(path.get(0).label.currentTime);
+            final Instant arrivalTime = Instant.ofEpochMilli(path.get(path.size() - 1).label.currentTime);
             return Collections.singletonList(new Trip.WalkLeg(
                     "Walk",
-                    path.stream().map(t -> t.edge).collect(Collectors.toList()),
-                    lineStringFromEdges(geometryFactory, path.stream().map(t -> t.edge).collect(Collectors.toList())),
-                    path.stream().mapToDouble(t -> t.edge.getDistance()).sum(),
-                    StreamSupport.stream(instructions.spliterator(), false).collect(Collectors.toCollection(() -> new InstructionList(tr)))));
+                    Date.from(departureTime),
+                    edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                    lineStringFromEdges(path),
+                    edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
+                    instructions.stream().collect(Collectors.toCollection(() -> new InstructionList(tr))),
+                    Date.from(arrivalTime)));
         }
     }
 
-    private static Geometry lineStringFromEdges(GeometryFactory geometryFactory, List<EdgeIteratorState> edges) {
-        return Stream.concat(Stream.of(edges.get(0).fetchWayGeometry(3)),
-                edges.stream().map(edge -> edge.fetchWayGeometry(2)))
-                .flatMap(pointList -> pointList.toGeoJson().stream())
-                    .map(doubles -> new Coordinate(doubles[0], doubles[1]))
-                    .collect(Collectors.collectingAndThen(Collectors.toList(),
-                            coords -> geometryFactory.createLineString(coords.toArray(new Coordinate[]{}))));
+    private Stream<Label.EdgeLabel> edges(List<Label.Transition> path) {
+        return path.stream().filter(t -> t.edge != null).map(t -> t.edge);
+    }
+
+    private Geometry lineStringFromEdges(List<Label.Transition> transitions) {
+        List<Coordinate> coordinates = new ArrayList<>();
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        iterator.next();
+        coordinates.addAll(toCoordinateArray(iterator.next().edge.edgeIteratorState.fetchWayGeometry(3)));
+        iterator.forEachRemaining(transition -> {
+            coordinates.addAll(toCoordinateArray(transition.edge.edgeIteratorState.fetchWayGeometry(2)));
+        });
+        return geometryFactory.createLineString(coordinates.toArray(new Coordinate[coordinates.size()]));
+    }
+
+
+    public static List<Coordinate> toCoordinateArray(PointList pointList) {
+        List<Coordinate> coordinates = new ArrayList<>(pointList.size());
+        for (int i=0; i<pointList.size(); i++) {
+            coordinates.add(pointList.getDimension() == 3 ?
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i)) :
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i), pointList.getEle(i)));
+        }
+        return coordinates;
     }
 
-    private Trip.Stop stopFromHopEdge(GeometryFactory geometryFactory, String feedId, String tripId, int stopSequence) {
-        GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
-        StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
-        Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-        return new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)));
+    private class StopsFromBoardHopDwellEdges {
+
+        private final String tripId;
+        private final List<Trip.Stop> stops = new ArrayList<>();
+        private final GTFSFeed gtfsFeed;
+        private long arrivalTimeFromHopEdge;
+        private Stop stop = null;
+
+        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
+            this.tripId = tripId;
+            this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
+        }
+
+        void next(Label.Transition t) {
+            long departureTime;
+            switch (t.edge.edgeType) {
+                case BOARD:
+                    stop = findStop(t);
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
+                    break;
+                case HOP:
+                    stop = findStop(t);
+                    arrivalTimeFromHopEdge = t.label.currentTime;
+                    break;
+                case DWELL:
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
+                    break;
+                default:
+                    throw new RuntimeException();
+            }
+        }
+
+        private Stop findStop(Label.Transition t) {
+            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
+            return gtfsFeed.stops.get(stopTime.stop_id);
+        }
+
+        void finish() {
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
+        }
+
     }
 
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 9cd1a06108..40674108f9 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -38,6 +38,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.time.LocalDate;
+import java.time.ZoneId;
 import java.util.*;
 import java.util.stream.Collectors;
 
@@ -134,11 +135,7 @@ public void readGraph() {
 
     private void buildPtNetwork() {
         LocalDate startDate = feed.calculateStats().getStartDate();
-        gtfsStorage.setStartDate(startDate);
         LocalDate endDate = feed.calculateStats().getEndDate();
-        BitSet alwaysValid = new BitSet((int) DAYS.between(startDate, endDate));
-        alwaysValid.set(0, alwaysValid.size());
-        gtfsStorage.getOperatingDayPatterns().put(alwaysValid, 0);
         HashMultimap<String, Trip> blockTrips = HashMultimap.create();
         for (Trip trip : feed.trips.values()) {
             if (trip.block_id != null) {
@@ -167,6 +164,7 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
+                        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trip.route_id).agency_id).agency_timezone);
                         StopTime prev = null;
                         int arrivalNode = -1;
                         int departureNode = -1;
@@ -208,7 +206,7 @@ private void buildPtNetwork() {
                             nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
                             times.put(departureNode, stopTime.departure_time + time);
                             int dayShift = stopTime.departure_time / (24 * 60 * 60);
-                            BitSet validOn = getValidOn(validOnDay, dayShift);
+                            GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
                             int validityId;
                             if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
                                 validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
@@ -303,15 +301,29 @@ private void buildPtNetwork() {
     }
 
     private void wireUpAndAndConnectArrivalTimeline(Stop stop, String routeId, int stopExitNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
+        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(routeId).agency_id).agency_timezone);
         for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
             EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode, 0.0, false);
             setEdgeType(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
             int arrivalTime = e.a;
             leaveTimeExpandedNetworkEdge.setFlags(encoder.setTime(leaveTimeExpandedNetworkEdge.getFlags(), arrivalTime));
+            setFeedIdWithTimezone(leaveTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
         }
     }
 
+    private void setFeedIdWithTimezone(EdgeIteratorState leaveTimeExpandedNetworkEdge, GtfsStorage.FeedIdWithTimezone validOn) {
+        int validityId;
+        if (gtfsStorage.getWritableTimeZones().containsKey(validOn)) {
+            validityId = gtfsStorage.getWritableTimeZones().get(validOn);
+        } else {
+            validityId = gtfsStorage.getWritableTimeZones().size();
+            gtfsStorage.getWritableTimeZones().put(validOn, validityId);
+        }
+        leaveTimeExpandedNetworkEdge.setFlags(encoder.setValidityId(leaveTimeExpandedNetworkEdge.getFlags(), validityId));
+    }
+
     private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId, int stopEnterNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
+        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(toRouteId).agency_id).agency_timezone);
         int time = 0;
         int prev = -1;
         for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
@@ -319,7 +331,7 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
             enterTimeExpandedNetworkEdge.setName(toStop.stop_name);
             setEdgeType(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
             enterTimeExpandedNetworkEdge.setFlags(encoder.setTime(enterTimeExpandedNetworkEdge.getFlags(), e.a));
-            gtfsStorage.getExtraStrings().put(enterTimeExpandedNetworkEdge.getEdge(), id);
+            setFeedIdWithTimezone(enterTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
                 EdgeIteratorState edge = graph.edge(e.b, prev, 0.0, false);
                 setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 8ef461e1a8..bcf528da11 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -20,29 +20,79 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Fare;
+import com.conveyal.gtfs.model.FareRule;
 import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.gtfs.fare.FixedFareAttributeLoader;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
 import org.mapdb.*;
 
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Files;
+import java.io.*;
 import java.time.LocalDate;
+import java.time.ZoneId;
+import java.nio.file.Files;
 import java.util.*;
 import java.util.concurrent.ExecutionException;
 import java.util.zip.ZipFile;
 
 public class GtfsStorage implements GraphExtension {
 
+	public static class Validity implements Serializable {
+		final BitSet validity;
+		final ZoneId zoneId;
+		final LocalDate start;
+
+		Validity(BitSet validity, ZoneId zoneId, LocalDate start) {
+			this.validity = validity;
+			this.zoneId = zoneId;
+			this.start = start;
+		}
+
+		@Override
+		public boolean equals(Object other) {
+			if (! (other instanceof Validity)) return false;
+			Validity v = (Validity) other;
+			return validity.equals(v.validity) && zoneId.equals(v.zoneId) && start.equals(v.start);
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(validity, zoneId, start);
+		}
+	}
+
+	static class FeedIdWithTimezone implements Serializable {
+		final String feedId;
+		final ZoneId zoneId;
+
+		FeedIdWithTimezone(String feedId, ZoneId zoneId) {
+			this.feedId = feedId;
+			this.zoneId = zoneId;
+		}
+
+		@Override
+		public boolean equals(Object other) {
+			if (! (other instanceof FeedIdWithTimezone)) return false;
+			FeedIdWithTimezone v = (FeedIdWithTimezone) other;
+			return feedId.equals(v.feedId) && zoneId.equals(v.zoneId);
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(feedId, zoneId);
+		}
+
+	}
+
 	private boolean isClosed = false;
 	private Directory dir;
 	private Set<String> gtfsFeedIds;
 	private Map<String, GTFSFeed> gtfsFeeds = new HashMap<>();
-	private HTreeMap<BitSet, Integer> operatingDayPatterns;
-	private Map<Integer, BitSet> validities;
-	private Atomic.Var<LocalDate> startDate;
+	private HTreeMap<Validity, Integer> operatingDayPatterns;
+	private Map<Integer, Validity> validities;
+	private Bind.MapWithModificationListener<FeedIdWithTimezone, Integer> timeZones;
+	private Map<Integer, FeedIdWithTimezone> readableTimeZones;
 	private Map<Integer, String> extra;
 	private Map<Integer, Integer> stopSequences;
 	private Map<String, Fare> fares;
@@ -121,13 +171,19 @@ public GraphExtension create(long byteCount) {
 	private void init() {
 		this.gtfsFeedIds = data.getHashSet("gtfsFeeds");
 		this.operatingDayPatterns = data.getHashMap("validities");
-		Map<Integer, BitSet> reverseOperatingDayPatterns = new HashMap<>();
-		for (Map.Entry<BitSet, Integer> entry : this.operatingDayPatterns.entrySet()) {
+		Map<Integer, Validity> reverseOperatingDayPatterns = new HashMap<>();
+		for (Map.Entry<Validity, Integer> entry : this.operatingDayPatterns.entrySet()) {
 			reverseOperatingDayPatterns.put(entry.getValue(), entry.getKey());
 		}
 		Bind.mapInverse(this.operatingDayPatterns, reverseOperatingDayPatterns);
+		this.timeZones = data.getHashMap("timeZones");
+		Map<Integer, FeedIdWithTimezone> readableTimeZones = new HashMap<>();
+		for (Map.Entry<FeedIdWithTimezone, Integer> entry : this.timeZones.entrySet()) {
+			readableTimeZones.put(entry.getValue(), entry.getKey());
+		}
+		Bind.mapInverse(this.timeZones, readableTimeZones);
+		this.readableTimeZones = Collections.unmodifiableMap(readableTimeZones);
 		this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
-		this.startDate = data.getAtomicVar("startDate");
 		this.extra = data.getTreeMap("extra");
 		this.stopSequences = data.getTreeMap("stopSequences");
 		this.fares = data.getTreeMap("fares");
@@ -139,6 +195,7 @@ void loadGtfsFromFile(String id, ZipFile zip) {
 		try {
 			GTFSFeed feed = new GTFSFeed(dir.getLocation() + "/" + id);
 			feed.loadFromFile(zip);
+			fixFares(feed, zip);
 			this.gtfsFeeds.put(id, feed);
 		} catch (Exception e) {
 			throw new RuntimeException(e);
@@ -146,6 +203,18 @@ void loadGtfsFromFile(String id, ZipFile zip) {
 		this.gtfsFeedIds.add(id);
 	}
 
+	private void fixFares(GTFSFeed feed, ZipFile zip) {
+		feed.fares.clear();
+		Map<String, Fare> fares = new HashMap<>();
+		try {
+			new FixedFareAttributeLoader(feed, fares).loadTable(zip);
+			new FareRule.Loader(feed, fares).loadTable(zip);
+		} catch (IOException e) {
+			throw new RuntimeException(e);
+		}
+		feed.fares.putAll(fares);
+	}
+
 	@Override
 	public void flush() {
 	}
@@ -171,22 +240,22 @@ public long getCapacity() {
 		return 0;
 	}
 
-	void setStartDate(LocalDate startDate) {
-		this.startDate.set(startDate);
-	}
-
-	LocalDate getStartDate() {
-		return startDate.get();
-	}
-
-    Map<BitSet, Integer> getOperatingDayPatterns() {
+    Map<Validity, Integer> getOperatingDayPatterns() {
         return operatingDayPatterns;
     }
 
-	Map<Integer, BitSet> getValidities() {
+	Map<Integer, Validity> getValidities() {
 		return validities;
 	}
 
+	Map<Integer, FeedIdWithTimezone> getTimeZones() {
+		return readableTimeZones;
+	}
+
+	Map<FeedIdWithTimezone, Integer> getWritableTimeZones() {
+		return timeZones;
+	}
+
 	Map<Integer, String> getExtraStrings() {
 		return extra;
 	}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 98aa2f7dcc..71e7706790 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.reader.gtfs;
 
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.util.Iterator;
@@ -28,12 +26,39 @@
 
     static class Transition {
         final Label label;
-        final EdgeIteratorState edge;
+        final EdgeLabel edge;
 
-        Transition(Label label, EdgeIteratorState edge) {
+        Transition(Label label, EdgeLabel edge) {
             this.label = label;
             this.edge = edge;
         }
+
+        @Override
+        public String toString() {
+            return (edge != null ? edge.toString() + " -> " : "") + label.adjNode;
+        }
+
+    }
+
+    static class EdgeLabel {
+        final EdgeIteratorState edgeIteratorState;
+        final GtfsStorage.EdgeType edgeType;
+        final int timeZoneId;
+        final int nTransfers;
+        final double distance;
+
+        public EdgeLabel(EdgeIteratorState edgeIteratorState, GtfsStorage.EdgeType edgeType, int timeZoneId, int nTransfers, double distance) {
+            this.edgeIteratorState = edgeIteratorState;
+            this.edgeType = edgeType;
+            this.timeZoneId = timeZoneId;
+            this.nTransfers = nTransfers;
+            this.distance = distance;
+        }
+
+        @Override
+        public String toString() {
+            return edgeType.toString();
+        }
     }
 
     final long currentTime;
@@ -65,28 +90,42 @@ public String toString() {
         return adjNode + " (" + edge + ") time: " + currentTime;
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
                 return new Iterator<Transition>() {
+                    int i = 0;
                     Label label = leaf;
                     @Override
                     public boolean hasNext() {
-                        return label.parent != null;
+                        return reverseEdgeFlags ? label != null : label.parent != null;
                     }
 
                     @Override
                     public Transition next() {
-                        EdgeIteratorState edgeIteratorState = graph.getEdgeIteratorState(label.edge, label.parent.adjNode)
-                                .detach(reverseEdgeFlags);
-                        Transition transition = new Transition(label, edgeIteratorState);
-                        label = label.parent;
-                        return transition;
+                        if (i==0 && !reverseEdgeFlags) {
+                            ++i;
+                            return new Transition(label, null);
+                        } else {
+                            EdgeIteratorState edgeIteratorState = label.parent == null ? null : graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
+                            Transition transition;
+                            if (reverseEdgeFlags) {
+                                transition = new Transition(label, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
+                            } else {
+                                transition = new Transition(label.parent, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
+                            }
+                            label = label.parent;
+                            return transition;
+                        }
                     }
                 };
             }
         };
     }
 
+    private static EdgeLabel getEdgeLabel(EdgeIteratorState edgeIteratorState, PtFlagEncoder flagEncoder) {
+        return new EdgeLabel(edgeIteratorState, flagEncoder.getEdgeType(edgeIteratorState.getFlags()), flagEncoder.getValidityId(edgeIteratorState.getFlags()), flagEncoder.getTransfers(edgeIteratorState.getFlags()), edgeIteratorState.getDistance());
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 761ce36f6e..68466f380a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -20,10 +20,10 @@
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
+import java.time.Instant;
 import java.util.*;
 
 /**
@@ -76,10 +76,10 @@ private long queueCriterion(Label o1) {
         return currentTimeCriterion(o1) + o1.nTransfers + o1.nWalkDistanceConstraintViolations;
     }
 
-    Set<Label> calcPaths(int from, Set<Integer> to, long startTime, long rangeQueryEndTime) {
-        this.rangeQueryEndTime = rangeQueryEndTime;
+    Set<Label> calcPaths(int from, Set<Integer> to, Instant startTime, Instant rangeQueryEndTime) {
+        this.rangeQueryEndTime = rangeQueryEndTime.toEpochMilli();
         Set<Label> targetLabels = new HashSet<>();
-        Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, Long.MAX_VALUE, null);
+        Label label = new Label(startTime.toEpochMilli(), EdgeIterator.NO_EDGE, from, 0, 0, 0.0, Long.MAX_VALUE, null);
         fromMap.put(from, label);
         if (to.contains(from)) {
             targetLabels.add(label);
@@ -93,20 +93,20 @@ private long queueCriterion(Label o1) {
                 GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
                 long nextTime;
                 if (reverse) {
-                    nextTime = label.currentTime - weighting.calcTravelTimeSeconds(edge, label.currentTime);
+                    nextTime = label.currentTime - explorer.calcTravelTimeMillis(edge, label.currentTime);
                 } else {
-                    nextTime = label.currentTime + weighting.calcTravelTimeSeconds(edge, label.currentTime);
+                    nextTime = label.currentTime + explorer.calcTravelTimeMillis(edge, label.currentTime);
                 }
                 int nTransfers = label.nTransfers + weighting.calcNTransfers(edge);
                 long firstPtDepartureTime = label.firstPtDepartureTime;
                 if (!reverse && edgeType == GtfsStorage.EdgeType.BOARD && firstPtDepartureTime == Long.MAX_VALUE) {
                     firstPtDepartureTime = nextTime;
                 }
-                if (reverse && edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && firstPtDepartureTime == Long.MAX_VALUE) {
+                if (reverse && edgeType == GtfsStorage.EdgeType.ALIGHT && firstPtDepartureTime == Long.MAX_VALUE) {
                     firstPtDepartureTime = nextTime;
                 }
-                double walkDistanceOnCurrentLeg = (edgeType == GtfsStorage.EdgeType.BOARD) ? 0 : (label.walkDistanceOnCurrentLeg + weighting.getWalkDistance(edge));
-                boolean isTryingToReEnterPtAfterTransferWalking = edgeType == GtfsStorage.EdgeType.ENTER_PT && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
+                double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + weighting.getWalkDistance(edge));
+                boolean isTryingToReEnterPtAfterTransferWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
                 int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
                         isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
                 Set<Label> sptEntries = fromMap.get(edge.getAdjNode());
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
index 78fc7ed6a1..b119fc953a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
@@ -22,25 +22,9 @@
 import com.graphhopper.routing.weighting.AbstractWeighting;
 import com.graphhopper.util.EdgeIteratorState;
 
-class PtTravelTimeWeighting extends AbstractWeighting {
+import java.time.Instant;
 
-    private static long travelTime(int edgeTimeValue, long earliestStartTime) {
-        int timeOfDay = (int) (earliestStartTime % (24 * 60 * 60));
-        if (timeOfDay <= edgeTimeValue) {
-            return (edgeTimeValue - timeOfDay);
-        } else {
-            throw new RuntimeException();
-        }
-    }
-
-    private static long travelTimeReverse(int edgeTimeValue, long latestExitTime) {
-        int timeOfDay = (int) (latestExitTime % (24 * 60 * 60));
-        if (timeOfDay >= edgeTimeValue) {
-            return (timeOfDay - edgeTimeValue);
-        } else {
-            throw new RuntimeException();
-        }
-    }
+class PtTravelTimeWeighting extends AbstractWeighting {
 
     private final boolean reverse;
     private final double walkSpeedKmH;
@@ -85,28 +69,6 @@ public long calcMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEd
         }
     }
 
-    long calcTravelTimeSeconds(EdgeIteratorState edge, long earliestStartTime) {
-        GtfsStorage.EdgeType edgeType = ((PtFlagEncoder) getFlagEncoder()).getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return (long) (getWalkDistance(edge) * 3.6 / walkSpeedKmH);
-            case ENTER_TIME_EXPANDED_NETWORK:
-                if (reverse) {
-                    return 0;
-                } else {
-                    return travelTime((int) ((PtFlagEncoder) getFlagEncoder()).getTime(edge.getFlags()), earliestStartTime);
-                }
-            case LEAVE_TIME_EXPANDED_NETWORK:
-                if (reverse) {
-                    return travelTimeReverse((int) ((PtFlagEncoder) getFlagEncoder()).getTime(edge.getFlags()), earliestStartTime);
-                } else {
-                    return 0;
-                }
-            default:
-                return ((PtFlagEncoder) getFlagEncoder()).getTime(edge.getFlags());
-        }
-	}
-
 	int calcNTransfers(EdgeIteratorState edge) {
         return transferFactor * ((PtFlagEncoder) getFlagEncoder()).getTransfers(edge.getFlags());
 	}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 878738c087..480c8b8d3a 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -27,6 +27,7 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
+import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -34,6 +35,7 @@
 
 import java.io.File;
 import java.math.BigDecimal;
+import java.time.Instant;
 import java.time.LocalDateTime;
 import java.time.LocalTime;
 import java.time.ZoneId;
@@ -51,6 +53,7 @@
 
     private static final String GRAPH_LOC = "target/GraphHopperGtfsIT";
     private static GraphHopperGtfs graphHopper;
+    private static final ZoneId zoneId = ZoneId.of("America/Los_Angeles");
     private static GraphHopperStorage graphHopperStorage;
     private static LocationIndex locationIndex;
 
@@ -61,7 +64,7 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
@@ -81,8 +84,7 @@ public void testRoute1() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0,0).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -98,8 +100,7 @@ public void testRoute1DoesNotGoAt654() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6,54).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,54).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -115,8 +116,8 @@ public void testRoute1GoesAt744() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,7,44).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -134,9 +135,8 @@ public void testRoute1ArriveBy() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6, 49));
-        ghRequest.getHints().put(GraphHopperGtfs.ARRIVE_BY, true);
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6, 49).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -154,14 +154,13 @@ public void testRoute1ProfileEarliestArrival() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0));
-        ghRequest.getHints().put(GraphHopperGtfs.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,1,13,0));
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,1,13,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(1)).departureTime.toInstant().atZone(ZoneId.systemDefault())))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
@@ -179,16 +178,15 @@ public void testRoute1ProfileLatestDeparture() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,2,13,00));
-        ghRequest.getHints().put(GraphHopperGtfs.ARRIVE_BY, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,2,11,0));
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,13,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, "true");
+        ghRequest.getHints().put(Parameters.PT.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,2,11,0).atZone(zoneId).toInstant());
         // TODO: Find the problem with 1.1.2007
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(1)).departureTime.toInstant().atZone(ZoneId.systemDefault())))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "12:44", "12:14", "11:44", "11:14", "10:44")
@@ -226,14 +224,14 @@ public void testRoute5() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0));
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(8, 10), route.getBest().getTime(), 0.1);
-        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(1)).tripId));
+        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).tripId));
+        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).tripId));
         assertEquals("Paid expected fare", 250, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue()); // Two legs, no transfers allowed. Need two 'p' tickets costing 125 cents each.
     }
 
@@ -249,7 +247,7 @@ public void testRouteWithLaterDepartureTime() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.914894, TO_LON = -116.76821; // NADAV stop
         // Missed the bus at 10 by one minute, will have to use the 10:30 one.
-        assertTravelTimeIs(graphHopper, FROM_LAT, FROM_LON, LocalDateTime.of(2007,1,1,10, 1), TO_LAT, TO_LON, time(0, 41));
+        assertTravelTimeIs(graphHopper, FROM_LAT, FROM_LON, LocalDateTime.of(2007,1,1,10, 1).atZone(zoneId).toInstant(), TO_LAT, TO_LON, time(0, 41));
     }
 
     @Test
@@ -260,8 +258,7 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0)); // Monday morning
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant()); // Monday morning
 
 
         GHResponse route = graphHopper.route(ghRequest);
@@ -271,14 +268,13 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest1.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,0,0));
-        ghRequest1.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest1.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,0,0).atZone(zoneId).toInstant());
         GHResponse route1 = graphHopper.route(ghRequest1);
 
         assertFalse(route1.hasErrors());
         assertFalse(route1.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route1.getBest().getTime());
-        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route1.getBest().getLegs().get(1)).tripId));
+        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route1.getBest().getLegs().get(0)).tripId));
         assertEquals("Paid expected fare", 525, route1.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue());
 
     }
@@ -291,20 +287,18 @@ public void testBlockTrips() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,8,0));
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
-        GHResponse route = graphHopper.route(ghRequest);
-        assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, route.getAll().size());
-        assertEquals("Expected travel time == scheduled travel time", time(1,20), route.getBest().getTime());
-        assertEquals("Four legs: walk, pt, pt, walk, but the two pt legs are in one vehicle, so...", 4, route.getBest().getLegs().size());
-        assertEquals("...one boarding instruction", 1, route.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_START_TRIP).count());
-        assertEquals("...and one alighting instruction", 1, route.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_END_TRIP).count());
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        GHResponse response = graphHopper.route(ghRequest);
+        assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, response.getAll().size());
+        assertEquals("Expected travel time == scheduled travel time", time(1,20), response.getBest().getTime());
+        assertEquals("Two legs: pt, pt, but the two pt legs are in one vehicle, so...", 2, response.getBest().getLegs().size());
+        assertEquals("...one boarding instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_START_TRIP).count());
+        assertEquals("...and one alighting instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_END_TRIP).count());
     }
 
     @Test
     public void testTransferRules() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
-        final double VIA_LAT = 36.868446, VIA_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO1_LAT = 36.641496, TO1_LON = -116.40094; // AMV stop
         final double TO2_LAT = 36.88108, TO2_LON = -116.81797; // BULLFROG stop
 
@@ -312,7 +306,7 @@ public void testTransferRules() {
                 FROM_LAT, FROM_LON,
                 TO1_LAT, TO1_LON
         );
-        request.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,7,30));
+        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(request);
         assertEquals("Ignoring transfer rules (free walking): Will be there at 9.", time(1, 30), response.getBest().getTime());
@@ -321,8 +315,8 @@ public void testTransferRules() {
                 FROM_LAT, FROM_LON,
                 TO1_LAT, TO1_LON
         );
-        request.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,7,30));
-        request.getHints().put(GraphHopperGtfs.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
+        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
+        request.getHints().put(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
 
         response = graphHopper.route(request);
         assertEquals("Transfer rule: 11 minutes. Will miss connection, and be there at 14.", time(6, 30), response.getBest().getTime());
@@ -331,7 +325,7 @@ public void testTransferRules() {
                 FROM_LAT, FROM_LON,
                 TO2_LAT, TO2_LON
         );
-        request.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,7,30));
+        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Ignoring transfer rules (free walking): Will be there at 8:10.", time(0, 40), response.getBest().getTime());
@@ -340,8 +334,8 @@ public void testTransferRules() {
                 FROM_LAT, FROM_LON,
                 TO2_LAT, TO2_LON
         );
-        request.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,7,30));
-        request.getHints().put(GraphHopperGtfs.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
+        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
+        request.getHints().put(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
 
         response = graphHopper.route(request);
         assertEquals("Will still be there at 8:10 because there is a route-specific exception for this route.", time(0, 40), response.getBest().getTime());
@@ -350,22 +344,21 @@ public void testTransferRules() {
                 TO2_LAT, TO2_LON,
                 FROM_LAT, FROM_LON
         );
-        request.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,12,05));
-        request.getHints().put(GraphHopperGtfs.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
+        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,12,5).atZone(zoneId).toInstant());
+        request.getHints().put(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, 0.0);
 
         response = graphHopper.route(request);
         assertEquals("Will take 1:15 because of a 'from route' exception with a longer transfer time.", time(1, 15), response.getBest().getTime());
-
     }
 
 
-    private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double from_lat, double from_lon, LocalDateTime earliestDepartureTime, double to_lat, double to_lon, int expectedTravelTime) {
+    private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double from_lat, double from_lon, Instant earliestDepartureTime, double to_lat, double to_lon, int expectedTravelTime) {
         GHRequest ghRequest = new GHRequest(
                 from_lat, from_lon,
                 to_lat, to_lon
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, earliestDepartureTime);
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, earliestDepartureTime);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -374,7 +367,7 @@ private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double from_lat, do
     }
 
     private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, double FROM_LON, double TO_LAT, double TO_LON, int expectedWeight) {
-        assertTravelTimeIs(graphHopper, FROM_LAT, FROM_LON, LocalDateTime.of(2007,1,1,0,0), TO_LAT, TO_LON, expectedWeight);
+        assertTravelTimeIs(graphHopper, FROM_LAT, FROM_LON, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant(), TO_LAT, TO_LON, expectedWeight);
     }
 
     private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double from_lon, double to_lat, double to_lon) {
@@ -382,8 +375,8 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
                 from_lat, from_lon,
                 to_lat, to_lon
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse route = graphHopper.route(ghRequest);
         Assert.assertTrue(route.getAll().isEmpty());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 428e5e7b2a..4982eb31c8 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -27,12 +27,15 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
+import java.time.Instant;
 import java.time.LocalDateTime;
+import java.time.ZoneId;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -43,6 +46,7 @@
 public class RealtimeIT {
 
     private static final String GRAPH_LOC = "target/RealtimeIT";
+    private static final ZoneId zoneId = ZoneId.of("America/Los_Angeles");
     private static GraphHopperGtfs.Factory graphHopperFactory;
     private static GraphHopperStorage graphHopperStorage;
     private static LocationIndex locationIndex;
@@ -75,9 +79,9 @@ public void testSkipDepartureStop() {
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6,44).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -106,9 +110,9 @@ public void testSkipArrivalStop() {
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6,44).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -137,9 +141,9 @@ public void testSkipTransferStop() {
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6,44).toString());
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -166,9 +170,9 @@ public void testBlockTrips() {
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,8,0));
-        ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, "true");
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
@@ -183,7 +187,7 @@ public void testBlockTrips() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(1)).tripId));
+        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).tripId));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/gtfs/fare/FareTest.java b/reader-gtfs/src/test/java/com/graphhopper/gtfs/fare/FareTest.java
index 499e4ae3fd..5df3630511 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/gtfs/fare/FareTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/gtfs/fare/FareTest.java
@@ -142,7 +142,7 @@ public void buyMoreThanOneTicketIfTripIsLongerThanAllowedOnOne(Map<String, Fare>
     private static Map<String, Fare> parseFares(String fareAttributes, String fareRules) {
         GTFSFeed feed = new GTFSFeed();
         HashMap<String, Fare> fares = new HashMap<>();
-        new FareAttribute.Loader(feed, fares) {
+        new FixedFareAttributeLoader(feed, fares) {
             void load(String input){
                 reader = new CsvReader(new StringReader(input));
                 reader.setHeaders(new String[]{"fare_id","price","currency_type","payment_method","transfers","transfer_duration"});
diff --git a/reader-json/pom.xml b/reader-json/pom.xml
index ded5652871..e3288a3817 100644
--- a/reader-json/pom.xml
+++ b/reader-json/pom.xml
@@ -22,14 +22,15 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.google.code.gson</groupId>
-            <artifactId>gson</artifactId>
-            <version>2.8.0</version>
-            <!-- in the future make implementation optional
-                 <scope>provided</scope>
-            -->
-        </dependency> 
-        
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.bedatadriven</groupId>
+            <artifactId>jackson-datatype-jts</artifactId>
+            <version>2.4</version>
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
diff --git a/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java b/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java
deleted file mode 100644
index a0dd19c174..0000000000
--- a/reader-json/src/main/java/com/graphhopper/json/FeatureJsonDeserializer.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import com.graphhopper.json.geo.*;
-import com.google.gson.*;
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.shapes.BBox;
-
-import java.lang.reflect.Type;
-import java.util.Map;
-import java.util.UUID;
-
-/**
- * This class makes reading the different geometry types possible for Gson.
- *
- * @author Peter Karich
- */
-public class FeatureJsonDeserializer implements JsonDeserializer<JsonFeature> {
-    @Override
-    public JsonFeature deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException {
-        try {
-            JsonObject obj = json.getAsJsonObject();
-            String id, strType = null;
-            Map<String, Object> properties = null;
-            BBox bbox = null;
-            Geometry geometry = null;
-
-            // TODO ensure uniqueness
-            if (obj.has("id"))
-                id = obj.get("id").getAsString();
-            else
-                id = UUID.randomUUID().toString();
-
-            if (obj.has("properties")) {
-                properties = context.deserialize(obj.get("properties"), Map.class);
-            }
-
-            if (obj.has("bbox"))
-                bbox = parseBBox(obj.get("bbox").getAsJsonArray());
-
-            if (obj.has("geometry")) {
-                JsonObject geometryJson = obj.get("geometry").getAsJsonObject();
-
-                if (geometryJson.has("coordinates")) {
-                    if (!geometryJson.has("type"))
-                        throw new IllegalArgumentException("No type for non-empty coordinates specified");
-
-                    strType = context.deserialize(geometryJson.get("type"), String.class);
-                    if ("Point".equals(strType)) {
-                        JsonArray arr = geometryJson.get("coordinates").getAsJsonArray();
-                        double lon = arr.get(0).getAsDouble();
-                        double lat = arr.get(1).getAsDouble();
-                        if (arr.size() == 3)
-                            geometry = new Point(lat, lon, arr.get(2).getAsDouble());
-                        else
-                            geometry = new Point(lat, lon);
-
-                    } else if ("MultiPoint".equals(strType)) {
-                        geometry = parseLineString(geometryJson);
-
-                    } else if ("LineString".equals(strType)) {
-                        geometry = parseLineString(geometryJson);
-
-                    } else if ("Polygon".equals(strType)) {
-                        geometry = parsePolygonString(geometryJson);
-                    } else if ("MultiPolygon".equals(strType)) {
-                        geometry = parsePolygonString(geometryJson);
-                    } else {
-                        throw new IllegalArgumentException("Coordinates type " + strType + " not yet supported");
-                    }
-                }
-            }
-
-            return new JsonFeature(id, strType, bbox, geometry, properties);
-
-        } catch (Exception ex) {
-            throw new JsonParseException("Problem parsing JSON feature " + json, ex);
-        }
-    }
-
-    LineString parseLineString(JsonObject geometry) {
-        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
-        boolean is3D = arr.size() == 0 || arr.get(0).getAsJsonArray().size() == 3;
-        LineString lineString = new LineString(arr.size(), is3D);
-
-        for (int i = 0; i < arr.size(); i++) {
-            JsonArray pointArr = arr.get(i).getAsJsonArray();
-            double lon = pointArr.get(0).getAsDouble();
-            double lat = pointArr.get(1).getAsDouble();
-            if (pointArr.size() == 3)
-                lineString.add(lat, lon, pointArr.get(2).getAsDouble());
-            else
-                lineString.add(lat, lon);
-        }
-        return lineString;
-    }
-
-    GeoJsonPolygon parsePolygonString(JsonObject geometry) {
-        JsonArray arr = geometry.get("coordinates").getAsJsonArray();
-        GeoJsonPolygon geoJsonPolygon = new GeoJsonPolygon();
-
-        if (geometry.get("type").getAsString().equals("Polygon")) {
-            geoJsonPolygon.addPolygon(parseSinglePolygonCoordinates(arr));
-        } else {
-            for (int i = 0; i < arr.size(); i++) {
-                geoJsonPolygon.addPolygon(parseSinglePolygonCoordinates(arr.get(i).getAsJsonArray()));
-            }
-        }
-        return geoJsonPolygon;
-    }
-
-    private Polygon parseSinglePolygonCoordinates(JsonArray arr) {
-        if (arr.size() == 0) {
-            throw new IllegalStateException("The passed Array should be of format: [[[coords1],[coords2],....[coordsN]]]");
-        }
-        /*
-         TODO We currently ignore holes/interior rings the spec defines:
-        For type "Polygon", the "coordinates" member must be an array of LinearRing coordinate arrays.
-        For Polygons with multiple rings, the first must be the exterior ring and any others must be
-        interior rings or holes.
-         */
-        JsonArray polygonArr = arr.get(0).getAsJsonArray();
-
-        double[] lats = new double[polygonArr.size()];
-        double[] lons = new double[polygonArr.size()];
-
-        for (int i = 0; i < polygonArr.size(); i++) {
-            JsonArray pointArr = polygonArr.get(i).getAsJsonArray();
-            lons[i] = pointArr.get(0).getAsDouble();
-            lats[i] = pointArr.get(1).getAsDouble();
-        }
-
-        return new Polygon(lats, lons);
-    }
-
-    private BBox parseBBox(JsonArray arr) {
-        // The value of the bbox member must be a 2*n array where n is the number of dimensions represented 
-        // in the contained geometries, with the lowest values for all axes followed by the highest values. 
-        // The axes order of a bbox follows the axes order of geometries => lon,lat,ele
-        if (arr.size() == 6) {
-            double minLon = arr.get(0).getAsDouble();
-            double minLat = arr.get(1).getAsDouble();
-            double minEle = arr.get(2).getAsDouble();
-
-            double maxLon = arr.get(3).getAsDouble();
-            double maxLat = arr.get(4).getAsDouble();
-            double maxEle = arr.get(5).getAsDouble();
-
-            return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle);
-
-        } else if (arr.size() == 4) {
-            double minLon = arr.get(0).getAsDouble();
-            double minLat = arr.get(1).getAsDouble();
-
-            double maxLon = arr.get(2).getAsDouble();
-            double maxLat = arr.get(3).getAsDouble();
-
-            return new BBox(minLon, maxLon, minLat, maxLat);
-        } else {
-            throw new IllegalArgumentException("Illegal array dimension (" + arr.size() + ") of bbox " + arr.toString());
-        }
-    }
-}
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java
deleted file mode 100644
index dcd28becda..0000000000
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonBuilder.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import com.graphhopper.json.geo.JsonFeature;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-
-/**
- * This class wraps the creation of the specific GHJson implementation.
- *
- * @author Peter Karich
- */
-public class GHJsonBuilder {
-    public GHJson create() {
-        // for now always return Gson implementation        
-        Gson gson = new GsonBuilder()
-                .disableHtmlEscaping()
-                .registerTypeHierarchyAdapter(JsonFeature.class, new FeatureJsonDeserializer())
-                .create();
-        // for geojson we could rely on external libs instead of inventing our own:
-        // https://github.com/filosganga/geogson or https://github.com/3sidedcube/Android-GeoGson
-
-        return new GHJsonGson(gson);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/json/geo/Geometry.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/json/geo/Geometry.java
rename to reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
index 474f44fd3d..ef265e4adb 100644
--- a/core/src/main/java/com/graphhopper/json/geo/Geometry.java
+++ b/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
@@ -15,29 +15,20 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.json.geo;
+package com.graphhopper.json;
 
-import com.graphhopper.routing.util.spatialrules.Polygon;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
+import com.bedatadriven.jackson.datatype.jts.JtsModule;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
 /**
- * This interface is used to define an area or location in geojson format.
+ * This class wraps the creation of the specific GHJson implementation.
  *
  * @author Peter Karich
  */
-public interface Geometry {
-    String getType();
-
-    boolean isPoint();
-
-    GHPoint asPoint();
-
-    boolean isPointList();
-
-    PointList asPointList();
-
-    boolean isPolygon();
-
-    GeoJsonPolygon asPolygon();
+public class GHJsonFactory {
+    public GHJson create() {
+        ObjectMapper gson = new ObjectMapper();
+        gson.registerModule(new JtsModule());
+        return new GHJsonJackson(gson);
+    }
 }
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java b/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
similarity index 73%
rename from reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java
rename to reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
index 3714e3341a..83f621d97b 100644
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonGson.java
+++ b/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
@@ -17,22 +17,24 @@
  */
 package com.graphhopper.json;
 
-import com.google.gson.Gson;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
+import java.io.IOException;
 import java.io.Reader;
 
-/**
- * @author Peter Karich
- */
-public class GHJsonGson implements GHJson {
-    private final Gson gson;
+class GHJsonJackson implements GHJson {
+    private final ObjectMapper gson;
 
-    public GHJsonGson(Gson gson) {
+    GHJsonJackson(ObjectMapper gson) {
         this.gson = gson;
     }
 
     @Override
     public <T> T fromJson(Reader source, Class<T> aClass) {
-        return gson.fromJson(source, aClass);
+        try {
+            return gson.readValue(source, aClass);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 }
diff --git a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
index 76e9610970..96f8738cb2 100644
--- a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
+++ b/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
@@ -18,8 +18,10 @@
 package com.graphhopper.json.geo;
 
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.vividsolutions.jts.geom.LineString;
 import org.junit.Test;
 
 import java.io.InputStreamReader;
@@ -32,7 +34,7 @@
  * @author Peter Karich
  */
 public class JsonFeatureCollectionTest {
-    private final GHJson ghson = new GHJsonBuilder().create();
+    private final GHJson ghson = new GHJsonFactory().create();
 
     @Test
     public void testDeserialization() {
@@ -42,17 +44,17 @@ public void testDeserialization() {
         JsonFeature f1 = data.getFeatures().get(0);
         assertEquals("1", f1.getId());
         assertEquals("value0", f1.getProperty("prop0"));
-        assertEquals(0.5, f1.getGeometry().asPoint().lat, .1);
-        assertEquals(102.0, f1.getGeometry().asPoint().lon, .1);
+        assertEquals(0.5, f1.getGeometry().getCoordinate().y, .1);
+        assertEquals(102.0, f1.getGeometry().getCoordinate().x, .1);
 
         JsonFeature f2 = data.getFeatures().get(1);
         // read as string despite the 2 (not a string) in json
         assertEquals("2", f2.getId());
-        assertEquals(4, f2.getGeometry().asPointList().size());
-        assertEquals(0.0, f2.getGeometry().asPointList().getLat(0), .1);
-        assertEquals(102.0, f2.getGeometry().asPointList().getLon(0), .1);
-        assertEquals(1.0, f2.getGeometry().asPointList().getLat(1), .1);
-        assertEquals(103.0, f2.getGeometry().asPointList().getLon(1), .1);
+        assertEquals(4, f2.getGeometry().getNumPoints());
+        assertEquals(0.0, PointList.from((LineString) f2.getGeometry()).getLat(0), .1);
+        assertEquals(102.0, PointList.from((LineString) f2.getGeometry()).getLon(0), .1);
+        assertEquals(1.0, PointList.from((LineString) f2.getGeometry()).getLat(1), .1);
+        assertEquals(103.0, PointList.from((LineString) f2.getGeometry()).getLon(1), .1);
 
         JsonFeature f3 = data.getFeatures().get(2);
         assertEquals("0.0,102.0,1.0,103.0", f3.getBBox().toString());
diff --git a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index 5e786563e4..a3d9bade0a 100644
--- a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -1,7 +1,7 @@
 package com.graphhopper.storage.change;
 
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.JsonFeatureConverter;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.AllEdgesIterator;
@@ -34,7 +34,7 @@
     public void setUp() {
         encodingManager = new EncodingManager("car");
         graph = new GraphBuilder(encodingManager).create();
-        ghson = new GHJsonBuilder().create();
+        ghson = new GHJsonFactory().create();
     }
 
     @Test
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 13d95eb36d..dd15449bd1 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -303,6 +303,20 @@ public void testMonacoBike3D_twoSpeedsPerEdge() {
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testBug1014() {
+        List<OneRun> list = new ArrayList<>();
+        OneRun run = new OneRun();
+        run.add(50.016923, 11.514187, 0, 0);
+        run.add(50.019129, 11.500325, 0, 0);
+        run.add(50.023623, 11.56929, 7325, 176);
+        list.add(run);
+
+        runAlgo(testCollector, DIR + "/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike", true, "bike", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoBike() {
         List<OneRun> list = new ArrayList<OneRun>();
diff --git a/tools/pom.xml b/tools/pom.xml
index a67272987b..5e07a6f951 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -62,6 +62,15 @@
                         <descriptorRef>jar-with-dependencies</descriptorRef>
                     </descriptorRefs>
                 </configuration>
+                <executions>
+                    <execution>
+                        <id>make-assembly</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>single</goal>
+                        </goals>
+                    </execution>
+                </executions>
             </plugin>
         </plugins>
     </build>
diff --git a/web/pom.xml b/web/pom.xml
index 762ccc96b4..d43f920955 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -16,7 +16,7 @@
         <version>0.9-SNAPSHOT</version>
     </parent>
     <properties>
-        <jetty.version>9.3.8.v20160314</jetty.version>
+        <jetty.version>9.4.2.v20170220</jetty.version>
     </properties>
 
     <dependencies>
@@ -36,11 +36,7 @@
             <version>${project.parent.version}</version>
         </dependency>
 
-        <dependency>
-            <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>${json.org.version}</version>
-        </dependency>
+
         <dependency>
             <groupId>com.fasterxml.jackson.core</groupId>
             <artifactId>jackson-databind</artifactId>
@@ -55,14 +51,14 @@
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
-            <version>4.0</version>
+            <version>4.1.0</version>
         </dependency>
 
         <!-- necessary to use guice ('@Inject') in servlets -->
         <dependency>
             <groupId>com.google.inject.extensions</groupId>
             <artifactId>guice-servlet</artifactId>
-            <version>4.0</version>
+            <version>4.1.0</version>
         </dependency>
 
         <dependency>
@@ -129,15 +125,6 @@
                     <target>1.8</target>
                 </configuration>
             </plugin>
-            <!-- create a jar file too, so others can use it more easily -->
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-war-plugin</artifactId>
-                <version>3.0.0</version>
-                <configuration>
-                    <attachClasses>true</attachClasses>
-                </configuration>
-            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
@@ -168,8 +155,7 @@
                 <executions>
                     <execution>
                         <id>make-assembly</id>
-                        <!-- bind to verify and not package to pass integration tests before creating assemblies -->
-                        <phase>integration-test</phase>
+                        <phase>package</phase>
                         <goals>
                             <goal>single</goal>
                         </goals>
diff --git a/web/src/main/java/com/graphhopper/http/ChangeGraphServlet.java b/web/src/main/java/com/graphhopper/http/ChangeGraphServlet.java
index 5265940109..f8660dff48 100644
--- a/web/src/main/java/com/graphhopper/http/ChangeGraphServlet.java
+++ b/web/src/main/java/com/graphhopper/http/ChangeGraphServlet.java
@@ -17,22 +17,21 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.json.GHJson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.storage.change.ChangeGraphResponse;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 
-import java.io.IOException;
-import java.io.InputStreamReader;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-
-import org.json.JSONObject;
-import com.graphhopper.json.GHJson;
+import java.io.IOException;
+import java.io.InputStreamReader;
 
 /**
  * This class defines a new endpoint to submit access and speed changes to the graph.
@@ -60,7 +59,7 @@ protected void doPost(HttpServletRequest httpReq, HttpServletResponse httpRes) t
             }
             // TODO make asynchronous!
             ChangeGraphResponse rsp = ((GraphHopper) graphHopper).changeGraph(collection.getFeatures());
-            JSONObject resObject = new JSONObject();
+            ObjectNode resObject = objectMapper.createObjectNode();
             resObject.put("updates", rsp.getUpdateCount());
             // prepare the consumer to get some changes not immediately when returning after POST
             resObject.put("scheduled_updates", 0);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 2fbdaea6cc..482d1a4c3d 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -17,8 +17,13 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.fasterxml.jackson.databind.SerializationFeature;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.routing.util.HintsMap;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,55 +45,52 @@
  */
 public class GHBaseServlet extends HttpServlet {
     protected static final Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
+
+    @Inject
+    protected ObjectMapper objectMapper;
+
     @Inject
     @Named("jsonp_allowed")
     private boolean jsonpAllowed;
 
-    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JSONObject json) throws JSONException, IOException {
+    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JsonNode json) throws IOException {
         String type = getParam(req, "type", "json");
         res.setCharacterEncoding("UTF-8");
-        boolean debug = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
+        final boolean indent = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
+        ObjectWriter objectWriter = indent ? objectMapper.writer().with(SerializationFeature.INDENT_OUTPUT) : objectMapper.writer();
         if ("jsonp".equals(type)) {
             res.setContentType("application/javascript");
             if (!jsonpAllowed) {
                 writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
-
             String callbackName = getParam(req, "callback", null);
             if (callbackName == null) {
                 writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
 
-            if (debug)
-                writeResponse(res, callbackName + "(" + json.toString(2) + ")");
-            else
-                writeResponse(res, callbackName + "(" + json.toString(0) + ")");
-
+            writeResponse(res, callbackName + "(" + objectWriter.writeValueAsString(json) + ")");
         } else {
             res.setContentType("application/json");
-            if (debug)
-                writeResponse(res, json.toString(2));
-            else
-                writeResponse(res, json.toString(0));
+            writeResponse(res, objectWriter.writeValueAsString(json));
         }
     }
 
     protected void writeError(HttpServletResponse res, int code, String message) {
-        JSONObject json = new JSONObject();
+        ObjectNode json = objectMapper.createObjectNode();
         json.put("message", message);
         writeJsonError(res, code, json);
     }
 
-    protected void writeJsonError(HttpServletResponse res, int code, JSONObject json) {
+    protected void writeJsonError(HttpServletResponse res, int code, JsonNode json) {
         try {
             // no type parameter check here as jsonp does not work if an error
             // also no debug parameter yet
             res.setContentType("application/json");
             res.setCharacterEncoding("UTF-8");
             res.setStatus(code);
-            res.getWriter().append(json.toString(2));
+            res.getWriter().append(objectMapper.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(json));
         } catch (IOException ex) {
             throw new RuntimeException("Cannot write JSON Error " + code, ex);
         }
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index f404310643..51ece38ac3 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -19,10 +19,7 @@
 
 import com.google.inject.*;
 import com.google.inject.servlet.GuiceFilter;
-import com.google.inject.servlet.ServletModule;
 import com.graphhopper.GraphHopper;
-import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
@@ -30,17 +27,18 @@
 import org.eclipse.jetty.server.HttpConnectionFactory;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.ContextHandler;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
 import org.eclipse.jetty.server.handler.gzip.GzipHandler;
 import org.eclipse.jetty.servlet.FilterHolder;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
+import org.eclipse.jetty.util.resource.Resource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.servlet.*;
-import java.io.IOException;
 import java.util.EnumSet;
 
 /**
@@ -70,7 +68,12 @@ public void start(Injector injector) throws Exception {
         resHandler.setWelcomeFiles(new String[]{
                 "index.html"
         });
-        resHandler.setResourceBase(args.get("jetty.resourcebase", "./web/src/main/webapp"));
+        resHandler.setRedirectWelcome(false);
+
+        ContextHandler contextHandler = new ContextHandler();
+        contextHandler.setContextPath("/");
+        contextHandler.setBaseResource(Resource.newResource(args.get("jetty.resourcebase", "./web/src/main/webapp")));
+        contextHandler.setHandler(resHandler);
 
         server = new Server();
         // getSessionHandler and getSecurityHandler should always return null
@@ -78,10 +81,12 @@ public void start(Injector injector) throws Exception {
         servHandler.setErrorHandler(new GHErrorHandler());
         servHandler.setContextPath("/");
         servHandler.addServlet(new ServletHolder(new ShutDownRequestServlet(this)), "/shutdown/*");
-        servHandler.addServlet(new ServletHolder(new InvalidRequestServlet()), "/*");
+        // Putting this here (and not in the guice servlet module) because it should take precedence
+        // over more specific routes. And guice, strangely, is order-dependent (even though, except in the servlet
+        // extension, modules are _not_ supposed to be ordered).
+        servHandler.addServlet(new ServletHolder(injector.getInstance(InvalidRequestServlet.class)), "/*");
 
-        FilterHolder guiceFilter = new FilterHolder(injector.getInstance(GuiceFilter.class));
-        servHandler.addFilter(guiceFilter, "/*", EnumSet.allOf(DispatcherType.class));
+        servHandler.addFilter(new FilterHolder(new GuiceFilter()), "/*", EnumSet.allOf(DispatcherType.class));
 
         ServerConnector connector0 = new ServerConnector(server);
         int httpPort = args.getInt("jetty.port", 8989);
@@ -99,7 +104,7 @@ public void start(Injector injector) throws Exception {
 
         HandlerList handlers = new HandlerList();
         handlers.setHandlers(new Handler[]{
-                resHandler, servHandler
+                contextHandler, servHandler
         });
 
         GzipHandler gzipHandler = new GzipHandler();
@@ -109,6 +114,10 @@ public void start(Injector injector) throws Exception {
         // gzipHandler.setIncludedMimeTypes();
         gzipHandler.setHandler(handlers);
 
+        GraphHopperService graphHopper = injector.getInstance(GraphHopperService.class);
+        graphHopper.start();
+        createCallOnDestroyModule("AutoCloseable for GraphHopper", graphHopper);
+
         server.setHandler(gzipHandler);
         server.setStopAtShutdown(true);
         server.start();
@@ -120,58 +129,33 @@ protected Module createModule() {
             @Override
             protected void configure() {
                 binder().requireExplicitBindings();
-                if (args.has("gtfs.file")) {  // switch to different API implementation when using Pt
+
+                if (args.has("gtfs.file")) {
+                    // switch to different API implementation when using Pt
                     install(new PtModule(args));
-                    // Close resources on exit. Ugly, but neither guice nor guice-servlet have a lifecycle API,
-                    // so I have to abuse a Filter for that.
-                    install(new ServletModule() {
-                        @Override
-                        protected void configureServlets() {
-                            final Provider<GraphHopperStorage> graphHopperStorage = getProvider(GraphHopperStorage.class);
-                            final Provider<LocationIndex> locationIndex = getProvider(LocationIndex.class);
-                            filter("*").through(new Filter() {
-                                @Override
-                                public void init(FilterConfig filterConfig) throws ServletException {}
-                                @Override
-                                public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-                                    chain.doFilter(request, response);
-                                }
-                                @Override
-                                public void destroy() {
-                                    graphHopperStorage.get().close();
-                                    locationIndex.get().close();
-                                }
-                            });
-                        }
-                    });
                 } else {
-                    install(new DefaultModule(args));
-                    install(new ServletModule() {
-                        @Override
-                        protected void configureServlets() {
-                            final Provider<GraphHopper> graphHopper = getProvider(GraphHopper.class);
-                            filter("*").through(new Filter() {
-                                @Override
-                                public void init(FilterConfig filterConfig) throws ServletException {}
-                                @Override
-                                public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-                                    chain.doFilter(request, response);
-                                }
-                                @Override
-                                public void destroy() {
-                                    graphHopper.get().close();
-                                }
-                            });
-                        }
-                    });
+                    install(new GraphHopperModule(args));
                 }
-                install(new GHServletModule(args));
-
-                bind(GuiceFilter.class);
+                install(new GraphHopperServletModule(args));
             }
         };
     }
 
+    /**
+     * Close resources on exit
+     */
+    public final void createCallOnDestroyModule(String name, final AutoCloseable closeable) {
+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
+            try {
+                if (closeable != null)
+                    closeable.close();
+            } catch (Exception ex) {
+                if (logger != null)
+                    logger.error("Cannot close " + name + " (" + closeable + ")", ex);
+            }
+        }, name));
+    }
+
     public void stop() {
         if (server == null)
             return;
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
deleted file mode 100644
index bf71bd9e83..0000000000
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.http;
-
-import com.google.inject.servlet.ServletModule;
-import com.graphhopper.util.CmdArgs;
-
-import javax.inject.Singleton;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * @author Peter Karich
- */
-public class GHServletModule extends ServletModule {
-    protected final CmdArgs args;
-    protected Map<String, String> params = new HashMap<String, String>();
-
-    public GHServletModule(CmdArgs args) {
-        this.args = args;
-        params.put("mimeTypes", "text/html,"
-                + "text/plain,"
-                + "text/xml,"
-                + "application/xhtml+xml,"
-                + "application/gpx+xml,"
-                + "application/xml,"
-                + "text/css,"
-                + "application/json,"
-                + "application/javascript,"
-                + "image/svg+xml");
-    }
-
-    @Override
-    protected void configureServlets() {
-        filter("*").through(HeadFilter.class);
-        bind(HeadFilter.class).in(Singleton.class);
-
-        filter("*").through(CORSFilter.class, params);
-        bind(CORSFilter.class).in(Singleton.class);
-
-        filter("*").through(IPFilter.class);
-        bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
-
-        serve("/i18n*").with(I18NServlet.class);
-        bind(I18NServlet.class).in(Singleton.class);
-
-        serve("/info*").with(InfoServlet.class);
-        bind(InfoServlet.class).in(Singleton.class);
-
-        serve("/route*").with(GraphHopperServlet.class);
-        bind(GraphHopperServlet.class).in(Singleton.class);
-
-        serve("/nearest*").with(NearestServlet.class);
-        bind(NearestServlet.class).in(Singleton.class);
-
-        serve("/change*").with(ChangeGraphServlet.class);
-        bind(ChangeGraphServlet.class).in(Singleton.class);
-    }
-}
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
similarity index 53%
rename from web/src/main/java/com/graphhopper/http/DefaultModule.java
rename to web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index b5971b7aac..e317a7f85d 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -20,22 +20,27 @@
 import com.google.inject.AbstractModule;
 import com.google.inject.Provides;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.spatialrules.SpatialRuleLookupBuilder;
+import com.graphhopper.spatialrules.CountriesSpatialRuleFactory;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.lm.PrepareLandmarks;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FlagEncoderFactory;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
-import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
-import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.shapes.BBox;
@@ -48,20 +53,20 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.util.Arrays;
+import java.util.List;
 
-public class DefaultModule extends AbstractModule {
+public class GraphHopperModule extends AbstractModule {
     protected final CmdArgs args;
     private final Logger logger = LoggerFactory.getLogger(getClass());
 
-    public DefaultModule(CmdArgs args) {
+    public GraphHopperModule(CmdArgs args) {
         this.args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
     }
 
     @Override
     protected void configure() {
         install(new CmdArgsModule(args));
-        bind(GHJson.class).toInstance(new GHJsonBuilder().create());
+        bind(GHJson.class).toInstance(new GHJsonFactory().create());
         bind(GraphHopperAPI.class).to(GraphHopper.class);
     }
 
@@ -77,13 +82,24 @@ protected void loadOrPrepareLM() {
                 try {
                     String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
                     Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
-                    JsonFeatureCollection jsonFeatureCollection = new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class);
+                    JsonFeatureCollection jsonFeatureCollection = new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
                     if (!jsonFeatureCollection.getFeatures().isEmpty()) {
-                        SpatialRuleLookup ruleLookup = new SpatialRuleLookupBuilder().build("country",
-                                new SpatialRuleLookupBuilder.SpatialRuleDefaultFactory(), jsonFeatureCollection,
-                                getGraphHopperStorage().getBounds(), 0.1, true);
+                        SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "country", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
+                            @Override
+                            public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
+                                return new DefaultSpatialRule() {
+                                    @Override
+                                    public String getId() {
+                                        return id;
+                                    }
+                                };
+                            }
+                        });
                         for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
-                            prep.setSpatialRuleLookup(ruleLookup);
+                            // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
+                            if (ruleLookup != null && ruleLookup.size() > 0) {
+                                prep.setSpatialRuleLookup(ruleLookup);
+                            }
                         }
                     }
                 } catch (IOException ex) {
@@ -92,34 +108,33 @@ protected void loadOrPrepareLM() {
 
                 super.loadOrPrepareLM();
             }
-        }.forServer().init(args);
+        }.forServer();
+
+        String spatialRuleLocation = args.get("spatial_rules.location", "");
+        if (!spatialRuleLocation.isEmpty()) {
+            try {
+                final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
+                final FileReader reader = new FileReader(spatialRuleLocation);
+                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), maxBounds);
+                logger.info("Set spatial rule lookup with " + index.size() + " rules");
+                final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
+                graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
+                    @Override
+                    public FlagEncoder createFlagEncoder(String name, PMap configuration) {
+                        if (name.equals(GENERIC)) {
+                            return new DataFlagEncoder(configuration).setSpatialRuleLookup(index);
+                        }
 
-        String location = args.get("spatial_rules.location", "");
-        if (!location.isEmpty()) {
-            if (!graphHopper.getEncodingManager().supports(("generic"))) {
-                logger.warn("spatial_rules.location was specified but 'generic' encoder is missing to utilize the index");
-            } else
-                try {
-                    SpatialRuleLookup spatialRuleLookup = buildSpatialRuleLookup(new FileReader(location), graphHopper.getGraphHopperStorage().getBounds());
-                    logger.info("Set spatial rule lookup with " + spatialRuleLookup.size() + " rules");
-                    ((DataFlagEncoder) graphHopper.getEncodingManager().getEncoder("generic")).setSpatialRuleLookup(spatialRuleLookup);
-                } catch (IOException ex) {
-                    throw new RuntimeException(ex);
-                }
+                        return oldFEF.createFlagEncoder(name, configuration);
+                    }
+                });
+            } catch (IOException ex) {
+                throw new RuntimeException(ex);
+            }
         }
-        graphHopper.importOrLoad();
-        logger.info("loaded graph at:" + graphHopper.getGraphHopperLocation()
-                + ", data_reader_file:" + graphHopper.getDataReaderFile()
-                + ", flag_encoders:" + graphHopper.getEncodingManager()
-                + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
-        return graphHopper;
-    }
 
-    static SpatialRuleLookup buildSpatialRuleLookup(Reader reader, BBox graphBBox) {
-        GHJson ghJson = new GHJsonBuilder().create();
-        JsonFeatureCollection jsonFeatureCollection = ghJson.fromJson(reader, JsonFeatureCollection.class);
-        return new SpatialRuleLookupBuilder().build(Arrays.asList(new GermanySpatialRule(), new AustriaSpatialRule()),
-                jsonFeatureCollection, graphBBox, 1, true);
+        graphHopper.init(args);
+        return graphHopper;
     }
 
     @Provides
@@ -159,4 +174,24 @@ boolean hasElevation(GraphHopper graphHopper) {
         return graphHopper.hasElevation();
     }
 
+    @Provides
+    GraphHopperService getGraphHopperService(GraphHopper graphHopper) {
+        return new GraphHopperService() {
+            @Override
+            public void start() {
+                graphHopper.importOrLoad();
+                logger.info("loaded graph at:" + graphHopper.getGraphHopperLocation()
+                        + ", data_reader_file:" + graphHopper.getDataReaderFile()
+                        + ", flag_encoders:" + graphHopper.getEncodingManager()
+                        + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
+
+            }
+
+            @Override
+            public void close() throws Exception {
+                graphHopper.close();
+            }
+        };
+    }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperService.java b/web/src/main/java/com/graphhopper/http/GraphHopperService.java
new file mode 100644
index 0000000000..982287133d
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperService.java
@@ -0,0 +1,25 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+interface GraphHopperService extends AutoCloseable {
+
+    void start();
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index cbe1f3a5be..2b861afa72 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -17,14 +17,16 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.*;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.HintsMap;
 import static com.graphhopper.util.Parameters.Routing.*;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
-import org.json.JSONObject;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
@@ -87,6 +89,9 @@ public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throw
 
         if (!ghRsp.hasErrors()) {
             try {
+                if(requestPoints.isEmpty()){
+                    throw new IllegalArgumentException("You have to pass at least one point");
+                }
                 List<Double> favoredHeadings = Collections.EMPTY_LIST;
                 try {
                     favoredHeadings = getDoubleParamList(httpReq, "heading");
@@ -181,9 +186,9 @@ public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throw
                 ((Map) infoMap).put("took", Math.round(took * 1000));
 
             if (ghRsp.hasErrors())
-                writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+                writeJsonError(httpRes, SC_BAD_REQUEST, objectMapper.getNodeFactory().pojoNode(map));
             else {
-                writeJson(httpReq, httpRes, new JSONObject(map));
+                writeJson(httpReq, httpRes, objectMapper.getNodeFactory().pojoNode(map));
             }
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServletModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperServletModule.java
new file mode 100644
index 0000000000..ea65f31c5f
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServletModule.java
@@ -0,0 +1,124 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.bedatadriven.jackson.datatype.jts.JtsModule;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.BeanDescription;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.SerializationConfig;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
+import com.fasterxml.jackson.databind.util.ISO8601DateFormat;
+import com.google.inject.Provides;
+import com.google.inject.servlet.ServletModule;
+import com.graphhopper.util.CmdArgs;
+
+import javax.inject.Singleton;
+import java.text.SimpleDateFormat;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperServletModule extends ServletModule {
+    protected final CmdArgs args;
+    protected Map<String, String> params = new HashMap<String, String>();
+
+    public GraphHopperServletModule(CmdArgs args) {
+        this.args = args;
+        params.put("mimeTypes", "text/html,"
+                + "text/plain,"
+                + "text/xml,"
+                + "application/xhtml+xml,"
+                + "application/gpx+xml,"
+                + "application/xml,"
+                + "text/css,"
+                + "application/json,"
+                + "application/javascript,"
+                + "image/svg+xml");
+    }
+
+    @Override
+    protected void configureServlets() {
+        filter("*").through(HeadFilter.class);
+        bind(HeadFilter.class).in(Singleton.class);
+
+        filter("*").through(CORSFilter.class, params);
+        bind(CORSFilter.class).in(Singleton.class);
+
+        filter("*").through(IPFilter.class);
+        bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+
+        serve("/i18n*").with(I18NServlet.class);
+        bind(I18NServlet.class).in(Singleton.class);
+
+        serve("/info*").with(InfoServlet.class);
+        bind(InfoServlet.class).in(Singleton.class);
+
+        serve("/route*").with(GraphHopperServlet.class);
+        bind(GraphHopperServlet.class).in(Singleton.class);
+
+        serve("/nearest*").with(NearestServlet.class);
+        bind(NearestServlet.class).in(Singleton.class);
+
+        if (args.getBool("web.change_graph.enabled", false)) {
+            serve("/change*").with(ChangeGraphServlet.class);
+            bind(ChangeGraphServlet.class).in(Singleton.class);
+        }
+
+        // Can't do this because otherwise we can't add more paths _after_ this module.
+        // Instead, put this route explicitly into Jetty.
+        // (We really need a web service framework.)
+        // serve("/*").with(InvalidRequestServlet.class);
+        bind(InvalidRequestServlet.class).in(Singleton.class);
+    }
+
+    @Provides
+    @Singleton
+    ObjectMapper createObjectMapper() {
+        ObjectMapper objectMapper = new ObjectMapper();
+        objectMapper.setDateFormat(new ISO8601DateFormat());
+        objectMapper.registerModule(new JtsModule());
+
+        // Because VirtualEdgeIteratorState has getters which throw Exceptions.
+        // http://stackoverflow.com/questions/35359430/how-to-make-jackson-ignore-properties-if-the-getters-throw-exceptions
+        objectMapper.registerModule(new SimpleModule().setSerializerModifier(new BeanSerializerModifier() {
+            @Override
+            public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
+                return beanProperties.stream().map(bpw -> new BeanPropertyWriter(bpw) {
+                    @Override
+                    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
+                        try {
+                            super.serializeAsField(bean, gen, prov);
+                        } catch (Exception e) {
+                            // Ignoring expected exception, see above.
+                        }
+                    }
+                }).collect(Collectors.toList());
+            }
+        }));
+        return objectMapper;
+    }
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 575ec68083..3326ffea8f 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -17,29 +17,19 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.util.*;
-import com.graphhopper.util.exceptions.ConnectionNotFoundException;
-import com.graphhopper.util.exceptions.DetailedIllegalArgumentException;
-import com.graphhopper.util.exceptions.DetailedRuntimeException;
-import com.graphhopper.util.exceptions.PointNotFoundException;
-import com.graphhopper.util.exceptions.PointOutOfBoundsException;
+import com.graphhopper.util.exceptions.*;
 import com.graphhopper.util.shapes.GHPoint;
-import org.json.JSONArray;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
-import org.json.JSONException;
+import java.util.*;
+import java.util.Map.Entry;
 
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
@@ -48,6 +38,7 @@
  * @author Peter Karich
  */
 public class GraphHopperWeb implements GraphHopperAPI {
+    private ObjectMapper objectMapper;
     private final Set<String> ignoreSet;
     private Downloader downloader = new Downloader("GraphHopper Java Client");
     private String routeServiceUrl = "https://graphhopper.com/api/1/route";
@@ -58,7 +49,7 @@
     private boolean elevation = false;
     public GraphHopperWeb() {
         // some parameters are supported directly via Java API so ignore them when writing the getHints map
-        ignoreSet = new HashSet<String>();
+        ignoreSet = new HashSet<>();
         ignoreSet.add("calc_points");
         ignoreSet.add("calcpoints");
         ignoreSet.add("instructions");
@@ -75,41 +66,41 @@ public GraphHopperWeb() {
         ignoreSet.add("points_encoded");
         ignoreSet.add("pointsencoded");
         ignoreSet.add("type");
+        objectMapper = new ObjectMapper();
     }
 
-    public static PathWrapper createPathWrapper(JSONObject path,
-                                                boolean tmpCalcPoints, boolean tmpInstructions,
-                                                boolean tmpElevation, boolean turnDescription) {
+    private PathWrapper createPathWrapper(JsonNode path,
+                                                 boolean tmpCalcPoints, boolean tmpInstructions,
+                                                 boolean tmpElevation, boolean turnDescription) {
         PathWrapper pathWrapper = new PathWrapper();
         pathWrapper.addErrors(readErrors(path));
         if (pathWrapper.hasErrors())
             return pathWrapper;
 
         if (path.has("snapped_waypoints")) {
-            String snappedPointStr = path.getString("snapped_waypoints");
+            String snappedPointStr = path.get("snapped_waypoints").asText();
             PointList snappedPoints = WebHelper.decodePolyline(snappedPointStr, 5, tmpElevation);
             pathWrapper.setWaypoints(snappedPoints);
         }
 
         if (tmpCalcPoints) {
-            String pointStr = path.getString("points");
+            String pointStr = path.get("points").asText();
             PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
             pathWrapper.setPoints(pointList);
 
             if (tmpInstructions) {
-                JSONArray instrArr = path.getJSONArray("instructions");
+                JsonNode instrArr = path.get("instructions");
 
                 InstructionList il = new InstructionList(null);
                 int viaCount = 1;
-                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++) {
-                    JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
-                    double instDist = jsonObj.getDouble("distance");
-                    String text = turnDescription ? jsonObj.getString("text") : jsonObj.getString("street_name");
-                    long instTime = jsonObj.getLong("time");
-                    int sign = jsonObj.getInt("sign");
-                    JSONArray iv = jsonObj.getJSONArray("interval");
-                    int from = iv.getInt(0);
-                    int to = iv.getInt(1);
+                for (JsonNode jsonObj : instrArr) {
+                    double instDist = jsonObj.get("distance").asDouble();
+                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
+                    long instTime = jsonObj.get("time").asLong();
+                    int sign = jsonObj.get("sign").asInt();
+                    JsonNode iv = jsonObj.get("interval");
+                    int from = iv.get(0).asInt();
+                    int to = iv.get(1).asInt();
                     PointList instPL = new PointList(to - from, tmpElevation);
                     for (int j = from; j <= to; j++) {
                         instPL.add(pointList, j);
@@ -117,7 +108,6 @@ public static PathWrapper createPathWrapper(JSONObject path,
 
                     InstructionAnnotation ia = InstructionAnnotation.EMPTY;
                     if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
-                        ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"), 0, false);
                     }
 
                     Instruction instr;
@@ -125,12 +115,12 @@ public static PathWrapper createPathWrapper(JSONObject path,
                         RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
 
                         if (jsonObj.has("exit_number")) {
-                            ri.setExitNumber(jsonObj.getInt("exit_number"));
+                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
                         }
 
                         if (jsonObj.has("turn_angle")) {
                             // TODO provide setTurnAngle setter
-                            double angle = jsonObj.getDouble("turn_angle");
+                            double angle = jsonObj.get("turn_angle").asDouble();
                             ri.setDirOfRotation(angle);
                             ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
                         }
@@ -161,62 +151,38 @@ public static PathWrapper createPathWrapper(JSONObject path,
             }
         }
 
-        double distance = path.getDouble("distance");
-        long time = path.getLong("time");
+        double distance = path.get("distance").asDouble();
+        long time = path.get("time").asLong();
         pathWrapper.setDistance(distance).setTime(time);
         return pathWrapper;
     }
 
     // Credits to: http://stackoverflow.com/a/24012023/194609
-    private static Map<String, Object> toMap(JSONObject object) throws JSONException {
-        Map<String, Object> map = new HashMap<>(object.keySet().size());
-        for (String key : object.keySet()) {
-            Object value = object.get(key);
-            if (value instanceof JSONArray) {
-                value = toList((JSONArray) value);
-            } else if (value instanceof JSONObject) {
-                value = toMap((JSONObject) value);
-            }
-            map.put(key, value);
-        }
-        return map;
-    }
-
-    private static List<Object> toList(JSONArray array) throws JSONException {
-        List<Object> list = new ArrayList<>();
-        for (Object value : array) {
-            if (value instanceof JSONArray) {
-                value = toList((JSONArray) value);
-            } else if (value instanceof JSONObject) {
-                value = toMap((JSONObject) value);
-            }
-            list.add(value);
-        }
-        return list;
+    private Map<String, Object> toMap(JsonNode object) {
+        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {});
     }
 
-    public static List<Throwable> readErrors(JSONObject json) {
+    public List<Throwable> readErrors(JsonNode json) {
         List<Throwable> errors = new ArrayList<>();
-        JSONArray errorJson;
+        JsonNode errorJson;
 
         if (json.has("message")) {
             if (json.has("hints")) {
-                errorJson = json.getJSONArray("hints");
+                errorJson = json.get("hints");
             } else {
                 // should not happen
-                errors.add(new RuntimeException(json.getString("message")));
+                errors.add(new RuntimeException(json.get("message").asText()));
                 return errors;
             }
         } else
             return errors;
 
-        for (int i = 0; i < errorJson.length(); i++) {
-            JSONObject error = errorJson.getJSONObject(i);
+        for (JsonNode error : errorJson) {
             String exClass = "";
             if (error.has("details"))
-                exClass = error.getString("details");
+                exClass = error.get("details").asText();
 
-            String exMessage = error.getString("message");
+            String exMessage = error.get("message").asText();
 
             if (exClass.equals(UnsupportedOperationException.class.getName()))
                 errors.add(new UnsupportedOperationException(exMessage));
@@ -229,10 +195,10 @@ else if (exClass.equals(IllegalArgumentException.class.getName()))
             else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
                 errors.add(new ConnectionNotFoundException(exMessage, toMap(error)));
             } else if (exClass.equals(PointNotFoundException.class.getName())) {
-                int pointIndex = error.getInt("point_index");
+                int pointIndex = error.get("point_index").asInt();
                 errors.add(new PointNotFoundException(exMessage, pointIndex));
             } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
-                int pointIndex = error.getInt("point_index");
+                int pointIndex = error.get("point_index").asInt();
                 errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
             } else if (exClass.isEmpty())
                 errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
@@ -241,7 +207,7 @@ else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
         }
 
         if (json.has("message") && errors.isEmpty())
-            errors.add(new RuntimeException(json.getString("message")));
+            errors.add(new RuntimeException(json.get("message").asText()));
 
         return errors;
     }
@@ -328,16 +294,15 @@ public GHResponse route(GHRequest request) {
             }
 
             String str = downloader.downloadAsString(url, true);
-            JSONObject json = new JSONObject(str);
+            JsonNode json = objectMapper.reader().readTree(str);
 
             GHResponse res = new GHResponse();
             res.addErrors(readErrors(json));
             if (res.hasErrors())
                 return res;
 
-            JSONArray paths = json.getJSONArray("paths");
-            for (int index = 0; index < paths.length(); index++) {
-                JSONObject path = paths.getJSONObject(index);
+            JsonNode paths = json.get("paths");
+            for (JsonNode path : paths) {
                 PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation, tmpTurnDescription);
                 res.add(altRsp);
             }
diff --git a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
deleted file mode 100644
index e51d03f146..0000000000
--- a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.http;
-
-import com.google.inject.Guice;
-import com.google.inject.Injector;
-import com.google.inject.Module;
-import com.google.inject.servlet.GuiceServletContextListener;
-import com.graphhopper.util.CmdArgs;
-
-/**
- * Replacement of web.xml used only for container deployment. Preferred method is to use GHServer.
- * <p>
- * http://code.google.com/p/google-guice/wiki/ServletModule
- * <p>
- *
- * @author Peter Karich
- */
-public class GuiceServletConfig extends GuiceServletContextListener {
-    private final CmdArgs args;
-
-    public GuiceServletConfig() {
-        try {
-            args = CmdArgs.readFromConfig("config.properties", "graphhopper.config");
-        } catch (Exception ex) {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    @Override
-    protected Injector getInjector() {
-        return Guice.createInjector(createDefaultModule(), createServletModule());
-    }
-
-    protected Module createDefaultModule() {
-        return new DefaultModule(args);
-    }
-
-    protected Module createServletModule() {
-        return new GHServletModule(args);
-    }
-}
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index f8b655333a..6142e81bbe 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -17,10 +17,10 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Translation;
 import com.graphhopper.util.TranslationMap;
-import org.json.JSONObject;
 
 import javax.inject.Inject;
 import javax.servlet.ServletException;
@@ -51,12 +51,12 @@ public void doGet(HttpServletRequest req, HttpServletResponse res) throws Servle
         }
 
         Translation tr = map.get(locale);
-        JSONObject json = new JSONObject();
+        ObjectNode json = objectMapper.createObjectNode();
         if (tr != null && !Locale.US.equals(tr.getLocale()))
-            json.put("default", tr.asMap());
+            json.putPOJO("default", tr.asMap());
 
-        json.put("locale", locale.toString());
-        json.put("en", map.get("en").asMap());
+        json.put("locale", locale);
+        json.putPOJO("en", map.get("en").asMap());
         writeJson(req, res, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index b8043b5f7f..b2e24cae01 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -17,13 +17,14 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
-import org.json.JSONObject;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -44,7 +45,6 @@
     @Named("hasElevation")
     private boolean hasElevation;
 
-
     @Override
     public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
         BBox bb = storage.getBounds();
@@ -54,18 +54,17 @@ public void doGet(HttpServletRequest req, HttpServletResponse res) throws Servle
         list.add(bb.maxLon);
         list.add(bb.maxLat);
 
-        JSONObject json = new JSONObject();
-        json.put("bbox", list);
+        final JsonNodeFactory jsonNodeFactory = new JsonNodeFactory(false);
+        final ObjectNode json = jsonNodeFactory.objectNode();
+        json.putPOJO("bbox", list);
 
         String[] vehicles = storage.getEncodingManager().toString().split(",");
-        json.put("supported_vehicles", vehicles);
-        JSONObject features = new JSONObject();
+        json.putPOJO("supported_vehicles", vehicles);
+        ObjectNode features = json.putObject("features");
         for (String v : vehicles) {
-            JSONObject perVehicleJson = new JSONObject();
+            ObjectNode perVehicleJson = features.putObject(v);
             perVehicleJson.put("elevation", hasElevation);
-            features.put(v, perVehicleJson);
         }
-        json.put("features", features);
 
         json.put("version", Constants.VERSION);
         json.put("build_date", Constants.BUILD_DATE);
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index a047a3748f..5ff491f608 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -15,7 +15,7 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONObject;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
@@ -25,7 +25,7 @@
 public class InvalidRequestServlet extends GHBaseServlet {
     @Override
     protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-        JSONObject json = new JSONObject();
+        ObjectNode json = objectMapper.createObjectNode();
         json.put("message", "Not found");
         writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
     }
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
index e1332f6a64..e933c220ff 100644
--- a/web/src/main/java/com/graphhopper/http/NearestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -24,8 +26,6 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-import org.json.JSONArray;
-import org.json.JSONObject;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -50,7 +50,7 @@ public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throw
         String pointStr = getParam(httpReq, "point", null);
         boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
 
-        JSONObject result = new JSONObject();
+        ObjectNode result = objectMapper.createObjectNode();
         if (pointStr != null && !pointStr.equalsIgnoreCase("")) {
             GHPoint place = GHPoint.parse(pointStr);
             QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
@@ -61,14 +61,12 @@ public void doGet(HttpServletRequest httpReq, HttpServletResponse httpRes) throw
                 GHPoint3D snappedPoint = qr.getSnappedPoint();
                 result.put("type", "Point");
 
-                JSONArray coord = new JSONArray();
-                coord.put(snappedPoint.lon);
-                coord.put(snappedPoint.lat);
+                ArrayNode coord = result.putArray("coordinates");
+                coord.add(snappedPoint.lon);
+                coord.add(snappedPoint.lat);
 
                 if (hasElevation && enabledElevation)
-                    coord.put(snappedPoint.ele);
-
-                result.put("coordinates", coord);
+                    coord.add(snappedPoint.ele);
 
                 // Distance from input to snapped point in meters
                 result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
diff --git a/web/src/main/java/com/graphhopper/http/PtModule.java b/web/src/main/java/com/graphhopper/http/PtModule.java
index 718f97c8b4..3eac109084 100644
--- a/web/src/main/java/com/graphhopper/http/PtModule.java
+++ b/web/src/main/java/com/graphhopper/http/PtModule.java
@@ -4,7 +4,7 @@
 import com.google.inject.Provides;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
@@ -32,7 +32,7 @@ public PtModule(CmdArgs args) {
     @Override
     protected void configure() {
         install(new CmdArgsModule(args));
-        bind(GHJson.class).toInstance(new GHJsonBuilder().create());
+        bind(GHJson.class).toInstance(new GHJsonFactory().create());
     }
 
     @Provides
@@ -99,4 +99,20 @@ RouteSerializer getRouteSerializer(GraphHopperStorage storage) {
         return new SimpleRouteSerializer(storage.getBounds());
     }
 
+    @Provides
+    GraphHopperService getGraphHopperService(GraphHopperStorage storage, LocationIndex locationIndex) {
+        return new GraphHopperService() {
+            @Override
+            public void start() {
+
+            }
+
+            @Override
+            public void close() throws Exception {
+                storage.close();
+                locationIndex.close();
+            }
+        };
+    }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/ShutDownRequestServlet.java b/web/src/main/java/com/graphhopper/http/ShutDownRequestServlet.java
index 7bea18faf0..82b9e0ccb2 100644
--- a/web/src/main/java/com/graphhopper/http/ShutDownRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/ShutDownRequestServlet.java
@@ -15,7 +15,7 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONObject;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
@@ -32,7 +32,7 @@
     @Override
     protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
         logger.info("Shutdown request received from " + req.getRemoteAddr() + " : " + req.getRequestURL()+ " : " + req.getQueryString() );
-        JSONObject json = new JSONObject();
+        ObjectNode json = objectMapper.createObjectNode();
         if (!req.getRequestURI().equals("/shutdown")) {
            json.put("message", "Not found");
            writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
index f228f3ebc3..2498cb6fb8 100644
--- a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -17,16 +17,6 @@
  */
 package com.graphhopper.http;
 
-import com.bedatadriven.jackson.datatype.jts.JtsModule;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.type.TypeReference;
-import com.fasterxml.jackson.databind.BeanDescription;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.SerializationConfig;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
-import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.util.Helper;
@@ -34,43 +24,19 @@
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.exceptions.GHException;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.WayTypeInfo;
 
 import java.text.NumberFormat;
-import java.text.SimpleDateFormat;
-import java.util.*;
-import com.graphhopper.util.WayTypeInfo;
 import java.util.*;
-import java.util.stream.Collectors;
 
 /**
  * @author Peter Karich
  */
 public class SimpleRouteSerializer implements RouteSerializer {
     private final BBox maxBounds;
-    private final ObjectMapper objectMapper = new ObjectMapper();
 
     public SimpleRouteSerializer(BBox maxBounds) {
         this.maxBounds = maxBounds;
-        this.objectMapper.setDateFormat(new SimpleDateFormat("YYYY-MM-dd'T'HH:mm")); // ISO8601 without time zone
-        this.objectMapper.registerModule(new JtsModule());
-
-        // Because VirtualEdgeIteratorState has getters which throw Exceptions.
-        // http://stackoverflow.com/questions/35359430/how-to-make-jackson-ignore-properties-if-the-getters-throw-exceptions
-        this.objectMapper.registerModule(new SimpleModule().setSerializerModifier(new BeanSerializerModifier() {
-            @Override
-            public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
-                return beanProperties.stream().map(bpw -> new BeanPropertyWriter(bpw) {
-                    @Override
-                    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
-                        try {
-                            super.serializeAsField(bean, gen, prov);
-                        } catch (Exception e) {
-                            // Ignoring expected exception, see above.
-                        }
-                    }
-                }).collect(Collectors.toList());
-            }
-        }));
 
     }
 
@@ -134,7 +100,8 @@ private String getMessage(Throwable t) {
                         jsonPath.put("instructions", instructions.createJson());
                     }
 
-                    jsonPath.put("legs", objectMapper.convertValue(ar.getLegs(), new TypeReference<List<Map<String, Object>>>() {}));
+
+                    jsonPath.put("legs", ar.getLegs());
 
                     jsonPath.put("ascend", ar.getAscend());
                     jsonPath.put("descend", ar.getDescend());
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 4bc566a7be..656aeae1c2 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -18,9 +18,6 @@
 package com.graphhopper.http;
 
 import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
-import org.json.JSONArray;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
@@ -151,11 +148,4 @@ public static String readString(InputStream inputStream) throws IOException {
         }
     }
 
-    public static GHPoint toGHPoint(JSONArray point) {
-        if (point.length() == 3 && !Double.isNaN(point.getDouble(2))) {
-            return new GHPoint3D(point.getDouble(1), point.getDouble(0), point.getDouble(2));
-        }
-
-        return new GHPoint(point.getDouble(1), point.getDouble(0));
-    }
 }
diff --git a/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java b/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java
new file mode 100644
index 0000000000..9c34934934
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java
@@ -0,0 +1,26 @@
+package com.graphhopper.spatialrules;
+
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
+import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
+import com.graphhopper.spatialrules.SpatialRuleLookupBuilder;
+
+import java.util.List;
+
+public class CountriesSpatialRuleFactory implements SpatialRuleLookupBuilder.SpatialRuleFactory {
+    @Override
+    public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
+        switch (id) {
+            case "AUT":
+                AustriaSpatialRule austriaSpatialRule = new AustriaSpatialRule();
+                austriaSpatialRule.setBorders(polygons);
+                return austriaSpatialRule;
+            case "DEU":
+                GermanySpatialRule germanySpatialRule = new GermanySpatialRule();
+                germanySpatialRule.setBorders(polygons);
+                return germanySpatialRule;
+        }
+        return SpatialRule.EMPTY;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
new file mode 100644
index 0000000000..a0d387b164
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
@@ -0,0 +1,90 @@
+package com.graphhopper.spatialrules;
+
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupArray;
+import com.graphhopper.util.shapes.BBox;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
+
+public class SpatialRuleLookupBuilder {
+
+    public interface SpatialRuleFactory {
+        SpatialRule createSpatialRule(String id, final List<Polygon> polygons);
+    }
+
+    private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupBuilder.class);
+
+    /**
+     * Builds a SpatialRuleLookup by passing the provided JSON features into the provided
+     * SpatialRuleFactory and collecting all the SpatialRule instances that it returns,
+     * ignoring when it returns SpatialRule.EMPTY.
+     *
+     * See {@link SpatialRuleLookup} and {@link SpatialRule}.
+     *
+     * @param jsonFeatureCollection a feature collection
+     * @param jsonIdField the name of a property in that feature collection which serves as an id
+     * @param spatialRuleFactory a factory which is called with all the (id, geometry) pairs.
+     *                           It should provide a SpatialRule for each id it knows about,
+     *                           and SpatialRule.EMPTY otherwise.
+     * @param maxBBox limit the maximum BBox of the SpatialRuleLookup to the given BBox
+     * @return the fully constructed SpatialRuleLookup.
+     */
+    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory, BBox maxBBox) {
+        BBox polygonBounds = BBox.createInverse(false);
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
+            String id = (String) jsonFeature.getProperty(jsonIdField);
+            List<Polygon> borders = new ArrayList<>();
+            for (int i=0; i<jsonFeature.getGeometry().getNumGeometries(); i++) {
+                borders.add(ghPolygonFromJTS((com.vividsolutions.jts.geom.Polygon) jsonFeature.getGeometry().getGeometryN(i)));
+            }
+            SpatialRule spatialRule = spatialRuleFactory.createSpatialRule(id, borders);
+            if (spatialRule != SpatialRule.EMPTY) {
+                spatialRules.add(spatialRule);
+                for (Polygon polygon : spatialRule.getBorders()) {
+                    polygonBounds.update(polygon.getMinLat(), polygon.getMinLon());
+                    polygonBounds.update(polygon.getMaxLat(), polygon.getMaxLon());
+                }
+            }
+        }
+
+        if (!polygonBounds.isValid()) {
+            return SpatialRuleLookup.EMPTY;
+        }
+
+        BBox calculatedBounds = polygonBounds.calculateIntersection(maxBBox);
+        if (calculatedBounds == null)
+            return SpatialRuleLookup.EMPTY;
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 0.1, true, calculatedBounds);
+
+        logger.info("Created the SpatialRuleLookup with the following rules: " + Arrays.toString(spatialRules.toArray()));
+
+        return spatialRuleLookup;
+    }
+
+    /**
+     * Wrapper Method for {@link SpatialRuleLookupBuilder#buildIndex(JsonFeatureCollection, String, SpatialRuleFactory, BBox)}.
+     * This method simply passes a world-wide BBox, this won't limit the SpatialRuleLookup.
+     */
+    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory) {
+        return buildIndex(jsonFeatureCollection, jsonIdField, spatialRuleFactory, new BBox(-180, 180, -90, 90));
+    }
+
+    private static Polygon ghPolygonFromJTS(com.vividsolutions.jts.geom.Polygon polygon) {
+        double[] lats = new double[polygon.getNumPoints()];
+        double[] lons = new double[polygon.getNumPoints()];
+        for (int i=0; i<polygon.getNumPoints(); i++) {
+            lats[i] = polygon.getCoordinates()[i].y;
+            lons[i] = polygon.getCoordinates()[i].x;
+        }
+        return new Polygon(lats, lons);
+    }
+
+}
diff --git a/web/src/main/resources/com/graphhopper/http/README.MD b/web/src/main/resources/com/graphhopper/spatialrules/README.MD
similarity index 100%
rename from web/src/main/resources/com/graphhopper/http/README.MD
rename to web/src/main/resources/com/graphhopper/spatialrules/README.MD
diff --git a/web/src/main/resources/com/graphhopper/http/countries.geo.json b/web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
similarity index 100%
rename from web/src/main/resources/com/graphhopper/http/countries.geo.json
rename to web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
diff --git a/web/src/main/webapp/META-INF/context.xml b/web/src/main/webapp/META-INF/context.xml
deleted file mode 100644
index bc3aa8fadf..0000000000
--- a/web/src/main/webapp/META-INF/context.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<Context antiJARLocking="true" path="/gh"/>
diff --git a/web/src/main/webapp/WEB-INF/web.xml b/web/src/main/webapp/WEB-INF/web.xml
deleted file mode 100644
index 452f2c61f6..0000000000
--- a/web/src/main/webapp/WEB-INF/web.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
-    <display-name>GraphHopperWeb</display-name>
-    <filter>
-        <filter-name>guiceFilter</filter-name>
-        <filter-class>com.google.inject.servlet.GuiceFilter</filter-class>
-    </filter>
-    <filter-mapping>
-        <filter-name>guiceFilter</filter-name>        
-        <url-pattern>/*</url-pattern>
-    </filter-mapping>    
-    <listener>
-        <listener-class>com.graphhopper.http.GuiceServletConfig</listener-class>
-    </listener>
-    <session-config>
-        <session-timeout>1</session-timeout>
-    </session-config>            
-</web-app>
diff --git a/web/src/main/webapp/graphhopper/graphhopper-web-0.9-SNAPSHOT-with-dep.jar b/web/src/main/webapp/graphhopper/graphhopper-web-0.9-SNAPSHOT-with-dep.jar
index 309575f520..383bdd9a90 100644
Binary files a/web/src/main/webapp/graphhopper/graphhopper-web-0.9-SNAPSHOT-with-dep.jar and b/web/src/main/webapp/graphhopper/graphhopper-web-0.9-SNAPSHOT-with-dep.jar differ
diff --git a/web/src/main/webapp/js/config/tileLayers.js b/web/src/main/webapp/js/config/tileLayers.js
index 9775ee4da7..818ce3a4df 100644
--- a/web/src/main/webapp/js/config/tileLayers.js
+++ b/web/src/main/webapp/js/config/tileLayers.js
@@ -29,22 +29,28 @@ var openMapSurfer = L.tileLayer('http://korona.geog.uni-heidelberg.de/tiles/road
 //     attribution: osmAttr + ', <a href="https://www.mapbox.com/about/maps/">&copy; MapBox</a>'
 // });
 
-var sorbianLang = L.tileLayer('http://map.dgpsonline.eu/osmsb/{z}/{x}/{y}.png', {
+var sorbianLang = L.tileLayer('http://a.tile.openstreetmap.de/tiles/osmhrb/{z}/{x}/{y}.png', {
     attribution: osmAttr + ', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'
 });
 
 var thunderTransport = L.tileLayer('https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png' + tfAddition, {
-    attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>'
+    attribution: osmAttr + ', <a href="https://www.thunderforest.com/maps/transport/" target="_blank">Thunderforest Transport</a>'
 });
 
 var thunderCycle = L.tileLayer('https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png' + tfAddition, {
-    attribution: osmAttr + ', <a href="http://www.thunderforest.com/opencyclemap/" target="_blank">Thunderforest Cycle</a>'
+    attribution: osmAttr + ', <a href="https://www.thunderforest.com/maps/opencyclemap/" target="_blank">Thunderforest Cycle</a>'
 });
 
 var thunderOutdoors = L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png' + tfAddition, {
-    attribution: osmAttr + ', <a href="http://www.thunderforest.com/outdoors/" target="_blank">Thunderforest Outdoors</a>'
+    attribution: osmAttr + ', <a href="https://www.thunderforest.com/maps/outdoors/" target="_blank">Thunderforest Outdoors</a>'
 });
 
+var thunderNeighbourhood = L.tileLayer('https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png' + tfAddition, {
+    attribution: osmAttr + ', <a href="https://thunderforest.com/maps/neighbourhood/" target="_blank">Thunderforest Neighbourhood</a>'
+});
+
+https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png?apikey=<insert-your-apikey-here>
+
 var wrk = L.tileLayer('http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png', {
     attribution: osmAttr + ', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',
     subdomains: ['topo4', 'topo', 'topo2', 'topo3']
@@ -73,6 +79,7 @@ var availableTileLayers = {
     "TF Transport": thunderTransport,
     "TF Cycle": thunderCycle,
     "TF Outdoors": thunderOutdoors,
+    "TF Neighbourhood": thunderNeighbourhood,
     "Lyrk": lyrk,
     "WanderReitKarte": wrk,
     "OpenMapSurfer": openMapSurfer,
diff --git a/web/src/main/webapp/js/graphhopper/GHRoute.js b/web/src/main/webapp/js/graphhopper/GHRoute.js
index a507a207b2..3b290f83a1 100644
--- a/web/src/main/webapp/js/graphhopper/GHRoute.js
+++ b/web/src/main/webapp/js/graphhopper/GHRoute.js
@@ -27,6 +27,11 @@ GHroute.isArray = function (value) {
     return (stringValue.toLowerCase() === "[object array]");
 };
 
+GHroute.isObject = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object object]");
+};
+
 GHroute.prototype = {
     first: function () {
         return this.getIndex(0);
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index faefc1c83b..7e561d98af 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -17,29 +17,23 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Module;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
-
-import java.io.IOException;
-
-import org.json.JSONObject;
+import okhttp3.*;
+import org.eclipse.jetty.http.HttpStatus;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.concurrent.TimeUnit;
 
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import org.eclipse.jetty.http.HttpStatus;
-
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -53,6 +47,7 @@
     protected static int port;
     private static GHServer server;
     protected Injector injector;
+    private ObjectMapper objectMapper = new ObjectMapper();
 
     public static void shutdownJetty(boolean force) {
         // this is too slow so allow force == false. Then on setUpJetty a new server is created on a different port
@@ -87,7 +82,7 @@ private void bootJetty(CmdArgs args, int retryCount) {
         server = new GHServer(args);
 
         if (injector == null)
-            setUpGuice(new DefaultModule(args), new GHServletModule(args));
+            setUpGuice(server.createModule());
 
         for (int i = 0; i < retryCount; i++) {
             port = 18080 + i;
@@ -136,11 +131,11 @@ protected String queryString(String query, int code) throws Exception {
         return Helper.isToString(downloader.fetch(conn, true));
     }
 
-    protected JSONObject query(String query, int code) throws Exception {
-        return new JSONObject(queryString(query, code));
+    protected JsonNode query(String query, int code) throws Exception {
+        return objectMapper.readTree(queryString(query, code));
     }
 
-    protected JSONObject nearestQuery(String query) throws Exception {
+    protected JsonNode nearestQuery(String query) throws Exception {
         String resQuery = "";
         for (String q : query.split("\\&")) {
             int index = q.indexOf("=");
@@ -153,7 +148,7 @@ protected JSONObject nearestQuery(String query) throws Exception {
         }
         String url = getTestNearestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
-        return new JSONObject(downloader.downloadAsString(url, true));
+        return objectMapper.readTree(downloader.downloadAsString(url, true));
     }
 
     protected String post(String path, int expectedStatusCode, String xmlOrJson) throws IOException {
diff --git a/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java b/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
index 91b9ecd6e5..a5fa2036e8 100644
--- a/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/ChangeGraphServletIT.java
@@ -17,10 +17,11 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
-import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -46,6 +47,7 @@ public void setUp() {
         CmdArgs args = new CmdArgs().
                 put(Parameters.CH.PREPARE + "weightings", "no").
                 put("graph.flag_encoders", "car").
+                put("web.change_graph.enabled", "true").
                 put("graph.location", DIR).
                 put("datareader.file", "../core/files/andorra.osm.pbf");
         setUpJetty(args);
@@ -53,41 +55,42 @@ public void setUp() {
 
     @Test
     public void testBlockAccessViaPoint() throws Exception {
-        JSONObject json = query("point=42.531453,1.518946&point=42.511178,1.54006", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        final ObjectMapper objectMapper = new ObjectMapper();
+        JsonNode json = query("point=42.531453,1.518946&point=42.511178,1.54006", 200);
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        JsonNode path = json.get("paths").get(0);
         // System.out.println("\n\n1\n" + path);
-        double distance = path.getDouble("distance");
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 3000);
         assertTrue("distance wasn't correct:" + distance, distance < 3500);
 
         // block road
         String geoJson = "{"
-                + "'type': 'FeatureCollection',"
-                + "'features': [{"
-                + "  'type': 'Feature',"
-                + "  'geometry': {"
-                + "    'type': 'Point',"
-                + "    'coordinates': [1.521692, 42.522969]"
+                + "\"type\": \"FeatureCollection\","
+                + "\"features\": [{"
+                + "  \"type\": \"Feature\","
+                + "  \"geometry\": {"
+                + "    \"type\": \"Point\","
+                + "    \"coordinates\": [1.521692, 42.522969]"
                 + "  },"
-                + "  'properties': {"
-                + "    'vehicles': ['car'],"
-                + "    'access': false"
-                + "  }}]}".replaceAll("'", "\"");
+                + "  \"properties\": {"
+                + "    \"vehicles\": [\"car\"],"
+                + "    \"access\": false"
+                + "  }}]}";
         String res = post("/change", 200, geoJson);
-        JSONObject jsonObj = new JSONObject(res);
-        assertEquals(1, jsonObj.getInt("updates"));
+        JsonNode jsonObj = objectMapper.readTree(res);
+        assertEquals(1, jsonObj.get("updates").asInt());
 
         // route around blocked road => longer
         json = query("point=42.531453,1.518946&point=42.511178,1.54006", 200);
-        infoJson = json.getJSONObject("info");
+        infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        path = json.getJSONArray("paths").getJSONObject(0);
+        path = json.get("paths").get(0);
 
         // System.out.println("\n\n2\n" + path);
 
-        distance = path.getDouble("distance");
+        distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 5300);
         assertTrue("distance wasn't correct:" + distance, distance < 5800);
     }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 789506f5ed..83d9bb705d 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -17,23 +17,21 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
-import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.io.File;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 
 import static org.junit.Assert.*;
@@ -61,11 +59,11 @@ public void setUp() {
 
     @Test
     public void testBasicQuery() throws Exception {
-        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        JsonNode json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
-        double distance = path.getDouble("distance");
+        JsonNode path = json.get("paths").get(0);
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 9000);
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
@@ -73,11 +71,11 @@ public void testBasicQuery() throws Exception {
     @Test
     public void testQueryWithDirections() throws Exception {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
-        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240&ch.force_heading=true", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        JsonNode json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240&ch.force_heading=true", 200);
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
-        double distance = path.getDouble("distance");
+        JsonNode path = json.get("paths").get(0);
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 960);
         assertTrue("distance wasn't correct:" + distance, distance < 970);
     }
@@ -85,29 +83,29 @@ public void testQueryWithDirections() throws Exception {
     @Test
     public void testQueryWithStraightVia() throws Exception {
         // Note, in general specifying straightvia does not work with CH, but this is an example where it works
-        JSONObject json = query(
+        JsonNode json = query(
                 "point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
-        double distance = path.getDouble("distance");
+        JsonNode path = json.get("paths").get(0);
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 320);
         assertTrue("distance wasn't correct:" + distance, distance < 325);
     }
 
     @Test
     public void testJsonRounding() throws Exception {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
-        JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
+        JsonNode json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
+        JsonNode cson = json.get("paths").get(0).get("points");
         assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
 
     @Test
     public void testFailIfElevationRequestedButNotIncluded() throws Exception {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
+        JsonNode json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
         assertTrue(json.has("message"));
-        assertEquals("Elevation not supported!", json.get("message"));
-        assertEquals("Elevation not supported!", json.getJSONArray("hints").getJSONObject(0).getString("message"));
+        assertEquals("Elevation not supported!", json.get("message").asText());
+        assertEquals("Elevation not supported!", json.get("hints").get(0).get("message").asText());
     }
 
     @Test
@@ -218,4 +216,12 @@ public void testGPXWithError() throws Exception {
         assertTrue("Expected error but was: " + str, str.contains("<message>At least 2 points have to be specified, but was:1</message>"));
         assertTrue("Expected error but was: " + str, str.contains("<hints><error details=\"java"));
     }
+
+    @Test
+    public void testUndefinedPointHeading() throws Exception {
+        JsonNode json = query("point=undefined&heading=0", 400);
+        assertEquals("You have to pass at least one point", json.get("message").asText());
+        json = query("point=42.554851,1.536198&point=undefined&heading=0&heading=0", 400);
+        assertEquals("The number of 'heading' parameters must be <= 1 or equal to the number of points (1)", json.get("message").asText());
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index c868d6824e..c97b1735d0 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -17,10 +17,10 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
-import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -56,41 +56,41 @@ public void setUp() {
 
     @Test
     public void testElevation() throws Exception {
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        JsonNode json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
-        double distance = path.getDouble("distance");
+        JsonNode path = json.get("paths").get(0);
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 2500);
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
 
-        JSONObject cson = path.getJSONObject("points");
-        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+        JsonNode cson = path.get("points");
+        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66.0]"));
 
         // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
         // or reading with and without elevation would be too complex for the client with no real use
-        assertEquals(4, path.getJSONArray("bbox").length());
+        assertEquals(4, path.get("bbox").size());
     }
 
     @Test
     public void testNoElevation() throws Exception {
         // default is elevation=false
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
-        JSONObject infoJson = json.getJSONObject("info");
+        JsonNode json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
+        JsonNode infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
-        double distance = path.getDouble("distance");
+        JsonNode path = json.get("paths").get(0);
+        double distance = path.get("distance").asDouble();
         assertTrue("distance wasn't correct:" + distance, distance > 2500);
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
-        JSONObject cson = path.getJSONObject("points");
+        JsonNode cson = path.get("points");
         assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
 
         // disable elevation
         json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false", 200);
-        infoJson = json.getJSONObject("info");
+        infoJson = json.get("info");
         assertFalse(infoJson.has("errors"));
-        path = json.getJSONArray("paths").getJSONObject(0);
-        cson = path.getJSONObject("points");
+        path = json.get("paths").get(0);
+        cson = path.get("points");
         assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
index 1cdd7c6f57..5e60eba800 100644
--- a/web/src/test/java/com/graphhopper/http/NearestServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -17,10 +17,10 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-import org.json.JSONArray;
-import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -53,12 +53,12 @@ public void setUp() {
 
     @Test
     public void testBasicNearestQuery() throws Exception {
-        JSONObject json = nearestQuery("point=42.554851,1.536198");
+        JsonNode json = nearestQuery("point=42.554851,1.536198");
         assertFalse(json.has("error"));
-        JSONArray point = json.getJSONArray("coordinates");
-        assertTrue("returned point is not 2D: " + point, point.length() == 2);
-        double lon = point.getDouble(0);
-        double lat = point.getDouble(1);
+        ArrayNode point = (ArrayNode) json.get("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.size() == 2);
+        double lon = point.get(0).asDouble();
+        double lat = point.get(1).asDouble();
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 42.55483907636756 && lon == 1.5363742288086868);
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
index 2c3f03eb9b..a3ef83acae 100644
--- a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
-import org.json.JSONArray;
-import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -58,33 +58,33 @@ public void setUp() {
 
     @Test
     public void testWithEleQuery() throws Exception {
-        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=true");
+        JsonNode json = nearestQuery("point=43.730864,7.420771&elevation=true");
         assertFalse(json.has("error"));
-        JSONArray point = json.getJSONArray("coordinates");
-        assertTrue("returned point is not 3D: " + point, point.length() == 3);
-        double lon = point.getDouble(0);
-        double lat = point.getDouble(1);
-        double ele = point.getDouble(2);
+        ArrayNode point = (ArrayNode) json.get("coordinates");
+        assertTrue("returned point is not 3D: " + point, point.size() == 3);
+        double lon = point.get(0).asDouble();
+        double lat = point.get(1).asDouble();
+        double ele = point.get(2).asDouble();
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon + ", ele=" + ele, lat == 43.73070006215647 && lon == 7.421392181993846 && ele == 66.0);
     }
 
     @Test
     public void testWithoutEleQuery() throws Exception {
-        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=false");
+        JsonNode json = nearestQuery("point=43.730864,7.420771&elevation=false");
         assertFalse(json.has("error"));
-        JSONArray point = json.getJSONArray("coordinates");
-        assertTrue("returned point is not 2D: " + point, point.length() == 2);
-        double lon = point.getDouble(0);
-        double lat = point.getDouble(1);
+        ArrayNode point = (ArrayNode) json.get("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.size() == 2);
+        double lon = point.get(0).asDouble();
+        double lat = point.get(1).asDouble();
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
 
         // Default elevation is false        
         json = nearestQuery("point=43.730864,7.420771");
         assertFalse(json.has("error"));
-        point = json.getJSONArray("coordinates");
-        assertTrue("returned point is not 2D: " + point, point.length() == 2);
-        lon = point.getDouble(0);
-        lat = point.getDouble(1);
+        point = (ArrayNode) json.get("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.size() == 2);
+        lon = point.get(0).asDouble();
+        lat = point.get(1).asDouble();
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
similarity index 65%
rename from web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java
rename to web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
index c728c6ba8e..24f2fef903 100644
--- a/web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java
+++ b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -15,18 +15,23 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http;
+package com.graphhopper.spatialrules;
 
-import com.graphhopper.routing.util.spatialrules.*;
+import com.graphhopper.json.GHJsonFactory;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
+import com.graphhopper.routing.util.spatialrules.TransportationMode;
 import com.graphhopper.util.shapes.BBox;
 import org.junit.Test;
 
-import java.io.*;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 import static junit.framework.TestCase.assertFalse;
+import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 
 /**
  * @author Robin Boldt
@@ -35,8 +40,8 @@
 
     @Test
     public void testIndex() {
-        Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = DefaultModule.buildSpatialRuleLookup(reader, new BBox(-180, 180, -90, 90));
+        Reader reader = new InputStreamReader(CountriesSpatialRuleFactory.class.getResourceAsStream("countries.geo.json"));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
 
         // Berlin
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
@@ -55,7 +60,7 @@ public void testIndex() {
     @Test
     public void testBounds() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = DefaultModule.buildSpatialRuleLookup(reader, new BBox(-180, 180, -90, 90));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, 180, -90, 90));
         BBox almostWorldWide = new BBox(-179, 179, -89, 89);
 
         // Might fail if a polygon is defined outside the above coordinates
@@ -64,19 +69,21 @@ public void testBounds() {
 
     @Test
     public void testIntersection() {
-        /*
-            We are creating a BBox smaller than Germany. We have the German Spatial rule activated by default.
-            So the BBox should not contain a Point lying somewhere close in Germany.
-         */
+                /*
+             We are creating a BBox smaller than Germany. We have the German Spatial rule activated by default.
+             So the BBox should not contain a Point lying somewhere close in Germany.
+          */
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = DefaultModule.buildSpatialRuleLookup(reader, new BBox(9, 10, 51, 52));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(9, 10, 51, 52));
         assertFalse("BBox seems to be incorrectly contracted", spatialRuleLookup.getBounds().contains(49.9, 8.9));
     }
 
     @Test
     public void testNoIntersection() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = DefaultModule.buildSpatialRuleLookup(reader, new BBox(-180, -179, -90, -89));
-        assertNull(spatialRuleLookup);
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, -179, -90, -89));
+        assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
+
+
 }
diff --git a/web/src/test/webapp/spec/graphhopper/GHRequestSpec.js b/web/src/test/webapp/spec/graphhopper/GHRequestSpec.js
index e9ab1b9856..31daaab46e 100644
--- a/web/src/test/webapp/spec/graphhopper/GHRequestSpec.js
+++ b/web/src/test/webapp/spec/graphhopper/GHRequestSpec.js
@@ -55,5 +55,25 @@ describe("GHRequest", function () {
         expect(ghRequest.api_params.test).toEqual("x");
         expect(ghRequest.api_params.test_array).toEqual([1, 2]);
     });
+
+    it("create URL from object 'dot' notation should work", function () {
+        var ghRequest = new GHRequest("http://test.de?");
+        var params = { pt: { earliest_departure_time : 123}};
+        ghRequest.init(params);
+        expect(ghRequest.api_params.pt).toBeDefined();
+        expect(ghRequest.api_params.pt.earliest_departure_time).toEqual(123);
+    });
+
+    it("createPath should work", function () {
+        var ghRequest = new GHRequest("http://test.de?");
+        ghRequest.init({ pt: { earliest_departure_time : 123 }, key: ""});
+        expect("&locale=en&vehicle=car&weighting=fastest&elevation=false&key=&pt.earliest_departure_time=123").
+            toEqual(ghRequest.createPath(""));
+
+        ghRequest = new GHRequest("http://test.de?");
+        ghRequest.api_params.test = {ab: { xy: "12", z: "3"}};
+        expect("&locale=en&vehicle=car&weighting=fastest&elevation=false&key=undefined&test.ab.xy=12&test.ab.z=3").
+            toEqual(ghRequest.createPath(""));
+    });
 });
 
diff --git a/web/src/test/webapp/spec/tools/urlSpec.js b/web/src/test/webapp/spec/tools/urlSpec.js
index 2d613ce820..d54013302f 100644
--- a/web/src/test/webapp/spec/tools/urlSpec.js
+++ b/web/src/test/webapp/spec/tools/urlSpec.js
@@ -17,4 +17,25 @@ describe('urlTools', function () {
         params = urlTools.parseUrl("blup?point=&point=49.946505%2C11.571232");
         expect(params.point).toEqual(["", "49.946505,11.571232"]);
     });
+
+    it("should create object from dotted URL parameter", function () {
+        var someObject = urlTools.mergeParamIntoObject({}, "one.two", "12");
+        expect("12").toEqual(someObject.one.two);
+
+        someObject = urlTools.mergeParamIntoObject({"one": {"xy": "34"}}, "one.two", "12");
+        expect("12").toEqual(someObject.one.two);
+        expect("34").toEqual(someObject.one.xy);
+
+        someObject = urlTools.mergeParamIntoObject({}, "one.two.three", "123");
+        expect("123").toEqual(someObject.one.two.three);
+
+        var params = urlTools.parseUrl("localhost:8989?pt.test=now&pt.go.test=single&pt.go.further=far&pt.go.further=now");
+        expect("now").toEqual(params.pt.test);
+        expect("single").toEqual(params.pt.go.test);
+        expect(["far", "now"]).toEqual(params.pt.go.further);
+
+        // does not work at the moment: the second parameter is skipped
+        // params = urlTools.parseUrl("localhost:8989?pt.mix=now&pt.mix.test=now2");
+        // expect(["now", {"test" : "now2"}]).toEqual(params.pt.mix);
+    });
 });
