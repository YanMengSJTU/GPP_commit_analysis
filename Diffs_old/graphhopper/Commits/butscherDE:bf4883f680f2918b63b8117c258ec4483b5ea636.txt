diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 2c3babcbf4..d184c2b41e 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -182,6 +182,8 @@ public long getTime() {
         return time;
     }
 
+    public void setTime(final long time) { this.time = time;}
+
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 407025a19f..c6b1294cf9 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -745,6 +745,10 @@ private UnsupportedOperationException exc() {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
 
+    public Graph getMainGraph() {
+        return this.mainGraph;
+    }
+
     class QueryGraphTurnExt extends TurnCostExtension {
         private final TurnCostExtension mainTurnExtension;
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 3ea21b9f50..7ff93c4920 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -87,6 +87,7 @@ public boolean isReady(PathMerger pathMerger, Translation translation) {
         // TODO check if all waypoints have been queried. Respectively: The entry exit points: Are they queried? Do They have to be queried or mustnt they be queried?
         this.altResponse.setWaypoints(getWaypoints());
         this.ghResponse.add(this.altResponse);
+        System.out.println(this.pathList.get(0).getNodesInPathOrder().toString());
         pathMerger.doWork(this.altResponse, this.pathList, this.encodingManager, translation);
         return true;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
index fb13178f1d..acf543ba70 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
@@ -24,7 +24,7 @@ private void sortRouteCandidatesToDistanceInROIDescending() {
         Collections.sort(this.candidates, new Comparator<RouteCandidatePolygon>() {
             @Override
             public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
-                double distanceDifference = rc1.getDistanceInROI() - rc2.getDistanceInROI();
+                double distanceDifference = rc1.getTimeInROI() - rc2.getTimeInROI();
                 int output;
                 if (distanceDifference < 0) {
                     output = 1;
@@ -103,8 +103,8 @@ private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDo
     }
 
     private boolean isPruningCandidateDominated(RouteCandidatePolygon currentPruningCandidate, RouteCandidatePolygon possiblyBetterRouteCandidate) {
-        return possiblyBetterRouteCandidate.getDistance() < currentPruningCandidate.getDistance() &&
-               possiblyBetterRouteCandidate.getDistanceInROI() > currentPruningCandidate.getDistanceInROI();
+        return possiblyBetterRouteCandidate.getTime() < currentPruningCandidate.getTime() &&
+               possiblyBetterRouteCandidate.getTimeInROI() > currentPruningCandidate.getTimeInROI();
     }
 
     private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
index 11968ea137..f6cf68c7cb 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
@@ -1,7 +1,6 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonRoutingTemplate;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -29,6 +28,53 @@ public RouteCandidatePolygon(final int startNodeID, final int endNodeID, final i
         this.detourEntryToDetourExit = detourEntryToDetourExit;
         this.detourExitToEnd = detourExitToEnd;
         this.directRouteStartEnd = directRouteStartEnd;
+
+        if (startNodeID == 906161 || startNodeID == 270195
+            || endNodeID == 906161 || endNodeID == 270195
+            || polygonEntryNodeID == 906161 || polygonEntryNodeID == 270195
+            || polygonExitNodeID == 906161 || polygonExitNodeID == 270195) {
+            System.out.println("hit2");
+        }
+
+//        if (startToDetourEntry.getNodesInPathOrder().contains(906161) && startToDetourEntry.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit3");
+//        }
+//
+//        if (detourEntryToDetourExit.getNodesInPathOrder().contains(906161) && detourEntryToDetourExit.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit4");
+//        }
+//
+//        if (detourExitToEnd.getNodesInPathOrder().contains(906161) && detourExitToEnd.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit5");
+//        }
+//
+//        if (directRouteStartEnd.getNodesInPathOrder().contains(906161) && directRouteStartEnd.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit6");
+//        }
+//
+//        for (EdgeIteratorState state : startToDetourEntry.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit7");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : detourEntryToDetourExit.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit8");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : detourExitToEnd.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit9");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : directRouteStartEnd.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit10");
+//            }
+//        }
     }
 
     public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
@@ -51,8 +97,8 @@ private void mergePath(QueryGraph queryGraph, AlgorithmOptions algoOpts) {
         this.mergedPath = completePathCandidate;
     }
 
-    public double getDistance() {
-        return this.startToDetourEntry.getDistance() + this.detourEntryToDetourExit.getDistance() + this.detourExitToEnd.getDistance();
+    public double getTime() {
+        return this.startToDetourEntry.getTime() + this.detourEntryToDetourExit.getTime() + this.detourExitToEnd.getTime();
     }
 
     /**
@@ -60,29 +106,19 @@ public double getDistance() {
      *
      * @return The approximated time spent in the region of interest
      */
-    public double getDistanceInROI() {
-        return this.detourEntryToDetourExit.getDistance();
+    public double getTimeInROI() {
+        return this.detourEntryToDetourExit.getTime();
     }
 
     public double getGain() {
         // + 1 to avoid division by zero
-        return this.getDistanceInROI() / (this.getDetourDistance() + 1);
+        return this.getTimeInROI() / (this.getDetourTime() + 1);
     }
 
-    public double getDetourDistance() {
-        return this.getDistance() - this.directRouteStartEnd.getDistance();
+    public double getDetourTime() {
+        return this.getTime() - this.directRouteStartEnd.getTime();
     }
 
-    /**
-     * Uses the sweepline algorithm of Michael Ian Shamos and Dan Hoey to find intersecting line segments induced by the edges of the merged path.
-     * <p>
-     * Reference:
-     * Michael Ian Shamos and Dan Hoey. Geometric intersection problems. In Proceedings
-     * of the 17th Annual IEEE Symposium on Foundations of Computer Science
-     * (FOCS '76), pages 208{215, 1976.
-     *
-     * @return true if at least one intersection occurs and false otherwise.
-     */
     public boolean isDetourSelfIntersecting(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
         mergePathIfNotDone(queryGraph, algoOpts);
 
@@ -128,9 +164,9 @@ public String toString() {
                     "endNodeID: " + endNodeID + ", " +
                     "polygonEntryNodeID: " + polygonEntryNodeID + ", " +
                     "polygonExitNodeID: " + polygonExitNodeID + ", " +
-                    "Distance: " + this.getDistance() + ", " +
-                    "DistanceInROI: " + getDistanceInROI() + ", " +
-                    "detour distance: " + getDetourDistance() + ", " +
+                    "Distance: " + this.getTime() + ", " +
+                    "DistanceInROI: " + getTimeInROI() + ", " +
+                    "detour distance: " + getDetourTime() + ", " +
                     "gain: " + this.getGain();
         return sb;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index c2db769812..894ad80a00 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -89,7 +89,7 @@ public TestAlgoCollector assertDistance(EncodingManager encodingManager, AlgoHel
         PointList pointList = rsp.getPoints();
         double tmpDist = pointList.calcDistance(distCalc);
         if (Math.abs(rsp.getDistance() - tmpDist) > 2) {
-            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
+            errors.add(algoEntry + " path.getTime was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index a8bbe1c3ad..1603d559b8 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -483,6 +483,9 @@ public CHEdgeIteratorImpl(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter
 
         @Override
         public final IntsRef getFlags() {
+            if (edgeId == 17733429) {
+                System.out.println("hit");
+            }
             checkShortcut(false, "getFlags");
             return super.getFlags();
         }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index 0359dedba1..58fccbc618 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -25,7 +25,7 @@
  * <pre>
  * EdgeExplorer explorer = graph.createEdgeExplorer();
  * EdgeIterator iter = explorer.setBaseNode(nodeId);
- * // calls to iter.getAdjNode(), getDistance() without calling next() will cause undefined behaviour!
+ * // calls to iter.getAdjNode(), getTime() without calling next() will cause undefined behaviour!
  * while(iter.next()) {
  *   int baseNodeId = iter.getBaseNode(); // equal to nodeId
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 584dcbdf7d..1ad530120f 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -92,7 +92,7 @@ public static void updateDistancesFor(Graph g, int node, double lat, double lon)
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next()) {
             iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
-            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
+            // System.out.println(node + "->" + adj + ": " + iter.getTime());
         }
     }
 
@@ -472,7 +472,7 @@ public void testCreateAlgoTwice() {
         graph.edge(8, 6, 1, true);
 
         // run the same query twice, this can be interesting because in the second call algorithms that pre-process
-        // the graph might depend on the state of the graph after the first call 
+        // the graph might depend on the state of the graph after the first call
         Path p1 = createAlgo(graph).calcPath(0, 4);
         Path p2 = createAlgo(graph).calcPath(0, 4);
 
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
index c1024ba965..a867c38a22 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
@@ -125,35 +125,35 @@ private void illegalCandidateNotAdded(RouteCandidateMocker testingCandidate) {
     }
 
     class RouteCandidateMocker extends RouteCandidatePolygon {
-        final double polygonRouteDistance;
-        final double roiDistance;
-        final double directDistance;
+        final double polygonRouteTime;
+        final double roiTime;
+        final double directTime;
         final String name;
 
-        RouteCandidateMocker(final double polygonRouteDistance, final double distanceInROI, final double directDistance,
+        RouteCandidateMocker(final double polygonRouteTime, final double timeInRoi, final double directTime,
                              final String name, final Path startToDetourEntry, final Path detourEntryToDetourExit, final Path detourExitToEnd,
                              final Path directRouteStartEnd) {
             super(0, 3, 1, 2, startToDetourEntry, detourEntryToDetourExit, detourExitToEnd, directRouteStartEnd);
 
-            this.polygonRouteDistance = polygonRouteDistance;
-            this.roiDistance = distanceInROI;
-            this.directDistance = directDistance;
+            this.polygonRouteTime = polygonRouteTime;
+            this.roiTime = timeInRoi;
+            this.directTime = directTime;
             this.name = name;
         }
 
         @Override
-        public double getDistance() {
-            return this.polygonRouteDistance;
+        public double getTime() {
+            return this.polygonRouteTime;
         }
 
         @Override
-        public double getDistanceInROI() {
-            return this.roiDistance;
+        public double getTimeInROI() {
+            return this.roiTime;
         }
 
         @Override
-        public double getDetourDistance() {
-            return this.getDistance() - this.directDistance;
+        public double getDetourTime() {
+            return this.getTime() - this.directTime;
         }
 
         @Override
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
index 0828f5dbaa..bf1154547e 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
@@ -22,10 +22,10 @@
     public void testCorrectDistanceMetricsSmaller() {
         RouteCandidatePolygon testSmaller = setupSmallerRouteCandidate();
 
-        assertEquals(1, testSmaller.getDistanceInROI(), 0);
-        assertEquals(3, testSmaller.getDistance(), 0);
-        assertEquals(2, testSmaller.directRouteStartEnd.getDistance(), 0);
-        assertEquals(1, testSmaller.getDetourDistance(), 0);
+        assertEquals(1, testSmaller.getTimeInROI(), 0);
+        assertEquals(3, testSmaller.getTime(), 0);
+        assertEquals(2, testSmaller.directRouteStartEnd.getTime(), 0);
+        assertEquals(1, testSmaller.getDetourTime(), 0);
         assertEquals(0.5, testSmaller.getGain(), 0);
     }
 
@@ -33,10 +33,10 @@ public void testCorrectDistanceMetricsSmaller() {
     public void testCorrectDistanceMetricsGreater() {
         RouteCandidatePolygon testGreater = setupGreaterRouteCandidate();
 
-        assertEquals(2, testGreater.getDistanceInROI(), 0);
-        assertEquals(6, testGreater.getDistance(), 0);
-        assertEquals(5, testGreater.directRouteStartEnd.getDistance(), 0);
-        assertEquals(1, testGreater.getDetourDistance(), 0);
+        assertEquals(2, testGreater.getTimeInROI(), 0);
+        assertEquals(6, testGreater.getTime(), 0);
+        assertEquals(5, testGreater.directRouteStartEnd.getTime(), 0);
+        assertEquals(1, testGreater.getDetourTime(), 0);
         assertEquals(1, testGreater.getGain(), 0);
     }
 
@@ -73,24 +73,24 @@ private RouteCandidatePolygon setupGreaterRouteCandidate() {
         return test;
     }
 
-    private Path createTestSubPath(int edgeId, int endNode, int distance) {
+    private Path createTestSubPath(int edgeId, int endNode, int time) {
         Path startPolygon = new PathMerge(graphMocker.graph, graphMocker.weighting);
 
         startPolygon.addEdge(edgeId);
         startPolygon.setEndNode(endNode);
-        startPolygon.setDistance(distance);
+        startPolygon.setTime(time);
         startPolygon.setFound(true);
 
         return startPolygon;
     }
 
-    private Path createDirectRoute(int distance) {
+    private Path createDirectRoute(int time) {
         Path directRoute = new PathMerge(graphMocker.graph, graphMocker.weighting);
 
         directRoute.addEdge(3);
         directRoute.addEdge(8);
         directRoute.setEndNode(3);
-        directRoute.setDistance(distance);
+        directRoute.setTime(time);
         directRoute.setFound(true);
 
         return directRoute;
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 1ea121c3d8..e506778407 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -291,7 +291,7 @@ public void testMonacoFoot3D() {
     @Test
     public void testNorthBayreuthHikeFastestAnd3D() {
         List<OneRun> list = new ArrayList<>();
-        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
+        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'
         list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
         // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach' but avoid tertiary highway from Pechgraben
         list.add(new OneRun(49.990967, 11.545258, 50.023182, 11.555386, 5636, 97));
@@ -469,8 +469,8 @@ public void testAndorraFoot() {
     public void testCampoGrande() {
         // test not only NE quadrant of earth!
 
-        // bzcat campo-grande.osm.bz2 
-        //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=- 
+        // bzcat campo-grande.osm.bz2
+        //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=-
         //   | bzip2 > campo-grande.extracted.osm.bz2
         List<OneRun> list = new ArrayList<>();
         list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25516, 271));
@@ -560,7 +560,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
 
             if (osmFile.contains("krautsand"))
                 hopper.setMinNetworkSize(0, 0);
-            // avoid that path.getDistance is too different to path.getPoint.calcDistance
+            // avoid that path.getTime is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
             // always enable landmarks, add maximum information to reduce warnings
@@ -633,7 +633,7 @@ public void testMonacoParallel() throws IOException {
         int MAX = 100;
         final FlagEncoder carEncoder = encodingManager.getEncoder("car");
 
-        // testing if algorithms are independent. should be. so test only two algorithms. 
+        // testing if algorithms are independent. should be. so test only two algorithms.
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
         final Weighting weighting = new ShortestWeighting(encodingManager.getEncoder("car"));
