diff --git a/.gitignore b/.gitignore
index 06d6c5334a..ed71111a94 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,7 +4,6 @@ TODO.txt
 *-gh/
 *.osm
 nbactions*.xml
-config.properties
 build.xml
 queries.sh
 maven/
diff --git a/config.properties b/config.properties
new file mode 100644
index 0000000000..ce16dfe72b
--- /dev/null
+++ b/config.properties
@@ -0,0 +1,127 @@
+
+##### Vehicles #####
+
+
+# Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
+# bike2 takes elevation data into account (like up-hill is slower than down-hill) and requires enabling graph.elevation.provider below
+graph.flag_encoders=car|turn_costs=true
+
+index.max_region_search 
+# Enable turn restrictions for car or motorcycle. 
+# graph.flag_encoders=car|turn_costs=true
+
+
+##### Elevation #####
+
+
+# Per default GraphHopper doesn't use elevation data, you can enable elevation by setting graph.elevation.provider
+# to srtm, cgiar, gmted, srtmgl1, or multi. See the corresponding classes at com.graphhopper.reader.dem for more information.
+# graph.elevation.provider=srtm
+
+
+# default location for cache is /tmp/srtm
+# graph.elevation.cache_dir=./srtmprovider/
+
+
+# If you have a slow disk or plenty of RAM change the default MMAP to:
+# graph.elevation.dataaccess=RAM_STORE
+
+
+
+#### Speed, hybrid and flexible mode ####
+
+
+# By default the speed mode with the 'fastest' weighting is used. Internally a graph preparation via
+# contraction hierarchies (CH) is done to speed routing up. This requires more RAM/disc space for holding the
+# graph but less for every request. You can also setup multiple weightings, by providing a comma separated list.
+prepare.ch.weightings=fastest
+
+
+# Disable the speed mode. Should be used only with routing.max_visited_nodes or when the hybrid mode is enabled instead
+# prepare.ch.weightings=no
+
+
+# To make CH preparation faster for multiple flagEncoders you can increase the default threads if you have enough RAM.
+# Change this setting only if you know what you are doing and if the default worked for you.
+# prepare.ch.threads=1
+
+
+# The hybrid mode can be enabled with
+# prepare.lm.weightings=fastest
+
+# To tune the performance vs. memory usage for the hybrid mode use
+# prepare.lm.landmarks=16
+
+# Make landmark preparation parallel if you have enough RAM. Change this only if you know what you are doing and if the default worked for you.
+# prepare.lm.threads=1
+
+
+# avoid being stuck in a (oneway) subnetwork, see https://discuss.graphhopper.com/t/93
+prepare.min_network_size=200
+prepare.min_one_way_network_size=200
+
+
+
+##### Routing #####
+
+
+# You can define the maximum visited nodes when routing. This may result in not found connections if there is no
+# connection between two points within the given visited nodes. The default is Integer.MAX_VALUE. Useful for flexibility mode
+# routing.max_visited_nodes = 1000000
+
+
+# If enabled, allows a user to run flexibility requests even if speed mode is enabled. Every request then has to include a hint routing.ch.disable=true.
+# Attention, non-CH route calculations take way more time and resources, compared to CH routing.
+# A possible attacker might exploit this to slow down your service. Only enable it if you need it and with routing.maxVisitedNodes
+# routing.ch.disabling_allowed=true
+
+
+# If enabled, allows a user to run flexible mode requests even if the hybrid mode is enabled. Every such request then has to include a hint routing.lm.disable=true.
+# routing.lm.disabling_allowed=true
+
+# Control how many active landmarks are picked per default, this can improve query performance
+# routing.lm.active_landmarks=4
+
+
+# You can limit the max distance between two consecutive waypoints of flexible routing requests to be less or equal
+# the given distance in meter. Default is set to 1000km.
+routing.non_ch.max_waypoint_distance = 1000000
+
+
+
+##### Web #####
+
+
+# if you want to support jsonp response type you need to add it explicitly here. By default it is disabled for stronger security.
+# web.jsonp_allowed=true
+
+
+
+##### Storage #####
+
+
+# configure the memory access, use RAM_STORE for well equipped servers (default and recommended)
+graph.dataaccess=RAM_STORE
+
+
+# will write way names in the preferred language (language code as defined in ISO 639-1 or ISO 639-2):
+# datareader.preferred_language=en
+
+
+# Sort the graph after import to make requests roughly ~10% faster. Note that this requires significantly more RAM on import.
+# graph.do_sort=true
+
+
+
+##### Spatial Rules #####
+# Spatial Rules require some configuration and only work with the DataFlagEncoder.
+
+
+# Spatial Rules require you to provide Polygons in which the rules are enforced
+# The line below contains the default location for these rules
+# spatial_rules.location=core/files/spatialrules/countries.geo.json
+
+# You can define the maximum BBox for which spatial rules are loaded.
+# You might want to do this if you are only importing a small area and don't need rules for other countries.
+# Having less rules, might result in a smaller graph. The line below contains the world-wide bounding box, uncomment and adapt to your need.
+# spatial_rules.max_bbox=-180,180,-90,90
\ No newline at end of file
diff --git a/core/pom.xml b/core/pom.xml
index 5b12a99c6e..3215d84ca4 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -85,7 +85,12 @@
             <version>${log4j.version}</version>
             <scope>test</scope>
         </dependency>
-        
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>23.0</version>
+        </dependency>
+
     </dependencies>
 
     <build>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 4141dfeaa1..762a0ead34 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.Penalties.Penalty;
+import com.graphhopper.Penalties.TurnPenalty;
 import com.graphhopper.json.geo.JsonFeature;
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.dem.*;
@@ -924,6 +926,10 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
 
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
+        } else if ("weighting_with_penalties".equalsIgnoreCase(weightingStr)) {
+            Collection<Penalty> penalties = new ArrayList<>();
+            penalties.add(new TurnPenalty(hintsMap));
+            weighting = new WeightingWithPenalties(encoder, hintsMap, penalties);
         }
 
         if (weighting == null)
diff --git a/core/src/main/java/com/graphhopper/Penalties/MapConfigurations.java b/core/src/main/java/com/graphhopper/Penalties/MapConfigurations.java
new file mode 100644
index 0000000000..50312fe3e7
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/Penalties/MapConfigurations.java
@@ -0,0 +1,49 @@
+package com.graphhopper.Penalties;
+
+import com.google.common.collect.ImmutableList;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MapConfigurations {
+    public static final int RIGHT = 0, STRAIGHT = 1, LEFT = 2;
+
+    private static final double penaltyForTurnRight = 1;
+    private static final double penaltyForTurnLeft = 3;
+    private static final double penaltyForTrafficLights = 1.5;
+
+    private final static Map<String, Collection<Double>> penaltiesByMap = new HashMap<>();
+
+    private static final Collection<String> DRIVING_ON_THE_LEFT_SIDE = ImmutableList.of(
+            "au",/*Australia*/
+            "vg",/*Caribbean Islands*/
+            "gb",/*Channel Islands*/
+            "cy",/*Cyprus*/
+            "jp",/*Japan*/
+            "hk",/*Hong Kong*/
+            "in",/*India*/
+            "im",/*Isle of Man*/
+            "ie",/*Ireland*/
+            "jm",/*Jamaica*/
+            "ke",/*Kenya*/
+            "mt",/*Malta*/
+            "my",/*Malaysia*/
+            "nz",/*New Zealand*/
+            "sg",/*Singapore*/
+            "th",/*Thailand*/
+            "uk",
+            "South Africa");
+
+
+    public static Collection<Double> getTurnPenalties(String map) {
+        if (penaltiesByMap.containsKey(map))
+            return penaltiesByMap.get(map);
+
+        return DRIVING_ON_THE_LEFT_SIDE.contains(map)
+                        ?
+                        ImmutableList.of(penaltyForTurnLeft, penaltyForTrafficLights, penaltyForTurnRight)
+                        :
+                        ImmutableList.of(penaltyForTurnRight, penaltyForTrafficLights, penaltyForTurnLeft);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/Penalties/Penalty.java b/core/src/main/java/com/graphhopper/Penalties/Penalty.java
new file mode 100644
index 0000000000..cc5a457d3a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/Penalties/Penalty.java
@@ -0,0 +1,9 @@
+package com.graphhopper.Penalties;
+
+import com.graphhopper.WeightingWithPenalties;
+import com.graphhopper.util.EdgeIteratorState;
+
+public abstract class Penalty {
+
+    abstract public double getPenalty(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, WeightingWithPenalties.WayData from, WeightingWithPenalties.WayData to);
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/Penalties/TurnPenalty.java b/core/src/main/java/com/graphhopper/Penalties/TurnPenalty.java
new file mode 100644
index 0000000000..012b30a776
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/Penalties/TurnPenalty.java
@@ -0,0 +1,71 @@
+package com.graphhopper.Penalties;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.graphhopper.WeightingWithPenalties;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+
+import static com.graphhopper.Penalties.MapConfigurations.*;
+
+public class TurnPenalty extends Penalty {
+    final static double SLIGHT_TURN_FACTOR = .7;
+    final static double SHARP_TURN_FACTOR = 1.5;
+
+    private final double penaltyForTurnRight;
+    private final double penaltyForTurnLeft;
+    private final double penaltyForTrafficLights;
+
+    public TurnPenalty(HintsMap hintsMap) {
+        Object[] turnPenalties = MapConfigurations.getTurnPenalties(hintsMap.get("map", "")).toArray();
+        penaltyForTrafficLights = (Double) turnPenalties[STRAIGHT];
+        penaltyForTurnRight = (Double) turnPenalties[RIGHT];
+        penaltyForTurnLeft = (Double) turnPenalties[LEFT];
+    }
+
+    @VisibleForTesting
+    public TurnPenalty(double penaltyForTurnRight, double penaltyForTurnLeft, double penaltyForTrafficLights) {
+        this.penaltyForTurnRight = penaltyForTurnRight;
+        this.penaltyForTurnLeft = penaltyForTurnLeft;
+        this.penaltyForTrafficLights = penaltyForTrafficLights;
+    }
+
+    public double getPenalty(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId, WeightingWithPenalties.WayData from, WeightingWithPenalties.WayData to) {
+        if (from != null && to != null) {
+            return calculatePenalty(from, to);
+        }
+        return 0;
+    }
+
+    private double calculatePenalty(WeightingWithPenalties.WayData from, WeightingWithPenalties.WayData to) {
+        double prevOrientation = Helper.ANGLE_CALC.calcOrientation(from.firstWayPointLat, from.firstWayPointLng, from.lastWayPointLat, from.lastWayPointLng, false);
+        double orientation = Helper.ANGLE_CALC.calcOrientation(to.firstWayPointLat, to.firstWayPointLng, to.lastWayPointLat, to.lastWayPointLng, false);
+
+        double delta = Helper.ANGLE_CALC.alignOrientation(prevOrientation, orientation) - prevOrientation;
+        double absDelta = Math.abs(delta);
+
+        double penalty;
+        if (absDelta < 0.2) { // 0.2 ~= 11° CONTINUE_ON_STREET
+            penalty = penaltyForTrafficLights;
+        } else if (absDelta < 0.8) { // 0.8 ~= 40° TURN_SLIGHT
+            if (delta > 0) {
+                penalty = penaltyForTurnLeft * SLIGHT_TURN_FACTOR;
+            } else {
+                penalty = penaltyForTurnRight * SLIGHT_TURN_FACTOR;
+            }
+        }  else if (absDelta < 1.8) { // 1.8 ~= 103° //TURN
+            if (delta > 0) {
+                penalty = penaltyForTurnLeft;
+            } else {
+                penalty = penaltyForTurnRight;
+            }
+        } else { //TURN_SHARP
+            if (delta > 0) {
+                penalty = penaltyForTurnLeft * SHARP_TURN_FACTOR;
+            } else {
+                penalty = penaltyForTurnRight * SHARP_TURN_FACTOR;
+            }
+        }
+        return penalty;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/WeightingWithPenalties.java b/core/src/main/java/com/graphhopper/WeightingWithPenalties.java
new file mode 100644
index 0000000000..e1b540df6a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/WeightingWithPenalties.java
@@ -0,0 +1,131 @@
+package com.graphhopper;
+
+import com.graphhopper.Penalties.Penalty;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.PointList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public class WeightingWithPenalties extends FastestWeighting {
+    /**
+     * Converting to seconds is not necessary but makes adding other penalties easier (e.g. turn
+     * costs or traffic light costs etc)
+     * speed is in km / hr
+     * distance is in meters convert it to km    ->   / 1000
+     * so time is in hours -> convert it to sec  ->   * 60 * 60
+     */
+    private final static double SPEED_CONV = 3.6;
+    private static final int MIN_TO_SEC = 60;
+    private final double headingPenalty;
+    private final long headingPenaltySec;
+    private final Map<Integer, WayData> visitedEdgesCoordinates = new HashMap<>();
+    private final Collection<Penalty> penalties;
+    private static final Logger logger = LoggerFactory.getLogger(WeightingWithPenalties.class);
+
+
+    public WeightingWithPenalties(FlagEncoder encoder, HintsMap hintsMap, Collection<Penalty> penalties) {
+        super(encoder);
+        this.headingPenalty = hintsMap.getDouble(Parameters.Routing.HEADING_PENALTY, Parameters.Routing.DEFAULT_HEADING_PENALTY);
+        this.penalties = penalties;
+        headingPenaltySec = Math.round(headingPenalty);
+    }
+
+    /**
+     * This method calculates the weighting a certain edgeState should be associated. E.g. a high
+     * value indicates that the edge should be avoided. Make sure that this method is very fast and
+     * optimized as this is called potentially millions of times for one route or a lot more for
+     * nearly any preprocessing phase.
+     *
+     * @param edge             the edge for which the weight should be calculated
+     * @param reverse          if the specified edge is specified in reverse direction e.g. from the reverse
+     *                         case of a bidirectional search.
+     * @param prevOrNextEdgeId if reverse is false this has to be the previous edgeId, if true it
+     *                         has to be the next edgeId in the direction from start to end.
+     * @return the calculated weight with the specified velocity has to be in the range of 0 and
+     * +Infinity. Make sure your method does not return NaN which can e.g. occur for 0/0.
+     */
+    @Override
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        long flags = edge.getFlags();
+
+        double speed = reverse ? super.flagEncoder.getReverseSpeed(flags) : super.flagEncoder.getSpeed(flags);// km/h
+        if (speed == 0) {
+            return Double.POSITIVE_INFINITY;
+        }
+
+        double distance = edge.getDistance(); //in meters
+        double time = distance / speed * SPEED_CONV; //sec
+
+        boolean unfavoredEdge = edge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge) {
+            time += headingPenalty;
+        }
+
+        return time + updateVisitedEdgesAndGetPenalty(edge, reverse, prevOrNextEdgeId);
+    }
+
+    @Override
+    public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        long time = 0;
+        boolean unfavoredEdge = edgeState.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge) {
+            time += headingPenaltySec * 1000;
+        }
+
+        final double penalty = updateVisitedEdgesAndGetPenalty(edgeState, reverse, prevOrNextEdgeId) * 1000;
+        return (long) (time + penalty + super.calcMillis(edgeState, reverse, prevOrNextEdgeId));
+    }
+
+    @Override
+    public String getName() {
+        return "weighting_with_penalties";
+    }
+
+
+    public static final class WayData {
+        public final double firstWayPointLat;
+        public final double firstWayPointLng;
+        public final double lastWayPointLat;
+        public final double lastWayPointLng;
+
+        public WayData(double firstWayPointLat, double firstWayPointLng, double lastWayPointLat, double lastWayPointLng) {
+            this.firstWayPointLat = firstWayPointLat;
+            this.firstWayPointLng = firstWayPointLng;
+            this.lastWayPointLat = lastWayPointLat;
+            this.lastWayPointLng = lastWayPointLng;
+        }
+    }
+
+    private double updateVisitedEdgesAndGetPenalty(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+
+        PointList pointList = edge.fetchWayGeometry(3);
+        WayData wayData = new WayData(
+                pointList.getLat(0),
+                pointList.getLon(0),
+                pointList.getLat(pointList.size() - 1),
+                pointList.getLon(pointList.size() - 1));
+        visitedEdgesCoordinates.put(edge.getEdge(), wayData);
+        WayData prevWayData;
+        if (reverse) { //if reverse is true prevOrNextEdgeId has to be the next edgeId in the direction from start to end.
+            prevWayData = wayData;
+            wayData = visitedEdgesCoordinates.get(prevOrNextEdgeId);
+        } else {
+            prevWayData = visitedEdgesCoordinates.get(prevOrNextEdgeId);
+        }
+
+        double penaltyCost = .0;
+        for (Penalty penalty : penalties) {
+            penaltyCost += penalty.getPenalty(edge, reverse, prevOrNextEdgeId, prevWayData, wayData);
+        }
+        return penaltyCost;
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/Penalties/TurnPenaltyTest.java b/core/src/test/java/com/graphhopper/Penalties/TurnPenaltyTest.java
new file mode 100644
index 0000000000..e9e92d5fec
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/Penalties/TurnPenaltyTest.java
@@ -0,0 +1,66 @@
+package com.graphhopper.Penalties;
+
+import com.graphhopper.WeightingWithPenalties;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Test;
+
+import java.util.Random;
+
+import static com.graphhopper.Penalties.TurnPenalty.SHARP_TURN_FACTOR;
+import static com.graphhopper.Penalties.TurnPenalty.SLIGHT_TURN_FACTOR;
+import static org.junit.Assert.*;
+
+public class TurnPenaltyTest {
+    Random random = new Random();
+    double penaltyTurnRight = random.nextDouble();
+    double penaltyTurnLeft = random.nextDouble();
+    double penaltyStraight = random.nextDouble();
+
+    TurnPenalty turnPenalty = new TurnPenalty(penaltyTurnRight, penaltyTurnLeft, penaltyStraight);
+    EdgeIteratorState edge = null;
+    boolean reverse = false;
+    int prevOrNextEdgeId = random.nextInt();
+
+    @Test
+    public void calculateSignRight() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.116391, 34.817488, 32.118253, 34.818363);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.118266, 34.818477, 32.117267, 34.820775);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnRight, 0.01);
+    }
+    @Test
+    public void calculateSignLeft() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.118266, 34.818477, 32.117267, 34.820775);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.116391, 34.817488, 32.118253, 34.818363);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnLeft, 0.01);
+    }
+    @Test
+    public void calculateSignSlightRight() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.116700, 34.817617, 32.117319, 34.817891);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.117342, 34.817945, 32.117731, 34.818230);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnRight * SLIGHT_TURN_FACTOR, 0.01);
+    }
+    @Test
+    public void calculateSignSlightLeft() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.123799, 34.812758, 32.123837, 34.811917);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.123836, 34.811879, 32.123738, 34.811667);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnLeft * SLIGHT_TURN_FACTOR, 0.01);
+    }
+    @Test
+    public void calculateSignSharpRight() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.124639, 34.812672, 32.124713, 34.812428);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.124755, 34.812483, 32.124728, 34.813218);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnRight * SHARP_TURN_FACTOR, 0.01);
+    }
+    @Test
+    public void calculateSignSharpLeft() {
+        WeightingWithPenalties.WayData wayDataFrom = new WeightingWithPenalties.WayData(32.124728, 34.813218, 32.124755, 34.812483);
+        WeightingWithPenalties.WayData wayDataTo = new WeightingWithPenalties.WayData(32.124713, 34.812428, 32.124639, 34.812672);
+        double penalty = turnPenalty.getPenalty(edge, reverse, prevOrNextEdgeId, wayDataFrom, wayDataTo);
+        assertEquals(penalty, penaltyTurnLeft * SHARP_TURN_FACTOR, 0.01);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index 76998138a8..6805f9482f 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -17,8 +17,14 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.BBox;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -126,4 +132,5 @@ public void testEnsureCapacity() throws IOException {
         // A new segment should be added, which will support 128 / 16 = 8 more entries.
         assertEquals(112, turnCostStorage.getCapacity() / 16);
     }
+
 }
