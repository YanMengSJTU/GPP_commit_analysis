diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
index 2ecb0f735c..ab20422475 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
@@ -162,18 +162,27 @@ public long getTotalRouteTime() {
 	}
 
 	public String getErrorMessage() {
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		
+		JsonObject error= jObject.getAsJsonObject("error");
+	//	JsonArray errors = info.getAsJsonArray("errors");
+		//JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		//		.getAsJsonPrimitive("message");
+		JsonPrimitive errorMessage = error.getAsJsonObject()
 				.getAsJsonPrimitive("message");
 		return errorMessage.getAsString();
 
 	}
 
 	public int getStatusCode() {
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
-				.getAsJsonPrimitive("statuscode");
-		return errorMessage.getAsInt();
+	//	JsonArray errors = info.getAsJsonArray("errors");
+		
+		JsonObject error= jObject.getAsJsonObject("error");
+	//	JsonArray errors = info.getAsJsonArray("errors");
+
+		JsonPrimitive statusCode = error.getAsJsonPrimitive("statuscode");
+		//JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		//		.getAsJsonPrimitive("statuscode");
+		return statusCode.getAsInt();
 
 	}
 
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
index 7bc129c934..6bb909bd68 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
@@ -13,6 +13,7 @@
 import cucumber.api.Scenario;
 import cucumber.api.java.After;
 import cucumber.api.java.Before;
+import cucumber.api.java.en.And;
 import cucumber.api.java.en.Given;
 import cucumber.api.java.en.Then;
 import cucumber.api.java.en.When;
@@ -170,6 +171,23 @@ public void I_should_be_able_to_verify_the_response_message_as(
 		graphUiUtil.verifyErrorMessage(responseMessage);
 
 	}
+	
+	@Then("^I should be able to verify the http statuscode as \"([^\"]*)\"$")
+	public void I_should_be_able_to_verify_the_http_responseCode_as(int statusCode) {
+
+		graphUiUtil.verifyHttpStatusCode(statusCode);
+
+	}
+
+	@Then("^I should be able to verify the http response message as \"([^\"]*)\"$")
+	public void I_should_be_able_to_verify_the_http_response_message_as(
+			String responseMessage) {
+
+		graphUiUtil.verifyHttpErrorMessage(responseMessage);
+
+	}
+
+	
 
 	@When("^I request for a route$")
 	public void I_request_for_route() {
@@ -206,6 +224,14 @@ public void I_request_for_route() {
 		}
 
 	}
+	
+	@And("^I request for HTTP \"([^\"]*)\" method$")
+	public void I_request_for_http_mehtod(String httpMethod)
+	{
+		graphUiUtil.setHTTPMethod(httpMethod);
+	}
+	
+	
 
 	@After("@SampleScenario")
 	public void I_should_be_able_to_capture_a_screenshot(Scenario sc)
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
index 6784e24280..c3d26794a3 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
@@ -25,9 +25,16 @@
 import org.alternativevision.gpx.beans.Route;
 import org.alternativevision.gpx.beans.Waypoint;
 import org.apache.commons.io.IOUtils;
+import org.apache.http.HttpRequest;
+import org.apache.http.StatusLine;
 import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.impl.client.CloseableHttpClient;
 import org.junit.Assert;
 import org.openqa.selenium.By;
@@ -63,6 +70,9 @@
 	JavascriptExecutor js = (JavascriptExecutor) driver;
 	WebElement we;
 	private BufferedImage actualMap;
+	private String httpMethod="";
+	private int actualResponseCode;
+	private String actualResponseMsg;
 
 	private static final Logger LOG = LoggerFactory
 			.getLogger(GraphHopperUIUtil.class);
@@ -671,6 +681,12 @@ public void verifyWayPointsThroughService() {
 
 	protected void addParameter(String key, String value) {
 		ArrayList<String> tempList = null;
+		if (value.equals("mountainbike"))
+		{	value="mtb";}
+		
+
+			value= value.toLowerCase().replaceAll(" ", "");
+		
 		if (requestParameters.containsKey(key)) {
 			tempList = requestParameters.get(key);
 			if (tempList == null)
@@ -680,6 +696,7 @@ protected void addParameter(String key, String value) {
 			tempList = new ArrayList<String>();
 			tempList.add(value);
 		}
+
 		requestParameters.put(key, tempList);
 	}
 
@@ -708,6 +725,10 @@ void sendAndGetResponse(StringBuffer sb) {
 					.toString());
 			serviceResponse = IOUtils.toString(httpResponse.getEntity()
 					.getContent(), "UTF-8");
+			
+			final StatusLine statusLine = httpResponse.getStatusLine();
+			actualResponseCode = statusLine.getStatusCode();
+			actualResponseMsg = statusLine.getReasonPhrase();
 
 		} catch (IOException e) {
 			LOG.info("Exception raised whilst attempting to call graphhopper server "
@@ -739,19 +760,50 @@ public CloseableHttpResponse dispatchServiceRequest(String requestUrl)
 		return doSendAndGetResponse(serviceUrl);
 	}
 
-	private void addCustomHeaders(HttpGet httpget) {
+	private void addCustomHeaders(HttpUriRequest httpRequest) {
 		for (Entry<String, String> header : customHeaders.entrySet()) {
-			httpget.addHeader(header.getKey(), header.getValue());
+			httpRequest.addHeader(header.getKey(), header.getValue());
 		}
 	}
 
 	CloseableHttpResponse doSendAndGetResponse(String serviceUrl)
 			throws IOException, ClientProtocolException {
 		CloseableHttpClient httpClient = HttpClientUtils.createClient();
-		HttpGet httpget = new HttpGet(serviceUrl);
-		addCustomHeaders(httpget);
+		
+		HttpUriRequest httpRequest=null;
+		
+	switch (httpMethod) {
+	case "PUT":
+		httpRequest = new HttpPut(serviceUrl);
+		
+		break;
+	case "GET":
+		
+		httpRequest = new HttpGet(serviceUrl);
+		
+		break;
+		
+	case "DEL":
+		
+		httpRequest = new HttpDelete(serviceUrl);
+		
+		break;
+		
+	case "POST":
+		
+		httpRequest = new HttpPost(serviceUrl);
+		
+		break;
+
+	default:
+		httpRequest = new HttpGet(serviceUrl);
+		break;
+	}
+		
+		//HttpGet httpget = new HttpGet(serviceUrl);
+		addCustomHeaders(httpRequest);
 
-		return httpClient.execute(httpget);
+		return httpClient.execute(httpRequest);
 	}
 
 	protected void getRouteFromServiceWithParameters() {
@@ -804,6 +856,10 @@ public void getRouteFromUI() {
 
 		String avoidances = requestParameters.get("avoidances").get(0);
 		String vehicle = requestParameters.get("vehicle").get(0);
+		if (vehicle.equalsIgnoreCase("mountainbike"))
+		{
+			vehicle="mtb";
+		}
 
 		ArrayList<String> points = requestParameters.get("point");
 
@@ -830,6 +886,9 @@ public void getRouteFromUI() {
 		case "bike":
 			clickElement(ROUTE_TYPE_BIKE);
 			break;
+		case "mtb":
+			clickElement(ROUTE_TYPE_MOUNTAINBIKE);
+			break;
 		case "foot":
 			clickElement(ROUTE_TYPE_WALK);
 			break;
@@ -969,4 +1028,22 @@ public String getNearestPointDistance() {
 		return GPHJSONUtil.getNearestPointDistance();
 	}
 
+	public void setHTTPMethod(String httpMethod) {
+		
+		this.httpMethod=httpMethod;
+		
+
+		
+	}
+
+	public void verifyHttpStatusCode(int statusCode) {
+		Assert.assertTrue("Actual http Status Code"+ actualResponseCode+ "i s not matching with "+statusCode,statusCode==actualResponseCode);		
+	}
+
+	public void verifyHttpErrorMessage(String responseMessage) {
+		Assert.assertTrue("Actual http Error Message "+ actualResponseMsg+ " is not matching with "+responseMessage,responseMessage.equalsIgnoreCase(actualResponseMsg));
+		
+	}
+
+	
 }
diff --git a/acceptancetesting/src/test/cucumber/DPNRouting.feature b/acceptancetesting/src/test/cucumber/DPNRouting.feature
index e76d0666ef..bd521a8a6b 100644
--- a/acceptancetesting/src/test/cucumber/DPNRouting.feature
+++ b/acceptancetesting/src/test/cucumber/DPNRouting.feature
@@ -339,10 +339,9 @@ Feature: Verify a route from A to B
 
     Examples: 
       | vehicleType | avoidances | routeType |
-      | foot        | Scree      |      fastavoid     |
+      | foot        | Scree      | fastavoid |
 
   #cliff
-  ##############
   @Routing
   Scenario Outline: Verify DPN Route without cliff avoidance -(cliff)
     Given I have route point as
@@ -375,7 +374,7 @@ Feature: Verify a route from A to B
 
     Examples: 
       | vehicleType | avoidances | routeType |
-      | foot        | Cliff      |     fastavoid      |
+      | foot        | Cliff      | fastavoid |
 
   @Routing
   Scenario Outline: Verify DPN Route with cliff avoidance -(cliff)
@@ -413,7 +412,7 @@ Feature: Verify a route from A to B
 
     Examples: 
       | vehicleType | avoidances | routeType |
-      | foot        | Cliff      |    fastavoid       |
+      | foot        | Cliff      | fastavoid |
 
   #boulders
   @Routing
@@ -448,9 +447,63 @@ Feature: Verify a route from A to B
 
     Examples: 
       | vehicleType | avoidances | routeType |
-      | foot        | Boulders   |     fastavoid      |
+      | foot        | Boulders   | fastavoid |
+
+  #Marsh
+  @Routing
+  Scenario Outline: Verify DPN Route with avoidance -(Marsh)
+    Given I have route point as
+      | pointA              | pointB              |
+      | 53.558921,-1.935834 | 53.512816,-1.873835 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints not on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                         | azimuth | direction | time  | distance | avoidance |
+      | 4             | 53.578173,-1.920445 | Turn sharp right onto Wessenden Road | 185.0   | S         | 45731 | 63.5     | Marsh     |
+
+    Examples: 
+      | vehicleType | avoidances | routeType |
+      | foot        | Marsh      | fastavoid |
+
+  #Quarry Or Pit
+  @Routing
+  Scenario Outline: Verify DPN Route with avoidance -(Quarry Or Pit)
+    Given I have route point as
+      | pointA              | pointB              |
+      | 53.348269,-2.061068 | 53.318817,-2.069958 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints not on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                        | azimuth | direction | time   | distance | avoidance     |
+      | 8             | 53.329862,-2.078685 | Turn slight left onto Shrigley Road | 184.0   | S         | 728997 | 1012.5   | Quarry Or Pit |
+
+    Examples: 
+      | vehicleType | avoidances    | routeType |
+      | foot        | Quarry Or Pit | fastavoid |
 
   #Multiple Avoidance
+  @Routing
+  Scenario Outline: Verify DPN Route with boulders avoidance -(boulders and A Road)
+    Given I have route point as
+      | pointA             | pointB              |
+      | 53.31423,-1.554174 | 53.179724,-1.677904 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints not on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                          | azimuth | direction | time   | distance | avoidance |
+      | 1             | 53.31462,-1.554123  | Continue onto Moss Road               | 274.0   | W         | 426191 | 591.9    | A Road    |
+      | 15            | 53.341682,-1.612202 | Turn slight left onto Ringinglow Road | 195.0   | S         | 52520  | 72.9     | Boulders  |
+
+    Examples: 
+      | vehicleType | avoidances      | routeType |
+      | foot        | Boulders,A Road | fastavoid |
+
   @Routing
   Scenario Outline: Verify DPN Route without boulders avoidance -(boulders)
     Given I have route point as
@@ -485,10 +538,10 @@ Feature: Verify a route from A to B
 
     Examples: 
       | vehicleType | avoidances     | routeType |
-      | foot        | Boulders,Cliff |    fastavoid       |
+      | foot        | Boulders,Cliff | fastavoid |
 
-  @Routing
-  Scenario Outline: Verify DPN Route with boulders avoidance -()
+  @Routing 
+  Scenario Outline: Verify DPN Route with -(mountainbike)
     Given I have route point as
       | pointA              | pointB              |
       | 53.298525,-1.679533 | 53.203145,-1.799292 |
@@ -497,11 +550,61 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco          | waypointdesc                        | azimuth | direction | time  | distance | avoidance         |
-      | 1             | 53.297007,-1.679015 | Continue onto Sir William Hill Road | 79.0    | E         | 61737 | 308.7    | cycleway, unpaved |
+      | wayPointIndex | waypointco          | waypointdesc                        | azimuth | direction | time   | distance | avoidance         |
+      | 1             | 53.297007,-1.679015 | Continue onto Sir William Hill Road | 257.0   | W         | 100235 | 501.2    | cycleway, unpaved |
+
+    Examples: 
+      | vehicleType  | avoidances | routeType |
+      | mountainbike |            |           |
+
+  @Routing 
+  Scenario Outline: Verify DPN Route with avoidance -(A Road)
+    Given I have route point as
+      | pointA              | pointB              |
+      | 53.298525,-1.679533 | 53.203145,-1.799292 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints not on the route map:
+      | wayPointIndex | waypointco         | waypointdesc           | azimuth | direction | time  | distance | avoidance |
+      | 6             | 53.28017,-1.711765 | Turn right onto A Road | 236.0   | SW        | 43838 | 219.2    | ARoad     |
+
+    Examples: 
+      | vehicleType  | avoidances | routeType |
+      | mountainbike | A Road      |      fastavoid     |
+
+  #Add shortest,fastest,fastavoid and shortavoid for both foot and mountainbike
+  @Routing 
+  Scenario Outline: Verify DPN Route with out avoidance -(Mountain Bike)
+    Given I have route point as
+      | pointA              | pointB              |
+      | 53.334174,-1.936591 | 53.182547,-1.824527 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc        | azimuth | direction | time | distance | avoidance   |
+      | 4             | 53.348198,-1.933166 | Continue onto Route | 33.0    | NE        | 3799 | 4.2      | InlandWater |
+
+    Examples: 
+      | vehicleType  | avoidances | routeType |
+      | mountainbike |            |           |
+
+  @Routing 
+  Scenario Outline: Verify DPN Route without  avoidance -(A Road )
+    Given I have route point as
+      | pointA              | pointB              |
+      | 53.288886,-1.980339 | 53.311846,-1.783654 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc              | azimuth | direction | time    | distance | avoidance |
+      | 5             | 53.277954,-1.981109 | Turn left onto Minor Road | 155.0   | SE        | 1125018 | 5625.1   | cycleway  |
 
     Examples: 
       | vehicleType  | avoidances | routeType |
       | mountainbike |            |           |
-    
-      #Add shortest,fastest,fastavoid and shortavoid for both foot and mountainbike 
diff --git a/acceptancetesting/src/test/cucumber/Routing-Errors.feature b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
new file mode 100644
index 0000000000..39e6dab057
--- /dev/null
+++ b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
@@ -0,0 +1,499 @@
+Feature: Verify a route from A to B
+   As a user
+   I want to get a valid Error message and status code for a invalid route request
+
+  #Error Messages
+  #Successful request
+  @Routing @ErrorMessages
+  Scenario: Successful request with all parameters
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "car"
+    And I have avoidances as ""
+    And I have weighting as "fastest"
+    And I have locale as "en-GB"
+    And I have debug as "true"
+    And I have points_encoded as "true"
+    And I have points_calc as "true"
+    And I have instructions as "true"
+    And I have algorithm as "astar"
+    And I have type as "json"
+    When I request for a route
+    Then I should be able to verify the http response message as "OK"
+    Then I should be able to verify the http statuscode as "200"
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                | azimuth | direction | time | distance | avoidance |
+      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 4050 | 112.5    |           |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages @Current
+  Scenario Outline: Incorrect Parameter Value for "Vehicle"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the http response message as "<httpErrorMessage>"
+    Then I should be able to verify the http statuscode as "<statusCode>"
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | errorMessage                                                  | statusCode | httpErrorMessage |
+      | 123         |            | fastest   | Vehicle 123 is not a valid vehicle. Valid vehicles are car.   | 400        | Bad Request      |
+      | foot        |            | fastest   | Vehicle foot is not a valid vehicle. Valid vehicles are car.  | 400        | Bad Request      |
+      | cycle       |            | fastest   | Vehicle cycle is not a valid vehicle. Valid vehicles are car. | 400        | Bad Request      |
+      | Bike        |            | fastest   | Vehicle Bike is not a valid vehicle. Valid vehicles are car.  | 400        | Bad Request      |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Name "vehicles"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage | statusCode |
+      | car         |            | fastest   | json           |              | 400        |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages
+  Scenario Outline: Missing Parameter "vehicle"
+    Given I have route points as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
+      | car         |            | fastest   | json           | No point parameter provided | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Value "point"
+    Given I have route point as
+      | pointA           | pointB              |
+      | 50.729961,string | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Name "points"
+    Given I have route points as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                       | statusCode |
+      | car         |            | fastest   | json           | Parameter points is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Missing Parameter "point"
+    Given I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
+      | car         |            | fastest   | json           | No point parameter provided | 400        |
+
+  # Parameter :  avoidances
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "avoidances"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  avoidances
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "avoidances"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | cliff      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  weighting
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "weighting"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  weighting
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "weighting"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  locale
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "locale"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have locale as "<locale>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | locale | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | en     | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  locale
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "locale"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have locals as "<locale>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | locale | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | en-GB  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  instructions
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "instructions"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have instructions as "<instructions>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | instructions | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | msg("box")   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  instructions
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "instructions"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have instruction as "<instructions>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | instructions | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | true         | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  algorithm
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "algorithm"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have algorithm as "<algorithm>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | algorithm | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | xyz       | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         |            | faster    | dijkstra  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         |            | faster    | astar     | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         |            | faster    | astarbi   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  algorithm
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "algorithm"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have algorithms as "<algorithm>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | algorithm | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | dijkstra  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  points_encoded
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "points_encoded"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have points_encoded as "<points_encoded>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | points_encoded | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | xyz            | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  points_encoded
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "points_encoded"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have points_encodedSSS as "<algorithm>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | points_encoded | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | true           | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  debug
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "debug"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have debug as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | debug | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | xyz   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  debug
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "debug"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have debug as "<debug>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | debug | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | true  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  calc_points
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have calc_points as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | xyz         | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  calc_points
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have calc_points as "<calc_points>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | true        | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  Type
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "type"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have calc_points as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | faster    | xyz         | txt            | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  Type
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have calc_pointSSS as "<calc_points>"
+    And I have weightings as "<routeType>"
+    And I have responseType as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                              | statusCode |
+      | car         |            | fastest   | true        | json           | Parameter calc_pointSSS is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+# http method
+  @Routing @ErrorMessages
+  Scenario Outline: http methods "PUT/POST/DEL/GET"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    Given I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    And I request for HTTP "<httpMethod>" method
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | httpMethod|responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | PUT|json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 405        |
+      | car         |            | fastest   | DEL|json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 405        |
+      | car         |            | fastest   | POST|json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 405        |
+      | car         |            | fastest   | GET|json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 405        |
+      
diff --git a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
index 56fc728bd7..359e625b40 100644
--- a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
@@ -150,8 +150,8 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco         | waypointdesc                           | azimuth | direction | time  | distance | avoidance |
-      | 4             | 50.726418,-3.52381 | Turn slight left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
+      | wayPointIndex | waypointco         | waypointdesc                    | azimuth | direction | time  | distance | avoidance |
+      | 4             | 50.726418,-3.52381 | Turn left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -297,7 +297,7 @@ Feature: Verify a route from A to B
       | car         |            | fastest   |
 
   # Access Limited To
-  @Routing
+  @Routing @Current
   Scenario Outline: Verify  Access Limited To  Restrictions on a Route (North Street-Exeter)
     Given I have route point as
       | pointA              | pointB              |
@@ -308,7 +308,7 @@ Feature: Verify a route from A to B
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco       | waypointdesc               | azimuth | direction | time  | distance | avoidance |
-      | 2             | 50.72258,-3.5326 | Continue onto SOUTH STREET | 135.0   | SE        | 15537 | 194.2    |           |
+      | 2             | 50.72258,-3.5326 | Continue onto SOUTH STREET | 135.0   | SE        | 30038 | 379.1    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -324,8 +324,8 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco         | waypointdesc                           | azimuth | direction | time  | distance | avoidance |
-      | 5             | 50.726418,-3.52381 | Turn slight left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
+      | wayPointIndex | waypointco         | waypointdesc                    | azimuth | direction | time  | distance | avoidance |
+      | 5             | 50.726418,-3.52381 | Turn left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -832,105 +832,3 @@ Feature: Verify a route from A to B
     Examples: 
       | vehicleType | avoidances | routeType |
       | car         |            | fastest   |
-
-  #Error Messages
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Value for "Vehicle"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | errorMessage                                                 | statusCode |
-      | 123         |            | fastest   | Vehicle 123 is not a valid vehicle. Valid vehicles are car. 	| 400        |
-      | foot        |            | fastest   | Vehicle foot is not a valid vehicle. Valid vehicles are car. | 400        |
-      | cycle       |            | fastest   | Vehicle cycle is not a valid vehicle. Valid vehicles are car.| 400        |
-      | Bike        |            | fastest   | Vehicle Bike is not a valid vehicle. Valid vehicles are car. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Name "vehicles"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage | statusCode |
-      | car         |            | fastest   | json           |              | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Value "point"
-    Given I have route point as
-      | pointA           | pointB              |
-      | 50.729961,string | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
-      | car         |            | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Name "points"
-    Given I have route points as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                       | statusCode |
-      | car         |            | fastest   | json           | Parameter points is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Missing Parameter "point"
-    Given I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
-      | car         |            | fastest   | json           | No point parameter provided | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Invalid Parameter Value for "avoidances"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    Given I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
-      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
index 29ca7faeec..994001ae2c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
@@ -4,80 +4,112 @@
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
 
-public abstract class AbstractAvoidanceDecorator implements EncoderDecorator {
+public abstract class AbstractAvoidanceDecorator implements EncoderDecorator
+{
 
 	protected EncodedValue wayTypeEncoder;
 	protected int originalShift;
 	public static final int KEY = 303;
 
-	protected abstract void defineEncoder(int shift);
+	protected abstract void defineEncoder( int shift );
+
 	protected abstract EdgeAttribute[] getEdgeAttributesOfInterest();
 
-	public int defineWayBits(int shift) {
+	@Override
+	public int defineWayBits( int shift )
+	{
 		originalShift = shift;
 		defineEncoder(shift);
 		shift += wayTypeEncoder.getBits();
 		return shift;
 	}
-	
-	public int getOriginalShift() {
+
+	@Override
+	public int getOriginalShift()
+	{
 		return originalShift;
 	}
 
+	@Override
 	public InstructionAnnotation getAnnotation( long flags, Translation tr )
-    {
-        long wayType = wayTypeEncoder.getValue(flags);
-        String wayName = getWayName(wayType, tr);
-        return new InstructionAnnotation(0, wayName);
-    }
+	{
+		long wayType = wayTypeEncoder.getValue(flags);
+		String wayName = getWayName(wayType, tr);
+		return new InstructionAnnotation(0, wayName);
+	}
 
-	public boolean supports(int key) {
+	@Override
+	public boolean supports( int key )
+	{
 		return key == KEY;
 	};
-	
+
 	@Override
-	public long getLong(long flags) {
+	public long getLong( long flags )
+	{
 		return wayTypeEncoder.getValue(flags);
 	}
-	
+
 	@Override
-	public double getDouble(long flags) {
+	public double getDouble( long flags )
+	{
 		double avoidanceType = wayTypeEncoder.getValue(flags);
 		return avoidanceType;
 	}
 
-	public long handleWayTags(Way way) {
+	@Override
+	public long handleWayTags( Way way )
+	{
 		long avoidanceValue = 0;
-	
-		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
-			if (aType.isValidForWay(way)) {
+
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest())
+		{
+			if (aType.isValidForWay(way))
+			{
 				avoidanceValue += aType.getValue();
 			}
 		}
 		return wayTypeEncoder.setValue(0L, avoidanceValue);
 	}
 
-	private String getWayName(long wayType, Translation tr) {
+	private String getWayName( long wayType, Translation tr )
+	{
 		String wayName = "";
-		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
-			if ((wayType & aType.getValue()) == aType.getValue()) {
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest())
+		{
+			if ((wayType & aType.getValue()) == aType.getValue())
+			{
 				wayName += " ";
 				wayName += aType.name();
 			}
 		}
-	
+
 		return wayName;
 	}
 
 	@Override
-	public long getBitMask(String[] attributes) {
+	public long getBitMask( String[] attributes )
+	{
 		long avoidanceValue = 0;
-		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
-			if (aType.representedIn(attributes)) {
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest())
+		{
+			if (aType.representedIn(attributes))
+			{
 				avoidanceValue += aType.getValue();
 			}
 		}
 		return avoidanceValue;
 	}
 
+	public String[] getEdgeAttributesOfInterestNames()
+	{
+		EdgeAttribute[] edgeAttributes = getEdgeAttributesOfInterest();
+		String[] results = new String[edgeAttributes.length];
+		for (int i = 0; i < edgeAttributes.length; i++)
+		{
+			results[i] = edgeAttributes[i].toString();
+		}
+		return results;
+	}
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
index 68472bbe3c..c0d589d309 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
@@ -5,55 +5,69 @@
 /**
  * Created by sadam on 4/15/15.
  */
-public class OsVehicleAvoidanceDecorator extends AbstractAvoidanceDecorator {
-    protected enum AvoidanceType implements EdgeAttribute
-    {
-        MOTORWAYS(1) {
-            @Override
-            public boolean isValidForWay(Way way) {
-               return way.hasTag("highway", "Motorway", "motorway");
-            }
-        },
-        TOLL(2) {
-            @Override
-            public boolean isValidForWay(Way way) {
-                return way.hasTag("toll", "yes");
-            }
-        };
-
-
-        private final long value;
-
-        private AvoidanceType( long value )
-        {
-            this.value = value;
-        }
-
-        public long getValue()
-        {
-            return value;
-        }
-
-        public boolean isValidForWay(Way way) {
-            return false;
-        }
-        
-        public boolean representedIn(String[] attributes) {
-			for (String attribute : attributes) {
-				if(attribute.equals(this.toString())) {
+public class OsVehicleAvoidanceDecorator extends AbstractAvoidanceDecorator
+{
+	protected enum AvoidanceType implements EdgeAttribute
+	{
+		MOTORWAYS(1)
+		{
+			@Override
+			public boolean isValidForWay( Way way )
+			{
+				return way.hasTag("highway", "Motorway", "motorway");
+			}
+		},
+		TOLL(2)
+		{
+			@Override
+			public boolean isValidForWay( Way way )
+			{
+				return way.hasTag("toll", "yes");
+			}
+		};
+
+		private final long value;
+
+		private AvoidanceType( long value )
+		{
+			this.value = value;
+		}
+
+		@Override
+		public long getValue()
+		{
+			return value;
+		}
+
+		@Override
+		public boolean isValidForWay( Way way )
+		{
+			return false;
+		}
+
+		@Override
+		public boolean representedIn( String[] attributes )
+		{
+			for (String attribute : attributes)
+			{
+				if (attribute.equals(this.toString()))
+				{
 					return true;
 				}
 			}
 			return false;
 		}
-    }
+	}
 
-    @Override
-	protected void defineEncoder(int shift) {
+	@Override
+	protected void defineEncoder( int shift )
+	{
 		wayTypeEncoder = new EncodedValue("HazardType", shift, 3, 1, 0, 4, true);
 	}
-    
-    protected EdgeAttribute[] getEdgeAttributesOfInterest() {
+
+	@Override
+	protected EdgeAttribute[] getEdgeAttributesOfInterest()
+	{
 		return AvoidanceType.values();
 	}
 
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 0f41ea3812..ff6aa8c358 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -17,8 +17,16 @@
  */
 package com.graphhopper.util;
 
-import java.io.*;
-import java.util.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 import java.util.Map.Entry;
 
 /**
@@ -27,252 +35,255 @@
  * <p/>
  * See here for more information: ./docs/core/translations.md
  * <p>
+ * 
  * @author Peter Karich
  */
 public class TranslationMap
 {
-    // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "cz", "de_DE", "el", "en_US", "es",
-            "fa", "fil", "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "ne", "nl", "pl_PL",
-            "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
-    private final Map<String, Translation> translations = new HashMap<String, Translation>();
+	// ISO codes (639-1), use 'en_US' as reference
+	public static final List<String> LOCALES = Arrays.asList("bg", "ca", "cz", "de_DE", "el",
+	        "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "ne", "nl",
+	        "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk", "vi_VI",
+	        "zh_CN");
+	private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
-    /**
-     * This loads the translation files from the specified folder.
-     */
-    public TranslationMap doImport( File folder )
-    {
-        try
-        {
-            for (String locale : LOCALES)
-            {
-                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
-                trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
-                add(trMap);
-            }
-            postImportHook();
-            return this;
-        } catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
+	/**
+	 * This loads the translation files from the specified folder.
+	 */
+	public TranslationMap doImport( File folder )
+	{
+		try
+		{
+			for (String locale : LOCALES)
+			{
+				TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
+				trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
+				add(trMap);
+			}
+			postImportHook();
+			return this;
+		} catch (Exception ex)
+		{
+			throw new RuntimeException(ex);
+		}
+	}
 
-    /**
-     * This loads the translation files from classpath.
-     */
-    public TranslationMap doImport()
-    {
-        try
-        {
-            for (String locale : LOCALES)
-            {
-                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
-                trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
-                add(trMap);
-            }
-            postImportHook();
-            return this;
-        } catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
+	/**
+	 * This loads the translation files from classpath.
+	 */
+	public TranslationMap doImport()
+	{
+		try
+		{
+			for (String locale : LOCALES)
+			{
+				TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
+				trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
+				add(trMap);
+			}
+			postImportHook();
+			return this;
+		} catch (Exception ex)
+		{
+			throw new RuntimeException(ex);
+		}
+	}
 
-    public void add( Translation tr )
-    {
-        Locale locale = tr.getLocale();
-        translations.put(locale.toString(), tr);
-        if (!locale.getCountry().isEmpty() && !translations.containsKey(tr.getLanguage()))
-            translations.put(tr.getLanguage(), tr);
+	public void add( Translation tr )
+	{
+		Locale locale = tr.getLocale();
+		translations.put(locale.toString(), tr);
+		if (!locale.getCountry().isEmpty() && !translations.containsKey(tr.getLanguage()))
+			translations.put(tr.getLanguage(), tr);
 
-        // Map old Java 'standard' to latest, Java is a bit ugly here: http://stackoverflow.com/q/13974169/194609
-        // Hebrew
-        if ("iw".equals(locale.getLanguage()))
-            translations.put("he", tr);
+		// Map old Java 'standard' to latest, Java is a bit ugly here:
+		// http://stackoverflow.com/q/13974169/194609
+		// Hebrew
+		if ("iw".equals(locale.getLanguage()))
+			translations.put("he", tr);
 
-        // Indonesia
-        if ("in".equals(locale.getLanguage()))
-            translations.put("id", tr);
-    }
+		// Indonesia
+		if ("in".equals(locale.getLanguage()))
+			translations.put("id", tr);
+	}
 
-    /**
-     * Returns the Translation object for the specified locale and falls back to english if the
-     * locale was not found.
-     */
-    public Translation getWithFallBack( Locale locale )
-    {
-        Translation tr = get(locale.toString());
-        if (tr == null)
-        {
-            tr = get(locale.getLanguage());
-            if (tr == null)
-                tr = get("en");
-        }
-        return tr;
-    }
+	/**
+	 * Returns the Translation object for the specified locale and falls back to english if the
+	 * locale was not found.
+	 */
+	public Translation getWithFallBack( Locale locale )
+	{
+		Translation tr = get(locale.toString());
+		if (tr == null)
+		{
+			tr = get(locale.getLanguage());
+			if (tr == null)
+				tr = get("en");
+		}
+		return tr;
+	}
 
-    /**
-     * Returns the Translation object for the specified locale and returns null if not found.
-     */
-    public Translation get( String locale )
-    {
-        locale = locale.replace("-", "_");
-        Translation tr = translations.get(locale);
-        if (locale.contains("_") && tr == null)
-            tr = translations.get(locale.substring(0, 2));
+	/**
+	 * Returns the Translation object for the specified locale and returns null if not found.
+	 */
+	public Translation get( String locale )
+	{
+		locale = locale.replace("-", "_");
+		Translation tr = translations.get(locale);
+		if (locale.contains("_") && tr == null)
+			tr = translations.get(locale.substring(0, 2));
 
-        return tr;
-    }
+		return tr;
+	}
 
-    public static int countOccurence( String phrase, String splitter )
-    {
-        if (Helper.isEmpty(phrase))
-            return 0;
-        return phrase.trim().split(splitter).length;
-    }
+	public static int countOccurence( String phrase, String splitter )
+	{
+		if (Helper.isEmpty(phrase))
+			return 0;
+		return phrase.trim().split(splitter).length;
+	}
 
-    /**
-     * This method does some checks and fills missing translation from en
-     */
-    private void postImportHook()
-    {
-        Map<String, String> enMap = get("en").asMap();
-        StringBuilder sb = new StringBuilder();
-        for (Translation tr : translations.values())
-        {
-            Map<String, String> trMap = tr.asMap();
-            for (Entry<String, String> enEntry : enMap.entrySet())
-            {
-                String value = trMap.get(enEntry.getKey());
-                if (Helper.isEmpty(value))
-                {
-                    trMap.put(enEntry.getKey(), enEntry.getValue());
-                    continue;
-                }
+	/**
+	 * This method does some checks and fills missing translation from en
+	 */
+	private void postImportHook()
+	{
+		Map<String, String> enMap = get("en").asMap();
+		StringBuilder sb = new StringBuilder();
+		for (Translation tr : translations.values())
+		{
+			Map<String, String> trMap = tr.asMap();
+			for (Entry<String, String> enEntry : enMap.entrySet())
+			{
+				String value = trMap.get(enEntry.getKey());
+				if (Helper.isEmpty(value))
+				{
+					trMap.put(enEntry.getKey(), enEntry.getValue());
+					continue;
+				}
 
-                int expectedCount = countOccurence(enEntry.getValue(), "\\%");
-                if (expectedCount != countOccurence(value, "\\%"))
-                {
-                    sb.append(tr.getLocale()).append(" - error in ").
-                            append(enEntry.getKey()).append("->").
-                            append(value).append("\n");
-                } else
-                {
-                    // try if formatting works, many times e.g. '%1$' instead of '%1$s'
-                    Object[] strs = new String[expectedCount];
-                    Arrays.fill(strs, "tmp");
-                    try
-                    {
-                        String.format(value, strs);
-                    } catch (Exception ex)
-                    {
-                        sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
-                                append(enEntry.getKey()).append("->").
-                                append(value).append("\n");
-                    }
-                }
-            }
-        }
+				int expectedCount = countOccurence(enEntry.getValue(), "\\%");
+				if (expectedCount != countOccurence(value, "\\%"))
+				{
+					sb.append(tr.getLocale()).append(" - error in ").append(enEntry.getKey())
+					        .append("->").append(value).append("\n");
+				} else
+				{
+					// try if formatting works, many times e.g. '%1$' instead of '%1$s'
+					Object[] strs = new String[expectedCount];
+					Arrays.fill(strs, "tmp");
+					try
+					{
+						String.format(value, strs);
+					} catch (Exception ex)
+					{
+						sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage())
+						        .append("in ").append(enEntry.getKey()).append("->").append(value)
+						        .append("\n");
+					}
+				}
+			}
+		}
 
-        if (sb.length() > 0)
-        {
-            System.out.println(sb);
-            throw new IllegalStateException(sb.toString());
-        }
-    }
+		if (sb.length() > 0)
+		{
+			System.out.println(sb);
+			throw new IllegalStateException(sb.toString());
+		}
+	}
 
-    public static class TranslationHashMap implements Translation
-    {
-        private final Map<String, String> map = new HashMap<String, String>();
-        final Locale locale;
+	public static class TranslationHashMap implements Translation
+	{
+		private final Map<String, String> map = new HashMap<String, String>();
+		final Locale locale;
 
-        public TranslationHashMap( Locale locale )
-        {
-            this.locale = locale;
-        }
+		public TranslationHashMap( Locale locale )
+		{
+			this.locale = locale;
+		}
 
-        public void clear()
-        {
-            map.clear();
-        }
+		public void clear()
+		{
+			map.clear();
+		}
 
-        @Override
-        public Locale getLocale()
-        {
-            return locale;
-        }
+		@Override
+		public Locale getLocale()
+		{
+			return locale;
+		}
 
-        @Override
-        public String getLanguage()
-        {
-            return locale.getLanguage();
-        }
+		@Override
+		public String getLanguage()
+		{
+			return locale.getLanguage();
+		}
 
-        @Override
-        public String tr( String key, Object... params )
-        {
-            String val = map.get(key.toLowerCase());
-            if (Helper.isEmpty(val))
-                return key;
+		@Override
+		public String tr( String key, Object... params )
+		{
+			String val = map.get(key.toLowerCase());
+			if (Helper.isEmpty(val))
+				return key;
 
-            return String.format(val, params);
-        }
+			return String.format(val, params);
+		}
 
-        public TranslationHashMap put( String key, String val )
-        {
-            String existing = map.put(key.toLowerCase(), val);
-            if (existing != null)
-                throw new IllegalStateException("Cannot overwrite key " + key + " with " + val + ", was: " + existing);
-            return this;
-        }
+		public TranslationHashMap put( String key, String val )
+		{
+			String existing = map.put(key.toLowerCase(), val);
+			if (existing != null)
+				throw new IllegalStateException("Cannot overwrite key " + key + " with " + val
+				        + ", was: " + existing);
+			return this;
+		}
 
-        @Override
-        public String toString()
-        {
-            return map.toString();
-        }
+		@Override
+		public String toString()
+		{
+			return map.toString();
+		}
 
-        @Override
-        public Map<String, String> asMap()
-        {
-            return map;
-        }
+		@Override
+		public Map<String, String> asMap()
+		{
+			return map;
+		}
 
-        public TranslationHashMap doImport( InputStream is )
-        {
-            if (is == null)
-                throw new IllegalStateException("No input stream found in class path!?");
-            try
-            {
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
-                {
-                    if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
-                        continue;
+		public TranslationHashMap doImport( InputStream is )
+		{
+			if (is == null)
+				throw new IllegalStateException("No input stream found in class path!?");
+			try
+			{
+				for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
+				{
+					if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
+						continue;
 
-                    int index = line.indexOf('=');
-                    if (index < 0)
-                        continue;
-                    String key = line.substring(0, index);
-                    if (key.isEmpty())
-                        throw new IllegalStateException("No key provided:" + line);
+					int index = line.indexOf('=');
+					if (index < 0)
+						continue;
+					String key = line.substring(0, index);
+					if (key.isEmpty())
+						throw new IllegalStateException("No key provided:" + line);
 
-                    String value = line.substring(index + 1);
-                    if (!value.isEmpty())
-                        put(key, value);
+					String value = line.substring(index + 1);
+					if (!value.isEmpty())
+						put(key, value);
 
-                }
-            } catch (IOException ex)
-            {
-                throw new RuntimeException(ex);
-            }
-            return this;
-        }
-    }
+				}
+			} catch (IOException ex)
+			{
+				throw new RuntimeException(ex);
+			}
+			return this;
+		}
+	}
 
-    @Override
-    public String toString()
-    {
-        return translations.toString();
-    }
+	@Override
+	public String toString()
+	{
+		return translations.toString();
+	}
 }
diff --git a/web/.classpath b/web/.classpath
index af6acd2e07..3ae6c18259 100644
--- a/web/.classpath
+++ b/web/.classpath
@@ -13,36 +13,7 @@
 			<attribute name="maven.pomderived" value="true"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="var" path="M2_REPO/javax/inject/javax.inject/1/javax.inject-1.jar"/>
-	<classpathentry kind="var" path="M2_REPO/javax/servlet/javax.servlet-api/3.0.1/javax.servlet-api-3.0.1.jar"/>
 	<classpathentry kind="src" path="/graphhopper"/>
-	<classpathentry kind="var" path="M2_REPO/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar"/>
-	<classpathentry kind="var" path="M2_REPO/log4j/log4j/1.2.17/log4j-1.2.17.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/apache/xmlgraphics/xmlgraphics-commons/1.5/xmlgraphics-commons-1.5.jar"/>
-	<classpathentry kind="var" path="M2_REPO/commons-io/commons-io/1.3.1/commons-io-1.3.1.jar"/>
-	<classpathentry kind="var" path="M2_REPO/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar"/>
-	<classpathentry kind="var" path="M2_REPO/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/openstreetmap/osmosis/osmosis-osm-binary/0.43.1/osmosis-osm-binary-0.43.1.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/json/json/20140107/json-20140107.jar"/>
-	<classpathentry kind="var" path="M2_REPO/com/google/inject/guice/3.0/guice-3.0.jar"/>
-	<classpathentry kind="var" path="M2_REPO/aopalliance/aopalliance/1.0/aopalliance-1.0.jar"/>
-	<classpathentry kind="var" path="M2_REPO/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-servlets/8.1.14.v20131031/jetty-servlets-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-continuation/8.1.14.v20131031/jetty-continuation-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-client/8.1.14.v20131031/jetty-client-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-http/8.1.14.v20131031/jetty-http-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-io/8.1.14.v20131031/jetty-io-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-util/8.1.14.v20131031/jetty-util-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-server/8.1.14.v20131031/jetty-server-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/orbit/javax.servlet/3.0.0.v201112011016/javax.servlet-3.0.0.v201112011016.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-servlet/8.1.14.v20131031/jetty-servlet-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-security/8.1.14.v20131031/jetty-security-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-webapp/8.1.14.v20131031/jetty-webapp-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/eclipse/jetty/jetty-xml/8.1.14.v20131031/jetty-xml-8.1.14.v20131031.jar"/>
-	<classpathentry kind="var" path="M2_REPO/junit/junit/4.11/junit-4.11.jar"/>
-	<classpathentry kind="var" path="M2_REPO/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar"/>
 	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
 		<attributes>
 			<attribute name="maven.pomderived" value="true"/>
diff --git a/web/src/main/java/com/graphhopper/http/ApiResource.java b/web/src/main/java/com/graphhopper/http/ApiResource.java
index c48f4c4657..a924dffbc7 100644
--- a/web/src/main/java/com/graphhopper/http/ApiResource.java
+++ b/web/src/main/java/com/graphhopper/http/ApiResource.java
@@ -4,143 +4,139 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.servlet.http.HttpServletRequest;
- 
- 
-public enum ApiResource {
-	ROUTE("route", new String[]{"point","vehicle"}, new String[] { "point", "locale", "instructions", "vehicle", "weighting", "algorithm", "points_encoded", "debug", "calc_points","tye","avoidances" }),
-    NEAREST("nearest", new String[]{"point"}, new String[] { "point"}),
-	INFO("info", new String[]{}, new String[] { });
-	   
-	
-    public String[] getMandatoryValues() {
-        return mandatoryValues;
-    }
- 
- 
-    public String[] getValidValues() {
-        return validValues;
-    }
- 
- 
-    public String getResourceName() {
-        return resourceName;
-    }
- 
- 
-    private String resourceName;
-    private String[] mandatoryValues;
-    private String[] validValues;
- 
- 
-    private ApiResource(String resourceName, String[] mandatoryValues, String[] validValues) {
-        this.resourceName = resourceName;
-        this.mandatoryValues = mandatoryValues;
-        this.validValues = validValues;
-    }
-   
-    /**
-     * Scans through all the request parameters. Checks if the mandatory field
-     * exists for a resource. Checks if all the request parameters are valid for
-     * the resource. Throws appropriate exceptions if not
-     *
-     * @param HttpServletRequest
-     * @param APIResource
-     *
-     * @throws MissingParameterException
-     * @throws NoSuchParameterException
-     */
-    public void checkAllRequestParameters(HttpServletRequest request)
-            throws MissingParameterException, NoSuchParameterException {
-        // Check if the mandatory parameter exists in the request
-        String value =  this.getMandatoryValues()[0];
-        boolean mandatoryValueExists = checkMandatoryValue(request, value);
-        if( mandatoryValueExists && this.getMandatoryValues().length > 1 )
-        {
-            value =  this.getMandatoryValues()[1];
-            mandatoryValueExists = checkMandatoryValue(request, value);
-        }
-        if(!mandatoryValueExists)
-        {
-            throw new MissingParameterException(value);
-        }
-       
-        // Now check for all the valid parameters for the resource
-        checkValidParameters(request);
-    }
-   
-    /**
-     * Checks if the given mandatory value exists in the request parameters
-     *
-     * @param parameters Enumeration<String>
-     * @param mandatoryValue
-     * @return
-     */
-    private boolean checkMandatoryValue(HttpServletRequest request, String mandatoryValue)
-    {
-        Set<String> keys = request.getParameterMap().keySet();
-        for(String key: keys)
-       {
-            if(mandatoryValue.equalsIgnoreCase(key))
-            {
-                return true;
-            }
-        }       
-        return false;
-    }
-   
-    /**
-     * Checks if all the valid parameters exist in the request for the resource
-     *
-     * @param request
-     * @throws NoSuchParameterException
-     */
-    private void checkValidParameters(HttpServletRequest request) throws NoSuchParameterException
-    {
-        // Now check for all the valid parameters for the resource
-        List<String> list = Arrays.asList(this.getValidValues());
-        Map<String, String[]> parameterMap = request.getParameterMap();
-        for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
-            String parameterName = entry.getKey().toLowerCase();
-            if (!list.contains(parameterName)) {
-                throw new NoSuchParameterException(getInvalidPara​meterMessage(
-                        parameterName, this.getResourceName(), this.getValidValues()));
-            }
-        }
-    }
- 
- 
-    /**
-     * Builds the message when the parameter provided is invalid
-     *
-     * @param invalid
-     * @param parameter
-     * @param validValues
-     * @return message String
-     */
-    private String getInvalidPara​meterMessage(String invalid, String parameter,
-            String[] validValues) {
-        StringBuilder sb = new StringBuilder();
- 
- 
-        sb.append("Parameter ").append(invalid)
-        .append(" is not a valid parameter for resource ")
-        .append(parameter)
-        .append(". Valid parameters for requested resource are ");
- 
- 
-        List<String> validList = Arrays.asList(validValues);
-        for (String valid : validList) {
-            sb.append(valid).append(", ");
-        }
-        String message = sb.substring(0, sb.length() - 2) + ".";
- 
- 
-        return message;
-    }
- 
- 
- 
- 
-}
\ No newline at end of file
+
+public enum ApiResource
+{
+	ROUTE("route", new String[] { "point", "vehicle" }, new String[] { "point", "vehicle",
+	        "locale", "instructions", "weighting", "algorithm", "points_encoded", "debug",
+	        "pretty", "calc_points", "type", "avoidances" }), NEAREST("nearest",
+	        new String[] { "point" }, new String[] { "point" }), INFO("info", new String[] {},
+	        new String[] {});
+
+	public String[] getMandatoryValues()
+	{
+		return mandatoryValues;
+	}
+
+	public String[] getValidValues()
+	{
+		return validValues;
+	}
+
+	public String getResourceName()
+	{
+		return resourceName;
+	}
+
+	private String resourceName;
+	private String[] mandatoryValues;
+	private String[] validValues;
+
+	private ApiResource( String resourceName, String[] mandatoryValues, String[] validValues )
+	{
+		this.resourceName = resourceName;
+		this.mandatoryValues = mandatoryValues;
+		this.validValues = validValues;
+	}
+
+	/**
+	 * Scans through all the request parameters. Checks if the mandatory field exists for a
+	 * resource. Checks if all the request parameters are valid for the resource. Throws appropriate
+	 * exceptions if not
+	 *
+	 * @param HttpServletRequest
+	 * @param APIResource
+	 *
+	 * @throws MissingParameterException
+	 * @throws NoSuchParameterException
+	 */
+	public void checkAllRequestParameters( HttpServletRequest request )
+	        throws MissingParameterException, NoSuchParameterException, InvalidParameterException
+	{
+		// Check if the mandatory parameter exists in the request
+		String value = this.getMandatoryValues()[0];
+		boolean mandatoryValueExists = checkMandatoryValue(request, value);
+		if (mandatoryValueExists && this.getMandatoryValues().length > 1)
+		{
+			value = this.getMandatoryValues()[1];
+			mandatoryValueExists = checkMandatoryValue(request, value);
+		}
+		if (!mandatoryValueExists)
+		{
+			throw new MissingParameterException(value);
+		}
+
+		// Now check for all the valid parameters for the resource
+		checkValidParameters(request);
+	}
+
+	/**
+	 * Checks if the given mandatory value exists in the request parameters
+	 *
+	 * @param parameters Enumeration<String>
+	 * @param mandatoryValue
+	 * @return
+	 */
+	private boolean checkMandatoryValue( HttpServletRequest request, String mandatoryValue )
+	{
+		Set<String> keys = request.getParameterMap().keySet();
+		for (String key : keys)
+		{
+			if (mandatoryValue.equalsIgnoreCase(key))
+			{
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Checks if all the valid parameters exist in the request for the resource
+	 *
+	 * @param request
+	 * @throws NoSuchParameterException
+	 */
+	private void checkValidParameters( HttpServletRequest request ) throws NoSuchParameterException
+	{
+		// Now check for all the valid parameters for the resource
+		List<String> list = Arrays.asList(this.getValidValues());
+		Map<String, String[]> parameterMap = request.getParameterMap();
+		for (Map.Entry<String, String[]> entry : parameterMap.entrySet())
+		{
+			String parameterName = entry.getKey().toLowerCase();
+			if (!list.contains(parameterName))
+			{
+				throw new NoSuchParameterException(getInvalidPara​meterMessage(parameterName,
+				        this.getResourceName(), this.getValidValues()));
+			}
+		}
+	}
+
+	/**
+	 * Builds the message when the parameter provided is invalid
+	 *
+	 * @param invalid
+	 * @param parameter
+	 * @param validValues
+	 * @return message String
+	 */
+	private String getInvalidPara​meterMessage( String invalid, String parameter,
+	        String[] validValues )
+	{
+		StringBuilder sb = new StringBuilder();
+
+		sb.append("Parameter ").append(invalid).append(" is not a valid parameter for resource ")
+		        .append(parameter).append(". Valid parameters for requested resource are ");
+
+		List<String> validList = Arrays.asList(validValues);
+		for (String valid : validList)
+		{
+			sb.append(valid).append(", ");
+		}
+		String message = sb.substring(0, sb.length() - 2) + ".";
+
+		return message;
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 9ca5a32c23..40bcf716c4 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,48 +17,45 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_OK;
+
+import java.io.IOException;
 
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-import static javax.servlet.http.HttpServletResponse.SC_OK;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * @author Peter Karich
  */
-public class GHBaseServlet extends HttpServlet
-{
+public class GHBaseServlet extends HttpServlet {
     protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonpAllowed")
-    private boolean jsonpAllowed;
+    protected boolean jsonpAllowed;
 
-    protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException, IOException
-    {
+    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JSONObject json) throws JSONException,
+            IOException {
         String type = getParam(req, "type", "json");
         res.setCharacterEncoding("UTF-8");
         boolean debug = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
-        if ("jsonp".equals(type))
-        {
+        if ("jsonp".equals(type)) {
             res.setContentType("application/javascript");
-            if (!jsonpAllowed)
-            {
+            if (!jsonpAllowed) {
                 writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
-            if (callbackName == null)
-            {
+            if (callbackName == null) {
                 writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
@@ -68,8 +65,7 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
 
-        } else
-        {
+        } else {
             res.setContentType("application/json");
             if (debug)
                 writeResponse(res, json.toString(2));
@@ -78,31 +74,26 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
         }
     }
 
-    protected void writeError( HttpServletResponse res, int code, String message )
-    {
+    protected void writeError(HttpServletResponse res, int code, String message) {
         JSONObject json = new JSONObject();
         json.put("message", message);
         writeJsonError(res, code, json);
     }
 
-    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
-    {
-        try
-        {
+    protected void writeJsonError(HttpServletResponse res, int code, JSONObject json) {
+        try {
             // no type parameter check here as jsonp does not work if an error
             // also no debug parameter yet
             res.setContentType("application/json");
             res.setCharacterEncoding("UTF-8");
             res.setStatus(code);
             res.getWriter().append(json.toString(2));
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write error " + ex.getMessage());
         }
     }
 
-    protected String getParam( HttpServletRequest req, String string, String _default )
-    {
+    protected String getParam(HttpServletRequest req, String string, String _default) {
         String[] l = req.getParameterMap().get(string);
         if (l != null && l.length > 0)
             return l[0];
@@ -110,57 +101,43 @@ protected String getParam( HttpServletRequest req, String string, String _defaul
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String string )
-    {
+    protected String[] getParams(HttpServletRequest req, String string) {
         String[] l = req.getParameterMap().get(string);
-        if (l != null && l.length > 0)
-        {
+        if (l != null && l.length > 0) {
             return l;
         }
         return new String[0];
     }
 
-    protected long getLongParam( HttpServletRequest req, String string, long _default )
-    {
-        try
-        {
+    protected long getLongParam(HttpServletRequest req, String string, long _default) {
+        try {
             return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
-    {
-        try
-        {
+    protected boolean getBooleanParam(HttpServletRequest req, String string, boolean _default) {
+        try {
             return Boolean.parseBoolean(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String string, double _default )
-    {
-        try
-        {
+    protected double getDoubleParam(HttpServletRequest req, String string, double _default) {
+        try {
             return Double.parseDouble(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    public void writeResponse( HttpServletResponse res, String str )
-    {
-        try
-        {
+    public void writeResponse(HttpServletResponse res, String str) {
+        try {
             res.setStatus(SC_OK);
             res.getWriter().append(str);
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write message:" + str, ex);
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index d48c5b634d..d0aa9dd79c 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,21 +17,17 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPoint;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 
-import org.json.JSONObject;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -45,272 +41,420 @@
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
 
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-import java.util.Map.Entry;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.http.validation.BooleanValidator;
+import com.graphhopper.http.validation.CaseInsensitiveStringListValidator;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.AbstractAvoidanceDecorator;
+import com.graphhopper.routing.util.AbstractFlagEncoder;
+import com.graphhopper.routing.util.EncoderDecorator;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.TranslationMap;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
  * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
  * used otherwise. See the full API response format in docs/web/api-doc.md
  * <p/>
+ *
  * @author Peter Karich
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
-    @Inject
-    private GraphHopper hopper;
-    
-    @Named("internalErrorsAllowed")
-    private boolean internalErrorsAllowed;
-
-    @Override
-    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
-    {
-        
-        GHResponse ghRsp;
-        StopWatch sw = new StopWatch().start();
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
-        String vehicleStr = getParam(httpReq, "vehicle", "car");
-        String weighting = getParam(httpReq, "weighting", "fastest");
-        String algoStr = getParam(httpReq, "algorithm", "");
-        String localeStr = getParam(httpReq, "locale", "en");
-        List<GHPoint> infoPoints = getPoints(httpReq, "point");
-        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
-        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
-        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
-        boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
-        boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
-        try {
-            ApiResource.ROUTE.checkAllRequestParameters(httpReq);
-            
-            // we can reduce the path length based on the maximum differences to the original coordinates
-            
-            
-            if (!hopper.getEncodingManager().supports(vehicleStr))
-            {
-                String supported = hopper.getGraph().getEncodingManager().toString();
-                String errMesg = String.format("Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr, supported);
-                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-            } else if (enableElevation && !hopper.hasElevation())
-            {
-            	ghRsp = new GHResponse().addError(new InvalidParameterException("Elevation not supported!"));
-            } else
-            {
-                FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-                GHRequest request = new GHRequest(infoPoints);
-                
-                initHints(request, httpReq.getParameterMap());
-                request.setVehicle(algoVehicle.toString()).
-                setWeighting(weighting).
-                setAlgorithm(algoStr).
-                setLocale(localeStr).
-                getHints().
-                put("calcPoints", calcPoints).
-                put("instructions", enableInstructions).
-                put("wayPointMaxDistance", minPathPrecision);
-                
-                ghRsp = hopper.route(request);
-            }
-        } catch (NoSuchParameterException | MissingParameterException e) {
-            ghRsp = new GHResponse().addError(e);
-        }
-        float took = sw.stop().getSeconds();
-        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
-        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
-        		+ took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
-        
-        if (ghRsp.hasErrors())
-        	logger.error(logStr + ", errors:" + ghRsp.getErrors());
-        else
-        	logger.info(logStr + ", distance: " + ghRsp.getDistance()
-        			+ ", time:" + Math.round(ghRsp.getTime() / 60000f)
-        			+ "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
-        
-        if (writeGPX)
-        {
-        	String xml = createGPXString(httpReq, httpRes, ghRsp);
-        	if (ghRsp.hasErrors())
-        	{
-        		httpRes.setStatus(SC_BAD_REQUEST);
-        		httpRes.getWriter().append(xml);
-        	} else
-        		writeResponse(httpRes, xml);
-        } else
-        {
-        	Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation, enableInstructions);
-        	Object infoMap = map.get("info");
-        	if (infoMap != null)
-        		((Map) infoMap).put("took", Math.round(took * 1000));
-        	
-        	if (ghRsp.hasErrors())
-        	{
-        		writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
-        	} else
-        		writeJson(httpReq, httpRes, new JSONObject(map));
-        }
-      
-    }
-
-    protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
-    {
-        boolean includeElevation = getBooleanParam(req, "elevation", false);
-        res.setCharacterEncoding("UTF-8");
-        res.setContentType("application/xml");
-        String trackName = getParam(req, "track", "GraphHopper Track");
-        res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-        long time = getLongParam(req, "millis", System.currentTimeMillis());
-        if (rsp.hasErrors())
-            return errorsToXML(rsp.getErrors());
-        else
-            return rsp.getInstructions().createGPX(trackName, time, includeElevation);
-    }
-
-    String errorsToXML( List<Throwable> list )
-    {
-        try
-        {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            DocumentBuilder builder = factory.newDocumentBuilder();
-            Document doc = builder.newDocument();
-            Element gpxElement = doc.createElement("gpx");
-            gpxElement.setAttribute("creator", "GraphHopper");
-            gpxElement.setAttribute("version", "1.1");
-            doc.appendChild(gpxElement);
-
-            Element mdElement = doc.createElement("metadata");
-            gpxElement.appendChild(mdElement);
-
-            Element extensionsElement = doc.createElement("extensions");
-            mdElement.appendChild(extensionsElement);
-
-            Element messageElement = doc.createElement("message");
-            extensionsElement.appendChild(messageElement);
-            messageElement.setTextContent(list.get(0).getMessage());
-
-            Element hintsElement = doc.createElement("hints");
-            extensionsElement.appendChild(hintsElement);
-
-            for (Throwable t : list)
-            {
-                Element error = doc.createElement("error");
-                hintsElement.appendChild(error);
-                error.setAttribute("message", t.getMessage());
-                if(internalErrorsAllowed) {
-                	error.setAttribute("details", t.getClass().getName());
-                }
-            }
-            TransformerFactory transformerFactory = TransformerFactory.newInstance();
-            Transformer transformer = transformerFactory.newTransformer();
-            StringWriter writer = new StringWriter();
-            transformer.transform(new DOMSource(doc), new StreamResult(writer));
-            return writer.toString();
-        } catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    protected Map<String, Object> createJson( GHResponse rsp,
-                                              boolean calcPoints, boolean pointsEncoded,
-                                              boolean includeElevation, boolean enableInstructions )
-    {
-        Map<String, Object> json = new HashMap<String, Object>();
-
-        if (rsp.hasErrors())
-        {
-        	Map<String, String> map = new HashMap<String, String>();
-            json.put("error",map);
-            Throwable throwable = rsp.getErrors().get(0);
-            map.put("message", throwable.getMessage());
-            map.put("statuscode", ((APIException) throwable).getStatusCode().toString());
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
-            {
-                Map<String, String> hintMap = new HashMap<String, String>();
-                hintMap.put("message", t.getMessage());
-//                if(internalErrorsAllowed) {
-                hintMap.put("details", t.getClass().getName());
-//                }
-                list.add(hintMap);
-            }
-            json.put("hints", list);
-        } else
-        {
-            Map<String, Object> jsonInfo = new HashMap<String, Object>();
-            json.put("info", jsonInfo);
-//            jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
-            Map<String, Object> jsonPath = new HashMap<String, Object>();
-            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getTime());
-
-            if (calcPoints)
-            {
-                jsonPath.put("points_encoded", pointsEncoded);
-
-                PointList points = rsp.getPoints();
-                if (points.getSize() >= 2)
-                {
-                    BBox maxBounds = hopper.getGraph().getBounds();
-                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
-                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
-                }
-
-                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-                if (enableInstructions)
-                {
-                    InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson());
-                }
-            }
-            json.put("paths", Collections.singletonList(jsonPath));
-        }
-        return json;
-    }
-
-    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
-        if (pointsEncoded)
-            return WebHelper.encodePolyline(points, includeElevation);
-
-        Map<String, Object> jsonPoints = new HashMap<String, Object>();
-        jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-        return jsonPoints;
-    }
-
-    protected List<GHPoint> getPoints( HttpServletRequest req, String key )
-    {
-        String[] pointsAsStr = getParams(req, key);
-        final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
-        for (String str : pointsAsStr)
-        {
-            String[] fromStrs = str.split(",");
-            if (fromStrs.length == 2)
-            {
-                GHPoint point = GHPoint.parse(str);
-                if (point != null)
-                {
-                    infoPoints.add(point);
-                }
-            }
-        }
-
-        return infoPoints;
-    }
-
-    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
-    {
-        WeightingMap m = request.getHints();
-        for (Entry<String, String[]> e : parameterMap.entrySet())
-        {
-            if (e.getValue().length == 1)
-                m.put(e.getKey(), e.getValue()[0]);
-        }
-    }
+	@Inject
+	private GraphHopper hopper;
+
+	@Named("internalErrorsAllowed")
+	private boolean internalErrorsAllowed;
+
+	@Override
+	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
+	        throws ServletException, IOException
+	{
+
+		List<GHPoint> infoPoints = getPoints(httpReq, "point");
+		boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+		double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+		boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+		boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+		boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
+		boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
+
+		String vehicleStr = getParam(httpReq, "vehicle", "car");
+		String weighting = getParam(httpReq, "weighting", "fastest");
+		String algoStr = getParam(httpReq, "algorithm", "");
+		String localeStr = getParam(httpReq, "locale", "en");
+
+		StopWatch sw = new StopWatch().start();
+		GHResponse ghRsp = null;
+
+		String instructionsString = getParam(httpReq, "instructions", "true");
+		String pointsEncodedString = getParam(httpReq, "points_encoded", "true");
+		String calcPointsString = getParam(httpReq, "calc_points", "true");
+		String debugString = getParam(httpReq, "debug", "true");
+		String prettyString = getParam(httpReq, "pretty", "true");
+		String avoidancesString = getParam(httpReq, "avoidances", null);
+		try
+		{
+			ApiResource.ROUTE.checkAllRequestParameters(httpReq);
+
+			// we can reduce the path length based on the maximum differences to the original
+			// coordinates
+
+			if (!new CaseInsensitiveStringListValidator()
+			        .isValid(localeStr, TranslationMap.LOCALES))
+			{
+				String errMesg = buildErrorMessageString(localeStr, "locale",
+				        TranslationMap.LOCALES);
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg.toString()));
+			} else if (!new CaseInsensitiveStringListValidator().isValid(algoStr,
+			        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI, AlgorithmOptions.DIJKSTRA,
+			        AlgorithmOptions.DIJKSTRA_BI, AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
+			{
+				String errMesg = buildErrorMessageString(algoStr, "algorithm",
+				        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+				        AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+				        AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!new BooleanValidator().isValid(instructionsString))
+			{
+				String errMesg = buildBooleanErrorMessageString(instructionsString, "instructions");
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!new BooleanValidator().isValid(pointsEncodedString))
+			{
+				String errMesg = buildBooleanErrorMessageString(pointsEncodedString,
+				        "points_encoded");
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!new BooleanValidator().isValid(calcPointsString))
+			{
+				String errMesg = buildBooleanErrorMessageString(calcPointsString, "calc_points");
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!new BooleanValidator().isValid(debugString))
+			{
+				String errMesg = buildBooleanErrorMessageString(debugString, "debug");
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!new BooleanValidator().isValid(prettyString))
+			{
+				String errMesg = buildBooleanErrorMessageString(prettyString, "pretty");
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (!hopper.getEncodingManager().supports(vehicleStr))
+			{
+				String supported = hopper.getGraph().getEncodingManager().toString();
+				String errMesg = String.format(
+				        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
+				        supported);
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+			} else if (enableElevation && !hopper.hasElevation())
+			{
+				ghRsp = new GHResponse().addError(new IllegalArgumentException(
+				        "Elevation not supported!"));
+			} else
+			{
+				FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
+
+				// Lots of lovely braces. I will tidy this up next week... promise!
+				if (avoidancesString != null)
+				{
+					System.out.println("Avoidances for " + algoVehicle);
+					List<String> allowedAvoidances = new ArrayList<>();
+					// Check Avoidances
+					if (algoVehicle instanceof AbstractFlagEncoder)
+					{
+						AbstractFlagEncoder abstractFlagEncoder = (AbstractFlagEncoder) algoVehicle;
+						List<EncoderDecorator> encoderDecorators = abstractFlagEncoder
+						        .getEncoderDecorators();
+						if (encoderDecorators != null)
+						{
+							for (EncoderDecorator encoderDecorator : encoderDecorators)
+							{
+								if (encoderDecorator instanceof AbstractAvoidanceDecorator)
+								{
+									AbstractAvoidanceDecorator abstractAvoidanceDecorator = (AbstractAvoidanceDecorator) encoderDecorator;
+									allowedAvoidances.addAll(Arrays
+									        .asList(abstractAvoidanceDecorator
+									                .getEdgeAttributesOfInterestNames()));
+								}
+							}
+						}
+					}
+					if (!allowedAvoidances.contains(avoidancesString))
+					{
+						String errMesg = buildErrorMessageString(avoidancesString, "avoidances",
+						        allowedAvoidances);
+						ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg
+						        .toString()));
+					}
+				}
+
+				if (ghRsp == null)
+				{
+					GHRequest request = new GHRequest(infoPoints);
+
+					initHints(request, httpReq.getParameterMap());
+					request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
+					        .setAlgorithm(algoStr).setLocale(localeStr).getHints()
+					        .put("calcPoints", calcPoints).put("instructions", enableInstructions)
+					        .put("wayPointMaxDistance", minPathPrecision);
+					ghRsp = hopper.route(request);
+				}
+			}
+		} catch (NoSuchParameterException | MissingParameterException | InvalidParameterException e)
+		{
+			ghRsp = new GHResponse().addError(e);
+		}
+		float took = sw.stop().getSeconds();
+		String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
+		        + httpReq.getHeader("User-Agent");
+		String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+		        + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+
+		if (ghRsp.hasErrors())
+			logger.error(logStr + ", errors:" + ghRsp.getErrors());
+		else
+			logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
+			        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
+			        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
+
+		if (writeGPX)
+		{
+			String xml = createGPXString(httpReq, httpRes, ghRsp);
+			if (ghRsp.hasErrors())
+			{
+				httpRes.setStatus(SC_BAD_REQUEST);
+				httpRes.getWriter().append(xml);
+			} else
+				writeResponse(httpRes, xml);
+		} else
+		{
+			String type = getParam(httpReq, "type", "json");
+			if (!"json".equalsIgnoreCase(type) || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
+			{
+				String errorMessage = type
+				        + " is not a valid value for parameter type. Valid values are ";
+				errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
+				ghRsp.addError(new IllegalArgumentException(errorMessage));
+			}
+			Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation,
+			        enableInstructions);
+			Object infoMap = map.get("info");
+			if (infoMap != null)
+				((Map) infoMap).put("took", Math.round(took * 1000));
+
+			if (ghRsp.hasErrors())
+			{
+				writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+			} else
+				writeJson(httpReq, httpRes, new JSONObject(map));
+		}
+	}
+
+	private String buildBooleanErrorMessageString( String paramValue, String paramName )
+	{
+		return buildErrorMessageString(paramValue, paramName,
+		        Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
+	}
+
+	private String buildErrorMessageString( String paramValue, String paramName,
+	        String... validValues )
+	{
+		return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
+	}
+
+	private String buildErrorMessageString( String paramValue, String paramName,
+	        List<String> validValues )
+	{
+		StringBuilder errMesg = new StringBuilder(paramValue)
+		        .append(" is not a valid value for parameter ").append(paramName)
+		        .append(". Valid values are ");
+		for (int i = 0; i < validValues.size(); i++)
+		{
+			String validStr = validValues.get(i);
+			if (i == validValues.size() - 1)
+			{
+				errMesg.append(" or ");
+			}
+			errMesg.append(validStr);
+			if (i < validValues.size() - 2)
+			{
+				errMesg.append(", ");
+			}
+		}
+		return errMesg.toString();
+	}
+
+	protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
+	        GHResponse rsp )
+	{
+		boolean includeElevation = getBooleanParam(req, "elevation", false);
+		res.setCharacterEncoding("UTF-8");
+		res.setContentType("application/xml");
+		String trackName = getParam(req, "track", "GraphHopper Track");
+		res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
+		long time = getLongParam(req, "millis", System.currentTimeMillis());
+		if (rsp.hasErrors())
+			return errorsToXML(rsp.getErrors());
+		else
+			return rsp.getInstructions().createGPX(trackName, time, includeElevation);
+	}
+
+	String errorsToXML( List<Throwable> list )
+	{
+		try
+		{
+			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+			DocumentBuilder builder = factory.newDocumentBuilder();
+			Document doc = builder.newDocument();
+			Element gpxElement = doc.createElement("gpx");
+			gpxElement.setAttribute("creator", "GraphHopper");
+			gpxElement.setAttribute("version", "1.1");
+			doc.appendChild(gpxElement);
+
+			Element mdElement = doc.createElement("metadata");
+			gpxElement.appendChild(mdElement);
+
+			Element extensionsElement = doc.createElement("extensions");
+			mdElement.appendChild(extensionsElement);
+
+			Element messageElement = doc.createElement("message");
+			extensionsElement.appendChild(messageElement);
+			messageElement.setTextContent(list.get(0).getMessage());
+
+			Element hintsElement = doc.createElement("hints");
+			extensionsElement.appendChild(hintsElement);
+
+			for (Throwable t : list)
+			{
+				Element error = doc.createElement("error");
+				hintsElement.appendChild(error);
+				error.setAttribute("message", t.getMessage());
+				if (internalErrorsAllowed)
+				{
+					error.setAttribute("details", t.getClass().getName());
+				}
+			}
+			TransformerFactory transformerFactory = TransformerFactory.newInstance();
+			Transformer transformer = transformerFactory.newTransformer();
+			StringWriter writer = new StringWriter();
+			transformer.transform(new DOMSource(doc), new StreamResult(writer));
+			return writer.toString();
+		} catch (Exception ex)
+		{
+			throw new RuntimeException(ex);
+		}
+	}
+
+	protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
+	        boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
+	{
+		Map<String, Object> json = new HashMap<String, Object>();
+
+		if (rsp.hasErrors())
+		{
+			Map<String, String> map = new HashMap<String, String>();
+			json.put("error", map);
+			Throwable throwable = rsp.getErrors().get(0);
+			map.put("message", throwable.getMessage());
+			map.put("statuscode", ((APIException) throwable).getStatusCode().toString());
+			List<Map<String, String>> list = new ArrayList<Map<String, String>>();
+			for (Throwable t : rsp.getErrors())
+			{
+				Map<String, String> hintMap = new HashMap<String, String>();
+				hintMap.put("message", t.getMessage());
+				if (internalErrorsAllowed)
+				{
+					hintMap.put("details", t.getClass().getName());
+				}
+				list.add(hintMap);
+			}
+			json.put("hints", list);
+		} else
+		{
+			Map<String, Object> jsonInfo = new HashMap<String, Object>();
+			json.put("info", jsonInfo);
+			// jsonInfo.put("copyrights", Arrays.asList("GraphHopper",
+			// "OpenStreetMap contributors"));
+			Map<String, Object> jsonPath = new HashMap<String, Object>();
+			jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+			jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+			jsonPath.put("time", rsp.getTime());
+
+			if (calcPoints)
+			{
+				jsonPath.put("points_encoded", pointsEncoded);
+
+				PointList points = rsp.getPoints();
+				if (points.getSize() >= 2)
+				{
+					BBox maxBounds = hopper.getGraph().getBounds();
+					BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
+					        maxBounds.minLat, maxBounds.maxLat);
+					jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+				}
+
+				jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+				if (enableInstructions)
+				{
+					InstructionList instructions = rsp.getInstructions();
+					jsonPath.put("instructions", instructions.createJson());
+				}
+			}
+			json.put("paths", Collections.singletonList(jsonPath));
+		}
+		return json;
+	}
+
+	protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+	{
+		if (pointsEncoded)
+			return WebHelper.encodePolyline(points, includeElevation);
+
+		Map<String, Object> jsonPoints = new HashMap<String, Object>();
+		jsonPoints.put("type", "LineString");
+		jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+		return jsonPoints;
+	}
+
+	protected List<GHPoint> getPoints( HttpServletRequest req, String key )
+	{
+		String[] pointsAsStr = getParams(req, key);
+		final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
+		for (String str : pointsAsStr)
+		{
+			String[] fromStrs = str.split(",");
+			if (fromStrs.length == 2)
+			{
+				GHPoint point = GHPoint.parse(str);
+				if (point != null)
+				{
+					infoPoints.add(point);
+				}
+			}
+		}
+
+		return infoPoints;
+	}
+
+	protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
+	{
+		WeightingMap m = request.getHints();
+		for (Entry<String, String[]> e : parameterMap.entrySet())
+		{
+			if (e.getValue().length == 1)
+				m.put(e.getKey(), e.getValue()[0]);
+		}
+	}
 }
diff --git a/web/src/main/java/com/graphhopper/http/validation/BooleanValidator.java b/web/src/main/java/com/graphhopper/http/validation/BooleanValidator.java
new file mode 100644
index 0000000000..b02e178f2a
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/validation/BooleanValidator.java
@@ -0,0 +1,11 @@
+package com.graphhopper.http.validation;
+
+public class BooleanValidator
+{
+
+	public boolean isValid( String param )
+	{
+		return "true".equalsIgnoreCase(param) || "false".equalsIgnoreCase(param);
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/validation/CaseInsensitiveStringListValidator.java b/web/src/main/java/com/graphhopper/http/validation/CaseInsensitiveStringListValidator.java
new file mode 100644
index 0000000000..a91b52f34c
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/validation/CaseInsensitiveStringListValidator.java
@@ -0,0 +1,24 @@
+package com.graphhopper.http.validation;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class CaseInsensitiveStringListValidator
+{
+	public boolean isValid( String value, String... validValues )
+	{
+		return isValid(value, Arrays.asList(validValues));
+	}
+
+	public boolean isValid( String value, List<String> validValues )
+	{
+		for (String validValue : validValues)
+		{
+			if (value.equalsIgnoreCase(validValue))
+			{
+				return true;
+			}
+		}
+		return false;
+	}
+}
diff --git a/web/src/main/webapp/js/main-bng.js b/web/src/main/webapp/js/main-bng.js
index 67f9d23219..52abe2d0ef 100644
--- a/web/src/main/webapp/js/main-bng.js
+++ b/web/src/main/webapp/js/main-bng.js
@@ -1030,8 +1030,8 @@ function routeLatLng(request, doQuery) {
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
     request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
-        if (json.message) {
-            var tmpErrors = json.message;
+        if (json.error) {
+            var tmpErrors = json.error;
             log(tmpErrors);
             if (json.hints)
                 for (var m = 0; m < json.hints.length; m++) {
