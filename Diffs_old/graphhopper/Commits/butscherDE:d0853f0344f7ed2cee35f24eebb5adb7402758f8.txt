diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
index 3577245ced..aa259b9fae 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
@@ -49,30 +49,16 @@ private void pathsOneToMany(int from) {
         for (int to : entryExitPoints) {
             this.currentTo = to;
 
+            this.clear();
             Path newPath = this.calcPath(from, to);
             allPaths.put(new Pair(from, to), newPath);
         }
     }
 
-    public List<Integer> buildPathSkeleton() {
-        Set<Integer> unionedNodesFromPaths = new HashSet<>(allPaths.size() * 10);
-
-        for (Map.Entry<Pair<Integer, Integer>, Path> entry : allPaths.entrySet()) {
-            addPathNodesToSet(unionedNodesFromPaths, entry.getValue());
-        }
-
-        return new ArrayList<>(unionedNodesFromPaths);
-    }
-
-    private void addPathNodesToSet(Set<Integer> unionedNodesFromPaths, Path path) {
-        IntIndexedContainer nodesInPath = path.calcNodes();
-        for (int i = 0; i < nodesInPath.size(); i++) {
-            int node = nodesInPath.get(i);
-            unionedNodesFromPaths.add(node);
-        }
-    }
-
-    public Path getPathByStartEndPoint(int start, int end) {
-        return this.allPaths.get(new Pair<Integer, Integer>(start, end));
+    public Path getPathByFromEndPoint(int from, int end) {
+        final Path pathByGivenNodeIDs = this.allPaths.get(new Pair<Integer, Integer>(from, end));
+        pathByGivenNodeIDs.setFromNode(from);
+        pathByGivenNodeIDs.setEndNode(end);
+        return pathByGivenNodeIDs;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 08ae2286dc..384a8ce7cd 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -120,7 +120,6 @@ public int findEndNode(int from, int to) {
         while (true) {
             visitedNodes++;
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
-            // TODO shouldnt this be do while because iter already has a first edge after setBaseNode called?
             while (iter.next()) {
                 exploreNextNeighbor(iter);
             }
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 33bfc79163..89af7b6152 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -19,6 +19,7 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
+import com.carrotsearch.hppc.cursors.IntCursor;
 import com.graphhopper.coll.GHIntArrayList;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -58,15 +59,15 @@
     /**
      * Shortest path tree entry
      */
-    protected SPTEntry sptEntry;
+    public SPTEntry sptEntry;
     protected int endNode = -1;
     private List<String> description;
     protected Weighting weighting;
     private FlagEncoder encoder;
     private boolean found;
     private int fromNode = -1;
-    private GHIntArrayList edgeIds;
-    private double weight;
+    protected GHIntArrayList edgeIds;
+    protected double weight;
     private NodeAccess nodeAccess;
 
     public Path(Graph graph, Weighting weighting) {
@@ -86,7 +87,7 @@ public Path(Graph graph, Weighting weighting) {
         buildThisPathFromAnotherPath(p);
     }
 
-    private void buildThisPathFromAnotherPath(Path p) {
+    protected void buildThisPathFromAnotherPath(Path p) {
         weight = p.weight;
         edgeIds = new GHIntArrayList(p.edgeIds);
         sptEntry = p.sptEntry;
@@ -406,6 +407,20 @@ public String toString() {
         return "found: " + found + ", weight: " + weight + ", time: " + time + ", distance: " + distance + ", edges: " + edgeIds.size();
     }
 
+    public List<Integer> getNodesInPathOrder() {
+        final List<Integer> edgeids = new ArrayList<>(edgeIds.size());
+        int adjacentNode = fromNode;
+        edgeids.add(adjacentNode);
+        for (final IntCursor edgeidCursor : edgeIds) {
+            final int edgeid = edgeidCursor.value;
+
+            adjacentNode = this.graph.getOtherNode(edgeid, adjacentNode);
+            edgeids.add(adjacentNode);
+        }
+
+        return edgeids;
+    }
+
     public String toDetailsString() {
         String str = "";
         for (int i = 0; i < edgeIds.size(); i++) {
@@ -426,42 +441,7 @@ public String toDetailsString() {
         void finish();
     }
 
-    public void addPath(final Path newPath) {
-        if (this.edgeIds.size() > 0) {
-            addIfThisPathIsntEmpty(newPath);
-        } else {
-            buildThisPathFromAnotherPath(newPath);
-        }
-    }
-
-    private void addIfThisPathIsntEmpty(Path newPath) {
-        final EdgeIteratorState lastEdgeOfThisPath = this.getFinalEdge();
-        final List<EdgeIteratorState> otherPathsEdges = newPath.calcEdges();
-
-        failOnNonAdablePath(lastEdgeOfThisPath, otherPathsEdges);
-        mergePaths(newPath, otherPathsEdges);
-    }
-
-    private void mergePaths(Path newPath, List<EdgeIteratorState> otherPathsEdges) {
-        addOtherPathsEdgesToThisPath(otherPathsEdges);
-        this.weight += newPath.getWeight();
-        this.sptEntry = null; // TODO: Test if this works and if not, how can be merge spt entries?
-        this.endNode = newPath.endNode;
-    }
-
-    private void failOnNonAdablePath(EdgeIteratorState lastEdgeOfThisPath, List<EdgeIteratorState> otherPathsEdges) {
-        if (!lastAndFirstNodeEqual(lastEdgeOfThisPath, otherPathsEdges)) {
-            throw new IllegalArgumentException("Paths must end and start with equal node");
-        }
-    }
-
-    private void addOtherPathsEdgesToThisPath(List<EdgeIteratorState> otherPathsEdges) {
-        for (EdgeIteratorState edge : otherPathsEdges) {
-            this.addEdge(edge.getEdge());
-        }
-    }
-
-    private boolean lastAndFirstNodeEqual(EdgeIteratorState lastEdgeOfThisPath, List<EdgeIteratorState> otherPathEdges) {
-        return lastEdgeOfThisPath.getAdjNode() == otherPathEdges.get(0).getBaseNode();
+    public boolean isNonEmpty() {
+        return this.edgeIds.size() > 0;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/PathMerge.java b/core/src/main/java/com/graphhopper/routing/PathMerge.java
new file mode 100644
index 0000000000..2cd0244bc9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/PathMerge.java
@@ -0,0 +1,63 @@
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.List;
+
+public class PathMerge extends Path {
+
+    public PathMerge(Graph graph, Weighting weighting) {
+        super(graph, weighting);
+    }
+
+    @Override
+    public Path extract() {
+        return setFound(true);
+    }
+
+    public void addPath(final Path newPath) {
+        if (!newPath.isNonEmpty()) {
+            throw new IllegalArgumentException("Cannot add empty paths");
+        }
+
+        if (this.edgeIds.size() > 0) {
+            addIfThisPathIsntEmpty(newPath);
+        } else {
+            buildThisPathFromAnotherPath(newPath);
+        }
+    }
+
+    private void addIfThisPathIsntEmpty(Path newPath) {
+        final EdgeIteratorState lastEdgeOfThisPath = this.getFinalEdge();
+        final List<EdgeIteratorState> otherPathsEdges = newPath.calcEdges();
+
+        failOnNonAdablePath(lastEdgeOfThisPath, otherPathsEdges);
+        mergePaths(newPath, otherPathsEdges);
+    }
+
+    private void mergePaths(Path newPath, List<EdgeIteratorState> otherPathsEdges) {
+        addOtherPathsEdgesToThisPath(otherPathsEdges);
+        this.weight += newPath.getWeight();
+        this.endNode = newPath.endNode;
+    }
+
+    private void failOnNonAdablePath(EdgeIteratorState lastEdgeOfThisPath, List<EdgeIteratorState> otherPathsEdges) {
+        if (!lastAndFirstNodeEqual(lastEdgeOfThisPath, otherPathsEdges)) {
+            throw new IllegalArgumentException("Paths must end and start with equal node");
+        }
+    }
+
+    private void addOtherPathsEdgesToThisPath(List<EdgeIteratorState> otherPathsEdges) {
+        for (int i = 0; i < otherPathsEdges.size(); i++) {
+            EdgeIteratorState edge = otherPathsEdges.get(i);
+            this.addEdge(edge.getEdge());
+        }
+    }
+
+    private boolean lastAndFirstNodeEqual(EdgeIteratorState lastEdgeOfThisPath, List<EdgeIteratorState> otherPathEdges) {
+        return lastEdgeOfThisPath.getAdjNode() == otherPathEdges.get(0).getBaseNode();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
index 32a843c956..d447406990 100644
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ b/core/src/main/java/com/graphhopper/routing/PathNative.java
@@ -37,7 +37,6 @@ public PathNative(Graph g, Weighting weighting, int[] parentNodes, int[] parentE
         this.parentEdges = parentEdges;
     }
 
-    @Override
     public Path extract() {
         if (endNode < 0)
             return this;
@@ -45,8 +44,9 @@ public Path extract() {
         int prevEdge = EdgeIterator.NO_EDGE;
         while (true) {
             int edgeId = parentEdges[endNode];
-            if (!EdgeIterator.Edge.isValid(edgeId))
+            if (!EdgeIterator.Edge.isValid(edgeId)) {
                 break;
+            }
 
             processEdge(edgeId, endNode, prevEdge);
             prevEdge = edgeId;
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 1b0a0b6068..79c3275961 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -17,6 +17,7 @@
 import com.graphhopper.util.shapes.Polygon;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public abstract class PolygonRoutingTemplate extends ViaRoutingTemplate {
@@ -39,6 +40,7 @@ public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationInd
         this.ghStorage = ghStorage;
         this.nodeAccess = nodeAccess;
         this.locationIndex = locationIndex;
+        this.pathList = new ArrayList<>(ghRequest.getPoints().size() - 1);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
index 39a06198f6..cd7e240c98 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
@@ -15,44 +15,54 @@
     private RoutingAlgorithm routingAlgorithm;
     private final DijkstraManyToMany pathSkeletonRouter;
     private final double distance;
+    private final int startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID;
 
     public RouteCandidate(final PolygonThroughRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
                           final int polygonExitNodeID) {
         this.polygonRoutingTemplate = polygonRoutingTemplate;
         this.pathSkeletonRouter = polygonRoutingTemplate.getPathSkeletonRouter();
 
-        calcPathFromStartToPolygonEntry(polygonRoutingTemplate, startNodeID, polygonEntryNodeID);
-        calcPathThroughPolygon(polygonEntryNodeID, polygonExitNodeID);
-        calcPathFromPolygonExitToEnd(polygonRoutingTemplate, endNodeID, polygonExitNodeID);
-        calcDirectRouteFromStartToEnd(polygonRoutingTemplate, startNodeID, endNodeID);
+        this.startNodeID = startNodeID;
+        this.endNodeID = endNodeID;
+        this.polygonEntryNodeID = polygonEntryNodeID;
+        this.polygonExitNodeID = polygonExitNodeID;
+
+        calcPathFromStartToPolygonEntry(polygonRoutingTemplate);
+        calcPathThroughPolygon();
+        calcPathFromPolygonExitToEnd(polygonRoutingTemplate);
+        calcDirectRouteFromStartToEnd(polygonRoutingTemplate);
 
         this.distance = this.startToPolygonEntry.getDistance() + this.polygonEntryToPolygonExit.getDistance() + this.polygonExitToEnd.getDistance();
     }
 
-    private void calcDirectRouteFromStartToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int endNodeID) {
+    private void calcPathFromStartToPolygonEntry(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
         this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
+        this.startToPolygonEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
     }
 
-    private void calcPathFromPolygonExitToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate, int endNodeID, int polygonExitNodeID) {
-        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
+    private void calcPathThroughPolygon() {
+        this.polygonEntryToPolygonExit = this.pathSkeletonRouter.getPathByFromEndPoint(polygonEntryNodeID, polygonExitNodeID);
     }
 
-    private void calcPathThroughPolygon(int polygonEntryNodeID, int polygonExitNodeID) {
-        this.polygonEntryToPolygonExit = this.pathSkeletonRouter.getPathByStartEndPoint(polygonEntryNodeID, polygonExitNodeID);
+    private void calcPathFromPolygonExitToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
+        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
     }
 
-    private void calcPathFromStartToPolygonEntry(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int polygonEntryNodeID) {
+    private void calcDirectRouteFromStartToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
         this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.startToPolygonEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
+        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
     }
 
     public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
-        Path completePathCandidate = new Path(queryGraph, algoOpts.getWeighting());
+        PathMerge completePathCandidate = new PathMerge(queryGraph, algoOpts.getWeighting());
+
         completePathCandidate.addPath(startToPolygonEntry);
         completePathCandidate.addPath(polygonEntryToPolygonExit);
         completePathCandidate.addPath(polygonExitToEnd);
+
+        completePathCandidate.extract();
+
         return completePathCandidate;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/SPTEntry.java b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
index da8cc82e31..7219f7ebfc 100644
--- a/core/src/main/java/com/graphhopper/storage/SPTEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/SPTEntry.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.util.EdgeIterator;
 
+import java.util.LinkedList;
+
 /**
  * This class is used to create the shortest-path-tree from linked entities.
  * <p>
@@ -76,7 +78,7 @@ public int compareTo(SPTEntry o) {
         if (weight < o.weight)
             return -1;
 
-        // assumption no NaN and no -0        
+        // assumption no NaN and no -0
         return weight > o.weight ? 1 : 0;
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
index 1c3cf37530..d1c2c16362 100644
--- a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
@@ -2,10 +2,7 @@
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraphs;
 import com.graphhopper.routing.util.*;
@@ -114,7 +111,17 @@ public void quickStartingTest() {
         RoutingAlgorithmFactory algorithmFactory = new RoutingAlgorithmFactorySimple();
         AlgorithmOptions algorithmOptions = buildAlgorithmOptions(algorithmHints, this.traversalMode, this.algorithmName, this.weighting, maxVisitedNodes);
 
-        routingTemplate.calcPaths(new QueryGraph(this.testGraph), algorithmFactory, algorithmOptions);
+        List<Path> paths = routingTemplate.calcPaths(new QueryGraph(this.testGraph), algorithmFactory, algorithmOptions);
+        System.out.println(paths.get(0).getNodesInPathOrder());
+        System.out.println(paths.toString());
+    }
+
+    @Test
+    public void showAllEdgesWithIDs() {
+        AllEdgesIterator aei = this.testGraph.getAllEdges();
+        while (aei.next()) {
+            System.out.println(aei.toString());
+        }
     }
 
     private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
