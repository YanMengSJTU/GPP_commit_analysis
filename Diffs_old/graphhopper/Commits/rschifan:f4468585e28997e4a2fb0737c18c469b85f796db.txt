diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 9df5e0f9ad..1e6a5410df 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -926,11 +926,12 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
                 weighting = new CurvatureWeighting(encoder, hintsMap);
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
-        } else if ("happymaps".equalsIgnoreCase(weightingStr)) {
-            weighting = new HappyMapsWeighting(encoder);
+        } else if ("mindful".equalsIgnoreCase(weightingStr)) {
+            weighting = new MindfulWeighting(encoder);
+        } else if ("vibrant".equalsIgnoreCase(weightingStr)) {
+            weighting = new VibrantWeighting(encoder);
         }
 
-
         if (weighting == null)
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
 
diff --git a/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java b/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java
deleted file mode 100644
index 6a129ea40f..0000000000
--- a/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.graphhopper;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.routing.weighting.HappyMapsWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class HappyMapsGraphHopper extends GraphHopper {
-
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-
-    @Override
-    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
-
-        String weightingStr = hintsMap.getWeighting().toLowerCase();
-
-        if ("happymaps".equals(weightingStr)) {
-            return new HappyMapsWeighting(encoder);
-        } else {
-            return super.createWeighting(hintsMap, encoder, graph);
-        }
-    }
-
-
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
index 355bd5b3ff..e0a4e93f95 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
@@ -61,8 +61,8 @@ else if (name.equals(CAR4WD))
         if (name.equals(MOTORCYCLE))
             return new MotorcycleFlagEncoder(configuration);
 
-        if (name.equals(RUNNINGHAPPYMAPS))
-            return new HappyMapsFlagEncoder(configuration);
+        if (name.equals(RUNNING))
+            return new RunningFlagEncoder(configuration);
 
         throw new IllegalArgumentException("entry in encoder list not supported " + name);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
index 998d81978d..9b65f8960e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
@@ -33,7 +33,7 @@
     final String HIKE = "hike";
     final String MOTORCYCLE = "motorcycle";
     final String GENERIC = "generic";
-    final String RUNNINGHAPPYMAPS = "runhappymaps";
+    final String RUNNING = "running";
     final FlagEncoderFactory DEFAULT = new DefaultFlagEncoderFactory();
 
     FlagEncoder createFlagEncoder(String name, PMap configuration);
diff --git a/core/src/main/java/com/graphhopper/routing/util/RunningFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RunningFlagEncoder.java
new file mode 100644
index 0000000000..d9edd7d09e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/RunningFlagEncoder.java
@@ -0,0 +1,669 @@
+package com.graphhopper.routing.util;
+
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+
+import java.io.*;
+import java.util.*;
+
+public class RunningFlagEncoder extends FootFlagEncoder {
+
+    static final int MAX_BEAUTY = 1;
+
+    // Encoders
+    protected EncodedDoubleValue beautyEncoder;
+    protected EncodedValue qualityHighwayEncoder;
+
+    protected EncodedValue highwayTypeEncoder;
+    protected EncodedValue OSMWayIdEncoder;
+
+    // Quality features
+    protected Set<String> sidewalkTypes;
+    protected Set<String> trackType;
+
+
+
+    // ------------------------------------------------------------------
+    // Surface feature
+    // ------------------------------------------------------------------
+
+    protected EncodedValue surfaceHighwayEncoder;
+
+    protected Set<String> surfaceTypes;
+
+    protected Set<String> designatedSurfaceTypes;
+    protected Set<String> accessibleSurfaceTypes;
+    protected Set<String> avoidedSurfaceTypes;
+    protected Set<String> grassSurfaceTypes;
+    protected Set<String> parkSurfaceTypes;
+    protected Set<String> pavementSurfaceTypes;
+    protected Set<String> sandSurfaceTypes;
+
+
+    // ------------------------------------------------------------------
+    // Crossing feature
+    // ------------------------------------------------------------------
+    protected Set<String> crossingTypes;
+
+    protected Set<String> designatedCrossingTypes;
+    protected Set<String> accessibleCrossingTypes;
+    protected Set<String> avoidedCrossingTypes;
+
+
+    private final Map<Long, Map<String, Double>> wayid2weights = new HashMap<>();
+    private final Map<String, Integer> highwayMap = new HashMap<>();
+    private final Map<Long, Long> idx2OSMWayId = new HashMap<>();
+    private long idx = 0;
+
+    public RunningFlagEncoder(PMap configuration) {
+        super(configuration);
+
+        // Quality Features
+        initSurfaceProperty();
+        initSidewalkProperty();
+        initTrackTypeProperty();
+        initCrossingProperty();
+
+        // OSM Highway Type Features
+        initOSMHighwayProperty();
+
+        loadCustomWeights();
+
+
+//        System.out.println(designatedSurfaceTypes);
+//        System.out.println(accessibleSurfaceTypes);
+//        System.out.println(avoidedSurfaceTypes);
+
+    }
+
+    protected void initOSMHighwayProperty(){
+        List<String> highwayList = Arrays.asList(
+                /* reserve index=0 for unset roads (not accessible) */
+
+                "_default",
+
+                "motorway", "motorway_link", "motorroad", "trunk", "trunk_link",
+                "bus_guideway", "escape", "cycleway", "raceway", "bridleway", "proposed", "construction",
+
+                "primary", "primary_link", "secondary", "secondary_link", "tertiary", "tertiary_link",
+                "unclassified", "residential", "living_street", "service", "road", "track",
+                "steps", "path", "footway", "pedestrian");
+
+        int counter = 0;
+        for (String hw : highwayList) {
+            highwayMap.put(hw, counter++);
+        }
+
+        // set up allowed, safe, and avoided highway maps
+        String[] avoidHighwayTagsArray = {
+                // Roads
+                "motorway",
+                // Link roads
+                "motorway_link"
+        };
+        String[] allowedHighwayTagsArray = {
+                // Roads
+                "trunk", "primary", "secondary", "tertiary",
+                "unclassified", "residential", "service",
+                // Link roads
+                "trunk_link", "primary_link", "secondary_link", "tertiary_link",
+                // Special road types
+                "living_street", "pedestrian", "track", "bus_guideway", "escape", "raceway", "road",
+                // Paths
+                "footway", "bridleway", "steps", "path", "cycleway",
+                // Lifecycle
+                "proposed", "construction"
+        };
+
+        // Original: [path, residential, service, footway, pedestrian, living_street, track, steps]
+        safeHighwayTags.clear();
+        safeHighwayTags.add("living_street");
+        safeHighwayTags.add("pedestrian");
+        safeHighwayTags.add("footway");
+        safeHighwayTags.add("path");
+        safeHighwayTags.add("track");
+        safeHighwayTags.add("residential");
+
+        allowedHighwayTags.clear();
+        for (String current: allowedHighwayTagsArray)
+            allowedHighwayTags.add(current);
+
+        avoidHighwayTags.clear();
+        for (String current: avoidHighwayTagsArray)
+            avoidHighwayTags.add(current);
+    }
+
+    final int DEFAULT_CROSSING_SCORE = 0;
+    final int DEFAULT_SURFACE_SCORE = 0;
+    final int DEFAULT_SIDEWALK_SCORE = 0;
+    final int DEFAULT_TRACKTYPE_SCORE = 1;
+
+    protected void initSurfaceProperty(){
+
+        // https://wiki.openstreetmap.org/wiki/Key:surface
+        surfaceTypes = new HashSet<String>(){{
+            // official
+            add("paved");add("unpaved");add("asphalt");add("concrete");
+            add("paving_stones");add("cobblestone");add("sett");
+            add("metal");add("wood");add("compacted");add("fine_gravel");add("gravel");add("pebblestone");
+            add("grass_paver");add("grass");add("dirt");add("earth");add("mud");add("ground");add("sand");
+            // unofficial
+            add("tarmac");add("bricks");add("brick");add("clay");add("grit");add("stone");add("tartan");
+            add("woodchips");add("tiles");
+        }};
+
+        designatedSurfaceTypes = new HashSet<String>(){
+            {
+                add("paved");
+                add("asphalt");
+                add("concrete");
+                add("tarmac");
+                add("metal");
+                add("wood");
+                add("compacted");
+                add("fine_gravel");
+                add("unpaved");
+                add("grass_paver");
+                add("grass");
+                add("earth");
+                add("ground");
+                add("grit");
+            }};
+        accessibleSurfaceTypes = new HashSet<String>(){
+            {
+                add("bricks");
+                add("brick");
+                add("stone");
+                add("tartan");
+                add("woodchips");
+                add("tiles");
+                add("pebblestone");
+                add("cobblestone");
+                add("sett");
+            }};
+        avoidedSurfaceTypes = new HashSet<String>(){
+            {
+                add("clay");
+                add("gravel");
+                add("mud");
+                add("sand");
+                add("dirt");
+            }};
+
+        grassSurfaceTypes = new HashSet<String>(){
+            { add("grass"); add("earth");}};
+        parkSurfaceTypes = new HashSet<String>(){
+            { add("ground");add("unpaved");add("fine_gravel");add("compacted"); }};
+        pavementSurfaceTypes = new HashSet<String>(){
+            { add("concrete");add("asphalt");add("paved");add("bricks");add("tartan");add("brick"); }};
+        sandSurfaceTypes = new HashSet<String>(){
+            { add("gravel");add("sand");add("dirt");add("mud");add("clay"); }};
+
+
+
+
+
+
+    }
+
+    protected void initSidewalkProperty(){
+        // https://wiki.openstreetmap.org/wiki/Key:sidewalk
+        sidewalkTypes = new HashSet<String>(){{
+            // official
+            add("no");add("left");add("right");add("both");
+            add("separate");add("none");add("yes");
+            // unofficial
+            add("shared");
+        }};
+    }
+
+    protected void initTrackTypeProperty(){
+        // https://wiki.openstreetmap.org/wiki/Key:tracktype
+        trackType = new HashSet<String>(){{
+            add("grade1");add("grade2");add("grade3");add("grade4");add("grade5");
+        }};
+    }
+
+    protected void initCrossingProperty(){
+        // https://wiki.openstreetmap.org/wiki/Approved_features/Road_crossings
+        crossingTypes = new HashSet<String>(){{
+            // official
+            add("traffic_signals");add("uncontrolled");add("unmarked");add("island");add("no");
+            // unofficial
+            add("zebra");add("toucan");add("pelican");add("traffic_lights");add("pedestrian_signals");add("yes");
+        }};
+
+        designatedCrossingTypes = new HashSet<String>(){
+            {
+                add("uncontrolled");
+                add("traffic_signals");
+                add("zebra");
+                add("toucan");
+                add("pelican");
+                add("pedestrian_signals");
+            }};
+
+        accessibleCrossingTypes = new HashSet<String>(){
+            {
+                add("unmarked");
+                add("yes");
+                add("island");
+                add("traffic_lights");
+            }};
+
+        avoidedCrossingTypes = new HashSet<String>(){
+            {
+                add("no");
+            }};
+
+
+
+    }
+
+    protected int getSurfaceScore(ReaderWay way){
+        String surface = way.getTag("surface");
+
+        if (surface!=null){
+            if (designatedSurfaceTypes.contains(surface))
+                return 2;
+            if (accessibleSurfaceTypes.contains(surface))
+                return 1;
+            else
+                return 0;
+        }
+        return DEFAULT_SURFACE_SCORE;
+    }
+
+    protected int getSidewalkScore(ReaderWay way){
+        String sidewalk = way.getTag("sidewalk");
+
+        // left, right, both, yes, separate, none, no, shared
+        if (sidewalk!=null){
+            if (sidewalk.equalsIgnoreCase("both"))
+                return 2;
+            if ((sidewalk.equalsIgnoreCase("yes")) ||
+                    (sidewalk.equalsIgnoreCase("left")) ||
+                    (sidewalk.equalsIgnoreCase("right")) ||
+                    (sidewalk.equalsIgnoreCase("separate")))
+                return 1;
+            else
+                return 0;
+        }
+        return DEFAULT_SIDEWALK_SCORE;
+    }
+
+    protected int getTrackTypeScore(ReaderWay way){
+        String tracktype = way.getTag("tracktype");
+
+        if (tracktype!=null){
+            if ((tracktype.equalsIgnoreCase("grade1")) ||
+                    (tracktype.equalsIgnoreCase("grade2")))
+                return 2;
+            if ((tracktype.equalsIgnoreCase("grade3")) ||
+                    (tracktype.equalsIgnoreCase("grade4")))
+                return 1;
+            else
+                return 0;
+        }
+        return DEFAULT_TRACKTYPE_SCORE;
+    }
+
+    protected int getCrossingScore(ReaderWay way){
+        String crossing = way.getTag("crossing");
+
+        if (crossing!=null){
+            if (designatedCrossingTypes.contains(crossing))
+                return 2;
+            if (accessibleCrossingTypes.contains(crossing))
+                return 1;
+            else
+                return 0;
+        }
+        return DEFAULT_CROSSING_SCORE;
+    }
+
+    protected int getQualityScore(ReaderWay way){
+        int surfaceScore = getSurfaceScore(way);
+        int sidewalkScore = getSidewalkScore(way);
+        int tracktypeScore = getTrackTypeScore(way);
+        int crossingScore = getCrossingScore(way);
+
+        return (surfaceScore+sidewalkScore+tracktypeScore+crossingScore);
+    }
+
+
+
+
+
+
+    @Override
+    public double getTurnCost(long flag) {
+        return 0;
+    }
+
+
+    /**
+     * Some ways are okay but not separate for pedestrians.
+     * <p>
+     */
+    @Override
+    public long acceptWay(ReaderWay way) {
+
+        String highwayValue = way.getTag("highway");
+
+        if (highwayValue == null) {
+
+            // Rules for ways that are not highways
+            // TODO: Disable ferries, trains, and public transportation
+            long acceptPotentially = 0;
+
+            if (way.hasTag("route", ferries)) {
+                String footTag = way.getTag("foot");
+                if (footTag == null || "yes".equals(footTag))
+                    acceptPotentially = acceptBit | ferryBit;
+            }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                acceptPotentially = acceptBit;
+
+            if (way.hasTag("man_made", "pier"))
+                acceptPotentially = acceptBit;
+
+            if (acceptPotentially != 0) {
+                if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+                    return 0;
+                return acceptPotentially;
+            }
+
+            return 0;
+        }
+
+        String sacScale = way.getTag("sac_scale");
+        if (sacScale != null) {
+            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
+                    && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
+                // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+                return 0;
+        }
+
+        // no need to evaluate ferries or fords - already included here
+        if (way.hasTag("foot", intendedValues))
+            return acceptBit;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+            return 0;
+
+        if (way.hasTag("sidewalk", sidewalkValues))
+            return acceptBit;
+
+        if (!allowedHighwayTags.contains(highwayValue))
+            return 0;
+
+        if (way.hasTag("motorroad", "yes"))
+            return 0;
+
+        // do not get our feet wet, "yes" is already included above
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
+            return 0;
+
+        if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
+            return 0;
+
+        return acceptBit;
+
+    }
+
+    @Override
+    public int defineWayBits(int index, int shift) {
+
+        shift = super.defineWayBits(index, shift);
+
+        beautyEncoder = new EncodedDoubleValue("Nature", shift, 16, 0.001, 0, MAX_BEAUTY);
+        shift += beautyEncoder.getBits();
+
+        highwayTypeEncoder = new EncodedValue("highway", shift, 5, 1, 0, highwayMap.size(), true);
+        shift += highwayTypeEncoder.getBits();
+
+        OSMWayIdEncoder = new EncodedValue("wayid", shift, 24, 1, 0, 8388608);
+        shift += OSMWayIdEncoder.getBits();
+
+        qualityHighwayEncoder = new EncodedValue("quality", shift, 4, 1, 0, 15, true);
+        shift += qualityHighwayEncoder.getBits();
+
+
+        surfaceHighwayEncoder = new EncodedValue("surface", shift, 3, 1, 0, 7, true);
+        shift += qualityHighwayEncoder.getBits();
+
+
+        return shift;
+    }
+
+    @Override
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags){
+
+        long flags = super.handleWayTags(way, allowed, relationFlags);
+
+        double nature = this.getCustomWeightByWayId(way.getId(), "nature");
+
+        flags = beautyEncoder.setDoubleValue(flags, nature);
+        // HIGHWAY
+        int hwValue = getHighwayType(way);
+        flags = highwayTypeEncoder.setValue(flags, hwValue);
+
+        // WAYID
+        idx2OSMWayId.put(new Long(idx), new Long(way.getId()));
+        flags = OSMWayIdEncoder.setValue(flags, idx);
+        idx++;
+
+        // QUALITY
+        flags = qualityHighwayEncoder.setValue(flags, getQualityScore(way));
+
+
+        return flags;
+    }
+
+    void collect(ReaderWay way, TreeMap<Double, Integer> weightToPrioMap) {
+        super.collect(way, weightToPrioMap);
+
+        // TODO modify the priority according to the highways rules defined in the survey
+
+//        String highway = way.getTag("highway");
+//
+//        if (way.hasTag("foot", "designated"))
+//            weightToPrioMap.put(100d, PREFER.getValue());
+//
+//        double maxSpeed = getMaxSpeed(way);
+//        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20) {
+//            weightToPrioMap.put(40d, PREFER.getValue());
+//            if (way.hasTag("tunnel", intendedValues)) {
+//                if (way.hasTag("sidewalk", sidewalksNoValues))
+//                    weightToPrioMap.put(40d, AVOID_IF_POSSIBLE.getValue());
+//                else
+//                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+//            }
+//        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway)) {
+//            if (!way.hasTag("sidewalk", sidewalkValues))
+//                weightToPrioMap.put(45d, AVOID_IF_POSSIBLE.getValue());
+//        }
+//
+//        if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
+//            weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
+
+    }
+
+    public double getBeautyScore(EdgeIteratorState edge) {
+        long flags = edge.getFlags();
+        return beautyEncoder.getDoubleValue(flags);
+    }
+
+    public long getQualityScore(EdgeIteratorState edge){
+        long flags = edge.getFlags();
+        return qualityHighwayEncoder.getValue(flags);
+    }
+
+    public long getOSMWayId(EdgeIteratorState edge) {
+        long flags = edge.getFlags();
+        long current = OSMWayIdEncoder.getValue(flags);
+        return idx2OSMWayId.get(current);
+    }
+
+    public String getHighwayTypeString(Integer code){
+
+        String key= null;
+
+        for(Map.Entry entry: highwayMap.entrySet()){
+            if(code.equals(entry.getValue())) {
+                key = (String) entry.getKey();
+                break; //breaking because its one to one map
+            }
+        }
+        return key;
+    }
+
+    public int getHighwayType(EdgeIteratorState edge) {
+        return (int) highwayTypeEncoder.getValue(edge.getFlags());
+    }
+
+    private int getHighwayType(ReaderWay way) {
+        String highwayValue = way.getTag("highway");
+
+        Integer hwValue = highwayMap.get(highwayValue);
+
+        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+            hwValue = 0;
+
+        if (hwValue == null)
+            return 0;
+
+        return hwValue;
+    }
+
+    // Weights
+
+//      SENSORY
+    private final short SMELL_WEIGHT_INDEX = 3;
+    private final short SOUND_WEIGHT_INDEX = 2;
+    private final short VISUAL_WEIGHT_INDEX = 1;
+
+    private final short DEFAULT_SMELL_WEIGHT = 0;
+    private final short DEFAULT_SOUND_WEIGHT = 0;
+    private final short DEFAULT_VISUAL_WEIGHT = 0;
+
+//      FACILITIES, SAFETY, CRIME
+
+    private final short CRIME_WEIGHT_INDEX = 10;
+    private final short SAFETY_WEIGHT_INDEX = 10;
+    private final short FACILITIES_WEIGHT_INDEX = 10;
+
+//    Facilities [0,+3]
+//    drinking water (+1)
+//    benches (+1)
+//    toilets (+1)
+
+//    Safety features [0,+3]
+//    light (+1)
+//    lit
+//    highway = street_lamp
+//    phones (+1)
+//    emergency:phone/rescue_box
+//    amenity:telephone
+//    police -in a certain range- (+1)
+//    amenity:police
+
+
+//      OBSTACLES
+
+//    Obstacles [-2,+9]
+//    sidewalk (-1,+1)
+//    surface (-1,+1)
+//    crossing (0,+2)
+//    tracktype (0,+5)
+
+
+
+
+
+
+    private void loadCustomWeights() {
+        System.out.println("loadCustomWeights");
+
+        HashMap<String, Double> tagsHashMap;
+
+        try {
+
+            File inputF = new File("data/weights/london_happy_maps_norms.csv");
+            InputStream inputFS = new FileInputStream(inputF);
+            BufferedReader br = new BufferedReader(new InputStreamReader(inputFS));
+
+            long wayid, nWayIds=0;
+            double nature;
+
+            // skip header
+//          String header = br.readLine();
+            String line = br.readLine();
+
+            while (line != null) {
+
+                String[] tt = line.split(",");
+
+                try {
+                    wayid = Long.valueOf(tt[0]);
+                    nature = Double.valueOf(tt[1]);
+
+                    tagsHashMap = new HashMap<String, Double>();
+                    tagsHashMap.put("nature", nature);
+                    this.getCustomWeights().put(wayid, tagsHashMap);
+
+                    nWayIds+=1;
+
+                } catch (NumberFormatException e) {
+                    System.out.println(e.getMessage());
+                }
+
+                line = br.readLine();
+            }
+
+            System.out.printf("Read %d custom weights wayids\n",nWayIds);
+
+            br.close();
+            inputFS.close();
+
+        } catch (FileNotFoundException e) {
+            System.out.println(e.getMessage());
+        } catch (IOException e) {
+            System.out.println(e.getMessage());
+        }
+
+    }
+
+    private Map<String, Double> getCustomWeightsByWayId(long wayid) {
+        return this.getCustomWeights().get(new Long(wayid));
+    }
+
+    private Double getCustomWeightByWayId(long wayid, String key) {
+
+        Map<String, Double> wayidInfo = this.getCustomWeightsByWayId(wayid);
+
+        if (wayidInfo!=null)
+            return wayidInfo.get(key);
+        else
+            return (double)0;
+    }
+
+    private Map<Long, Map<String, Double>> getCustomWeights() {
+        return wayid2weights;
+    }
+
+
+    @Override
+    public String toString() {
+        return "running";
+    }
+
+
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java
deleted file mode 100644
index 41a5709a40..0000000000
--- a/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.graphhopper.routing.weighting;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.HappyMapsFlagEncoder;
-import com.graphhopper.util.EdgeIteratorState;
-
-
-public class HappyMapsWeighting extends PriorityWeighting {
-
-    private final HappyMapsFlagEncoder happymapsFlagEncoder;
-
-
-    public HappyMapsWeighting(FlagEncoder flagEncoder) {
-
-        super(flagEncoder);
-
-        happymapsFlagEncoder = (HappyMapsFlagEncoder) flagEncoder;
-    }
-
-    @Override
-    public double getMinWeight(double currDistToGoal) {
-        return currDistToGoal;
-    }
-
-    @Override
-    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
-
-        double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
-
-        double sensorial = happymapsFlagEncoder.getBeautyScore(edgeState);
-        long quality = happymapsFlagEncoder.getQualityScore(edgeState);
-
-        if (Double.isInfinite(weight))
-            return Double.POSITIVE_INFINITY;
-
-//        return weight / (sensorial + quality + flagEncoder.getDouble(edgeState.getFlags(), KEY));
-        return weight / (sensorial + flagEncoder.getDouble(edgeState.getFlags(), KEY));
-    }
-
-    @Override
-    public String getName() {
-        return "happymaps";
-    }
-
-}
-
-
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/MindfulWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/MindfulWeighting.java
new file mode 100644
index 0000000000..a85ff42144
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/MindfulWeighting.java
@@ -0,0 +1,89 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.RunningFlagEncoder;
+import com.graphhopper.routing.util.TurnCostEncoder;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+
+
+public class MindfulWeighting extends PriorityWeighting {
+
+    private final RunningFlagEncoder runningFlagEncoder;
+    private final TurnCostEncoder turnCostEncoder;
+    private final TurnCostExtension turnCostExt=null;
+
+    private String prevName;
+
+
+    public MindfulWeighting(FlagEncoder flagEncoder) {
+
+        super(flagEncoder);
+
+        this.turnCostEncoder = flagEncoder;
+//        this.turnCostExt = turnCostExt;
+
+        runningFlagEncoder = (RunningFlagEncoder) flagEncoder;
+    }
+
+    @Override
+    public double getMinWeight(double currDistToGoal) {
+        return currDistToGoal;
+    }
+
+
+    /**
+     * This method calculates the turn weight separately.
+     */
+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+        System.out.println(turnCostExt.getClass().getName());
+//        if (turnCostEncoder.isTurnRestricted(turnFlags))
+//            return Double.POSITIVE_INFINITY;
+
+        return turnCostEncoder.getTurnCost(turnFlags);
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+
+        double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        double turnCost = 0;
+
+        String currentName = edgeState.getName();
+        if (!currentName.equals(prevName)) {
+            turnCost = 0;
+            prevName = currentName;
+        }
+
+//        System.out.println(currentName+" "+prevName);
+
+
+
+//        System.out.println(edgeState.fetchWayGeometry(1));
+//        System.out.println(edgeState.getClass().getName());
+//        int edgeId = edgeState.getEdge();
+//        System.out.println(edgeId+" "+edgeState.getBaseNode()+" " + prevOrNextEdgeId);
+
+
+//        int edgeId = edgeState.getEdge();
+//        double turnCosts = calcTurnWeight(edgeId, edgeState.getBaseNode(), prevOrNextEdgeId);
+
+        double sensorial = runningFlagEncoder.getBeautyScore(edgeState);
+        long quality = runningFlagEncoder.getQualityScore(edgeState);
+
+        if (Double.isInfinite(weight))
+            return Double.POSITIVE_INFINITY;
+
+//        return weight / (sensorial + quality + flagEncoder.getDouble(edgeState.getFlags(), KEY));
+        return weight / (sensorial + flagEncoder.getDouble(edgeState.getFlags(), KEY)) + turnCost;
+    }
+
+    @Override
+    public String getName() {
+        return "mindful";
+    }
+
+}
+
+
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/VibrantWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/VibrantWeighting.java
new file mode 100644
index 0000000000..09b1528b0d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/VibrantWeighting.java
@@ -0,0 +1,89 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.RunningFlagEncoder;
+import com.graphhopper.routing.util.TurnCostEncoder;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+
+
+public class VibrantWeighting extends PriorityWeighting {
+
+    private final RunningFlagEncoder runningFlagEncoder;
+    private final TurnCostEncoder turnCostEncoder;
+    private final TurnCostExtension turnCostExt=null;
+
+    private String prevName;
+
+
+    public VibrantWeighting(FlagEncoder flagEncoder) {
+
+        super(flagEncoder);
+
+        this.turnCostEncoder = flagEncoder;
+//        this.turnCostExt = turnCostExt;
+
+        runningFlagEncoder = (RunningFlagEncoder) flagEncoder;
+    }
+
+    @Override
+    public double getMinWeight(double currDistToGoal) {
+        return currDistToGoal;
+    }
+
+
+    /**
+     * This method calculates the turn weight separately.
+     */
+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+        System.out.println(turnCostExt.getClass().getName());
+//        if (turnCostEncoder.isTurnRestricted(turnFlags))
+//            return Double.POSITIVE_INFINITY;
+
+        return turnCostEncoder.getTurnCost(turnFlags);
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+
+        double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        double turnCost = 0;
+
+        String currentName = edgeState.getName();
+        if (!currentName.equals(prevName)) {
+            turnCost = 10;
+            prevName = currentName;
+        }
+
+//        System.out.println(currentName+" "+prevName);
+
+
+
+//        System.out.println(edgeState.fetchWayGeometry(1));
+//        System.out.println(edgeState.getClass().getName());
+//        int edgeId = edgeState.getEdge();
+//        System.out.println(edgeId+" "+edgeState.getBaseNode()+" " + prevOrNextEdgeId);
+
+
+//        int edgeId = edgeState.getEdge();
+//        double turnCosts = calcTurnWeight(edgeId, edgeState.getBaseNode(), prevOrNextEdgeId);
+
+        double sensorial = runningFlagEncoder.getBeautyScore(edgeState);
+        long quality = runningFlagEncoder.getQualityScore(edgeState);
+
+        if (Double.isInfinite(weight))
+            return Double.POSITIVE_INFINITY;
+
+//        return weight / (sensorial + quality + flagEncoder.getDouble(edgeState.getFlags(), KEY));
+        return weight / (sensorial + flagEncoder.getDouble(edgeState.getFlags(), KEY)) + turnCost;
+    }
+
+    @Override
+    public String getName() {
+        return "vibrant";
+    }
+
+}
+
+
diff --git a/core/src/main/java/com/graphhopper/util/details/HighwayDetails.java b/core/src/main/java/com/graphhopper/util/details/HighwayDetails.java
index a92787be1e..1eecfd7037 100644
--- a/core/src/main/java/com/graphhopper/util/details/HighwayDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/HighwayDetails.java
@@ -1,7 +1,7 @@
 package com.graphhopper.util.details;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.HappyMapsFlagEncoder;
+import com.graphhopper.routing.util.RunningFlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 
 import static com.graphhopper.util.Parameters.DETAILS.HIGHWAY;
@@ -9,12 +9,12 @@
 public class HighwayDetails extends AbstractPathDetailsBuilder {
 
     private int highway = -1;
-    private final HappyMapsFlagEncoder encoder;
+    private final RunningFlagEncoder encoder;
 
     public HighwayDetails(FlagEncoder encoder) {
 
         super(HIGHWAY);
-        this.encoder = (HappyMapsFlagEncoder) encoder;
+        this.encoder = (RunningFlagEncoder) encoder;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/util/details/WayidDetails.java b/core/src/main/java/com/graphhopper/util/details/WayidDetails.java
index a70c683fea..2c62f96fa7 100644
--- a/core/src/main/java/com/graphhopper/util/details/WayidDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/WayidDetails.java
@@ -1,7 +1,7 @@
 package com.graphhopper.util.details;
 
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.HappyMapsFlagEncoder;
+import com.graphhopper.routing.util.RunningFlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 
 import static com.graphhopper.util.Parameters.DETAILS.WAYID;
@@ -9,12 +9,12 @@
 public class WayidDetails extends AbstractPathDetailsBuilder {
 
     private long wayid = -1;
-    private final HappyMapsFlagEncoder encoder;
+    private final RunningFlagEncoder encoder;
 
     public WayidDetails(FlagEncoder encoder) {
 
         super(WAYID);
-        this.encoder = (HappyMapsFlagEncoder) encoder;
+        this.encoder = (RunningFlagEncoder) encoder;
     }
 
     @Override
