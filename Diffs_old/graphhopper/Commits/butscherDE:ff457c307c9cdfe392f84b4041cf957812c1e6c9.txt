diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index d44408b4c7..ee2c8c2929 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -6,15 +6,12 @@
 import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidateList;
 import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidatePolygon;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.Translation;
-import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index b2f4e3d192..9a8e445b9b 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -5,7 +5,6 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.polygonRoutingUtil.*;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
@@ -18,8 +17,8 @@
 import java.util.*;
 
 public class PolygonThroughRoutingTemplate extends PolygonRoutingTemplate {
-    private OneToManyRouting dijkstraForLOTNodes;
-    private ManyToManyRouting dijkstraForPathSkeleton;
+    private OneToManyRouting lotNodeRouter;
+    private ManyToManyRouting pathSkeletonRouter;
     private List<Integer> nodesInPolygon;
 
     public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
@@ -35,8 +34,8 @@ protected RouteCandidateList findCandidateRoutes() {
         this.nodesInPolygon = getNodesInPolygon();
         List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
         List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
-        this.dijkstraForPathSkeleton = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, this.algoFactory, this.algorithmOptions);
-        this.dijkstraForPathSkeleton.findPathBetweenAllNodePairs();
+        this.pathSkeletonRouter = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, this.algoFactory, this.algorithmOptions);
+        this.pathSkeletonRouter.findPathBetweenAllNodePairs();
 
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
             buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
@@ -83,12 +82,15 @@ private RouteCandidatePolygon buildCandidatePath(int currentPointID, int nextPoi
     }
 
     private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
+        System.out.println(point.getClosestNode());
         Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
         addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
 
         List<Integer> thisPointLOTNodeList = LOTNodes.get(LOTNodes.size() - 1);
         int i = 0;
         do {
+
+
             int entryExitPoint = thisPointLOTNodeList.get(i);
             boolean betterFound = checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
 
@@ -142,9 +144,9 @@ private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List
 
     private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
         final int fromNode = point.getClosestNode();
-        this.dijkstraForLOTNodes = new OneToManyRouting(fromNode, polygonEntryExitPoints, this.nodesInPolygon, this.queryGraph, this.algoFactory, this.algorithmOptions);
-        this.dijkstraForLOTNodes.findPathBetweenAllNodePairs();
-        final List<Path> allFoundPaths = this.dijkstraForLOTNodes.getAllFoundPaths();
+        this.lotNodeRouter = new OneToManyRouting(fromNode, polygonEntryExitPoints, this.nodesInPolygon, this.queryGraph, this.algoFactory, this.algorithmOptions);
+        this.lotNodeRouter.findPathBetweenAllNodePairs();
+        final List<Path> allFoundPaths = this.lotNodeRouter.getAllFoundPaths();
 
         final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<>();
         for (int i = 0; i < polygonEntryExitPoints.size(); i++) {
@@ -190,7 +192,7 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
     }
 
     public ManyToManyRouting getPathSkeletonRouter() {
-        return this.dijkstraForPathSkeleton;
+        return this.pathSkeletonRouter;
     }
 
     private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractor.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractor.java
new file mode 100644
index 0000000000..341564db37
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractor.java
@@ -0,0 +1,118 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import javafx.util.Pair;
+
+import java.util.*;
+
+/**
+ * Takes a set of polygon entry exit points as well as a set of via routing points and extracts the local optimal touch nodes for each point.
+ */
+public class LOTNodeExtractor {
+    private final Graph graph;
+    private final RoutingAlgorithmFactory routingAlgorithmFactory;
+    private final AlgorithmOptions algorithmOptions;
+    private final EdgeExplorer edgeExplorer;
+    private final List<Integer> viaPoints;
+    private final List<Integer> entryExitPoints;
+    private final Map<Integer, List<Integer>> viaPointToLOTNodes;
+    private final Map<Pair<Integer, Integer>, Double> viaPointToEntryExitPointDistances;
+
+    private LOTNodeExtractor(final Graph graph, final RoutingAlgorithmFactory routingAlgorithmFactory, final AlgorithmOptions algorithmOptions, final EdgeExplorer edgeExplorer,
+                             final List<Integer> viaPoints, final List<Integer> entryExitPoints) {
+        this.graph = graph;
+        this.routingAlgorithmFactory = routingAlgorithmFactory;
+        this.algorithmOptions = algorithmOptions;
+        this.edgeExplorer = edgeExplorer;
+        this.viaPoints = viaPoints;
+        this.entryExitPoints = entryExitPoints;
+        this.viaPointToLOTNodes = new HashMap<>();
+        this.viaPointToEntryExitPointDistances = new HashMap<>();
+
+        this.extractData();
+    }
+
+    public static LOTNodeExtractor createExtractedData(final Graph graph, final RoutingAlgorithmFactory routingAlgorithmFactory, final AlgorithmOptions algorithmOptions,
+                                                       final EdgeExplorer edgeExplorer, final List<Integer> viaPoints, final List<Integer> entryExitPoints) {
+        return new LOTNodeExtractor(graph, routingAlgorithmFactory, algorithmOptions, edgeExplorer, viaPoints, entryExitPoints);
+    }
+
+    private void extractData() {
+        this.saveDistancesBetweenAllViaPointsAndEntryExitPoints();
+        this.saveLOTNodesForEachViaPoint();
+    }
+
+    private void saveDistancesBetweenAllViaPointsAndEntryExitPoints() {
+        for (final int viaPoint : this.viaPoints) {
+            for (final int entryExitPoint : this.entryExitPoints) {
+                saveDistanceBetween(viaPoint, entryExitPoint);
+            }
+        }
+    }
+
+    private void saveDistanceBetween(final int viaPoint, final int entryExitPoint) {
+        final double distance = this.calcDistanceBetween(viaPoint, entryExitPoint);
+        this.viaPointToEntryExitPointDistances.put(new Pair<>(viaPoint, entryExitPoint), distance);
+    }
+
+    private double calcDistanceBetween(final int viaPoint, final int entryExitPoint) {
+        final RoutingAlgorithm routingAlgorithm = this.routingAlgorithmFactory.createAlgo(graph, algorithmOptions);
+        final Path path = routingAlgorithm.calcPath(viaPoint, entryExitPoint);
+        return path.getDistance();
+    }
+
+    private void saveLOTNodesForEachViaPoint() {
+        for (final int viaPoint : this.viaPoints) {
+            this.saveLOTNodesFor(viaPoint);
+        }
+    }
+
+    private void saveLOTNodesFor(final int viaPoint) {
+        final List<Integer> lotNodes = createLotNodesFor(viaPoint);
+
+        this.viaPointToLOTNodes.put(viaPoint, lotNodes);
+    }
+
+    private List<Integer> createLotNodesFor(final int viaPoint) {
+        final List<Integer> lotNodes = new ArrayList<>(entryExitPoints.size());
+
+        for (final int possibleLotNode : this.entryExitPoints) {
+            if (hasPossibleLotNodeShorterDistanceNeighbor(viaPoint, possibleLotNode)) {
+                lotNodes.add(possibleLotNode);
+            }
+        }
+
+        return lotNodes;
+    }
+
+    private boolean hasPossibleLotNodeShorterDistanceNeighbor(final int viaPoint, final int possibleLotNode) {
+        final EdgeIterator neighborIterator = this.edgeExplorer.setBaseNode(possibleLotNode);
+        boolean betterNeighborFound = false;
+        final double distanceOfThisPossibleLotNode = this.viaPointToEntryExitPointDistances.get(new Pair<>(viaPoint, possibleLotNode));
+
+        while (neighborIterator.next()) {
+            final int neighbor = neighborIterator.getAdjNode();
+            final Double otherDistance = this.viaPointToEntryExitPointDistances.get(new Pair<>(viaPoint, neighbor));
+
+            if (otherDistance != null) {
+                betterNeighborFound |= distanceOfThisPossibleLotNode > otherDistance;
+            }
+        }
+
+        return betterNeighborFound;
+    }
+
+    public List<Integer> getLotNodesFor(final int viaPoint) {
+        return this.viaPointToLOTNodes.get(viaPoint);
+    }
+
+    public int size() {
+        return this.viaPointToLOTNodes.size();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
index a7d2b15973..aabd82c15e 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -3,6 +3,7 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.StopWatch;
 import javafx.util.Pair;
 
 import java.util.ArrayList;
@@ -29,6 +30,7 @@ public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<In
 
     void calculatePaths() {
         for (final int toNode : toNodes) {
+            System.out.println("to: " + toNode);
             final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
             final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
             this.allFoundPaths.put(new Pair(this.fromNode, toNode), path);
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java
new file mode 100644
index 0000000000..622805110f
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java
@@ -0,0 +1,5 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+public class LOTNodeExtractorTest {
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
index 0e915dabad..2827541d7b 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
@@ -18,10 +18,11 @@
 import static org.junit.Assert.assertEquals;
 
 public class RouteCandidateListTest {
+    private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
     private final RouteCandidateList<RouteCandidateMocker> candidateList = new RouteCandidateList<>();
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double [] {5, 10, 10, 5}, new double [] {5, 5, 10, 10}));
-    private final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, null, null, null, null);
-    private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
+    private final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, graphMocker.locationIndex, graphMocker.nodeAccess,
+                                                                                                    graphMocker.graph,graphMocker.encodingManager);
 
     private void addTestingCandidates() {
         this.candidateList.getCandidates().clear();
