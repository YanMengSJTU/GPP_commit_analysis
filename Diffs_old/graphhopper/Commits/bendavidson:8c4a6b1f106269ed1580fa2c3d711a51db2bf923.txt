diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 7dc60d34db..53172cf7be 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -24,9 +24,15 @@ appear on your fork its github page afterwards.
 
 ## License Agreement
 
-For contributions like pull requests, bug fixes and translations please read and electronically sign 
-the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>,
-which gives not away your rights but it will make sure for others that you agree to the Apache License, Version 2.
+For contributions like pull requests, bug fixes and translations please read 
+the <a href="https://graphhopper.com/agreements/individual-cla.html">GraphHopper License Agreement</a>, which includes our
+<a href="https://graphhopper.com/agreements/cccoc.html">contributor covenant code of conduct</a>.
+<a href="https://graphhopper.com/#contact">Send us</a> an email with the signed print out of this CLA. Or, if you prefer
+the faster electronically method via signaturit.com, please send us an email with a request for this - 
+keep in mind that this requires storing your Email there. The same applies if you want to sign a CLA for your whole company.
+
+Note, our CLA does not influence your rights on your contribution but it makes sure for others that you agree to the Apache License, Version 2.
+After this you'll appear in the <a href="CONTRIBUTORS.md">contributors list</a> and you pull request can be also technically discussed.
 
 ## Syntax:
 
diff --git a/README.md b/README.md
index 8703f92428..f5152d41f6 100644
--- a/README.md
+++ b/README.md
@@ -5,8 +5,7 @@
 GraphHopper is a fast and memory efficient Java road routing engine released under Apache License 2.0.
 Per default it uses OpenStreetMap data but can import other data sources.
 
-GraphHopper for the Web
---------------
+## GraphHopper for the Web
 
 See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
 
@@ -19,63 +18,106 @@ where the default is [Omniscale](http://omniscale.com/), and all is available fo
 for a nice and private route planning experience!
 
 
-GraphHopper for Mobile
----------------
+## GraphHopper for Mobile
 
 There are subprojects to make GraphHopper working offline
 on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
 and [iOS](http://github.com/graphhopper/graphhopper-ios)
 
 
-Get Started
----------------
+## Get Started
 
-Read through our Documentation ([0.5](https://github.com/graphhopper/graphhopper/blob/0.5/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
+Read through our Documentation ([0.6](https://github.com/graphhopper/graphhopper/blob/0.6/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
 and sign up to the [discussion](https://discuss.graphhopper.com/).
 
 
-Contribute
----------------
+## Contribute
 
 Read through [how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md)
 like finding and fixing bugs and improving our documentation or translations!
 
 
-Features
----------------
+# Technical Overview
 
- * Written in Java
- * Open Source
- * Memory efficient and fast
- * Highly customizable
- * Works on the desktop, as a web service and offline on Android or iOS
- * Large test suite
-
-## Overview
-
-GraphHopper supports several algorithms like Dijkstra and A* and its bidirectional variants. 
-Furthermore it allows you to use Contraction Hierarchies (CH) very easily, we call this 
+GraphHopper supports several routing algorithms like 
+<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a> and 
+<a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A</a>`*` and its bidirectional variants. 
+Furthermore it allows you to use 
+<a href="https://en.wikipedia.org/wiki/Contraction_hierarchies">Contraction Hierarchies</a> (CH) very easily, we call this 
 **speed mode** and in contrast to the speed mode we call everything without CH the
 **flexibility mode**. BTW: This does not mean that the flexibility mode is *slow*.
 
-The speed mode comes with much faster and lightweight (less RAM) responses and it does not use heuristics.
-The downsides are that the speed mode allows only a pre-defined vehicle profile and requires a time 
-consuming and resource intense preparation. And implementing certain features are not possible or 
-very complex compared to the flexibility mode. But since 0.4 you can use both modes at the same time since. 
+The speed mode comes with much faster and lightweight (less RAM) responses and it does not use heuristics in its default settings.
+The downsides are that the speed mode allows only pre-defined vehicle profiles (multiple possible in GraphHopper) and requires a time consuming and resource intense preparation. And implementing certain features are not possible or very complex compared to the flexibility mode. Since 0.4 you can use both modes at the same time. 
 See [here](https://github.com/graphhopper/graphhopper/pull/631) for more details.
 
+## License
+
+We chose the Apache License to make it easy for you to embed GraphHopper in your products.
+We suggest to contribute back your changes, as GraphHopper will evolves fast,
+but of course this is not necessary.
+
+## OpenStreetMap Support
+
+OpenStreetMap is directly supported from GraphHopper. Without the amazing data from
+OpenStreetMap GraphHopper wouldn't be possible at all.
+Other map data will need a custom import procedure, see e.g. <a href="https://github.com/graphhopper/graphhopper/issues/277">Ordnance Survey</a>,
+<a href="https://github.com/graphhopper/graphhopper/pull/616">Shapefile like ESRI</a> or <a href="https://github.com/knowname/morituri">Navteq</a>.
+
+## Written in Java
+
+GraphHopper is written in Java and runs on Linux, Mac OS X,
+Windows, BSD, Solaris, Raspberry Pi,  Android, Blackberry and even iOS. Other 
+environments which supports at least Java 5 will work too.
+
+## Customizable
+
+We've build the GraphHopper class which makes simple things easy and complex things like multi-modal routing possible. Still you can use the low level API of GraphHopper and you'll see that
+it was created to allow fast and memory efficient use of the underlying datastructures and algorithms.
+
+### Android / Blackberry
+
+On Android and Blackberry (since 10.2.1) we provide an integration with Mapsforge which makes offline navigation one step closer.
+Due to the usage of memory mapped files and Contraction Hierarchies
+we avoid allocating too much memory which makes it possible to run Germany-wide queries with only 
+32MB in a few seconds. We provide an Android studio project as well as the Maven-Android integration to be 
+used in other IDEs.
+
+### Web UI and API
+
+With the web module we provide code to query GraphHopper over HTTP and decrease bandwidth usage as much as possible.
+For that we use the polyline encoding from Google, the Ramer–Douglas–Peucker algorithm and a simple 
+GZIP servlet filter.                 
+On the client side we provide Java and JavaScript code (via Leaflet) to consume that service and 
+visualize the routes.
+
+### Desktop
+
+GraphHopper also runs on the Desktop in a Java application without internet access.
+E.g. you could use the rough user interface called MiniGraphUI provided in the tools module, see some
+visualizations done with it [here](https://graphhopper.com/blog/2016/01/19/alternative-roads-to-rome/).
+A fast and production ready map visualization for the Desktop can be easily implemented via mapsforge.
+
+# Features
+
 Here is a list of the more detailed features including a link to the documentation:
 
- * [a web API](./docs/web/api-doc.md) including JavaScript and Java clients
- * turn instructions in more than 30 languages, contribute or improve [here](./docs/core/translations.md)
- * [including elevation](./docs/core/elevation.md) (per default disabled)
- * [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexibility only)
+ * [Simple start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
+ * Works out of the box with OpenStreetMap (osm and pbf) but can be adapted to use your own data
+ * OpenStreetMap integration: Takes care of the road type, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
+ * GraphHopper is fast. And with the so called "Contraction Hierarchies" it can be even faster (enabled by default).
+ * Memory efficient data structures, algorithms and [the low and high level API](./docs/core/low-level-api.md) is tuned towards ease of use and efficiency
+ * Provides a simple [web API](./docs/web/api-doc.md) including JavaScript and Java clients
+ * Offers turn instructions in more than 30 languages, contribute or improve [here](./docs/core/translations.md)
+ * Displays and takes into account [elevation data](./docs/core/elevation.md) (per default disabled)
+ * Can apply [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexibility only)
  * Customized routing profiles per request (flexibility only)
- * A '[heading](./docs/core/routing.md)' for start, end and via points for navigation applications via pass_through or favoredHeading parameters (flexibility only)
+ * Possibility to specify a '[heading parameter](./docs/core/routing.md)' for start, end and via points for navigation applications via `pass_through` or `favoredHeading` parameters (flexibility only)
  * [alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexibility only)
- * [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621)
  * [turn costs and restrictions](https://github.com/graphhopper/graphhopper/pull/55#issuecomment-31089096) (flexibility only)
  * multiple profiles and weightings (flexibility and speed mode since 0.5)
  * several pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle
- * [map matching](https://github.com/graphhopper/map-matching) (flexibility only)
\ No newline at end of file
+ * the core uses only a few dependencies (trove4j and slf4j)
+ * scales from small indoor- to world-wide-sized graphs
+ * [map matching component](https://github.com/graphhopper/map-matching) (flexibility only)
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index afdc193f46..2a10bea4af 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -73,7 +73,7 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "http://download2.graphhopper.com/public/maps/0.6/";
+    private String fileListURL = "http://download2.graphhopper.com/public/maps/0.7/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index cd032f0754..01a3a46fb1 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,8 +1,11 @@
+0.7
+    missing renames for Path.setEdgeEntry -> setSPTEntry and AbstractAlgorithm.createEdgeEntry -> createSPTEntry
+
 0.6
     removed methods deprecated in 0.4 and 0.5
     renamed EdgeEntry to SPTEntry and AStar.AStarEdge to AStar.AStarEntry
     parameter force removed from AbstractFlagEncoder.applyMaxSpeed
-    GHResponse now wraps multiple AltResponse; renames GraphHopper.getPaths to calcPaths as 'get' sounds too cheap; a new method RoutingAlgorithm.calcPaths is added; see #596
+    GHResponse now wraps multiple PathWrapper; renamed GraphHopper.getPaths to calcPaths as 'get' sounded too cheap; a new method RoutingAlgorithm.calcPaths is added; see #596
     moving lgpl licensed file into own submodule graphhopper-tools-lgpl
     renaming of Tarjans algorithm class to TarjansSCCAlgorithm
     more strict naming for Weighting enforced and more strict matching to select Weighting (equals check), #490
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index bcb7d833bd..03be962244 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -194,30 +194,24 @@ void preProcess( File osmFile )
                                     + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
                         }
                     }
-                } else
+                } else if (item.isType(OSMElement.RELATION))
                 {
-                    if (item.isType(OSMElement.RELATION))
-                    {
-                        final OSMRelation relation = (OSMRelation) item;
-                        if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
-                            prepareWaysWithRelationInfo(relation);
+                    final OSMRelation relation = (OSMRelation) item;
+                    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
+                        prepareWaysWithRelationInfo(relation);
 
-                        if (relation.hasTag("type", "restriction"))
-                            prepareRestrictionRelation(relation);
+                    if (relation.hasTag("type", "restriction"))
+                        prepareRestrictionRelation(relation);
 
-                        if (++tmpRelationCounter % 50000 == 0)
-                        {
-                            logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
-                                    + " " + Helper.getMemInfo());
-                        }
-                    } else
+                    if (++tmpRelationCounter % 50000 == 0)
                     {
-                        if (item.isType(OSMElement.FILEHEADER))
-                        {
-                            final OSMFileHeader fileHeader = (OSMFileHeader) item;
-                            osmDataDate = Helper.createFormatter().parse(fileHeader.getTag("timestamp"));
-                        }
+                        logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
+                                + " " + Helper.getMemInfo());
                     }
+                } else if (item.isType(OSMElement.FILEHEADER))
+                {
+                    final OSMFileHeader fileHeader = (OSMFileHeader) item;
+                    osmDataDate = Helper.createFormatter().parse(fileHeader.getTag("timestamp"));
                 }
 
             }
@@ -791,10 +785,12 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
             if (pointList.is3D())
             {
                 ele = pointList.getElevation(i);
-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+                if (!distCalc.isCrossBoundary(lon, prevLon))
+                    towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
                 prevEle = ele;
-            } else
+            } else if (!distCalc.isCrossBoundary(lon, prevLon))
                 towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+
             prevLat = lat;
             prevLon = lon;
             if (nodes > 2 && i < nodes - 1)
@@ -870,13 +866,10 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList, bool
             // convert pillarNode type to towerNode, make pillar values invalid
             pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
             tmpNode = addTowerNode(osmId, lat, lon, ele);
-        } else
-        {
-            if (pointList.is3D())
-                pointList.add(lat, lon, ele);
-            else
-                pointList.add(lat, lon);
-        }
+        } else if (pointList.is3D())
+            pointList.add(lat, lon, ele);
+        else
+            pointList.add(lat, lon);
 
         return (int) tmpNode;
     }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index ec7a9b27fb..e52b1fcf3a 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -18,19 +18,21 @@
  */
 package com.graphhopper.reader.dem;
 
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.DAType;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.*;
 import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Elevation data from NASA (SRTM).
  * <p>
@@ -77,7 +79,8 @@ public static void main( String[] args ) throws IOException
     private final double invPrecision = 1 / precision;
     // possible alternatives see #451
     // http://mirror.ufs.ac.za/datasets/SRTM3/
-    private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+    //"http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/"
+    private String baseUrl = "http://srtm.motoroute.me/SRTM3/";
     private boolean calcMean = false;
 
     public SRTMProvider()
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index bad5b815e6..c6905f049d 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -158,11 +158,11 @@ private Path runAlgo()
     @Override
     protected Path extractPath()
     {
-        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
+        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
     }
 
     @Override
-    protected SPTEntry createEdgeEntry( int node, double weight )
+    protected SPTEntry createSPTEntry( int node, double weight )
     {
         throw new IllegalStateException("use AStarEdge constructor directly");
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 3ea8b7c250..4f968807f7 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -94,7 +94,7 @@ public AStarBidirection setApproximation( WeightApproximator approx )
     }
 
     @Override
-    protected SPTEntry createEdgeEntry( int node, double weight )
+    protected SPTEntry createSPTEntry( int node, double weight )
     {
         throw new IllegalStateException("use AStarEdge constructor directly");
     }
@@ -125,7 +125,7 @@ public void initFrom( int from, double weight )
             if (currTo != null && currTo.adjNode == from)
             {
                 // special case of identical start and end
-                bestPath.edgeEntry = currFrom;
+                bestPath.sptEntry = currFrom;
                 bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
@@ -159,7 +159,7 @@ public void initTo( int to, double weight )
             if (currFrom != null && currFrom.adjNode == to)
             {
                 // special case of identical start and end
-                bestPath.edgeEntry = currFrom;
+                bestPath.sptEntry = currFrom;
                 bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
@@ -314,7 +314,7 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEntry entryCurrent
         if (newWeight < bestPath.getWeight())
         {
             bestPath.setSwitchToFrom(reverse);
-            bestPath.edgeEntry = entryCurrent;
+            bestPath.sptEntry = entryCurrent;
             bestPath.edgeTo = entryOther;
             bestPath.setWeight(newWeight);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index b06af723f0..23f38bb824 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -80,7 +80,7 @@ protected boolean accept( EdgeIterator iter, int prevOrNextEdgeId )
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);
     }
 
-    protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry bestEdgeEntry, int traversalId )
+    protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry bestSPTEntry, int traversalId )
     {
     }
 
@@ -92,7 +92,7 @@ protected void checkAlreadyRun()
         alreadyRun = true;
     }
 
-    protected SPTEntry createEdgeEntry( int node, double weight )
+    protected SPTEntry createSPTEntry( int node, double weight )
     {
         return new SPTEntry(EdgeIterator.NO_EDGE, node, weight);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index b04d05881b..158bc8a46d 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -355,49 +355,49 @@ public Path searchBest( int to, int from )
                     plateauInfluence, bestPlateau);
 
             final AlternativeInfo bestAlt = new AlternativeInfo(sortBy, bestPath,
-                    bestPath.edgeEntry, bestPath.edgeTo, bestShare, getAltNames(graph, bestPath.edgeEntry));
+                    bestPath.sptEntry, bestPath.edgeTo, bestShare, getAltNames(graph, bestPath.sptEntry));
             alternatives.add(bestAlt);
             final List<SPTEntry> bestPathEntries = new ArrayList<SPTEntry>(2);
 
             bestWeightMapFrom.forEachEntry(new TIntObjectProcedure<SPTEntry>()
             {
                 @Override
-                public boolean execute( final int traversalId, final SPTEntry fromEdgeEntry )
+                public boolean execute( final int traversalId, final SPTEntry fromSPTEntry )
                 {
-                    SPTEntry toEdgeEntry = bestWeightMapTo.get(traversalId);
-                    if (toEdgeEntry == null)
+                    SPTEntry toSPTEntry = bestWeightMapTo.get(traversalId);
+                    if (toSPTEntry == null)
                         return true;
 
                     if (traversalMode.isEdgeBased())
                     {
-                        if (toEdgeEntry.parent != null)
+                        if (toSPTEntry.parent != null)
                             // move to parent for two reasons: 
                             // 1. make only turn costs missing in 'weight' and not duplicating current edge.weight
                             // 2. to avoid duplicate edge in Path
-                            toEdgeEntry = toEdgeEntry.parent;
-                        // TODO else if fromEdgeEntry.parent != null fromEdgeEntry = fromEdgeEntry.parent;
+                            toSPTEntry = toSPTEntry.parent;
+                        // TODO else if fromSPTEntry.parent != null fromSPTEntry = fromSPTEntry.parent;
 
                     } else
                     {
                         // The alternative path is suboptimal when both entries are parallel
-                        if (fromEdgeEntry.edge == toEdgeEntry.edge)
+                        if (fromSPTEntry.edge == toSPTEntry.edge)
                             return true;
                     }
 
                     // (1) skip too long paths
-                    final double weight = fromEdgeEntry.getWeightOfVisitedPath() + toEdgeEntry.getWeightOfVisitedPath();
+                    final double weight = fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath();
                     if (weight > maxWeight)
                         return true;
 
                     // (2) Use the start traversal ID of a plateau as ID for the alternative path.
                     // Accept from-EdgeEntries only if such a start of a plateau 
-                    // i.e. discard if its parent has the same edgeId as the next to-EdgeEntry.                                        
+                    // i.e. discard if its parent has the same edgeId as the next to-SPTEntry.                                        
                     // Ignore already added best path
-                    if (isBestPath(fromEdgeEntry, bestPath))
+                    if (isBestPath(fromSPTEntry, bestPath))
                         return true;
 
                     // For edge based traversal we need the next entry to find out the plateau start
-                    SPTEntry tmpFromEntry = traversalMode.isEdgeBased() ? fromEdgeEntry.parent : fromEdgeEntry;
+                    SPTEntry tmpFromEntry = traversalMode.isEdgeBased() ? fromSPTEntry.parent : fromSPTEntry;
                     if (tmpFromEntry == null || tmpFromEntry.parent == null)
                     {
                         // we can be here only if edge based and only if entry is not part of the best path 
@@ -407,14 +407,14 @@ public boolean execute( final int traversalId, final SPTEntry fromEdgeEntry )
                     {
                         int nextToTraversalId = traversalMode.createTraversalId(tmpFromEntry.adjNode,
                                 tmpFromEntry.parent.adjNode, tmpFromEntry.edge, true);
-                        SPTEntry tmpNextToEdgeEntry = bestWeightMapTo.get(nextToTraversalId);
-                        if (tmpNextToEdgeEntry == null)
+                        SPTEntry tmpNextToSPTEntry = bestWeightMapTo.get(nextToTraversalId);
+                        if (tmpNextToSPTEntry == null)
                             return true;
 
                         if (traversalMode.isEdgeBased())
-                            tmpNextToEdgeEntry = tmpNextToEdgeEntry.parent;
+                            tmpNextToSPTEntry = tmpNextToSPTEntry.parent;
                         // skip if on plateau
-                        if (fromEdgeEntry.edge == tmpNextToEdgeEntry.edge)
+                        if (fromSPTEntry.edge == tmpNextToSPTEntry.edge)
                             return true;
                     }
 
@@ -427,44 +427,44 @@ public boolean execute( final int traversalId, final SPTEntry fromEdgeEntry )
                     //    start    end
                     //
                     // extend plateau in only one direction necessary (A to B to ...) as we know
-                    // that the from-EdgeEntry is the start of the plateau or there is no plateau at all
+                    // that the from-SPTEntry is the start of the plateau or there is no plateau at all
                     //
                     double plateauWeight = 0;
-                    SPTEntry prevToEdgeEntry = toEdgeEntry;
+                    SPTEntry prevToSPTEntry = toSPTEntry;
                     // List<Integer> plateauEdges = new ArrayList<Integer>();
-                    while (prevToEdgeEntry.parent != null)
+                    while (prevToSPTEntry.parent != null)
                     {
-                        int nextFromTraversalId = traversalMode.createTraversalId(prevToEdgeEntry.adjNode, prevToEdgeEntry.parent.adjNode,
-                                prevToEdgeEntry.edge, false);
+                        int nextFromTraversalId = traversalMode.createTraversalId(prevToSPTEntry.adjNode, prevToSPTEntry.parent.adjNode,
+                                prevToSPTEntry.edge, false);
 
-                        SPTEntry nextFromEdgeEntry = bestWeightMapFrom.get(nextFromTraversalId);
+                        SPTEntry nextFromSPTEntry = bestWeightMapFrom.get(nextFromTraversalId);
                         // end of a plateau
-                        if (nextFromEdgeEntry == null)
+                        if (nextFromSPTEntry == null)
                             break;
 
-                        // is the next from-EdgeEntry on the plateau?
-                        if (prevToEdgeEntry.edge != nextFromEdgeEntry.edge)
+                        // is the next from-SPTEntry on the plateau?
+                        if (prevToSPTEntry.edge != nextFromSPTEntry.edge)
                             break;
 
-                        // plateauEdges.add(prevToEdgeEntry.edge);
-                        plateauWeight += (prevToEdgeEntry.getWeightOfVisitedPath() - prevToEdgeEntry.parent.getWeightOfVisitedPath());
-                        prevToEdgeEntry = prevToEdgeEntry.parent;
+                        // plateauEdges.add(prevToSPTEntry.edge);
+                        plateauWeight += (prevToSPTEntry.getWeightOfVisitedPath() - prevToSPTEntry.parent.getWeightOfVisitedPath());
+                        prevToSPTEntry = prevToSPTEntry.parent;
                     }
 
                     if (plateauWeight <= 0 || plateauWeight / weight < minPlateauFactor)
                         return true;
 
-                    if (fromEdgeEntry.parent == null)
-                        throw new IllegalStateException("not implemented yet. in case of an edge based traversal the parent of fromEdgeEntry could be null");
+                    if (fromSPTEntry.parent == null)
+                        throw new IllegalStateException("not implemented yet. in case of an edge based traversal the parent of fromSPTEntry could be null");
 
                     // (3b) calculate share                    
-                    SPTEntry fromEE = getFirstShareEE(fromEdgeEntry.parent, true);
-                    SPTEntry toEE = getFirstShareEE(toEdgeEntry.parent, false);
+                    SPTEntry fromEE = getFirstShareEE(fromSPTEntry.parent, true);
+                    SPTEntry toEE = getFirstShareEE(toSPTEntry.parent, false);
                     double shareWeight = fromEE.getWeightOfVisitedPath() + toEE.getWeightOfVisitedPath();
                     boolean smallShare = shareWeight / bestPath.getWeight() < maxShareFactor;
                     if (smallShare)
                     {
-                        List<String> altNames = getAltNames(graph, fromEdgeEntry);
+                        List<String> altNames = getAltNames(graph, fromSPTEntry);
 
                         double sortBy = calcSortBy(weightInfluence, weight, shareInfluence, shareWeight, plateauInfluence, plateauWeight);
                         double worstSortBy = getWorstSortBy();
@@ -473,7 +473,7 @@ public boolean execute( final int traversalId, final SPTEntry fromEdgeEntry )
                         if (sortBy < worstSortBy || alternatives.size() < maxPaths)
                         {
                             Path path = new PathBidirRef(graph, flagEncoder).
-                                    setEdgeEntryTo(toEdgeEntry).setEdgeEntry(fromEdgeEntry).
+                                    setSPTEntryTo(toSPTEntry).setSPTEntry(fromSPTEntry).
                                     setWeight(weight);
                             path.extract();
 
@@ -538,30 +538,30 @@ public boolean execute( TIntSet set )
                     return alternatives.get(alternatives.size() - 1).sortBy;
                 }
 
-                // returns true if fromEdgeEntry is identical to the specified best path
-                boolean isBestPath( SPTEntry fromEdgeEntry, Path bestPath )
+                // returns true if fromSPTEntry is identical to the specified best path
+                boolean isBestPath( SPTEntry fromSPTEntry, Path bestPath )
                 {
                     if (traversalMode.isEdgeBased())
                     {
-                        if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromEdgeEntry.edge)
+                        if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromSPTEntry.edge)
                         {
-                            if (fromEdgeEntry.parent == null)
-                                throw new IllegalStateException("best path must have no parent but was non-null: " + fromEdgeEntry);
+                            if (fromSPTEntry.parent == null)
+                                throw new IllegalStateException("best path must have no parent but was non-null: " + fromSPTEntry);
 
                             return true;
                         }
 
                     } else
                     {
-                        if (fromEdgeEntry.parent == null)
+                        if (fromSPTEntry.parent == null)
                         {
-                            bestPathEntries.add(fromEdgeEntry);
+                            bestPathEntries.add(fromSPTEntry);
                             if (bestPathEntries.size() > 1)
                                 throw new IllegalStateException("There is only one best path but was: " + bestPathEntries);
 
-                            if (startTID.get() != fromEdgeEntry.adjNode)
+                            if (startTID.get() != fromSPTEntry.adjNode)
                                 throw new IllegalStateException("Start traversal ID has to be identical to root edge entry "
-                                        + "which is the plateau start of the best path but was: " + startTID + " vs. adjNode: " + fromEdgeEntry.adjNode);
+                                        + "which is the plateau start of the best path but was: " + startTID + " vs. adjNode: " + fromSPTEntry.adjNode);
 
                             return true;
                         }
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index f32a7ca165..9f0f46d97e 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -61,7 +61,7 @@ public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
         this.to = to;
-        currEdge = createEdgeEntry(from, 0);
+        currEdge = createSPTEntry(from, 0);
         if (!traversalMode.isEdgeBased())
         {
             fromMap.put(from, currEdge);
@@ -132,7 +132,7 @@ protected Path extractPath()
         if (currEdge == null || isWeightLimitExceeded() || !finished())
             return createEmptyPath();
 
-        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
+        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index e8f5f6d731..1d745806e3 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -69,7 +69,7 @@ protected void initCollections( int nodes )
     @Override
     public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, weight);
+        currFrom = createSPTEntry(from, weight);
         openSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -84,7 +84,7 @@ public void initFrom( int from, double weight )
             if (currTo != null && currTo.adjNode == from)
             {
                 // special case of identical start and end
-                bestPath.edgeEntry = currFrom;
+                bestPath.sptEntry = currFrom;
                 bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
@@ -95,7 +95,7 @@ public void initFrom( int from, double weight )
     @Override
     public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, weight);
+        currTo = createSPTEntry(to, weight);
         openSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -110,7 +110,7 @@ public void initTo( int to, double weight )
             if (currFrom != null && currFrom.adjNode == to)
             {
                 // special case of identical start and end
-                bestPath.edgeEntry = currFrom;
+                bestPath.sptEntry = currFrom;
                 bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
@@ -258,9 +258,9 @@ protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry entryCurren
         if (newWeight < bestPath.getWeight())
         {
             bestPath.setSwitchToFrom(reverse);
-            bestPath.setEdgeEntry(entryCurrent);
+            bestPath.setSPTEntry(entryCurrent);
             bestPath.setWeight(newWeight);
-            bestPath.setEdgeEntryTo(entryOther);
+            bestPath.setSPTEntryTo(entryOther);
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 7828a5f9d3..5f09e4709c 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -46,11 +46,14 @@
     protected Graph graph;
     private FlagEncoder encoder;
     protected double distance;
-    // we go upwards (via EdgeEntry.parent) from the goal node to the origin node
+    // we go upwards (via SPTEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
     protected long time;
     private boolean found;
-    protected SPTEntry edgeEntry;
+    /**
+     * Shortest path tree entry
+     */
+    protected SPTEntry sptEntry;
     final StopWatch extractSW = new StopWatch("extract");
     private int fromNode = -1;
     protected int endNode = -1;
@@ -75,7 +78,7 @@ public Path( Graph graph, FlagEncoder encoder )
         this(p.graph, p.encoder);
         weight = p.weight;
         edgeIds = new TIntArrayList(p.edgeIds);
-        edgeEntry = p.edgeEntry;
+        sptEntry = p.sptEntry;
     }
 
     /**
@@ -95,9 +98,9 @@ public Path setDescription( List<String> description )
         return this;
     }
 
-    public Path setEdgeEntry( SPTEntry edgeEntry )
+    public Path setSPTEntry( SPTEntry sptEntry )
     {
-        this.edgeEntry = edgeEntry;
+        this.sptEntry = sptEntry;
         return this;
     }
 
@@ -183,7 +186,7 @@ public Path setWeight( double w )
     }
 
     /**
-     * Extracts the Path from the shortest-path-tree determined by edgeEntry.
+     * Extracts the Path from the shortest-path-tree determined by sptEntry.
      */
     public Path extract()
     {
@@ -191,7 +194,7 @@ public Path extract()
             throw new IllegalStateException("Extract can only be called once");
 
         extractSW.start();
-        SPTEntry goalEdge = edgeEntry;
+        SPTEntry goalEdge = sptEntry;
         setEndNode(goalEdge.adjNode);
         while (EdgeIterator.Edge.isValid(goalEdge.edge))
         {
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 1886c6b07d..9899110792 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -50,7 +50,7 @@ public PathBidirRef setSwitchToFrom( boolean b )
         return this;
     }
 
-    public PathBidirRef setEdgeEntryTo( SPTEntry edgeTo )
+    public PathBidirRef setSPTEntryTo( SPTEntry edgeTo )
     {
         this.edgeTo = edgeTo;
         return this;
@@ -62,21 +62,21 @@ public PathBidirRef setEdgeEntryTo( SPTEntry edgeTo )
     @Override
     public Path extract()
     {
-        if (edgeEntry == null || edgeTo == null)
+        if (sptEntry == null || edgeTo == null)
             return this;
 
-        if (edgeEntry.adjNode != edgeTo.adjNode)
-            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + edgeEntry + ", toEntry:" + edgeTo);
+        if (sptEntry.adjNode != edgeTo.adjNode)
+            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + sptEntry + ", toEntry:" + edgeTo);
 
         extractSW.start();
         if (switchWrapper)
         {
-            SPTEntry ee = edgeEntry;
-            edgeEntry = edgeTo;
+            SPTEntry ee = sptEntry;
+            sptEntry = edgeTo;
             edgeTo = ee;
         }
 
-        SPTEntry currEdge = edgeEntry;
+        SPTEntry currEdge = sptEntry;
         while (EdgeIterator.Edge.isValid(currEdge.edge))
         {
             processEdge(currEdge.edge, currEdge.adjNode);
diff --git a/core/src/main/java/com/graphhopper/routing/RoundTripAltAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoundTripAltAlgorithm.java
index f95d97998d..dfd5edd12b 100644
--- a/core/src/main/java/com/graphhopper/routing/RoundTripAltAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoundTripAltAlgorithm.java
@@ -99,7 +99,7 @@ protected void processEdge( int edgeId, int adjNode )
             }
         };
 
-        bestForwardPath.setEdgeEntry(currFrom);
+        bestForwardPath.setSPTEntry(currFrom);
         bestForwardPath.setWeight(currFrom.weight);
         bestForwardPath.extract();
         if (forwardEdgeSet.isEmpty())
@@ -167,10 +167,10 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
                 int tKey = traversalMode.createTraversalId(newTo.adjNode, newTo.parent.adjNode, newTo.edge, false);
 
                 // do new extract
-                SPTEntry tmpFromEdgeEntry = altDijkstra.getFromEntry(tKey);
+                SPTEntry tmpFromSPTEntry = altDijkstra.getFromEntry(tKey);
 
-                // if (tmpFromEdgeEntry.parent != null) tmpFromEdgeEntry = tmpFromEdgeEntry.parent;
-                bestForwardPath = new Path(graph, flagEncoder).setEdgeEntry(tmpFromEdgeEntry).setWeight(tmpFromEdgeEntry.weight).extract();
+                // if (tmpFromSPTEntry.parent != null) tmpFromSPTEntry = tmpFromSPTEntry.parent;
+                bestForwardPath = new Path(graph, flagEncoder).setSPTEntry(tmpFromSPTEntry).setWeight(tmpFromSPTEntry.weight).extract();
 
                 newTo = newTo.parent;
                 // force new 'to'
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index f66e7db833..a04bd2b0ee 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -30,92 +30,12 @@
  */
 public class BresenhamLine
 {
-    public static void calcPoints( int y1, int x1, int y2, int x2,
-                                   PointEmitter emitter )
+    public static void calcPoints( int y1, int x1, int y2, int x2, PointEmitter emitter )
     {
         bresenham(y1, x1, y2, x2, emitter);
     }
 
-    public static void voxelTraversal( double y1, double x1, double y2, double x2,
-                                       PointEmitter emitter )
-    {
-        // edge case
-        x1 = fix(x1);
-        y1 = fix(y1);
-        x2 = fix(x2);
-        y2 = fix(y2);
-
-        int x = (int) x1, y = (int) y1;
-        int endX = (int) x2, endY = (int) y2;
-
-        // deltaX and Y is how far we have to move in ray direction until we find a new cell in x or y direction
-        // y = u + t * v, where u=(x1,x2) and v=(stepX,stepY) is the direction vector
-        final double gridCellWidth = 1, gridCellHeight = 1;
-
-        double deltaX = gridCellWidth / Math.abs(x2 - x1);
-        int stepX = (int) Math.signum(x2 - x1);
-        double tmp = frac(x1 / gridCellWidth);
-        double maxX = deltaX * (1.0 - tmp);
-
-        double deltaY = gridCellHeight / Math.abs(y2 - y1);
-        int stepY = (int) Math.signum(y2 - y1);
-        tmp = frac(y1 / gridCellHeight);
-        double maxY = deltaY * (1.0 - tmp);
-
-        boolean reachedY = false, reachedX = false;
-
-        emitter.set(y, x);
-        // trace primary ray
-        while (!(reachedX && reachedY))
-        {
-            if (maxX < maxY)
-            {
-                maxX += deltaX;
-                x += stepX;
-            } else
-            {
-                maxY += deltaY;
-                y += stepY;
-            }
-
-            emitter.set(y, x);
-
-            if (stepX > 0.0)
-            {
-                if (x >= endX)
-                    reachedX = true;
-
-            } else if (x <= endX)
-            {
-                reachedX = true;
-            }
-
-            if (stepY > 0.0)
-            {
-                if (y >= endY)
-                    reachedY = true;
-
-            } else if (y <= endY)
-            {
-                reachedY = true;
-            }
-        }
-    }
-
-    static final double fix( double val )
-    {
-        if (frac(val) == 0)
-            return val + 0.1;
-        return val;
-    }
-
-    static final double frac( double val )
-    {
-        return val - (int) val;
-    }
-
-    public static void bresenham( int y1, int x1, int y2, int x2,
-                                  PointEmitter emitter )
+    public static void bresenham( int y1, int x1, int y2, int x2, PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
@@ -144,111 +64,15 @@ public static void bresenham( int y1, int x1, int y2, int x2,
         }
     }
 
-    public static void xiaolinWu( double y1, double x1, double y2, double x2,
-                                  PointEmitter emitter )
-    {
-        double dx = x2 - x1;
-        double dy = y2 - y1;
-
-        if (Math.abs(dx) > Math.abs(dy))
-        {
-            if (x2 < x1)
-            {
-                // algo only handles rightwards so swap
-                double tmp = x1;
-                x1 = x2;
-                x2 = tmp;
-                tmp = y1;
-                y1 = y2;
-                y2 = tmp;
-            }
-
-            double gradient = dy / dx;
-            // orig: round
-            int xend = (int) (x1);
-            double yend = y1 + gradient * (xend - x1);
-            int xpxl1 = xend;
-            int ypxl1 = (int) yend;
-
-            // first endpoint
-            emitter.set(ypxl1, xpxl1);
-            emitter.set(ypxl1 + 1, xpxl1);
-            double intery = yend + gradient;
-
-            // orig: round
-            xend = (int) (x2);
-            yend = y2 + gradient * (xend - x2);
-            int xpxl2 = xend;
-            int ypxl2 = (int) yend;
-
-            // second endpoint
-            emitter.set(ypxl2, xpxl2);
-            emitter.set(ypxl2 + 1, xpxl2);
-
-            // all the points between the endpoints
-            for (int x = xpxl1 + 1; x <= xpxl2 - 1; ++x)
-            {
-                emitter.set((int) intery, x);
-                emitter.set((int) intery + 1, x);
-                intery += gradient;
-            }
-        } else
-        {
-            if (y2 < y1)
-            {
-                // algo only handles topwards so swap
-                double tmp = x1;
-                x1 = x2;
-                x2 = tmp;
-                tmp = y1;
-                y1 = y2;
-                y2 = tmp;
-            }
-
-            double gradient = dx / dy;
-            // orig: round
-            int yend = (int) (y1);
-            double xend = x1 + gradient * (yend - y1);
-            int ypxl1 = yend;
-            int xpxl1 = (int) xend;
-
-            // first endpoint
-            emitter.set(ypxl1, xpxl1);
-            emitter.set(ypxl1 + 1, xpxl1);
-            double interx = xend + gradient;
-
-            // orig: round
-            yend = (int) (y2);
-            xend = x2 + gradient * (yend - y2);
-            int ypxl2 = yend;
-            int xpxl2 = (int) xend;
-
-            // second endpoint
-            emitter.set(ypxl2, xpxl2);
-            emitter.set(ypxl2 + 1, xpxl2);
-
-            // all the points between the endpoints
-            for (int y = ypxl1 + 1; y <= ypxl2 - 1; ++y)
-            {
-                emitter.set(y, (int) interx);
-                emitter.set(y, (int) interx + 1);
-                interx += gradient;
-            }
-        }
-    }
-
+    /**
+     * Calls the Bresenham algorithm but make it working for double values
+     */
     public static void calcPoints( final double lat1, final double lon1,
                                    final double lat2, final double lon2,
                                    final PointEmitter emitter,
                                    final double offsetLat, final double offsetLon,
                                    final double deltaLat, final double deltaLon )
     {
-//        double y1 = (lat1 - offsetLat) / deltaLat;
-//        double x1 = (lon1 - offsetLon) / deltaLon;
-//        double y2 = (lat2 - offsetLat) / deltaLat;
-//        double x2 = (lon2 - offsetLon) / deltaLon;
-        // for xiaolinWu or calcPoints
-
         // round to make results of bresenham closer to correct solution
         int y1 = (int) ((lat1 - offsetLat) / deltaLat);
         int x1 = (int) ((lon1 - offsetLon) / deltaLon);
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 502684f731..5535373719 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -431,9 +431,13 @@ public void set( double lat, double lon )
                     addNode(root, nodeA, 0, keyPart, key);
                 }
             };
-            BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
-                    graph.getBounds().minLat, graph.getBounds().minLon,
-                    deltaLat, deltaLon);
+
+            if (!distCalc.isCrossBoundary(lon1, lon2))
+            {
+                BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
+                        graph.getBounds().minLat, graph.getBounds().minLon,
+                        deltaLat, deltaLon);
+            }
         }
 
         void addNode( InMemEntry entry, int nodeId, int depth, long keyPart, long key )
@@ -922,6 +926,13 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
                 double wayLat = pointList.getLatitude(pointIndex);
                 double wayLon = pointList.getLongitude(pointIndex);
                 QueryResult.Position pos = QueryResult.Position.EDGE;
+                if (distCalc.isCrossBoundary(tmpLon, wayLon))
+                {
+                    tmpLat = wayLat;
+                    tmpLon = wayLon;
+                    continue;
+                }
+
                 if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, wayLat, wayLon))
                 {
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 0908b59f8f..c687038dc8 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -63,7 +63,7 @@
      *   r
      *  .
      * a-------b
-     *
+     * <p>
      * case 2:
      * r
      *  .
@@ -91,4 +91,10 @@ boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
     GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
                                      double a_lat_deg, double a_lon_deg,
                                      double b_lat_deg, double b_lon_deg );
+
+    /**
+     * Simple heuristic to detect if the specified two points are crossing the boundary +-180°. See
+     * #667
+     */
+    boolean isCrossBoundary( double lon1, double lon2 );
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 86b2d586fd..5b291bd6c0 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -164,7 +164,8 @@ else if (factor < 0)
         return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
-    private double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
+    private double calcShrinkFactor( double a_lat_deg, double b_lat_deg )
+    {
         return cos(toRadians((a_lat_deg + b_lat_deg) / 2));
     }
 
@@ -235,6 +236,12 @@ public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
         return ab_ar > 0 && ab_rb > 0;
     }
 
+    @Override
+    public boolean isCrossBoundary( double lon1, double lon2 )
+    {
+        return Math.abs(lon1 - lon2) > 300;
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 7e1606ab9d..7c8833cc14 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -40,6 +40,7 @@
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -279,7 +280,7 @@ public void testOneWay()
     {
         GraphHopper hopper = new GraphHopperTest(file2).importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
-                              
+
         assertEquals("2014-01-02T01:10:14Z", graph.getProperties().get("osmreader.data.date"));
 
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52.0);
@@ -836,4 +837,21 @@ public void testDataDateWithinPBF()
 
         assertEquals("2014-01-02T00:10:14Z", graph.getProperties().get("osmreader.data.date"));
     }
+
+    @Test
+    public void testCrossBoundary_issue667()
+    {
+        GraphHopper hopper = new GraphHopperTest("test-osm-waterway.xml").importOrLoad();
+        QueryResult qr = hopper.getLocationIndex().findClosest(0.1, 179.5, EdgeFilter.ALL_EDGES);
+        assertTrue(qr.isValid());
+        assertEquals(0.1, qr.getSnappedPoint().lat, 0.1);
+        assertEquals(179.5, qr.getSnappedPoint().lon, 0.1);
+        assertEquals(11, qr.getClosestEdge().getDistance() / 1000, 1);
+
+        qr = hopper.getLocationIndex().findClosest(0.1, -179.6, EdgeFilter.ALL_EDGES);
+        assertTrue(qr.isValid());
+        assertEquals(0.1, qr.getSnappedPoint().lat, 0.1);
+        assertEquals(-179.6, qr.getSnappedPoint().lon, 0.1);
+        assertEquals(56, qr.getClosestEdge().getDistance() / 1000, 1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index c3486fd090..b2c32c5beb 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -52,8 +52,8 @@ public void testExtract()
         EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
         EdgeIterator iter = explorer.setBaseNode(1);
         iter.next();
-        pw.edgeEntry = new SPTEntry(iter.getEdge(), 2, 0);
-        pw.edgeEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
+        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 0);
+        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
         pw.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
         Path p = pw.extract();
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
@@ -70,8 +70,8 @@ public void testExtract2()
         EdgeIterator iter = explorer.setBaseNode(1);
         iter.next();
         PathBidirRef pw = new PathBidirRef(g, carEncoder);
-        pw.edgeEntry = new SPTEntry(iter.getEdge(), 2, 10);
-        pw.edgeEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 10);
+        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
 
         explorer = g.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, false));
         iter = explorer.setBaseNode(3);
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 8c6b5038b9..540a74df05 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -92,7 +92,7 @@ public void testWayList()
         SPTEntry e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setEdgeEntry(e1);
+        path.setSPTEntry(e1);
         path.extract();
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
@@ -118,7 +118,7 @@ public void testWayList()
         e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setEdgeEntry(e1);
+        path.setSPTEntry(e1);
         path.extract();
         instr = path.calcInstructions(tr);
         res = instr.createJson();
@@ -142,7 +142,7 @@ public void testWayList()
         e1 = new SPTEntry(edge1.getEdge(), 0, 1);
         e1.parent = new SPTEntry(edge2.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 2, 1);
-        path.setEdgeEntry(e1);
+        path.setSPTEntry(e1);
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
@@ -194,7 +194,7 @@ public void testFindInstruction()
         e1.parent.parent = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent.parent.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setEdgeEntry(e1);
+        path.setSPTEntry(e1);
         path.extract();
 
         InstructionList il = path.calcInstructions(tr);
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 36b61b1892..5cabee4c2b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -60,14 +60,6 @@ public void testBresenhamLineLeftDown()
         assertEquals(Helper.createPointList(5, 2, 4, 2, 3, 1, 2, 1, 1, 0, 0, 0), points);
     }
 
-    @Test
-    public void testLineRightDown2()
-    {
-        // example http://stackoverflow.com/a/12370474/194609
-        BresenhamLine.voxelTraversal(0.25, 0.25, 2.75, 5.25, emitter);
-        assertEquals(Helper.createPointList(0, 0, 0, 1, 1, 1, 1, 2, 1, 3, 2, 3, 2, 4, 2, 5), points);
-    }
-
     @Test
     public void testBresenhamLineRightDown()
     {
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index fe4cdd4d3e..357cd49ade 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -495,4 +495,50 @@ public void testSearchWithFilter_issue318()
         assertTrue(qr.isValid());
         assertEquals(2, qr.getClosestNode());
     }
+
+    // 0--1--2--3, the "cross boundary" edges are 1-2 and 5-6
+    // |  |  |  |
+    // 4--5--6--7
+    @Test
+    public void testCrossBoundaryNetwork_issue667()
+    {
+        Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0.1, 179.5);
+        na.setNode(1, 0.1, 179.9);
+        na.setNode(2, 0.1, -179.8);
+        na.setNode(3, 0.1, -179.5);
+        na.setNode(4, 0, 179.5);
+        na.setNode(5, 0, 179.9);
+        na.setNode(6, 0, -179.8);
+        na.setNode(7, 0, -179.5);
+
+        // just use 1 as distance which is incorrect but does not matter in this unit case
+        graph.edge(0, 1, 1, true);
+        graph.edge(0, 4, 1, true);
+        graph.edge(1, 5, 1, true);
+        graph.edge(4, 5, 1, true);
+
+        graph.edge(2, 3, 1, true);
+        graph.edge(2, 6, 1, true);
+        graph.edge(3, 7, 1, true);
+        graph.edge(6, 7, 1, true);
+
+        // as last edges: create cross boundary edges
+        // See #667 where the recommendation is to adjust the import and introduce two pillar nodes 
+        // where the connection is cross boundary and would be okay if ignored as real length is 0
+        graph.edge(1, 2, 1, true).setWayGeometry(Helper.createPointList(0, 180, 0, -180));
+        // but this unit test succeeds even without this adjusted import:
+        graph.edge(5, 6, 1, true);
+
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareIndex();
+
+        assertTrue(graph.getNodes() > 0);
+        for (int i = 0; i < graph.getNodes(); i++)
+        {
+            QueryResult qr = index.findClosest(na.getLat(i), na.getLon(i), EdgeFilter.ALL_EDGES);
+            assertEquals(i, qr.getClosestNode());
+        }
+    }
 }
diff --git a/core/src/test/resources/com/graphhopper/reader/test-osm-waterway.xml b/core/src/test/resources/com/graphhopper/reader/test-osm-waterway.xml
new file mode 100644
index 0000000000..5311b7e114
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/test-osm-waterway.xml
@@ -0,0 +1,32 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm" timestamp="2013-01-02T01:10:14Z">
+    
+    <node id="10" lat="0" lon="179.5" uid="24853">           
+    </node>    
+    <node id="20" lat="0" lon="179.6" uid="24854">        
+    </node>
+    <node id="30" lat="0.1" lon="-179.9" uid="24855">        
+    </node>
+
+    <node id="35" lat="0.1" lon="-179.5" uid="3212487">        
+    </node>
+    
+    <node id="11" lat="0.1" lon="179.5" uid="34853">           
+    </node>
+
+    <way id="10" uid="85761">
+        <nd ref="10"/>
+        <nd ref="20"/>
+        <nd ref="30"/>
+        <nd ref="35"/>
+        <tag k="name" v="fake waterway cross" />
+        <tag k="highway" v="motorway" />       
+    </way> 
+    
+    <way id="20" uid="85762">
+        <nd ref="10"/>
+        <nd ref="11"/>
+        <tag k="name" v="fake waterway2" />
+        <tag k="highway" v="motorway" />       
+    </way> 
+</osm>
diff --git a/docs/index.md b/docs/index.md
index 2e09ce0a1e..ffaad80e79 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,16 +1,18 @@
-# Users
+# GraphHopper Documentation
+
+## Users
 
  * [Quickstart](./web/quickstart.md): HowTo for users.
  * [Read Overview](https://graphhopper.com/#overview): Summary of the product GraphHopper. 
  * [Add GraphHopper Maps to your Browser](./web/open-search.md): Instructions how to setup GraphHopper as the standard search enginge in your browser.
  * [Embed GraphHopper on your website](https://github.com/karussell/graphhopper-embed-form): A small code snippet on how to integrate GraphHopper Maps in your web site like a contact form
 
-# Translators
+## Translators
 
 * [Translations](./core/translations.md): Tutorial how to help with the GraphHopper translations or how to setup a new language.
 
 
-# Developers
+## Developers
 
  * [Quickstart](./core/quickstart-from-source.md): Introduction for developers. Explains git checkout, IDE setup and commands for setting up a GraphHopper server.
  * [Android](./android/index.md): Instructions how to setup the demo project for GraphHopper on Android as base for further development (i.e. with Android Studio).
@@ -18,7 +20,7 @@
  * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md): Detailed instructions how to setup GraphHopper in eclipse with maven.
  * [iOS](https://github.com/graphhopper/graphhopper-ios/): Link to the GraphHopper-iOS github repository.
 
-## Core
+### Core
 
  * [Simple routing](./core/routing.md): Tutorial how to integrate GraphHopper in your Java application (or pick any JVM language)
  * [Create custom weighting](./core/weighting.md): Documentation about how to create a custom weighting class to influence the track calculation.
@@ -28,11 +30,11 @@
  * [Contraction Hierarchies](./core/ch.md): Details about speeding up the track calculations by [Contraction Hierarchies](http://en.wikipedia.org/wiki/Contraction_hierarchies).
  * [Deployment Guide](./core/deploy.md): Details about deploying GraphHopper.
 
-## Web
+### Web
 
  * [Routing API](./web/api-doc.md): Documentation of the Web API to communicate with any GraphHopper server via http.
  
-## Advanced Topics
+### Advanced Topics
 
  * [Low level API](./core/low-level-api.md): Instructions how to use GraphHopper as a Java library.
  * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index cec8525cbd..41e529f998 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -3,7 +3,7 @@
 If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
 The following steps are simpler and only need the JRE, a jar file and an OSM file.
 
- 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.6-SNAPSHOT/) (~9MB)
+ 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.7-SNAPSHOT/) (~9MB)
  2. Unzip it and copy an OSM file into the created directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
  3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf`
  4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
