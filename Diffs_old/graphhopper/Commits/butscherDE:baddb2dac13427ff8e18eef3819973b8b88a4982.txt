diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index b44e2e1d42..c68c4b4dca 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -15,17 +15,22 @@
 import com.graphhopper.util.shapes.Polygon;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
-import java.util.LinkedList;
-import java.util.List;
+import java.util.*;
 
 public class PolygonRoutingTemplate extends ViaRoutingTemplate {
+    private final GHRequest ghRequest;
     private final Polygon polygon;
     private final GraphHopper gh;
     private final GraphHopperStorage ghStorage;
+    private QueryGraph queryGraph;
+    private AlgorithmOptions algoOpts;
+    private RoutingAlgorithmFactory algoFactory;
+    private DijkstraOneToMany dijkstraOTM;
 
     public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
                                   EncodingManager encodingManager) {
         super(ghRequest, ghRsp, locationIndex, encodingManager);
+        this.ghRequest = ghRequest;
         this.polygon = ghRequest.getPolygon();
         this.gh = gh;
         this.ghStorage = this.gh.getGraphHopperStorage();
@@ -33,24 +38,103 @@ public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationInd
 
     @Override
     public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
-        return routeWithPolygon(algoFactory, queryGraph, algoOpts);
+        this.queryGraph = queryGraph;
+        this.algoFactory = algoFactory;
+        this.algoOpts = algoOpts;
+
+        return routeWithPolygon();
+    }
+
+    private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+        return !queryGraph.equals(this.queryGraph) || !algoFactory.equals(this.algoFactory) || !algoOpts.equals(this.algoOpts);
     }
 
-    private List<Path> routeWithPolygon(RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
-        List<QueryResult> additionalPoints = this.findViaPointsToFullfillPolygonOrientedRouting(algoOpts);
+    private List<Path> routeWithPolygon() {
+        List<QueryResult> additionalPoints = this.findViaPointsToFullfillPolygonOrientedRouting();
 
         throw new NotImplementedException();
     }
 
-    private List<QueryResult> findViaPointsToFullfillPolygonOrientedRouting(AlgorithmOptions algoOpts) {
+    private List<QueryResult> findViaPointsToFullfillPolygonOrientedRouting() {
         List<Integer> nodesInPolygon = getNodesInPolygon();
         List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
-        List<Integer> pathSkeleton = calculatePathSkeleton(nodesInPolygon, polygonEntryExitPoints, algoOpts);
+        List<Integer> pathSkeleton = calculatePathSkeleton(nodesInPolygon, polygonEntryExitPoints);
+        List<List<Integer>> LOTnodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
 
         throw new NotImplementedException();
     }
 
-        private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
+    // Definition 6 in Storandts paper Region-Aware Routing Planning
+    private List<List<Integer>> findLocalOptimalTouchnodes(final List<Integer> polygonEntryExitPoints) {
+        // TODO: Is there an A* one to many option? Does this make sense at all?
+
+        final EdgeExplorer edgeExplorer = this.queryGraph.createEdgeExplorer();
+
+        List<QueryResult> fixedUserSpecifiedPoints = this.queryResults;
+        List<List<Integer>> LOTNodes = new ArrayList<>();
+        for (final QueryResult point : fixedUserSpecifiedPoints) {
+            makeLOTNodeListForThisPoint(polygonEntryExitPoints, edgeExplorer, LOTNodes, point);
+        }
+
+
+        return LOTNodes;
+    }
+
+    private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
+        Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
+        addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
+        for (final int entryExitPoint :  LOTNodes.get(LOTNodes.size() - 1)) {
+            checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
+        }
+    }
+
+    private void checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
+        EdgeIterator neighborFinder = edgeExplorer.setBaseNode(entryExitPoint);
+        Double distanceOfThisEntryExitPointFromPoint = distancesToPolygonEntryExit.get(entryExitPoint);
+
+        boolean foundABetterLOTNode = false;
+        foundABetterLOTNode =
+                lookForNeighborsThatMakeABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint, foundABetterLOTNode);
+
+        pruneThisNoteFromLOTIfBetterWasFound(LOTNodes, entryExitPoint, foundABetterLOTNode);
+    }
+
+    private void pruneThisNoteFromLOTIfBetterWasFound(List<List<Integer>> LOTNodes, int entryExitPoint, boolean foundABetterLOTNode) {
+        if (foundABetterLOTNode) {
+            LOTNodes.get(LOTNodes.size() - 1).remove(entryExitPoint);
+        }
+    }
+
+    private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder,
+                                                           Double distanceOfThisEntryExitPointFromPoint, boolean foundABetterLOTNode) {
+        do {
+            final int currentNeighbor = neighborFinder.getAdjNode();
+            Double distanceOfNeighborFromPoint = distancesToPolygonEntryExit.get(currentNeighbor);
+            if (distanceOfNeighborFromPoint != null) {
+                if (distanceOfNeighborFromPoint < distanceOfThisEntryExitPointFromPoint) {
+                    foundABetterLOTNode = true;
+                }
+            }
+        } while (neighborFinder.next() && !foundABetterLOTNode);
+        return foundABetterLOTNode;
+    }
+
+    private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List<List<Integer>> LOTNodes) {
+        int index = LOTNodes.size();
+        LOTNodes.add(index, (ArrayList<Integer>)  ((ArrayList<Integer>) polygonEntryExitPoints).clone());
+    }
+
+    private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
+        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<Integer, Double>();
+        for (final int entryExitPoint : polygonEntryExitPoints) {
+            this.dijkstraOTM.calcPath(point.getClosestNode(), entryExitPoint);
+            weightsOfEntryExitPoints.put(entryExitPoint, this.dijkstraOTM.getWeight(entryExitPoint));
+        }
+
+        return weightsOfEntryExitPoints;
+    }
+
+    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
         final List<Integer> entryExitPoints = new LinkedList<>();
         final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
 
@@ -77,8 +161,8 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
     }
 
     // According to Prof. Storandts paper Region-Aware Route Planning Definition 2.
-    private List<Integer> calculatePathSkeleton(List<Integer> subGraphNodes, final List<Integer> polygonEntryExitPoints, AlgorithmOptions algoOpts) {
-        DijkstraManyToMany dijkstraMTM = new DijkstraManyToMany(this.ghStorage.getBaseGraph(), algoOpts.getWeighting(), algoOpts.getTraversalMode(), subGraphNodes,
+    private List<Integer> calculatePathSkeleton(List<Integer> subGraphNodes, final List<Integer> polygonEntryExitPoints) {
+        DijkstraManyToMany dijkstraMTM = new DijkstraManyToMany(this.queryGraph, algoOpts.getWeighting(), this.algoOpts.getTraversalMode(), subGraphNodes,
                                                                 polygonEntryExitPoints);
         dijkstraMTM.findAllPathsBetweenEntryExitPoints();
         return dijkstraMTM.buildPathSkeleton();
