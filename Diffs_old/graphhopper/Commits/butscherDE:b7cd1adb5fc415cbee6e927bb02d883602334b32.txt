diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 89af7b6152..1df1acf2ec 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -92,6 +92,7 @@ protected void buildThisPathFromAnotherPath(Path p) {
         edgeIds = new GHIntArrayList(p.edgeIds);
         sptEntry = p.sptEntry;
         endNode = p.endNode;
+        distance = p.distance;
     }
 
     /**
@@ -114,11 +115,11 @@ public Path setSPTEntry(SPTEntry sptEntry) {
         return this;
     }
 
-    protected void addEdge(int edge) {
+    public void addEdge(int edge) {
         edgeIds.add(edge);
     }
 
-    protected Path setEndNode(int end) {
+    public Path setEndNode(int end) {
         endNode = end;
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/PathMerge.java b/core/src/main/java/com/graphhopper/routing/PathMerge.java
index 2cd0244bc9..9fc8f62b27 100644
--- a/core/src/main/java/com/graphhopper/routing/PathMerge.java
+++ b/core/src/main/java/com/graphhopper/routing/PathMerge.java
@@ -41,6 +41,7 @@ private void addIfThisPathIsntEmpty(Path newPath) {
     private void mergePaths(Path newPath, List<EdgeIteratorState> otherPathsEdges) {
         addOtherPathsEdgesToThisPath(otherPathsEdges);
         this.weight += newPath.getWeight();
+        this.distance += newPath.distance;
         this.endNode = newPath.endNode;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 79c3275961..dd8bf55147 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -3,8 +3,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidate;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidateList;
+import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidatePolygon;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -30,7 +30,7 @@
     AlgorithmOptions algorithmOptions;
     RoutingAlgorithmFactory algoFactory;
     RoutingAlgorithm routingAlgorithm;
-    RouteCandidateList routeCandidates;
+    RouteCandidateList<RouteCandidatePolygon> routeCandidates;
 
     public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
                                          EncodingManager encodingManager) {
@@ -59,7 +59,7 @@ private void setCalcPathsParams(QueryGraph queryGraph, RoutingAlgorithmFactory a
         this.algoFactory = algoFactory;
         this.algorithmOptions = algoOpts;
         this.routingAlgorithm = algoFactory.createAlgo(queryGraph, algoOpts);
-        this.routeCandidates = RouteCandidateList.createEmptyCandidateList();
+        this.routeCandidates = new RouteCandidateList<>();
     }
 
     private void lookupPoints() {
@@ -85,55 +85,10 @@ private void extractBestPathCandidate() {
 
     private void prepareRouteCandidateList() {
         this.findCandidateRoutes();
-        this.pruneDominatedCandidateRoutes();
+        this.routeCandidates.pruneDominatedCandidateRoutes();
         this.pruneLowerQuantileInROIcandidateRoutes();
     }
 
-    // Do it in a skyline problem pruning fashion
-    private void pruneDominatedCandidateRoutes() {
-        this.routeCandidates.sortRouteCandidatesToDistanceInROIDescending();
-
-        int currentPruningCandidateIndex = 1;
-        while (indexInCandidateBounds(currentPruningCandidateIndex)) {
-            RouteCandidate currentPruningCandidate = this.routeCandidates.candidates.get(currentPruningCandidateIndex);
-
-            boolean foundDominatingPath = isThisCandidateDominatedByAny(currentPruningCandidateIndex, currentPruningCandidate);
-
-            currentPruningCandidateIndex = pruneOrUpdateIndex(currentPruningCandidateIndex, foundDominatingPath);
-        }
-    }
-
-    private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex, RouteCandidate currentPruningCandidate) {
-        boolean foundDominatingPath = false;
-        for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i--) {
-            // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
-            RouteCandidate possiblyBetterRouteCandidate = this.routeCandidates.candidates.get(i);
-
-            if (isPruningCandidateDominated(currentPruningCandidate, possiblyBetterRouteCandidate)) {
-                foundDominatingPath = true;
-            }
-        }
-        return foundDominatingPath;
-    }
-
-    private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDominatingPath) {
-        if (foundDominatingPath) {
-            this.routeCandidates.candidates.remove(currentPruningCandidateIndex);
-        } else {
-            currentPruningCandidateIndex++;
-        }
-        return currentPruningCandidateIndex;
-    }
-
-    private boolean isPruningCandidateDominated(RouteCandidate currentPruningCandidate, RouteCandidate possiblyBetterRouteCandidate) {
-        return possiblyBetterRouteCandidate.getDistance() < currentPruningCandidate.getDistance() &&
-               possiblyBetterRouteCandidate.getDistanceInROI() > currentPruningCandidate.getDistanceInROI();
-    }
-
-    private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
-        return currentPruningCandidateIndex < this.routeCandidates.candidates.size();
-    }
-
     private void pruneLowerQuantileInROIcandidateRoutes() {
         // Assumes that routeCandidates was already sorted descending to roi distance after pruning dominated route candidates
         int startIndex = (int) (this.routeCandidates.candidates.size() * 0.75) + 1;
@@ -143,7 +98,7 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
         }
     }
 
-    abstract RouteCandidateList findCandidateRoutes();
+    protected abstract RouteCandidateList findCandidateRoutes();
 
     @Override
     public boolean isReady(PathMerger pathMerger, Translation translation) {
@@ -160,4 +115,8 @@ public boolean isReady(PathMerger pathMerger, Translation translation) {
     public GHRequest getGhRequest() {
         return this.ghRequest;
     }
+
+    public RoutingAlgorithm getNewRoutingAlgorithm() {
+        return this.algoFactory.createAlgo(queryGraph, algorithmOptions);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
deleted file mode 100644
index cd7e240c98..0000000000
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package com.graphhopper.routing.template.PolygonRoutingUtil;
-
-import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
-
-/**
- * A route candidate as in Prof. Dr. Sabine Storandts Paper Region-Aware Route Planning.
- */
-public class RouteCandidate implements Comparable<RouteCandidate> {
-    private Path startToPolygonEntry;
-    private Path polygonEntryToPolygonExit;
-    private Path polygonExitToEnd;
-    private Path directRouteStartEnd;
-    private final PolygonThroughRoutingTemplate polygonRoutingTemplate;
-    private RoutingAlgorithm routingAlgorithm;
-    private final DijkstraManyToMany pathSkeletonRouter;
-    private final double distance;
-    private final int startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID;
-
-    public RouteCandidate(final PolygonThroughRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
-                          final int polygonExitNodeID) {
-        this.polygonRoutingTemplate = polygonRoutingTemplate;
-        this.pathSkeletonRouter = polygonRoutingTemplate.getPathSkeletonRouter();
-
-        this.startNodeID = startNodeID;
-        this.endNodeID = endNodeID;
-        this.polygonEntryNodeID = polygonEntryNodeID;
-        this.polygonExitNodeID = polygonExitNodeID;
-
-        calcPathFromStartToPolygonEntry(polygonRoutingTemplate);
-        calcPathThroughPolygon();
-        calcPathFromPolygonExitToEnd(polygonRoutingTemplate);
-        calcDirectRouteFromStartToEnd(polygonRoutingTemplate);
-
-        this.distance = this.startToPolygonEntry.getDistance() + this.polygonEntryToPolygonExit.getDistance() + this.polygonExitToEnd.getDistance();
-    }
-
-    private void calcPathFromStartToPolygonEntry(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
-        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.startToPolygonEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
-    }
-
-    private void calcPathThroughPolygon() {
-        this.polygonEntryToPolygonExit = this.pathSkeletonRouter.getPathByFromEndPoint(polygonEntryNodeID, polygonExitNodeID);
-    }
-
-    private void calcPathFromPolygonExitToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
-        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
-    }
-
-    private void calcDirectRouteFromStartToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate) {
-        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
-        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
-    }
-
-    public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
-        PathMerge completePathCandidate = new PathMerge(queryGraph, algoOpts.getWeighting());
-
-        completePathCandidate.addPath(startToPolygonEntry);
-        completePathCandidate.addPath(polygonEntryToPolygonExit);
-        completePathCandidate.addPath(polygonExitToEnd);
-
-        completePathCandidate.extract();
-
-        return completePathCandidate;
-    }
-
-    public double getDistance() {
-        return this.distance;
-    }
-
-    /**
-     * According to 5.2 in Storandts Region-Aware route planning paper.
-     *
-     * @return The approximated time spent in the region of interest
-     */
-    public double getDistanceInROI() {
-        return this.polygonEntryToPolygonExit.getDistance();
-    }
-
-    public double getGain() {
-        // + 1 to avoid division by zero
-        return this.polygonEntryToPolygonExit.getDistance() / (this.getDetourDistance() + 1);
-    }
-
-    public double getDetourDistance() {
-        return this.getDistance() - this.directRouteStartEnd.getDistance();
-    }
-
-    /**
-     * Uses the sweepline algorithm of Michael Ian Shamos and Dan Hoey to find intersecting line segments induced by the edges of the merged path.
-     * <p>
-     * Reference:
-     * Michael Ian Shamos and Dan Hoey. Geometric intersection problems. In Proceedings
-     * of the 17th Annual IEEE Symposium on Foundations of Computer Science
-     * (FOCS '76), pages 208{215, 1976.
-     *
-     * @return true if at least one intersection occurs and false otherwise.
-     */
-    public boolean isDetourSelfIntersecting() {
-        return false;
-        // TODO: Check with storandt what she means with intersections
-    }
-
-    @Override
-    /**
-     * @param   o - The Route Candidate to be compared.
-     * @return A negative integer, zero, or a positive integer as this RouteCandidate
-     *          is less than, equal to, or greater than the supplied RouteCandidate object.
-     */
-    public int compareTo(RouteCandidate o) {
-        double gainDifference = this.getGain() - o.getGain();
-        if (gainDifference < 0) {
-            return -1;
-        } else if (gainDifference == 0) {
-            return 0;
-        } else {
-            return 1;
-        }
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateList.java
index 9d47c4cd9d..e09ebd7e7b 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateList.java
@@ -9,25 +9,21 @@
 import java.util.Comparator;
 import java.util.List;
 
-public class RouteCandidateList {
-    public List<RouteCandidate> candidates;
+public class RouteCandidateList <T extends RouteCandidatePolygon> {
+    public List<T> candidates;
 
-    private RouteCandidateList(final List<RouteCandidate> candidates) {
-        this.candidates = candidates;
-    }
-
-    public static RouteCandidateList createEmptyCandidateList() {
-        return new RouteCandidateList(new ArrayList<RouteCandidate>());
+    public RouteCandidateList() {
+        this.candidates = new ArrayList<T>();
     }
 
     public void sortByGainAscending() {
         Collections.sort(this.candidates);
     }
 
-    public void sortRouteCandidatesToDistanceInROIDescending() {
-        Collections.sort(this.candidates, new Comparator<RouteCandidate>() {
+    private void sortRouteCandidatesToDistanceInROIDescending() {
+        Collections.sort(this.candidates, new Comparator<RouteCandidatePolygon>() {
             @Override
-            public int compare(RouteCandidate rc1, RouteCandidate rc2) {
+            public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
                 double distanceDifference = rc1.getDistanceInROI() - rc2.getDistanceInROI();
                 int output;
                 if (distanceDifference < 0) {
@@ -46,10 +42,57 @@ public int compare(RouteCandidate rc1, RouteCandidate rc2) {
     public List<Path> getFirstAsPathList(final int nOfFirstElements, final QueryGraph queryGraph, final AlgorithmOptions algorithmOptions) {
         final List<Path> paths = new ArrayList<>(nOfFirstElements);
 
-        for (int i = 0; i < nOfFirstElements; i++) {
+        final int endOfCandidates = candidates.size() - 1;
+        final int endOfIteration = endOfCandidates - nOfFirstElements;
+        for (int i = endOfCandidates; i > endOfIteration; i--) {
             paths.add(this.candidates.get(i).getMergedPath(queryGraph, algorithmOptions));
         }
 
         return paths;
     }
+
+    // Do it in a skyline problem pruning fashion
+    public void pruneDominatedCandidateRoutes() {
+        this.sortRouteCandidatesToDistanceInROIDescending();
+
+        int currentPruningCandidateIndex = 1;
+        while (indexInCandidateBounds(currentPruningCandidateIndex)) {
+            RouteCandidatePolygon currentPruningCandidate = this.candidates.get(currentPruningCandidateIndex);
+
+            boolean foundDominatingPath = isThisCandidateDominatedByAny(currentPruningCandidateIndex, currentPruningCandidate);
+
+            currentPruningCandidateIndex = pruneOrUpdateIndex(currentPruningCandidateIndex, foundDominatingPath);
+        }
+    }
+
+    private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex, RouteCandidatePolygon currentPruningCandidate) {
+        boolean foundDominatingPath = false;
+        for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i--) {
+            // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
+            RouteCandidatePolygon possiblyBetterRouteCandidate = this.candidates.get(i);
+
+            if (isPruningCandidateDominated(currentPruningCandidate, possiblyBetterRouteCandidate)) {
+                foundDominatingPath = true;
+            }
+        }
+        return foundDominatingPath;
+    }
+
+    private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDominatingPath) {
+        if (foundDominatingPath) {
+            this.candidates.remove(currentPruningCandidateIndex);
+        } else {
+            currentPruningCandidateIndex++;
+        }
+        return currentPruningCandidateIndex;
+    }
+
+    private boolean isPruningCandidateDominated(RouteCandidatePolygon currentPruningCandidate, RouteCandidatePolygon possiblyBetterRouteCandidate) {
+        return possiblyBetterRouteCandidate.getDistance() < currentPruningCandidate.getDistance() &&
+               possiblyBetterRouteCandidate.getDistanceInROI() > currentPruningCandidate.getDistanceInROI();
+    }
+
+    private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
+        return currentPruningCandidateIndex < this.candidates.size();
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygon.java
new file mode 100644
index 0000000000..967ba372e0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygon.java
@@ -0,0 +1,112 @@
+package com.graphhopper.routing.template.PolygonRoutingUtil;
+
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.template.PolygonRoutingTemplate;
+
+/**
+ * A route candidate as in Prof. Dr. Sabine Storandts Paper Region-Aware Route Planning.
+ */
+public abstract class RouteCandidatePolygon implements Comparable<RouteCandidatePolygon> {
+    Path startToDetourEntry;
+    Path detourEntryToDetourExit;
+    Path detourExitToEnd;
+    Path directRouteStartEnd;
+    final PolygonRoutingTemplate polygonRoutingTemplate;
+    RoutingAlgorithm routingAlgorithm;
+    final int startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID;
+
+    public RouteCandidatePolygon(final PolygonRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
+                                 final int polygonExitNodeID) {
+        this.polygonRoutingTemplate = polygonRoutingTemplate;
+
+        this.startNodeID = startNodeID;
+        this.endNodeID = endNodeID;
+        this.polygonEntryNodeID = polygonEntryNodeID;
+        this.polygonExitNodeID = polygonExitNodeID;
+    }
+
+    public abstract void calcPaths();
+
+    void calcDirectRouteFromStartToEnd() {
+        this.routingAlgorithm = this.polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
+    }
+
+    public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
+        PathMerge completePathCandidate = new PathMerge(queryGraph, algoOpts.getWeighting());
+
+        completePathCandidate.addPath(startToDetourEntry);
+        completePathCandidate.addPath(detourEntryToDetourExit);
+        completePathCandidate.addPath(detourExitToEnd);
+
+        completePathCandidate.extract();
+
+        return completePathCandidate;
+    }
+
+    public double getDistance() {
+        return this.startToDetourEntry.getDistance() + this.detourEntryToDetourExit.getDistance() + this.detourExitToEnd.getDistance();
+    }
+
+    /**
+     * According to 5.2 in Storandts Region-Aware route planning paper.
+     *
+     * @return The approximated time spent in the region of interest
+     */
+    public double getDistanceInROI() {
+        return this.detourEntryToDetourExit.getDistance();
+    }
+
+    public double getGain() {
+        // + 1 to avoid division by zero
+        return this.getDistanceInROI() / (this.getDetourDistance() + 1);
+    }
+
+    public double getDetourDistance() {
+        return this.getDistance() - this.directRouteStartEnd.getDistance();
+    }
+
+    /**
+     * Uses the sweepline algorithm of Michael Ian Shamos and Dan Hoey to find intersecting line segments induced by the edges of the merged path.
+     * <p>
+     * Reference:
+     * Michael Ian Shamos and Dan Hoey. Geometric intersection problems. In Proceedings
+     * of the 17th Annual IEEE Symposium on Foundations of Computer Science
+     * (FOCS '76), pages 208{215, 1976.
+     *
+     * @return true if at least one intersection occurs and false otherwise.
+     */
+    public boolean isDetourSelfIntersecting() {
+        return false;
+        // TODO: Selfintersecting: Complete route or detour part?
+    }
+
+    @Override
+    public int compareTo(RouteCandidatePolygon o) {
+        final double thisGain = this.getGain();
+        final double thatGain = o.getGain();
+        final double gainDifference = this.getGain() - o.getGain();
+        if (gainDifference < 0) {
+            return -1;
+        } else if (gainDifference == 0) {
+            return 0;
+        } else {
+            return 1;
+        }
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder sb = new StringBuilder();
+
+        sb.append("startNodeID: " + startNodeID + ", ");
+        sb.append("endNodeID: " + endNodeID + ", ");
+        sb.append("polygonEntryNodeID: " + polygonEntryNodeID + ", ");
+        sb.append("polygonExitNodeID: " + polygonExitNodeID + ", ");
+        sb.append("DistanceInROI: " + getDistanceInROI() + ", ");
+        sb.append("detour distance: " + getDetourDistance() + ", ");
+        sb.append("gain: " + this.getGain());
+
+        return sb.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygonThrough.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygonThrough.java
new file mode 100644
index 0000000000..bf90d3bb04
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidatePolygonThrough.java
@@ -0,0 +1,35 @@
+package com.graphhopper.routing.template.PolygonRoutingUtil;
+
+import com.graphhopper.routing.DijkstraManyToMany;
+import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
+
+public class RouteCandidatePolygonThrough extends RouteCandidatePolygon {
+    private final DijkstraManyToMany pathSkeletonRouter;
+    public RouteCandidatePolygonThrough(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int endNodeID,
+                                        int polygonEntryNodeID, int polygonExitNodeID) {
+        super(polygonRoutingTemplate, startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID);
+        this.pathSkeletonRouter = polygonRoutingTemplate.getPathSkeletonRouter();
+    }
+
+    private void calcPathFromStartToDetourEntry() {
+        this.routingAlgorithm = this.polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.startToDetourEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
+    }
+
+    private void calcDetourPath() {
+        this.detourEntryToDetourExit = this.pathSkeletonRouter.getPathByFromEndPoint(polygonEntryNodeID, polygonExitNodeID);
+    }
+
+    private void calcPathFromDetourExitToEnd() {
+        this.routingAlgorithm = this.polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.detourExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
+    }
+
+    @Override
+    public void calcPaths() {
+        calcPathFromStartToDetourEntry();
+        calcDetourPath();
+        calcPathFromDetourExitToEnd();
+        calcDirectRouteFromStartToEnd();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index f6f48d71ca..001643a7e9 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -3,8 +3,9 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidate;
+import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidatePolygon;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidateList;
+import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidatePolygonThrough;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
@@ -13,7 +14,6 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
 
 import java.util.*;
@@ -31,7 +31,7 @@ private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFac
         return !queryGraph.equals(this.queryGraph) || !algoFactory.equals(this.algoFactory) || !algoOpts.equals(this.algorithmOptions);
     }
 
-    RouteCandidateList findCandidateRoutes() {
+    protected RouteCandidateList findCandidateRoutes() {
         List<Integer> nodesInPolygon = getNodesInPolygon();
         List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
         List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
@@ -40,7 +40,6 @@ RouteCandidateList findCandidateRoutes() {
         this.dijkstraForPathSkeleton.findAllPathsBetweenEntryExitPoints();
 
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
-            lookUpStartEndNodes(i);
             buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
         }
 
@@ -61,22 +60,13 @@ private void buildRouteCandidatesForCurrentPoint(List<Integer> currentPointsLOTN
         }
     }
 
-    private RouteCandidate buildCandidatePath(int currentPointID, int nextPointID, int LOTNodeL, int LOTNodeLPrime) {
-        RouteCandidate routeCandidate = new RouteCandidate(this, currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime);
+    private RouteCandidatePolygon buildCandidatePath(int currentPointID, int nextPointID, int LOTNodeL, int LOTNodeLPrime) {
+        RouteCandidatePolygon routeCandidate = new RouteCandidatePolygonThrough(this, currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime);
+        routeCandidate.calcPaths();
 
         return routeCandidate;
     }
 
-    private void lookUpStartEndNodes(int pointsIndex) {
-        // TODO Check if this is necessary since we already have node ids and we would add additional via points to the queryGraph result cache. This could have an impact.
-//        final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
-//        final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
-//
-//        List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
-//        List<QueryResult> lookupResults = super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
-//        this.queryGraph.lookup(lookupResults);
-    }
-
     // Definition 6 in Storandts paper Region-Aware Routing Planning
     private List<List<Integer>> findLocalOptimalTouchnodes(final List<Integer> polygonEntryExitPoints) {
         // TODO: Is there an A* one to many option? Does this make sense at all?
@@ -197,11 +187,6 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
         return visitor.getNodesInPolygon();
     }
 
-    public RoutingAlgorithm getNewRoutingAlgorithm() {
-        return this.algoFactory.createAlgo(queryGraph, algorithmOptions);
-        //return this.routingAlgorithm;
-    }
-
     public DijkstraManyToMany getPathSkeletonRouter() {
         return this.dijkstraForPathSkeleton;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateListTest.java
new file mode 100644
index 0000000000..7ab7b40dc2
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateListTest.java
@@ -0,0 +1,126 @@
+package com.graphhopper.routing.template.PolygonRoutingUtil;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.template.PolygonRoutingTemplate;
+import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.shapes.Polygon;
+import org.junit.Test;
+
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class RouteCandidateListTest {
+    final RouteCandidateList<RouteCandidateMocker> candidateList = new RouteCandidateList<>();
+    final GHRequest ghRequest = new GHRequest(0,0, 10, 10).setPolygon(new Polygon(new double [] {5,10,10,5}, new double [] {5,5,10,10}));
+    final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, null, null, null, null);
+    final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
+
+    private void addTestingCandidates() {
+        this.candidateList.candidates.clear();
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 3,6,1, "a"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 2,3,1, "b"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 6,6,5, "c"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 4,5,3, "d"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 8,4,6, "e"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 6,1,3, "f"));
+        this.candidateList.candidates.add(new RouteCandidateMocker(routingTemplate, 7,1,6, "g"));
+    }
+
+    @Test
+    public void assertCorrectListContentAfterPruning() {
+        addTestingCandidates();
+        this.candidateList.pruneDominatedCandidateRoutes();
+
+        assertEquals("a", this.candidateList.candidates.get(0).name);
+        assertEquals("c", this.candidateList.candidates.get(1).name);
+        assertEquals("b", this.candidateList.candidates.get(2).name);
+    }
+
+    @Test
+    public void assertCorrectTopThreeRoutes() {
+        addTestingCandidates();
+        this.candidateList.pruneDominatedCandidateRoutes();
+        this.candidateList.sortByGainAscending();
+
+        List<Path> topCandidates = this.candidateList.getFirstAsPathList(3, new QueryGraph(graphMocker.graph), new AlgorithmOptions("dijkstrabi", graphMocker.weighting,
+                                                                                                                                    graphMocker.traversalMode));
+
+        assertEquals("c", ((TestPath) topCandidates.get(0)).name);
+        assertEquals("a", ((TestPath) topCandidates.get(1)).name);
+        assertEquals("b", ((TestPath) topCandidates.get(2)).name);
+        assertEquals(3, topCandidates.size());
+    }
+
+    @Test
+    public void assertCorrectBestCandidate() {
+
+    }
+
+    public class RouteCandidateMocker extends RouteCandidatePolygon {
+        protected final double polygonRouteDistance;
+        protected final double roiDistance;
+        protected final double directDistance;
+        protected final String name;
+
+        public RouteCandidateMocker(PolygonRoutingTemplate polygonRoutingTemplate, final double polygonRouteDistance, final double distanceInROI, final double directDistance,
+                                    final String name) {
+            super(polygonRoutingTemplate, 0,3,1,2);
+
+            this.polygonRouteDistance = polygonRouteDistance;
+            this.roiDistance = distanceInROI;
+            this.directDistance = directDistance;
+            this.name = name;
+        }
+
+        @Override
+        public void calcPaths() {
+
+        }
+
+        @Override
+        public double getDistance() { return this.polygonRouteDistance; }
+
+        @Override
+        public double getDistanceInROI() { return this.roiDistance; }
+
+        @Override
+        public double getDetourDistance() { return this.getDistance() - this.directDistance; }
+
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+
+            sb.append(super.toString());
+            sb.append(", name: ");
+            sb.append(name);
+
+            return sb.toString();
+        }
+
+        @Override
+        public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algorithmOptions) {
+            Path mergedPath = new TestPath(graphMocker.graph, graphMocker.weighting, this.name);
+            return mergedPath;
+        }
+    }
+
+    private class TestPath extends Path {
+        final String name;
+
+        public TestPath(Graph graph, Weighting weighting, final String name) {
+            super(graph, weighting);
+            this.name = name;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateTest.java
new file mode 100644
index 0000000000..d6ffcb649b
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidateTest.java
@@ -0,0 +1,87 @@
+package com.graphhopper.routing.template.PolygonRoutingUtil;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.PathMerge;
+import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
+import com.graphhopper.util.shapes.Polygon;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class RouteCandidateTest {
+    final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double [] {5, 10, 10, 5}, new double [] {5, 5, 10, 10}));
+    final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
+    final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, graphMocker.locationIndex, graphMocker.nodeAccess, graphMocker.graph
+            , graphMocker.encodingManager);
+
+
+    @Test
+    public void testCorrectDistanceMetricsSmaller() {
+        RouteCandidatePolygon testSmaller = setupSmallerRouteCandidate();
+
+        assertEquals(1, testSmaller.getDistanceInROI(), 0);
+        assertEquals(3, testSmaller.getDistance(), 0);
+        assertEquals(2, testSmaller.directRouteStartEnd.getDistance(), 0);
+        assertEquals(1, testSmaller.getDetourDistance(), 0);
+        assertEquals(0.5, testSmaller.getGain(), 0);
+    }
+
+    @Test
+    public void testCorrectDistanceMetricsGreater() {
+        RouteCandidatePolygon testGreater = setupGreaterRouteCandidate();
+
+        assertEquals(2, testGreater.getDistanceInROI(), 0);
+        assertEquals(6, testGreater.getDistance(), 0);
+        assertEquals(5, testGreater.directRouteStartEnd.getDistance(), 0);
+        assertEquals(1, testGreater.getDetourDistance(), 0);
+        assertEquals(1, testGreater.getGain(), 0);
+    }
+
+    @Test
+    public void testCorrectComparision() {
+        RouteCandidatePolygon testSmaller = setupSmallerRouteCandidate();
+        RouteCandidatePolygon testGreater = setupGreaterRouteCandidate();
+
+        final int comparisionResult = testSmaller.compareTo(testGreater);
+        assertEquals(-1, comparisionResult);
+    }
+
+    private RouteCandidatePolygon setupGreaterRouteCandidate() {
+        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 0, 3, 1, 2);
+        test.startToDetourEntry = createTestSubPath(7, 28, 2);
+        test.detourEntryToDetourExit = createTestSubPath(72, 29, 2);
+        test.detourExitToEnd = createTestSubPath(12, 3, 2);
+        test.directRouteStartEnd = createDirectRoute(5);
+        return test;
+    }
+
+    private RouteCandidatePolygon setupSmallerRouteCandidate() {
+        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 0, 3, 1, 2);
+        test.startToDetourEntry = createTestSubPath(7, 28, 1);
+        test.detourEntryToDetourExit = createTestSubPath(72, 29, 1);
+        test.detourExitToEnd = createTestSubPath(12, 3, 1);
+        test.directRouteStartEnd = createDirectRoute(2);
+        return test;
+    }
+
+    private Path createTestSubPath(int edgeId, int endNode, int distance) {
+        Path startPolygon = new PathMerge(graphMocker.graph, graphMocker.weighting);
+        startPolygon.addEdge(edgeId);
+        startPolygon.setEndNode(endNode);
+        startPolygon.setDistance(distance);
+        startPolygon.setFound(true);
+        return startPolygon;
+    }
+
+    private Path createDirectRoute(int distance) {
+        Path directRoute = new PathMerge(graphMocker.graph, graphMocker.weighting);
+        directRoute.addEdge(3);
+        directRoute.addEdge(8);
+        directRoute.setEndNode(3);
+        directRoute.setDistance(distance);
+        directRoute.setFound(true);
+        return directRoute;
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
index d1c2c16362..442e8d2de2 100644
--- a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
@@ -3,101 +3,24 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.profiles.*;
-import com.graphhopper.routing.template.util.PolygonRoutingTestGraphs;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.IntsRef;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.util.InstructionAnnotation;
-import com.graphhopper.util.Parameters;
-import com.graphhopper.util.Translation;
 import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.Polygon;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.management.Query;
 import java.util.ArrayList;
 import java.util.List;
 
 import static com.graphhopper.util.Parameters.Routing.*;
 
 public class PolygonThroughRoutingTemplateTest {
-    private PolygonRoutingTestGraphs testGraphCreator = new PolygonRoutingTestGraphs();
-    private EncodingManager encodingManager;
-    private GraphHopperStorage testGraph;
-    private Polygon polygon;
-    private LocationIndex locationIndex;
-    private NodeAccess nodeAccess;
-    private TraversalMode traversalMode;
-    private String algorithmName;
-    private HintsMap algorithmHints;
-    private FlagEncoder flagEncoder;
-    private Weighting weighting;
+    private PolygonRoutingTestGraph testGraph = new PolygonRoutingTestGraph();
+
 
     @Before
     public void initVariables() {
-        this.createEncodingManager();
-        this.createTestGraph();
-        this.createTestPolygon();
-        this.createLocationIndex();
-        this.getNodeAccess();
-        this.setTraversalMode();
-        this.setAlgorithmName();
-        this.buildHintsMap();
-        this.setWeighting();
-    }
-
-
-    private void createEncodingManager() {
-        final FlagEncoder carFlagEncoder = new CarFlagEncoder();
-        this.flagEncoder = carFlagEncoder;
-        this.encodingManager = EncodingManager.create(carFlagEncoder);
-    }
-
-    private void createTestGraph() {
-        this.testGraph = this.testGraphCreator.createPolygonTestGraph(encodingManager);
-    }
-
-    private void createTestPolygon() {
-        this.polygon = new PolygonRoutingTestGraphs().createPolygon();
-    }
-
-    private void createLocationIndex() {
-        this.locationIndex = this.testGraphCreator.getCorrespondingIndex();
-    }
-
-    private void getNodeAccess() {
-        this.nodeAccess = this.testGraph.getNodeAccess();
-    }
-
-    private void setTraversalMode() {
-        this.traversalMode = TraversalMode.NODE_BASED;
-    }
-
-    private void setAlgorithmName() {
-        this.algorithmName = "dijkstrabi";
-    }
-
-    private void buildHintsMap() {
-        this.algorithmHints = new HintsMap();
-        this.algorithmHints.put("elevation", "false");
-        this.algorithmHints.put("instructions", "true");
-        this.algorithmHints.put("way_point_max_distance", "1.0");
-        this.algorithmHints.put("calc_points", "true");
-        this.algorithmHints.put("type", "json");
-        this.algorithmHints.put("locale", "de-DE");
-        this.algorithmHints.put("weighting", "fastest");
-        this.algorithmHints.put("key", "");
-        this.algorithmHints.put("vehicle", "car");
-    }
-
-    private void setWeighting() {
-        this.weighting = new FastestWeighting(this.flagEncoder, this.algorithmHints);
     }
 
     @Test
@@ -105,20 +28,21 @@ public void quickStartingTest() {
         // Just to let something run
         GHRequest request = buildRequest(new GHPoint(25, 0), new GHPoint(25, 46));
         GHResponse response = new GHResponse();
-        final int maxVisitedNodes = this.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
+        final int maxVisitedNodes = this.testGraph.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
 
-        RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.locationIndex, this.nodeAccess, this.testGraph, this.encodingManager);
+        RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.testGraph.locationIndex, this.testGraph.nodeAccess, this.testGraph.graph,
+                                                                            this.testGraph.encodingManager);
         RoutingAlgorithmFactory algorithmFactory = new RoutingAlgorithmFactorySimple();
-        AlgorithmOptions algorithmOptions = buildAlgorithmOptions(algorithmHints, this.traversalMode, this.algorithmName, this.weighting, maxVisitedNodes);
+        AlgorithmOptions algorithmOptions = buildAlgorithmOptions(testGraph.algorithmHints, this.testGraph.traversalMode, this.testGraph.algorithmName, this.testGraph.weighting, maxVisitedNodes);
 
-        List<Path> paths = routingTemplate.calcPaths(new QueryGraph(this.testGraph), algorithmFactory, algorithmOptions);
+        List<Path> paths = routingTemplate.calcPaths(new QueryGraph(this.testGraph.graph), algorithmFactory, algorithmOptions);
         System.out.println(paths.get(0).getNodesInPathOrder());
         System.out.println(paths.toString());
     }
 
     @Test
     public void showAllEdgesWithIDs() {
-        AllEdgesIterator aei = this.testGraph.getAllEdges();
+        AllEdgesIterator aei = this.testGraph.graph.getAllEdges();
         while (aei.next()) {
             System.out.println(aei.toString());
         }
@@ -151,7 +75,7 @@ private GHRequest buildRequest(GHPoint... startViaEndPoints) {
                 setPointHints(new ArrayList<String>()).
                 setSnapPreventions(new ArrayList<String>()).
                 setPathDetails(new ArrayList<String>()).
-                setPolygon(this.polygon).
+                setPolygon(this.testGraph.polygon).
                 getHints().
                 put(CALC_POINTS, calcPoints).
                 put(INSTRUCTIONS, instructions).
diff --git a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
rename to core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
index a14c9aac74..a5534b334e 100644
--- a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
+++ b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraph.java
@@ -1,8 +1,9 @@
 package com.graphhopper.routing.template.util;
 
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -14,19 +15,37 @@
 import com.graphhopper.util.shapes.Polygon;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
-public class PolygonRoutingTestGraphs {
-    private final TurnCostExtension turnCostExtension;
-    private GraphHopperStorage graph;
-    private Node[] nodes;
-    private DistanceCalc2D distanceCalculator;
-
-    public PolygonRoutingTestGraphs() {
+public class PolygonRoutingTestGraph {
+    public final TurnCostExtension turnCostExtension;
+    public Node[] nodes;
+    public DistanceCalc2D distanceCalculator;
+    public EncodingManager encodingManager;
+    public FlagEncoder flagEncoder;
+    public GraphHopperStorage graph;
+    public Polygon polygon;
+    public LocationIndex locationIndex;
+    public NodeAccess nodeAccess;
+    public TraversalMode traversalMode;
+    public String algorithmName;
+    public HintsMap algorithmHints;
+    public Weighting weighting;
+
+    public PolygonRoutingTestGraph() {
         this.turnCostExtension = new TurnCostExtension();
         this.distanceCalculator = new DistanceCalc2D();
+        this.createEncodingManager();
+        this.createTestGraph();
+        this.createTestPolygon();
+        this.createLocationIndex();
+        this.getNodeAccess();
+        this.setTraversalMode();
+        this.setAlgorithmName();
+        this.buildHintsMap();
+        this.setWeighting();
     }
 
-    public GraphHopperStorage createPolygonTestGraph(EncodingManager tmpEM) {
-        this.graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, turnCostExtension);
+    public GraphHopperStorage createPolygonTestGraph() {
+        this.graph = new GraphHopperStorage(new RAMDirectory(), this.encodingManager, false, turnCostExtension);
         this.graph.create(1000);
 
         // Exterior this.graph including to Entry / Exit nodes
@@ -402,4 +421,49 @@ public MinDistanceNodeFinder invoke() {
             return this;
         }
     }
+
+    private void createEncodingManager() {
+        final FlagEncoder carFlagEncoder = new CarFlagEncoder();
+        this.flagEncoder = carFlagEncoder;
+        this.encodingManager = EncodingManager.create(carFlagEncoder);
+    }    private void createTestGraph() {
+        this.graph = this.createPolygonTestGraph();
+    }
+
+    private void createTestPolygon() {
+        this.polygon = createPolygon();
+    }
+
+    private void createLocationIndex() {
+        this.locationIndex = this.getCorrespondingIndex();
+    }
+
+    private void getNodeAccess() {
+        this.nodeAccess = this.graph.getNodeAccess();
+    }
+
+    private void setTraversalMode() {
+        this.traversalMode = TraversalMode.NODE_BASED;
+    }
+
+    private void setAlgorithmName() {
+        this.algorithmName = "dijkstrabi";
+    }
+
+    private void buildHintsMap() {
+        this.algorithmHints = new HintsMap();
+        this.algorithmHints.put("elevation", "false");
+        this.algorithmHints.put("instructions", "true");
+        this.algorithmHints.put("way_point_max_distance", "1.0");
+        this.algorithmHints.put("calc_points", "true");
+        this.algorithmHints.put("type", "json");
+        this.algorithmHints.put("locale", "de-DE");
+        this.algorithmHints.put("weighting", "fastest");
+        this.algorithmHints.put("key", "");
+        this.algorithmHints.put("vehicle", "car");
+    }
+
+    private void setWeighting() {
+        this.weighting = new FastestWeighting(this.flagEncoder, this.algorithmHints);
+    }
 }
