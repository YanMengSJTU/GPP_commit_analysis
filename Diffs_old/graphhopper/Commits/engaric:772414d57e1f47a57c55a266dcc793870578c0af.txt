diff --git a/.travis.yml b/.travis.yml
index b1b8faf3f1..178e6f4a75 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,4 +8,7 @@ install: true
 script: ./core/files/travis-build.sh
 notifications:
   email:
-    - github@graphhopper.com
\ No newline at end of file
+    - github@graphhopper.com
+
+# enable container-based stack
+sudo: false
\ No newline at end of file
diff --git a/README.md b/README.md
index 377c3f9495..1d2bba0701 100644
--- a/README.md
+++ b/README.md
@@ -29,7 +29,7 @@ and [iOS](http://github.com/graphhopper/graphhopper-ios)
 Get Started
 ---------------
 
-Read through our [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), 
+Read through our Documentation ([0.3](https://github.com/graphhopper/graphhopper/blob/0.3/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
 and sign up to the [mailing list](http://graphhopper.com/#developers).
 
@@ -50,4 +50,4 @@ Features
  * Highly customizable
  * Works on the desktop, as a web service and offline on Android or iOS
  * Large test suite
- * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
+ * [... more](http://graphhopper.com/#overview)
diff --git a/android/src/com/graphhopper/android/AndroidDownloader.java b/android/src/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..e5b8e83268
--- /dev/null
+++ b/android/src/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,69 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader
+{
+
+    public AndroidDownloader()
+    {
+        super("GraphHopper Android");
+    }
+
+    @Override
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
+            @Override
+            public void update( long sumBytes )
+            {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    @Override
+    public String downloadAsString( String url ) throws IOException
+    {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+
+    // There is something broken on Android with HTTPS and Android HttpURLConnection.
+    // Probably for 4.* only? See #251 for discussion and https://developer.android.com/training/articles/security-ssl.html
+    private HttpEntity getEntity( String url )
+    {        
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try
+        {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+}
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/src/com/graphhopper/android/MainActivity.java
index d6afb483a6..2e038c38c9 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/src/com/graphhopper/android/MainActivity.java
@@ -52,7 +52,6 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
@@ -239,8 +238,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").
-                        downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -263,6 +261,7 @@ protected void onPostExecute( List<String> nameList )
             {
                 if (hasError() || nameList.isEmpty())
                 {
+                    getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
@@ -273,10 +272,8 @@ protected void onPostExecute( List<String> nameList )
                     public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder, selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder, selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -357,7 +354,7 @@ protected Object saveDoInBackground( Void... _ignore )
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                Downloader downloader = new Downloader("GraphHopper Android");
+                AndroidDownloader downloader = new AndroidDownloader();
                 downloader.setTimeout(30000);
                 downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
diff --git a/config-example.properties b/config-example.properties
index 026338ae2c..f57a1add45 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,19 +1,7 @@
-#################
-### OSMReader ###
-
-graph.dataaccess=RAM_STORE
-# graph.dataaccess=MMAP_STORE_SYNC
-
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# Use chWeighting=no to disable it (more flexibility while querying) 
-# Java API usage is: GraphHopper.setCHWeighting("fastest")
-prepare.chWeighting=fastest
-
-# increase from 1 to 5, to reduce way geometry e.g. for android
-osmreader.wayPointMaxDistance=1
-
+####################
+##### Vehicles #####
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together remeber to set "prepare.chWeighting=no" above.
+# When using two or three option together set "prepare.chWeighting=no" - see below
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
 # and requires enabling graph.elevation.provider below, e.g. see #169
 graph.flagEncoders=car
@@ -21,20 +9,33 @@ graph.flagEncoders=car
 # to enable turn restrictions for car do
 # graph.flagEncoders=car|turnCosts=true
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
-# osmreader.instructions=false
 
+
+##### Elevation #####
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
+#
 # default location for cache is used /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
+#
 # If you have a slow disk or plenty of RAM change the default MMAP to
 # graph.elevation.dataaccess=RAM_STORE
 
-# Location index lookup. Advanced customization. Resolution is in meter, the search specifies the 'radius' in number of tiles.
-# E.g. decrease resolution for a faster lookup and increase region search for a more dynamic search and less 'location not found' results
-# index.highResolution=300
-# index.maxRegionSearch=4
 
+
+##### Storage #####
+# configure the memory access, use RAM_STORE for well equipped servers
+# MMAP_STORE_SYNC could be used otherwise but will be a lot slower
+graph.dataaccess=RAM_STORE
+
+# if you want to reduce storage size and you don't need instructions for a path uncomment this
+# osmreader.instructions=false
+
+# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
+prepare.chWeighting=fastest
+
+
+
+##### Web #####
 # if you want to support jsonp response type you need to add it explicitely here:
 #web.jsonpAllowed=true
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index ecf782503d..a735d96d27 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk vi_VI"
+translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 574cd0d1cd..68ca6d8d94 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -83,6 +83,14 @@
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <version>20140107</version>
+            <scope>test</scope>
+        </dependency>
+        
     </dependencies>
         
     <build>
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index d3d294865a..c37edcd413 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -37,7 +37,6 @@
     private double routeWeight;
     private long time;
     private InstructionList instructions = null;
-    private boolean found;
 
     public GHResponse()
     {
@@ -157,7 +156,7 @@ public double getRouteWeight()
     public BBox calcRouteBBox( BBox _fallback )
     {
         check("calcRouteBBox");
-        BBox bounds = BBox.INVERSE.clone();
+        BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = list.getSize();
         if (len == 0)
             return _fallback;
@@ -166,17 +165,14 @@ public BBox calcRouteBBox( BBox _fallback )
         {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (lat > bounds.maxLat)
-                bounds.maxLat = lat;
-
-            if (lat < bounds.minLat)
-                bounds.minLat = lat;
-
-            if (lon > bounds.maxLon)
-                bounds.maxLon = lon;
-
-            if (lon < bounds.minLon)
-                bounds.minLon = lon;
+            if (bounds.hasElevation())
+            {
+                double ele = list.getEle(i);
+                bounds.update(lat, lon, ele);
+            } else
+            {
+                bounds.update(lat, lon);
+            }
         }
         return bounds;
     }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f23e462595..95c07af129 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -63,6 +63,7 @@
     boolean enableInstructions = true;
     private boolean fullyLoaded = false;
     // for routing
+    private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
     private String defaultVehicleStr;
@@ -73,7 +74,7 @@
     private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
@@ -116,6 +117,9 @@ public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
         this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
@@ -180,18 +184,18 @@ public TraversalMode getTraversalMode()
     }
 
     /**
-     * Configures the underlying storage to be used on a well equipped server.
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
         setSimplifyResponse(true);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer with enough RAM but no
-     * network latency.
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
      */
     public GraphHopper forDesktop()
     {
@@ -200,8 +204,8 @@ public GraphHopper forDesktop()
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine like Android and
-     * Raspberry Pi with only few RAM.
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
      */
     public GraphHopper forMobile()
     {
@@ -221,6 +225,12 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
     /**
      * This method call results in an in-memory graph.
      */
@@ -304,8 +314,8 @@ public String getCHWeighting()
     }
 
     /**
-     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
-     * the full usage of CH use setCHEnable(false) instead.
+     * <<<<<<< HEAD Disables the "CH-preparation" preparation only. Use only if you know what you
+     * do. To disable the full usage of CH use setCHEnable(false) instead.
      */
     public GraphHopper setDoPrepare( boolean doPrepare )
     {
@@ -315,7 +325,11 @@ public GraphHopper setDoPrepare( boolean doPrepare )
 
     /**
      * Enables or disables contraction hierarchies (CH). Enabled by default, this is called speed-up
-     * mode. Without CH it is called flexibility mode.
+     * mode. Without CH it is called flexibility mode. ======= Enables or disables contraction
+     * hierarchies. Enabled by default. Disabling CH is only recommended for a small area or in
+     * combination with setDefaultWeightLimit
+     * <p>
+     * @see #setDefaultWeightLimit(double) >>>>>>> master
      */
     public GraphHopper setCHEnable( boolean enable )
     {
@@ -325,6 +339,17 @@ public GraphHopper setCHEnable( boolean enable )
         return this;
     }
 
+    /**
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
+     */
+    public void setDefaultWeightLimit( double defaultWeightLimit )
+    {
+        this.defaultWeightLimit = defaultWeightLimit;
+    }
+
     public boolean isCHEnabled()
     {
         return chEnabled;
@@ -542,7 +567,7 @@ public GraphHopper init( CmdArgs args )
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
@@ -559,9 +584,7 @@ public GraphHopper init( CmdArgs args )
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
         String flagEncoders = args.get("graph.flagEncoders", "");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
@@ -571,6 +594,9 @@ public GraphHopper init( CmdArgs args )
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
@@ -857,12 +883,6 @@ public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEnco
     @Override
     public GHResponse route( GHRequest request )
     {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
-
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
@@ -885,6 +905,12 @@ public GHResponse route( GHRequest request )
 
     protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
+        if (graph == null || !fullyLoaded)
+            throw new IllegalStateException("Call load or importOrLoad before routing");
+
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
             vehicle = getDefaultVehicle();
@@ -943,6 +969,7 @@ public GHResponse route( GHRequest request )
         Weighting weighting = createWeighting(request.getHints(), encoder);
         weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
         AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
 
@@ -951,6 +978,7 @@ public GHResponse route( GHRequest request )
             QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
             RoutingAlgorithm algo = getAlgorithmFactory().createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
             sw = new StopWatch().start();
@@ -1041,7 +1069,7 @@ protected void cleanUp()
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 3b6e167958..06f694cbae 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -61,7 +61,7 @@ public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double min
 
     public LinearKeyAlgo setBounds( BBox bounds )
     {
-        setBounds(bounds.minLon, bounds.maxLat, bounds.minLat, bounds.maxLat);
+        setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
@@ -115,4 +115,5 @@ public double getLonDelta()
     {
         return lonDelta;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 5f9cd07277..56ba796d60 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -96,6 +96,9 @@ private Path runAlgo()
         {
             int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitReached())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
@@ -109,7 +112,7 @@ private Path runAlgo()
                 int traversalId = traversalMode.createTraversalId(iter, false);
                 // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
                 float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
-                                                      + currEdge.weightOfVisitedPath);
+                        + currEdge.weightOfVisitedPath);
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
@@ -124,7 +127,7 @@ private Path runAlgo()
                         fromMap.put(traversalId, ase);
                     } else
                     {
-                        assert(ase.weight > distEstimation): "Inconsistent distance estimate";
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
@@ -173,6 +176,11 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index fd854eb62e..f8a92e1bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -162,6 +162,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -178,8 +181,13 @@ protected boolean finished()
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight();
-        return currFrom.weight + currTo.weight >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index c2fb75debd..2a047c7434 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,6 +40,8 @@
 
     protected abstract Path createAndInitPath();
 
+    protected abstract boolean isWeightLimitReached();
+
     abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
 
     abstract boolean fillEdgesFrom();
@@ -62,9 +64,9 @@ public Path calcPath( int from, int to )
         return extractPath();
     }
 
-    void runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitReached())
         {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 8c13e4e0df..62349b3d81 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -38,6 +38,7 @@
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
     protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
@@ -57,6 +58,12 @@ public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting wei
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
     }
 
+    @Override
+    public void setWeightLimit( double weight )
+    {
+        this.weightLimit = weight;
+    }
+       
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
     {
         this.additionalEdgeFilter = additionalEdgeFilter;
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 031fe22b6c..16d7cd0df6 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -38,11 +38,11 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
     public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
@@ -66,16 +66,17 @@ public Path calcPath( int from, int to )
         {
             fromMap.put(from, currEdge);
         }
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitReached() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
@@ -111,13 +112,12 @@ private Path runAlgo()
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
@@ -129,20 +129,26 @@ protected boolean finished()
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitReached() || !finished())
             return createEmptyPath();
+
         return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
     {
-        return AlgorithmOptions.DIJKSTRA;
+        return visitedNodes;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 24e62ba052..d3de4faa19 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -129,6 +129,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -177,6 +180,12 @@ public boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
             TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
@@ -252,12 +261,6 @@ protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurre
         }
     }
 
-    @Override
-    public String getName()
-    {
-        return AlgorithmOptions.DIJKSTRA_BI;
-    }
-
     TIntObjectMap<EdgeEntry> getBestFromMap()
     {
         return bestWeightMapFrom;
@@ -302,4 +305,10 @@ void setBestPath( PathBidirRef bestPath )
     {
         this.bestPath = bestPath;
     }
+
+    @Override
+    public String getName()
+    {
+        return AlgorithmOptions.DIJKSTRA_BI;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 5056a82dfa..d566173302 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -22,7 +22,6 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
@@ -45,7 +44,6 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
@@ -68,12 +66,6 @@ public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting,
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
@@ -95,8 +87,9 @@ public Path extractPath()
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitReached())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
@@ -164,7 +157,7 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                int adjNode = iter.getAdjNode();                
+                int adjNode = iter.getAdjNode();
                 int prevEdgeId = edgeIds[adjNode];
                 if (!accept(iter, prevEdgeId))
                     continue;
@@ -192,7 +185,7 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitReached())
                 return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
@@ -207,7 +200,12 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return weights[currNode] >= weightLimit;
     }
 
     public void close()
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 3cbcc4692c..d0e9f9aa24 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -34,6 +35,7 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
@@ -384,22 +386,28 @@ public InstructionList calcInstructions( final Translation tr )
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
                 long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -408,86 +416,160 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                    updatePointsAndInstruction(edge, wayGeo);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                     ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                    if ((!name.equals(tmpName))
-                            || (!annotation.equals(tmpAnnotation)))
+                    if (isRoundabout)
+                        // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                                                annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
+
+                        // Add passed exits to instruction. There is an exit if there are
+                        // at least 2 out-going edges (one continuing in the roundabout)
+                        // This could lead to problems if there are non-complete roundabouts!
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        edgeIter.next();
+                        if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNumber();}
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
+                    {
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                            .setRadian(deltaInOut)
+                            .setDirOfRotation(deltaOut)
+                            .setExited();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        annotation = tmpAnnotation;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11°
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, annotation, points);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()) );
                         ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                }
                 else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong =  wayGeo.getLongitude(beforeLast);
                 }
+                prevInRoundabout = isRoundabout;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
                     ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -496,7 +578,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index 1e5436f154..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -34,6 +34,12 @@
      */
     Path calcPath( int from, int to );
 
+    /**
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
+     */
+    void setWeightLimit( double weight );
+
     /**
      * @return name of this algorithm
      */
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index ce088beeee..ae6609148f 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -32,7 +32,7 @@
 {
     @Override
     public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {
+    {        
         AbstractRoutingAlgorithm algo;
         String algoStr = opts.getAlgorithm();
         if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 067b47640f..088fbadfd5 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -590,8 +590,8 @@ void findShortcuts( ShortcutHandler sch )
                     continue;
 
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                prepareAlgo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
                         .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
@@ -792,9 +792,11 @@ protected boolean finished()
                     if (finishedFrom && finishedTo)
                         return true;
 
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
+
                     // changed finish condition for CH
-                    double tmpWeight = bestPath.getWeight();
-                    return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
                 }
 
                 @Override
@@ -837,6 +839,9 @@ public boolean finished()
                     if (finishedFrom && finishedTo)
                         return true;
 
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
+
                     // changed also the final finish condition for CH                
                     return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
                 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 084b956469..e9af85667b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -65,6 +65,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index f2ca16fcbe..8baa0804c1 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -69,6 +69,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         restrictedValues.add("no");
         restrictedValues.add("restricted");
         restrictedValues.add("delivery");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("permissive");
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 789e41a269..3a5a7f1632 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -38,7 +38,7 @@
     public FastestWeighting( FlagEncoder encoder )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed() * SPEED_CONV;
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
     @Override
@@ -53,7 +53,7 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / (speed * SPEED_CONV);
+        return edge.getDistance() / speed * SPEED_CONV;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index e72d4688f0..87ab0156a1 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -67,6 +67,7 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 01a363bfc9..a02bf36a83 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -43,7 +43,7 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
     private FlagEncoder singleEncoder;
@@ -64,9 +64,9 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
-    public PrepareRoutingSubnetworks setMinOnewayNetworkSize( int minOnewayNetworkSize )
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
     {
-        this.minOnewayNetworkSize = minOnewayNetworkSize;
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
         return this;
     }
 
@@ -77,7 +77,7 @@ public void doWork()
         keepLargeNetworks(map);
 
         int unvisitedDeadEnds = -1;
-        if ((this.minOnewayNetworkSize > 0) && singleEncoder != null)
+        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
             unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
@@ -245,8 +245,7 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
         int removed = 0;
         for (TIntArrayList component : components)
         {
-
-            if (component.size() < minOnewayNetworkSize)
+            if (component.size() < minOneWayNetworkSize)
             {
                 for (int i = 0; i < component.size(); i++)
                 {
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index 67346bf3f4..b075f3864f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -60,25 +60,13 @@ public final void setNode( int nodeId, double lat, double lon, double ele )
         {
             // meter precision is sufficient for now
             that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
-            if (ele > that.bounds.maxEle)
-                that.bounds.maxEle = ele;
+            that.bounds.update(lat, lon, ele);
 
-            if (ele < that.bounds.minEle)
-                that.bounds.minEle = ele;
+        } else
+        {
+            that.bounds.update(lat, lon);
         }
 
-        if (lat > that.bounds.maxLat)
-            that.bounds.maxLat = lat;
-
-        if (lat < that.bounds.minLat)
-            that.bounds.minLat = lat;
-
-        if (lon > that.bounds.maxLon)
-            that.bounds.maxLon = lon;
-
-        if (lon < that.bounds.minLon)
-            that.bounds.minLon = lon;
-
         // set the default value for the additional field of this node
         if (that.extStorage.isRequireNodeField())
             that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 69ee74105e..de2e8b4a51 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -120,7 +120,7 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.INVERSE.clone();
+        this.bounds = BBox.createInverse(withElevation);
         this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
@@ -1145,7 +1145,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1295,7 +1295,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1490,6 +1490,13 @@ protected int loadNodesHeader()
         bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
         bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
         bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }        
+
         return 7;
     }
 
@@ -1502,6 +1509,12 @@ protected int setNodesHeader()
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
         return 7;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index b9fdbf6b5f..49a7786419 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -131,8 +131,11 @@ void prepareAlgo()
         // if we assume a minimum resolution like 0.5km for a leaf-tile                
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
-        if (graph.getNodes() == 0 || !bounds.check())
-            throw new IllegalStateException("Bounds of graph are invalid: " + bounds);
+        if (graph.getNodes() == 0)
+            throw new IllegalStateException("Cannot create location index of empty graph!");
+
+        if (!bounds.isValid())
+            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
 
         double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
         double maxDistInMeter = Math.max(
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 09756dad5f..11957181dd 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -195,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -275,7 +278,7 @@ public final int getIntHigh( long longValue )
         return (int) (longValue >> 32);
     }
 
-    public final long combineIntsToLong( int intLow, int intHigh)
+    public final long combineIntsToLong( int intLow, int intHigh )
     {
         return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
     }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 7eac90a65e..27538e3e61 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -50,8 +50,8 @@
     public static final String OS_ARCH = System.getProperty("os.arch");
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
-    public static final int VERSION_NODE = 3;
-    public static final int VERSION_EDGE = 9;
+    public static final int VERSION_NODE = 4;
+    public static final int VERSION_EDGE = 10;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 599ca36916..5e56078c64 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -358,6 +358,8 @@ public static final int degreeToInt( double deg )
     {
         if (deg >= Double.MAX_VALUE)
             return Integer.MAX_VALUE;
+        if (deg <= -Double.MAX_VALUE)
+            return -Integer.MAX_VALUE;
         return (int) (deg * DEGREE_FACTOR);
     }
 
@@ -370,6 +372,8 @@ public static final double intToDegree( int storedInt )
     {
         if (storedInt == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
+        if (storedInt == -Integer.MAX_VALUE)
+            return -Double.MAX_VALUE;
         return (double) storedInt / DEGREE_FACTOR;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index b5792db8c4..4bcc150ae1 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,11 +17,16 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -31,18 +36,20 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
         this.sign = sign;
         this.name = name;
@@ -55,19 +62,34 @@ public InstructionAnnotation getAnnotation()
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName(String name)
+    {
+        this.name = name;
+    }
+
+    public Map<String,Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo(String key, Object value)
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -223,7 +245,7 @@ void checkOne()
     public String getTurnDescription( Translation tr )
     {
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
         if (indi == Instruction.FINISH)
         {
@@ -233,7 +255,7 @@ public String getTurnDescription( Translation tr )
             str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
         } else if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
@@ -261,7 +283,7 @@ public String getTurnDescription( Translation tr )
             if (dir == null)
                 throw new IllegalStateException("Indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 51eedba419..5d36783569 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -61,47 +61,6 @@ public int size()
         return instructions.size();
     }
 
-    /**
-     * Returns the descriptions of the distance per instruction.
-     */
-    public List<String> createDistances( boolean mile )
-    {
-        List<String> labels = new ArrayList<String>(instructions.size());
-        for (int i = 0; i < instructions.size(); i++)
-        {
-            double distInMeter = instructions.get(i).getDistance();
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) Helper.round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(Helper.round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
-            {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(Helper.round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
-            }
-        }
-        return labels;
-    }
-
     public List<Map<String, Object>> createJson()
     {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
@@ -126,6 +85,7 @@ public int size()
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index da01a41579..a8c8288634 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -31,9 +31,9 @@
 public class PathMerger
 {
     private boolean enableInstructions = true;
-    private boolean simplifyResponse = false;
+    private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker;
-    private boolean calcPoints;
+    private boolean calcPoints = true;
 
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
@@ -60,7 +60,11 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (!il.isEmpty())
                 {
                     if (fullPoints.isEmpty())
-                        fullPoints = createSimilarPL(il.get(0).getPoints());
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
 
                     for (Instruction i : il)
                     {
@@ -86,7 +90,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             {
                 PointList tmpPoints = path.calcPoints();
                 if (fullPoints.isEmpty())
-                    fullPoints = createSimilarPL(tmpPoints);
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
                 if (simplifyResponse)
                 {
@@ -121,11 +125,6 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 setMillis(fullMillis);
     }
 
-    PointList createSimilarPL( PointList pl )
-    {
-        return new PointList(pl.size(), pl.is3D());
-    }
-
     public PathMerger setCalcPoints( boolean calcPoints )
     {
         this.calcPoints = calcPoints;
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..c7786a3cc8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,129 @@
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+    private int exitNumber = 0;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber( int exitNumber )
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation( double deltaIn )
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        } else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        } else
+        {
+            double tmpRadian = Math.PI - clockwise * radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian( double radian )
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (!Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+
+        return tmpMap;
+
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else
+            {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber())
+                        : tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 8b3bb36dca..56912dc470 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -34,7 +34,7 @@
     // ISO codes (639-1), use 'en_US' as reference
     private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
             "fr", "gl", "he", "it", "ja", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
-            "vi_VI");
+            "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 09e46810ca..d0eb1ebb46 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -34,20 +34,7 @@
  */
 public class BBox implements Shape, Cloneable
 {
-    /**
-     * A bounding box which prefills the values with minimum values so that it can increase.
-     */
-    public static final BBox INVERSE = new BBox();
 
-    static
-    {
-        INVERSE.minLon = Double.MAX_VALUE;
-        INVERSE.maxLon = -Double.MAX_VALUE;
-        INVERSE.minLat = Double.MAX_VALUE;
-        INVERSE.maxLat = -Double.MAX_VALUE;
-        INVERSE.minEle = Double.MAX_VALUE;
-        INVERSE.maxEle = -Double.MAX_VALUE;
-    }
     // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
@@ -55,17 +42,7 @@
     public double maxLat;
     public double minEle;
     public double maxEle;
-    private final boolean is3D;
-
-    private BBox()
-    {
-        this.is3D = false;
-    }
-
-    private BBox( boolean is3D )
-    {
-        this.is3D = is3D;
-    }
+    private final boolean elevation;
 
     public BBox( double minLon, double maxLon, double minLat, double maxLat )
     {
@@ -77,9 +54,9 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean is3D )
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
     {
-        this.is3D = is3D;
+        this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
         this.minLat = minLat;
@@ -88,28 +65,73 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this.maxEle = maxEle;
     }
 
-    public boolean check()
+    public boolean hasElevation()
     {
-        // second longitude should be bigger than the first
-        if (minLon >= maxLon)
-            return false;
+        return elevation;
+    }
 
-        // second latitude should be smaller than the first
-        if (minLat >= maxLat)
-            return false;
+    /**
+     * Prefills BBox with minimum values so that it can increase.
+     */
+    public static BBox createInverse( boolean elevation )
+    {
+        if (elevation)
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.MAX_VALUE, -Double.MAX_VALUE, true);
+        } else
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.NaN, Double.NaN, false);
+        }
+    }
 
-        // second elevation should be smaller than the first
-        if (is3D && minEle >= maxEle)
-            return false;
+    public void update( double lat, double lon )
+    {
+        if (lat > maxLat)
+        {
+            maxLat = lat;
+        }
+
+        if (lat < minLat)
+        {
+            minLat = lat;
+        }
 
-        return true;
+        if (lon > maxLon)
+        {
+            maxLon = lon;
+        }
+        if (lon < minLon)
+        {
+            minLon = lon;
+        }
+    }
+
+    public void update( double lat, double lon, double elev )
+    {
+        if (elevation)
+        {
+            if (elev > maxEle)
+            {
+                maxEle = elev;
+            }
+            if (elev < minEle)
+            {
+                minEle = elev;
+            }
+        } else
+        {
+            throw new IllegalStateException("No BBox with elevation to update");
+        }
+        update(lat, lon);
 
     }
 
     @Override
     public BBox clone()
     {
-        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, is3D);
+        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
@@ -172,7 +194,7 @@ public boolean contains( Circle c )
     public String toString()
     {
         String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
-        if (is3D)
+        if (elevation)
             str += "," + minEle + "," + maxEle;
 
         return str;
@@ -214,10 +236,29 @@ public int hashCode()
 
     public boolean isValid()
     {
-        return Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(INVERSE.maxLat)
-                && Double.doubleToLongBits(minLat) != Double.doubleToLongBits(INVERSE.minLat)
-                && Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(INVERSE.maxLon)
-                && Double.doubleToLongBits(minLon) != Double.doubleToLongBits(INVERSE.minLon);
+        // second longitude should be bigger than the first
+        if (minLon >= maxLon)
+            return false;
+
+        // second latitude should be smaller than the first
+        if (minLat >= maxLat)
+            return false;
+
+        if (elevation)
+        {
+            // equal elevation is okay
+            if (minEle > maxEle)
+                return false;
+
+            if (Double.compare(maxEle, -Double.MAX_VALUE) == 0
+                    || Double.compare(minEle, Double.MAX_VALUE) == 0)
+                return false;
+        }
+
+        return Double.compare(maxLat, -Double.MAX_VALUE) != 0
+                && Double.compare(minLat, Double.MAX_VALUE) != 0
+                && Double.compare(maxLon, -Double.MAX_VALUE) != 0
+                && Double.compare(minLon, Double.MAX_VALUE) != 0;
     }
 
     /**
@@ -230,12 +271,12 @@ public boolean isValid()
         list.add(Helper.round6(minLon));
         list.add(Helper.round6(minLat));
         // hmh
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(minEle));
 
         list.add(Helper.round6(maxLon));
         list.add(Helper.round6(maxLat));
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(maxEle));
 
         return list;
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index 12647784c2..3fed4a65b1 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -43,3 +43,7 @@ unpaved=черен
 stopover=прехвърляне %1$s
 roundaboutInstruction=Влез в кръговото и използвай изход %1$s
 roundaboutInstructionWithDir=Влез в кръговото и използвай изход %1$s в посока %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index e1a812b703..980f7a8ec0 100644
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -43,3 +43,7 @@ unpaved=sense pavimentar
 stopover=passant per %1$s
 roundaboutInstruction=Entra a la rotonda y agafa la %1$ sortida
 roundaboutInstructionWithDir=Entra a la rotonda y agafa la %1$s sortida direcció %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index f9b8831bc9..f7db1f2b5b 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -43,3 +43,7 @@ unpaved=unbefestigt
 stopover=Zwischenziel %1$s
 roundaboutInstruction=In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen
 roundaboutInstructionWithDir=In den Kreisverkehr einfahren und Ausfahrt %1$s in Richtung %2$s nehmen
+roundaboutInstructionOnto=In den Kreisverkehr einfahren und Ausfahrt %1$s auf %2$s nehmen
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index e3a9288ae0..cb6890ef00 100644
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -24,7 +24,7 @@ web.mtb=Ποδήλατο βουνού
 web.car=Αυτοκίνητο
 web.foot=Πεζός
 web.staticlink=στατική διεύθυνση
-web.motorcycle=
+web.motorcycle=Μοτοσυκλέτα
 via=μέσω
 finish=Τέρμα!
 hourAbbr=h
@@ -43,3 +43,7 @@ unpaved=χωματόδρομος
 stopover=ενδιάμεση στάση %1$s
 roundaboutInstruction=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s
 roundaboutInstructionWithDir=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s στην κατεύθυνση %2$s
+roundaboutInstructionOnto=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s στην %2$s
+roundaboutEnter=Μπείτε στον κυκλικό κόμβο
+roundaboutExit=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s
+roundaboutExitOnto=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s στην %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 150064e709..abfebb9177 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -41,5 +41,9 @@ way=way
 paved=paved
 unpaved=unpaved
 stopover=stopover %1$s
-roundaboutInstruction=Enter roundabout and use exit %1$s
-roundaboutInstructionWithDir=Enter roundabout and use exit %1$s in direction %2$s
+roundaboutInstruction=Enter roundabout and take exit %1$s
+roundaboutInstructionWithDir=Enter roundabout and take exit %1$s in direction %2$s
+roundaboutInstructionOnto=Enter roundabout and take exit %1$s onto %2$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index b63805492a..9d9ec6ea7c 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -43,3 +43,7 @@ unpaved=no pavimentado
 stopover=pasando por %1$s
 roundaboutInstruction=Entre a la rotonda y tome la salida %1$s
 roundaboutInstructionWithDir=Entre a la rotonda y tome la salida %1$s en dirección a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
index 8c51819ca8..3477681d9f 100644
--- a/core/src/main/resources/com/graphhopper/util/fil.txt
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -43,3 +43,7 @@ unpaved=hindi aspaltado
 stopover=pamahingahan %1$s
 roundaboutInstruction=Lpasok rotonda at gamitin %1$s
 roundaboutInstructionWithDir=Epasok rotonda at gamitin %1$s direksyon %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index bee3ecfe7b..f5169052b0 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -43,3 +43,7 @@ unpaved=non-pavé
 stopover=escale %1$s
 roundaboutInstruction=empruntez le rond point et prenez la sortie %1$s
 roundaboutInstructionWithDir=empruntez le rond point et prenez la sortie %1$s, en direction de %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
index a03eda11a4..ff53f51f72 100644
--- a/core/src/main/resources/com/graphhopper/util/gl.txt
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -43,3 +43,7 @@ unpaved=non pavimentada
 stopover=escala%1$s
 roundaboutInstruction= Entre na rotonda e tome a saída %1$s
 roundaboutInstructionWithDir= Entre na rotonda e tome a saída %1$s en dirección%2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index e565afe2b1..672fbf6945 100644
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -24,7 +24,7 @@ web.mtb=אופני הרים
 web.car=מכונית
 web.foot=רגל
 web.staticlink=קישור קבוע
-web.motorcycle=
+web.motorcycle=אופנוע
 via=דרך
 finish=סיימת!
 hourAbbr=שע׳
@@ -43,3 +43,7 @@ unpaved=לא סלולה
 stopover=נקודת עצירה מס׳ %1$s
 roundaboutInstruction=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s
 roundaboutInstructionWithDir=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s בכיוון %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index c9ad8dfcb8..1ca1c1259d 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -43,3 +43,7 @@ unpaved=non pavimentata
 stopover=sosta %1$s
 roundaboutInstruction=Prendere l'uscita %1$s
 roundaboutInstructionWithDir=Prendere l'uscita %1$s in direzione %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index fa8095337d..41c1bdf6b1 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -43,3 +43,7 @@ unpaved=未舗装の道
 stopover=%1$sで降りる
 roundaboutInstruction=円形交差点の%1$s出口から
 roundaboutInstructionWithDir=円形交差点の%1$s出口から%2$s方向へ
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index cca8ce0924..b89fc49ae1 100644
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -43,3 +43,7 @@ unpaved=onverhard
 stopover=tussenbestemming %1$s
 roundaboutInstruction=ga de rotonde op en neem afrit %1$s
 roundaboutInstructionWithDir=ga de rotonde op en neem afrit %1$s richting %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index 145acf0f6f..1565698d45 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -43,3 +43,7 @@ unpaved=não pavimentada
 stopover=parada %1$s
 roundaboutInstruction=Entre na rotatória e saia na saída número %1$s
 roundaboutInstructionWithDir=Entre na rotatória e saia na saída número %1$s em direção a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index cd0cb6b61c..a6e6f3a0fe 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -43,3 +43,7 @@ unpaved=não pavimentada
 stopover=paragem %1$s
 roundaboutInstruction=Entre na rotunda e saia na saída número %1$s
 roundaboutInstructionWithDir=Entre na rotunda e saia na saída número %1$s em direção a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index 3b95d3528a..95f52e55ab 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -43,3 +43,7 @@ unpaved=nepavat
 stopover=escala %1$s
 roundaboutInstruction= Intrați în giratoriu și folosiți ieșirea %1$s
 roundaboutInstructionWithDir= Intrați în giratoriu și folosiți ieșirea %1$s în direcția %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index a32caa5a95..3076988c9e 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -8,8 +8,8 @@ slight_left=немного левее
 slight_right=немного правее
 continue=продолжайте
 continue_onto=продолжайте по %1$s
-turn=Поверните на %1$s
-turn_onto=Поверните на %1$s на %2$s
+turn=Поверните %1$s
+turn_onto=Поверните %1$s на %2$s
 web.searchButton=Поиск
 web.fromHint=От
 web.viaHint=Через
@@ -43,3 +43,7 @@ unpaved=без покрытия
 stopover=остановка %1$s
 roundaboutInstruction=Въезжайте на кольцо и используйте съезд %1$s
 roundaboutInstructionWithDir=Въезжайте на кольцо и используйте съезд %1$s в направлении %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index 349143a802..8954a0701b 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -43,3 +43,7 @@ unpaved=netlakovana
 stopover=postanek %1$s
 roundaboutInstruction=zapelji v krožišče in izberi izhod %1$
 roundaboutInstructionWithDir=zapelji v krožišče in izberi izhod %1$ v smeri %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 89f40e77fb..96d95aa0dd 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -24,7 +24,7 @@ web.mtb=Horský bicykel
 web.car=Automobil
 web.foot=Pešo
 web.staticlink=nemenný odkaz
-web.motorcycle=
+web.motorcycle=Motocykel
 via=cez
 finish=Cieľ!
 hourAbbr=Horský bicykel
@@ -43,3 +43,7 @@ unpaved=nespevnená
 stopover=zastávka %1$s
 roundaboutInstruction=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd
 roundaboutInstructionWithDir=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd v smere %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
index 2be5c3d179..8d2f51b219 100644
--- a/core/src/main/resources/com/graphhopper/util/sv_SE.txt
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -43,3 +43,7 @@ unpaved=obelagd
 stopover=delmål %1$s
 roundaboutInstruction=Kör in i rondellen och ta avfart %1$s
 roundaboutInstructionWithDir=Kör in i rondellen och ta avfart %1$s mot %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index 802ae88134..e8299466e9 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -43,3 +43,7 @@ unpaved=kaldırımsız yol
 stopover=mola yeri %1$s
 roundaboutInstruction=döner kavsağa girin ve cıkışı kullanın %1$
 roundaboutInstructionWithDir=döner kavşağa girin ve çıkışı kullanın %1$ - %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index f0bd0b35d5..917e9ad796 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -43,3 +43,7 @@ unpaved=без покриття
 stopover=зупинка %1$s
 roundaboutInstruction=в’їзд на кільце та виїзд по %1$s
 roundaboutInstructionWithDir=в’їзд на кільце та виїзд по %1$s у напрямку %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
index d31c14d228..2a048e62da 100644
--- a/core/src/main/resources/com/graphhopper/util/vi_VI.txt
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -43,3 +43,7 @@ unpaved=đường không lát
 stopover=điểm nghỉ %1$s
 roundaboutInstruction=Vào vòng xoay và tìm lối ra %1$s
 roundaboutInstructionWithDir=Vào vòng xoay và tìm lối ra %1$s theo hướng %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..850f571717
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=左急转
+sharp_right=右急转
+left=左转
+right=右转
+slight_left=偏左转
+slight_right=偏右转
+continue=继续
+continue_onto=继续行驶到 %1$s
+turn=转 %1$s
+turn_onto=转  %1$s 到  %2$s
+web.searchButton=搜索
+web.fromHint=起点
+web.viaHint=途经点
+web.toHint=终点
+web.moreButton=更多
+web.gpxExportButton=GPX导出
+web.routeInfo=%1$s 的路线，需要 %2$s 时间
+web.locationsNotFound=地点未找到
+web.bike=自行车
+web.racingbike=竞技自行车
+web.mtb=山地自行车
+web.car=驾车
+web.foot=步行
+web.staticlink=静态链接
+web.motorcycle=摩托车
+via=途经
+finish=终点到达
+hourAbbr=小时
+dayAbbr=天
+minAbbr=分钟
+kmAbbr=公里
+mAbbr=米
+miAbbr=英里
+ftAbbr=英尺
+road=道路
+off_bike=下自行车
+cycleway=自行车道
+way=路
+paved=路面铺就
+unpaved=路面未铺就
+stopover=途中休息 %1$s
+roundaboutInstruction=进入环岛，并用%1$s出口出环岛
+roundaboutInstructionWithDir=进入环岛，并用%1$s出口出环岛，进入%2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index cb8e34888f..36dfb74cd2 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.geohash;
 
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import static org.junit.Assert.*;
 import org.junit.Test;
@@ -67,4 +68,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+    /*
+    * Test if different constructors yield same results
+     */
+    @Test
+    public void testInstantiation()
+    {
+        double minLon = 0; 
+        double minLat = 2;
+        double maxLat = 6;
+        double maxLon = 5;
+        
+        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+        assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
+        assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index ef82bc6dfa..ea30e4233c 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 1b83e2d881..92c5a2b0a7 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -36,7 +36,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index dc8cb0fbc3..5b09bd3268 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -77,11 +77,24 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 7);
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
         assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
     }
 
+    @Test
+    public void testCalcShortestPathWithLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
+    }
+
     // see calc-fastest-graph.svg
     @Test
     public void testCalcFastestPath()
@@ -666,7 +679,7 @@ public void testTwoWeightsPerEdge()
 //        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(85124371, p.getMillis());
         assertEquals(425622, p.getDistance(), 1);
-        assertEquals(6568, p.getWeight(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index a90beaace4..0f67d59627 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index c9d6e2d3b0..3f156783dc 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -28,6 +28,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
  *
@@ -39,7 +40,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameterized.Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 539dfd7e2d..fb8c479901 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index b640f438ae..1bbc864885 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -130,9 +130,9 @@ private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncod
         tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
     }
 
-    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs )
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
     {
-        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs);
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
     }
 
     @Test
@@ -142,16 +142,25 @@ public void testBasicTurnRestriction()
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
-        Path p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
         assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 7);
         assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
 
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(7, 5);
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -168,21 +177,26 @@ public void testUTurns()
         // force u-turn via lowering the cost for it
         EdgeIteratorState e3_6 = getEdge(g, 3, 6);
         e3_6.setDistance(0.1);
-        getEdge(g, 3, 2).setDistance(8642);
-        getEdge(g, 1, 0).setDistance(8642);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
 
         tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
         tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
-        Path p = createAlgo(g,
-                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build()).
-                calcPath(7, 5);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);        
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
-        // no u-turn    from 6-3
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build()).
-                calcPath(7, 5);
+        p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -193,7 +207,10 @@ public void testBasicTurnCosts()
         GraphStorage g = createGraph(createEncodingManager(false));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        Path p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
 
         // no restriction and costs
@@ -205,7 +222,10 @@ public void testBasicTurnCosts()
         long tflags = carEncoder.getTurnFlags(false, 2);
         tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
 
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
         assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
     }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 4e6b9e423f..a74897fb02 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -40,10 +37,11 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testFound()
@@ -213,4 +211,165 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
+    private class RoundaboutGraph
+    {
+        public EdgeIteratorState edge2change;
+        boolean clockwise;
+        final public Graph g = new GraphBuilder(carManager).create();
+        final public NodeAccess na = g.getNodeAccess();
+
+        private RoundaboutGraph(boolean clockwise)
+        {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        |
+            //        6
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.351);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge2change = tmpEdge.detach(false);
+            this.clockwise = clockwise;
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto MainStreet",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        delta = rg.getAngle(1, 2, 4, 7);
+        instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        RoundaboutGraph rg = new RoundaboutGraph(true);
+        System.out.println(rg.clockwise);
+
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 427ee36ee3..9dd71bd9c2 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -37,7 +37,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 21ebfceed2..d2956408f6 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -74,8 +74,8 @@ public void testShortestPathSkipNode()
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
-
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -93,10 +93,11 @@ public void testShortestPathSkipNode2()
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -108,7 +109,8 @@ public void testShortestPathLimit()
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index c4d697d037..2bf1cb7e1c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -51,9 +51,9 @@ public void testAccess()
         // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
-        way.setTag("tracktype", "grade2");        
+        way.setTag("tracktype", "grade2");
         assertTrue(encoder.acceptWay(way) > 0);
-        way.setTag("tracktype", "grade4");        
+        way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
         way.clearTags();
@@ -98,6 +98,15 @@ public void testAccess()
         assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
     }
 
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
+    }
+
     @Test
     public void testSetAccess()
     {
@@ -242,8 +251,8 @@ public void testRailway()
 
         // on disallowed highway, railway is allowed, sometimes incorrectly mapped
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);        
-        
+        assertTrue(encoder.acceptWay(way) > 0);
+
         // this is fully okay as sometimes old rails are on the road
         way.setTag("highway", "primary");
         way.setTag("railway", "historic");
@@ -435,12 +444,14 @@ public void testFordAccess()
         assertFalse(encoder.acceptWay(way) > 0);
         assertTrue(encoder.handleNodeTags(node) > 0);
 
-        try {
+        try
+        {
             // Now they are passable
             encoder.setBlockFords(false);
             assertTrue(encoder.acceptWay(way) > 0);
             assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally {
+        } finally
+        {
             encoder.setBlockFords(true);
         }
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 81df2aac3c..92f737654c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -27,8 +27,8 @@
  */
 public class MotorcycleFlagEncoderTest
 {
-    private final EncodingManager em = new EncodingManager("CAR,BIKE,FOOT");
-    private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("CAR");
+    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
     @Test
     public void testHandleWayTags()
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index cbae05663d..61a2936111 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -28,6 +28,7 @@
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
+
 /**
  *
  * @author Peter Karich
@@ -197,7 +198,8 @@ public void testRemoveDeadEndUnvisitedNetworks()
         GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(3);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
         int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
@@ -220,24 +222,36 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
-        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
-        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            9
+        }), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression() {
+    public void testNodeOrderingRegression()
+    {
         // 1 -> 2 -> 0
         GraphStorage g = createGraph(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
-
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(2);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
         int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
-        
+
         assertEquals(3, removed);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index beba510ca5..181c5d1adc 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -686,7 +686,7 @@ public void testBounds()
     {
         graph = createGraph();
         BBox b = graph.getBounds();
-        assertEquals(BBox.INVERSE.maxLat, b.maxLat, 1e-6);
+        assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 10, 20);
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 1c0900623a..ff4bdbacc0 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -67,16 +67,17 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -88,7 +89,7 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -96,14 +97,17 @@ public void testSave_and_fileFormat() throws IOException
 
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
-        assertEquals(new BBox(10, 20, 10, 12), g.getBounds());
+        assertTrue(na.is3D());
+        assertTrue(g.getBounds().isValid());
+        
+        assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutFilter);
@@ -112,12 +116,12 @@ protected void checkGraph( Graph g )
 
         EdgeIterator iter = explorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(3.5, 4.5, 5, 6), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0), iter.fetchWayGeometry(0));
 
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3), iter.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(10, 10, 1.5, 1, 2, 3), iter.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3, 11, 20), iter.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 10, 0, 1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0, 11, 20, 1), iter.fetchWayGeometry(2));
 
         assertEquals(11, na.getLatitude(1), 1e-2);
         assertEquals(20, na.getLongitude(1), 1e-2);
@@ -131,9 +135,9 @@ protected void checkGraph( Graph g )
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
 
         EdgeIteratorState eib = GHUtility.getEdge(g, 1, 2);
-        assertEquals(Helper.createPointList(), eib.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(11, 20), eib.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(12, 12), eib.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(), eib.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(11, 20, 1), eib.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(12, 12, 0.4), eib.fetchWayGeometry(2));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index f58cd0ed11..e624d5ce83 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -48,19 +48,21 @@ protected GraphStorage newRAMGraph()
         return newGraph(new RAMDirectory(), false);
     }
 
+    @Override
     @Test
-    public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
+    public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -76,7 +78,7 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -90,12 +92,13 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
         assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     @Test
-    public void testEnsureCapacity() throws IOException {
+    public void testEnsureCapacity() throws IOException
+    {
         graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
@@ -106,7 +109,8 @@ public void testEnsureCapacity() throws IOException {
         Random r = new Random();
 
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++)
+        {
             double randomLat = 90 * r.nextDouble();
             double randomLon = 180 * r.nextDouble();
 
@@ -114,15 +118,18 @@ public void testEnsureCapacity() throws IOException {
         }
 
         // Make node 50 the 'center' node
-        for (int nodeId = 51; nodeId < 100; nodeId++) {
+        for (int nodeId = 51; nodeId < 100; nodeId++)
+        {
             graph.edge(50, nodeId, r.nextDouble(), true);
         }
-        for (int nodeId = 0; nodeId < 50; nodeId++) {
+        for (int nodeId = 0; nodeId < 50; nodeId++)
+        {
             graph.edge(nodeId, 50, r.nextDouble(), true);
         }
 
         // add 100 turn cost entries around node 50
-        for (int edgeId = 0; edgeId < 50; edgeId++) {
+        for (int edgeId = 0; edgeId < 50; edgeId++)
+        {
             turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
             turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
         }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index f15d51967a..0fbc9477e4 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -19,9 +19,13 @@
 
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.LevelEdgeFilter;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -43,7 +47,7 @@ public GraphStorage newGraph( Directory dir, boolean is3D )
     }
 
     @Test
-    public void testCannotBeLoadedViaDifferentClass()
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     {
         GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         g.flush();
@@ -60,6 +64,8 @@ public void testCannotBeLoadedViaDifferentClass()
 
         g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
         assertTrue(g.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(g.getBounds(), BBox.createInverse(false));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index c6735a0a6e..79b9fc9f95 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -35,6 +35,8 @@
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
 import org.junit.Before;
@@ -114,10 +116,6 @@ public void testWayList()
                 "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
-        List<String> distStrings = wayList.createDistances(true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"),
-                distStrings);
-
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
@@ -125,9 +123,6 @@ public void testWayList()
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
-        distStrings = wayList.createDistances(false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"),
-                distStrings);
 
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
@@ -348,6 +343,56 @@ public void testInstructionsWithTimeAndPlace()
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
     @Test
     public void testCreateGPXWithEle()
     {
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
new file mode 100644
index 0000000000..eb2093e9a2
--- /dev/null
+++ b/docs/core/eclipse-setup.md
@@ -0,0 +1,153 @@
+Getting started with GraphHopper in Eclipse
+=========
+This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
+Instructions for Android branch will be provided in future.
+
+The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. Setting up Apache Tomcat server and configuring it to run GraphHopper will be covered in subsequent documents.
+
+###1. Download Eclipse
+
+The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
+
+**Note:** Make sure you grab the correct 32-bit or 64-bit version, depending on your machine and the version of the java installed in your computer. If for example you have a 32 bit java in your x64 machine, you still need to download a 32 bit version of eclipse or you may get an error while trying to open the eclipse.exe file.
+
+**Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
+
+
+###2.	Eclipse Addition al Plugins
+Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
+
+*	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
+*	The Eclipse Maven plugin, [m2eclipse](http://www.eclipse.org/m2e/) which adds Maven support to Eclipse, for editing project models and (automatically) running builds
+*	If you want to work on the web interfaces you also need [Web Tools Platform (WTP)](http://www.eclipse.org/webtools/)
+
+**Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
+
+###3.	Configuring Eclipse with additional plugins
+Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
+
+####3.1. Using Eclipse Marketplace
+The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
+
+You should take the below steps to install your needed components:
+
+* In Eclipse, under _help_ menu, choose _Eclipse Marketplace_. 
+
+* In the opened window, search all _markets/all categories_ and in the _find_ dialoge box type the name of the needed component and click on _Go_ button:
+
+ * Search for “egit” if you need “EGIT” and “EGit – Git Team Provider” should be among first items to appear.
+ 
+ * Search for “maven” or “m2eclipse” if you need “m2eclipse” and “m2eclipse – "Maven Integration for Eclipse” should be among first items to appear. 
+   
+ * Search for “wtp” if you need “m2e-wtp” and “m2eclipse – "Maven Integration for Eclipse WTP” should be among first items to appear. 
+
+*   Click on _Install_ button. Please note if the component is already installed then there are two other buttons available instead of _Install_. _Update_ if there is an update for the component and _Uninstall_. For example in picture below the user has tried to install EGit using market place, while it has already been included in the package. 
+
+![](./images/egit.png)
+
+*	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
+
+
+####3.2. Using “Install New Software…” Option
+Alternatively, you can use the “Install New Software” option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try “Install New Software Option” instead of the “Marketplace”. 
+
+Based on needed components take the below steps:
+ 
+*	To install “EGit” in the "Work with:" dialog box, type the EGit server address  at http://download.eclipse.org/egit/updates. Select Eclipse Git Team Provider and JGit form option and click _Next_ and _Finish_ install.
+ 
+![](./images/egit2.png)  
+
+*	To install “m2e” In the "Work with:" dialog box, type the me2eclipse server address at http://download.eclipse.org/technology/m2e/releases. Select Maven Integration for Eclipse form option and click _Next_ and _Finish_ install. 
+
+![](./images/maven.png) 
+
+*	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
+
+
+###4.	Clone and import the GraphHopper Source
+At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
+
+1. EGit Repositories View from within Eclipse
+
+2. Command-line Git tools. Once they are cloned into the local filesystem, the Maven projects in the GraphHopper Git repository can then be imported into Eclipse. 
+
+3. The clone and import operations can be done together using _File -> Import -> Maven -> Import Maven projects from SCM in Eclipse_.
+ 
+**Note:** When the initial clone operation is not done using the clone button in the EGit Repositories View (For example if it is done using command-line Git or "Import Maven projects from SCM"), you  need to inform Eclipse that your project is under Git version control if you want to do pull / push / commit operations from within Eclipse. In any case you can just perform these operations using command-line Git tools.
+
+**Note:**  It is suggested that repositories should be cloned somewhere outside your Eclipse workspace to avoid any misinterpretation or misuse of Git metadata by Eclipse and vice-versa. 
+
+Below we talk more about the first and third approaches of cloning.
+
+
+####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+
+* Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
+If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
+
+![](./images/clone1.png)
+
+The "Repository Exploring perspective" is preconfigured to contain the Git Repositories view. Alternatively, you can add the Git Repositories view to your main Java perspective: _Window -> Show View -> Other -> Git Repositories_. 
+
+* In the Git Repositories view, click on the "Clone a Git Repository and add clone to this view" button as shown below:
+
+![](./images/clone2.png)
+
+* Enter https://github.com/graphhopper/graphhopper/ for the URI, select "HTTPS" for the protocol. Entering the GitHub username and password is not necessary for cloning the repository. However, if you want to contribute edits back, you'll need to enter your GitHub username and password here too.
+
+![](./images/clone3.png)
+
+* Click _Next_, then select all branches (the “master” branch is probably what need).
+
+* Click _Next_, then select the directory where you want the code to be checked out to. Then click _Finish_. It will take Eclipse a minute or two to download the source to your computer, and then the GraphHopper repository should appear in the "Git Repositories" panel. 
+
+**Note:** An alternate and easy way to this approach is to manually download the GraphHopper zip file directly from GitHub and save it in a local drive in your machine.
+
+**Note:** You still need to import the GraphHopper Maven projects from the local clone of the repository into Eclipse (see Importing existing GraphHopper Maven projects into Eclipse part).
+
+
+
+####4.2. Importing existing GraphHopper Maven projects into Eclipse
+
+If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
+
+* Choose the menu option _File -> Import, and then browse to the Maven / Existing Maven Projects element_.
+
+![](./images/import1.png)
+
+* Browse to the local directory where you cloned the GraphHopper Git repository, and then select all the projects of interest.
+
+![](./images/import2.png)
+
+* Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
+
+####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+To use this method follow the below steps:
+* In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
+
+![](./images/clone4.png)
+
+* Click _Next_, then confirm that you are using the Git version control sytstem using the dropdown box next to the label "SCM URL". 
+
+**Note:** The first time you use this option, this "git" option will probably not be available because an m2e/git connector must be installed. Use the blue "m2e marketplace" link in the lower right corner of this dialog box to find and install the m2e Maven SCM handler for Egit,  and the 'git' option should become available in the drop-down box.
+
+* specify the "Target Location" (in this case, the URL of the remote Github repository that you want to clone locally), as shown in below figure. This URL should be https://github.com/graphhopper/graphhopper/
+
+![](./images/clone5.png)
+
+* Click _Next_, then uncheck "Use default workspace location" and specify a directory outside your Eclipse workspace (e.g. ~/git). Your cloned copy of the repository will be placed in a subdirectory of the specified directory, with a rather uninformative name (e.g. ~/git/ maven.1424033308371).
+
+* Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
+
+####4.4 Making Eclipse aware of your local GraphHopper Git repository
+
+If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
+
+*	Right-click the top-level GraphHopper project in the Project Explorer view and choose _Team -> Share Project_.
+
+*	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
+
+Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
+
+
+
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/images/clone1.png b/docs/core/images/clone1.png
new file mode 100644
index 0000000000..b05ec6fc9f
Binary files /dev/null and b/docs/core/images/clone1.png differ
diff --git a/docs/core/images/clone2.png b/docs/core/images/clone2.png
new file mode 100644
index 0000000000..7a8297f4a1
Binary files /dev/null and b/docs/core/images/clone2.png differ
diff --git a/docs/core/images/clone3.png b/docs/core/images/clone3.png
new file mode 100644
index 0000000000..d5a76bfe93
Binary files /dev/null and b/docs/core/images/clone3.png differ
diff --git a/docs/core/images/clone4.png b/docs/core/images/clone4.png
new file mode 100644
index 0000000000..b89d2a0ee3
Binary files /dev/null and b/docs/core/images/clone4.png differ
diff --git a/docs/core/images/clone5.png b/docs/core/images/clone5.png
new file mode 100644
index 0000000000..abef84335e
Binary files /dev/null and b/docs/core/images/clone5.png differ
diff --git a/docs/core/images/egit.png b/docs/core/images/egit.png
new file mode 100644
index 0000000000..b7b9ab7a61
Binary files /dev/null and b/docs/core/images/egit.png differ
diff --git a/docs/core/images/egit2.png b/docs/core/images/egit2.png
new file mode 100644
index 0000000000..1fad659389
Binary files /dev/null and b/docs/core/images/egit2.png differ
diff --git a/docs/core/images/import1.png b/docs/core/images/import1.png
new file mode 100644
index 0000000000..76c746f7ba
Binary files /dev/null and b/docs/core/images/import1.png differ
diff --git a/docs/core/images/import2.png b/docs/core/images/import2.png
new file mode 100644
index 0000000000..a384664bb6
Binary files /dev/null and b/docs/core/images/import2.png differ
diff --git a/docs/core/images/maven.png b/docs/core/images/maven.png
new file mode 100644
index 0000000000..2177c5296f
Binary files /dev/null and b/docs/core/images/maven.png differ
diff --git a/docs/core/translations.md b/docs/core/translations.md
index 30b9265a18..4f7d6eb502 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -3,7 +3,11 @@
 You can help improve GraphHopper by adding your language!
 
 See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
-and add a column for your language. Revisit it regularly to update or add new items.
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
 
 ## Questions
 
@@ -33,4 +37,4 @@ want to try your changes or want to speed up the integration you can do the foll
 
 ## License Agreement
 
-Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
\ No newline at end of file
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/index.md b/docs/index.md
index a170ce92c4..587a244dfe 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,17 +1,40 @@
-Users
----------------
+# Users
+
  * [Read Overview](http://graphhopper.com/#overview)
- * [Add GraphHopper Maps to your Browser](./web/open-search.md)
- * [GraphHopper on Twitter](https://twitter.com/graphhopp)
  * [Quickstart](./web/quickstart.md) for users
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md)
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper)
+
+# Translators
+
+* [Translations](./core/translations.md)
+
+
+# Developers
 
-Developers
---------------- 
  * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
-   * [Android](./android/index.md)
-   * [Windows](./core/windows-setup.md)
- * [Translations](./core/translations.md)
- * [Slides from FOSDEM 2014](http://graphhopper.com/public/slides/)
+ * [Android](./android/index.md)
+ * [Windows](./core/windows-setup.md)
+ * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md)
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/)
+
+## Core
+
+ * [Simple routing](./core/routing.md) to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md)
+ * [Elevation](./core/elevation.md)
+ * [Technical overview](./core/technical.md)
+ * [Slides from 2014](http://graphhopper.com/public/slides/)
+ * [Contraction Hierarchies](./core/ch.md)
+
+## Web
+
+ * [Routing API](./web/api-doc.md)
+ 
+## Advanced Topics
+
+ * [Low level API](./core/low-level-api.md)
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md)
+ * [LocationIndex](./core/location-index.md)
  * [World-Wide-Road-Network](./core/world-wide.md)
  * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
-
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..328585b83d 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -116,14 +116,16 @@ paths[0].instructions[0].text                 | A description what the user has
 paths[0].instructions[0].distance             | The distance for this instruction, in meter
 paths[0].instructions[0].time                 | The duration for this instruction, in ms
 paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
 paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
 
 
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -171,6 +173,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/graphhopper.sh b/graphhopper.sh
index ba20ac1e98..9ac713622b 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -3,13 +3,13 @@
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
+if [ "$JAVA_HOME" = "" ]; then
  JAVA=java
 fi
 
 vers=$($JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \")
 bit64=$($JAVA -version 2>&1 | grep "64-Bit")
-if [ "x$bit64" != "x" ]; then
+if [ "$bit64" != "" ]; then
   vers="$vers (64bit)"
 fi
 echo "## using java $vers from $JAVA_HOME"
@@ -22,13 +22,29 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
-if [ "x$ACTION" = "x" ]; then
- echo -e "## action $ACTION not found. try \n$USAGE"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
+if [ "$ACTION" = "" ]; then
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
-  if [ "x$OSM_FILE" = "x" ]; then
+  if [ "$OSM_FILE" = "" ]; then
     # skip
     return
   elif [ ! -s "$OSM_FILE" ]; then
@@ -61,10 +77,10 @@ function ensureOsmXml {
 
 function ensureMaven {
   # maven home existent?
-  if [ "x$MAVEN_HOME" = "x" ]; then
+  if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
     MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
-    if [ "x$MAVEN_HOME" = "x" ]; then
+    if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
@@ -116,40 +132,41 @@ function prepareEclipse {
 
 
 ## now handle actions which do not take an OSM file
-if [ "x$ACTION" = "xclean" ]; then
+if [ "$ACTION" = "clean" ]; then
  rm -rf ./*/target
  exit
 
-elif [ "x$ACTION" = "xeclipse" ]; then
+elif [ "$ACTION" = "eclipse" ]; then
  prepareEclipse
  exit
 
-elif [ "x$ACTION" = "xbuild" ]; then
+elif [ "$ACTION" = "build" ]; then
  prepareEclipse
  exit  
  
-elif [ "x$ACTION" = "xextract" ]; then
+elif [ "$ACTION" = "extract" ]; then
  echo use "./graphhopper.sh extract \"left,bottom,right,top\""
  URL="http://overpass-api.de/api/map?bbox=$2"
  #echo "$URL"
  wget -O extract.osm "$URL"
  exit
  
-elif [ "x$ACTION" = "xandroid" ]; then
+elif [ "$ACTION" = "android" ]; then
  prepareEclipse
  "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
  exit
 fi
 
-if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+if [ "$FILE" = "" ]; then
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
 # NAME = file without extension if any
 NAME="${FILE%.*}"
 
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    OSM_FILE=
 elif [ ${FILE: -4} == ".osm" ]; then
    OSM_FILE="$FILE"
@@ -175,7 +192,7 @@ VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<'
 JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
 LINK=$(echo $NAME | tr '_' '/')
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
@@ -188,7 +205,7 @@ else
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
-if [ "x$JAVA_OPTS" = "x" ]; then
+if [ "$JAVA_OPTS" = "" ]; then
   JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
@@ -199,9 +216,9 @@ packageCoreJar
 
 echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
-if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
+if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "x$JETTY_PORT" = "x" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then  
     JETTY_PORT=8989
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
@@ -217,7 +234,7 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
 
   RC_BASE=./web/src/main/webapp
 
-  if [ "x$GH_FOREGROUND" = "x" ]; then
+  if [ "$GH_FOREGROUND" = "" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
 	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
@@ -226,30 +243,30 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
     	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
-    if [ "x$GH_PID_FILE" != "x" ]; then
+    if [ "$GH_PID_FILE" != "" ]; then
        echo $! > $GH_PID_FILE
     fi
     exit $?                    
   fi
 
-elif [ "x$ACTION" = "ximport" ]; then
+elif [ "$ACTION" = "import" ]; then
  "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
       config=$CONFIG \
       $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtorture" ]; then
+elif [ "$ACTION" = "torture" ]; then
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "x$ACTION" = "xminiui" ]; then
+elif [ "$ACTION" = "xminiui" ]; then
  "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
               graph.location="$GRAPH"
 
 
-elif [ "x$ACTION" = "xmeasurement" ]; then
+elif [ "$ACTION" = "measurement" ]; then
  ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
@@ -270,7 +287,7 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
  # use all <last_commits> versions starting from HEAD
  last_commits=$3
   
- if [ "x$last_commits" = "x" ]; then
+ if [ "$last_commits" = "" ]; then
    # use current version
    "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
diff --git a/pom.xml b/pom.xml
index 5042897e07..a0ed958b9f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -91,6 +91,8 @@
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
+                    
+                    <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                     <source>1.6</source>
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index f2c3ae2ec6..e4dd2bc3f1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -24,6 +24,7 @@
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.IOException;
 import java.io.StringWriter;
@@ -72,20 +73,20 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         }
     }
 
-    void writePath( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
     {
-        List<GHPoint> infoPoints = getPoints(req);
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
 
         // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(req, "way_point_max_distance", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean elevation = getBooleanParam(req, "elevation", false);
-        String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-        String weighting = getParam(req, "weighting", "fastest");
-        String algoStr = getParam(req, "algorithm", "");
-        String localeStr = getParam(req, "locale", "en");
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        String vehicleStr = getParam(httpReq, "vehicle", "car");
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
 
         StopWatch sw = new StopWatch().start();
         GHResponse ghRsp;
@@ -100,7 +101,7 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
             GHRequest request = new GHRequest(infoPoints);
 
-            initHints(request, req.getParameterMap());
+            initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
                     setWeighting(weighting).
                     setAlgorithm(algoStr).
@@ -114,8 +115,8 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
         }
 
         float took = sw.stop().getSeconds();
-        String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-        String logStr = req.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
                 + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
         if (ghRsp.hasErrors())
@@ -126,9 +127,9 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
                     + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
-            writeResponse(res, createGPXString(req, res, ghRsp));
+            writeResponse(res, createGPXString(httpReq, res, ghRsp));
         else
-            writeJson(req, res, new JSONObject(createJson(req, ghRsp, took)));
+            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
@@ -213,7 +214,11 @@ String errorsToXML( List<Throwable> list ) throws Exception
 
                 PointList points = rsp.getPoints();
                 if (points.getSize() >= 2)
-                    jsonPath.put("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
+                {
+                    BBox maxBounds = hopper.getGraph().getBounds();
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
 
                 jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
@@ -239,25 +244,27 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
         return jsonPoints;
     }
 
-    private List<GHPoint> getPoints( HttpServletRequest req ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
     {
-        String[] pointsAsStr = getParams(req, "point");
+        String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
         for (String str : pointsAsStr)
         {
             String[] fromStrs = str.split(",");
             if (fromStrs.length == 2)
             {
-                GHPoint place = GHPoint.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                {
+                    infoPoints.add(point);
+                }
             }
         }
 
         return infoPoints;
     }
 
-    private void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
     {
         WeightingMap m = request.getHints();
         for (Entry<String, String[]> e : parameterMap.entrySet())
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index a8f092946e..d1a1265773 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -53,6 +53,8 @@ GHRequest = function (host) {
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
+    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
+    this.api_params = [];
 
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
@@ -303,20 +305,26 @@ GHroute.prototype = {
     }
 };
 
-// todo
 GHRequest.prototype.init = function (params) {
-    //    for(var key in params) {
-    //        var val = params[key];
-    //        if(val === "false")
-    //            val = false;
-    //        else if(val === "true")
-    //            val = true;
-    //        else {            
-    //            if(parseFloat(val) != NaN)
-    //                val = parseFloat(val)
-    //        }
-    //        this[key] = val;
-    //    } 
+    for (var key in params) {
+        var val = params[key];
+        if (val === "false")
+            val = false;
+        else if (val === "true")
+            val = true;
+        else {
+            if (parseFloat(val) != NaN)
+                val = parseFloat(val)
+        }
+
+        // todo
+        // this[key] = val;
+
+        if (key.indexOf('api.') === 0) {
+            this.api_params[key.substring(4)] = val;
+        }
+    }
+
     if (params.minPathPrecision)
         this.minPathPrecision = params.minPathPrecision;
     if (params.vehicle)
@@ -385,50 +393,42 @@ GHRequest.prototype.hasElevation = function () {
     return this.elevation;
 };
 
-GHRequest.prototype.createGeocodeURL = function (host) {
+GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
     var tmpHost = this.host;
     if (host)
         tmpHost = host;
-    return this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key + "&locale=" + this.locale);
+
+    var path = this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key);
+    if (prevIndex >= 0 && prevIndex < this.route.size()) {
+        var point = this.route.getIndex(prevIndex);
+        path += "&lat=" + point.lat + "&lon=" + point.lng;
+    }
+    return path;
 };
 
 GHRequest.prototype.createURL = function () {
-    return this.createPath(this.host + "/route?" + this.createParams() + "&type=" + this.dataType + "&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=" + this.dataType + "&key=" + this.key);
 };
 
 GHRequest.prototype.createGPXURL = function () {
-    // use points instead of strings
-    var str = "", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
-    }
-    return this.createPath(this.host + "/route?" + str + "&type=gpx&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx&key=" + this.key);
 };
 
 GHRequest.prototype.createHistoryURL = function () {
-    var str = "?", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.input);
-    }
-    return this.createPath(str);
+    return this.createPath("?" + this.createPointParams(true));
 };
 
-GHRequest.prototype.createParams = function () {
+GHRequest.prototype.createPointParams = function (useRawInput) {
     var str = "", point, i, l;
 
     for (i = 0, l = this.route.size(); i < l; i++) {
         point = this.route.getIndex(i);
         if (i > 0)
             str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
+        if (useRawInput)
+            str += "point=" + encodeURIComponent(point.input);
+        else
+            str += "point=" + encodeURIComponent(point.toString());
     }
     return (str);
 };
@@ -455,6 +455,10 @@ GHRequest.prototype.createPath = function (url) {
         url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+
+    for (var key in this.api_params) {
+        url += "&" + key + "=" + this.api_params[key];
+    }
     return url;
 };
 
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 59b4df81ba..9909577d8d 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -15,7 +15,6 @@ if (!host) {
 }
 
 var ghRequest = new GHRequest(host);
-var tmpArgs = parseUrlWithHisto();
 var bounds = {};
 
 var nominatimURL = "https://nominatim.openstreetmap.org/search";
@@ -366,9 +365,9 @@ function initMap(selectLayer) {
     var mapLink = '<a href="http://www.esri.com/">Esri</a>';
     var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
     var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
-                attribution: osmAttr + '&copy; ' + mapLink + ', ' + wholink,
-                maxZoom: 18
-            });
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
+    });
 
     var baseMaps = {
         "Lyrk": lyrk,
@@ -392,7 +391,7 @@ function initMap(selectLayer) {
     map = L.map('map', {
         layers: [defaultLayer],
         contextmenu: true,
-        contextmenuWidth: 140,
+        contextmenuWidth: 145,
         contextmenuItems: [{
                 separator: true,
                 index: 3,
@@ -599,7 +598,8 @@ function setFlag(coord, index) {
                     draggable: true,
                     contextmenu: true,
                     contextmenuItems: [{
-                            text: 'Marker ' + ((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')),
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
                             disabled: true,
                             index: 0,
                             state: 2
@@ -620,7 +620,8 @@ function setFlag(coord, index) {
                             state: 2
                         }],
                     contextmenuAtiveState: 2
-                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')));
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
         // intercept openPopup
         marker._openPopup = marker.openPopup;
         marker.openPopup = function () {
@@ -1146,6 +1147,8 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "marker-icon-red";
     else if (sign === 5)
         sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
@@ -1410,14 +1413,15 @@ function setAutoCompleteList(index) {
         },
         serviceUrl: function () {
             // see https://graphhopper.com/#directions-api
-            return ghRequest.createGeocodeURL(host);
+            return ghRequest.createGeocodeURL(host, index - 1);
         },
         transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
         onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index faa0205ede..a70129ef98 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -66,6 +66,10 @@ public void testElevation() throws Exception
 
         JSONObject cson = path.getJSONObject("points");
         assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+
+        // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
+        // or reading with and without elevation would be too complex for the client with no real use
+        assertEquals(4, path.getJSONArray("bbox").length());
     }
 
     @Test
