diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
new file mode 100644
index 0000000000..981cafaeed
--- /dev/null
+++ b/reader-shp/pom.xml
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-reader-shp</artifactId>
+    <version>0.9-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <name>GraphHopper Reader for Shapefile Data</name>
+	
+    <properties>      
+        <geotools.version>13.2</geotools.version>
+    </properties>
+    	
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>    	
+        <version>0.9-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>org.geotools</groupId>
+            <artifactId>gt-shapefile</artifactId>
+            <version>${geotools.version}</version>
+        </dependency>
+		
+        <!-- 
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-compress</artifactId>
+            <version>${commons-compress.version}</version>
+        </dependency>
+        -->
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>${slf4j.version}</version>
+        </dependency>   
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>${log4j.version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>        
+    </dependencies>
+	
+    <repositories>
+        <repository>
+            <id>osgeo</id>
+            <name>Open Source Geospatial Foundation Repository</name>
+            <url>http://download.osgeo.org/webdav/geotools/</url>
+        </repository>
+    </repositories>
+	
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>                
+                <configuration>
+                    <archive>
+                        <manifest>
+                            <mainClass>com.graphhopper.import.osm.Import</mainClass>
+                        </manifest>
+                    </archive>
+                        	                    
+                    <!-- for standalone usage -->
+                    <descriptorRefs>
+                        <descriptorRef>jar-with-dependencies</descriptorRef>
+                    </descriptorRefs>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java
new file mode 100644
index 0000000000..725bb0f58e
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java
@@ -0,0 +1,13 @@
+package com.graphhopper.reader.shp;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.storage.GraphHopperStorage;
+
+public class GraphhopperShp extends GraphHopper {
+    @Override
+    protected DataReader createReader(GraphHopperStorage ghStorage) {
+        return initDataReader(new OSMShapeFileReader(ghStorage));
+    }
+
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
new file mode 100644
index 0000000000..e0305d0b74
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -0,0 +1,283 @@
+package com.graphhopper.reader.shp;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import org.geotools.data.DataStore;
+import org.geotools.feature.FeatureIterator;
+import org.opengis.feature.simple.SimpleFeature;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.GHPoint;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.MultiLineString;
+
+import gnu.trove.map.hash.THashMap;
+
+/**
+ * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It extracts the data as per the structure of
+ * shape files
+ *
+ * @author Vikas Veshishth
+ */
+public class OSMShapeFileReader extends ShapeFileReader {
+	private static final String[] DIRECT_COPY_TAGS = new String[] { "name" };
+	private File roadsFile;
+	private THashMap<Coordinate, Integer> towerCoordIdMap = new THashMap<Coordinate, Integer>();
+	private final DistanceCalc distCalc = Helper.DIST_EARTH;
+	private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
+
+	public OSMShapeFileReader(GraphHopperStorage ghStorage) {
+		super(ghStorage);
+	}
+
+	@Override
+	void processJunctions() throws IOException {
+		{
+			DataStore dataStore = null;
+			FeatureIterator<SimpleFeature> roads = null;
+
+			try {
+				dataStore = openShapefileDataStore(roadsFile);
+				roads = getFeatureIerator(dataStore);
+
+				while (roads.hasNext()) {
+					SimpleFeature road = roads.next();
+
+					MultiLineString geom = (MultiLineString) road.getDefaultGeometry();
+					if (geom.getNumGeometries() != 1) {
+						// TODO is this an error? Are roads split if they're too long?
+						// Will getting all coordinates as below still lead sensible results,
+						// providing the individual linestrings are digitised in a sensible order?
+						throw new RuntimeException("Found road with more than one geometry, OSM id " + getOSMId(road));
+					}
+					
+					Coordinate[] points = geom.getCoordinates();
+
+					Coordinate start = points[0];
+					Coordinate end = points[points.length - 1];
+
+					checkAndAdd(start);
+					checkAndAdd(end);
+
+				}
+			} finally {
+				if (roads != null) {
+					roads.close();
+				}
+				if (dataStore != null) {
+					dataStore.dispose();
+				}
+			}
+
+			LOGGER.info("Number of junction points : " + towerCoordIdMap.size());
+
+		}
+	}
+
+	@Override
+	void processRoads() throws IOException {
+
+		DataStore dataStore = null;
+		FeatureIterator<SimpleFeature> roads = null;
+
+		try {
+			dataStore = openShapefileDataStore(roadsFile);
+			roads = getFeatureIerator(dataStore);
+
+			while (roads.hasNext()) {
+				SimpleFeature road = roads.next();
+
+				MultiLineString mls = (MultiLineString) road.getDefaultGeometry();
+
+				Coordinate[] points = mls.getCoordinates();
+
+				// Parse all points in the geometry, splitting into individual graphhopper edges
+				// whenever we find a node that's a start or end node elsewhere (can happen commonly
+				// with main roads that have several side roads coming off them).
+				Coordinate startTower = null;
+				List<Coordinate> pillars = new ArrayList<Coordinate>();
+				for (Coordinate point : points) {
+					if (startTower == null) {
+						startTower = point;
+					} else {
+						if (towerCoordIdMap.containsKey(point)) {
+							int fromTower = towerCoordIdMap.get(startTower);
+							int toTower = towerCoordIdMap.get(point);
+
+							// get distance and estimated centres
+							double distance = getWayLength(startTower, pillars, point);
+							GHPoint estmCentre = new GHPoint(0.5 * (lat(startTower) + lat(point)), 0.5 * (lng(startTower) + lng(point)));
+							PointList pillarNodes = new PointList(pillars.size(), false);
+
+							for (Coordinate pillar : pillars) {
+								pillarNodes.add(lat(pillar), lng(pillar));
+							}
+
+							addEdge(fromTower, toTower, road, distance, estmCentre,pillarNodes);
+							startTower = point;
+							pillars.clear();
+						} else {
+							pillars.add(point);
+						}
+					}
+				}
+
+			}
+		} catch (Exception e) {
+			LOGGER.error("Exception while processing for roads: ", e);
+		} finally {
+			if (roads != null) {
+				roads.close();
+			}
+
+			if (dataStore != null) {
+				dataStore.dispose();
+			}
+		}
+	}
+
+	private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
+		double distance = 0;
+
+		Coordinate previous = start;
+		for (Coordinate point : pillars) {
+			distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
+			previous = point;
+		}
+		distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
+
+		return distance;
+	}
+
+
+	private void checkAndAdd(Coordinate point) {
+		if (!towerCoordIdMap.containsKey(point)) {
+			int nodeId = towerCoordIdMap.size();
+			towerCoordIdMap.put(point, nodeId);
+			saveTowerPosition(nodeId, point);
+		}
+	}
+
+	@Override
+	public DataReader setFile(File file) {
+		this.roadsFile = file;
+		return this;
+	}
+
+	@Override
+	public DataReader setElevationProvider(ElevationProvider ep) {
+		// Elevation not supported
+		return this;
+	}
+
+	@Override
+	public DataReader setWorkerThreads(int workerThreads) {
+		// Its only single-threaded
+		return this;
+	}
+
+	@Override
+	public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
+		// TODO Auto-generated method stub
+		return this;
+	}
+
+	@Override
+	public Date getDataDate() {
+		return null;
+	}
+
+	private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,GHPoint estmCentre , PointList pillarNodes) {
+		EdgeIteratorState edge = graph.edge(fromTower, toTower);
+
+		// read the OSM id, should never be null
+		long id = getOSMId(road);
+
+		// Make a temporary ReaderWay object with the properties we need so we can use the enocding manager
+		// We (hopefully don't need the node structure on here as we're only calling the flag
+		// encoders, which don't use this...
+		ReaderWay way = new ReaderWay(id);
+
+		way.setTag("estimated_distance", distance);
+		way.setTag("estimated_center", estmCentre);
+
+		// read the highway type
+		Object type = road.getAttribute("fclass");
+		if (type != null) {
+			way.setTag("highway", type.toString());
+		}
+		
+		// read maxspeed filtering for 0 which for Geofabrik shapefiles appears to correspond to no tag
+		Object maxSpeed = road.getAttribute("maxspeed");
+		if(maxSpeed!=null && !maxSpeed.toString().trim().equals("0")){
+			way.setTag("maxspeed", maxSpeed.toString());
+		}
+
+		for (String tag : DIRECT_COPY_TAGS) {
+			Object val = road.getAttribute(tag);
+			if (val != null) {
+				way.setTag(tag, val.toString());
+			}
+		}
+
+		// read oneway
+		Object oneway = road.getAttribute("oneway");
+		if (oneway != null) {
+			// Geofabrik is using an odd convention for oneway field in shapefile.
+			// We map back to the standard convention so that tag can be dealt with correctly by the flag encoder.
+			String val = oneway.toString().trim().toLowerCase();
+			if(val.equals("b")){
+				// both ways
+				val = "no";
+			}else if (val.equals("t")){
+				// one way against the direction of digitisation
+				val = "-1";
+			}
+			else if (val.equals("f")){
+				// one way Forward in the direction of digitisation
+				val = "yes";
+			}
+			else{
+				throw new RuntimeException("Unrecognised value of oneway field \"" + val + "\" found in road with OSM id " + id);
+			}
+			
+			way.setTag("oneway", val);
+		}
+
+		// Process the flags using the encoders
+		long includeWay = encodingManager.acceptWay(way);
+		if (includeWay == 0) {
+			return;
+		}
+
+		// TODO we're not using the relation flags
+		long relationFlags = 0;
+
+		long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+		if (wayFlags == 0)
+			return;
+
+		edge.setDistance(distance);
+		edge.setFlags(wayFlags);
+		edge.setWayGeometry(pillarNodes);
+	}
+
+	private long getOSMId(SimpleFeature road) {
+		long id = Long.parseLong(road.getAttribute("osm_id").toString());
+		return id;
+	}
+
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
new file mode 100644
index 0000000000..5cbed55fad
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
@@ -0,0 +1,98 @@
+package com.graphhopper.reader.shp;
+
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.vividsolutions.jts.geom.Coordinate;
+import org.geotools.data.DataStore;
+import org.geotools.data.DataStoreFinder;
+import org.geotools.data.FeatureSource;
+import org.geotools.feature.FeatureCollection;
+import org.geotools.feature.FeatureIterator;
+import org.opengis.feature.simple.SimpleFeature;
+import org.opengis.feature.simple.SimpleFeatureType;
+import org.opengis.filter.Filter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * ShapeFileReader takes care of reading a shape file and writing it to a road network graph
+ *
+ * @author Vikas Veshishth
+ */
+public abstract class ShapeFileReader implements DataReader {
+
+	private final GraphStorage graphStorage;
+	private final NodeAccess nodeAccess;
+	protected final Graph graph;
+	protected EncodingManager encodingManager;
+
+	private static final Logger LOGGER = LoggerFactory.getLogger(ShapeFileReader.class);
+
+	public ShapeFileReader(GraphHopperStorage ghStorage) {
+		this.graphStorage = ghStorage;
+		this.graph = ghStorage;
+		this.nodeAccess = graph.getNodeAccess();
+	}
+
+	@Override
+	public void readGraph() throws IOException {
+		// TODO why 1000?
+		graphStorage.create(1000);
+		processJunctions();
+		processRoads();
+	}
+
+	abstract void processJunctions() throws IOException;
+
+	abstract void processRoads() throws IOException;
+
+
+	protected FeatureIterator<SimpleFeature> getFeatureIerator(DataStore dataStore) throws IOException {
+		String typeName = dataStore.getTypeNames()[0];
+		FeatureSource<SimpleFeatureType, SimpleFeature> source = dataStore.getFeatureSource(typeName);
+		Filter filter = Filter.INCLUDE;
+		FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures(filter);
+
+		FeatureIterator<SimpleFeature> features = collection.features();
+		return features;
+	}
+
+	protected DataStore openShapefileDataStore(File file) throws IOException {
+		Map<String, Object> map = new HashMap<String, Object>();
+		map.put("url", file.toURI().toURL());
+		return DataStoreFinder.getDataStore(map);
+	}
+
+	/*
+	 * Get longitude using the current long-lat order convention
+	 */
+	protected double lng(Coordinate coordinate) {
+		return coordinate.getOrdinate(0);
+	}
+
+	/*
+	 * Get latitude using the current long-lat order convention
+	 */
+	protected double lat(Coordinate coordinate) {
+		return coordinate.getOrdinate(1);
+	}
+
+	protected void saveTowerPosition(int nodeId, Coordinate point) {
+		nodeAccess.setNode(nodeId, lat(point), lng(point));
+	}
+
+	@Override
+	public ShapeFileReader setEncodingManager(EncodingManager encodingManager) {
+		this.encodingManager = encodingManager;
+		return this;
+	}
+}
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
new file mode 100644
index 0000000000..54602e4c9d
--- /dev/null
+++ b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
@@ -0,0 +1,100 @@
+package com.graphhopper.reader.shp;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+
+/**
+ * Tests the ShapeFileReader with the normal helper initialized.
+ * <p>
+ * 
+ * @author Vikas Veshishth
+ */
+public class ShapeFileReaderTest {
+
+	private final String shapefile = "/shapefiles/gis.osm_roads_free_1.shp";
+	private final String tempOutputDirectory = "./target/tmp/test-db";
+	// private CarFlagEncoder carEncoder;
+
+	@Before
+	public void setUp() {
+		new File(tempOutputDirectory).mkdirs();
+	}
+
+	@After
+	public void tearDown() {
+		Helper.removeDir(new File(tempOutputDirectory));
+	}
+
+
+	private static class ExpectedDuration {
+		final GHPoint from;
+		final GHPoint to;
+		final double minSecs;
+		final double maxSecs;
+
+		private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng, double minSecs, double maxSecs) {
+			from = new GHPoint(fromLat, fromLng);
+			to = new GHPoint(toLat, toLng);
+			this.minSecs = minSecs;
+			this.maxSecs = maxSecs;
+		}
+	}
+
+	@Test
+	public void testMain() throws URISyntaxException {
+		// test we can make a graph without any exceptions....
+		URL resourceURL = getClass().getResource(shapefile);
+		String shapeFile = new File(resourceURL.toURI()).getAbsolutePath();
+
+		GraphHopper hopper = new GraphhopperShp().setStoreOnFlush(false).setDataReaderFile(shapeFile)
+				.setGraphHopperLocation(tempOutputDirectory).setEncodingManager(new EncodingManager(new CarFlagEncoder()))
+				.setCHEnabled(false).importOrLoad();
+
+		// try a couple of test points, with an expected time range that will only fail if something is really bad...
+		ExpectedDuration[] expected = new ExpectedDuration[] {
+				new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60, 60 * 6) ,
+				new ExpectedDuration(35.899167, 14.515171, 35.877645,14.398956, 8*60, 25*60 ),
+				new ExpectedDuration(35.85817,14.561348, 35.877645,14.398956, 10*60, 30*60 ),
+				new ExpectedDuration(35.812802,14.528732, 35.979673,14.335785, 20*60, 50*60 ),
+
+		};
+		for (ExpectedDuration ed : expected) {
+			GHRequest request = new GHRequest(ed.from, ed.to).setVehicle("car");
+			GHResponse response = hopper.route(request);
+			assertFalse(response.hasErrors());
+			PathWrapper pw = response.getBest();
+			assertNotNull(pw);
+			long millis = pw.getTime();
+			double secs = 0.001 * millis;
+
+			String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs + " <= travelsecs <= " + ed.maxSecs
+					+ ", found " + secs + " secs";
+			assertTrue(message, secs >= ed.minSecs);
+			assertTrue(message, secs <= ed.maxSecs);
+			System.out.println(message);
+		}
+
+		// assertEquals(2917, graph.getNodes());
+	}
+
+}
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.cpg b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.cpg
new file mode 100644
index 0000000000..7edc66b06a
--- /dev/null
+++ b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.cpg
@@ -0,0 +1 @@
+UTF-8
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.dbf b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.dbf
new file mode 100644
index 0000000000..116ff9c648
Binary files /dev/null and b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.dbf differ
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.prj b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.prj
new file mode 100644
index 0000000000..8f73f480ff
--- /dev/null
+++ b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.prj
@@ -0,0 +1 @@
+GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shp b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shp
new file mode 100644
index 0000000000..491be81e73
Binary files /dev/null and b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shp differ
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shx b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shx
new file mode 100644
index 0000000000..25718abea1
Binary files /dev/null and b/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shx differ
