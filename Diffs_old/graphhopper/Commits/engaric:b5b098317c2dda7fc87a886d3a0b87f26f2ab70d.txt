diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index ae1285c12a..5f9cd07277 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.util.DistancePlaneProjection;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
@@ -53,7 +54,9 @@ public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode t
     {
         super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(new BeelineWeightApproximator(nodeAccess, weighting));
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     /**
@@ -76,6 +79,7 @@ public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
         to1 = to;
+        weightApprox.setGoalNode(to);
         currEdge = createEdgeEntry(from, 0);
         if (!traversalMode.isEdgeBased())
         {
@@ -103,27 +107,29 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;
+                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
+                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
+                                                      + currEdge.weightOfVisitedPath);
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
                 AStarEdge ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
+                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    currWeightToGoal = weightApprox.approximate(neighborNode, to1);
+                    currWeightToGoal = weightApprox.approximate(neighborNode);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
                     if (ase == null)
                     {
                         ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
                         fromMap.put(traversalId, ase);
-                    } else if (ase.weight > distEstimation)
+                    } else
                     {
+                        assert(ase.weight > distEstimation): "Inconsistent distance estimate";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
                         ase.weightOfVisitedPath = alreadyVisitedWeight;
-                    } else
-                        continue;
+                    }
 
                     ase.parent = currEdge;
                     prioQueueOpenSet.add(ase);
@@ -176,7 +182,6 @@ public int getVisitedNodes()
         public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
             super(edgeId, adjNode, weightForHeap);
-            // round makes distance smaller => heuristic should underestimate the distance!
             this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 148e3afc08..d55c8f21c2 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -26,7 +26,6 @@
 import com.graphhopper.routing.AStar.AStarEdge;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
@@ -51,12 +50,12 @@
  * or could we even use this three phase approach?
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
- * @author Peter Karich
+ * @author Peter Karich, jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
     private DistanceCalc dist;
-    private ConsitentWeightApproximator weightApprox;
+    private ConsistentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -71,8 +70,9 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
-        setApproximation(new BeelineWeightApproximator(nodeAccess, weighting));
-
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new  DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     protected void initCollections( int size )
@@ -89,7 +89,7 @@ protected void initCollections( int size )
      */
     public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        weightApprox = new ConsitentWeightApproximator(approx);
+        weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
@@ -224,7 +224,8 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weightOfVisitedPath;
+            float alreadyVisitedWeight =(float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                                                 + currEdge.weightOfVisitedPath);
             if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
             
@@ -237,14 +238,14 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
                 {
                     ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
                     shortestWeightMap.put(traversalId, ase);
-                } else //if (ase.weight > estimationFullDist)
+                } else
                 {
-                    //assert (ase.weight > estimationFullDist): "weight: " + ase.weight + "full" + estimationFullDist;
+                    assert(ase.weight > estimationFullDist): "Inconsistent distance estimate";
                     prioQueueOpenSet.remove(ase);
                     ase.edge = iter.getEdge();
                     ase.weight = estimationFullDist;
                     ase.weightOfVisitedPath = alreadyVisitedWeight;
-                } //else  continue;
+                }
 
                 ase.parent = currEdge;
                 prioQueueOpenSet.add(ase);
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index 6189066622..3bca270ac8 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -17,7 +17,11 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.BeelineWeightApproximator;
+import com.graphhopper.routing.util.WeightApproximator;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistancePlaneProjection;
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
@@ -39,19 +43,53 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
         } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
         {
-            return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+                                                            opts.getTraversalMode());
+            String approximation = opts.getHints().get(AlgorithmOptions.ASTAR_BI + ".approximation",
+                                                       "BeelineSimplification");
+            if (approximation == "BeelineSimplification") {
+                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStarBi.nodeAccess, aStarBi.weighting);
+                approx.setDistanceCalc(new DistancePlaneProjection());
+                aStarBi.setApproximation(approx);
+            }
+            else if (approximation == "BeelineAccurate")
+            {
+                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStarBi.nodeAccess, aStarBi.weighting);
+                approx.setDistanceCalc(new DistanceCalcEarth());
+                aStarBi.setApproximation(approx);
+            } else
+            {
+                throw new IllegalArgumentException("Approximation " + approximation + " not found in " + getClass().getName());
+            }
 
+            return aStarBi;
         } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
         {
             return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
         } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
         {
-            return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(),opts.getTraversalMode());
+            String approximation = opts.getHints().get(AlgorithmOptions.ASTAR + ".approximation",
+                                                       "BeelineSimplification");
+            if (approximation == "BeelineSimplification") {
+                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStar.nodeAccess, aStar.weighting);
+                approx.setDistanceCalc(new DistancePlaneProjection());
+                aStar.setApproximation(approx);
+            }
+            else if (approximation == "BeelineAccurate")
+            {
+                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStar.nodeAccess, aStar.weighting);
+                approx.setDistanceCalc(new DistanceCalcEarth());
+                aStar.setApproximation(approx);
+            } else
+            {
+                throw new IllegalArgumentException("Approximation " + approximation + " not found in " + getClass().getName());
+            }
+            return aStar;
         } else
         {
             throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
         }
 
-        return algo;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
index 3a13802206..5df84cfe62 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -7,13 +7,14 @@
 
 /**
  * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
- * @author Jan Soe
+ * @author jansoe
  */
 public class BeelineWeightApproximator implements WeightApproximator {
 
     private NodeAccess nodeAccess;
     private Weighting weighting;
     private DistanceCalc distanceCalc;
+    double toLat, toLon;
 
     public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
         this.nodeAccess = nodeAccess;
@@ -21,21 +22,31 @@ public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
         setDistanceCalc(new DistanceCalcEarth());
     }
 
+    public void setGoalNode(int toNode){
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+    }
+
+    @Override
+    public WeightApproximator duplicate() {
+        return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
+    }
+
+
     @Override
-    public double approximate(int fromNode, int toNode) {
+    public double approximate(int fromNode) {
 
-        double fromLat, fromLon, toLat, toLon, dist2goal, weight2goal;
+        double fromLat, fromLon, dist2goal, weight2goal;
         fromLat  = nodeAccess.getLatitude(fromNode);
         fromLon = nodeAccess.getLongitude(fromNode);
-        toLat = nodeAccess.getLatitude(toNode);
-        toLon = nodeAccess.getLongitude(toNode);
         dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
         weight2goal = weighting.getMinWeight(dist2goal);
 
         return weight2goal;
     }
 
-    public void setDistanceCalc(DistanceCalc distanceCalc) {
+    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
         this.distanceCalc = distanceCalc;
+        return this;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
similarity index 55%
rename from core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java
rename to core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
index 163420d7c3..c7b67e7c68 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -10,30 +10,30 @@
  * pages 291–296.
  * <p/>
  *
- * @author Jan Soe
+ * @author jansoe
  */
-public class ConsitentWeightApproximator {
+public class ConsistentWeightApproximator {
 
     private NodeAccess nodeAccess;
     private Weighting weighting;
-    private WeightApproximator uniDirectionalApproximator;
-    int goalNode, sourceNode;
+    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
 
-    public ConsitentWeightApproximator(WeightApproximator weightApprox){
-        this.uniDirectionalApproximator = weightApprox;
+    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+        uniDirApproximatorForward = weightApprox;
+        uniDirApproximatorReverse = weightApprox.duplicate();
     }
 
     public void setSourceNode(int sourceNode){
-        this.sourceNode = sourceNode;
+        uniDirApproximatorReverse.setGoalNode(sourceNode);
     }
 
     public void setGoalNode(int goalNode){
-        this.goalNode = goalNode;
+        uniDirApproximatorForward.setGoalNode(goalNode);
     }
 
     public double approximate(int fromNode, boolean reverse)    {
-        double weightApproximation = 0.5*(uniDirectionalApproximator.approximate(fromNode, goalNode)
-                                          - uniDirectionalApproximator.approximate(fromNode, sourceNode));
+        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
+                                          - uniDirApproximatorReverse.approximate(fromNode));
         if (reverse) {
             weightApproximation *= -1;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
index 4d74e8b451..b88bc1e5fe 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
@@ -114,7 +114,7 @@ void testAlgos()
         prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
 
         final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
-        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "true");
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
         final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
         prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
         prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
index e4a6a24dfb..f471be0d07 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -3,14 +3,20 @@
 /**
  * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
  * <p/>
- * @author Jan Soe
+ * @author jansoe
  */
 public interface WeightApproximator
 {
 
     /**
-     * @return minimal weight fromNode to the toNode
+     * @return minimal weight fromNode to the goalNode
      */
-    double approximate(int fromNode, int toNode);
+    double approximate(int fromNode);
 
+    void setGoalNode(int to);
+
+    /**
+     * makes a deep copy of itself
+     */
+    WeightApproximator duplicate();
 }
