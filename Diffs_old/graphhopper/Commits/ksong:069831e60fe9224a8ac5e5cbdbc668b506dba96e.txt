diff --git a/.codeclimate.yml b/.codeclimate.yml
index 63f072aaeb..d9d364d924 100644
--- a/.codeclimate.yml
+++ b/.codeclimate.yml
@@ -16,10 +16,6 @@ engines:
         enabled: false
       com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck:
         enabled: false
-      com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.naming.LocalVariableNameCheck:
-        enabled: false
   duplication:
     enabled: true
     config:
diff --git a/.travis.yml b/.travis.yml
index 359bf681a8..27a6e0cf12 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,67 +1,49 @@
+after_success:
+- if [ "$TRAVIS_JDK_VERSION" == "oraclejdk8" ] && [ "$TRAVIS_BRANCH" == "master" ]
+  && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then travis_wait mvn deploy --settings
+  core/files/settings.xml -DskipTests=true -B; else echo "Not deploying snapshot artifact
+  for $TRAVIS_BRANCH"; fi
+before_install:
+- if [ "$TRAVIS_OS_NAME" == "linux" ]; then wget --no-check-certificate $(echo -n
+  $BASEURL | sed -e 's#VERSION#'$VERSION'#g'); unzip -qq $(echo -n $FILE | sed -e
+  's#VERSION#'$VERSION'#'); export M2_HOME=$PWD/$(echo -n $DIR | sed -e 's#VERSION#'$VERSION'#');
+  export PATH=$M2_HOME/bin:$PATH; fi
+- if [ "$TRAVIS_OS_NAME" == "linux" ] && [ "$JVM" == "latest" ]; then sudo apt-get
+  update -qq; sudo /bin/echo -e oracle-java9-installer shared/accepted-oracle-license-v1-1
+  select true | sudo debconf-set-selections; sudo apt-get -o Dpkg::Options::="--force-confnew"
+  install -y oracle-java9-installer oracle-java9-set-default oracle-java9-unlimited-jce-policy;
+  sudo update-java-alternatives -s java-9-oracle; fi
+cache:
+  directories:
+  - $HOME/.m2
+env:
+  global:
+  - BASEURL=https://www-eu.apache.org/dist/maven/maven-3/VERSION/binaries/apache-maven-VERSION-bin.zip
+  - FILE=apache-maven-VERSION-bin.zip
+  - DIR=apache-maven-VERSION
+  - VERSION=3.3.9
+  - secure: j6a61/qnfFcSjx5XxmxO2hqBOwtVx5HWrD1+4Atl7WG/pRKz9+jSga1Y7oDAFb2SIl8S65kDmPQB/vC8aHxUDj/Wizjxnxn1FhPqoe9yO6Ztft+984FKFyvj7s6tsBJKcehGec+chTOwZQpH4oI4rU6IlepDHnGLHiOd0Iviryg=
+  - secure: GiFr+v2lTQk/sTQB7CYjju1/mupS8LSJupmizLqY454utiZkabDMBOZQnF9ukpy7WhveB9hKQyEKf9iP2w7HSYEjgvogT26vZ5f2MeLnR4SWvqEtf/WBvvh+W+k/rb2f6YgitkB4Jlxn2izemBEDuKplGJphzGW41lf8XZ2IxVI=
+install: true
+jdk:
+- oraclejdk8
 language: java
-sudo: false
 matrix:
   fast_finish: true
   include:
-    - jdk: oraclejdk8
-      # Java 9 needs to be manually installed/upgraded
-      # see: https://github.com/travis-ci/travis-ci/issues/2968#issuecomment-149164058      
-    - jdk: oraclejdk9
-      env: JVM=latest
-      sudo: required
-      dist: trusty
-      group: edge
-
-env:
-  global:
-    - BASEURL=https://www-eu.apache.org/dist/maven/maven-3/VERSION/binaries/apache-maven-VERSION-bin.zip
-    - FILE=apache-maven-VERSION-bin.zip
-    - DIR=apache-maven-VERSION
-    - VERSION=3.3.9
-    - secure: "j6a61/qnfFcSjx5XxmxO2hqBOwtVx5HWrD1+4Atl7WG/pRKz9+jSga1Y7oDAFb2SIl8S65kDmPQB/vC8aHxUDj/Wizjxnxn1FhPqoe9yO6Ztft+984FKFyvj7s6tsBJKcehGec+chTOwZQpH4oI4rU6IlepDHnGLHiOd0Iviryg="
-    - secure: "GiFr+v2lTQk/sTQB7CYjju1/mupS8LSJupmizLqY454utiZkabDMBOZQnF9ukpy7WhveB9hKQyEKf9iP2w7HSYEjgvogT26vZ5f2MeLnR4SWvqEtf/WBvvh+W+k/rb2f6YgitkB4Jlxn2izemBEDuKplGJphzGW41lf8XZ2IxVI="
-
-jdk:
-  - oraclejdk8
-
-before_install:
-   # update maven
-   - if [ "$TRAVIS_OS_NAME" == "linux" ]; then
-         wget --no-check-certificate $(echo -n $BASEURL | sed -e 's#VERSION#'$VERSION'#g');
-         unzip -qq $(echo -n $FILE | sed -e 's#VERSION#'$VERSION'#');
-         export M2_HOME=$PWD/$(echo -n $DIR | sed -e 's#VERSION#'$VERSION'#');
-         export PATH=$M2_HOME/bin:$PATH;
-     fi
-   # update java 9
-   - if [ "$TRAVIS_OS_NAME" == "linux" ] && [ "$JVM" == "latest" ]; then
-         sudo apt-get update -qq;
-         sudo /bin/echo -e oracle-java9-installer shared/accepted-oracle-license-v1-1 select true | sudo debconf-set-selections;
-         sudo apt-get -o Dpkg::Options::="--force-confnew" install -y oracle-java9-installer oracle-java9-set-default oracle-java9-unlimited-jce-policy;
-         sudo update-java-alternatives -s java-9-oracle;
-     fi
-#   - if [ "$TRAVIS_JDK_VERSION" == oraclejdk9 ]; then
-#         sudo rm /etc/mavenrc;
-#     fi
-
-install: true
-
+  - jdk: oraclejdk8
+  - dist: trusty
+    env: JVM=latest
+    group: edge
+    jdk: oraclejdk9
+    sudo: required
 script:
-  - mvn clean test verify checkstyle:check findbugs:check forbiddenapis:check -B
-
-after_success:
-  # deploy snapshot artifacts to maven central
-  - if [ "$TRAVIS_JDK_VERSION" == "oraclejdk8" ] &&
-       [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
-         travis_wait mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
-    else
-        echo "Not deploying snapshot artifact for $TRAVIS_BRANCH";
-    fi
-
-notifications:
-  email:
-    - secure: l7/fjqL0c/9UcULXdhaKxsroZMg07nfNDiOHRBf7YKf8wrKdH52Z5kP7E10+a8iD/ieLD+ZaZPlom1bE7HymE1bVkp3d17Ezha47W5sdyOOb3NBDpg8olS4TkehOKo3AQhLXSfF6QGtipxY8Iy9QknXHngQOrcoGYiOlzCZ3BTQ=
-
-cache:
-  directories:
-  - $HOME/.m2
-
+- touch NOW
+- echo GIBSTUDYSTART $(date)
+- mvn clean test verify checkstyle:check findbugs:check -B
+- echo GIBSTUDYEND $(date)
+- cd $TRAVIS_BUILD_DIR
+- if [ "$TRAVIS_OS_NAME" == "osx" ];        then echo TESTNUM $(find . -name TEST-*.xml
+  -newer NOW | wc -l);        else echo TESTNUM $(find -name TEST-*.xml -newer NOW
+  | wc -l);        fi
+sudo: false
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 3f26531b71..aa23cb20cb 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -38,7 +38,6 @@ Here is an overview:
  * JohannesPelzer, improved GPX information and various other things
  * karussell, one of the core developers
  * khuebner, initial turn costs support
- * legraina, improved docker for dockerhub
  * lmar, improved instructions
  * michaz, one of the core developers
  * mprins, improvements for travis CI and regarding JDK9 #806
diff --git a/Dockerfile b/Dockerfile
index 19d70fc819..07d264dfd3 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,21 +1,10 @@
 FROM openjdk:8-jdk
 
-ENV JETTY_PORT 11111
-ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
-
-RUN mkdir -p /data && \
-    mkdir -p /graphhopper
+RUN mkdir -p /data
+RUN mkdir -p /graphhopper
 
 COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
 RUN ./graphhopper.sh buildweb
-
-VOLUME [ "/data" ]
-
-EXPOSE 11111
-
-ENTRYPOINT [ "./graphhopper.sh", "web" ]
-
-CMD [ "/data/europe_germany_berlin.pbf" ]
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 60b02405bc..ba2fb0c0d6 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion 27
-    buildToolsVersion "27.0.1"
+    buildToolsVersion "27.0.0"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
@@ -11,10 +11,9 @@ android {
     }
 
     buildTypes {
-        all {
-            minifyEnabled true
-            useProguard false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
         }
     }
 
@@ -42,15 +41,15 @@ dependencies {
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.9.0'
-    implementation 'org.mapsforge:vtm-android:0.9.0'
-    implementation 'org.mapsforge:vtm-android:0.9.0:natives-armeabi'
-    implementation 'org.mapsforge:vtm-android:0.9.0:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.9.0:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.9.0:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.9.0:natives-x86_64'
-    implementation 'org.mapsforge:vtm-jts:0.9.0'
-    implementation 'org.mapsforge:vtm-themes:0.9.0'
+    implementation 'org.mapsforge:vtm:0.8.0'
+    implementation 'org.mapsforge:vtm-android:0.8.0'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-x86'
+    implementation('org.mapsforge:vtm-jts:0.8.0') {
+        exclude group: 'com.vividsolutions', module: 'jts-core'
+    }
+    implementation 'org.mapsforge:vtm-themes:0.8.0'
     implementation 'com.caverock:androidsvg:1.2.2-beta-1'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 92d1d2792b..1ca4a99567 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -19,7 +19,7 @@
         <version>0.10-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.9.0</vtm.version>
+        <vtm.version>0.8.0</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -67,29 +67,23 @@
             <version>${vtm.version}</version>
             <classifier>natives-armeabi-v7a</classifier>
         </dependency>  
-         <dependency>
-            <groupId>org.mapsforge</groupId>
-            <artifactId>vtm-android</artifactId>
-            <version>${vtm.version}</version>
-            <classifier>natives-arm64-v8a</classifier>
-        </dependency>
          <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-android</artifactId>
             <version>${vtm.version}</version>
             <classifier>natives-x86</classifier>
         </dependency>        
-         <dependency>
-            <groupId>org.mapsforge</groupId>
-            <artifactId>vtm-android</artifactId>
-            <version>${vtm.version}</version>
-            <classifier>natives-x86_64</classifier>
-        </dependency>
-
+        
         <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-jts</artifactId>
             <version>${vtm.version}</version>
+            <exclusions>
+            	<exclusion>
+            	  <groupId>com.vividsolutions</groupId>            
+  		  <artifactId>jts-core</artifactId>
+            	</exclusion>
+            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.mapsforge</groupId>            
diff --git a/android/app/proguard-rules.pro b/android/app/proguard-rules.pro
deleted file mode 100644
index 63b4a48a1c..0000000000
--- a/android/app/proguard-rules.pro
+++ /dev/null
@@ -1,8 +0,0 @@
--keep class com.** { *; }
--dontwarn com.**
--keep class okhttp3.** { *; }
--dontwarn okhttp3.**
--keep class okio.** { *; }
--dontwarn okio.**
--keep class org.** { *; }
--dontwarn org.**
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 8dc3e82782..5434d6fb9f 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -39,6 +39,7 @@
 import org.oscim.android.canvas.AndroidGraphics;
 import org.oscim.backend.canvas.Bitmap;
 import org.oscim.core.GeoPoint;
+import org.oscim.core.Tile;
 import org.oscim.event.Gesture;
 import org.oscim.event.GestureListener;
 import org.oscim.event.MotionEvent;
@@ -118,6 +119,7 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
 
+        Tile.SIZE = Tile.calculateTileSize(getResources().getDisplayMetrics().scaledDensity);
         mapView = new MapView(this);
 
         final EditText input = new EditText(this);
diff --git a/android/build.gradle b/android/build.gradle
index 7105f5a2dd..42a1c7f0e4 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.1'
+        classpath 'com.android.tools.build:gradle:3.0.0'
     }
 }
 
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 9a39b7cc31..a8f1e524e3 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -75,13 +75,14 @@ public MatrixResponse route(GHMRequest ghRequest) {
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
 
+        ObjectNode hintsObject = requestJson.putObject("hints");
         Map<String, String> hintsMap = ghRequest.getHints().toMap();
         for (String hintKey : hintsMap.keySet()) {
             if (ignoreSet.contains(hintKey))
                 continue;
 
             String hint = hintsMap.get(hintKey);
-            requestJson.put(hintKey, hint);
+            hintsObject.put(hintKey, hint);
         }
 
         boolean withTimes = outArraysList.contains("times");
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index b8ca744ade..48daf5a87d 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -37,8 +37,6 @@
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient
  * usage.
@@ -176,11 +174,6 @@ PathWrapper createPathWrapper(JsonNode path,
                         instr = new FinishInstruction(text, instPL, 0);
                     } else {
                         instr = new Instruction(sign, text, ia, instPL);
-                        if(sign == Instruction.CONTINUE_ON_STREET){
-                            if(jsonObj.has("heading")){
-                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
-                            }
-                        }
                     }
 
                     // Usually, the translation is done from the routing service so just use the provided string
@@ -414,7 +407,7 @@ private Request createRequest(GHRequest request) {
 
         String places = "";
         for (GHPoint p : request.getPoints()) {
-            places += "point=" + round6(p.lat) + "," + round6(p.lon) + "&";
+            places += "point=" + Helper.round6(p.lat) + "," + Helper.round6(p.lon) + "&";
         }
 
         String type = request.getHints().get("type", "json");
@@ -448,7 +441,7 @@ private Request createRequest(GHRequest request) {
             String urlValue = entry.getValue();
 
             // use lower case conversion for check only!
-            if (ignoreSet.contains(toLowerCase(urlKey))) {
+            if (ignoreSet.contains(urlKey.toLowerCase())) {
                 continue;
             }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 92ec9d6cd1..c92f3980cb 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -56,7 +56,7 @@ public void testBikeMatrix() {
         req.addOutArray("times");
 
         MatrixResponse res = ghMatrix.route(req);
-        assertEquals(2495, res.getTime(1, 2) / 1000, 50);
+        assertEquals(2350, res.getTime(1, 2) / 1000, 50);
     }
 
     @Test
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 2724370451..0b2814cd5b 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -252,29 +252,6 @@ public void testMatrix() {
         assertEquals(1695, res.getWeight(1, 2), 10);
     }
 
-    @Test
-    public void testMatrix_DoNotWrapHints() {
-        final GraphHopperMatrixWeb ghMatrix = new GraphHopperMatrixWeb(new GHMatrixBatchRequester() {
-            @Override
-            protected String postJson(String url, JsonNode data) throws IOException {
-                assertFalse(data.has("hints"));
-                assertTrue(data.has("something"));
-                return super.postJson(url, data);
-            }
-        });
-        ghMatrix.setKey(System.getProperty("graphhopper.key", KEY));
-
-        GHMRequest req = new GHMRequest();
-        req.addPoint(new GHPoint(49.6724, 11.3494));
-        req.addPoint(new GHPoint(49.6550, 11.4180));
-        req.getHints().put("something", "xy");
-        ghMatrix.route(req);
-
-        // clashing parameter will overwrite!
-        req.getHints().put("vehicle", "xy");
-        assertEquals("xy", req.getVehicle());
-    }
-
     @Test
     public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
diff --git a/config-example.properties b/config-example.properties
index c3b2067732..f0aa981bef 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -14,8 +14,7 @@ graph.flag_encoders=car
 ##### Elevation #####
 
 
-# Per default GraphHopper doesn't use elevation data, you can enable elevation by setting graph.elevation.provider
-# to srtm, cgiar, gmted, or multi. See the corresponding classes at com.graphhopper.reader.dem for more information.
+# To populate your graph with elevation data use SRTM, default is noop (no elevation)
 # graph.elevation.provider=srtm
 
 
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
index ff9d1f7c7c..55c7c34c5b 100644
--- a/core/files/docker-compose.yml
+++ b/core/files/docker-compose.yml
@@ -10,4 +10,7 @@ services:
             JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
         ports:
             - "11111:11111"
-        command: /data/europe_germany_berlin.pbf
+        entrypoint:
+            - ./graphhopper.sh
+            - web
+            - ../data/europe_germany_berlin.pbf
diff --git a/core/files/krautsand.osm.gz b/core/files/krautsand.osm.gz
deleted file mode 100644
index d8e1578532..0000000000
Binary files a/core/files/krautsand.osm.gz and /dev/null differ
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 5c460ec166..2b74df151d 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -57,7 +57,6 @@
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.*;
 
 /**
@@ -437,7 +436,7 @@ public String getDataReaderFile() {
      */
     public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
-        if (isEmpty(dataReaderFileStr))
+        if (Helper.isEmpty(dataReaderFileStr))
             throw new IllegalArgumentException("Data reader file cannot be empty.");
 
         dataReaderFile = dataReaderFileStr;
@@ -523,15 +522,15 @@ public GraphHopper init(CmdArgs args) {
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
 
         String tmpOsmFile = args.get("datareader.file", "");
-        if (!isEmpty(tmpOsmFile))
+        if (!Helper.isEmpty(tmpOsmFile))
             dataReaderFile = tmpOsmFile;
 
         String graphHopperFolder = args.get("graph.location", "");
-        if (isEmpty(graphHopperFolder) && isEmpty(ghLocation)) {
-            if (isEmpty(dataReaderFile))
+        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+            if (Helper.isEmpty(dataReaderFile))
                 throw new IllegalArgumentException("You need to specify an OSM file.");
 
-            graphHopperFolder = pruneFileEnd(dataReaderFile) + "-gh";
+            graphHopperFolder = Helper.pruneFileEnd(dataReaderFile) + "-gh";
         }
 
         // graph
@@ -554,7 +553,7 @@ public GraphHopper init(CmdArgs args) {
             lockFactory = new NativeFSLockFactory();
 
         // elevation
-        String eleProviderStr = toLowerCase(args.get("graph.elevation.provider", "noop"));
+        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
 
         // keep fallback until 0.8
         boolean eleCalcMean = args.has("graph.elevation.calcmean")
@@ -577,15 +576,10 @@ public GraphHopper init(CmdArgs args) {
             CGIARProvider cgiarProvider = new CGIARProvider();
             cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
             tmpProvider = cgiarProvider;
-        } else if (eleProviderStr.equalsIgnoreCase("gmted")) {
-            tmpProvider = new GMTEDProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("multi")) {
-            tmpProvider = new MultiSourceElevationProvider();
         }
 
         tmpProvider.setCalcMean(eleCalcMean);
-        if (!cacheDirStr.isEmpty())
-            tmpProvider.setCacheDir(new File(cacheDirStr));
+        tmpProvider.setCacheDir(new File(cacheDirStr));
         if (!baseURL.isEmpty())
             tmpProvider.setBaseURL(baseURL);
         tmpProvider.setDAType(elevationDAType);
@@ -656,7 +650,7 @@ private GraphHopper process(String graphHopperLocation) {
 
             try {
                 DataReader reader = importData();
-                DateFormat f = createFormatter();
+                DateFormat f = Helper.createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
                 if (reader.getDataDate() != null)
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
@@ -685,7 +679,7 @@ protected DataReader importData() throws IOException {
         encodingManager.setEnableInstructions(enableInstructions);
         encodingManager.setPreferredLanguage(preferredLanguage);
         DataReader reader = createReader(ghStorage);
-        logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
+        logger.info("using " + ghStorage.toString() + ", memory:" + Helper.getMemInfo());
         reader.readGraph();
         return reader;
     }
@@ -714,7 +708,7 @@ protected DataReader initDataReader(DataReader reader) {
      */
     @Override
     public boolean load(String graphHopperFolder) {
-        if (isEmpty(graphHopperFolder))
+        if (Helper.isEmpty(graphHopperFolder))
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
 
         if (fullyLoaded)
@@ -848,7 +842,7 @@ public void postProcessing() {
 
             GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
             GHUtility.sortDFS(ghStorage, newGraph);
-            logger.info("graph sorted (" + getMemInfo() + ")");
+            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
             ghStorage = newGraph;
         }
 
@@ -901,7 +895,7 @@ private void interpolateBridgesAndOrTunnels() {
      * @see HintsMap
      */
     public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
-        String weightingStr = toLowerCase(hintsMap.getWeighting());
+        String weightingStr = hintsMap.getWeighting().toLowerCase();
         Weighting weighting = null;
 
         if (encoder.supports(GenericWeighting.class)) {
@@ -1075,9 +1069,6 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                         setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
                         setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
 
-                if(request.hasFavoredHeading(0))
-                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
-
                 if (routingTemplate.isReady(pathMerger, tr))
                     break;
             }
@@ -1134,7 +1125,7 @@ private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
         GHPoint lastPoint = points.get(0);
         GHPoint point;
         double dist;
-        DistanceCalc calc = DIST_3D;
+        DistanceCalc calc = Helper.DIST_3D;
         for (int i = 1; i < points.size(); i++) {
             point = points.get(i);
             dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
@@ -1222,9 +1213,9 @@ protected void cleanUp() {
 
     protected void flush() {
         logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
-                + getMemInfo() + ")");
+                + Helper.getMemInfo() + ")");
         ghStorage.flush();
-        logger.info("flushed graph " + getMemInfo() + ")");
+        logger.info("flushed graph " + Helper.getMemInfo() + ")");
         fullyLoaded = true;
     }
 
@@ -1255,7 +1246,7 @@ public void clean() {
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
         File folder = new File(getGraphHopperLocation());
-        removeDir(folder);
+        Helper.removeDir(folder);
     }
 
     protected void ensureNotLoaded() {
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 2b82d6cd7c..1664eef86a 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -254,6 +254,9 @@ public void addPathDetails(Map<String, List<PathDetail>> details) {
             throw new IllegalStateException("Details have to be the same size");
         }
         for (Map.Entry<String, List<PathDetail>> detailEntry : details.entrySet()) {
+            if (detailEntry.getValue().isEmpty())
+                throw new IllegalStateException("PathDetails " + detailEntry.getKey() + " must not be empty");
+
             if (this.pathDetails.containsKey(detailEntry.getKey())) {
                 List<PathDetail> pd = this.pathDetails.get(detailEntry.getKey());
                 PathMerger.merge(pd, detailEntry.getValue());
diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index bc891342aa..4ed6b675e7 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -12,24 +12,25 @@
     public static abstract class Leg {
         public final String type;
         public final String departureLocation;
+        public final Date departureTime;
         public final List<EdgeIteratorState> edges;
         public final Geometry geometry;
         public final double distance;
+        public final Date arrivalTime;
 
-        public Leg(String type, String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance) {
+        public Leg(String type, String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, Date arrivalTime) {
             this.type = type;
             this.departureLocation = departureLocation;
             this.edges = edges;
             this.geometry = geometry;
             this.distance = distance;
+            this.departureTime = departureTime;
+            this.arrivalTime = arrivalTime;
         }
 
         public double getDistance() {
             return distance;
         }
-
-        public abstract Date getDepartureTime();
-        public abstract Date getArrivalTime();
     }
 
     public static class Stop {
@@ -47,38 +48,14 @@ public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date
             this.arrivalTime = arrivalTime;
             this.departureTime = departureTime;
         }
-
-        @Override
-        public String toString() {
-            return "Stop{" +
-                    "stop_id='" + stop_id + '\'' +
-                    ", arrivalTime=" + arrivalTime +
-                    ", departureTime=" + departureTime +
-                    '}';
-        }
     }
     public static class WalkLeg extends Leg {
         public final InstructionList instructions;
-        private final Date departureTime;
-        private final Date arrivalTime;
 
         public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
-            super("walk", departureLocation, edges, geometry, distance);
+            super("walk", departureLocation, departureTime, edges, geometry, distance, arrivalTime);
             this.instructions = instructions;
-            this.departureTime = departureTime;
-            this.arrivalTime = arrivalTime;
         }
-
-        @Override
-        public Date getDepartureTime() {
-            return departureTime;
-        }
-
-        @Override
-        public Date getArrivalTime() {
-            return arrivalTime;
-        }
-
     }
     public static class PtLeg extends Leg {
         public final String feed_id;
@@ -89,8 +66,8 @@ public Date getArrivalTime() {
         public final String trip_id;
         public final String route_id;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
-            super("pt", stops.get(0).stop_name, edges, geometry, distance);
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
+            super("pt", stops.get(0).stop_name, departureTime, edges, geometry, distance, arrivalTime);
             this.feed_id = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
             this.trip_id = tripId;
@@ -100,15 +77,6 @@ public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, St
             this.stops = stops;
         }
 
-        @Override
-        public Date getDepartureTime() {
-            return stops.get(0).departureTime;
-        }
-
-        @Override
-        public Date getArrivalTime() {
-            return stops.get(stops.size()-1).arrivalTime;
-        }
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java
deleted file mode 100644
index 2944228dc0..0000000000
--- a/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.dem;
-
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.util.Downloader;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.awt.image.Raster;
-import java.io.File;
-import java.io.IOException;
-import java.net.SocketTimeoutException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Provides basic methods that are usually used in an ElevationProvider that reads tiff files.
- *
- * @author Robin Boldt
- */
-public abstract class AbstractTiffElevationProvider implements ElevationProvider {
-    final Logger logger = LoggerFactory.getLogger(getClass());
-    final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
-    protected Downloader downloader;
-    File cacheDir;
-    String baseUrl;
-    private Directory dir;
-    private DAType daType = DAType.MMAP;
-    boolean calcMean = false;
-    boolean autoRemoveTemporary = true;
-    long sleep = 2000;
-
-    public AbstractTiffElevationProvider(String baseUrl, String cacheDir, String downloaderName) {
-        this.baseUrl = baseUrl;
-        this.cacheDir = new File(cacheDir);
-        downloader = new Downloader(downloaderName).setTimeout(10000);
-    }
-
-    @Override
-    public void setCalcMean(boolean eleCalcMean) {
-        calcMean = eleCalcMean;
-    }
-
-    void setSleep(long sleep) {
-        this.sleep = sleep;
-    }
-
-    /**
-     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
-     * our DataAccess object, so this option can be used to disable the default clear mechanism via
-     * specifying 'false'.
-     */
-    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
-        this.autoRemoveTemporary = autoRemoveTemporary;
-    }
-
-    public void setDownloader(Downloader downloader) {
-        this.downloader = downloader;
-    }
-
-    @Override
-    public ElevationProvider setCacheDir(File cacheDir) {
-        if (cacheDir.exists() && !cacheDir.isDirectory())
-            throw new IllegalArgumentException("Cache path has to be a directory");
-        try {
-            this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex) {
-            throw new RuntimeException(ex);
-        }
-        return this;
-    }
-
-    protected File getCacheDir() {
-        return cacheDir;
-    }
-
-    @Override
-    public ElevationProvider setBaseURL(String baseUrl) {
-        if (baseUrl == null || baseUrl.isEmpty())
-            throw new IllegalArgumentException("baseUrl cannot be empty");
-
-        this.baseUrl = baseUrl;
-        return this;
-    }
-
-    @Override
-    public ElevationProvider setDAType(DAType daType) {
-        this.daType = daType;
-        return this;
-    }
-
-
-    @Override
-    public void release() {
-        cacheData.clear();
-
-        // for memory mapped type we create temporary unpacked files which should be removed
-        if (autoRemoveTemporary && dir != null)
-            dir.clear();
-    }
-
-    /**
-     * Download a file at the provided url and save it as the given downloadFile if the downloadFile does not exist.
-     */
-    protected void downloadFile(File downloadFile, String url) throws IOException {
-        if (!downloadFile.exists()) {
-            int max = 3;
-            for (int trial = 0; trial < max; trial++) {
-                try {
-                    downloader.downloadFile(url, downloadFile.getAbsolutePath());
-                    return;
-                } catch (SocketTimeoutException ex) {
-                    if (trial >= max - 1)
-                        throw new RuntimeException(ex);
-                    try {
-                        Thread.sleep(sleep);
-                    } catch (InterruptedException ignored) {
-                    }
-                }
-            }
-        }
-    }
-
-    protected void fillDataAccessWithElevationData(Raster raster, DataAccess heights, int dataAccessWidth) {
-        final int height = raster.getHeight();
-        final int width = raster.getWidth();
-        int x = 0;
-        int y = 0;
-        try {
-            for (y = 0; y < height; y++) {
-                for (x = 0; x < width; x++) {
-                    short val = (short) raster.getPixel(x, y, (int[]) null)[0];
-                    if (val < -1000 || val > 12000)
-                        val = Short.MIN_VALUE;
-
-                    heights.setShort(2 * (y * dataAccessWidth + x), val);
-                }
-            }
-            heights.flush();
-
-            // TODO remove tifName and zip?
-        } catch (Exception ex) {
-            throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
-        }
-    }
-
-    protected Directory getDirectory() {
-        if (dir != null)
-            return dir;
-
-        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
-        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
-    }
-}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index e1d527400f..973a54bf03 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -17,17 +17,26 @@
  */
 package com.graphhopper.reader.dem;
 
+import com.graphhopper.storage.DAType;
 import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
 import org.apache.xmlgraphics.image.codec.util.SeekableStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.awt.image.Raster;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
@@ -47,17 +56,22 @@
  * @author NopMap
  * @author Peter Karich
  */
-public class CGIARProvider extends AbstractTiffElevationProvider {
+public class CGIARProvider implements ElevationProvider {
     private static final int WIDTH = 6000;
-    private final double precision = 1e7;
+    final double precision = 1e7;
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
     private final double invPrecision = 1 / precision;
     private final int degree = 5;
-
-    public CGIARProvider() {
-        super("http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff",
-                "/tmp/cgiar",
-                "GraphHopper CGIARReader");
-    }
+    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
+    private File cacheDir = new File("/tmp/cgiar");
+    // for alternatives see #346
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
+    private Directory dir;
+    private DAType daType = DAType.MMAP;
+    private boolean calcMean = false;
+    private boolean autoRemoveTemporary = true;
+    private long sleep = 2000;
 
     public static void main(String[] args) {
         CGIARProvider provider = new CGIARProvider();
@@ -66,33 +80,85 @@ public static void main(String[] args) {
 
         // 337.0
         System.out.println(provider.getEle(49.949784, 11.57517));
-        // 466.0
+        // 453.0
         System.out.println(provider.getEle(49.968668, 11.575127));
-        // 455.0
+        // 447.0
         System.out.println(provider.getEle(49.968682, 11.574842));
 
-        // 3134
+        // 3131
         System.out.println(provider.getEle(-22.532854, -65.110474));
 
-        // 120
+        // 123
         System.out.println(provider.getEle(38.065392, -87.099609));
 
         // 1615
         System.out.println(provider.getEle(40, -105.2277023));
         System.out.println(provider.getEle(39.99999999, -105.2277023));
         System.out.println(provider.getEle(39.9999999, -105.2277023));
-        // 1616
+        // 1617
         System.out.println(provider.getEle(39.999999, -105.2277023));
 
         // 0
         System.out.println(provider.getEle(29.840644, -42.890625));
     }
 
+    @Override
+    public void setCalcMean(boolean eleCalcMean) {
+        calcMean = eleCalcMean;
+    }
+
+    void setSleep(long sleep) {
+        this.sleep = sleep;
+    }
+
+    /**
+     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
+     * our DataAccess object, so this option can be used to disable the default clear mechanism via
+     * specifying 'false'.
+     */
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+    public void setDownloader(Downloader downloader) {
+        this.downloader = downloader;
+    }
+
+    @Override
+    public ElevationProvider setCacheDir(File cacheDir) {
+        if (cacheDir.exists() && !cacheDir.isDirectory())
+            throw new IllegalArgumentException("Cache path has to be a directory");
+        try {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+        return this;
+    }
+
+    protected File getCacheDir() {
+        return cacheDir;
+    }
+
+    @Override
+    public ElevationProvider setBaseURL(String baseUrl) {
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
+
+        this.baseUrl = baseUrl;
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType(DAType daType) {
+        this.daType = daType;
+        return this;
+    }
+
     @Override
     public double getEle(double lat, double lon) {
-        // Return fast, if there is no data available
-        // See https://www2.jpl.nasa.gov/srtm/faq.html
-        if (lat >= 60 || lat <= -56)
+        // no data we can avoid the trouble
+        if (lat > 60 || lat < -60)
             return 0;
 
         lat = (int) (lat * precision) / precision;
@@ -106,7 +172,7 @@ public double getEle(double lat, double lon) {
             int minLat = down(lat);
             int minLon = down(lon);
             // less restrictive against boundary checking
-            demProvider = new HeightTile(minLat, minLon, WIDTH, WIDTH, degree * precision, degree, degree);
+            demProvider = new HeightTile(minLat, minLon, WIDTH, degree * precision, degree);
             demProvider.setCalcMean(calcMean);
 
             cacheData.put(name, demProvider);
@@ -124,14 +190,31 @@ public double getEle(double lat, double lon) {
                 String zippedURL = baseUrl + "/" + name + ".zip";
                 File file = new File(cacheDir, new File(zippedURL).getName());
 
-                try {
-                    downloadFile(file, zippedURL);
-                } catch (IOException e) {
-                    demProvider.setSeaLevel(true);
-                    // use small size on disc and in-memory
-                    heights.setSegmentSize(100).create(10).
-                            flush();
-                    return 0;
+                // get zip file if not already in cacheDir - unzip later and in-memory only!
+                if (!file.exists()) {
+                    try {
+                        int max = 3;
+                        for (int trial = 0; trial < max; trial++) {
+                            try {
+                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                                break;
+                            } catch (SocketTimeoutException ex) {
+                                // just try again after a little nap
+                                Thread.sleep(sleep);
+                                if (trial >= max - 1)
+                                    throw ex;
+                                continue;
+                            } catch (IOException ex) {
+                                demProvider.setSeaLevel(true);
+                                // use small size on disc and in-memory
+                                heights.setSegmentSize(100).create(10).
+                                        flush();
+                                return 0;
+                            }
+                        }
+                    } catch (Exception ex) {
+                        throw new RuntimeException(ex);
+                    }
                 }
 
                 // short == 2 bytes
@@ -160,8 +243,26 @@ public double getEle(double lat, double lon) {
                         Helper.close(ss);
                 }
 
-                fillDataAccessWithElevationData(raster, heights, WIDTH);
+                // logger.info("start converting to our format");
+                final int height = raster.getHeight();
+                final int width = raster.getWidth();
+                int x = 0, y = 0;
+                try {
+                    for (y = 0; y < height; y++) {
+                        for (x = 0; x < width; x++) {
+                            short val = (short) raster.getPixel(x, y, (int[]) null)[0];
+                            if (val < -1000 || val > 12000)
+                                val = Short.MIN_VALUE;
+
+                            heights.setShort(2 * (y * WIDTH + x), val);
+                        }
+                    }
+                    heights.flush();
 
+                    // TODO remove tifName and zip?
+                } catch (Exception ex) {
+                    throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
+                }
             } // loadExisting
         }
 
@@ -200,8 +301,25 @@ protected String getFileName(double lat, double lon) {
         return str;
     }
 
+    @Override
+    public void release() {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (autoRemoveTemporary && dir != null)
+            dir.clear();
+    }
+
     @Override
     public String toString() {
         return "CGIAR";
     }
-}
\ No newline at end of file
+
+    private Directory getDirectory() {
+        if (dir != null)
+            return dir;
+
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
+        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java b/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java
deleted file mode 100644
index 5cb498c38f..0000000000
--- a/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.dem;
-
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.util.Helper;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
-import org.apache.xmlgraphics.image.codec.util.SeekableStream;
-
-import java.awt.image.Raster;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Locale;
-
-import static com.graphhopper.util.Helper.*;
-
-/**
- * Elevation data from Global Multi-resolution Terrain Elevation Data 2010 (GMTED2010).
- * The data provides 7.5 arc seconds resolution (~250 m) global elevation data. The data is available between latitudes
- * of 84°N and 70°S. The data is available as .tiff and the we are using the mean elevation per cell (other options are
- * median, min, max, etc.).
- * <p>
- * More information can be found here: https://topotools.cr.usgs.gov/gmted_viewer/
- * <p>
- * When using the data we have to acknowledge the source: "Data available from the U.S. Geological Survey.",
- * more information can be found here: https://lta.cr.usgs.gov/citation
- * <p>
- * The gdalinfo of one GeoTiff is:
- * Driver: GTiff/GeoTIFF
- * Files: 50N000E_20101117_gmted_mea075.tif
- * Size is 14400, 9600
- * Coordinate System is:
- * GEOGCS["WGS 84",
- * DATUM["WGS_1984",
- * SPHEROID["WGS 84",6378137,298.257223563,
- * AUTHORITY["EPSG","7030"]],
- * AUTHORITY["EPSG","6326"]],
- * PRIMEM["Greenwich",0],
- * UNIT["degree",0.0174532925199433],
- * AUTHORITY["EPSG","4326"]]
- * Origin = (-0.000138888888889,69.999861111111116)
- * Pixel Size = (0.002083333333333,-0.002083333333333)
- * Metadata:
- * AREA_OR_POINT=Area
- * Image Structure Metadata:
- * INTERLEAVE=BAND
- * Corner Coordinates:
- * Upper Left  (  -0.0001389,  69.9998611) (  0d 0' 0.50"W, 69d59'59.50"N)
- * Lower Left  (  -0.0001389,  49.9998611) (  0d 0' 0.50"W, 49d59'59.50"N)
- * Upper Right (  29.9998611,  69.9998611) ( 29d59'59.50"E, 69d59'59.50"N)
- * Lower Right (  29.9998611,  49.9998611) ( 29d59'59.50"E, 49d59'59.50"N)
- * Center      (  14.9998611,  59.9998611) ( 14d59'59.50"E, 59d59'59.50"N)
- * Band 1 Block=14400x1 Type=Int16, ColorInterp=Gray
- * Min=-209.000 Max=2437.000
- * Minimum=-209.000, Maximum=2437.000, Mean=149.447, StdDev=239.767
- * NoData Value=-32768
- * Metadata:
- * STATISTICS_EXCLUDEDVALUES=-32768
- * STATISTICS_MAXIMUM=2437
- * STATISTICS_MEAN=149.44718774595
- * STATISTICS_MINIMUM=-209
- * STATISTICS_STDDEV=239.767158482
- *
- * @author Robin Boldt
- */
-public class GMTEDProvider extends AbstractTiffElevationProvider {
-    private static final int WIDTH = 14400;
-    private static final int HEIGHT = 9600;
-    // TODO is the precision correct?
-    private final double precision = 1e7;
-    private final int latDegree = 20;
-    private final int lonDegree = 30;
-    // for alternatives see #346
-    private final String FILE_NAME_END = "_20101117_gmted_mea075";
-
-    public GMTEDProvider() {
-        super("https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/topo/downloads/GMTED/Global_tiles_GMTED/075darcsec/mea/",
-                "/tmp/gmted",
-                "GraphHopper GMTEDReader");
-    }
-
-    public static void main(String[] args) {
-        GMTEDProvider provider = new GMTEDProvider();
-
-        System.out.println(provider.getEle(46, -20));
-
-        // 337.0 (339)
-        System.out.println(provider.getEle(49.949784, 11.57517));
-        // 453.0 (438)
-        System.out.println(provider.getEle(49.968668, 11.575127));
-        // 447.0 (432)
-        System.out.println(provider.getEle(49.968682, 11.574842));
-
-        // 3131 (3169)
-        System.out.println(provider.getEle(-22.532854, -65.110474));
-
-        // 123 (124)
-        System.out.println(provider.getEle(38.065392, -87.099609));
-
-        // 1615 (1615)
-        System.out.println(provider.getEle(40, -105.2277023));
-        // (1618)
-        System.out.println(provider.getEle(39.99999999, -105.2277023));
-        System.out.println(provider.getEle(39.9999999, -105.2277023));
-        // 1617 (1618)
-        System.out.println(provider.getEle(39.999999, -105.2277023));
-
-        // 1046 (1070)
-        System.out.println(provider.getEle(47.468668, 14.575127));
-        // 1113 (1115)
-        System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 1946 (1990)
-        System.out.println(provider.getEle(46.468835, 12.578777));
-
-        // 845 (841)
-        System.out.println(provider.getEle(48.469123, 9.576393));
-
-        // 1113 vs new: (1115)
-        provider.setCalcMean(true);
-        System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 0
-        System.out.println(provider.getEle(29.840644, -42.890625));
-    }
-
-    @Override
-    public double getEle(double lat, double lon) {
-        // Return fast, if there is no data available
-        if (lat > 84 || lat < -70)
-            return 0;
-
-        lat = (int) (lat * precision) / precision;
-        lon = (int) (lon * precision) / precision;
-        String name = getFileName(lat, lon);
-        // To lowercase and remove the directory and file ending so it works with the DataAccess
-        HeightTile demProvider = cacheData.get(name);
-        if (demProvider == null) {
-            if (!cacheDir.exists())
-                cacheDir.mkdirs();
-
-            int minLat = getMinLatForTile(lat);
-            int minLon = getMinLonForTile(lon);
-            // less restrictive against boundary checking
-            demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, lonDegree * precision, lonDegree, latDegree);
-            demProvider.setCalcMean(calcMean);
-
-            cacheData.put(name, demProvider);
-            DataAccess heights = getDirectory().find(name + ".gh");
-            demProvider.setHeights(heights);
-            boolean loadExisting = false;
-            try {
-                loadExisting = heights.loadExisting();
-            } catch (Exception ex) {
-                logger.warn("cannot load " + name + ", error: " + ex.getMessage());
-            }
-
-            if (!loadExisting) {
-                String zippedURL = baseUrl + "/" + getDownloadURL(lat, lon);
-                File file = new File(cacheDir, new File(name + ".tif").getName());
-
-                try {
-                    downloadFile(file, zippedURL);
-                } catch (IOException e) {
-                    demProvider.setSeaLevel(true);
-                    // use small size on disc and in-memory
-                    heights.setSegmentSize(100).create(10).
-                            flush();
-                    return 0;
-                }
-
-                // short == 2 bytes
-                heights.create(2 * WIDTH * HEIGHT);
-
-                Raster raster;
-                SeekableStream ss = null;
-                try {
-                    InputStream is = new FileInputStream(file);
-                    ss = SeekableStream.wrapInputStream(is, true);
-                    TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
-                    raster = imageDecoder.decodeAsRaster();
-                } catch (Exception e) {
-                    throw new RuntimeException("Can't decode " + file.getName(), e);
-                } finally {
-                    if (ss != null)
-                        close(ss);
-                }
-
-                fillDataAccessWithElevationData(raster, heights, WIDTH);
-
-            } // loadExisting
-        }
-
-        if (demProvider.isSeaLevel())
-            return 0;
-
-        return demProvider.getHeight(lat, lon);
-    }
-
-    int getMinLatForTile(double lat) {
-        return (int) (Math.floor((90 + lat) / latDegree) * latDegree) - 90;
-    }
-
-    int getMinLonForTile(double lon) {
-        return (int) (Math.floor((180 + lon) / lonDegree) * lonDegree) - 180;
-    }
-
-    // TODO it is a bit ugly that we have to duplicate the code with getDownloadURL, but since the DataAccess only allows lower case strings, but the files on the server are uppper cases, this creates too many issues
-    String getFileName(double lat, double lon) {
-        int lonInt = getMinLonForTile(lon);
-        int latInt = getMinLatForTile(lat);
-        String north = getNorthString(latInt);
-        String east = getEastString(lonInt);
-        String lonString = String.format(Locale.ROOT, "%03d", Math.abs(lonInt));
-        return toLowerCase(String.format(Locale.ROOT, "%02d", Math.abs(latInt)) + north + lonString + east + FILE_NAME_END);
-    }
-
-    String getDownloadURL(double lat, double lon) {
-        int lonInt = getMinLonForTile(lon);
-        int latInt = getMinLatForTile(lat);
-        String north = getNorthString(latInt);
-        String east = getEastString(lonInt);
-        String lonString = String.format(Locale.ROOT, "%03d", Math.abs(lonInt));
-        return east + lonString + "/" + String.format(Locale.ROOT, "%02d", Math.abs(latInt)) + north + lonString + east + FILE_NAME_END + ".tif";
-    }
-
-    private String getNorthString(int lat) {
-        if (lat < 0) {
-            return "S";
-        }
-        return "N";
-    }
-
-    private String getEastString(int lon) {
-        if (lon < 0) {
-            return "W";
-        }
-        return "E";
-    }
-
-    @Override
-    public String toString() {
-        return "gmted";
-    }
-
-}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index c7b5b866c1..7fb681172e 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -36,27 +36,21 @@
     private final int minLat;
     private final int minLon;
     private final int width;
-    private final int height;
-    private final int horizontalDegree;
-    private final int verticalDegree;
+    private final int degree;
     private final double lowerBound;
-    private final double lonHigherBound;
-    private final double latHigherBound;
+    private final double higherBound;
     private DataAccess heights;
     private boolean calcMean;
 
-    public HeightTile(int minLat, int minLon, int width, int height, double precision, int horizontalDegree, int verticalDegree) {
+    public HeightTile(int minLat, int minLon, int width, double precision, int degree) {
         this.minLat = minLat;
         this.minLon = minLon;
         this.width = width;
-        this.height = height;
 
         this.lowerBound = -1 / precision;
-        this.lonHigherBound = horizontalDegree + 1 / precision;
-        this.latHigherBound = verticalDegree + 1 / precision;
+        this.higherBound = degree + 1 / precision;
 
-        this.horizontalDegree = horizontalDegree;
-        this.verticalDegree = verticalDegree;
+        this.degree = degree;
     }
 
     public HeightTile setCalcMean(boolean b) {
@@ -80,18 +74,18 @@ void setHeights(DataAccess da) {
     public double getHeight(double lat, double lon) {
         double deltaLat = Math.abs(lat - minLat);
         double deltaLon = Math.abs(lon - minLon);
-        if (deltaLat > latHigherBound || deltaLat < lowerBound)
+        if (deltaLat > higherBound || deltaLat < lowerBound)
             throw new IllegalStateException("latitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
-        if (deltaLon > lonHigherBound || deltaLon < lowerBound)
+        if (deltaLon > higherBound || deltaLon < lowerBound)
             throw new IllegalStateException("longitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
 
         // first row in the file is the northernmost one
         // http://gis.stackexchange.com/a/43756/9006
-        int lonSimilar = (int) (width / horizontalDegree * deltaLon);
+        int lonSimilar = (int) (width / degree * deltaLon);
         // different fallback methods for lat and lon as we have different rounding (lon -> positive, lat -> negative)
         if (lonSimilar >= width)
             lonSimilar = width - 1;
-        int latSimilar = height - 1 - (int) (height / verticalDegree * deltaLat);
+        int latSimilar = width - 1 - (int) (width / degree * deltaLat);
         if (latSimilar < 0)
             latSimilar = 0;
 
@@ -112,7 +106,7 @@ public double getHeight(double lat, double lon) {
             if (latSimilar > 0)
                 value += includePoint(daPointer - 2 * width, counter);
 
-            if (latSimilar < height - 1)
+            if (latSimilar < width - 1)
                 value += includePoint(daPointer + 2 * width, counter);
         }
 
@@ -133,13 +127,14 @@ public void toImage(String imageFile) throws IOException {
     }
 
     protected BufferedImage makeARGB() {
+        int height = width;
         BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
         Graphics g = argbImage.getGraphics();
-        long len = width * height;
+        long len = width * width;
         for (int i = 0; i < len; i++) {
             int lonSimilar = i % width;
             // no need for width - y as coordinate system for Graphics is already this way
-            int latSimilar = i / height;
+            int latSimilar = i / width;
             int green = Math.abs(heights.getShort(i * 2));
             if (green == 0) {
                 g.setColor(new Color(255, 0, 0, 255));
@@ -159,7 +154,8 @@ protected BufferedImage makeARGB() {
         return argbImage;
     }
 
-    public BufferedImage getImageFromArray(int[] pixels, int width, int height) {
+    public BufferedImage getImageFromArray(int[] pixels, int width) {
+        int height = width;
         BufferedImage tmpImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
         tmpImage.setRGB(0, 0, width, height, pixels, 0, width);
         return tmpImage;
@@ -169,4 +165,4 @@ public BufferedImage getImageFromArray(int[] pixels, int width, int height) {
     public String toString() {
         return minLat + "," + minLon;
     }
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java
deleted file mode 100644
index 6b7e2e13d4..0000000000
--- a/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.dem;
-
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.util.Helper;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
-import org.apache.xmlgraphics.image.codec.util.SeekableStream;
-
-import java.awt.image.Raster;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * The MultiSourceElevationProvider mixes different elevation providers to provide the best available elevation data
- * for a certain area.
- *
- * @author Robin Boldt
- */
-public class MultiSourceElevationProvider implements ElevationProvider {
-
-    private CGIARProvider cgiarProvider;
-    private GMTEDProvider gmtedProvider;
-
-    public MultiSourceElevationProvider(CGIARProvider cgiarProvider, GMTEDProvider gmtedProvider) {
-        this.cgiarProvider = cgiarProvider;
-        this.gmtedProvider = gmtedProvider;
-    }
-
-    public MultiSourceElevationProvider() {
-        this(new CGIARProvider(), new GMTEDProvider());
-    }
-
-    @Override
-    public double getEle(double lat, double lon) {
-        // Sometimes the cgiar data north of 59.999 equals 0
-        if (lat < 59.999 && lat > -56) {
-            return cgiarProvider.getEle(lat, lon);
-        }
-        return gmtedProvider.getEle(lat, lon);
-    }
-
-    /**
-     * For the MultiSourceElevationProvider you have to specify the base URL separated by a ';'.
-     * The first for cgiar, the second for gmted.
-     */
-    @Override
-    public ElevationProvider setBaseURL(String baseURL) {
-        String[] urls = baseURL.split(";");
-        if (urls.length != 2) {
-            throw new IllegalArgumentException("The base url must consist of two urls separated by a ';'. The first for cgiar, the second for gmted");
-        }
-        cgiarProvider.setBaseURL(urls[0]);
-        gmtedProvider.setBaseURL(urls[1]);
-        return this;
-    }
-
-    @Override
-    public ElevationProvider setCacheDir(File cacheDir) {
-        cgiarProvider.setCacheDir(cacheDir);
-        gmtedProvider.setCacheDir(cacheDir);
-        return this;
-    }
-
-    @Override
-    public ElevationProvider setDAType(DAType daType) {
-        cgiarProvider.setDAType(daType);
-        gmtedProvider.setDAType(daType);
-        return this;
-    }
-
-    @Override
-    public void setCalcMean(boolean calcMean) {
-        cgiarProvider.setCalcMean(calcMean);
-        gmtedProvider.setCalcMean(calcMean);
-    }
-
-    @Override
-    public void release() {
-        cgiarProvider.release();
-        gmtedProvider.release();
-    }
-
-    @Override
-    public String toString() {
-        return "multi";
-    }
-
-}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 74adffd0f6..7c1fc29c16 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -199,11 +199,6 @@ String getFileString(double lat, double lon) {
 
     @Override
     public double getEle(double lat, double lon) {
-        // Return fast, if there is no data available
-        // See https://www2.jpl.nasa.gov/srtm/faq.html
-        if (lat >= 60 || lat <= -56)
-            return 0;
-
         lat = (int) (lat * precision) / precision;
         lon = (int) (lon * precision) / precision;
         int intKey = calcIntKey(lat, lon);
@@ -233,7 +228,7 @@ public double getEle(double lat, double lon) {
         if (width == 0)
             width = DEFAULT_WIDTH;
 
-        demProvider = new HeightTile(down(lat), down(lon), width, width, precision, 1, 1);
+        demProvider = new HeightTile(down(lat), down(lon), width, precision, 1);
         cacheData.put(intKey, demProvider);
         demProvider.setCalcMean(calcMean);
         demProvider.setHeights(heights);
@@ -312,4 +307,4 @@ private Directory getDirectory() {
         logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
         return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
     }
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 6307564897..4278e995b7 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -66,17 +66,13 @@
     private double doublePrevLat, doublePrevLon; // Lat and Lon of node t-2
     private int prevNode;
     private double prevOrientation;
-    private double prevInstructionPrevOrientation = Double.NaN;
     private Instruction prevInstruction;
     private boolean prevInRoundabout;
     private String prevName;
-    private String prevInstructionName;
     private InstructionAnnotation prevAnnotation;
     private EdgeExplorer outEdgeExplorer;
     private EdgeExplorer crossingExplorer;
 
-    private final int MAX_U_TURN_DISTANCE = 35;
-
     public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder, NodeAccess nodeAccess, Translation tr, InstructionList ways) {
         this.weighting = weighting;
         this.encoder = encoder;
@@ -123,10 +119,6 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
         {
             int sign = Instruction.CONTINUE_ON_STREET;
             prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
-            double startLat = nodeAccess.getLat(baseNode);
-            double startLon = nodeAccess.getLon(baseNode);
-            double heading = Helper.ANGLE_CALC.calcAzimuth(startLat, startLon, latitude, longitude);
-            prevInstruction.setExtraInfo("heading", Helper.round(heading, 2));
             ways.add(prevInstruction);
             prevName = name;
             prevAnnotation = annotation;
@@ -138,7 +130,6 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                 int sign = Instruction.USE_ROUNDABOUT;
                 RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
                         annotation, new PointList(10, nodeAccess.is3D()));
-                prevInstructionPrevOrientation = prevOrientation;
                 if (prevName != null) {
                     // check if there is an exit at the same node the roundabout was entered
                     EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
@@ -201,7 +192,6 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                     .setDirOfRotation(deltaOut)
                     .setExited();
 
-            prevInstructionName = prevName;
             prevName = name;
             prevAnnotation = annotation;
 
@@ -209,56 +199,9 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
             int sign = getTurn(edge, baseNode, prevNode, adjNode, annotation, name);
 
             if (sign != Instruction.IGNORE) {
-                /*
-                    Check if the next instruction is likely to only be a short connector to execute a u-turn
-                    --A->--
-                           |    <-- This is the short connector
-                    --B-<--
-                    Road A and Road B have to have the same name and roughly the same, but opposite orientation, otherwise we are assuming this is no u-turn.
-
-                    Note: This approach only works if there a turn instruction fro A->Connector and Connector->B.
-                    Currently we don't create a turn instruction if there is no other possible turn
-                    We only create a u-turn if edge B is a one-way, see #1073 for more details.
-                  */
-
-                boolean isUTurn = false;
-                int uTurnType = Instruction.U_TURN_UNKNOWN;
-                if (!Double.isNaN(prevInstructionPrevOrientation)
-                        && prevInstruction.getDistance() < MAX_U_TURN_DISTANCE
-                        && (sign < 0) == (prevInstruction.getSign() < 0)
-                        && (Math.abs(sign) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(sign) == Instruction.TURN_RIGHT || Math.abs(sign) == Instruction.TURN_SHARP_RIGHT)
-                        && (Math.abs(prevInstruction.getSign()) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_SHARP_RIGHT)
-                        && edge.isForward(encoder) != edge.isBackward(encoder)
-                        && InstructionsHelper.isNameSimilar(prevInstructionName, name)) {
-                    // Chances are good that this is a u-turn, we only need to check if the orientation matches
-                    GHPoint point = InstructionsHelper.getPointForOrientationCalculation(edge, nodeAccess);
-                    double lat = point.getLat();
-                    double lon = point.getLon();
-                    double currentOrientation = Helper.ANGLE_CALC.calcOrientation(prevLat, prevLon, lat, lon, false);
-
-                    double diff = Math.abs(prevInstructionPrevOrientation - currentOrientation);
-                    if (diff > (Math.PI * .9) && diff < (Math.PI * 1.1)) {
-                        isUTurn = true;
-                        if (sign < 0) {
-                            uTurnType = Instruction.U_TURN_LEFT;
-                        } else {
-                            uTurnType = Instruction.U_TURN_RIGHT;
-                        }
-                    }
-
-                }
-
-                if (isUTurn) {
-                    prevInstruction.setSign(uTurnType);
-                    prevInstruction.setName(name);
-                } else {
-                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
-                    // Remember the Orientation and name of the road, before doing this maneuver
-                    prevInstructionPrevOrientation = prevOrientation;
-                    prevInstructionName = prevName;
-                    ways.add(prevInstruction);
-                    prevAnnotation = annotation;
-                }
+                prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                ways.add(prevInstruction);
+                prevAnnotation = annotation;
             }
             // Updated the prevName, since we don't always create an instruction on name changes the previous
             // name can be an old name. This leads to incorrect turn instructions due to name changes
@@ -293,11 +236,7 @@ public void finish() {
             ((RoundaboutInstruction) prevInstruction).setRadian(delta);
 
         }
-
-        Instruction finishInstruction = new FinishInstruction(nodeAccess, prevEdge.getAdjNode());
-        // This is the heading how the edge ended
-        finishInstruction.setExtraInfo("last_heading", Helper.ANGLE_CALC.calcAzimuth(doublePrevLat, doublePrevLon, prevLat, prevLon));
-        ways.add(finishInstruction);
+        ways.add(new FinishInstruction(nodeAccess, prevEdge.getAdjNode()));
     }
 
     private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjNode, InstructionAnnotation annotation, String name) {
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
index b395f6025f..daebfb9543 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
@@ -39,6 +39,9 @@ static int calculateSign(double prevLatitude, double prevLongitude, double latit
         double delta = calculateOrientationDelta(prevLatitude, prevLongitude, latitude, longitude, prevOrientation);
         double absDelta = Math.abs(delta);
 
+        // TODO not only calculate the mathematical orientation, but also compare to other streets
+        // TODO If there is one street turning slight right and one right, but no straight street
+        // TODO We can assume the slight right street would be a continue
         if (absDelta < 0.2) {
             // 0.2 ~= 11°
             return Instruction.CONTINUE_ON_STREET;
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index f4898ea1ae..996b464a39 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -35,7 +35,6 @@
 import java.util.*;
 import java.util.concurrent.*;
 
-import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.CH.DISABLE;
 
 /**
@@ -228,7 +227,7 @@ public CHAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList)
 
         weightingsAsStrings.clear();
         for (String strWeighting : weightingList) {
-            strWeighting = toLowerCase(strWeighting);
+            strWeighting = strWeighting.toLowerCase();
             strWeighting = strWeighting.trim();
             addWeighting(strWeighting);
         }
@@ -283,7 +282,7 @@ public void prepare(final StorableProperties properties) {
         ExecutorCompletionService completionService = new ExecutorCompletionService<>(threadPool);
         int counter = 0;
         for (final PrepareContractionHierarchies prepare : getPreparations()) {
-            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling CH prepare.doWork for " + prepare.getWeighting() + " ... (" + getMemInfo() + ")");
+            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling CH prepare.doWork for " + prepare.getWeighting() + " ... (" + Helper.getMemInfo() + ")");
             final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting());
             completionService.submit(new Runnable() {
                 @Override
@@ -291,7 +290,7 @@ public void run() {
                     // toString is not taken into account so we need to cheat, see http://stackoverflow.com/q/6113746/194609 for other options
                     Thread.currentThread().setName(name);
                     prepare.doWork();
-                    properties.put(CH.PREPARE + "date." + name, createFormatter().format(new Date()));
+                    properties.put(CH.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
                 }
             }, name);
 
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
index 785b95ff76..6ac4991120 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
@@ -44,8 +44,6 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * This class implements the A*, landmark and triangulation (ALT) decorator.
  *
@@ -150,7 +148,7 @@ public LMAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList)
 
         weightingsAsStrings.clear();
         for (String strWeighting : weightingList) {
-            strWeighting = toLowerCase(strWeighting);
+            strWeighting = strWeighting.toLowerCase();
             strWeighting = strWeighting.trim();
             addWeighting(strWeighting);
         }
@@ -284,11 +282,11 @@ public void run() {
                     if (plm.loadExisting())
                         return;
 
-                    LOGGER.info(tmpCounter + "/" + getPreparations().size() + " calling LM prepare.doWork for " + plm.getWeighting() + " ... (" + getMemInfo() + ")");
+                    LOGGER.info(tmpCounter + "/" + getPreparations().size() + " calling LM prepare.doWork for " + plm.getWeighting() + " ... (" + Helper.getMemInfo() + ")");
                     prepared.set(true);
                     Thread.currentThread().setName(name);
                     plm.doWork();
-                    properties.put(Landmark.PREPARE + "date." + name, createFormatter().format(new Date()));
+                    properties.put(Landmark.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
                 }
             }, name);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 4384b64b03..458527582d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -674,8 +674,8 @@ public double getDouble(long flags, int key) {
     }
 
     /**
-     * @param way   needed to retrieve tags
-     * @param speed speed guessed e.g. from the road type or other tags
+     * @param way:   needed to retrieve tags
+     * @param speed: speed guessed e.g. from the road type or other tags
      * @return The assumed speed.
      */
     protected double applyMaxSpeed(ReaderWay way, double speed) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 54a6dcd1cf..54c4cf5a5e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -325,8 +325,8 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
      * just only 90%.
      * <p>
      *
-     * @param way   needed to retrieve tags
-     * @param speed speed guessed e.g. from the road type or other tags
+     * @param way:   needed to retrieve tags
+     * @param speed: speed guessed e.g. from the road type or other tags
      * @return The assumed average speed.
      */
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 1a9d691d5b..21e905b3bf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -335,8 +335,8 @@ public String getWayInfo(ReaderWay way) {
     }
 
     /**
-     * @param way   needed to retrieve tags
-     * @param speed speed guessed e.g. from the road type or other tags
+     * @param way:   needed to retrieve tags
+     * @param speed: speed guessed e.g. from the road type or other tags
      * @return The assumed speed
      */
     protected double applyBadSurfaceSpeed(ReaderWay way, double speed) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index b8ac216e8a..a3b24989dd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -29,8 +29,6 @@
 import java.util.*;
 import java.util.Map.Entry;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * This encoder tries to store all way information into a 32 or 64bit value. Later extendable to
  * multiple ints or bytes. The assumption is that edge.getFlags is cheap and can be later replaced
@@ -428,7 +426,7 @@ private SpatialRule getSpatialRule(ReaderWay way) {
 
     private long extractMeter(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
         String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value)) return flags;
+        if (Helper.isEmpty(value)) return flags;
 
         double val;
         try {
@@ -449,7 +447,7 @@ private long extractMeter(ReaderWay way, long flags, EncodedDoubleValue valueEnc
 
     private long extractTons(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
         String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value)) return flags;
+        if (Helper.isEmpty(value)) return flags;
 
         double val;
         try {
@@ -469,7 +467,7 @@ private long extractTons(ReaderWay way, long flags, EncodedDoubleValue valueEnco
     }
 
     public static double stringToTons(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
+        value = value.toLowerCase().replaceAll(" ", "").replaceAll("(tons|ton)", "t");
         value = value.replace("mgw", "").trim();
         double factor = 1;
         if (value.endsWith("t")) {
@@ -483,7 +481,7 @@ public static double stringToTons(String value) {
     }
 
     public static double stringToMeter(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
+        value = value.toLowerCase().replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
         double factor = 1;
         double offset = 0;
         value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 5dc6fbdccb..682eb585c4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -30,9 +30,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Locale;
-
-import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
@@ -111,14 +108,14 @@ public EncodingManager(List<? extends FlagEncoder> flagEncoders, int bytesForEdg
         if (encoderList.contains(":"))
             throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
 
-        if (!encoderList.equals(toLowerCase(encoderList)))
+        if (!encoderList.equals(encoderList.toLowerCase()))
             throw new IllegalArgumentException("Since 0.7 EncodingManager does no longer accept upper case profiles: " + encoderList);
 
         String[] entries = encoderList.split(",");
         List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
         for (String entry : entries) {
-            entry = toLowerCase(entry.trim());
+            entry = entry.trim().toLowerCase();
             if (entry.isEmpty())
                 continue;
 
@@ -189,26 +186,26 @@ private void registerEncoder(AbstractFlagEncoder encoder) {
         int encoderCount = edgeEncoders.size();
         int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "node"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "relation"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
         // turn flag bits are independent from edge encoder bits
         usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
         if (usedBits > bitsForTurnFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForTurnFlags, "turn"));
+            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForTurnFlags, "turn"));
         nextTurnBit = usedBits;
 
         edgeEncoders.add(encoder);
diff --git a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
index 10950e8f20..314af30c60 100644
--- a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
@@ -19,8 +19,6 @@
 
 import com.graphhopper.util.PMap;
 
-import static com.graphhopper.util.Helper.toLowerCase;
-
 /**
  * @author Peter Karich
  */
@@ -55,7 +53,7 @@ public HintsMap put(String key, Object str) {
     }
 
     public String getWeighting() {
-        return toLowerCase(super.get("weighting", ""));
+        return super.get("weighting", "").toLowerCase();
     }
 
     public HintsMap setWeighting(String w) {
@@ -65,7 +63,7 @@ public HintsMap setWeighting(String w) {
     }
 
     public String getVehicle() {
-        return toLowerCase(super.get("vehicle", ""));
+        return super.get("vehicle", "").toLowerCase();
     }
 
     public HintsMap setVehicle(String v) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
index 530cdbffba..94a5132a06 100644
--- a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
@@ -17,16 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.apache.commons.lang3.StringUtils;
 import com.graphhopper.debatty.java.stringsimilarity.JaroWinkler;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.apache.commons.lang3.StringUtils;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 import java.util.regex.Pattern;
 
-import static com.graphhopper.util.Helper.toLowerCase;
-
 /**
  * This class defines the basis for NameSimilarity matching using an EdgeFilter.
  * The typical use-case is to match not the nearest edge in
@@ -70,7 +67,7 @@ private String prepareName(String name) {
         String tmp;
         List<String> list = new ArrayList<>(arr.length);
         for (int i = 0; i < arr.length; i++) {
-            tmp = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
+            tmp = NON_WORD_CHAR.matcher(arr[i].toLowerCase()).replaceAll("");
             // Ignore matching short frases like, de, rue, st, etc.
             if (!tmp.isEmpty() && tmp.length() > 3) {
                 list.add(tmp);
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index 693ca6a71d..e54ad8532b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -22,8 +22,6 @@
 
 import java.util.Arrays;
 
-import static com.graphhopper.util.Helper.toUpperCase;
-
 /**
  * Defines how the graph can be traversed while Dijkstra or similar RoutingAlgorithm is in progress.
  * Different options define how precise turn restrictions and costs are taken into account, but
@@ -72,7 +70,7 @@
 
     public static TraversalMode fromString(String name) {
         try {
-            return valueOf(toUpperCase(name));
+            return valueOf(name.toUpperCase());
         } catch (Exception ex) {
             throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
                     + "Supported are: " + Arrays.asList(TraversalMode.values()));
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
index 43f227689a..70564e59d3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
@@ -7,11 +7,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static com.graphhopper.util.Helper.toLowerCase;
+import java.util.*;
 
 public class SpatialRuleLookupBuilder {
 
@@ -43,7 +39,7 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
 
         for (int jsonFeatureIdx = 0; jsonFeatureIdx < jsonFeatureCollection.getFeatures().size(); jsonFeatureIdx++) {
             JsonFeature jsonFeature = jsonFeatureCollection.getFeatures().get(jsonFeatureIdx);
-            String id = jsonIdField.isEmpty() || toLowerCase(jsonIdField).equals("id") ? jsonFeature.getId() : (String) jsonFeature.getProperty(jsonIdField);
+            String id = jsonIdField.isEmpty() || jsonIdField.toLowerCase().equals("id") ? jsonFeature.getId() : (String) jsonFeature.getProperty(jsonIdField);
             if (id == null || id.isEmpty())
                 throw new IllegalArgumentException("ID cannot be empty but was for JsonFeature " + jsonFeatureIdx);
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index 3f043952a3..e5572cf992 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -21,8 +21,6 @@
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.EdgeIteratorState;
 
-import static com.graphhopper.util.Helper.toLowerCase;
-
 /**
  * @author Peter Karich
  */
@@ -93,7 +91,7 @@ static final boolean isValidName(String name) {
      * Replaces all characters which are not numbers, characters or underscores with underscores
      */
     public static String weightingToFileName(Weighting w) {
-        return toLowerCase(w.toString()).replaceAll("\\|", "_");
+        return w.toString().toLowerCase().replaceAll("\\|", "_");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index c78735f943..7da8bd52bb 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -599,25 +599,18 @@ public int getMaxId() {
 
         @Override
         public final void setSkippedEdges(int edge1, int edge2) {
-            checkShortcut(true, "setSkippedEdges");
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
-                throw new IllegalStateException("Skipped edges of a shortcut needs "
-                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
-            }
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE2, edge2);
         }
 
         @Override
         public final int getSkippedEdge1() {
-            checkShortcut(true, "getSkippedEdge1");
-            return shortcuts.getInt(edgePointer + S_SKIP_EDGE1);
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE1);
         }
 
         @Override
         public final int getSkippedEdge2() {
-            checkShortcut(true, "getSkippedEdge2");
-            return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
         @Override
@@ -641,13 +634,5 @@ public final double getWeight() {
         public int getMergeStatus(long flags) {
             return PrepareEncoder.getScMergeStatus(getDirectFlags(), flags);
         }
-
-        void checkShortcut(boolean shouldBeShortcut, String methodName) {
-            if (isShortcut()) {
-                if (!shouldBeShortcut)
-                    throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
-            } else if (shouldBeShortcut)
-                throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
-        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index 30266d601a..ec672e7996 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.storage;
 
-import static com.graphhopper.util.Helper.toUpperCase;
-
 /**
  * Defines how a DataAccess object is created.
  * <p>
@@ -74,7 +72,7 @@ public DAType(MemRef memRef, boolean storing, boolean integ, boolean allowWrites
     }
 
     public static DAType fromString(String dataAccess) {
-        dataAccess = toUpperCase(dataAccess);
+        dataAccess = dataAccess.toUpperCase();
         DAType type;
         if (dataAccess.contains("SYNC"))
             throw new IllegalArgumentException("SYNC option is no longer supported, see #982");
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 8d39ace8d2..953985ad91 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -25,8 +25,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * Implements some common methods for the subclasses.
  * <p>
@@ -42,7 +40,7 @@
 
     public GHDirectory(String _location, DAType defaultType) {
         this.defaultType = defaultType;
-        if (isEmpty(_location))
+        if (Helper.isEmpty(_location))
             _location = new File("").getAbsolutePath();
 
         if (!_location.endsWith("/"))
@@ -74,7 +72,7 @@ public ByteOrder getByteOrder() {
     }
 
     public Directory put(String name, DAType type) {
-        if (!name.equals(toLowerCase(name)))
+        if (!name.equals(name.toLowerCase()))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
         types.put(name, type);
@@ -92,7 +90,7 @@ public DataAccess find(String name) {
 
     @Override
     public DataAccess find(String name, DAType type) {
-        if (!name.equals(toLowerCase(name)))
+        if (!name.equals(name.toLowerCase()))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
         DataAccess da = map.get(name);
@@ -137,7 +135,7 @@ public void clear() {
             removeDA(da, da.getName(), false);
         }
         if (mmapDA != null)
-            cleanHack();
+            Helper.cleanHack();
         map.clear();
     }
 
@@ -154,7 +152,7 @@ void removeDA(DataAccess da, String name, boolean forceClean) {
             da.close();
 
         if (da.getType().isStoring())
-            removeDir(new File(location + name));
+            Helper.removeDir(new File(location + name));
     }
 
     void removeFromMap(String name) {
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 1b088e17bb..71597910a1 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -26,8 +26,6 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * Writes an in-memory HashMap into a file on flush. Thread safe, see #743.
  *
@@ -52,7 +50,7 @@ public synchronized boolean loadExisting() {
         byte[] bytes = new byte[len];
         da.getBytes(0, bytes, len);
         try {
-            loadProperties(map, new StringReader(new String(bytes, UTF_CS)));
+            Helper.loadProperties(map, new StringReader(new String(bytes, Helper.UTF_CS)));
             return true;
         } catch (IOException ex) {
             throw new IllegalStateException(ex);
@@ -63,9 +61,9 @@ public synchronized boolean loadExisting() {
     public synchronized void flush() {
         try {
             StringWriter sw = new StringWriter();
-            saveProperties(map, sw);
+            Helper.saveProperties(map, sw);
             // TODO at the moment the size is limited to da.segmentSize() !
-            byte[] bytes = sw.toString().getBytes(UTF_CS);
+            byte[] bytes = sw.toString().getBytes(Helper.UTF_CS);
             da.setBytes(0, bytes, bytes.length);
             da.flush();
         } catch (IOException ex) {
@@ -92,7 +90,7 @@ public synchronized StorableProperties put(String key, String val) {
      * Before it saves this value it creates a string out of it.
      */
     public synchronized StorableProperties put(String key, Object val) {
-        if (!key.equals(toLowerCase(key)))
+        if (!key.equals(key.toLowerCase()))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
         map.put(key, val.toString());
@@ -100,7 +98,7 @@ public synchronized StorableProperties put(String key, Object val) {
     }
 
     public synchronized String get(String key) {
-        if (!key.equals(toLowerCase(key)))
+        if (!key.equals(key.toLowerCase()))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
         String ret = map.get(key);
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index b2c42fee57..b780f0ee74 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -115,7 +115,7 @@ public double calcAzimuth(double lat1, double lon1, double lat2, double lon2) {
         if (orientation < 0)
             orientation += 2 * Math.PI;
 
-        return Math.toDegrees(Helper.round4(orientation)) % 360;
+        return Math.toDegrees(Helper.round4(orientation))%360;
     }
 
     String azimuth2compassPoint(double azimuth) {
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index b25ef1acc9..ebf9ee70d7 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -26,8 +26,6 @@
 import java.util.Map.Entry;
 import java.util.Properties;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
  * <p>
@@ -56,8 +54,8 @@ public static CmdArgs readFromConfig(String fileStr, String systemProperty) thro
             configLocation = fileStr;
 
         Map<String, String> map = new LinkedHashMap<String, String>();
-        loadProperties(map, new InputStreamReader(new FileInputStream(
-                new File(configLocation).getAbsoluteFile()), UTF_CS));
+        Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
+                new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
         CmdArgs args = new CmdArgs();
         args.merge(map);
 
@@ -95,9 +93,9 @@ public static CmdArgs read(String[] args) {
             }
 
             String value = arg.substring(index + 1);
-            String old = map.put(toLowerCase(key), value);
+            String old = map.put(key.toLowerCase(), value);
             if (old != null)
-                throw new IllegalArgumentException("Pair '" + toLowerCase(key) + "'='" + value + "' not possible to " +
+                throw new IllegalArgumentException("Pair '" + key.toLowerCase() + "'='" + value + "' not possible to " +
                         "add to the CmdArgs-object as the key already exists with '" + old + "'");
         }
 
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 942b90db61..b300b1c3e8 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.StringTokenizer;
 
-import static com.graphhopper.util.Helper.*;
+import static com.graphhopper.util.Helper.readFile;
 
 /**
  * Defining several important constants for GraphHopper. Partially taken from Lucene.
@@ -94,7 +94,7 @@
         try {
             // see com/graphhopper/version file in resources which is modified in the maven packaging process
             // to contain the current version
-            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), UTF_CS));
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), Helper.UTF_CS));
             version = v.get(0);
         } catch (Exception ex) {
             System.err.println("GraphHopper Initialization ERROR: cannot read version!? " + ex.getMessage());
@@ -114,12 +114,12 @@
             if (indexM >= 0)
                 tmp = version.substring(0, indexM);
 
-            SNAPSHOT = toLowerCase(version).contains("-snapshot");
+            SNAPSHOT = version.toLowerCase().contains("-snapshot");
             VERSION = tmp;
         }
         String buildDate = "";
         try {
-            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), UTF_CS));
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), Helper.UTF_CS));
             buildDate = v.get(0);
         } catch (Exception ex) {
         }
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 58f6637b4e..901576ec1e 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -88,14 +88,6 @@ public static Locale getLocale(String param) {
         return new Locale(param.substring(0, index), param.substring(index + 1));
     }
 
-    public static String toLowerCase(String string){
-        return string.toLowerCase(Locale.ROOT);
-    }
-
-    public static String toUpperCase(String string){
-        return string.toUpperCase(Locale.ROOT);
-    }
-
     static String packageToPath(Package pkg) {
         return pkg.getName().replaceAll("\\.", File.separator);
     }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 085cb88ba9..28af4c88a7 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,14 +17,12 @@
  */
 package com.graphhopper.util;
 
-import java.util.HashMap;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
 public class Instruction {
     public static final int UNKNOWN = -99;
-    public static final int U_TURN_UNKNOWN = -98;
-    public static final int U_TURN_LEFT = -8;
     public static final int KEEP_LEFT = -7;
     public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
@@ -39,7 +37,6 @@
     public static final int USE_ROUNDABOUT = 6;
     public static final int IGNORE = Integer.MIN_VALUE;
     public static final int KEEP_RIGHT = 7;
-    public static final int U_TURN_RIGHT = 8;
     public static final int PT_START_TRIP = 101;
     public static final int PT_TRANSFER = 102;
     public static final int PT_END_TRIP = 103;
@@ -51,7 +48,6 @@
     protected String name;
     protected double distance;
     protected long time;
-    protected Map<String, Object> extraInfo = new HashMap<>(3);
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
@@ -83,10 +79,6 @@ public int getSign() {
         return sign;
     }
 
-    public void setSign(int sign) {
-        this.sign = sign;
-    }
-
     public String getName() {
         return name;
     }
@@ -96,11 +88,11 @@ public void setName(String name) {
     }
 
     public Map<String, Object> getExtraInfoJSON() {
-        return extraInfo;
+        return Collections.<String, Object>emptyMap();
     }
 
     public void setExtraInfo(String key, Object value) {
-        extraInfo.put(key, value);
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
     }
 
     /**
@@ -278,15 +270,6 @@ public String getTurnDescription(Translation tr) {
         } else {
             String dir = null;
             switch (indi) {
-                case Instruction.U_TURN_UNKNOWN:
-                    dir = tr.tr("u_turn");
-                    break;
-                case Instruction.U_TURN_LEFT:
-                    dir = tr.tr("u_turn");
-                    break;
-                case Instruction.U_TURN_RIGHT:
-                    dir = tr.tr("u_turn");
-                    break;
                 case Instruction.KEEP_LEFT:
                     dir = tr.tr("keep_left");
                     break;
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 91dd0febaf..ec63f393ef 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -174,10 +174,11 @@ private void createWayPointBlock(StringBuilder output, Instruction instruction,
     public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
         DateFormat formatter = Helper.createFormatter();
 
-        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
+        DecimalFormat decimalFormat = new DecimalFormat("#");
         decimalFormat.setMinimumFractionDigits(1);
         decimalFormat.setMaximumFractionDigits(6);
         decimalFormat.setMinimumIntegerDigits(1);
+        decimalFormat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.US));
 
         String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
                 + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 34a04c3810..6712382627 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -21,8 +21,6 @@
 import org.slf4j.LoggerFactory;
 
 import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.util.Locale;
 
 /**
  * @author Peter Karich
@@ -94,7 +92,7 @@ public String getReport() {
     }
 
     public String nf(Number num) {
-        return new DecimalFormat("#.###", DecimalFormatSymbols.getInstance(Locale.ROOT)).format(num);
+        return new DecimalFormat("#.###").format(num);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 4395e0d395..33b3db07ee 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -48,7 +48,6 @@
     private boolean calcPoints = true;
     private PathDetailsBuilderFactory pathBuilderFactory;
     private List<String> requestedPathDetails = Collections.EMPTY_LIST;
-    private double favoredHeading = Double.NaN;
 
     public PathMerger setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
@@ -88,10 +87,6 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         List<String> description = new ArrayList<>();
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
             Path path = paths.get(pathIndex);
-            if (!path.isFound()) {
-                allFound = false;
-                continue;
-            }
             description.addAll(path.getDescription());
             fullTimeInMillis += path.getTime();
             fullDistance += path.getDistance();
@@ -136,10 +131,8 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 calcAscendDescend(altRsp, fullPoints);
         }
 
-        if (enableInstructions) {
-            fullInstructions = updateInstructionsWithContext(fullInstructions);
+        if (enableInstructions)
             altRsp.setInstructions(fullInstructions);
-        }
 
         if (!allFound) {
             altRsp.addError(new ConnectionNotFoundException("Connection between locations not found", Collections.<String, Object>emptyMap()));
@@ -176,51 +169,6 @@ public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDet
         pathDetails.addAll(otherDetails);
     }
 
-    /**
-     * This method iterates over all instructions and uses the available context to improve the instructions.
-     * If the requests contains a heading, this method can transform the first continue to a u-turn if the heading
-     * points into the opposite direction of the route.
-     * At a waypoint it can transform the continue to a u-turn if the route involves turning.
-     */
-    private InstructionList updateInstructionsWithContext(InstructionList instructions) {
-        Instruction instruction;
-        Instruction nextInstruction;
-
-        for (int i = 0; i < instructions.size() - 1; i++) {
-            instruction = instructions.get(i);
-
-            if (i == 0 && !Double.isNaN(favoredHeading) && instruction.extraInfo.containsKey("heading")) {
-                double heading = (double) instruction.extraInfo.get("heading");
-                double diff = Math.abs(heading - favoredHeading) % 360;
-                if (diff > 170 && diff < 190) {
-                    // The requested heading points into the opposite direction of the calculated heading
-                    // therefore we change the continue instruction to a u-turn
-                    instruction.setSign(Instruction.U_TURN_UNKNOWN);
-                }
-            }
-
-            if (instruction.getSign() == Instruction.REACHED_VIA) {
-                nextInstruction = instructions.get(i + 1);
-                if (nextInstruction.getSign() != Instruction.CONTINUE_ON_STREET
-                        || !instruction.extraInfo.containsKey("last_heading")
-                        || !nextInstruction.extraInfo.containsKey("heading")) {
-                    // TODO throw exception?
-                    continue;
-                }
-                double lastHeading = (double) instruction.extraInfo.get("last_heading");
-                double heading = (double) nextInstruction.extraInfo.get("heading");
-
-                // Since it's supposed to go back the same edge, we can be very strict with the diff
-                double diff = Math.abs(lastHeading - heading) % 360;
-                if (diff > 179 && diff < 181) {
-                    nextInstruction.setSign(Instruction.U_TURN_UNKNOWN);
-                }
-            }
-        }
-
-        return instructions;
-    }
-
     private void calcAscendDescend(final PathWrapper rsp, final PointList pointList) {
         double ascendMeters = 0;
         double descendMeters = 0;
@@ -240,8 +188,4 @@ private void calcAscendDescend(final PathWrapper rsp, final PointList pointList)
         rsp.setAscend(ascendMeters);
         rsp.setDescend(descendMeters);
     }
-
-    public void setFavoredHeading(double favoredHeading) {
-        this.favoredHeading = favoredHeading;
-    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/util/PathSimplification.java b/core/src/main/java/com/graphhopper/util/PathSimplification.java
index dc1ea86eee..3a5feb5555 100644
--- a/core/src/main/java/com/graphhopper/util/PathSimplification.java
+++ b/core/src/main/java/com/graphhopper/util/PathSimplification.java
@@ -49,8 +49,7 @@ public PathSimplification(PathWrapper pathWrapper, DouglasPeucker douglasPeucker
         this.pathDetails = pathWrapper.getPathDetails();
         for (String name : pathDetails.keySet()) {
             List<PathDetail> pathDetailList = pathDetails.get(name);
-            // If the pointList only contains one point, PathDetails have to be empty because 1 point => 0 edges
-            if (pathDetailList.isEmpty() && pointList.size() > 1)
+            if (pathDetailList.isEmpty())
                 throw new IllegalStateException("PathDetails " + name + " must not be empty");
 
             listsToSimplify.add(pathDetailList);
@@ -59,7 +58,7 @@ public PathSimplification(PathWrapper pathWrapper, DouglasPeucker douglasPeucker
     }
 
     public PointList simplify() {
-        if (listsToSimplify.isEmpty() || pointList.size() <= 2)
+        if (listsToSimplify.isEmpty() || pointList.isEmpty())
             return pointList;
 
         // The offset of already included points
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index a4dd1d356b..d7511aaa1d 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -265,9 +265,7 @@ public void add(PointList points) {
         size = newSize;
     }
 
-    public void removeLastPoint() {
-        if (size == 0)
-            throw new IllegalStateException("Cannot remove last point from empty PointList");
+    public void removeLastPoint(){
         size--;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 3a890f7bb4..7695d3fb9c 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -21,8 +21,6 @@
 import java.util.*;
 import java.util.Map.Entry;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * A class which manages the translations in-memory. See here for more information:
  * ./docs/core/translations.md
@@ -40,7 +38,7 @@
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     public static int countOccurence(String phrase, String splitter) {
-        if (isEmpty(phrase))
+        if (Helper.isEmpty(phrase))
             return 0;
         return phrase.trim().split(splitter).length;
     }
@@ -51,7 +49,7 @@ public static int countOccurence(String phrase, String splitter) {
     public TranslationMap doImport(File folder) {
         try {
             for (String locale : LOCALES) {
-                TranslationHashMap trMap = new TranslationHashMap(getLocale(locale));
+                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
                 trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
                 add(trMap);
             }
@@ -68,7 +66,7 @@ public TranslationMap doImport(File folder) {
     public TranslationMap doImport() {
         try {
             for (String locale : LOCALES) {
-                TranslationHashMap trMap = new TranslationHashMap(getLocale(locale));
+                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
                 trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
                 add(trMap);
             }
@@ -131,7 +129,7 @@ private void postImportHook() {
             Map<String, String> trMap = tr.asMap();
             for (Entry<String, String> enEntry : enMap.entrySet()) {
                 String value = trMap.get(enEntry.getKey());
-                if (isEmpty(value)) {
+                if (Helper.isEmpty(value)) {
                     trMap.put(enEntry.getKey(), enEntry.getValue());
                     continue;
                 }
@@ -146,7 +144,7 @@ private void postImportHook() {
                     Object[] strs = new String[expectedCount];
                     Arrays.fill(strs, "tmp");
                     try {
-                        String.format(Locale.ROOT, value, strs);
+                        String.format(value, strs);
                     } catch (Exception ex) {
                         sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
                                 append(enEntry.getKey()).append("->").
@@ -191,15 +189,15 @@ public String getLanguage() {
 
         @Override
         public String tr(String key, Object... params) {
-            String val = map.get(toLowerCase(key));
-            if (isEmpty(val))
+            String val = map.get(key.toLowerCase());
+            if (Helper.isEmpty(val))
                 return key;
 
-            return String.format(Locale.ROOT, val, params);
+            return String.format(val, params);
         }
 
         public TranslationHashMap put(String key, String val) {
-            String existing = map.put(toLowerCase(key), val);
+            String existing = map.put(key.toLowerCase(), val);
             if (existing != null)
                 throw new IllegalStateException("Cannot overwrite key " + key + " with " + val + ", was: " + existing);
             return this;
@@ -219,7 +217,7 @@ public TranslationHashMap doImport(InputStream is) {
             if (is == null)
                 throw new IllegalStateException("No input stream found in class path!?");
             try {
-                for (String line : readFile(new InputStreamReader(is, UTF_CS))) {
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS))) {
                     if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
                         continue;
 
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index cf35a22237..6d348bc768 100644
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -31,7 +31,6 @@ public ViaInstruction(Instruction instr) {
         this(instr.getName(), instr.getAnnotation(), instr.getPoints());
         setDistance(instr.getDistance());
         setTime(instr.getTime());
-        this.extraInfo = instr.extraInfo;
     }
 
     @Override
diff --git a/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java
deleted file mode 100644
index 6c72cae7c1..0000000000
--- a/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.dem;
-
-import com.graphhopper.util.Downloader;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.SocketTimeoutException;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Robin Boldt
- */
-public class GMTEDProviderTest {
-    GMTEDProvider instance;
-
-    @Before
-    public void setUp() {
-        instance = new GMTEDProvider();
-    }
-
-    @Test
-    public void testMinLat() {
-        assertEquals(50, instance.getMinLatForTile(52.5));
-        assertEquals(10, instance.getMinLatForTile(29.9));
-        assertEquals(-70, instance.getMinLatForTile(-59.9));
-    }
-
-    @Test
-    public void testMinLon() {
-        assertEquals(-60, instance.getMinLonForTile(-59.9));
-        assertEquals(0, instance.getMinLonForTile(0.9));
-    }
-
-    @Test
-    public void testGetDownloadUrl() {
-        // Created a couple of random tests and compared to https://topotools.cr.usgs.gov/gmted_viewer/viewer.htm
-        assertEquals("E000/30N000E_20101117_gmted_mea075.tif", instance.getDownloadURL(42.940339, 11.953125));
-        assertEquals("W090/30N090W_20101117_gmted_mea075.tif", instance.getDownloadURL(38.548165, -77.167969));
-        assertEquals("W180/70N180W_20101117_gmted_mea075.tif", instance.getDownloadURL(74.116047, -169.277344));
-        assertEquals("W180/70S180W_20101117_gmted_mea075.tif", instance.getDownloadURL(-61.015725, -156.621094));
-        assertEquals("E150/70N150E_20101117_gmted_mea075.tif", instance.getDownloadURL(74.590108, 166.640625));
-        assertEquals("E150/70S150E_20101117_gmted_mea075.tif", instance.getDownloadURL(-61.015725, 162.949219));
-    }
-
-    @Test
-    public void testGetFileName() {
-        assertEquals("30n000e_20101117_gmted_mea075", instance.getFileName(42.940339, 11.953125));
-        assertEquals("30n090w_20101117_gmted_mea075", instance.getFileName(38.548165, -77.167969));
-        assertEquals("70n180w_20101117_gmted_mea075", instance.getFileName(74.116047, -169.277344));
-        assertEquals("70s180w_20101117_gmted_mea075", instance.getFileName(-61.015725, -156.621094));
-        assertEquals("70n150e_20101117_gmted_mea075", instance.getFileName(74.590108, 166.640625));
-        assertEquals("70s150e_20101117_gmted_mea075", instance.getFileName(-61.015725, 162.949219));
-    }
-
-    @Test
-    public void testFileNotFound() {
-        File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
-        File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".tif");
-        file.delete();
-        zipFile.delete();
-
-        instance.setDownloader(new Downloader("test GH") {
-            @Override
-            public void downloadFile(String url, String toFile) throws IOException {
-                throw new FileNotFoundException("xyz");
-            }
-        });
-        assertEquals(0, instance.getEle(46, -20), 1);
-
-        // file not found => small!
-        assertTrue(file.exists());
-        assertEquals(228, file.length());
-
-        instance.setDownloader(new Downloader("test GH") {
-            @Override
-            public void downloadFile(String url, String toFile) throws IOException {
-                throw new SocketTimeoutException("xyz");
-            }
-        });
-
-        try {
-            instance.setSleep(30);
-            instance.getEle(16, -20);
-            assertTrue(false);
-        } catch (Exception ex) {
-        }
-
-        file.delete();
-        zipFile.delete();
-    }
-}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index 8bc1d90b5b..046ff8d5e8 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -32,18 +32,17 @@ public void testGetHeight() {
         // data access has same coordinate system as graphical or UI systems have (or the original DEM data has).
         // But HeightTile has lat,lon system ('mathematically')
         int width = 10;
-        int height = 20;
-        HeightTile instance = new HeightTile(0, 0, width, height, 1e-6, 10, 20);
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10);
         DataAccess heights = new RAMDirectory().find("tmp");
-        heights.create(2 * width * height);
+        heights.create(2 * 10 * 10);
         instance.setHeights(heights);
-        init(heights, width, height, 1);
+        init(heights, width, 1);
 
         // x,y=1,7
-        heights.setShort(2 * (17 * width + 1), (short) 70);
+        heights.setShort(2 * (7 * width + 1), (short) 70);
 
         // x,y=2,9
-        heights.setShort(2 * (19 * width + 2), (short) 90);
+        heights.setShort(2 * (9 * width + 2), (short) 90);
 
         assertEquals(1, instance.getHeight(5, 5), 1e-3);
         assertEquals(70, instance.getHeight(2.5, 1.5), 1e-3);
@@ -51,7 +50,7 @@ public void testGetHeight() {
         assertEquals(1, instance.getHeight(3, 2), 1e-3);
         assertEquals(70, instance.getHeight(2, 1), 1e-3);
 
-        // edge cases for the whole object
+        // edge cases for the whole object        
         assertEquals(1, instance.getHeight(+1.0, 2), 1e-3);
         assertEquals(90, instance.getHeight(0.5, 2.5), 1e-3);
         assertEquals(90, instance.getHeight(0.0, 2.5), 1e-3);
@@ -76,11 +75,11 @@ public void testGetHeight() {
     @Test
     public void testGetHeightForNegativeTile() {
         int width = 10;
-        HeightTile instance = new HeightTile(-20, -20, width, width, 1e-6, 10, 10);
+        HeightTile instance = new HeightTile(-20, -20, width, 1e-6, 10);
         DataAccess heights = new RAMDirectory().find("tmp");
         heights.create(2 * 10 * 10);
         instance.setHeights(heights);
-        init(heights, width, width, 1);
+        init(heights, width, 1);
 
         // x,y=1,7
         heights.setShort(2 * (7 * width + 1), (short) 70);
@@ -98,11 +97,11 @@ public void testGetHeightForNegativeTile() {
     @Test
     public void testCalcMean() {
         int width = 10;
-        HeightTile instance = new HeightTile(0, 0, width, width, 1e-6, 10, 10).setCalcMean(true);
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10).setCalcMean(true);
         DataAccess heights = new RAMDirectory().find("tmp");
         heights.create(2 * 10 * 10);
         instance.setHeights(heights);
-        init(heights, width, width, 1);
+        init(heights, width, 1);
 
         // x,y=0,9
         heights.setShort(2 * (9 * width + 0), (short) 10);
@@ -122,11 +121,11 @@ public void testCalcMean() {
         assertEquals((10 + 2) / 3d, instance.getHeight(-0.5, -0.5), 1e-3);
     }
 
-    private void init(DataAccess da, int width, int height, int i) {
+    private void init(DataAccess da, int width, int i) {
         for (int x = 0; x < width; x++) {
-            for (int y = 0; y < height; y++) {
+            for (int y = 0; y < width; y++) {
                 da.setShort(2 * (y * width + x), (short) 1);
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java
deleted file mode 100644
index e8158db64e..0000000000
--- a/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.dem;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Robin Boldt
- */
-public class MultiSourceElevationProviderTest {
-    MultiSourceElevationProvider instance;
-
-    @Before
-    public void setUp() {
-        instance = new MultiSourceElevationProvider(
-                new CGIARProvider() {
-                    @Override
-                    public double getEle(double lat, double lon) {
-                        return 1;
-                    }
-                },
-                new GMTEDProvider() {
-                    @Override
-                    public double getEle(double lat, double lon) {
-                        return 2;
-                    }
-                }
-        );
-    }
-
-    @Test
-    public void testGetEle() {
-        assertEquals(1, instance.getEle(0, 0), .1);
-        assertEquals(2, instance.getEle(60.0001, 0), .1);
-        assertEquals(2, instance.getEle(-56.0001, 0), .1);
-    }
-}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index fbbb480a43..c2df7a627d 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -597,76 +597,6 @@ public void testCalcInstructionSlightTurn() {
         assertEquals(-1, wayList.get(1).getSign());
     }
 
-    @Test
-    public void testUTurnLeft() {
-        final Graph g = new GraphBuilder(carManager).create();
-        final NodeAccess na = g.getNodeAccess();
-
-        // Real Situation: point=48.402116%2C9.994367&point=48.402198%2C9.99507
-        //       7
-        //       |
-        //  4----5----6
-        //       |
-        //  1----2----3
-        na.setNode(1, 48.402116, 9.994367);
-        na.setNode(2, 48.402198, 9.99507);
-        na.setNode(3, 48.402344, 9.996266);
-        na.setNode(4, 48.402191, 9.994351);
-        na.setNode(5, 48.402298, 9.995053);
-        na.setNode(6, 48.402422, 9.996067);
-        na.setNode(7, 48.402604, 9.994962);
-
-        g.edge(1, 2, 5, false).setName("Olgastraße");
-        g.edge(2, 3, 5, false).setName("Olgastraße");
-        g.edge(6, 5, 5, false).setName("Olgastraße");
-        g.edge(5, 4, 5, false).setName("Olgastraße");
-        g.edge(2, 5, 5, true).setName("Neithardtstraße");
-        g.edge(5, 7, 5, true).setName("Neithardtstraße");
-
-        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
-                .calcPath(1, 4);
-        assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-
-        assertEquals(3, wayList.size());
-        assertEquals(Instruction.U_TURN_LEFT, wayList.get(1).getSign());
-    }
-
-    @Test
-    public void testUTurnRight() {
-        final Graph g = new GraphBuilder(carManager).create();
-        final NodeAccess na = g.getNodeAccess();
-
-        // Real Situation: point=-33.885758,151.181472&point=-33.885692,151.181445
-        //       7
-        //       |
-        //  4----5----6
-        //       |
-        //  3----2----1
-        na.setNode(1, -33.885758,151.181472);
-        na.setNode(2, -33.885852,151.180968);
-        na.setNode(3, -33.885968,151.180501);
-        na.setNode(4, -33.885883,151.180442);
-        na.setNode(5, -33.885772,151.180941);
-        na.setNode(6, -33.885692,151.181445);
-        na.setNode(7, -33.885692,151.181445);
-
-        g.edge(1, 2, 5, false).setName("Parramatta Road");
-        g.edge(2, 3, 5, false).setName("Parramatta Road");
-        g.edge(4, 5, 5, false).setName("Parramatta Road");
-        g.edge(5, 6, 5, false).setName("Parramatta Road");
-        g.edge(2, 5, 5, true).setName("Larkin Street");
-        g.edge(5, 7, 5, true).setName("Larkin Street");
-
-        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
-                .calcPath(1, 6);
-        assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-
-        assertEquals(3, wayList.size());
-        assertEquals(Instruction.U_TURN_RIGHT, wayList.get(1).getSign());
-    }
-
     @Test
     public void testCalcInstructionsForTurn() {
         // The street turns left, but there is not turn
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index acde4d6e42..200806f488 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -344,46 +344,6 @@ public void testSimpleShortcutCreationAndTraversal() {
         assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
     }
 
-    @Test
-    public void testAddShortcutSkippedEdgesWriteRead() {
-        graph = createGHStorage();
-        final EdgeIteratorState edge1 = graph.edge(1, 3, 10, true);
-        final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
-        graph.freeze();
-
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        lg.shortcut(1, 4);
-
-        AllCHEdgesIterator iter = lg.getAllEdges();
-        iter.next();
-        iter.next();
-        iter.next();
-        assertTrue(iter.isShortcut());
-        iter.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
-        assertEquals(edge1.getEdge(), iter.getSkippedEdge1());
-        assertEquals(edge2.getEdge(), iter.getSkippedEdge2());
-    }
-
-    @Test
-    public void testAddShortcutSkippedEdgesWriteRead_writeWithCHEdgeIterator() {
-        graph = createGHStorage();
-        final EdgeIteratorState edge1 = graph.edge(1, 3, 10, true);
-        final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
-        graph.freeze();
-
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        CHEdgeIteratorState shortcut = lg.shortcut(1, 4);
-        shortcut.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
-
-        AllCHEdgesIterator iter = lg.getAllEdges();
-        iter.next();
-        iter.next();
-        iter.next();
-        assertTrue(iter.isShortcut());
-        assertEquals(edge1.getEdge(), iter.getSkippedEdge1());
-        assertEquals(edge2.getEdge(), iter.getSkippedEdge2());
-    }
-
     @Test
     public void testShortcutCreationAndAccessForManyVehicles() {
         FlagEncoder tmpCar = new CarFlagEncoder();
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index 9319b0ff9a..d11f574e1b 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,7 +20,11 @@
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import java.util.Arrays;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
@@ -103,20 +107,10 @@ public void testRemoveLast() {
             list.add(1, i);
         }
         assertEquals(10, list.getSize());
-        assertEquals(9, list.getLon(list.getSize() - 1), .1);
+        assertEquals(9, list.getLon(list.getSize()-1), .1);
         list.removeLastPoint();
         assertEquals(9, list.getSize());
-        assertEquals(8, list.getLon(list.getSize() - 1), .1);
-
-        list = new PointList(20, false);
-        list.add(1, 1);
-        list.removeLastPoint();
-        try {
-            list.removeLastPoint();
-            fail();
-        } catch (Exception ex) {
-        }
-        assertEquals(0, list.getSize());
+        assertEquals(8, list.getLon(list.getSize()-1), .1);
     }
 
     @Test
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
index 349e816816..04532aefd5 100644
--- a/docs/core/elevation.md
+++ b/docs/core/elevation.md
@@ -1,28 +1,29 @@
 # Elevation
 
-Per default elevation is disabled. But you can easily enable it e.g. via
-`graph.elevation.provider=cgiar`. Or use other possibilities `srtm`, `gmted`
-or `multi` (combined cgiar and gmted).
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
 
-Then GraphHopper will automatically download the necessary data for the area and include elevation 
+then GraphHopper will automatically download the necessary data for the area and include elevation 
 for all vehicles - making also the distances a bit more precise. 
 
-The default cache directory `/tmp/<provider name>` will be used. For large areas it is highly recommended to 
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
 use a SSD disc, thus you need to specify the cache directory:
 `graph.elevation.cache_dir=/myssd/ele_cache/`
 
 ## What to download and where to store it? 
 
-All should work automatically but you can tune certain settings like the location where the files are 
-downloaded and e.g. if the servers are not reachable, then you set:
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
 `graph.elevation.base_url`
 
-For CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
 `http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
 where the last one is only accessibly if you specify the 
 [full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
 
-If the geographical area is small and you need a faster import you can change the default MMAP setting to:
+If the area is small and you need a faster import you can change the default MMAP setting to:
 `graph.elevation.dataaccess=RAM_STORE`
 
 ## CGIAR vs. SRTM
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index d5ce068dd3..8d50f43698 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -95,7 +95,7 @@ paths[0].instructions[0].annotation_text      | [optional] A text describing the
 paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
 paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
 paths[0].instructions[0].exited               | [optional] Only available for USE_ROUNDABOUT instructions. True if the roundabout should be exited. False if a via point or end is placed in the roundabout, thus, the roundabout should not be exited due to this instruction.
-paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: `0 < r < 2*PI` for clockwise and `-2PI < r < 0` for counterclockwise transit. `NaN` if the direction of rotation is undefined.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Null if the direction of rotation is undefined.
 
 ```json
 {
diff --git a/pom.xml b/pom.xml
index 13e4e21a9b..7acc855517 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,6 +1,4 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.graphhopper</groupId>
@@ -19,7 +17,6 @@
         <log4j.version>1.2.17</log4j.version>
         <commons-compress.version>1.12</commons-compress.version>
         <jackson.version>2.8.4</jackson.version>
-        <maven.compiler.target>1.8</maven.compiler.target>
 
         <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
         <org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>4</org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>
@@ -95,7 +92,8 @@
                     <compilerArgument>-Xlint:deprecation</compilerArgument>
                     -->
 
-                    <!-- suppress warning about Unsafe functionality -->
+
+                    <!-- suppress warning about Unsafe functionality -->                    
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                     <source>1.7</source>
@@ -170,41 +168,6 @@
                 </configuration>
                 -->
             </plugin>
-            <plugin>
-                <groupId>de.thetaphi</groupId>
-                <artifactId>forbiddenapis</artifactId>
-                <version>2.4.1</version>
-                <configuration>
-                    <!--
-                      if the used Java version is too new,
-                      don't fail, just do nothing:
-                    -->
-                    <failOnUnsupportedJava>false</failOnUnsupportedJava>
-                    <bundledSignatures>
-                        <!--
-                          This will automatically choose the right
-                          signatures based on 'maven.compiler.target':
-                        -->
-                        <bundledSignature>jdk-unsafe</bundledSignature>
-                        <bundledSignature>jdk-deprecated</bundledSignature>
-                        <!-- disallow undocumented classes like sun.misc.Unsafe: -->
-                        <bundledSignature>jdk-non-portable</bundledSignature>
-                    </bundledSignatures>
-                    <excludes>
-                        <!-- Excluded because of "Helper7#getBeanMemInfo" -->
-                        <exclude>
-                            com/graphhopper/util/Helper7.class
-                        </exclude>
-                        <exclude>
-                            com/graphhopper/storage/UnsafeDataAccess.class
-                        </exclude>
-                        <!-- Has a couple of issues with the FileWriter -->
-                        <exclude>
-                            com/graphhopper/tools/Measurement.class
-                        </exclude>
-                    </excludes>
-                </configuration>
-            </plugin>
         </plugins>
     </build>
 
@@ -232,7 +195,7 @@
                 <activeByDefault>false</activeByDefault>
             </activation>
             <!-- this exception is valid for jdk8 profile below too -->
-            <modules>
+            <modules>                
                 <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
                 Currently works for jdk8 only -->
                 <module>reader-shp</module>
@@ -304,14 +267,14 @@
                 <module>android/app</module>
             </modules>
         </profile>
-
+        
         <profile>
             <id>jdk8</id>
             <activation>
                 <activeByDefault>true</activeByDefault>
             </activation>
-            <properties />
-            <modules>
+            <properties/>
+            <modules>                
                 <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
                 Currently works for jdk8 only -->
                 <module>reader-shp</module>
@@ -327,7 +290,7 @@
                 </plugins>
             </build>
         </profile>
-
+        
         <profile>
             <id>jdk9</id>
             <activation>
@@ -339,3 +302,4 @@
     </profiles>
 
 </project>
+
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index d19a18aa74..ec80420efc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -115,7 +115,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             try {
                 initialTime = Instant.parse(departureTimeString);
             } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+                throw new IllegalArgumentException(String.format("Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
             }
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
@@ -280,7 +280,7 @@ public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap,
         this.locationIndex = locationIndex;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
-        this.tripFromLabel = new TripFromLabel(this.gtfsStorage, this.realtimeFeed);
+        this.tripFromLabel = new TripFromLabel(this.gtfsStorage);
     }
 
     public static GtfsStorage createGtfsStorage() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
index bee02ff8eb..45ca525f4c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
@@ -20,7 +20,6 @@
 import java.text.SimpleDateFormat;
 import java.time.LocalDateTime;
 import java.util.Date;
-import java.util.Locale;
 
 /**
  * Generic helper for GTFS routines.
@@ -51,6 +50,6 @@ public static int time(LocalDateTime localDateTime) {
     }
 
     public static LocalDateTime localDateTimeFromDate(Date date) {
-        return LocalDateTime.parse(new SimpleDateFormat("YYYY-MM-dd'T'HH:mm", Locale.ROOT).format(date));
+        return LocalDateTime.parse(new SimpleDateFormat("YYYY-MM-dd'T'HH:mm").format(date));
     }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 6514c8befa..6eef12943f 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -20,13 +20,7 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.Frequency;
-import com.conveyal.gtfs.model.Route;
-import com.conveyal.gtfs.model.Service;
-import com.conveyal.gtfs.model.Stop;
-import com.conveyal.gtfs.model.StopTime;
-import com.conveyal.gtfs.model.Transfer;
-import com.conveyal.gtfs.model.Trip;
+import com.conveyal.gtfs.model.*;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
@@ -45,20 +39,9 @@
 
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.NavigableSet;
-import java.util.Optional;
-import java.util.SortedSet;
-import java.util.TreeSet;
+import java.util.*;
 import java.util.stream.Collectors;
 
-import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 class GtfsReader {
@@ -67,14 +50,14 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay) {
+        public TripWithStopTimes(Trip trip, Iterable<StopTime> stopTimes, BitSet validOnDay) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
         }
 
         Trip trip;
-        List<StopTime> stopTimes;
+        Iterable<StopTime> stopTimes;
         BitSet validOnDay;
     }
 
@@ -139,10 +122,10 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
         this.i = graph.getNodes();
         this.startDate = feed.calculateStats().getStartDate();
         this.endDate = feed.calculateStats().getEndDate();
+        this.gtfsStorage.getFares().putAll(feed.fares);
     }
 
     void readGraph() {
-        gtfsStorage.getFares().putAll(feed.fares);
         buildPtNetwork();
         connectStopsToStreetNetwork();
         connectStopsToStationNodes();
@@ -201,9 +184,7 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
-                        ArrayList<StopTime> stopTimes = new ArrayList<>();
-                        getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
-                        return new TripWithStopTimes(trip, stopTimes, validOnDay);
+                        return new TripWithStopTimes(trip, getInterpolatedStopTimesForTrip(trip.trip_id), validOnDay);
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
                     .collect(Collectors.toList());
@@ -268,10 +249,6 @@ void wireUpStops() {
     void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
         List<Integer> arrivalNodes = new ArrayList<>();
         for (TripWithStopTimes trip : trips) {
-            GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder()
-                    .setTripId(trip.trip.trip_id)
-                    .setStartTime(convertToGtfsTime(time)).build();
-
             IntArrayList boardEdges = new IntArrayList();
             IntArrayList alightEdges = new IntArrayList();
             StopTime prev = null;
@@ -333,7 +310,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
                 boardEdges.add(boardEdge.getEdge());
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
+                gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip.trip_id);
                 boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
                 boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
 
@@ -346,7 +323,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
                 alightEdges.add(alightEdge.getEdge());
                 gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getTripDescriptors().put(alightEdge.getEdge(), tripDescriptor.toByteArray());
+                gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip.trip_id);
                 alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
 //                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
 
@@ -360,10 +337,11 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
                 dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
                 if (prev == null) {
-                    insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validityId);
+                    insertInboundBlockTransfers(arrivalNodes, trip.trip, departureNode, stopTime, stop, validityId);
                 }
                 prev = stopTime;
             }
+            final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
             gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
             gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
             arrivalNodes.add(arrivalNode);
@@ -437,7 +415,7 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
         });
     }
 
-    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, int validityId) {
+    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip, int departureNode, StopTime stopTime, Stop stop, int validityId) {
         EdgeIteratorState edge;
         for (int lastTripArrivalNode : arrivalNodes) {
             int dwellTime = times.get(departureNode) - times.get(lastTripArrivalNode);
@@ -461,7 +439,7 @@ private void insertInboundBlockTransfers(List<Integer> arrivalNodes, GtfsRealtim
                 setEdgeType(edge, GtfsStorage.EdgeType.BOARD);
                 edge.setFlags(encoder.setValidityId(edge.getFlags(), validityId));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getTripDescriptors().put(edge.getEdge(), tripDescriptor.toByteArray());
+                gtfsStorage.getExtraStrings().put(edge.getEdge(), trip.trip_id);
             }
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 7b4ab0ee1c..916af7c6cb 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -93,7 +93,7 @@ public int hashCode() {
 	private Map<Integer, Validity> validities;
 	private Bind.MapWithModificationListener<FeedIdWithTimezone, Integer> timeZones;
 	private Map<Integer, FeedIdWithTimezone> readableTimeZones;
-	private Map<Integer, byte[]> tripDescriptors;
+	private Map<Integer, String> extra;
 	private Map<Integer, Integer> stopSequences;
 	private Map<String, Fare> fares;
 	private Map<GtfsRealtime.TripDescriptor, int[]> boardEdgesForTrip;
@@ -186,7 +186,7 @@ private void init() {
 		Bind.mapInverse(this.timeZones, readableTimeZones);
 		this.readableTimeZones = Collections.unmodifiableMap(readableTimeZones);
 		this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
-		this.tripDescriptors = data.getTreeMap("tripDescriptors");
+		this.extra = data.getTreeMap("extra");
 		this.stopSequences = data.getTreeMap("stopSequences");
 		this.fares = data.getTreeMap("fares");
 		this.boardEdgesForTrip = data.getHashMap("boardEdgesForTrip");
@@ -259,8 +259,8 @@ public long getCapacity() {
 		return timeZones;
 	}
 
-	Map<Integer, byte[]> getTripDescriptors() {
-		return tripDescriptors;
+	Map<Integer, String> getExtraStrings() {
+		return extra;
 	}
 
 	Map<Integer, Integer> getStopSequences() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index a68cd1d6ac..9119b9e35a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -21,7 +21,6 @@
 import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.IntIntHashMap;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.Agency;
 import com.conveyal.gtfs.model.StopTime;
 import com.conveyal.gtfs.model.Trip;
 import com.google.transit.realtime.GtfsRealtime;
@@ -35,53 +34,35 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-import org.mapdb.Fun;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.time.Duration;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+
+import java.time.*;
 import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
 import java.util.List;
-import java.util.Optional;
 import java.util.stream.Collectors;
-import java.util.stream.StreamSupport;
 
-import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 public class RealtimeFeed {
-    private static final Logger logger = LoggerFactory.getLogger(RealtimeFeed.class);
     private final IntHashSet blockedEdges;
+
     private final List<VirtualEdgeIteratorState> additionalEdges;
-    private final GtfsRealtime.FeedMessage feedMessage;
-    private final GTFSFeed staticFeed;
-    private final Agency agency;
-
-    private RealtimeFeed(GTFSFeed feed, Agency agency, GtfsRealtime.FeedMessage feedMessage, IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
-        this.staticFeed = feed;
-        this.agency = agency;
-        this.feedMessage = feedMessage;
+
+    private RealtimeFeed(IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
         this.blockedEdges = blockedEdges;
         this.additionalEdges = additionalEdges;
     }
 
     public static RealtimeFeed empty() {
-        return new RealtimeFeed(null, null, null, new IntHashSet(), Collections.emptyList());
+        return new RealtimeFeed(new IntHashSet(), Collections.emptyList());
     }
 
     public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
-        String feedKey = "gtfs_0";
+        String feedKey = "gtfs_0"; //FIXME
         GTFSFeed feed = staticGtfs.getGtfsFeeds().get(feedKey);
-        // TODO: Require configuration of feed and agency this realtime feed is for.
-        Agency agency = feed.agency.values().iterator().next(); // Realtime feeds are always specific to an agency.
         final IntHashSet blockedEdges = new IntHashSet();
         feedMessage.getEntityList().stream()
             .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -241,7 +222,7 @@ public GraphExtension getExtension() {
         };
         final GtfsReader gtfsReader = new GtfsReader(feedKey, overlayGraph, encoder, null);
         Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
-        LocalDate dateToChange = timestamp.atZone(ZoneId.of(agency.agency_timezone)).toLocalDate(); //FIXME
+        LocalDate dateToChange = timestamp.atZone(ZoneId.of(feed.agency.values().iterator().next().agency_timezone)).toLocalDate(); //FIXME
 
         feedMessage.getEntityList().stream()
                 .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -257,9 +238,9 @@ public GraphExtension getExtension() {
                                 stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
                                 stopTime.stop_id = stopTimeUpdate.getStopId();
                                 stopTime.trip_id = trip.trip_id;
-                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
                                 stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
-                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
                                 stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
                                 return stopTime;
                             })
@@ -269,10 +250,10 @@ public GraphExtension getExtension() {
                     validOnDay.set((int) DAYS.between(startDate, dateToChange));
                     return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
                 })
-                .forEach(trip -> gtfsReader.addTrips(ZoneId.of(agency.agency_timezone), Collections.singletonList(trip), 0));
+                .forEach(trip -> gtfsReader.addTrips(ZoneId.systemDefault(), Collections.singletonList(trip), 0));
         gtfsReader.wireUpStops();
         gtfsReader.connectStopsToStationNodes();
-        return new RealtimeFeed(feed, agency, feedMessage, blockedEdges, additionalEdges);
+        return new RealtimeFeed(blockedEdges, additionalEdges);
     }
 
     boolean isBlocked(int edgeId) {
@@ -283,99 +264,4 @@ boolean isBlocked(int edgeId) {
         return additionalEdges;
     }
 
-    public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GtfsRealtime.TripDescriptor tripDescriptor) {
-        if (feedMessage == null) {
-            return Optional.empty();
-        } else {
-            return feedMessage.getEntityList().stream()
-                    .filter(e -> e.hasTripUpdate())
-                    .map(e -> e.getTripUpdate())
-                    .filter(tu -> tu.getTrip().equals(tripDescriptor))
-                    .map(tu -> toTripWithStopTimes(staticFeed, agency, tu))
-                    .findFirst();
-        }
-    }
-
-    public static GtfsReader.TripWithStopTimes toTripWithStopTimes(GTFSFeed feed, Agency agency, GtfsRealtime.TripUpdate tripUpdate) {
-        logger.trace("{}", tripUpdate.getTrip());
-        final List<StopTime> stopTimes = new ArrayList<>();
-        Trip originalTrip = feed.trips.get(tripUpdate.getTrip().getTripId());
-        Trip trip = new Trip();
-        if (originalTrip != null) {
-            trip.trip_id = originalTrip.trip_id;
-            trip.route_id = originalTrip.route_id;
-        } else {
-            trip.trip_id = tripUpdate.getTrip().getTripId();
-            trip.route_id = tripUpdate.getTrip().getRouteId();
-        }
-        int delay = 0;
-        int time = -1;
-        List<GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdateListWithSentinel = new ArrayList<>(tripUpdate.getStopTimeUpdateList());
-        Iterable<StopTime> interpolatedStopTimesForTrip;
-        try {
-            interpolatedStopTimesForTrip = feed.getInterpolatedStopTimesForTrip(tripUpdate.getTrip().getTripId());
-        } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) {
-            throw new RuntimeException(firstAndLastStopsDoNotHaveTimes);
-        }
-        int stopSequenceCeiling = Math.max(stopTimeUpdateListWithSentinel.isEmpty() ? 0 : stopTimeUpdateListWithSentinel.get(stopTimeUpdateListWithSentinel.size() - 1).getStopSequence(),
-                StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).mapToInt(stopTime -> stopTime.stop_sequence).max().orElse(0)
-        ) + 1;
-        stopTimeUpdateListWithSentinel.add(GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder().setStopSequence(stopSequenceCeiling).setScheduleRelationship(NO_DATA).build());
-        for (GtfsRealtime.TripUpdate.StopTimeUpdate stopTimeUpdate : stopTimeUpdateListWithSentinel) {
-            int nextStopSequence = stopTimes.isEmpty() ? 1 : stopTimes.get(stopTimes.size()-1).stop_sequence+1;
-            for (int i=nextStopSequence; i<stopTimeUpdate.getStopSequence(); i++) {
-                StopTime previousOriginalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), i));
-                if (previousOriginalStopTime == null) {
-                    continue; // This can and does happen. Stop sequence numbers can be left out.
-                }
-                StopTime updatedPreviousStopTime = previousOriginalStopTime.clone();
-                updatedPreviousStopTime.arrival_time = Math.max(previousOriginalStopTime.arrival_time + delay, time);
-                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", i, previousOriginalStopTime.arrival_time, updatedPreviousStopTime.arrival_time);
-                time = updatedPreviousStopTime.arrival_time;
-                updatedPreviousStopTime.departure_time = Math.max(previousOriginalStopTime.departure_time + delay, time);
-                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", i, previousOriginalStopTime.departure_time, updatedPreviousStopTime.departure_time);
-                time = updatedPreviousStopTime.departure_time;
-                stopTimes.add(updatedPreviousStopTime);
-            }
-
-            final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTimeUpdate.getStopSequence()));
-            if (originalStopTime != null) {
-                StopTime updatedStopTime = originalStopTime.clone();
-                if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
-                    delay = 0;
-                }
-                if (stopTimeUpdate.hasArrival()) {
-                    delay = stopTimeUpdate.getArrival().getDelay();
-                }
-                updatedStopTime.arrival_time = Math.max(originalStopTime.arrival_time + delay, time);
-                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopTimeUpdate.getStopSequence(), originalStopTime.arrival_time, updatedStopTime.arrival_time);
-                time = updatedStopTime.arrival_time;
-                if (stopTimeUpdate.hasDeparture()) {
-                    delay = stopTimeUpdate.getDeparture().getDelay();
-                }
-                updatedStopTime.departure_time = Math.max(originalStopTime.departure_time + delay, time);
-                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopTimeUpdate.getStopSequence(), originalStopTime.departure_time, updatedStopTime.departure_time);
-                time = updatedStopTime.departure_time;
-                stopTimes.add(updatedStopTime);
-            } else if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
-            } else if (tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED) {
-                final StopTime stopTime = new StopTime();
-                stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
-                stopTime.stop_id = stopTimeUpdate.getStopId();
-                stopTime.trip_id = trip.trip_id;
-                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
-                stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
-                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
-                stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
-                System.out.println(delay);
-                stopTimes.add(stopTime);
-            } else {
-                throw new RuntimeException();
-            }
-        }
-        BitSet validOnDay = new BitSet(); // Not valid on any day. Just a template.
-        return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
-    }
-
-
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 9afc2f8030..0afaaa4666 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -21,8 +21,6 @@
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Stop;
 import com.conveyal.gtfs.model.StopTime;
-import com.google.protobuf.InvalidProtocolBufferException;
-import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.Trip;
 import com.graphhopper.gtfs.fare.Fares;
@@ -33,8 +31,6 @@
 import com.vividsolutions.jts.geom.Geometry;
 import com.vividsolutions.jts.geom.GeometryFactory;
 import org.mapdb.Fun;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.time.Duration;
 import java.time.Instant;
@@ -44,21 +40,9 @@
 import java.util.stream.Stream;
 
 import static com.graphhopper.reader.gtfs.Label.reverseEdges;
-import static java.time.temporal.ChronoUnit.SECONDS;
 
 class TripFromLabel {
 
-    private static final Logger logger = LoggerFactory.getLogger(TripFromLabel.class);
-
-    private final GtfsStorage gtfsStorage;
-    private final RealtimeFeed realtimeFeed;
-    private final GeometryFactory geometryFactory = new GeometryFactory();
-
-    TripFromLabel(GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
-        this.gtfsStorage = gtfsStorage;
-        this.realtimeFeed = realtimeFeed;
-    }
-
     PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
         final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         return createPathWrapper(tr, waypoints, legs);
@@ -67,11 +51,11 @@ PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Trans
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
-            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).getDepartureTime().getTime() - (accessLeg.getArrivalTime().getTime() - accessLeg.getDepartureTime().getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).getDepartureTime()));
+            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).departureTime.getTime() - (accessLeg.arrivalTime.getTime() - accessLeg.departureTime.getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).departureTime));
         }
         if (legs.size() > 1 && legs.get(legs.size()-1) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg egressLeg = (Trip.WalkLeg) legs.get(legs.size()-1);
-            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size() - 2).getArrivalTime(), egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size() - 2).getArrivalTime().getTime() + (egressLeg.getArrivalTime().getTime() - egressLeg.getDepartureTime().getTime()))));
+            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size()-2).arrivalTime, egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size()-2).arrivalTime.getTime() + (egressLeg.arrivalTime.getTime() - egressLeg.departureTime.getTime()))));
         }
 
         PathWrapper path = new PathWrapper();
@@ -87,7 +71,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         }
         path.setPoints(pointsList);
         path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((legs.get(legs.size() - 1).getArrivalTime().toInstant().toEpochMilli() - legs.get(0).getDepartureTime().toInstant().toEpochMilli()));
+        path.setTime((legs.get(legs.size()-1).arrivalTime.toInstant().toEpochMilli() - legs.get(0).departureTime.toInstant().toEpochMilli()));
         path.setNumChanges((int) path.getLegs().stream()
                 .filter(l -> l instanceof Trip.PtLeg)
                 .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
@@ -98,13 +82,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
                 .map(leg -> (Trip.PtLeg) leg)
                 .findFirst()
                 .ifPresent(firstPtLeg -> {
-                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.getDepartureTime());
+                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
                     path.getLegs().stream()
                             .filter(leg -> leg instanceof Trip.PtLeg)
                             .map(leg -> (Trip.PtLeg) leg)
                             .map(ptLeg -> {
                                 final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feed_id);
-                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.getDepartureTime())).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
+                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
                             })
                             .forEach(faresTrip.segments::add);
                     Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
@@ -191,81 +175,59 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
 
     private class StopsFromBoardHopDwellEdges {
 
-        private final GtfsRealtime.TripDescriptor tripDescriptor;
+        private final String tripId;
         private final List<Trip.Stop> stops = new ArrayList<>();
         private final GTFSFeed gtfsFeed;
-        private Instant arrivalTimeFromHopEdge;
-        private Instant updatedArrival;
-        private StopTime stopTime = null;
-        private final GtfsReader.TripWithStopTimes tripUpdate;
+        private long arrivalTimeFromHopEdge;
+        private Stop stop = null;
 
-        StopsFromBoardHopDwellEdges(String feedId, GtfsRealtime.TripDescriptor tripDescriptor) {
-            this.tripDescriptor = tripDescriptor;
+        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
+            this.tripId = tripId;
             this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
-            this.tripUpdate = realtimeFeed.getTripUpdate(tripDescriptor).orElse(null);
         }
 
         void next(Label.Transition t) {
+            long departureTime;
             switch (t.edge.edgeType) {
-                case BOARD: {
-                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
-                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
-                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
-                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopSequence), SECONDS);
-                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(updatedDeparture)));
+                case BOARD:
+                    stop = findStop(t);
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
                     break;
-                }
-                case HOP: {
-                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
-                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
-                    arrivalTimeFromHopEdge = Instant.ofEpochMilli(t.label.currentTime);
-                    updatedArrival = arrivalTimeFromHopEdge.plus(getArrivalDelay(stopSequence), SECONDS);
+                case HOP:
+                    stop = findStop(t);
+                    arrivalTimeFromHopEdge = t.label.currentTime;
                     break;
-                }
-                case DWELL: {
-                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
-                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopTime.stop_sequence), SECONDS);
-                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), Date.from(updatedDeparture)));
+                case DWELL:
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
                     break;
-                }
-                default: {
+                default:
                     throw new RuntimeException();
-                }
-            }
-        }
-
-        private long getArrivalDelay(int stopSequence) {
-            if (tripUpdate != null) {
-                int arrival_time = tripUpdate.stopTimes.get(stopSequence - 1).arrival_time;
-                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopSequence, stopTime.arrival_time, arrival_time);
-                return arrival_time - stopTime.arrival_time;
-            } else {
-                return 0;
             }
         }
 
-        private int getDepartureDelay(int stopSequence) {
-            if (tripUpdate != null) {
-                int departure_time = tripUpdate.stopTimes.get(stopSequence - 1).departure_time;
-                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopSequence, stopTime.departure_time, departure_time);
-                return departure_time - stopTime.departure_time;
-            } else {
-                return 0;
-            }
+        private Stop findStop(Label.Transition t) {
+            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
+            return gtfsFeed.stops.get(stopTime.stop_id);
         }
 
         void finish() {
-            Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), null));
-            for (Trip.Stop tripStop : stops) {
-                logger.trace("{}", tripStop);
-            }
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
         }
 
     }
 
+
+    private final GtfsStorage gtfsStorage;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
+
+    TripFromLabel(GtfsStorage gtfsStorage) {
+
+        this.gtfsStorage = gtfsStorage;
+    }
+
     // We are parsing a string of edges into a hierarchical trip.
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
@@ -292,28 +254,25 @@ void finish() {
                 }
                 if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
                     Geometry lineString = lineStringFromEdges(partition);
-                    GtfsRealtime.TripDescriptor tripDescriptor;
-                    try {
-                        tripDescriptor = GtfsRealtime.TripDescriptor.parseFrom(gtfsStorage.getTripDescriptors().get(partition.get(0).edge.edgeIteratorState.getEdge()));
-                    } catch (InvalidProtocolBufferException e) {
-                        throw new RuntimeException(e);
-                    }
-                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripDescriptor);
+                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
+                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
                     partition.stream()
                             .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
                             .forEach(stopsFromBoardHopDwellEdges::next);
                     stopsFromBoardHopDwellEdges.finish();
                     List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
 
-                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripDescriptor.getTripId());
+                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
                     result.add(new Trip.PtLeg(
                             feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
-                            tripDescriptor.getTripId(),
+                            tripId,
                             trip.route_id,
                             edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                            new Date(boardTime),
                             stops,
                             partition.stream().mapToDouble(t -> t.edge.distance).sum(),
                             path.get(i-1).label.currentTime - boardTime,
+                            new Date(path.get(i-1).label.currentTime),
                             lineString));
                     partition = null;
                 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 5d5ffbfc73..d94d1419e5 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -182,7 +182,7 @@ public void testRoute1ProfileEarliestArrival() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
@@ -209,7 +209,7 @@ public void testRoute1ProfileLatestDeparture() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "12:44", "12:14", "11:44", "11:14")
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index f0200d359e..676500e16b 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -77,10 +77,10 @@ public void testDepartureTimeOfAccessLeg() {
 
         GHResponse response = graphHopper.route(ghRequest);
 
-        assertThat(response.getAll().get(0).getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+        assertThat(response.getAll().get(0).getLegs().get(0).departureTime.toInstant().atZone(zoneId).toLocalTime())
                 .isEqualTo("06:41:06");
-        assertThat(response.getAll().get(0).getLegs().get(0).getArrivalTime().toInstant())
-                .isEqualTo(response.getAll().get(0).getLegs().get(1).getDepartureTime().toInstant());
+        assertThat(response.getAll().get(0).getLegs().get(0).arrivalTime.toInstant())
+                .isEqualTo(response.getAll().get(0).getLegs().get(1).departureTime.toInstant());
     }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index f8f9297958..47bc982462 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -30,21 +30,14 @@
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
 import static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED;
-import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -58,7 +51,7 @@
     private static LocationIndex locationIndex;
 
     @BeforeClass
-    public static void init() throws InterruptedException {
+    public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
@@ -66,12 +59,6 @@ public static void init() throws InterruptedException {
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
-        graphHopperStorage.close();
-        locationIndex.close();
-        // Re-load read only
-        directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
 
@@ -81,7 +68,6 @@ public static void close() {
         locationIndex.close();
     }
 
-
     @Test
     public void testSkipDepartureStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -175,7 +161,7 @@ public void testSkipTransferStop() {
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
     }
 
-    @Test @Ignore //Pending feature
+    @Test
     public void testExtraTrip() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
@@ -227,122 +213,6 @@ public void testExtraTrip() {
         assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
     }
 
-    @Test
-    public void testZeroDelay() {
-        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
-        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO_LAT, TO_LON
-        );
-
-        // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
-
-        GHResponse responseWithoutRealtimeUpdate = graphHopperFactory.createWithoutRealtimeFeed().route(ghRequest);
-
-        // The 6:00 departure of my line is going to be "late" by 0 minutes
-        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
-                .setGtfsRealtimeVersion("1")
-                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
-
-
-        feedMessageBuilder.addEntityBuilder()
-                .setId("1")
-                .getTripUpdateBuilder()
-                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
-                .addStopTimeUpdateBuilder()
-                .setStopSequence(5)
-                .setScheduleRelationship(SCHEDULED)
-                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(0).build());
-
-        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, responseWithRealtimeUpdate.getAll().size());
-
-        PathWrapper responseWithRealtimeUpdateBest = responseWithRealtimeUpdate.getBest();
-        PathWrapper responseWithoutRealtimeUpdateBest = responseWithoutRealtimeUpdate.getBest();
-        assertEquals("My line run is 0 minutes late, doesn't matter.", time(0, 5), responseWithRealtimeUpdateBest.getTime(), 0.1);
-
-//        assertEquals(responseWithoutRealtimeUpdateBest.toString(), responseWithRealtimeUpdateBest.toString());
-    }
-
-    @Test
-    public void testDelayWithoutTransfer() {
-        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
-        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO_LAT, TO_LON
-        );
-
-        // I want to go at 6:44
-        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
-
-        // The 6:00 departure of my line is going to be late by 3 minutes
-        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
-                .setGtfsRealtimeVersion("1")
-                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
-
-
-        feedMessageBuilder.addEntityBuilder()
-                .setId("1")
-                .getTripUpdateBuilder()
-                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
-                .addStopTimeUpdateBuilder()
-                .setStopSequence(4)
-                .setScheduleRelationship(SCHEDULED)
-                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
-
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, response.getAll().size());
-
-        assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
-    }
-
-
-    @Test
-    public void testDelayFromBeginningWithoutTransfer() {
-        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
-        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO_LAT, TO_LON
-        );
-
-        // I want to go at 6:44
-        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
-
-        // The 6:00 departure of my line is going to be "late" by 0 minutes
-        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
-                .setGtfsRealtimeVersion("1")
-                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
-
-
-        feedMessageBuilder.addEntityBuilder()
-                .setId("1")
-                .getTripUpdateBuilder()
-                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
-                .addStopTimeUpdateBuilder()
-                .setStopSequence(1)
-                .setScheduleRelationship(SCHEDULED)
-                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
-
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, response.getAll().size());
-
-        assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant());
-    }
 
     @Test
     public void testBlockTrips() {
diff --git a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java b/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
index b61a125ec0..004ee0af4a 100644
--- a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
+++ b/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
@@ -21,9 +21,11 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.change.ChangeGraphHelper;
 
-import java.io.*;
-
-import static com.graphhopper.util.Helper.UTF_CS;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FilenameFilter;
+import java.io.Reader;
 
 /**
  * Creates JsonFeature out of files and applies them to the graph.
@@ -49,7 +51,7 @@ public long applyChanges(String fileOrFolderStr) {
         File fileOrFolder = new File(fileOrFolderStr);
         try {
             if (fileOrFolder.isFile()) {
-                return applyChanges(new InputStreamReader(new FileInputStream(fileOrFolder), UTF_CS));
+                return applyChanges(new FileReader(fileOrFolder));
             }
 
             long sum = 0;
@@ -60,7 +62,7 @@ public boolean accept(File dir, String name) {
                 }
             });
             for (File f : fList) {
-                sum += applyChanges(new InputStreamReader(new FileInputStream(f), UTF_CS));
+                sum += applyChanges(new FileReader(f));
             }
             return sum;
 
diff --git a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
index 37c472f385..33cc90ea75 100644
--- a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
+++ b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
@@ -12,17 +12,16 @@
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.FileInputStream;
+import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
 
-import static com.graphhopper.util.Helper.UTF_CS;
-
 /**
  * Helper class to build the spatial rule index
  *
@@ -37,7 +36,7 @@ public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdA
         if (!spatialRuleLocation.isEmpty()) {
             try {
                 final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
-                final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS);
+                final FileReader reader = new FileReader(spatialRuleLocation);
                 final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
                 logger.info("Set spatial rule lookup with " + index.size() + " rules");
                 final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
@@ -59,7 +58,7 @@ public FlagEncoder createFlagEncoder(String name, PMap configuration) {
 
     public static JsonFeatureCollection createLandmarkSplittingFeatureCollection(String location) {
         try {
-            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(location), UTF_CS);
+            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
             return new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
         } catch (IOException e) {
             logger.error("Problem while reading border map GeoJSON. Skipping this.", e);
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index e1ca2b6d7b..c3ecf7b8e5 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -129,35 +129,6 @@ public void testMonacoWithInstructions() throws Exception {
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
-    @Test
-    public void testUTurn() throws Exception {
-        GraphHopper tmpHopper = new GraphHopperOSM().
-                setOSMFile(DIR + "/monaco.osm.gz").
-                setCHEnabled(false).
-                setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
-        tmpHopper.importOrLoad();
-
-        GHRequest request = new GHRequest();
-        //Force initial U-Turn
-        request.addPoint(new GHPoint(43.743887, 7.431151), 200);
-        request.addPoint(new GHPoint(43.744007, 7.431076));
-
-        request.setAlgorithm(ASTAR).setVehicle("car").setWeighting(weightCalcStr);
-        GHResponse rsp = tmpHopper.route(request);
-
-        assertFalse(rsp.hasErrors());
-        PathWrapper arsp = rsp.getBest();
-        InstructionList il = arsp.getInstructions();
-        assertEquals(3, il.size());
-
-        List<Map<String, Object>> resultJson = il.createJson();
-        // Initial U-turn
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
-        // Second U-turn to get to destination
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
-    }
-
     @Test
     public void testAlternativeRoutes() {
         GHRequest req = new GHRequest(43.729057, 7.41251, 43.740298, 7.423561).
@@ -368,7 +339,6 @@ public void testMonacoVia() {
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
 
         assertEquals("Waypoint 1", resultJson.get(20).get("text"));
-        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
 
         assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
         assertEquals("Turn left", resultJson.get(32).get("text"));
@@ -686,7 +656,6 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
         assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
-        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
         assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
         assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
 
@@ -761,7 +730,7 @@ public void testCircularJunctionInstructionsWithCH() {
 
         assertEquals(2, tmpHopper.getCHFactoryDecorator().getPreparations().size());
 
-        GHResponse rsp = tmpHopper.route(new GHRequest(52.513505, 13.350443, 52.513505, 13.350245)
+        GHResponse rsp = tmpHopper.route(new GHRequest(52.513505,13.350443, 52.513505,13.350245)
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
         Instruction instr = rsp.getBest().getInstructions().get(1);
@@ -901,26 +870,6 @@ public void testPathDetails1216() {
         assertFalse(rsp.hasErrors());
     }
 
-    @Test
-    public void testPathDetailsSamePoint() {
-        GraphHopper tmpHopper = new GraphHopperOSM().
-                setOSMFile(DIR + "/north-bayreuth.osm.gz").
-                setCHEnabled(false).
-                setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
-        tmpHopper.importOrLoad();
-
-        GHRequest req = new GHRequest().
-                addPoint(new GHPoint(49.984352, 11.498802)).
-                addPoint(new GHPoint(49.984352, 11.498802)).
-                setVehicle("car").setWeighting("fastest").
-                setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
-
-        GHResponse rsp = tmpHopper.route(req);
-
-        assertFalse(rsp.hasErrors());
-    }
-
     @Test
     public void testFlexMode_631() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 359476b86e..9834b60469 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -486,19 +486,6 @@ public void testNeudrossenfeld() {
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
-    @Test
-    public void testDisconnectedAreaAndMultiplePoints() {
-        List<OneRun> list = new ArrayList<OneRun>();
-        OneRun oneRun = new OneRun();
-        oneRun.add(53.753177, 9.435968, 10, 10);
-        oneRun.add(53.751299, 9.386959, 10, 10);
-        oneRun.add(53.751299, 9.3869, 10, 10);
-        list.add(oneRun);
-
-        runAlgo(testCollector, DIR + "/krautsand.osm.gz", "target/krautsand-gh",
-                list, "car", true, "car", "fastest", true);
-    }
-
     /**
      * @param withCH if true also the CH and LM algorithms will be tested which need
      *               preparation and takes a bit longer
@@ -522,8 +509,6 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
                     setGraphHopperLocation(graphFile).
                     setEncodingManager(new EncodingManager(importVehicles));
 
-            if (osmFile.contains("krautsand"))
-                hopper.setMinNetworkSize(0, 0);
             // avoid that path.getDistance is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
index 70c4d4ed33..00afc556b3 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -42,8 +42,6 @@
 import java.util.HashSet;
 import java.util.List;
 
-import static com.graphhopper.util.Helper.*;
-
 /**
  * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
  * extracts the data as per the structure of shape files
@@ -58,7 +56,7 @@
     private static final String[] DIRECT_COPY_TAGS = new String[]{"name"};
     private File roadsFile;
     private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
-    private final DistanceCalc distCalc = DIST_EARTH;
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
     private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
     private int nextNodeId = FIRST_NODE_ID;
@@ -301,7 +299,7 @@ private void addEdge(int fromTower, int toTower, SimpleFeature road, double dist
             // shapefile.
             // We map back to the standard convention so that tag can be dealt
             // with correctly by the flag encoder.
-            String val = toLowerCase(oneway.toString().trim());
+            String val = oneway.toString().trim().toLowerCase();
             if (val.equals("b")) {
                 // both ways
                 val = "no";
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 7a8de1ac21..7ec739bcea 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -48,7 +48,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 
 /**
@@ -69,7 +68,7 @@ public static void main(String[] strs) {
     void start(CmdArgs args) {
         String graphLocation = args.get("graph.location", "");
         String propLocation = args.get("measurement.location", "");
-        if (isEmpty(propLocation))
+        if (Helper.isEmpty(propLocation))
             propLocation = "measurement" + new SimpleDateFormat("yyyy-MM-dd_HH_mm_ss").format(new Date()) + ".properties";
 
         seed = args.getLong("measurement.seed", 123);
@@ -162,8 +161,8 @@ protected DataReader importData() throws IOException {
             put("measurement.seed", seed);
             put("measurement.time", sw.stop().getTime());
             System.gc();
-            put("measurement.totalMB", getTotalMB());
-            put("measurement.usedMB", getUsedMB());
+            put("measurement.totalMB", Helper.getTotalMB());
+            put("measurement.usedMB", Helper.getUsedMB());
             try {
                 store(new FileWriter(propLocation), "measurement finish, "
                         + new Date().toString() + ", " + Constants.BUILD_DATE);
@@ -184,7 +183,7 @@ private GHBitSet printGraphDetails(GraphHopperStorage g, String vehicleStr) {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getMaxId());
-        put("graph.size_in_MB", g.getCapacity() / MB);
+        put("graph.size_in_MB", g.getCapacity() / Helper.MB);
         put("graph.encoder", vehicleStr);
 
         AllEdgesIterator iter = g.getAllEdges();
@@ -318,7 +317,7 @@ private void compareRouting(final GraphHopper hopper, String vehicle, int count)
 
             String infoStr = " weight:" + lmRsp.getBest().getRouteWeight() + ", original: " + originalRsp.getBest().getRouteWeight()
                     + " distance:" + lmRsp.getBest().getDistance() + ", original: " + originalRsp.getBest().getDistance()
-                    + " time:" + round2(lmRsp.getBest().getTime() / 1000) + ", original: " + round2(originalRsp.getBest().getTime() / 1000)
+                    + " time:" + Helper.round2(lmRsp.getBest().getTime() / 1000) + ", original: " + Helper.round2(originalRsp.getBest().getTime() / 1000)
                     + " points:" + lmRsp.getBest().getPoints().size() + ", original: " + originalRsp.getBest().getPoints().size();
 
             if (Math.abs(1 - lmRsp.getBest().getRouteWeight() / originalRsp.getBest().getRouteWeight()) > 0.000001)
@@ -368,7 +367,7 @@ private void compareCHWithAndWithoutSOD(final GraphHopper hopper, String vehicle
             String infoStr =
                     " weight:" + noSodRsp.getBest().getRouteWeight() + ", original: " + sodRsp.getBest().getRouteWeight()
                             + " distance:" + noSodRsp.getBest().getDistance() + ", original: " + sodRsp.getBest().getDistance()
-                            + " time:" + round2(noSodRsp.getBest().getTime() / 1000) + ", original: " + round2(sodRsp.getBest().getTime() / 1000)
+                            + " time:" + Helper.round2(noSodRsp.getBest().getTime() / 1000) + ", original: " + Helper.round2(sodRsp.getBest().getTime() / 1000)
                             + " points:" + noSodRsp.getBest().getPoints().size() + ", original: " + sodRsp.getBest().getPoints().size();
 
             if (Math.abs(1 - noSodRsp.getBest().getRouteWeight() / sodRsp.getBest().getRouteWeight()) > 0.000001)
@@ -435,7 +434,7 @@ public int doCalc(boolean warmup, int run) {
 
                     if (rsp.getErrors().get(0).getMessage() == null)
                         rsp.getErrors().get(0).printStackTrace();
-                    else if (!toLowerCase(rsp.getErrors().get(0).getMessage()).contains("not found"))
+                    else if (!rsp.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
                         logger.error("errors should NOT happen in Measurement! " + req + " => " + rsp.getErrors());
 
                     return 0;
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
index 3454deb432..bb85d59410 100644
--- a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -108,7 +108,7 @@ private String getMessage(Throwable t) {
 
                 jsonPath.put("snapped_waypoints", createPoints(ar.getWaypoints(), pointsEncoded, includeElevation));
                 if (ar.getFare() != null) {
-                    jsonPath.put("fare", NumberFormat.getCurrencyInstance(Locale.ROOT).format(ar.getFare()));
+                    jsonPath.put("fare", NumberFormat.getCurrencyInstance().format(ar.getFare()));
                 }
                 jsonPathList.add(jsonPath);
             }
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 104617a35b..ccd2d2715f 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -68,6 +68,7 @@ at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).off
 
 },{}],20:[function(require,module,exports){
 L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(t){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter;var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),o=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){var i=a(t.dist);return t.xDiagCoord=i,i}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(o,i.theme),this._initToggle();var r=d3.select(o);r.attr("width",i.width);var n=r.append("svg");n.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(t){return d3.mouse(n.select("g"))[0]}).y(function(t){return this._height()});var l=d3.select(this._container).select("svg").select("g");this._areapath=l.append("path").attr("class","area");var d=this._background=l.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.mobile?(d.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(d.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=l.append("g"),this._yaxisgraphicnode=l.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=l.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),o},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_findItemForLatLng:function(t){var i=null,e=1/0;return this._data.forEach(function(a){var s=t.distanceTo(a.latlng);e>s&&(e=s,i=a)}),i},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.mobile?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,t);i.href="#",i.title=this.options.controlButton.title,L.Browser.mobile?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a;a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"";var s=a.split(".");if(s[1]){for(var o=i-s[1].length;o>0;o--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){var i=this.options;i.imperial?t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){var i=this.options;i.imperial?t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(t,i,e){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),s=this.options,o=this._data[this._findItemForX(a[0])],r=o.altitude,n=o.dist,h=o.latlng,l=s.hoverNumber.formatter(r,s.hoverNumber.decimalsY);s.hoverNumber.formatter(n,s.hoverNumber.decimalsX),this._showDiagramIndicator(o,a[0]);var d=this._map.latLngToLayerPoint(h);if(s.useHeightIndicator){if(!this._mouseHeightFocus){var c=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=c.append("svg:line").attr("class",s.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var _=this._pointG=c.append("g");_.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",s.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=c.append("svg:text").attr("class",s.theme+" height-focus-label").style("pointer-events","none")}var u=this._height()/this._maxElevation*r,g=d.y-u;this._mouseHeightFocus.attr("x1",d.x).attr("x2",d.x).attr("y1",d.y).attr("y2",g).style("visibility","visible"),this._pointG.attr("transform","translate("+d.x+","+d.y+")").style("visibility","visible"),s.imperial?this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(h):this._marker=new L.Marker(h).addTo(this._map)}},_addGeoJSONData:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=new L.LatLng(t[o][1],t[o][0]),n=new L.LatLng(t[o?o-1:0][1],t[o?o-1:0][0]),h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<t[o][2]?t[o][2]:s,e.push({dist:a,altitude:i.imperial?t[o][2]*this.__footFactor:t[o][2],x:t[o][0],y:t[o][1],latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addGPXdata:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=t[o],n=t[o?o-1:0],h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<r.meta.ele?r.meta.ele:s,e.push({dist:a,altitude:i.imperial?r.meta.ele*this.__footFactor:r.meta.ele,x:r.lng,y:r.lat,latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}var a=t&&"FeatureCollection"===t.type;if(a)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t,i){this._addData(t),this._container&&this._applyData(),null===i&&t.on&&(i=t),i&&i.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(t){if(this._data&&0!==this._data.length){var i=t.latlng,e=this._findItemForLatLng(i);if(e){var a=e.xDiagCoord;this._showDiagramIndicator(e,a)}}},_showDiagramIndicator:function(t,i){var e=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",i).attr("y1",0).attr("x2",i).attr("y2",this._height()).classed("hidden",!1);var a=t.altitude,s=t.dist,o=(t.latlng,e.hoverNumber.formatter(a,e.hoverNumber.decimalsY)),r=e.hoverNumber.formatter(s,e.hoverNumber.decimalsX);e.imperial?(this._focuslabelX.attr("x",i).text(o+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" mi")):(this._focuslabelX.attr("x",i).text(o+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" km"))},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
+
 },{}],21:[function(require,module,exports){
 L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number:"",shadowUrl:null,iconSize:new L.Point(25,41),iconAnchor:new L.Point(12,40),popupAnchor:new L.Point(0,-33),shadowSize:new L.Point(50,-64),shadowAnchor:new L.Point(4,-62),className:"leaflet-div-icon"},createIcon:function(){var n=document.createElement("div"),e=this._createImg(this.options.iconUrl),o=document.createElement("div");return o.setAttribute("class","number"),o.innerHTML=this.options.number||"",n.appendChild(e),n.appendChild(o),this._setIconStyles(n,"icon"),n},createShadow:function(){return null}});
 
@@ -79,7 +80,7 @@ function initFromParams(e,t){ghRequest.init(e);var o=new Flatpickr(document.getE
 function adjustMapSize(){var e=$("#map"),t=$(window).width()-280;t<400?(t=400,e.attr("style","position: relative; float: right;")):e.attr("style","position: absolute; right: 0;");var a=$(window).height();a<500&&(a=500),e.width(t).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(e,t,a,n,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:t,index:0},m={text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),icon:"./img/marker-small-red.png",callback:n,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(m,m.index),menuEnd=map.contextmenu.insertItem(s,s.index);var u=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:u}).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={color:"black",weight:2,opacity:.3},c={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(c,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,a){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,a))}function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null,defaultContextmenuItems;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){var t=routingLayer.getLayers();return t.filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,a,n,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),icon:i!==TO?"./img/marker-small-red.png":"./img/marker-small-green.png",callback:i!==TO?a:n,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:i!==-1&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
 
 },{"./config/tileLayers.js":10,"./main-template.js":22,"./translate.js":31}],24:[function(require,module,exports){
-module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-98?"u_turn_unknown":e===-8?"u_turn_left":e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":8===e?"u_turn_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
+module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
 
 },{}],25:[function(require,module,exports){
 function createAmbiguityList(o){o.error="",o.resolvedList=[];var n=3e3;if(o.isResolved()){var r=$.Deferred();return r.resolve([o]),r}if(o.lat&&o.lng){var t=nominatimReverseURL+"?lat="+o.lat+"&lon="+o.lng+"&format=json&zoom=16";return $.ajax({url:t,type:"GET",dataType:"json",timeout:n}).then(function(n){if(!n)return o.error="No description found for coordinate",[o];var r=n.address,t={};return t.lat=o.lat,t.lng=o.lng,t.bbox=n.boundingbox,t.positionType=n.type,t.locationDetails=format.formatLocationEntry(r),o.resolvedList.push(t),[o]},function(n){return console.log("[nominatim_reverse] Error while looking up coordinate lat="+o.lat+"&lon="+o.lng),o.error="Problem while looking up location.",[o]})}return doGeoCoding(o.input,10,n).then(function(n){if(!n||0===n.length)return o.error="No area description found",[o];var r,t=n[0].importance;for(var e in n){var i=n[e];if(t-i.importance>.4)break;if(!r||JSON.stringify(r)!==JSON.stringify(i.address)){r=i.address,t=i.importance;var a={};a.lat=mathTools.round(i.lat),a.lng=mathTools.round(i.lon),a.locationDetails=format.formatLocationEntry(r),a.bbox=i.boundingbox,a.positionType=i.type,o.resolvedList.push(a)}}if(0===o.resolvedList.length)return o.error="No area description found",[o];var s=o.resolvedList;return o.lat=s[0].lat,o.lng=s[0].lng,[o]},function(){return o.error="Problem while looking up address",[o]})}function doGeoCoding(o,n,r){n||(n=10);var t=nominatimURL+"?format=json&addressdetails=1&q="+encodeURIComponent(o)+"&limit="+n;return bounds.initialized&&(t+="&bounded=1&viewbox="+bounds.minLon+","+bounds.maxLat+","+bounds.maxLon+","+bounds.minLat),$.ajax({url:t,type:"GET",dataType:"json",timeout:r}).fail(createCallback("[nominatim] Problem while looking up location "+o))}function createCallback(o){return function(n){console.log(o+" "+JSON.stringify(n))}}function resolve(o,n){var r=$("#locationpoints > div.pointDiv").eq(o);return $(r).find(".pointFlag").hide(),$(r).find(".pointIndicator").show(),$(r).find(".pointInput").val(n.input),createAmbiguityList(n).always(function(){var o=$(r).find(".pointResolveError");return o.empty(),n.error&&(o.show(),o.text(n.error).fadeOut(5e3),n.error=""),$(r).find(".pointIndicator").hide(),$(r).find(".pointFlag").show(),n})}var nominatimURL="https://nominatim.openstreetmap.org/search",nominatimReverseURL="https://nominatim.openstreetmap.org/reverse",bounds,mathTools=require("./tools/math.js"),format=require("./tools/format.js");module.exports.resolve=resolve,module.exports.setBounds=function(o){bounds=o};
diff --git a/web/src/main/webapp/js/messages.js b/web/src/main/webapp/js/messages.js
index fafe236e7b..9fa39c9384 100644
--- a/web/src/main/webapp/js/messages.js
+++ b/web/src/main/webapp/js/messages.js
@@ -15,13 +15,9 @@ module.exports.extractMetaVersionInfo = function (json) {
 };
 
 module.exports.getSignName = function (sign) {
-    if (sign === -98)
-        return "u_turn_unknown";
-    else if (sign === -8)
-        return "u_turn_left";
-    else if (sign === -7)
+    if (sign === -7)
         return "keep_left";
-    else if (sign === -3)
+    if (sign === -3)
         return "sharp_left";
     else if (sign === -2)
         return "left";
@@ -43,8 +39,6 @@ module.exports.getSignName = function (sign) {
         return "roundabout";
     else if (sign === 7)
         return "keep_right";
-    else if (sign === 8)
-        return "u_turn_right";
     else if (sign === 101)
         return "pt_start_trip";
     else if (sign === 102)
@@ -52,7 +46,7 @@ module.exports.getSignName = function (sign) {
     else if (sign === 103)
         return "pt_end_trip";
     else
-    // throw "did not find sign " + sign;
+        // throw "did not find sign " + sign;
         return "unknown";
 };
 
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 0aa9303b83..0891185abc 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -179,17 +179,6 @@ public void testPathDetails() throws Exception {
         assertEquals(expectedTime, actualTime);
     }
 
-    @Test
-    public void testPathDetailsSamePoint() throws Exception {
-        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
-        assertTrue(hopper.load(getTestRouteAPIUrl()));
-        GHRequest request = new GHRequest(42.554851, 1.536198, 42.554851, 1.536198);
-        request.setPathDetails(Arrays.asList("average_speed", "edge_id", "time"));
-        GHResponse rsp = hopper.route(request);
-        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
-    }
-
     @Test
     public void testPathDetailsNoConnection() throws Exception {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
