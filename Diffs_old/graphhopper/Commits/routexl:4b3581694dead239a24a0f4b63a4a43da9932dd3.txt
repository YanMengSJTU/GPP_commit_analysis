diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index b84f185f82..d3095e49bc 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -30,15 +30,15 @@ the <a href="https://graphhopper.com/agreements/individual-cla.html">GraphHopper
 <a href="https://graphhopper.com/agreements/cccoc.html">contributor covenant code of conduct</a>.
 <a href="https://graphhopper.com/#contact">Send us</a> an email with the signed print out of this CLA. Or, if you prefer
 the faster electronically method via signaturit.com, please send us an email with a request for this - 
-keep in mind that this requires storing your Email there. The same applies if you want to sign a CLA for your whole company.
+keep in mind that this requires storing your Email there.
+
+For companies that would like that their developers work for us, we need an additional [corporate CLA signed](https://graphhopper.com/agreements/corporate-cla.html).
 
 Note, our CLA does not influence your rights on your contribution but it makes sure for others that you agree to the Apache License, Version 2.
 After this you'll appear in the <a href="CONTRIBUTORS.md">contributors list</a> and your pull request can also be discussed technically.
 
 Read more in [this issue](https://github.com/graphhopper/graphhopper/pull/1129#issuecomment-375820168) why it is not that easy to make this CLA-signing process simpler for first-time contributors and maintainers.
 
-For companies that would like that their developers work for us, we need an additional [corporate CLA signed](https://graphhopper.com/agreements/corporate-cla.html).
-
 ## Code formatting
 
 We use IntelliJ defaults and a very similar configuration for NetBeans defined in the root pom.xml. For eclipse there is this [configuration](https://github.com/graphhopper/graphhopper/files/481920/GraphHopper.Formatter.zip). Also for other IDEs 
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 0a1e6b68e0..c9e8a55893 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -10,11 +10,13 @@ Here is an overview:
  * AnahitaS, docs for Android, Android, Tomcat
  * andreaswolf, flag encoder versioning and more
  * andreylh, polygon for blocked area #1306
+ * Anvoker, fixes like #1614
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
  * baumboi, path detail and landmark improvements
  * boldtrn, one of the core developers with motorcycle knowledge :)
  * cgarreau, increase of routing success rate via subnetwork cleanup
+ * chollemans, fixes like #1482
  * ChristianSeitzer, motorcycle improvements
  * ChristophKaser, agrees to the project's CLA, improved Android compatibility #1207
  * daisy1754, fixed usage of graphhopper.sh script
@@ -24,7 +26,7 @@ Here is an overview:
  * dos65, bug fixes in routing algo
  * drnextgis, ru translation and JS fixes
  * duongnt, fixes in storage
- * easbar, several improvements on core algorithms
+ * easbar, one of the core developers
  * edy, improvements regarding docker #849
  * elibar, fix for alternative route calculation
  * fbonzon, several UI improvements like #615
@@ -42,20 +44,29 @@ Here is an overview:
  * khuebner, initial turn costs support
  * legraina, improved docker for dockerhub
  * lmar, improved instructions
+ * manueltimita, fixes like #1651
+ * michalmac, fixes like #1467
  * michaz, one of the core developers
  * mprins, improvements for travis CI and regarding JDK9 #806
+ * msb5014, fixes like #1733
+ * njanakiev, fixes like #1560
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
+ * oschlueter, fixes like #1185
+ * otbutz, added multiple EncodedValues
  * PGWelch, shapefile reader #874
  * rajanski, script to do routing via PostGIS
  * ratrun, route relations, GPX information, bike handling etc
  * rodneyodonnell, improved dead end removal (PrepareRoutingSubnetworks) and fords
  * rodo, more descriptions
  * seeebiii, motorcycle improvements
+ * sguill, fixes like #1683
  * stefanholder, Stefan Holder, BMW AG, refactored unfavoring of virtual edges #885
+ * stevensnoeijen, fixes like #1568
  * Svantulden, improved documentation and nearest API
  * thehereward, code cleanups like #620
  * vvikas, ideas for many to many improvements and #616
+ * zstadler, multiple fixes and car4wd
 
 ## Translations
 
diff --git a/README.md b/README.md
index 3f0e6cf633..e3940f777d 100644
--- a/README.md
+++ b/README.md
@@ -48,7 +48,7 @@ like finding and fixing bugs and improving our documentation or translations!
 
 ## For the Web
 
-See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
+See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps) and [install it](./docs/index.md) on your own machine:
 
 [![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
diff --git a/api/src/main/java/com/graphhopper/GHRequest.java b/api/src/main/java/com/graphhopper/GHRequest.java
index cff736a291..b50c6ceb34 100644
--- a/api/src/main/java/com/graphhopper/GHRequest.java
+++ b/api/src/main/java/com/graphhopper/GHRequest.java
@@ -39,6 +39,7 @@
     // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
     private final List<Double> favoredHeadings;
     private List<String> pointHints = new ArrayList<>();
+    private List<String> curbSides = new ArrayList<>();
     private List<String> snapPreventions = new ArrayList<>();
     private List<String> pathDetails = new ArrayList<>();
     private String algo = "";
@@ -255,6 +256,19 @@ public boolean hasPointHints() {
         return pointHints.size() == points.size() && !points.isEmpty();
     }
 
+    public GHRequest setCurbSides(List<String> curbSides) {
+        this.curbSides = curbSides;
+        return this;
+    }
+
+    public List<String> getCurbSides() {
+        return curbSides;
+    }
+
+    public boolean hasCurbSides() {
+        return curbSides.size() == points.size() && !points.isEmpty();
+    }
+
     public GHRequest setSnapPreventions(List<String> snapPreventions) {
         this.snapPreventions = snapPreventions;
         return this;
diff --git a/api/src/main/java/com/graphhopper/util/AngleCalc.java b/api/src/main/java/com/graphhopper/util/AngleCalc.java
index 3bdbbcd14d..195da60320 100644
--- a/api/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/api/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -33,7 +33,7 @@
     private final static double PI_2 = Math.PI / 2.0;
     private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
-    static final double atan2(double y, double x) {
+    static double atan2(double y, double x) {
         // kludge to prevent 0/0 condition
         double absY = Math.abs(y) + 1e-10;
         double r, angle;
@@ -144,4 +144,17 @@ String azimuth2compassPoint(double azimuth) {
         return cp;
     }
 
+    /**
+     * @return true if the given vectors follow a clockwise order abc, bca or cab,
+     * false if the order is counter-clockwise cba, acb or bac, e.g. this returns true:
+     * a   b
+     * | /
+     * 0 - c
+     */
+    public boolean isClockwise(double aX, double aY, double bX, double bY, double cX, double cY) {
+        // simply compare angles between a,b and b,c
+        final double angleDiff = (cX - aX) * (bY - aY) - (cY - aY) * (bX - aX);
+        return angleDiff < 0;
+    }
+
 }
diff --git a/api/src/main/java/com/graphhopper/util/Parameters.java b/api/src/main/java/com/graphhopper/util/Parameters.java
index ffe88aa62c..b8b92d0c81 100644
--- a/api/src/main/java/com/graphhopper/util/Parameters.java
+++ b/api/src/main/java/com/graphhopper/util/Parameters.java
@@ -116,6 +116,8 @@
          */
         public static final String PASS_THROUGH = "pass_through";
         public static final String POINT_HINT = "point_hint";
+        public static final String CURBSIDE = "curbside";
+        public static final String FORCE_CURBSIDE = "force_curbside";
         public static final String SNAP_PREVENTION = "snap_prevention";
         /**
          * default heading penalty in seconds
@@ -129,6 +131,15 @@
         public static final String BLOCK_AREA = "block_area";
     }
 
+    /**
+     * Possible values of {@link Parameters.Routing#CURBSIDE}
+     */
+    public static final class CurbSides {
+        public static final String CURBSIDE_LEFT = "left";
+        public static final String CURBSIDE_RIGHT = "right";
+        public static final String CURBSIDE_ANY = "any";
+    }
+
     /**
      * Properties for routing with contraction hierarchies speedup
      */
diff --git a/api/src/test/java/com/graphhopper/util/AngleCalcTest.java b/api/src/test/java/com/graphhopper/util/AngleCalcTest.java
index c4dca68aef..03ed409706 100644
--- a/api/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/api/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -19,7 +19,8 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
 
 /**
  * @author Johannes Pelzer
@@ -100,7 +101,7 @@ public void testAtan2() {
     }
 
     @Test
-    public void testConvertAzimuth2xaxisAngle() {
+    public void testConvertAzimuth2xAxisAngle() {
         assertEquals(Math.PI / 2, AC.convertAzimuth2xaxisAngle(0), 1E-6);
         assertEquals(Math.PI / 2, Math.abs(AC.convertAzimuth2xaxisAngle(360)), 1E-6);
         assertEquals(0, AC.convertAzimuth2xaxisAngle(90), 1E-6);
@@ -111,7 +112,7 @@ public void testConvertAzimuth2xaxisAngle() {
     }
 
     @Test
-    public void checkAzimuthConsitency() {
+    public void checkAzimuthConsistency() {
         double azimuthDegree = AC.calcAzimuth(0, 0, 1, 1);
         double radianXY = AC.calcOrientation(0, 0, 1, 1);
         double radian2 = AC.convertAzimuth2xaxisAngle(azimuthDegree);
@@ -122,4 +123,31 @@ public void checkAzimuthConsitency() {
         radian2 = AC.convertAzimuth2xaxisAngle(azimuthDegree);
         assertEquals(radianXY, radian2, 1E-3);
     }
+
+    @Test
+    public void testIsClockwise() {
+        Coordinate a = new Coordinate(0.1, 1);
+        Coordinate b = new Coordinate(0.2, 0.8);
+        Coordinate c = new Coordinate(0.6, 0.3);
+        assertTrue(isClockwise(a, b, c));
+        assertTrue(isClockwise(b, c, a));
+        assertTrue(isClockwise(c, a, b));
+        assertFalse(isClockwise(c, b, a));
+        assertFalse(isClockwise(a, c, b));
+        assertFalse(isClockwise(b, a, c));
+    }
+
+    private boolean isClockwise(Coordinate a, Coordinate b, Coordinate c) {
+        return AC.isClockwise(a.x, a.y, b.x, b.y, c.x, c.y);
+    }
+
+    private static class Coordinate {
+        final double x;
+        final double y;
+
+        Coordinate(double x, double y) {
+            this.x = x;
+            this.y = y;
+        }
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index b1ade00fab..d2c7e146c8 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -45,31 +45,17 @@ private void initIgnore() {
 
     @Override
     public MatrixResponse route(GHMRequest ghRequest) {
-        StringBuilder pointHintsStr = new StringBuilder();
-
         String pointsStr;
+        String pointHintsStr;
         if (ghRequest.identicalLists) {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "point");
-
-            for (String hint : ghRequest.getFromPointHints()) {
-                if (pointHintsStr.length() > 0)
-                    pointHintsStr.append("&");
-                pointHintsStr.append("point_hint=").append(encode(hint));
-            }
+            pointHintsStr = createUrlString("point_hint", ghRequest.getFromPointHints());
         } else {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "from_point");
             pointsStr += "&" + createPointQuery(ghRequest.getToPoints(), "to_point");
 
-            for (String hint : ghRequest.getFromPointHints()) {
-                if (pointHintsStr.length() > 0)
-                    pointHintsStr.append("&");
-                pointHintsStr.append("from_point_hint=").append(encode(hint));
-            }
-            for (String hint : ghRequest.getToPointHints()) {
-                if (pointHintsStr.length() > 0)
-                    pointHintsStr.append("&");
-                pointHintsStr.append("to_point_hint=").append(encode(hint));
-            }
+            pointHintsStr = createUrlString("from_point_hint", ghRequest.getFromPointHints());
+            pointHintsStr += "&" + createUrlString("to_point_hint", ghRequest.getToPointHints());
         }
 
         String outArrayStr = "";
@@ -119,6 +105,16 @@ public MatrixResponse route(GHMRequest ghRequest) {
         return matrixResponse;
     }
 
+    private String createUrlString(String paramName, List<String> params) {
+        StringBuilder result = new StringBuilder();
+        for (String param : params) {
+            if (result.length() > 0)
+                result.append("&");
+            result.append(paramName).append('=').append(encode(param));
+        }
+        return result.toString();
+    }
+
     private String createPointQuery(List<GHPoint> list, String pointName) {
         StringBuilder pointsStr = new StringBuilder();
         for (GHPoint p : list) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index cd2f8fb64b..2c19c52df5 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -40,6 +40,7 @@
 
 import static com.graphhopper.util.Helper.round6;
 import static com.graphhopper.util.Helper.toLowerCase;
+import static com.graphhopper.util.Parameters.CurbSides.CURBSIDE_ANY;
 
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient
@@ -253,6 +254,16 @@ private Request createRequest(GHRequest request) {
             }
         }
 
+        // append *all* curbsides only if at least *one* is not CURBSIDE_ANY
+        for (String checkEitherSide : request.getCurbSides()) {
+            if (!checkEitherSide.equals(CURBSIDE_ANY)) {
+                for (String curbSide : request.getCurbSides()) {
+                    url += "&" + Parameters.Routing.CURBSIDE + "=" + WebHelper.encodeURL(curbSide);
+                }
+                break;
+            }
+        }
+
         for (String snapPrevention : request.getSnapPreventions()) {
             url += "&" + Parameters.Routing.SNAP_PREVENTION + "=" + WebHelper.encodeURL(snapPrevention);
         }
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index b88526ff85..e019b54f16 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -157,7 +157,7 @@ public void testConnectionNotFound_doNotFailFast() {
                 } else if (i == 0 && j == 3) {
                     assertTrue(connected);
                     assertEquals(4931, weight, 100);
-                    assertEquals(78643, distance, 100);
+                    assertEquals(78812, distance, 100);
                     assertEquals(3752000, time, 100000);
                 } else if (i == 3 && j == 0) {
                     assertTrue(connected);
diff --git a/config-example.yml b/config-example.yml
index 3b6273de56..d547db8158 100644
--- a/config-example.yml
+++ b/config-example.yml
@@ -17,8 +17,6 @@ graphhopper:
   # If road_environment is added and elevation is enabled then also a tunnel and bridge interpolation is done, see #798.
   # More options are: surface,max_width,max_height,max_weight,max_axle_load,max_length,toll,track_type
   graph.encoded_values: road_class,road_class_link,road_environment,max_speed,road_access
-  # If many flag_encoders or encoded_values are used you need to increase bytes_for_flags to 8 or more (multiple of 4)
-  graph.bytes_for_flags: 4
 
   ##### Elevation #####
 
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 85b0be6ac3..1631be6fd2 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,6 +1,7 @@
 0.14
-    conditional turn restrictions now supported, #1683
     removed PathNative,PathBidirRef,Path4CH,EdgeBasedPathCH and moved path extraction code out of Path class, added PathExtractor,BidirPathExtractor(+subclasses for CH) instead, #1730
+    conditional turn restrictions now supported, #1683
+    added new `curbside` feature, #1697
 
 0.13
     removed docker compose file
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index d98aa3e00f..e82ccdd8f1 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -68,6 +68,7 @@
 import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.*;
+import static com.graphhopper.util.Parameters.Routing.CURBSIDE;
 
 /**
  * Easy to use access point to configure import and (offline) routing.
@@ -512,8 +513,7 @@ public GraphHopper init(CmdArgs args) {
 
         sortGraph = args.getBool("graph.do_sort", sortGraph);
         removeZipped = args.getBool("graph.remove_zipped", removeZipped);
-        int bytesForFlags = args.getInt("graph.bytes_for_flags", 4);
-        EncodingManager.Builder emBuilder = new EncodingManager.Builder(bytesForFlags);
+        EncodingManager.Builder emBuilder = new EncodingManager.Builder();
         String flagEncodersStr = args.get("graph.flag_encoders", "");
         String encodedValueStr = args.get("graph.encoded_values", "");
         if (!flagEncodersStr.isEmpty() || !encodedValueStr.isEmpty()) {
@@ -980,6 +980,10 @@ public GHResponse route(GHRequest request) {
                 throw new IllegalArgumentException("You need a turn cost extension to make use of edge_based=true, e.g. use car|turn_costs=true");
             }
 
+            if (!tMode.isEdgeBased() && !request.getCurbSides().isEmpty()) {
+                throw new IllegalArgumentException("To make use of the " + CURBSIDE + " parameter you need to set " + Routing.EDGE_BASED + " to true");
+            }
+
             boolean disableCH = hints.getBool(CH.DISABLE, false);
             if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
                 throw new IllegalArgumentException("Disabling CH not allowed on the server-side");
@@ -1032,16 +1036,14 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
 
                     if (chAlgoFactory instanceof PrepareContractionHierarchies) {
                         CHProfile chProfile = ((PrepareContractionHierarchies) chAlgoFactory).getCHProfile();
-                        queryGraph = new QueryGraph(ghStorage.getCHGraph(chProfile));
-                        queryGraph.lookup(qResults);
+                        queryGraph = QueryGraph.lookup(ghStorage.getCHGraph(chProfile), qResults);
                         weighting = chProfile.getWeighting();
                     } else {
                         throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
                     }
                 } else {
                     checkNonChMaxWaypointDistance(points);
-                    queryGraph = new QueryGraph(ghStorage);
-                    queryGraph.lookup(qResults);
+                    queryGraph = QueryGraph.lookup(ghStorage, qResults);
                     weighting = createWeighting(hints, encoder, queryGraph);
                 }
                 ghRsp.addDebugInfo("tmode:" + tMode.toString());
@@ -1064,7 +1066,7 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                         build();
 
                 // do the actual route calculation !
-                altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+                altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts, encoder);
 
                 boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
                 boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 8ccdd1b33d..1b0e20f29c 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -72,40 +72,20 @@ public void setVehicleTypeRestricted(String vehicleTypeRestricted) {
         return vehicleTypesExcept;
     }
 
-    public void addVehicleTypesExcept(List<String> vehicleTypesExcept) {
+    public void setVehicleTypesExcept(List<String> vehicleTypesExcept) {
         this.vehicleTypesExcept = vehicleTypesExcept;
     }
 
     /**
      * For a conditional turn restriction, test each vehicle type to verify if it is concerned.
      * For a normal turn restriction (non conditional), the restriction is necessary considered.
-     * @param vehicleTypes
-     * @return
      */
     public boolean isVehicleTypeConcernedByTurnRestriction(List<String> vehicleTypes) {
-        if (vehicleTypeRestricted.isEmpty() && vehicleTypesExcept.isEmpty()) {
-            //normal turn restriction, not dedicated to a vehicle type
-            return true;
-        }
-        for (String vehicleType : vehicleTypes) {
-            if (!vehicleTypeRestricted.isEmpty()) {
-                if (vehicleTypeRestricted.equals(vehicleType)) {
-                    //turn restriction dedicated to vehicleType, for example: restriction:bus = no_left_turn
-                    return true;
-                }
-            }
-            if (!vehicleTypesExcept.isEmpty()) {
-                if (vehicleTypesExcept.contains(vehicleType)) {
-                    //turn restriction except for vehicleType
-                    return false;
-                }
-            }
-        }
-        if (!vehicleTypeRestricted.isEmpty()) {
-            //turn restriction dedicated to a vehicle type not found in vehicleTypes
+        // if the restriction explicitly does not apply for one of the vehicles we do not accept it
+        if (!Collections.disjoint(vehicleTypes, vehicleTypesExcept)) {
             return false;
         }
-        return true;
+        return vehicleTypeRestricted.isEmpty() || vehicleTypes.contains(vehicleTypeRestricted);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderElement.java b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
index 50ca7ac13f..aaf5ff7202 100644
--- a/core/src/main/java/com/graphhopper/reader/ReaderElement.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
@@ -17,13 +17,8 @@
  */
 package com.graphhopper.reader;
 
-import com.graphhopper.util.Helper;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Set;
 
 /**
  * Base class for all network objects
@@ -97,22 +92,14 @@ public String getTag(String name) {
         return val;
     }
 
-    public String getKeyStartsWith(String keyPrefix) {
-        int nbMatchedKeys = 0;
-        String matchedKey = null;
+    public List<String> getKeysWithPrefix(String keyPrefix) {
+        List<String> keys = new ArrayList<>();
         for (String key : properties.keySet()) {
             if (key.startsWith(keyPrefix)) {
-                nbMatchedKeys++;
-                matchedKey = key;
-                if (nbMatchedKeys > 1) {
-                    throw new IllegalArgumentException("Several matched keys found for keyPrefix " + keyPrefix);
-                }
+                keys.add(key);
             }
         }
-        if (nbMatchedKeys == 1) {
-            return matchedKey;
-        }
-        return null;
+        return keys;
     }
 
     public void setTag(String name, Object value) {
@@ -165,7 +152,7 @@ public boolean hasTag(List<String> keyList, Set<String> values) {
         return false;
     }
 
-    public boolean hasTagStartsWith(String keyPrefix) {
+    public boolean hasTagWithKeyPrefix(String keyPrefix) {
         for (String key : properties.keySet()) {
             if (key.startsWith(keyPrefix)) {
                 return true;
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
index 7d4eab92a8..acd8d51da1 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
@@ -44,11 +44,13 @@
     public AbstractBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
         super(graph, weighting, TraversalMode.EDGE_BASED);
         this.turnWeighting = weighting;
+        // the inner explorers will run on the base- (or query/base-)graph edges only
+        Graph baseGraph = graph.getBaseGraph();
         // we need extra edge explorers, because they get called inside a loop that already iterates over edges
-        // important: we have to use different filter ids, otherwise this will not work with QueryGraph's edge explorer
-        // cache, see #1623.
-        innerInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder).setFilterId(1));
-        innerOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder).setFilterId(1));
+        // important: we have to use different filter ids for the edge explorers here than we use for the edge
+        // explorers in the superclass, otherwise this will not work with QueryGraph's edge explorer cache, see #1623.
+        innerInExplorer = baseGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder).setFilterId(1));
+        innerOutExplorer = baseGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder).setFilterId(1));
     }
 
     @Override
@@ -114,7 +116,6 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
             }
         }
 
-        // todo: it would be sufficient (and maybe more efficient) to use an original edge explorer here ?
         EdgeIterator iter = reverse ?
                 innerInExplorer.setBaseNode(edgeState.getAdjNode()) :
                 innerOutExplorer.setBaseNode(edgeState.getAdjNode());
@@ -124,7 +125,7 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
         while (iter.next()) {
             final int edgeId = getOrigEdgeId(iter, !reverse);
             final int prevOrNextOrigEdgeId = getOrigEdgeId(edgeState, reverse);
-            int key = GHUtility.getEdgeKey(graph, edgeId, iter.getBaseNode(), !reverse);
+            int key = GHUtility.createEdgeKey(graph.getOtherNode(edgeId, iter.getBaseNode()), iter.getBaseNode(), edgeId, !reverse);
             SPTEntry entryOther = bestWeightMapOther.get(key);
             if (entryOther == null) {
                 continue;
diff --git a/core/src/main/java/com/graphhopper/routing/DirectionResolver.java b/core/src/main/java/com/graphhopper/routing/DirectionResolver.java
new file mode 100644
index 0000000000..c26ce1eccd
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/DirectionResolver.java
@@ -0,0 +1,288 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.*;
+
+/**
+ * This class is used to determine the pairs of edges that go into/out of a node of the routing graph. Two such pairs
+ * are determined: One pair for the case a given coordinate should be right of a vehicle driving into/out of the node and
+ * one pair for the case where the coordinate is on the left.
+ * <p>
+ * Example:
+ * <p>
+ * .a  x  b
+ * --- o ---
+ * <p>
+ * If the location 'x' should be on the left side the incoming edge would be 'a' and the outgoing edge would be 'b'.
+ * If the location 'x' should be on the right side the incoming edge would be 'b' and the outgoing edge would be 'a'.
+ * <p>
+ * The returned edge IDs can have some special values: we use {@link EdgeIterator#NO_EDGE} to indicate it is
+ * not possible to arrive or leave a location in a certain direction and {@link EdgeIterator#ANY_EDGE} if
+ * there was no clear way to determine an edge id.
+ * <p>
+ * There are a few special cases:
+ * - if it is not possible to determine a clear result, such as for junctions with multiple adjacent edges
+ * we return {@link DirectionResolverResult#unrestricted()}}
+ * - if there is no way to reach or leave a location at all we return {@link DirectionResolverResult#impossible()}
+ * - for locations where the location can only possibly be on the left or right side (such as one-ways we return
+ * {@link DirectionResolverResult#onlyLeft(int, int)} or {@link DirectionResolverResult#onlyRight(int, int)}
+ */
+public class DirectionResolver {
+    private final EdgeExplorer edgeExplorer;
+    private final NodeAccess nodeAccess;
+    private final FlagEncoder encoder;
+
+    public DirectionResolver(Graph graph, FlagEncoder encoder) {
+        edgeExplorer = graph.createEdgeExplorer();
+        nodeAccess = graph.getNodeAccess();
+        this.encoder = encoder;
+    }
+
+    /**
+     * @param node     the node for which the incoming/outgoing edges should be determined
+     * @param location the location next to the road relative to which the 'left' and 'right' side edges should be determined
+     * @see DirectionResolver
+     */
+    public DirectionResolverResult resolveDirections(int node, GHPoint location) {
+        AdjacentEdges adjacentEdges = calcAdjEdges(node);
+        if (adjacentEdges.numNonLoops == 0) {
+            return DirectionResolverResult.impossible();
+        }
+        if (!adjacentEdges.hasInEdges() || !adjacentEdges.hasOutEdges()) {
+            return DirectionResolverResult.impossible();
+        }
+        if (adjacentEdges.nextPoints.isEmpty()) {
+            return DirectionResolverResult.impossible();
+        }
+        if (adjacentEdges.numLoops > 0) {
+            return DirectionResolverResult.unrestricted();
+        }
+        GHPoint snappedPoint = new GHPoint(nodeAccess.getLat(node), nodeAccess.getLon(node));
+        if (adjacentEdges.nextPoints.contains(snappedPoint)) {
+            // this might happen if a pillar node of an adjacent edge has the same coordinates as the snapped point,
+            // but this should be prevented by the map import already
+            throw new IllegalArgumentException("Pillar node of adjacent edge matches snapped point, this should not happen");
+        }
+        // we can classify the different cases by the number of different next points!
+        if (adjacentEdges.nextPoints.size() == 1) {
+            GHPoint neighbor = adjacentEdges.nextPoints.iterator().next();
+            List<Edge> inEdges = adjacentEdges.getInEdges(neighbor);
+            List<Edge> outEdges = adjacentEdges.getOutEdges(neighbor);
+            assert inEdges.size() > 0 && outEdges.size() > 0 : "if there is only one next point there has to be an in edge and an out edge connected with it";
+            // if there are multiple edges going to the (single) next point we cannot return a reasonable result and
+            // leave this point unrestricted
+            if (inEdges.size() > 1 || outEdges.size() > 1) {
+                return DirectionResolverResult.unrestricted();
+            }
+            // since there is only one next point we know this is the end of a dead end street so the right and left
+            // side are treated equally and for both cases we use the only possible edge ids.
+            return DirectionResolverResult.restricted(inEdges.get(0).edgeId, outEdges.get(0).edgeId, inEdges.get(0).edgeId, outEdges.get(0).edgeId);
+        } else if (adjacentEdges.nextPoints.size() == 2) {
+            Iterator<GHPoint> iter = adjacentEdges.nextPoints.iterator();
+            GHPoint p1 = iter.next();
+            GHPoint p2 = iter.next();
+            List<Edge> in1 = adjacentEdges.getInEdges(p1);
+            List<Edge> in2 = adjacentEdges.getInEdges(p2);
+            List<Edge> out1 = adjacentEdges.getOutEdges(p1);
+            List<Edge> out2 = adjacentEdges.getOutEdges(p2);
+            if (in1.size() > 1 || in2.size() > 1 || out1.size() > 1 || out2.size() > 1) {
+                return DirectionResolverResult.unrestricted();
+            }
+            if (in1.size() + in2.size() == 0 || out1.size() + out2.size() == 0) {
+                throw new IllegalStateException("there has to be at least one in and one out edge when there are two next points");
+            }
+            if (in1.size() + out1.size() == 0 || in2.size() + out2.size() == 0) {
+                throw new IllegalStateException("there has to be at least one in or one out edge for each of the two next points");
+            }
+            if (in1.isEmpty() || out2.isEmpty()) {
+                return resolveDirections(snappedPoint, location, in2.get(0), out1.get(0));
+            } else if (in2.isEmpty() || out1.isEmpty()) {
+                return resolveDirections(snappedPoint, location, in1.get(0), out2.get(0));
+            } else {
+                return resolveDirections(snappedPoint, location, in1.get(0), out2.get(0), in2.get(0).edgeId, out1.get(0).edgeId);
+            }
+        } else {
+            // we snapped to a junction, in this case we do not apply restrictions
+            // note: TOWER and PILLAR mostly occur when location is near the end of a dead end street or a sharp
+            // curve, like switchbacks in the mountains of andorra
+            return DirectionResolverResult.unrestricted();
+        }
+    }
+
+    private DirectionResolverResult resolveDirections(GHPoint snappedPoint, GHPoint queryPoint, Edge inEdge, Edge outEdge) {
+        boolean rightLane = isOnRightLane(queryPoint, snappedPoint, inEdge.nextPoint, outEdge.nextPoint);
+        if (rightLane) {
+            return DirectionResolverResult.onlyRight(inEdge.edgeId, outEdge.edgeId);
+        } else {
+            return DirectionResolverResult.onlyLeft(inEdge.edgeId, outEdge.edgeId);
+        }
+    }
+
+    private DirectionResolverResult resolveDirections(GHPoint snappedPoint, GHPoint queryPoint, Edge inEdge, Edge outEdge, int altInEdge, int altOutEdge) {
+        GHPoint inPoint = inEdge.nextPoint;
+        GHPoint outPoint = outEdge.nextPoint;
+        boolean rightLane = isOnRightLane(queryPoint, snappedPoint, inPoint, outPoint);
+        if (rightLane) {
+            return DirectionResolverResult.restricted(inEdge.edgeId, outEdge.edgeId, altInEdge, altOutEdge);
+        } else {
+            return DirectionResolverResult.restricted(altInEdge, altOutEdge, inEdge.edgeId, outEdge.edgeId);
+        }
+    }
+
+    private boolean isOnRightLane(GHPoint queryPoint, GHPoint snappedPoint, GHPoint inPoint, GHPoint outPoint) {
+        double qX = diffLon(snappedPoint, queryPoint);
+        double qY = diffLat(snappedPoint, queryPoint);
+        double iX = diffLon(snappedPoint, inPoint);
+        double iY = diffLat(snappedPoint, inPoint);
+        double oX = diffLon(snappedPoint, outPoint);
+        double oY = diffLat(snappedPoint, outPoint);
+        return !Helper.ANGLE_CALC.isClockwise(iX, iY, oX, oY, qX, qY);
+    }
+
+    private double diffLon(GHPoint p, GHPoint q) {
+        return q.lon - p.lon;
+    }
+
+    private double diffLat(GHPoint p, GHPoint q) {
+        return q.lat - p.lat;
+    }
+
+    private AdjacentEdges calcAdjEdges(int node) {
+        AdjacentEdges adjacentEdges = new AdjacentEdges();
+        EdgeIterator iter = edgeExplorer.setBaseNode(node);
+        while (iter.next()) {
+            // we are not interested in shortcuts here, even if there are shortcuts it is still sufficient to look
+            // at the original edges they begin with
+            if (iter instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) iter).isShortcut()) {
+                continue;
+            }
+            BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+            boolean isIn = iter.getReverse(accessEnc);
+            boolean isOut = iter.get(accessEnc);
+            if (!isIn && !isOut) {
+                continue;
+            }
+            if (iter.getBaseNode() == iter.getAdjNode()) {
+                adjacentEdges.numLoops++;
+            } else {
+                adjacentEdges.numNonLoops++;
+            }
+            // we are interested in the coordinates of the next point on this edge, it could be the adj tower node
+            // but also a pillar node
+            final PointList geometry = iter.fetchWayGeometry(3);
+            double nextPointLat = geometry.getLat(1);
+            double nextPointLon = geometry.getLon(1);
+
+            // todo: special treatment in case the coordinates of the first pillar node equal those of the base tower
+            // node, see #1694
+            if (geometry.size() > 2 && PointList.equalsEps(nextPointLat, geometry.getLat(0)) &&
+                    PointList.equalsEps(nextPointLon, geometry.getLon(0))) {
+                nextPointLat = geometry.getLat(2);
+                nextPointLon = geometry.getLon(2);
+            }
+            GHPoint nextPoint = new GHPoint(nextPointLat, nextPointLon);
+            Edge edge = new Edge(iter.getEdge(), iter.getAdjNode(), nextPoint);
+            adjacentEdges.addEdge(edge, isIn, isOut);
+        }
+        return adjacentEdges;
+    }
+
+    private static class AdjacentEdges {
+        private final Map<GHPoint, List<Edge>> inEdgesByNextPoint = new HashMap<>(2);
+        private final Map<GHPoint, List<Edge>> outEdgesByNextPoint = new HashMap<>(2);
+        final Set<GHPoint> nextPoints = new HashSet<>(2);
+        int numLoops;
+        int numNonLoops;
+
+        void addEdge(Edge edge, boolean isIn, boolean isOut) {
+            if (isIn) {
+                addInEdge(edge);
+            }
+            if (isOut) {
+                addOutEdge(edge);
+            }
+            addNextPoint(edge);
+        }
+
+        List<Edge> getInEdges(GHPoint p) {
+            List<Edge> result = inEdgesByNextPoint.get(p);
+            return result == null ? Collections.<Edge>emptyList() : result;
+        }
+
+        List<Edge> getOutEdges(GHPoint p) {
+            List<Edge> result = outEdgesByNextPoint.get(p);
+            return result == null ? Collections.<Edge>emptyList() : result;
+        }
+
+        boolean hasInEdges() {
+            return !inEdgesByNextPoint.isEmpty();
+        }
+
+        boolean hasOutEdges() {
+            return !outEdgesByNextPoint.isEmpty();
+        }
+
+        private void addOutEdge(Edge edge) {
+            addEdge(outEdgesByNextPoint, edge);
+        }
+
+        private void addInEdge(Edge edge) {
+            addEdge(inEdgesByNextPoint, edge);
+        }
+
+        private void addNextPoint(Edge edge) {
+            nextPoints.add(edge.nextPoint);
+        }
+
+        private void addEdge(Map<GHPoint, List<Edge>> edgesByNextPoint, Edge edge) {
+            List<Edge> edges = edgesByNextPoint.get(edge.nextPoint);
+            if (edges == null) {
+                edges = new ArrayList<>(2);
+                edges.add(edge);
+                edgesByNextPoint.put(edge.nextPoint, edges);
+            } else {
+                edges.add(edge);
+            }
+        }
+    }
+
+    private static class Edge {
+        final int edgeId;
+        final int adjNode;
+        /**
+         * the next point of this edge, not necessarily the point corresponding to adjNode, but often this is the
+         * next pillar (!) node.
+         */
+        final GHPoint nextPoint;
+
+        Edge(int edgeId, int adjNode, GHPoint nextPoint) {
+            this.edgeId = edgeId;
+            this.adjNode = adjNode;
+            this.nextPoint = nextPoint;
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/DirectionResolverResult.java b/core/src/main/java/com/graphhopper/routing/DirectionResolverResult.java
new file mode 100644
index 0000000000..b6403a42a3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/DirectionResolverResult.java
@@ -0,0 +1,155 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import java.util.Objects;
+
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+import static com.graphhopper.util.Parameters.CurbSides.*;
+import static com.graphhopper.util.Parameters.Routing.CURBSIDE;
+
+public class DirectionResolverResult {
+    private static DirectionResolverResult UNRESTRICTED = new DirectionResolverResult(ANY_EDGE, ANY_EDGE, ANY_EDGE, ANY_EDGE);
+    private static DirectionResolverResult IMPOSSIBLE = new DirectionResolverResult(NO_EDGE, NO_EDGE, NO_EDGE, NO_EDGE);
+
+    private final int inEdgeRight;
+    private final int outEdgeRight;
+    private final int inEdgeLeft;
+    private final int outEdgeLeft;
+
+    public static DirectionResolverResult onlyLeft(int inEdge, int outEdge) {
+        return new DirectionResolverResult(NO_EDGE, NO_EDGE, inEdge, outEdge);
+    }
+
+    public static DirectionResolverResult onlyRight(int inEdge, int outEdge) {
+        return new DirectionResolverResult(inEdge, outEdge, NO_EDGE, NO_EDGE);
+    }
+
+    public static DirectionResolverResult restricted(int inEdgeRight, int outEdgeRight, int inEdgeLeft, int outEdgeLeft) {
+        return new DirectionResolverResult(inEdgeRight, outEdgeRight, inEdgeLeft, outEdgeLeft);
+    }
+
+    public static DirectionResolverResult unrestricted() {
+        return UNRESTRICTED;
+    }
+
+    public static DirectionResolverResult impossible() {
+        return IMPOSSIBLE;
+    }
+
+    private DirectionResolverResult(int inEdgeRight, int outEdgeRight, int inEdgeLeft, int outEdgeLeft) {
+        this.inEdgeRight = inEdgeRight;
+        this.outEdgeRight = outEdgeRight;
+        this.inEdgeLeft = inEdgeLeft;
+        this.outEdgeLeft = outEdgeLeft;
+    }
+
+    public static int getOutEdge(DirectionResolverResult directionResolverResult, String curbSide) {
+        if (curbSide.trim().isEmpty()) {
+            curbSide = CURBSIDE_ANY;
+        }
+        switch (curbSide) {
+            case CURBSIDE_RIGHT:
+                return directionResolverResult.getOutEdgeRight();
+            case CURBSIDE_LEFT:
+                return directionResolverResult.getOutEdgeLeft();
+            case CURBSIDE_ANY:
+                return ANY_EDGE;
+            default:
+                throw new IllegalArgumentException("Unknown value for " + CURBSIDE + " : '" + curbSide + "'. allowed: " + CURBSIDE_LEFT + ", " + CURBSIDE_RIGHT + ", " + CURBSIDE_ANY);
+        }
+    }
+
+    public static int getInEdge(DirectionResolverResult directionResolverResult, String curbSide) {
+        if (curbSide.trim().isEmpty()) {
+            curbSide = CURBSIDE_ANY;
+        }
+        switch (curbSide) {
+            case CURBSIDE_RIGHT:
+                return directionResolverResult.getInEdgeRight();
+            case CURBSIDE_LEFT:
+                return directionResolverResult.getInEdgeLeft();
+            case CURBSIDE_ANY:
+                return ANY_EDGE;
+            default:
+                throw new IllegalArgumentException("Unknown value for '" + CURBSIDE + " : " + curbSide + "'. allowed: " + CURBSIDE_LEFT + ", " + CURBSIDE_RIGHT + ", " + CURBSIDE_ANY);
+        }
+    }
+
+    public int getInEdgeRight() {
+        return inEdgeRight;
+    }
+
+    public int getOutEdgeRight() {
+        return outEdgeRight;
+    }
+
+    public int getInEdgeLeft() {
+        return inEdgeLeft;
+    }
+
+    public int getOutEdgeLeft() {
+        return outEdgeLeft;
+    }
+
+    public boolean isRestricted() {
+        return !equals(UNRESTRICTED);
+    }
+
+    public boolean isImpossible() {
+        return equals(IMPOSSIBLE);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        DirectionResolverResult that = (DirectionResolverResult) o;
+        return inEdgeRight == that.inEdgeRight &&
+                outEdgeRight == that.outEdgeRight &&
+                inEdgeLeft == that.inEdgeLeft &&
+                outEdgeLeft == that.outEdgeLeft;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(inEdgeRight, outEdgeRight, inEdgeLeft, outEdgeLeft);
+    }
+
+    @Override
+    public String toString() {
+        if (!isRestricted()) {
+            return "unrestricted";
+        } else if (isImpossible()) {
+            return "impossible";
+        } else {
+            return "in-edge-right: " + pretty(inEdgeRight) + ", out-edge-right: " + pretty(outEdgeRight) + ", in-edge-left: " + pretty(inEdgeLeft) + ", out-edge-left: " + pretty(outEdgeLeft);
+        }
+    }
+
+    private String pretty(int edgeId) {
+        if (edgeId == NO_EDGE) {
+            return "NO_EDGE";
+        } else if (edgeId == ANY_EDGE) {
+            return "ANY_EDGE";
+        } else {
+            return edgeId + "";
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 2c1511405e..646b3a5b2c 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -145,6 +145,12 @@ public double getEle(int nodeId) {
 
     private boolean useEdgeExplorerCache = false;
 
+    public static QueryGraph lookup(Graph graph, List<QueryResult> queryResults) {
+        QueryGraph result = new QueryGraph(graph);
+        result.lookup(queryResults);
+        return result;
+    }
+
     public QueryGraph(Graph graph) {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
diff --git a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
index ddd3f66bf3..e9d8878ec2 100644
--- a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
@@ -59,12 +59,12 @@ public AlternativeRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, Locatio
     }
 
     @Override
-    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts, FlagEncoder encoder) {
         boolean withViaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
         if (withViaTurnPenalty)
             throw new IllegalArgumentException("Alternative paths and " + PASS_THROUGH + " at the same time is currently not supported");
 
-        return super.calcPaths(queryGraph, algoFactory, algoOpts);
+        return super.calcPaths(queryGraph, algoFactory, algoOpts, encoder);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index 82ad1044a2..cdb3cf5fb2 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -108,7 +108,7 @@ void setQueryResults(List<QueryResult> queryResults) {
     }
 
     @Override
-    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts, FlagEncoder encoder) {
         pathList = new ArrayList<>(queryResults.size() - 1);
 
         AvoidEdgesWeighting avoidPathWeighting = new AvoidEdgesWeighting(algoOpts.getWeighting());
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
index a3a073fa96..e2e43ecf44 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
@@ -45,7 +45,7 @@
      * This method returns a list of Path objects which then can be merged to serve one route with
      * via points or multiple alternative paths.
      */
-    List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts);
+    List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts, FlagEncoder encoder);
 
     /**
      * This method merges the returned paths appropriately e.g. all paths from the list into one
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index bf6c7cdaab..a28edf407f 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -35,8 +35,12 @@
 import com.graphhopper.util.shapes.GHPoint;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+
 /**
  * Implementation of calculating a route with multiple via points.
  *
@@ -87,14 +91,25 @@ else if (ghRequest.hasSnapPreventions())
     }
 
     @Override
-    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts, FlagEncoder encoder) {
         long visitedNodesSum = 0L;
-        boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
-        int pointCounts = ghRequest.getPoints().size();
-        pathList = new ArrayList<>(pointCounts - 1);
+        final boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
+        final int pointsCount = ghRequest.getPoints().size();
+        pathList = new ArrayList<>(pointsCount - 1);
+
+        List<DirectionResolverResult> directions = Collections.emptyList();
+        if (!ghRequest.getCurbSides().isEmpty()) {
+            DirectionResolver directionResolver = new DirectionResolver(queryGraph, encoder);
+            directions = new ArrayList<>(queryResults.size());
+            for (QueryResult qr : queryResults) {
+                directions.add(directionResolver.resolveDirections(qr.getClosestNode(), qr.getQueryPoint()));
+            }
+        }
+
+        final boolean forceCurbSides = ghRequest.getHints().getBool(Routing.FORCE_CURBSIDE, true);
         QueryResult fromQResult = queryResults.get(0);
         StopWatch sw;
-        for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
+        for (int placeIndex = 1; placeIndex < pointsCount; placeIndex++) {
             if (placeIndex == 1) {
                 // enforce start direction
                 queryGraph.enforceHeading(fromQResult.getClosestNode(), ghRequest.getFavoredHeading(0), false);
@@ -119,7 +134,23 @@ else if (ghRequest.hasSnapPreventions())
             sw = new StopWatch().start();
 
             // calculate paths
-            List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            List<Path> tmpPathList;
+            if (!directions.isEmpty()) {
+                assert ghRequest.getCurbSides().size() == directions.size();
+                if (!(algo instanceof AbstractBidirAlgo)) {
+                    throw new IllegalArgumentException("To make use of the " + Routing.CURBSIDE + " parameter you need a bidirectional algorithm, got: " + algo.getName());
+                } else {
+                    int sourceOutEdge = DirectionResolverResult.getOutEdge(directions.get(placeIndex - 1), ghRequest.getCurbSides().get(placeIndex - 1));
+                    int targetInEdge = DirectionResolverResult.getInEdge(directions.get(placeIndex), ghRequest.getCurbSides().get(placeIndex));
+                    sourceOutEdge = ignoreThrowOrAcceptImpossibleCurbSides(sourceOutEdge, placeIndex - 1, forceCurbSides);
+                    targetInEdge = ignoreThrowOrAcceptImpossibleCurbSides(targetInEdge, placeIndex, forceCurbSides);
+                    // todo: enable curbside feature for alternative routes as well ?
+                    tmpPathList = Collections.singletonList(((AbstractBidirAlgo) algo)
+                            .calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode(), sourceOutEdge, targetInEdge));
+                }
+            } else {
+                tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            }
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s";
             if (tmpPathList.isEmpty())
                 throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
@@ -148,11 +179,26 @@ else if (ghRequest.hasSnapPreventions())
         }
 
         ghResponse.getHints().put("visited_nodes.sum", visitedNodesSum);
-        ghResponse.getHints().put("visited_nodes.average", (float) visitedNodesSum / (pointCounts - 1));
+        ghResponse.getHints().put("visited_nodes.average", (float) visitedNodesSum / (pointsCount - 1));
 
         return pathList;
     }
 
+    private int ignoreThrowOrAcceptImpossibleCurbSides(int edge, int placeIndex, boolean forceCurbSides) {
+        if (edge != NO_EDGE) {
+            return edge;
+        }
+        if (forceCurbSides) {
+            return throwImpossibleCurbSideConstraint(placeIndex);
+        } else {
+            return ANY_EDGE;
+        }
+    }
+
+    private int throwImpossibleCurbSideConstraint(int placeIndex) {
+        throw new IllegalArgumentException("Impossible curbside constraint: 'curbside=" + ghRequest.getCurbSides().get(placeIndex) + "' at point " + placeIndex);
+    }
+
     @Override
     public boolean isReady(PathMerger pathMerger, Translation tr) {
         if (ghRequest.getPoints().size() - 1 != pathList.size())
@@ -168,4 +214,5 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
     public int getMaxRetries() {
         return 1;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 49f73f583a..bb70eda981 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -189,10 +189,7 @@ protected double getSpeed(ReaderWay way) {
 
     @Override
     public boolean acceptsTurnRelation(OSMTurnRelation relation) {
-        if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
-            return true;
-        }
-        return false;
+        return relation.isVehicleTypeConcernedByTurnRestriction(restrictions);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index e7b36598dd..e11e6c297c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -118,10 +118,7 @@ public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
 
     @Override
     public boolean acceptsTurnRelation(OSMTurnRelation relation) {
-        if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
-            return true;
-        }
-        return false;
+        return relation.isVehicleTypeConcernedByTurnRestriction(restrictions);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index f22885e73e..2eac436e45 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
@@ -48,12 +47,11 @@
  * @author Nop
  */
 public class EncodingManager implements EncodedValueLookup {
-    private static final String ERR = "Encoders are requesting %s bits, more than %s bits of %s flags. ";
+    private static final int BITS_FOR_TURN_FLAGS = 8 * 4;
+
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<>();
     private final Map<String, EncodedValue> encodedValueMap = new LinkedHashMap<>();
     private final List<TagParser> tagParserList = new ArrayList<>();
-    private final int bitsForEdgeFlags;
-    private final int bitsForTurnFlags = 8 * 4;
     private int nextNodeBit = 0;
     private int nextRelBit = 0;
     private int nextTurnBit = 0;
@@ -69,19 +67,11 @@
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
     public static EncodingManager create(String flagEncodersStr) {
-        return create(flagEncodersStr, 4);
-    }
-
-    public static EncodingManager create(String flagEncodersStr, int bytesForEdgeFlags) {
-        return create(new DefaultFlagEncoderFactory(), flagEncodersStr, bytesForEdgeFlags);
-    }
-
-    public static EncodingManager create(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
-        return createBuilder(factory, flagEncodersStr, bytesForEdgeFlags).build();
+        return create(new DefaultFlagEncoderFactory(), flagEncodersStr);
     }
 
-    public static EncodingManager.Builder createBuilder(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
-        return createBuilder(parseEncoderString(factory, flagEncodersStr), bytesForEdgeFlags);
+    public static EncodingManager create(FlagEncoderFactory factory, String flagEncodersStr) {
+        return createBuilder(parseEncoderString(factory, flagEncodersStr)).build();
     }
 
     /**
@@ -99,15 +89,11 @@ public static EncodingManager create(FlagEncoder... flagEncoders) {
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
     public static EncodingManager create(List<? extends FlagEncoder> flagEncoders) {
-        return create(flagEncoders, 4);
-    }
-
-    public static EncodingManager create(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
-        return createBuilder(flagEncoders, bytesForEdgeFlags).build();
+        return createBuilder(flagEncoders).build();
     }
 
-    private static EncodingManager.Builder createBuilder(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
-        Builder builder = new Builder(bytesForEdgeFlags);
+    private static EncodingManager.Builder createBuilder(List<? extends FlagEncoder> flagEncoders) {
+        Builder builder = new Builder();
         for (FlagEncoder flagEncoder : flagEncoders) {
             builder.add(flagEncoder);
         }
@@ -125,13 +111,7 @@ public static EncodingManager create(EncodedValueFactory evFactory, FlagEncoderF
             throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
                     + dir.getLocation());
 
-        int bytesForFlags = 4;
-        try {
-            bytesForFlags = Integer.parseInt(properties.get("graph.bytes_for_flags"));
-        } catch (NumberFormatException ex) {
-        }
-
-        EncodingManager.Builder builder = new EncodingManager.Builder(bytesForFlags, false);
+        EncodingManager.Builder builder = new EncodingManager.Builder(false);
         String encodedValuesStr = properties.get("graph.encoded_values");
         if (!Helper.isEmpty(encodedValuesStr))
             builder.addAll(evFactory, encodedValuesStr);
@@ -150,26 +130,22 @@ public static EncodingManager create(EncodedValueFactory evFactory, FlagEncoderF
      * Starts the build process of an EncodingManager
      */
     public static Builder start() {
-        return new Builder(4);
+        return new Builder();
     }
 
-    private EncodingManager(int bytes) {
-        if (bytes <= 0 || (bytes / 4) * 4 != bytes)
-            throw new IllegalStateException("bytesForEdgeFlags can be only a multiple of 4");
-
-        this.bitsForEdgeFlags = bytes * 8;
+    private EncodingManager() {
         this.config = new EncodedValue.InitializerConfig();
     }
 
     public static class Builder {
         private EncodingManager em;
 
-        public Builder(int bytes) {
-            this(bytes, true);
+        public Builder() {
+            this(true);
         }
 
-        private Builder(int bytes, boolean addRoundabout) {
-            em = new EncodingManager(bytes);
+        private Builder(boolean addRoundabout) {
+            em = new EncodingManager();
             if (addRoundabout)
                 add(new OSMRoundaboutParser());
         }
@@ -330,8 +306,8 @@ static String fixWayName(String str) {
         return str.replaceAll(";[ ]*", ", ");
     }
 
-    public int getBytesForFlags() {
-        return bitsForEdgeFlags / 8;
+    public int getIntsForFlags() {
+        return (int) Math.ceil((double) config.getRequiredBits() / 32.0);
     }
 
     private void setEnableInstructions(boolean enableInstructions) {
@@ -349,10 +325,6 @@ private void setPreferredLanguage(String preferredLanguage) {
         this.preferredLanguage = preferredLanguage;
     }
 
-    public String getPreferredLanguage() {
-        return preferredLanguage;
-    }
-
     private void addEncoder(AbstractFlagEncoder encoder) {
         if (encoder.isRegistered())
             throw new IllegalStateException("You must not register a FlagEncoder (" + encoder.toString() + ") twice!");
@@ -366,8 +338,6 @@ private void addEncoder(AbstractFlagEncoder encoder) {
 
         int encoderCount = edgeEncoders.size();
         int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
-        if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
@@ -379,15 +349,13 @@ private void addEncoder(AbstractFlagEncoder encoder) {
         }
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
-        if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
         // turn flag bits are independent from edge encoder bits
         usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
-        if (usedBits > bitsForTurnFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForTurnFlags, "turn"));
+        if (usedBits > BITS_FOR_TURN_FLAGS)
+            throw new IllegalArgumentException(String.format(Locale.ROOT, "Encoders are requesting %s bits, more than %s bits of turn flags. ", usedBits, BITS_FOR_TURN_FLAGS));
         nextTurnBit = usedBits;
 
         edgeEncoders.add(encoder);
@@ -398,13 +366,7 @@ private void addEncodedValue(EncodedValue ev, boolean encValBoundToFlagEncoder)
             throw new IllegalStateException("EncodedValue " + ev.getName() + " already exists " + encodedValueMap.get(ev.getName()) + " vs " + ev);
         if (!encValBoundToFlagEncoder && ev.getName().contains(SPECIAL_SEPARATOR))
             throw new IllegalArgumentException("EncodedValue " + ev.getName() + " must not contain '" + SPECIAL_SEPARATOR + "' as reserved for FlagEncoder");
-
         ev.init(config);
-        if (config.getRequiredBits() > getBytesForFlags() * 8)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR + "(Attempt to add EncodedValue " + ev.getName() + ") ",
-                    config.getRequiredBits(), bitsForEdgeFlags, "edge") +
-                    "Decrease the number of vehicles or increase the flags to more bytes via graph.bytes_for_flags: " + (config.getRequiredBits() / 32 * 4 + 4));
-
         encodedValueMap.put(ev.getName(), ev);
     }
 
@@ -480,10 +442,6 @@ public boolean hasAccepted() {
             return hasAccepted;
         }
 
-        private boolean has(String key) {
-            return accessMap.containsKey(key);
-        }
-
         public Access getAccess() {
             if (accessMap.isEmpty())
                 throw new IllegalStateException("Cannot determine Access if map is empty");
@@ -585,7 +543,7 @@ public String toEncodedValuesAsString() {
 
     // TODO hide IntsRef even more in a later version: https://gist.github.com/karussell/f4c2b2b1191be978d7ee9ec8dd2cd48f
     public IntsRef createEdgeFlags() {
-        return new IntsRef(bitsForEdgeFlags / 32);
+        return new IntsRef(getIntsForFlags());
     }
 
     public IntsRef flagsDefault(boolean forward, boolean backward) {
@@ -601,8 +559,7 @@ public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         EncodingManager that = (EncodingManager) o;
-        return bitsForEdgeFlags == that.bitsForEdgeFlags &&
-                enableInstructions == that.enableInstructions &&
+        return enableInstructions == that.enableInstructions &&
                 edgeEncoders.equals(that.edgeEncoders) &&
                 encodedValueMap.equals(that.encodedValueMap) &&
                 preferredLanguage.equals(that.preferredLanguage);
@@ -610,7 +567,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(edgeEncoders, encodedValueMap, bitsForEdgeFlags, enableInstructions, preferredLanguage);
+        return Objects.hash(edgeEncoders, encodedValueMap, enableInstructions, preferredLanguage);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index c2db769812..6787fca014 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -48,8 +48,7 @@ public TestAlgoCollector(String name) {
     public TestAlgoCollector assertDistance(EncodingManager encodingManager, AlgoHelperEntry algoEntry, List<QueryResult> queryList,
                                             OneRun oneRun) {
         List<Path> altPaths = new ArrayList<>();
-        QueryGraph queryGraph = new QueryGraph(algoEntry.getForQueryGraph());
-        queryGraph.lookup(queryList);
+        QueryGraph queryGraph = QueryGraph.lookup(algoEntry.getForQueryGraph(), queryList);
         AlgorithmOptions opts = algoEntry.getAlgorithmOptions();
         FlagEncoder encoder = opts.getWeighting().getFlagEncoder();
         if (encoder.supports(TurnWeighting.class)) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java b/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java
index ee0174c1d7..568bbd052a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java
@@ -1,19 +1,17 @@
 package com.graphhopper.routing.util.parsers.helpers;
 
-import static com.graphhopper.util.Helper.isEmpty;
-import static com.graphhopper.util.Helper.toLowerCase;
-
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.storage.IntsRef;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.List;
+
+import static com.graphhopper.util.Helper.toLowerCase;
 
 public class OSMValueExtractor {
-    
+
     private static final Logger LOG = LoggerFactory.getLogger(OSMValueExtractor.class);
 
     private OSMValueExtractor() {
@@ -22,8 +20,6 @@ private OSMValueExtractor() {
 
     public static void extractTons(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
         String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value))
-            return;
         try {
             double val = stringToTons(value);
             if (val > valueEncoder.getMaxDecimal())
@@ -36,25 +32,27 @@ public static void extractTons(IntsRef edgeFlags, ReaderWay way, DecimalEncodedV
     }
 
     public static double stringToTons(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
-        value = value.replace("mgw", "").trim();
+        value = toLowerCase(value).replaceAll("(tons|ton)", "t").
+                replace("mgw", "").trim();
+        if (isInvalid(value))
+            throw new NumberFormatException("Cannot parse value for 'tons': " + value);
+
         double factor = 1;
-        if (value.equals("default") || value.equals("none")) {
-            return -1;
-        } else if (value.endsWith("t")) {
+        if (value.endsWith("t")) {
             value = value.substring(0, value.length() - 1);
         } else if (value.endsWith("lbs")) {
             value = value.substring(0, value.length() - 3);
             factor = 0.00045359237;
+        } else if (value.endsWith("kg")) {
+            value = value.substring(0, value.length() - 2);
+            factor = 0.001;
         }
-    
+
         return Double.parseDouble(value) * factor;
     }
 
     public static void extractMeter(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
         String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value))
-            return;
         try {
             double val = stringToMeter(value);
             if (val > valueEncoder.getMaxDecimal())
@@ -67,18 +65,17 @@ public static void extractMeter(IntsRef edgeFlags, ReaderWay way, DecimalEncoded
     }
 
     public static double stringToMeter(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m").
+                replaceAll("(\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
+        if (isInvalid(value))
+            throw new NumberFormatException("Cannot parse value for 'meter': " + value);
         double factor = 1;
         double offset = 0;
-        value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
         if (value.startsWith("~") || value.contains("approx")) {
-            value = value.replaceAll("(\\~|approx)", "").trim();
+            value = value.replaceAll("(~|approx)", "").trim();
             factor = 0.8;
         }
-    
-        if (value.equals("default") || value.equals("none") || value.equals("unsigned"))
-            return -1;
-    
+
         if (value.endsWith("in")) {
             int startIndex = value.indexOf("ft");
             String inchValue;
@@ -87,23 +84,37 @@ public static double stringToMeter(String value) {
             } else {
                 startIndex += 2;
             }
-    
+
             inchValue = value.substring(startIndex, value.length() - 2);
             value = value.substring(0, startIndex);
             offset = Double.parseDouble(inchValue) * 0.0254;
         }
-    
+
         if (value.endsWith("ft")) {
             value = value.substring(0, value.length() - 2);
             factor *= 0.3048;
+        } else if (value.endsWith("cm")) {
+            value = value.substring(0, value.length() - 2);
+            factor *= 0.01;
         } else if (value.endsWith("m")) {
             value = value.substring(0, value.length() - 1);
         }
-    
+
         if (value.isEmpty()) {
             return offset;
         } else {
             return Double.parseDouble(value) * factor + offset;
         }
     }
+
+    static boolean isInvalid(String value) {
+        value = toLowerCase(value);
+        return value.isEmpty() || value.startsWith("default") || value.equals("none") || value.equals("unknown")
+                || value.contains("unrestricted") || value.startsWith("〜")
+                || value.contains("narrow") || value.equals("unsigned") || value.equals("fixme") || value.equals("small")
+                || value.contains(";") || value.contains(":") || value.contains("(")
+                || value.contains(">") || value.contains("<") || value.contains("-")
+                // only support '.' and no German decimals
+                || value.contains(",");
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 7de9936ba2..f95b3d4d3c 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -31,7 +31,6 @@
 
 import java.util.Locale;
 
-import static com.graphhopper.util.EdgeIteratorState.REVERSE_STATE;
 import static com.graphhopper.util.Helper.nf;
 
 /**
@@ -60,7 +59,7 @@
     final BitUtil bitUtil;
     final EncodingManager encodingManager;
     final EdgeAccess edgeAccess;
-    private final int bytesForFlags;
+    private final int intsForFlags;
     // length | nodeA | nextNode | ... | nodeB
     // as we use integer index in 'egdes' area => 'geometry' area is limited to 4GB (we use pos&neg values!)
     private final DataAccess wayGeometry;
@@ -97,7 +96,7 @@ public BaseGraph(Directory dir, final EncodingManager encodingManager, boolean w
                      InternalGraphEventListener listener, GraphExtension extendedStorage) {
         this.dir = dir;
         this.encodingManager = encodingManager;
-        this.bytesForFlags = encodingManager.getBytesForFlags();
+        this.intsForFlags = encodingManager.getIntsForFlags();
         this.bitUtil = BitUtil.get(dir.getByteOrder());
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
@@ -229,7 +228,7 @@ void initStorage() {
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
-                nextEdgeEntryIndex(encodingManager.getBytesForFlags()));
+                nextEdgeEntryIndex(encodingManager.getIntsForFlags() * 4));
 
         E_DIST = nextEdgeEntryIndex(4);
         E_GEO = nextEdgeEntryIndex(4);
@@ -397,7 +396,7 @@ public void debugPrint() {
         System.out.println("edges:");
         String formatEdges = "%12s | %12s | %12s | %12s | %12s | %12s | %12s \n";
         System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_FLAGS", "E_DIST");
-        IntsRef intsRef = new IntsRef(bytesForFlags / 4);
+        IntsRef intsRef = new IntsRef(intsForFlags);
         for (int i = 0; i < Math.min(edgeCount, printMax); ++i) {
             long edgePointer = edgeAccess.toPointer(i);
             edgeAccess.readFlags(edgePointer, intsRef);
@@ -478,16 +477,7 @@ void loadExisting(String dim) {
      * @return the updated iterator the properties where copied to.
      */
     EdgeIteratorState copyProperties(EdgeIteratorState from, CommonEdgeIterator to) {
-        boolean reverse = from.get(REVERSE_STATE);
-        if (to.reverse)
-            reverse = !reverse;
-        // in case reverse is true we have to swap the nodes to store flags correctly in its "storage direction"
-        int nodeA = reverse ? from.getAdjNode() : from.getBaseNode();
-        int nodeB = reverse ? from.getBaseNode() : from.getAdjNode();
         long edgePointer = edgeAccess.toPointer(to.getEdge());
-        int linkA = reverse ? edgeAccess.getLinkB(edgePointer) : edgeAccess.getLinkA(edgePointer);
-        int linkB = reverse ? edgeAccess.getLinkA(edgePointer) : edgeAccess.getLinkB(edgePointer);
-        edgeAccess.writeEdge(to.getEdge(), nodeA, nodeB, linkA, linkB);
         edgeAccess.writeFlags(edgePointer, from.getFlags());
 
         // copy the rest with higher level API
@@ -1167,7 +1157,7 @@ public CommonEdgeIterator(long edgePointer, EdgeAccess edgeAccess, BaseGraph bas
             this.edgePointer = edgePointer;
             this.edgeAccess = edgeAccess;
             this.baseGraph = baseGraph;
-            this.baseIntsRef = new IntsRef(baseGraph.bytesForFlags / 4);
+            this.baseIntsRef = new IntsRef(baseGraph.intsForFlags);
         }
 
         @Override
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 51f9c4d559..935a9b6216 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -42,7 +42,7 @@
     int getNodes();
 
     /**
-     * @return the number of edges in this graph. equivalent to getAllEdges().length();
+     * @return the number of edges in this graph. Equivalent to getAllEdges().length().
      */
     int getEdges();
 
@@ -59,7 +59,6 @@
     /**
      * Creates an edge between the nodes a and b. To set distance or access use the returned edge
      * and e.g. edgeState.setDistance
-     * <p>
      *
      * @param a the index of the starting (tower) node of the edge
      * @param b the index of the ending (tower) node of the edge
@@ -75,9 +74,9 @@
     /**
      * Returns a wrapper over the specified edgeId.
      *
-     * @param adjNode is the node that will be returned via adjNode(). If adjNode is
+     * @param adjNode is the node that will be returned via getAdjNode(). If adjNode is
      *                Integer.MIN_VALUE then the edge will be returned in the direction of how it is stored
-     * @return an edge iterator state or potentially null if adjNode does not match
+     * @return a new EdgeIteratorState object or potentially null if adjNode does not match
      * @throws IllegalStateException if edgeId is not valid
      */
     EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode);
@@ -99,9 +98,7 @@
 
     /**
      * Returns an EdgeExplorer which makes it possible to traverse all filtered edges of a specific
-     * node. Reduce calling this method as much as possible, e.g. create an explorer before a for
-     * loop!
-     * <p>
+     * node. Calling this method might be expensive, so e.g. create an explorer before a for loop!
      *
      * @see EdgeExplorer
      * @see Graph#createEdgeExplorer()
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 4dc0f14bad..d7b38c9820 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -174,7 +174,6 @@ public GraphHopperStorage create(long byteCount) {
         long initSize = Math.max(byteCount, 100);
         properties.create(100);
 
-        properties.put("graph.bytes_for_flags", encodingManager.getBytesForFlags());
         properties.put("graph.encoded_values", encodingManager.toEncodedValuesAsString());
         properties.put("graph.flag_encoders", encodingManager.toFlagEncodersAsString());
 
@@ -260,10 +259,6 @@ public boolean loadExisting() {
             if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
                 throw new IllegalStateException("Configured graph.byte_order (" + dir.getByteOrder() + ") is not equal to loaded " + byteOrder + "");
 
-            String bytesForFlags = properties.get("graph.bytes_for_flags");
-            if (!bytesForFlags.equalsIgnoreCase("" + encodingManager.getBytesForFlags()))
-                throw new IllegalStateException("Configured graph.bytes_for_flags (" + encodingManager.getBytesForFlags() + ") is not equal to loaded " + bytesForFlags);
-
             String dim = properties.get("graph.dimension");
             baseGraph.loadExisting(dim);
 
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index 6bc1c33942..8e6e385563 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -22,6 +22,14 @@
 
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
+ * Example:
+ * <span>
+ * EdgeExplorer expl = graph.createEdgeExplorer();
+ * EdgeIterator iter = expl.setBaseNode(baseNode);
+ * while(iter.next()) {
+ * iter.getBaseBase() // equals to the specified baseNode
+ * }
+ * </span>
  *
  * @author Peter Karich
  * @see EdgeIterator
@@ -77,10 +85,8 @@ public void setBool(boolean reverse, IntsRef ref, boolean value) {
     int getOrigEdgeLast();
 
     /**
-     * Returns the node used to instantiate the EdgeIterator. Example: "EdgeIterator iter =
-     * graph.getEdges(baseNode)". Often only used for convenience reasons. Do not confuse this with
-     * a <i>source node</i> of a directed edge.
-     * <p>
+     * Returns the node used to instantiate the EdgeIterator. Often only used for convenience reasons.
+     * Do not confuse this with a <i>source node</i> of a directed edge.
      *
      * @return the requested node itself
      * @see EdgeIterator
@@ -94,12 +100,11 @@ public void setBool(boolean reverse, IntsRef ref, boolean value) {
     int getAdjNode();
 
     /**
-     * For road network data like OSM a way is nearly always a curve not just a straight line. These
-     * nodes are called pillar nodes and are between tower nodes (which are used for routing), they
-     * are necessary to have a more exact geometry. See the docs for more information
+     * For road network data like OSM a way is often not just a straight line. The nodes between the junction nodes
+     * are called pillar nodes. The junction nodes are called tower nodes and used for routing. The pillar nodes are
+     * necessary to have an exact geometry. See the docs for more information
      * (docs/core/low-level-api.md#what-are-pillar-and-tower-nodes). Updates to the returned list
      * are not reflected in the graph, for that you've to use setWayGeometry.
-     * <p>
      *
      * @param mode can be <ul> <li>0 = only pillar nodes, no tower nodes</li> <li>1 = inclusive the
      *             base tower node only</li> <li>2 = inclusive the adjacent tower node only</li> <li>3 =
@@ -109,9 +114,9 @@ public void setBool(boolean reverse, IntsRef ref, boolean value) {
     PointList fetchWayGeometry(int mode);
 
     /**
-     * @param list is a sorted collection of nodes between the base node and the current adjacent node. Specify the list
-     *             without the adjacent and base node. This method can be called multiple times, but if the distance
-     *             changes, the setDistance method is not called automatically.
+     * @param list is a sorted collection of coordinates between the base node and the current adjacent node. Specify
+     *             the list without the adjacent and base node. This method can be called multiple times, but if the
+     *             distance changes, the setDistance method is not called automatically.
      */
     EdgeIteratorState setWayGeometry(PointList list);
 
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index fd03380960..93b81e725f 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -546,15 +546,6 @@ public static int getEdgeFromEdgeKey(int edgeKey) {
         return edgeKey / 2;
     }
 
-    /**
-     * Returns the edge key for a given edge id and adjacent node. This is needed in a few places where
-     * the base node is not known.
-     */
-    public static int getEdgeKey(Graph graph, int edgeId, int node, boolean reverse) {
-        EdgeIteratorState edgeIteratorState = graph.getEdgeIteratorState(edgeId, node);
-        return GHUtility.createEdgeKey(edgeIteratorState.getBaseNode(), edgeIteratorState.getAdjNode(), edgeId, reverse);
-    }
-
     public static IntsRef setProperties(IntsRef edgeFlags, FlagEncoder encoder, double averageSpeed, boolean fwd, boolean bwd) {
         if (averageSpeed < 0.0001 && (fwd || bwd))
             throw new IllegalStateException("Zero speed is only allowed if edge will get inaccessible. Otherwise Weighting can produce inconsistent results");
diff --git a/core/src/main/resources/com/graphhopper/util/ko.txt b/core/src/main/resources/com/graphhopper/util/ko.txt
index 3ecc805fda..0fc92d946a 100644
--- a/core/src/main/resources/com/graphhopper/util/ko.txt
+++ b/core/src/main/resources/com/graphhopper/util/ko.txt
@@ -1,18 +1,18 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=계속
-continue_onto=%1$s 계속 이동
+continue_onto=%1$s(으)로 계속 이동
 turn_left=좌회전
 turn_right=우회전
 turn_slight_left=왼쪽 방향
 turn_slight_right=오른쪽 방향
 turn_sharp_left=왼쪽 방향
 turn_sharp_right=오른쪽 방향
-keep_left=
-keep_right=
+keep_left=좌측 유지
+keep_right=우측 유지
 turn_onto=%2$s로 %1$s
-u_turn=
-unknown=
+u_turn=유턴
+unknown=알 수 없는 안내 '%1$s'
 web.search_button=탐색
 web.from_hint=출발
 web.via_hint=경유
@@ -20,8 +20,8 @@ web.to_hint=도착
 web.more_button=더보기
 web.gpx_export_button=GPX 내보내기
 web.route_info=%1$s %2$s 소요
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=%1$s회 환승, %2$s에 도착 (%3$s)
+web.pt_route_info_walking=도보 이용, %1$s에 도착 (%2$s)
 web.locations_not_found=경로를 탐색할 수 없습니다. 이 지역에서 위치를 찾을 수 없습니다.
 web.bike=자전거
 web.racingbike=경주용 자전거
@@ -35,15 +35,15 @@ web.truck=트럭
 web.staticlink=정적 링크
 web.motorcycle=모터사이클
 via=경유
-finish=도착!
+finish=도착
 hour_abbr=시간
 day_abbr=일
 min_abbr=분
 km_abbr=km
 m_abbr=m
 mi_abbr=마일
-ft_abbr=도보
-road=피트
+ft_abbr=피트
+road=도로
 off_bike=자전거에서 하차
 cycleway=자전거도로
 way=도로
@@ -51,18 +51,18 @@ small_way=소로
 paved=포장
 unpaved=비포장
 stopover=경유지 %1$s
-roundabout_enter=로터리 진입
-roundabout_exit=로터리에서 %1$s 진출
-roundabout_exit_onto=로터리에서 %1$s 진출 후 %2$s 이동
-total_ascend=%1$s 오르막길
-total_descend=%1$s 내리막길
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=출발
-web.intermediate_label=경유
-web.end_label=도착
+roundabout_enter=회전교차로 진입
+roundabout_exit=회전교차로에서 %1$s 진출
+roundabout_exit_onto=회전교차로에서 %1$s 진출 후 %2$s 이동
+total_ascend=오르막길 총 %1$s
+total_descend=내리막길 총 %1$s
+way_contains_ford=경로에 여울이 있습니다
+pt_start_trip=%1$s 진입
+pt_end_trip=%1$s 진출
+pt_transfer_to=%1$s(으)로 환승
+web.start_label=출발지
+web.intermediate_label=경유지
+web.end_label=도착지
 web.set_start=출발지로 설정
 web.set_intermediate=경유지로 설정
 web.set_end=도착지로 설정
@@ -70,10 +70,10 @@ web.center_map=여기를 지도의 중심으로 설정
 web.show_coords=좌표 보기
 web.route=경로
 web.delete_from_route=경로에서 삭제
-web.marker=마커
-web.gh_offline_info=GraphHopper API 상태가 오프라인입니까?
+web.marker=핀
+web.gh_offline_info=GraphHopper API에 연결할 수 없습니다.
 web.refresh_button=새로고침
 web.server_status=상태
 web.zoom_in=확대
 web.zoom_out=축소
-web.drag_to_reorder=
+web.drag_to_reorder=드래그하여 재정렬
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 9cc85e6b3c..e0a3c790f6 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -115,7 +115,7 @@ public void testDisconnected179() {
     public void testDoNotInterpolateTwice1645() {
         String loc = "./target/issue1645";
         Helper.removeDir(new File(loc));
-        EncodingManager em = new EncodingManager.Builder(4).add(new OSMRoadEnvironmentParser()).add(new CarFlagEncoder()).build();
+        EncodingManager em = new EncodingManager.Builder().add(new OSMRoadEnvironmentParser()).add(new CarFlagEncoder()).build();
         GraphHopperStorage graph = new GraphBuilder(em).setLocation(loc).set3D(true).setStore(true).create();
 
         // we need elevation
diff --git a/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
index fd32b1bf19..52bec8d356 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
@@ -54,7 +54,7 @@
     @Before
     public void setUp() {
         graph = new GraphHopperStorage(new RAMDirectory(),
-                encodingManager = new EncodingManager.Builder(8).add(new CarFlagEncoder()).add(new FootFlagEncoder()).
+                encodingManager = new EncodingManager.Builder().add(new CarFlagEncoder()).add(new FootFlagEncoder()).
                         add(new OSMRoadEnvironmentParser()).build(),
                 true, new GraphExtension.NoOpExtension()).create(100);
         roadEnvEnc = encodingManager.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 7985c2f808..dc57b2ff36 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -29,7 +29,10 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.*;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -723,7 +726,7 @@ Path calcPathViaQuery(Weighting weighting, GraphHopperStorage ghStorage, double
         // correct order for CH: in factory do prepare and afterwards wrap in query graph
         AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).build();
         RoutingAlgorithmFactory factory = createFactory(ghStorage, opts);
-        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage, weighting)).lookup(from, to);
+        QueryGraph qGraph = QueryGraph.lookup(getGraph(ghStorage, weighting), Arrays.asList(from, to));
         return factory.createAlgo(qGraph, opts).
                 calcPath(from.getClosestNode(), to.getClosestNode());
     }
@@ -734,7 +737,7 @@ Path calcPath(GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int to
         QueryResult to = newQR(ghStorage, toNode1, toNode2);
 
         RoutingAlgorithmFactory factory = createFactory(ghStorage, defaultOpts);
-        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage, defaultOpts.getWeighting())).lookup(from, to);
+        QueryGraph qGraph = QueryGraph.lookup(getGraph(ghStorage, defaultOpts.getWeighting()), Arrays.asList(from, to));
         return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
@@ -869,7 +872,7 @@ public String getName() {
         QueryResult to = newQR(graph, 10, 9);
 
         RoutingAlgorithmFactory factory = createFactory(graph, fakeOpts);
-        QueryGraph qGraph = new QueryGraph(getGraph(graph, fakeWeighting)).lookup(from, to);
+        QueryGraph qGraph = QueryGraph.lookup(getGraph(graph, fakeWeighting), Arrays.asList(from, to));
         p = factory.createAlgo(qGraph, fakeOpts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(IntArrayList.from(12, 0, 1, 2, 11, 7, 10, 13), p.calcNodes());
         assertEquals(37009621, p.getTime());
diff --git a/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java
index 0a8e28613c..b8a8bada48 100644
--- a/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java
@@ -12,7 +12,6 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -24,7 +23,6 @@
 import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
 import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
 
 /**
  * This test makes sure that {@link DijkstraBidirectionRef#calcPath(int from, int to, int fromOutEdge, int toInEdge)}, i.e.
@@ -40,8 +38,6 @@
     private FlagEncoder encoder;
     private EncodingManager encodingManager;
     private Weighting weighting;
-    private LocationIndex locationIndex;
-    private QueryGraph queryGraph;
 
     @Rule
     public RepeatRule repeatRule = new RepeatRule();
@@ -479,9 +475,12 @@ public void directedRouting_noUTurnAtVirtualEdge() {
         na.setNode(3, 0, 2);
         na.setNode(4, 0, 1);
         na.setNode(5, 0, 0);
-        initQueryGraph();
 
-        QueryResult qr = findClosest();
+        LocationIndex locationIndex = new LocationIndexTree(graph, dir);
+        locationIndex.prepareIndex();
+        QueryResult qr = locationIndex.findClosest(1.1, 0.5, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = QueryGraph.lookup(graph, Collections.singletonList(qr));
+
         assertEquals("wanted to get EDGE", QueryResult.Position.EDGE, qr.getSnappedPosition());
         assertEquals(6, qr.getClosestNode());
 
@@ -498,18 +497,6 @@ public void directedRouting_noUTurnAtVirtualEdge() {
         assertEquals(5 + virtualEdge.getDistance(), path.getDistance(), 1.e-3);
     }
 
-    private void initQueryGraph() {
-        queryGraph = new QueryGraph(graph);
-        locationIndex = new LocationIndexTree(graph, dir);
-        locationIndex.prepareIndex();
-    }
-
-    private QueryResult findClosest() {
-        QueryResult qr = locationIndex.findClosest(1.1, 0.5, EdgeFilter.ALL_EDGES);
-        queryGraph.lookup(Collections.singletonList(qr));
-        return qr;
-    }
-
     private Path calcPath(int source, int target, int sourceOutEdge, int targetInEdge) {
         return calcPath(source, target, sourceOutEdge, targetInEdge, weighting);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/DirectionResolverOnQueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/DirectionResolverOnQueryGraphTest.java
new file mode 100644
index 0000000000..0d9e3df374
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/DirectionResolverOnQueryGraphTest.java
@@ -0,0 +1,365 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static com.graphhopper.routing.DirectionResolverResult.unrestricted;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+import static com.graphhopper.util.Helper.createPointList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * This test simulates incoming lat/lon coordinates that get snapped to graph edges (using {@link QueryGraph}) and the
+ * calculated directions are tested.
+ *
+ * @see DirectionResolverTest which tests direction resolving on a normal graph only considering real nodes and edges
+ */
+public class DirectionResolverOnQueryGraphTest {
+    private QueryGraph queryGraph;
+    private NodeAccess na;
+    private FlagEncoder encoder;
+    private Graph g;
+    private LocationIndex locationIndex;
+
+    @Before
+    public void setup() {
+        encoder = new CarFlagEncoder();
+        g = new GraphBuilder(EncodingManager.create(encoder)).create();
+        na = g.getNodeAccess();
+    }
+
+    @Test
+    public void junction() {
+        //      3
+        //    a | b
+        // 0 -> 1 -> 2
+        //    c | d
+        //      4
+        addNode(0, 2.000, 1.990);
+        addNode(1, 2.000, 2.000);
+        addNode(2, 2.000, 2.010);
+        addNode(3, 2.010, 2.000);
+        addNode(4, 1.990, 2.000);
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+        addEdge(1, 3, true);
+        addEdge(1, 4, true);
+        init();
+
+        // close to the junction we snap to the closest edge (a virtual node 5 will be added)
+        // a
+        checkResult(2.001, 1.998, onlyLeft(edge(0, 5), edge(5, 1)));
+        checkResult(2.002, 1.999, restricted(edge(3, 5), edge(5, 1), edge(1, 5), edge(5, 3)));
+        // b
+        checkResult(2.001, 2.002, onlyLeft(edge(1, 5), edge(5, 2)));
+        checkResult(2.002, 2.001, restricted(edge(1, 5), edge(5, 3), edge(3, 5), edge(5, 1)));
+        // c
+        checkResult(1.999, 1.998, onlyRight(edge(0, 5), edge(5, 1)));
+        checkResult(1.998, 1.999, restricted(edge(1, 5), edge(5, 4), edge(4, 5), edge(5, 1)));
+        // d
+        checkResult(1.999, 2.002, onlyRight(edge(1, 5), edge(5, 2)));
+        checkResult(1.998, 2.001, restricted(edge(4, 5), edge(5, 1), edge(1, 5), edge(5, 4)));
+
+        // precisely hit the junction -> no restriction (there is no reasonable way to restrict the directions for
+        // a junction)
+        assertUnrestricted(2.0, 2.0);
+    }
+
+    @Test
+    public void multiple_locations_same_road() {
+        //      3     5
+        //  0 --x--x--x-- 1
+        //         4
+        addNode(0, 1, 1);
+        addNode(1, 1, 2);
+        // make sure graph bounds are valid
+        addNode(2, 5, 5);
+
+        addEdge(0, 1, true);
+        init();
+
+        // virtual nodes 3,4,5 will be added to query graph
+        checkResults(
+                result(1.01, 1.2, restricted(edge(4, 3), edge(3, 0), edge(0, 3), edge(3, 4))),
+                result(0.99, 1.5, restricted(edge(3, 4), edge(4, 5), edge(5, 4), edge(4, 3))),
+                result(1.01, 1.7, restricted(edge(1, 5), edge(5, 4), edge(4, 5), edge(5, 1)))
+        );
+    }
+
+    @Test
+    public void multiple_locations_same_road_one_way() {
+        //      3     5
+        //  0 --x--x--x--> 1
+        //         4
+        addNode(0, 1, 1);
+        addNode(1, 1, 2);
+        // make sure graph bounds are valid
+        addNode(2, 5, 5);
+
+        addEdge(0, 1, false);
+        init();
+
+        // virtual nodes 3,4,5 will be added to query graph
+        checkResults(
+                result(1.01, 1.2, onlyLeft(edge(0, 3), edge(3, 4))),
+                result(0.99, 1.5, onlyRight(edge(3, 4), edge(4, 5))),
+                result(1.01, 1.7, onlyLeft(edge(4, 5), edge(5, 1)))
+        );
+    }
+
+    @Test
+    public void two_locations_same_spot_same_side() {
+        //      3
+        //      3
+        //  0 --x-- 1
+        addNode(0, 1, 1);
+        addNode(1, 1, 2);
+        // make sure graph bounds are valid
+        addNode(2, 5, 5);
+
+        addEdge(0, 1, true);
+        init();
+
+        // there should only be a single virtual node, used for both queried points
+        checkResults(
+                result(1.01, 1.5, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1))),
+                result(1.01, 1.5, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1)))
+        );
+    }
+
+    @Test
+    public void two_locations_same_spot_different_sides() {
+        //      3
+        //  0 --x-- 1
+        //      3
+        addNode(0, 1, 1);
+        addNode(1, 1, 2);
+        // make sure graph bounds are valid
+        addNode(2, 5, 5);
+
+        addEdge(0, 1, true);
+        init();
+
+        checkResults(
+                result(1.01, 1.5, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1))),
+                result(0.99, 1.5, restricted(edge(0, 3), edge(3, 1), edge(1, 3), edge(3, 0)))
+        );
+    }
+
+    @Test
+    public void road_with_geometry() {
+        //       3
+        //    x --- x
+        //   3|  3  |3
+        //    0     1
+        addNode(0, 1, 2);
+        addNode(1, 1, 3);
+        // make sure graph has valid bounds
+        addNode(2, 5, 5);
+
+        addEdge(0, 1, true).setWayGeometry(createPointList(2, 2, 2, 3));
+        init();
+
+        // pillar nodes / geometry are important to decide on which side of the road a location is.
+        // note that to determine the edges we are only interested in the virtual edges between the
+        // tower nodes and the virtual node
+        checkResult(1.50, 1.99, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1)));
+        checkResult(2.01, 2.50, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1)));
+        checkResult(1.50, 3.01, restricted(edge(1, 3), edge(3, 0), edge(0, 3), edge(3, 1)));
+        checkResult(1.99, 2.50, restricted(edge(0, 3), edge(3, 1), edge(1, 3), edge(3, 0)));
+    }
+
+    @Test
+    public void sharp_curves() {
+        // 0 --- x
+        //      /
+        //     x---- 1
+        addNode(0, 2, 1);
+        addNode(1, 1, 3);
+        addEdge(0, 1, true).setWayGeometry(createPointList(2.0, 1.5, 1.0, 1.3));
+        init();
+        // these are cases where we snap onto pillar nodes
+        // .. at the 'outside' of the turns
+        checkResult(2.0, 1.501, restricted(edge(1, 2), edge(2, 0), edge(0, 2), edge(2, 1)));
+        checkResult(1.0, 1.299, restricted(edge(0, 2), edge(2, 1), edge(1, 2), edge(2, 0)));
+        // .. at the 'inside' of the turns
+        checkResult(1.99, 1.49, restricted(edge(0, 2), edge(2, 1), edge(1, 2), edge(2, 0)));
+        checkResult(1.01, 1.31, restricted(edge(1, 2), edge(2, 0), edge(0, 2), edge(2, 1)));
+    }
+
+    @Test
+    public void junction_hitFromTheSide() {
+        // 0  1  2
+        //  \ | /
+        //   \|/
+        //    3
+        addNode(0, 2, 1);
+        addNode(1, 2, 2);
+        addNode(2, 2, 3);
+        addNode(3, 1, 2);
+        addEdge(0, 3, true);
+        addEdge(1, 3, true);
+        addEdge(2, 3, true);
+        init();
+
+        // we will easily snap onto the (junction) tower node if it is 'exposed' like this (much more likely than
+        // hitting the exact coordinates)
+        assertUnrestricted(0.99, 2);
+    }
+
+    @Test
+    public void duplicateCoordinatesAtBaseOrAdjNode() {
+        // 0-x   x-1
+        //   x-x-x
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        // todo: we add duplicate coordinates to the beginning/end of the geometry, these are currently possible, so we
+        // have to handle this separately, see #1694
+        addEdge(0, 1, true).setWayGeometry(createPointList(0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.9, 0.9, 0.9, 0.9));
+        init();
+        checkResult(0.1, 0.1, restricted(edge(0, 2), edge(2, 1), edge(1, 2), edge(2, 0)));
+        checkResult(0.9, 0.9, restricted(edge(0, 2), edge(2, 1), edge(1, 2), edge(2, 0)));
+    }
+
+    private void addNode(int nodeId, double lat, double lon) {
+        na.setNode(nodeId, lat, lon);
+    }
+
+    private EdgeIteratorState addEdge(int from, int to, boolean bothDirections) {
+        return g.edge(from, to, 1, bothDirections);
+    }
+
+    private void init() {
+        locationIndex = new LocationIndexTree(g, new RAMDirectory());
+        locationIndex.prepareIndex();
+    }
+
+    private void checkResult(double lat, double lon, ExpectedEdge... edges) {
+        checkResults(result(lat, lon, edges));
+    }
+
+    private void checkResults(ExpectedResult... expectedResults) {
+        List<QueryResult> qrs = new ArrayList<>(expectedResults.length);
+        for (ExpectedResult r : expectedResults) {
+            qrs.add(getQueryResult(r.lat, r.lon));
+        }
+        queryGraph = QueryGraph.lookup(g, qrs);
+        DirectionResolver resolver = new DirectionResolver(queryGraph, encoder);
+        for (int i = 0; i < expectedResults.length; i++) {
+            assertEquals("unexpected resolved direction",
+                    restrictedDirection(expectedResults[i]),
+                    resolver.resolveDirections(qrs.get(i).getClosestNode(), qrs.get(i).getQueryPoint()));
+        }
+    }
+
+    private ExpectedEdge[] onlyLeft(ExpectedEdge leftIn, ExpectedEdge leftOut) {
+        return new ExpectedEdge[]{null, null, leftIn, leftOut};
+    }
+
+    private ExpectedEdge[] onlyRight(ExpectedEdge rightIn, ExpectedEdge rightOut) {
+        return new ExpectedEdge[]{rightIn, rightOut, null, null};
+    }
+
+    private ExpectedEdge[] restricted(ExpectedEdge rightIn, ExpectedEdge rightOut, ExpectedEdge leftIn, ExpectedEdge leftOut) {
+        return new ExpectedEdge[]{rightIn, rightOut, leftIn, leftOut};
+    }
+
+    private void assertUnrestricted(double lat, double lon) {
+        QueryResult qr = getQueryResult(lat, lon);
+        queryGraph = QueryGraph.lookup(g, Collections.singletonList(qr));
+        DirectionResolver resolver = new DirectionResolver(queryGraph, encoder);
+        assertEquals(unrestricted(), resolver.resolveDirections(qr.getClosestNode(), qr.getQueryPoint()));
+    }
+
+    private DirectionResolverResult restrictedDirection(ExpectedResult restriction) {
+        IntArrayList edgeIds = new IntArrayList(restriction.expectedEdges.length);
+        for (ExpectedEdge e : restriction.expectedEdges) {
+            edgeIds.add(e == null ? NO_EDGE : findEdge(e.from, e.to));
+        }
+        return DirectionResolverResult.restricted(edgeIds.get(0), edgeIds.get(1), edgeIds.get(2), edgeIds.get(3));
+    }
+
+    private int findEdge(int from, int to) {
+        EdgeExplorer explorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder.getAccessEnc()));
+        EdgeIterator iter = explorer.setBaseNode(from);
+        while (iter.next()) {
+            if (iter.getAdjNode() == to) {
+                return iter.getEdge();
+            }
+        }
+        throw new IllegalStateException("Could not find edge from: " + from + ", to: " + to);
+    }
+
+    private QueryResult getQueryResult(double lat, double lon) {
+        return locationIndex.findClosest(lat, lon, EdgeFilter.ALL_EDGES);
+    }
+
+    private ExpectedEdge edge(int from, int to) {
+        return new ExpectedEdge(from, to);
+    }
+
+    private ExpectedResult result(double lat, double lon, ExpectedEdge... edges) {
+        return new ExpectedResult(lat, lon, edges);
+    }
+
+    // we need to store the from/to nodes instead of obtaining the edges directly, because by the time we specify
+    // the expected edges the query graph has not been build yet
+    private static class ExpectedEdge {
+        int from;
+        int to;
+
+        ExpectedEdge(int from, int to) {
+            this.from = from;
+            this.to = to;
+        }
+    }
+
+    private static class ExpectedResult {
+        double lat;
+        double lon;
+        ExpectedEdge[] expectedEdges;
+
+        ExpectedResult(double lat, double lon, ExpectedEdge[] expectedEdges) {
+            if (expectedEdges.length != 4) {
+                fail("there should be four expected edges, but got: " + expectedEdges.length);
+            }
+            this.lat = lat;
+            this.lon = lon;
+            this.expectedEdges = expectedEdges;
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/DirectionResolverTest.java b/core/src/test/java/com/graphhopper/routing/DirectionResolverTest.java
new file mode 100644
index 0000000000..aa46ceb6bb
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/DirectionResolverTest.java
@@ -0,0 +1,408 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.routing.DirectionResolverResult.*;
+import static com.graphhopper.util.Helper.createPointList;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Tests {@link DirectionResolver} on a simple graph (no {@link QueryGraph}.
+ *
+ * @see DirectionResolverOnQueryGraphTest for tests that include direction resolving for virtual nodes and edges
+ */
+public class DirectionResolverTest {
+    private FlagEncoder encoder;
+    private GraphHopperStorage g;
+    private NodeAccess na;
+
+    @Before
+    public void setup() {
+        encoder = new CarFlagEncoder();
+        g = new GraphBuilder(EncodingManager.create(encoder)).create();
+        na = g.getNodeAccess();
+    }
+
+    @Test
+    public void isolated_nodes() {
+        // 0   1
+        addNode(0, 0, 0);
+        addNode(1, 0.1, 0.1);
+
+        checkResult(0, impossible());
+        checkResult(1, impossible());
+    }
+
+    @Test
+    public void isolated_nodes_blocked_edge() {
+        // 0 |-| 1
+        addNode(0, 0, 0);
+        addNode(1, 0.1, 0.1);
+        // with edges without access flags (blocked edges)
+        g.edge(0, 1)
+                .set(encoder.getAccessEnc(), false)
+                .setReverse(encoder.getAccessEnc(), false);
+
+        checkResult(0, impossible());
+        checkResult(1, impossible());
+    }
+
+    @Test
+    public void isolated_nodes_with_loops() {
+        // 1      2__     3    4     5-6
+        // |\     |  \    |\   |\      |\
+        // x-x    x->x    --   ->      --
+        addNode(0, 2, 0);
+        addNode(1, 2, 1);
+        addNode(2, 2, 2);
+        addNode(3, 2, 3);
+        addNode(4, 2, 4);
+        addNode(5, 2, 5);
+        addNode(6, 2, 5.1);
+        // make sure graph bounds are valid
+        addNode(7, 5, 5);
+
+        addEdge(1, 1, true).setWayGeometry(createPointList(1.9, 1, 1.9, 1.1));
+        addEdge(2, 2, false).setWayGeometry(createPointList(1.9, 2, 1.9, 2.1));
+        addEdge(3, 3, true);
+        addEdge(4, 4, false);
+        addEdge(5, 6, true);
+        addEdge(6, 6, true);
+
+        checkResult(1, impossible());
+        checkResult(2, impossible());
+        checkResult(3, impossible());
+        checkResult(4, impossible());
+
+        // for node 5 we cannot know (without further loop traversing) that 5 is only connected to a single
+        // other node (and its only a loop), so we restrict it as usual
+        checkResult(5, restricted(edge(5, 6), edge(6, 5), edge(5, 6), edge(6, 5)));
+    }
+
+    @Test
+    public void nodes_at_end_of_dead_end_street() {
+        //       4
+        //       |
+        // 0 --> 1 --> 2
+        //       |
+        //       3
+        addNode(0, 2, 1.9);
+        addNode(1, 2, 2.0);
+        addNode(2, 2, 2.1);
+        addNode(3, 1.9, 2.0);
+        addNode(4, 2.1, 2.0);
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+        addEdge(1, 3, true);
+        addEdge(1, 4, true);
+
+        checkResult(0, impossible());
+        checkResult(2, impossible());
+        // at the end of a dead end street the (only) in/out edges are used as restriction for both right and left
+        // side approach
+        checkResult(3, restricted(edge(1, 3), edge(3, 1), edge(1, 3), edge(3, 1)));
+        checkResult(4, restricted(edge(1, 4), edge(4, 1), edge(1, 4), edge(4, 1)));
+    }
+
+    @Test
+    public void unreachable_nodes() {
+        //   1   3
+        //  / \ /
+        // 0   2
+        addNode(0, 1, 1);
+        addNode(1, 2, 1.5);
+        addNode(2, 1, 2);
+        addNode(3, 2, 2.5);
+        addEdge(0, 1, false);
+        addEdge(2, 1, false);
+        addEdge(2, 3, false);
+
+        // we can go to node 1, but never leave it
+        checkResult(1, impossible());
+        // we can leave point 2, but never arrive at it
+        checkResult(2, impossible());
+    }
+
+    @Test
+    public void nodes_with_loops() {
+        // in case there is a loop edge we simply do not apply any restrictions. loops are rather rare and excluded
+        // by the OSM import. Snapping a point onto a tower node that has a loop is even less likely.
+        // If there is a loop there is often no reasonable way to restrict the direction similar to junctions.
+        // 0------1-------2----3
+        // |\     |  \    |\   |\
+        // x-x    x->x    --   ->
+        addNode(0, 2, 0);
+        addNode(1, 2, 1);
+        addNode(2, 2, 2);
+        addNode(3, 2, 3);
+        // make sure graph bounds are valid
+        addNode(4, 5, 5);
+        addEdge(0, 0, true).setWayGeometry(createPointList(1.9, 0, 1.9, 0.1));
+        addEdge(0, 1, true);
+        addEdge(1, 1, false).setWayGeometry(createPointList(1.9, 1, 1.9, 1.1));
+        addEdge(1, 2, true);
+        addEdge(2, 2, true);
+        addEdge(2, 3, true);
+        addEdge(3, 3, false);
+
+        checkResult(0, unrestricted());
+        checkResult(1, unrestricted());
+        checkResult(2, unrestricted());
+        checkResult(3, unrestricted());
+    }
+
+    @Test
+    public void junction() {
+        //      3___
+        //      |   \
+        // 0 -> 1 -> 2 - 5
+        //      |
+        //      4
+        addNode(0, 2.000, 1.990);
+        addNode(1, 2.000, 2.000);
+        addNode(2, 2.000, 2.010);
+        addNode(3, 2.010, 2.000);
+        addNode(4, 1.990, 2.000);
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+        addEdge(1, 3, true);
+        addEdge(2, 3, true);
+        addEdge(1, 4, true);
+        addEdge(2, 5, true);
+
+        // at junctions there is no reasonable way to restrict the directions!
+        checkResult(1, unrestricted());
+        checkResult(2, unrestricted());
+    }
+
+    @Test
+    public void junction_exposed() {
+        // 0  1  2
+        //  \ | /
+        //   \|/
+        //    3
+        addNode(0, 2, 1);
+        addNode(1, 2, 2);
+        addNode(2, 2, 3);
+        addNode(3, 1, 2);
+        addEdge(0, 3, true);
+        addEdge(1, 3, true);
+        addEdge(2, 3, true);
+        checkResult(3, unrestricted());
+    }
+
+    @Test
+    public void duplicateEdges() {
+        // 0 = 1 - 2
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        addNode(2, 0, 2);
+        addEdge(0, 1, true);
+        addEdge(0, 1, true);
+        addEdge(1, 2, true);
+        // if there are multiple incoming/outgoing edges due to duplicate edges its the same as for a junction,
+        // -> we leave the directions unrestricted
+        checkResult(1, unrestricted());
+
+        // for duplicate edges at the end of a dead-end road we also leave the direction unrestricted
+        checkResult(0, unrestricted());
+    }
+
+    @Test
+    public void duplicateEdges_in() {
+        // 0 => 1 - 2
+        addNode(0, 1, 1);
+        addNode(1, 2, 2);
+        addNode(2, 1, 3);
+        // duplicate in edges between 0 and 1 -> we do not apply any restrictions
+        addEdge(0, 1, false);
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+
+        checkResult(1, unrestricted());
+    }
+
+    @Test
+    public void duplicateEdges_out() {
+        // 0 - 1 => 2
+        addNode(0, 1, 1);
+        addNode(1, 2, 2);
+        addNode(2, 1, 3);
+        // duplicate out edges between 1 and 2 -> we do not apply any restrictions
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+        addEdge(1, 2, false);
+
+        checkResult(1, unrestricted());
+    }
+
+    @Test
+    public void simple_road() {
+        //    x   x
+        //  0-1-2-3-4
+        //    x   x
+        addNode(0, 1, 0);
+        addNode(1, 1, 1);
+        addNode(2, 1, 2);
+        addNode(3, 1, 3);
+        addNode(4, 1, 4);
+        // make sure graph bounds are valid
+        addNode(5, 2, 5);
+
+        addEdge(0, 1, true);
+        addEdge(1, 2, true);
+        addEdge(2, 3, true);
+        addEdge(3, 4, true);
+
+        checkResult(1, 1.01, 1, restricted(edge(2, 1), edge(1, 0), edge(0, 1), edge(1, 2)));
+        checkResult(1, 0.99, 1, restricted(edge(0, 1), edge(1, 2), edge(2, 1), edge(1, 0)));
+        checkResult(3, 1.01, 3, restricted(edge(4, 3), edge(3, 2), edge(2, 3), edge(3, 4)));
+        checkResult(3, 0.99, 3, restricted(edge(2, 3), edge(3, 4), edge(4, 3), edge(3, 2)));
+    }
+
+    @Test
+    public void simple_road_one_way() {
+        //     x     x
+        //  0->1->2->3->4
+        //     x     x
+        addNode(0, 1, 0);
+        addNode(1, 1, 1);
+        addNode(2, 1, 2);
+        addNode(3, 1, 3);
+        addNode(4, 1, 4);
+        // make sure graph bounds are valid
+        addNode(5, 2, 5);
+
+        addEdge(0, 1, false);
+        addEdge(1, 2, false);
+        addEdge(2, 3, false);
+        addEdge(3, 4, false);
+
+        // if a location is on the 'wrong'side on a one-way street
+        checkResult(1, 1.01, 1, onlyLeft(edge(0, 1), edge(1, 2)));
+        checkResult(1, 0.99, 1, onlyRight(edge(0, 1), edge(1, 2)));
+        checkResult(3, 1.01, 3, onlyLeft(edge(2, 3), edge(3, 4)));
+        checkResult(3, 0.99, 3, onlyRight(edge(2, 3), edge(3, 4)));
+    }
+
+
+    @Test
+    public void twoOutOneIn_oneWayRight() {
+        //     x
+        // 0 - 1 -> 2
+        //     x
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        addNode(2, 2, 2);
+        addEdge(0, 1, true);
+        addEdge(1, 2, false);
+
+        // we cannot approach the southern target so it is on our left
+        checkResult(1, 0.99, 1, onlyRight(0, 1));
+        // we cannot approach the northern target so it is on our left
+        checkResult(1, 1.01, 1, onlyLeft(0, 1));
+    }
+
+    @Test
+    public void twoOutOneIn_oneWayLeft() {
+        //      x
+        // 0 <- 1 - 2
+        //      x
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        addNode(2, 2, 2);
+        addEdge(1, 0, false);
+        addEdge(1, 2, true);
+
+        checkResult(1, 0.99, 1, onlyLeft(1, 0));
+        checkResult(1, 1.01, 1, onlyRight(1, 0));
+    }
+
+    @Test
+    public void twoInOneOut_oneWayRight() {
+        //     x
+        // 0 - 1 <- 2
+        //     x
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        addNode(2, 2, 2);
+        addEdge(0, 1, true);
+        addEdge(2, 1, false);
+
+        checkResult(1, 0.99, 1, onlyLeft(1, 0));
+        checkResult(1, 1.01, 1, onlyRight(1, 0));
+    }
+
+    @Test
+    public void twoInOneOut_oneWayLeft() {
+        //      x
+        // 0 -> 1 - 2
+        //      x
+        addNode(0, 0, 0);
+        addNode(1, 1, 1);
+        addNode(2, 2, 2);
+        addEdge(0, 1, false);
+        addEdge(2, 1, true);
+
+        checkResult(1, 0.99, 1, onlyRight(0, 1));
+        checkResult(1, 1.01, 1, onlyLeft(0, 1));
+    }
+
+    private void addNode(int nodeId, double lat, double lon) {
+        na.setNode(nodeId, lat, lon);
+    }
+
+    private EdgeIteratorState addEdge(int from, int to, boolean bothDirections) {
+        return g.edge(from, to, 1, bothDirections);
+    }
+
+    private void checkResult(int node, DirectionResolverResult expectedResult) {
+        checkResult(node, g.getNodeAccess().getLat(node), g.getNodeAccess().getLon(node), expectedResult);
+    }
+
+    private void checkResult(int node, double lat, double lon, DirectionResolverResult expectedResult) {
+        DirectionResolver resolver = new DirectionResolver(g, encoder);
+        assertEquals(expectedResult, resolver.resolveDirections(node, new GHPoint(lat, lon)));
+    }
+
+    private int edge(int from, int to) {
+        EdgeExplorer explorer = g.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder.getAccessEnc()));
+        EdgeIterator iter = explorer.setBaseNode(from);
+        while (iter.next()) {
+            if (iter.getAdjNode() == to) {
+                return iter.getEdge();
+            }
+        }
+        throw new IllegalStateException("Could not find edge from: " + from + ", to: " + to);
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index baf8ae858a..e32eb3da49 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -48,7 +48,7 @@
     private final BooleanEncodedValue carManagerRoundabout = carManager.getBooleanEncodedValue(Roundabout.KEY);
     private final BooleanEncodedValue carAccessEnc = encoder.getAccessEnc();
     private final DecimalEncodedValue carAvSpeedEnv = encoder.getAverageSpeedEnc();
-    private final EncodingManager dataFlagManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4)).add(dataFlagEncoder).build();
+    private final EncodingManager dataFlagManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(dataFlagEncoder).build();
     private final EncodingManager mixedEncoders = EncodingManager.create(new CarFlagEncoder(), new FootFlagEncoder());
     private final BooleanEncodedValue mixedManagerRoundabout = mixedEncoders.getBooleanEncodedValue(Roundabout.KEY);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index fe65613253..75c04a7805 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -83,65 +83,58 @@ public void testOneVirtualNode() {
         EdgeIterator iter = expl.setBaseNode(2);
         iter.next();
 
-        QueryGraph queryGraph = new QueryGraph(g);
         QueryResult res = createLocationResult(1, -1, iter, 0, TOWER);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph0 = lookup(res);
         assertEquals(new GHPoint(0, 0), res.getSnappedPoint());
 
         // b)
         res = createLocationResult(1, -1, iter, 1, TOWER);
-        queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph1 = lookup(res);
         assertEquals(new GHPoint(1, 0), res.getSnappedPoint());
         // c)
         iter = expl.setBaseNode(1);
         iter.next();
         res = createLocationResult(1.2, 2.7, iter, 0, TOWER);
-        queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph2 = lookup(res);
         assertEquals(new GHPoint(1, 2.5), res.getSnappedPoint());
 
         // node number stays
-        assertEquals(3, queryGraph.getNodes());
+        assertEquals(3, queryGraph2.getNodes());
 
         // snap directly to pillar node
-        queryGraph = new QueryGraph(g);
         iter = expl.setBaseNode(1);
         iter.next();
         res = createLocationResult(2, 1.5, iter, 1, PILLAR);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph3 = lookup(res);
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
-        assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
+        assertEquals(3, getPoints(queryGraph3, 0, 3).getSize());
+        assertEquals(2, getPoints(queryGraph3, 3, 1).getSize());
 
-        queryGraph = new QueryGraph(g);
         res = createLocationResult(2, 1.7, iter, 1, PILLAR);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph4 = lookup(res);
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
-        assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
+        assertEquals(3, getPoints(queryGraph4, 0, 3).getSize());
+        assertEquals(2, getPoints(queryGraph4, 3, 1).getSize());
 
         // snap to edge which has pillar nodes        
-        queryGraph = new QueryGraph(g);
         res = createLocationResult(1.5, 2, iter, 0, EDGE);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph5 = lookup(res);
         assertEquals(new GHPoint(1.300019, 1.899962), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
-        assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
+        assertEquals(4, getPoints(queryGraph5, 0, 3).getSize());
+        assertEquals(2, getPoints(queryGraph5, 3, 1).getSize());
 
         // snap to edge which has no pillar nodes
-        queryGraph = new QueryGraph(g);
         iter = expl.setBaseNode(2);
         iter.next();
         res = createLocationResult(0.5, 0.1, iter, 0, EDGE);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph6 = lookup(res);
         assertEquals(new GHPoint(0.5, 0), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(2, getPoints(queryGraph, 0, 3).getSize());
-        assertEquals(2, getPoints(queryGraph, 3, 2).getSize());
+        assertEquals(2, getPoints(queryGraph6, 0, 3).getSize());
+        assertEquals(2, getPoints(queryGraph6, 3, 2).getSize());
     }
 
     @Test
@@ -185,8 +178,7 @@ public void testMultipleVirtualNodes() {
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(1);
         iter.next();
         QueryResult res1 = createLocationResult(2, 1.7, iter, 1, PILLAR);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res1));
+        QueryGraph queryGraph = lookup(res1);
         assertEquals(new GHPoint(1.5, 1.5), res1.getSnappedPoint());
         assertEquals(3, res1.getClosestNode());
         assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
@@ -208,8 +200,7 @@ public void testMultipleVirtualNodes() {
         iter.next();
         res1 = createLocationResult(2, 1.7, iter, 1, PILLAR);
         QueryResult res2 = createLocationResult(1.5, 2, iter, 0, EDGE);
-        queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res1, res2));
+        queryGraph = lookup(Arrays.asList(res1, res2));
         assertEquals(4, res2.getClosestNode());
         assertEquals(new GHPoint(1.300019, 1.899962), res2.getSnappedPoint());
         assertEquals(3, res1.getClosestNode());
@@ -232,8 +223,7 @@ public void testOneWay() {
         EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
         QueryResult res1 = createLocationResult(0.1, 0.1, edge, 0, EDGE);
         QueryResult res2 = createLocationResult(0.1, 0.9, edge, 0, EDGE);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res2, res1));
+        QueryGraph queryGraph = lookup(Arrays.asList(res2, res1));
         assertEquals(2, res1.getClosestNode());
         assertEquals(new GHPoint(0, 0.1), res1.getSnappedPoint());
         assertEquals(3, res2.getClosestNode());
@@ -307,8 +297,7 @@ public void testLoopStreet_Issue151() {
         qr.setWayIndex(1);
         qr.calcSnappedPoint(new DistanceCalc2D());
 
-        QueryGraph qg = new QueryGraph(g);
-        qg.lookup(Arrays.asList(qr));
+        QueryGraph qg = lookup(qr);
         EdgeExplorer ee = qg.createEdgeExplorer();
 
         assertEquals(GHUtility.asSet(0, 5, 3), GHUtility.getNeighbors(ee.setBaseNode(1)));
@@ -340,8 +329,7 @@ public void testOneWayLoop_Issue162() {
         qr.setWayIndex(1);
         qr.calcSnappedPoint(new DistanceCalc2D());
 
-        QueryGraph qg = new QueryGraph(g);
-        qg.lookup(Arrays.asList(qr));
+        QueryGraph qg = lookup(qr);
         EdgeExplorer ee = qg.createEdgeExplorer();
         assertTrue(qr.getClosestNode() > 1);
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
@@ -363,8 +351,7 @@ public void testEdgesShareOneNode() {
         QueryResult res1 = createLocationResult(0.5, 0, iter, 0, EDGE);
         iter = GHUtility.getEdge(g, 1, 0);
         QueryResult res2 = createLocationResult(1.5, 2, iter, 0, EDGE);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res1, res2));
+        QueryGraph queryGraph = lookup(Arrays.asList(res1, res2));
         assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
         assertEquals(new GHPoint(1.300019, 1.899962), res2.getSnappedPoint());
         assertNotNull(GHUtility.getEdge(queryGraph, 0, 4));
@@ -378,8 +365,7 @@ public void testAvoidDuplicateVirtualNodesIfIdentical() {
         EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
         QueryResult res1 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
         QueryResult res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res1, res2));
+        QueryGraph queryGraph = lookup(Arrays.asList(res1, res2));
         assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
         assertEquals(new GHPoint(0.5, 0), res2.getSnappedPoint());
         assertEquals(3, res1.getClosestNode());
@@ -391,8 +377,7 @@ public void testAvoidDuplicateVirtualNodesIfIdentical() {
         // now create virtual edges
         edgeState = GHUtility.getEdge(g, 0, 2);
         res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
-        queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(res1, res2));
+        queryGraph = lookup(Arrays.asList(res1, res2));
         // make sure only one virtual node was created
         assertEquals(queryGraph.getNodes(), g.getNodes() + 1);
         EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(0);
@@ -403,9 +388,8 @@ public void testAvoidDuplicateVirtualNodesIfIdentical() {
     public void testGetEdgeProps() {
         initGraph(g);
         EdgeIteratorState e1 = GHUtility.getEdge(g, 0, 2);
-        QueryGraph queryGraph = new QueryGraph(g);
         QueryResult res1 = createLocationResult(0.5, 0, e1, 0, EDGE);
-        queryGraph.lookup(Arrays.asList(res1));
+        QueryGraph queryGraph = lookup(res1);
         // get virtual edge
         e1 = GHUtility.getEdge(queryGraph, res1.getClosestNode(), 0);
         EdgeIteratorState e2 = queryGraph.getEdgeIteratorState(e1.getEdge(), Integer.MIN_VALUE);
@@ -459,8 +443,7 @@ public void testIteration_Issue163() {
         QueryResult res1 = createLocationResult(1.5, 3, it, 1, QueryResult.Position.EDGE);
         QueryResult res2 = createLocationResult(1.5, 7, it, 2, QueryResult.Position.EDGE);
 
-        QueryGraph q = new QueryGraph(g);
-        q.lookup(Arrays.asList(res1, res2));
+        QueryGraph q = lookup(Arrays.asList(res1, res2));
         int nodeC = res1.getClosestNode();
         int nodeD = res2.getClosestNode();
 
@@ -563,8 +546,7 @@ public void testEnforceHeading() {
 
         // query result on first vertical part of way (upward)
         QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(qr));
+        QueryGraph queryGraph = lookup(qr);
 
         // enforce going out north
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
@@ -588,8 +570,7 @@ public void testEnforceHeading() {
 
         // query result on second vertical part of way (downward)
         qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
-        queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(qr));
+        queryGraph = lookup(Arrays.asList(qr));
 
         // enforce going north
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
@@ -615,8 +596,7 @@ public void testunfavorVirtualEdgePair() {
 
         // query result on first vertical part of way (upward)
         QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Arrays.asList(qr));
+        QueryGraph queryGraph = lookup(qr);
 
         // enforce coming in north
         queryGraph.unfavorVirtualEdgePair(2, 1);
@@ -641,12 +621,11 @@ public void testInternalAPIOriginalEdgeKey() {
         initGraph(g);
 
         EdgeExplorer explorer = g.createEdgeExplorer();
-        QueryGraph queryGraph = new QueryGraph(g);
         EdgeIterator iter = explorer.setBaseNode(1);
         assertTrue(iter.next());
         int origEdgeId = iter.getEdge();
         QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph = lookup(res);
 
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
@@ -672,8 +651,8 @@ public void useEECache() {
         assertTrue(iter.next());
         QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
 
-        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);
-        queryGraph.lookup(Arrays.asList(res));
+        QueryGraph queryGraph = lookup(res);
+        queryGraph.setUseEdgeExplorerCache(true);
 
         EdgeExplorer edgeExplorer = queryGraph.createEdgeExplorer();
         // using cache means same reference
@@ -700,8 +679,8 @@ public void useEECache_nestedLoop() {
         assertTrue(iter.next());
         QueryResult res = createLocationResult(0, 0, iter, 1, PILLAR);
 
-        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);
-        queryGraph.lookup(Collections.singletonList(res));
+        QueryGraph queryGraph = lookup(Collections.singletonList(res));
+        queryGraph.setUseEdgeExplorerCache(true);
 
         EdgeExplorer outerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
         EdgeExplorer innerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
@@ -737,13 +716,12 @@ public void testWayGeometry_edge() {
         na.setNode(1, 0.3, 0.3);
         g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(0.1, 0.1, 0.2, 0.2));
 
-        QueryGraph queryGraph = new QueryGraph(g);
         LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory());
         locationIndex.prepareIndex();
         QueryResult qr = locationIndex.findClosest(0.15, 0.15, DefaultEdgeFilter.allEdges(carEncoder));
         assertTrue(qr.isValid());
         assertEquals("this test was supposed to test the Position.EDGE case", EDGE, qr.getSnappedPosition());
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = lookup(qr);
         EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(qr.getClosestNode());
 
         assertTrue(iter.next());
@@ -779,13 +757,12 @@ public void testWayGeometry_pillar() {
         na.setNode(1, 0.5, 0.1);
         g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(0.1, 0.1, 0.2, 0.2));
 
-        QueryGraph queryGraph = new QueryGraph(g);
         LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory());
         locationIndex.prepareIndex();
         QueryResult qr = locationIndex.findClosest(0.2, 0.21, DefaultEdgeFilter.allEdges(carEncoder));
         assertTrue(qr.isValid());
         assertEquals("this test was supposed to test the Position.PILLAR case", PILLAR, qr.getSnappedPosition());
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = lookup(qr);
         EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(qr.getClosestNode());
 
         assertTrue(iter.next());
@@ -827,8 +804,7 @@ public void testVirtualEdgeDistance() {
         LocationIndexTree index = new LocationIndexTree(g, new RAMDirectory());
         index.prepareIndex();
         QueryResult qr = index.findClosest(1.01, 0.7, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = lookup(qr);
         // the sum of the virtual edge distances adjacent to the virtual node should be equal to the distance
         // of the real edge, so the 'distance' from 0 to 1 is the same no matter if we travel on the query graph or the
         // real graph
@@ -841,4 +817,13 @@ public void testVirtualEdgeDistance() {
         assertEquals(directDist, virtualEdgeDistanceSum, 1.e-3);
     }
 
+
+    private QueryGraph lookup(QueryResult res) {
+        return lookup(Collections.singletonList(res));
+    }
+
+    private QueryGraph lookup(List<QueryResult> queryResults) {
+        return QueryGraph.lookup(g, queryResults);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
index ef0ac373be..3c858be02c 100644
--- a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
@@ -142,11 +142,11 @@ private void runRandomTest(Random rnd, int numVirtualNodes) {
 
         int numQueryGraph = 25;
         for (int j = 0; j < numQueryGraph; j++) {
-            QueryGraph queryGraph = new QueryGraph(graph);
-            QueryGraph chQueryGraph = new QueryGraph(chGraph);
             // add virtual nodes and edges, because they can change the routing behavior and/or produce bugs, e.g.
             // when via-points are used
-            addVirtualNodesAndEdges(rnd, queryGraph, chQueryGraph, numVirtualNodes);
+            List<QueryResult> qrs = createQueryResults(rnd, numVirtualNodes);
+            QueryGraph queryGraph = QueryGraph.lookup(graph, qrs);
+            QueryGraph chQueryGraph = QueryGraph.lookup(chGraph, qrs);
 
             int numQueries = 100;
             int numPathsNotFound = 0;
@@ -196,7 +196,7 @@ private void runRandomTest(Random rnd, int numVirtualNodes) {
         }
     }
 
-    private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGraph chQueryGraph, int numVirtualNodes) {
+    private List<QueryResult> createQueryResults(Random rnd, int numVirtualNodes) {
         BBox bbox = graph.getBounds();
         int count = 0;
         List<QueryResult> qrs = new ArrayList<>(numVirtualNodes);
@@ -210,8 +210,7 @@ private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGra
             }
             count++;
         }
-        queryGraph.lookup(qrs);
-        chQueryGraph.lookup(qrs);
+        return qrs;
     }
 
     private QueryResult findQueryResult(Random rnd, BBox bbox) {
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
index 92b3df91e0..8799f1534c 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -38,9 +38,9 @@
 
 import java.util.*;
 
-import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static com.graphhopper.routing.ch.CHParameters.*;
 import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.*;
 
 /**
@@ -836,8 +836,7 @@ public void test_issue1593_full() {
         }
 
         RoutingAlgorithmFactory pch = automaticPrepareCH();
-        QueryGraph queryGraph = new QueryGraph(chGraph);
-        queryGraph.lookup(queryResults);
+        QueryGraph queryGraph = QueryGraph.lookup(chGraph, queryResults);
         RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
                 .traversalMode(TraversalMode.EDGE_BASED)
                 .build());
@@ -884,8 +883,7 @@ public void test_issue_1593_simple() {
         LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
         index.prepareIndex();
         QueryResult qr = index.findClosest(0.1, 0.15, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(chGraph);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(chGraph, Collections.singletonList(qr));
         assertEquals("expected one virtual node", 1, queryGraph.getNodes() - chGraph.getNodes());
         RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
                 .traversalMode(TraversalMode.EDGE_BASED)
@@ -914,12 +912,11 @@ public void test_issue_1623_query_graph_cache() {
         index.prepareIndex();
         QueryResult qr1 = index.findClosest(49.400772, 9.706245, EdgeFilter.ALL_EDGES);
         QueryResult qr2 = index.findClosest(49.403167, 9.704774, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(chGraph);
+        QueryGraph queryGraph = QueryGraph.lookup(chGraph, Arrays.asList(qr1, qr2));
 
         // before fixing #1623 this test only worked for a disabled edge explorer cache
         queryGraph.setUseEdgeExplorerCache(true);
 
-        queryGraph.lookup(Arrays.asList(qr1, qr2));
         assertEquals(2, qr1.getClosestNode());
         assertEquals(3, qr2.getClosestNode());
         RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
@@ -945,8 +942,7 @@ public void testRouteViaVirtualNode() {
         LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
         index.prepareIndex();
         QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(chGraph);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(chGraph, Collections.singletonList(qr));
         assertEquals(3, qr.getClosestNode());
         assertEquals(0, qr.getClosestEdge().getEdge());
         RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
@@ -975,8 +971,7 @@ public void testRouteViaVirtualNode_withAlternative() {
         LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
         index.prepareIndex();
         QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(chGraph);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(chGraph, Collections.singletonList(qr));
         assertEquals(3, qr.getClosestNode());
         assertEquals(0, qr.getClosestEdge().getEdge());
         RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
@@ -1015,8 +1010,7 @@ public void testFiniteUTurnCost_virtualViaNode() {
         index.prepareIndex();
         GHPoint virtualPoint = new GHPoint(0.1, 0.35);
         QueryResult qr = index.findClosest(virtualPoint.lat, virtualPoint.lon, EdgeFilter.ALL_EDGES);
-        QueryGraph chQueryGraph = new QueryGraph(chGraph);
-        chQueryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph chQueryGraph = QueryGraph.lookup(chGraph, Collections.singletonList(qr));
         assertEquals(3, qr.getClosestEdge().getEdge());
         RoutingAlgorithm chAlgo = pch.createAlgo(chQueryGraph, AlgorithmOptions.start()
                 .traversalMode(TraversalMode.EDGE_BASED)
@@ -1026,8 +1020,7 @@ public void testFiniteUTurnCost_virtualViaNode() {
         assertEquals(IntArrayList.from(4, 3, 2, 1, 0, 1, 5, 6), path.calcNodes());
 
         QueryResult qr2 = index.findClosest(virtualPoint.lat, virtualPoint.lon, EdgeFilter.ALL_EDGES);
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.singletonList(qr2));
+        QueryGraph queryGraph = QueryGraph.lookup(graph, Collections.singletonList(qr2));
         assertEquals(3, qr2.getClosestEdge().getEdge());
         Dijkstra dijkstra = new Dijkstra(queryGraph, new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension(), chGraph.getCHProfile().getUTurnCosts()), TraversalMode.EDGE_BASED);
         Path dijkstraPath = dijkstra.calcPath(4, 6);
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 784ba8c75b..36211de90f 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -425,11 +425,11 @@ public void routingWithHeading_fails() {
         LocationIndexTree locationIndex = new LocationIndexTree(graph, new RAMDirectory());
         locationIndex.prepareIndex();
 
-        QueryGraph chQueryGraph = new QueryGraph(lg);
-        chQueryGraph.lookup(Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
+        QueryGraph chQueryGraph = QueryGraph.lookup(lg,
+                Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
 
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
+        QueryGraph queryGraph = QueryGraph.lookup(graph,
+                Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
 
         // without heading
         {
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 7f12a151ee..ef6bcc120e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -501,8 +501,7 @@ public int getNumNodes() {
         qr.setClosestNode(8);
         qr.setWayIndex(0);
         qr.calcSnappedPoint(new DistanceCalc2D());
-        QueryGraph queryGraph = new QueryGraph(lg);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(lg, Collections.singletonList(qr));
 
         // we make sure our weight fine tunings do what they are supposed to
         double weight03 = getWeight(queryGraph, fastestWeighting, 0, 3, false);
diff --git a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
index 33c6ee0e3c..f2f4ce5f2b 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
@@ -164,10 +164,9 @@ public void testLandmarkStorageAndRouting() {
 
         // landmarks with A* and a QueryGraph. We expect slightly less optimal as two more cycles needs to be traversed
         // due to the two more virtual nodes but this should not harm in practise
-        QueryGraph qGraph = new QueryGraph(graph);
         QueryResult fromQR = index.findClosest(-0.0401, 0.2201, EdgeFilter.ALL_EDGES);
         QueryResult toQR = index.findClosest(-0.2401, 0.0601, EdgeFilter.ALL_EDGES);
-        qGraph.lookup(fromQR, toQR);
+        QueryGraph qGraph = QueryGraph.lookup(graph, Arrays.asList(fromQR, toQR));
         RoutingAlgorithm qGraphOneDirAlgo = prepare.getDecoratedAlgorithm(qGraph,
                 new AStar(qGraph, weighting, tm), opts);
         path = qGraphOneDirAlgo.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 9b26da4bd2..6b79951f3d 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -90,19 +90,18 @@ public void testLookupAndCalcPaths_simpleSquareGraph() {
         assertEquals(6, stagePoints.get(1).getClosestNode());
         assertEquals(0, stagePoints.get(2).getClosestNode());
 
-        QueryGraph queryGraph = new QueryGraph(g);
-        queryGraph.lookup(stagePoints);
+        QueryGraph queryGraph = QueryGraph.lookup(g, stagePoints);
         Weighting weighting = new FastestWeighting(carFE);
         List<Path> paths = routingTemplate.calcPaths(
-                queryGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+                queryGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode), carFE);
         // make sure the resulting paths are connected and form a round trip starting and ending at the start node 0
         assertEquals(2, paths.size());
-        assertEquals(IntArrayList.from(new int[]{0, 7, 6, 5}), paths.get(0).calcNodes());
-        assertEquals(IntArrayList.from(new int[]{5, 4, 3, 2, 1, 0}), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(0, 7, 6, 5), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), paths.get(1).calcNodes());
     }
 
     @Test
-    public void testCalcRoundTrip() throws Exception {
+    public void testCalcRoundTrip() {
         Weighting weighting = new FastestWeighting(carFE);
         Graph g = createTestGraph(true);
 
@@ -117,23 +116,21 @@ public void testCalcRoundTrip() throws Exception {
         QueryResult qr6 = locationIndex.findClosest(0.00, 0.10, EdgeFilter.ALL_EDGES);
         assertEquals(6, qr6.getClosestNode());
 
-        QueryGraph qGraph = new QueryGraph(g);
-        qGraph.lookup(qr4, qr5);
+        QueryGraph qGraph = QueryGraph.lookup(g, Arrays.asList(qr4, qr5));
         rTripRouting.setQueryResults(Arrays.asList(qr5, qr4, qr5));
         List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
-                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode), carFE);
         assertEquals(2, paths.size());
-        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), paths.get(0).calcNodes());
-        assertEquals(IntArrayList.from(new int[]{4, 8, 7, 6, 5}), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 3, 4), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(4, 8, 7, 6, 5), paths.get(1).calcNodes());
 
-        qGraph = new QueryGraph(g);
-        qGraph.lookup(qr4, qr6);
+        qGraph = QueryGraph.lookup(g, Arrays.asList(qr4, qr6));
         rTripRouting.setQueryResults(Arrays.asList(qr6, qr4, qr6));
         paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
-                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode), carFE);
         assertEquals(2, paths.size());
-        assertEquals(IntArrayList.from(new int[]{6, 3, 4}), paths.get(0).calcNodes());
-        assertEquals(IntArrayList.from(new int[]{4, 8, 7, 6}), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(6, 3, 4), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(4, 8, 7, 6), paths.get(1).calcNodes());
     }
 
     private Graph createTestGraph(boolean fullGraph) {
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 04adb88b84..957260e602 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.*;
@@ -39,7 +38,7 @@
  */
 public class CarFlagEncoderTest {
     private final EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(new PMap("speed_two_directions=true")),
-            new BikeFlagEncoder(), new FootFlagEncoder()), 8);
+            new BikeFlagEncoder(), new FootFlagEncoder()));
     private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("car");
     private final BooleanEncodedValue roundaboutEnc = em.getBooleanEncodedValue(Roundabout.KEY);
     private final DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
@@ -652,34 +651,4 @@ public void testIssue_1256() {
         assertEquals(2.5, encoder.getFerrySpeed(way), .1);
         assertEquals(.5, lowFactorCar.getFerrySpeed(way), .1);
     }
-
-    @Test
-    public void testAcceptsTurnRelation() {
-        List<String> vehicleTypesExcept = new ArrayList<>();
-        OSMTurnRelation osmTurnRelation = new OSMTurnRelation(1, 1, 1, OSMTurnRelation.Type.NOT);
-        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
-
-        vehicleTypesExcept.add("bus");
-        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
-        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
-
-        vehicleTypesExcept.clear();
-        vehicleTypesExcept.add("vehicle");
-        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
-        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
-
-        vehicleTypesExcept.clear();
-        vehicleTypesExcept.add("motor_vehicle");
-        vehicleTypesExcept.add("vehicle");
-        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
-        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
-
-        vehicleTypesExcept.clear();
-        osmTurnRelation.setVehicleTypeRestricted("bus");
-        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
-        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
-
-        osmTurnRelation.setVehicleTypeRestricted("vehicle");
-        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index e0b17c6fb7..5d84c9ba0c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -60,7 +60,7 @@
     public DataFlagEncoderTest() {
         properties = new PMap();
         encoder = new DataFlagEncoder(properties);
-        encodingManager = new EncodingManager.Builder(8).
+        encodingManager = new EncodingManager.Builder().
                 add(new OSMRoadEnvironmentParser()).
                 add(new OSMRoadClassParser()).
                 add(new OSMRoadAccessParser()).
@@ -83,8 +83,8 @@ public void testNoDefaultEncodedValues() {
     @Test
     public void testSufficientEncoderBitLength() {
         try {
-            EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new DataFlagEncoder(properties)).build();
-            EncodingManager em1 = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(12)).add(new DataFlagEncoder(properties)).build();
+            EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(new DataFlagEncoder(properties)).build();
+            EncodingManager em1 = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(new DataFlagEncoder(properties)).build();
         } catch (Throwable t) {
             fail(t.toString());
         }
@@ -364,7 +364,7 @@ public BBox getBounds() {
         };
 
         DataFlagEncoder tmpEncoder = new DataFlagEncoder(new PMap());
-        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4).add(new SpatialRuleParser(index))).add(tmpEncoder).build();
+        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder().add(new SpatialRuleParser(index))).add(tmpEncoder).build();
         IntEncodedValue countrySpatialIdEnc = em.getIntEncodedValue(Country.KEY);
         EnumEncodedValue<RoadAccess> tmpRoadAccessEnc = em.getEnumEncodedValue(RoadAccess.KEY, RoadAccess.class);
         DecimalEncodedValue tmpCarMaxSpeedEnc = em.getDecimalEncodedValue(MaxSpeed.KEY);
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index f7281ab182..080548ff94 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -78,13 +78,6 @@ public void testWrongEncoders() {
         } catch (Exception ex) {
             assertEquals("You must not register a FlagEncoder (foot) twice!", ex.getMessage());
         }
-
-        try {
-            EncodingManager.create(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
-            fail("There should have been an exception");
-        } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting 36 bits, more than 32 bits of edge flags"));
-        }
     }
 
     @Test
@@ -107,10 +100,7 @@ protected String getPropertiesString() {
 
             @Override
             public boolean acceptsTurnRelation(OSMTurnRelation relation) {
-                if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
-                    return true;
-                }
-                return false;
+                return relation.isVehicleTypeConcernedByTurnRestriction(restrictions);
             }
 
             @Override
@@ -223,7 +213,7 @@ public void testFixWayName() {
 
     @Test
     public void testCompatibilityBug() {
-        EncodingManager manager2 = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2", 8);
+        EncodingManager manager2 = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2");
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
@@ -236,7 +226,7 @@ public void testCompatibilityBug() {
         assertEquals(4, singleSpeed, 1e-3);
         assertEquals(singleSpeed, singleBikeEnc.getSpeed(true, flags), 1e-3);
 
-        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2,bike,foot", 8);
+        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2,bike,foot");
         FootFlagEncoder foot = (FootFlagEncoder) manager.getEncoder("foot");
         BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike2");
 
@@ -254,7 +244,7 @@ public void testCompatibilityBug() {
     public void testSupportFords() {
         // 1) no encoder crossing fords
         String flagEncodersStr = "car,bike,foot";
-        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
+        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
@@ -262,7 +252,7 @@ public void testSupportFords() {
 
         // 2) two encoders crossing fords
         flagEncodersStr = "car,bike|block_fords=false,foot|block_fords=false";
-        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
+        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertFalse(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
@@ -270,7 +260,7 @@ public void testSupportFords() {
 
         // 2) Try combined with another tag
         flagEncodersStr = "car|turn_costs=true|block_fords=true,bike,foot|block_fords=false";
-        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
+        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
@@ -279,7 +269,7 @@ public void testSupportFords() {
 
     @Test
     public void testSharedEncodedValues() {
-        EncodingManager manager = EncodingManager.create("car,foot,bike,motorcycle,mtb", 8);
+        EncodingManager manager = EncodingManager.create("car,foot,bike,motorcycle,mtb");
 
         for (FlagEncoder tmp : manager.fetchEdgeEncoders()) {
             AbstractFlagEncoder encoder = (AbstractFlagEncoder) tmp;
diff --git a/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java
index e5fa5cfeaa..ba955e45bc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java
@@ -23,7 +23,7 @@ public boolean accept(EdgeIteratorState edgeState) {
                 return true;
             }
         };
-        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4)).build();
+        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).build();
         EnumEncodedValue<RoadClass> rcEnc = em.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
         EnumEncodedValue<RoadEnvironment> reEnc = em.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
         SnapPreventionEdgeFilter filter = new SnapPreventionEdgeFilter(trueFilter, rcEnc, reEnc, Arrays.asList("motorway", "ferry"));
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java
index d5b76a70d9..9e24e6a3a5 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java
@@ -21,7 +21,7 @@
     @Before
     public void setUp() {
         parser = new OSMMaxAxleLoadParser();
-        em = new EncodingManager.Builder(4).add(parser).build();
+        em = new EncodingManager.Builder().add(parser).build();
         malEnc = em.getDecimalEncodedValue(MaxAxleLoad.KEY);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java
index 7a3cc149dd..a0f9c516be 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java
@@ -20,7 +20,7 @@
     @Before
     public void setUp() {
         parser = new OSMMaxWeightParser();
-        em = new EncodingManager.Builder(4).add(parser).build();
+        em = new EncodingManager.Builder().add(parser).build();
         mwEnc = em.getDecimalEncodedValue(MaxWeight.KEY);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java
index 3adb03b4b8..b78b72fe83 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java
@@ -21,7 +21,7 @@
     @Before
     public void setUp() {
         parser = new OSMRoadClassParser();
-        em = new EncodingManager.Builder(4).add(parser).build();
+        em = new EncodingManager.Builder().add(parser).build();
         rcEnc = em.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
index 94249da5ec..eaafb2c749 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
@@ -19,7 +19,7 @@
     @Before
     public void setUp() {
         parser = new OSMTollParser();
-        em = new EncodingManager.Builder(4).add(parser).build();
+        em = new EncodingManager.Builder().add(parser).build();
         tollEnc = em.getEnumEncodedValue(Toll.KEY, Toll.class);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java
index eefc29332d..6b5ef7bb09 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java
@@ -21,7 +21,7 @@
     @Before
     public void setUp() {
         parser = new OSMTrackTypeParser();
-        em = new EncodingManager.Builder(4).add(parser).build();
+        em = new EncodingManager.Builder().add(parser).build();
         ttEnc = em.getEnumEncodedValue(TrackType.KEY, TrackType.class);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java
index 916249b18f..11686b4ff2 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java
@@ -1,14 +1,13 @@
 package com.graphhopper.routing.util.parsers;
 
-import static org.junit.Assert.assertEquals;
-
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
 import org.junit.Test;
 
-import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
+import static org.junit.Assert.assertEquals;
 
 public class OSMValueExtractorTest {
-    
-    private final double DELTA = 0.1;
+
+    private final double DELTA = 0.01;
 
     @Test
     public void stringToTons() {
@@ -20,6 +19,7 @@ public void stringToTons() {
         assertEquals(1.5, OSMValueExtractor.stringToTons("3306.9 lbs"), DELTA);
         assertEquals(3, OSMValueExtractor.stringToTons("3 T"), DELTA);
         assertEquals(3, OSMValueExtractor.stringToTons("3ton"), DELTA);
+        assertEquals(10, OSMValueExtractor.stringToTons("10000 kg"), DELTA);
 
         // maximum gross weight
         assertEquals(6, OSMValueExtractor.stringToTons("6t mgw"), DELTA);
@@ -27,10 +27,14 @@ public void stringToTons() {
 
     @Test(expected = NumberFormatException.class)
     public void stringToTonsException() {
-        // Unexpected values
         OSMValueExtractor.stringToTons("weight limit 1.5t");
     }
 
+    @Test(expected = NumberFormatException.class)
+    public void stringToTonsException2() {
+        OSMValueExtractor.stringToTons("");
+    }
+
     @Test
     public void stringToMeter() {
         assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5"), DELTA);
@@ -55,11 +59,22 @@ public void stringToMeter() {
 
         assertEquals(2.743, OSMValueExtractor.stringToMeter("9'"), DELTA);
         assertEquals(2.743, OSMValueExtractor.stringToMeter("9 feet"), DELTA);
+
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("150 cm"), DELTA);
     }
 
     @Test(expected = NumberFormatException.class)
     public void stringToMeterException() {
-        // Unexpected values
         OSMValueExtractor.stringToMeter("height limit 1.5m");
     }
+
+    @Test(expected = NumberFormatException.class)
+    public void stringToMeterException2() {
+        OSMValueExtractor.stringToMeter("");
+    }
+
+    @Test(expected = NumberFormatException.class)
+    public void stringToMeterException3() {
+        OSMValueExtractor.stringToMeter("default");
+    }
 }
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
index 2a28ef42f3..701125d7f7 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
@@ -26,7 +26,7 @@
     @Before
     public void setUp() {
         encoder = new CarFlagEncoder();
-        em = EncodingManager.create(Arrays.asList(encoder), 8);
+        em = EncodingManager.create(Arrays.asList(encoder));
         graph = new GraphBuilder(em).create();
         // 0-1
         graph.edge(0, 1, 1, true);
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java
index 35fb14f139..ff3c942c2b 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java
@@ -205,11 +205,8 @@ public void randomGraph_withQueryGraph() {
             List<QueryResult> chQueryResults = findQueryResults(index, points);
             List<QueryResult> queryResults = findQueryResults(index, points);
 
-            QueryGraph chQueryGraph = new QueryGraph(prepareCH ? chGraph : graph);
-            QueryGraph queryGraph = new QueryGraph(graph);
-
-            chQueryGraph.lookup(chQueryResults);
-            queryGraph.lookup(queryResults);
+            QueryGraph chQueryGraph = QueryGraph.lookup(prepareCH ? chGraph : graph, chQueryResults);
+            QueryGraph queryGraph = QueryGraph.lookup(graph, queryResults);
 
             int source = queryResults.get(0).getClosestNode();
             int target = queryResults.get(1).getClosestNode();
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
index 2ae8440fbf..e45be586e4 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
@@ -45,7 +45,7 @@
 
     public GenericWeightingTest() {
         encoder = new DataFlagEncoder();
-        em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new OSMMaxHeightParser()).
+        em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(new OSMMaxHeightParser()).
                 add(encoder).build();
     }
 
@@ -85,7 +85,7 @@ public void testRoadAttributeRestriction() {
     @Test
     public void testDisabledRoadAttributes() {
         DataFlagEncoder simpleEncoder = new DataFlagEncoder();
-        EncodingManager simpleEncodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(simpleEncoder).build();
+        EncodingManager simpleEncodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(simpleEncoder).build();
         Graph simpleGraph = new GraphBuilder(simpleEncodingManager).create();
 
         ReaderWay way = new ReaderWay(27l);
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 247700dac9..42f05f40d0 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -986,7 +986,7 @@ public String toString() {
             }
         });
         list.add(new TmpCarFlagEncoder(29, 0.001, 0));
-        EncodingManager manager = EncodingManager.create(list, 8);
+        EncodingManager manager = EncodingManager.create(list);
         graph = new GraphHopperStorage(dir, manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
 
         EdgeIteratorState edge = graph.edge(0, 1);
@@ -1035,7 +1035,7 @@ public String toString() {
                 return "car2";
             }
         });
-        manager = EncodingManager.create(list, 20);
+        manager = EncodingManager.create(list);
         graph = new GraphHopperStorage(new RAMDirectory(), manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
         edgeIter = graph.edge(0, 1).set(access0Enc, true).setReverse(access0Enc, false);
         assertTrue(edgeIter.get(access0Enc));
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index de6faa0e6a..23b0a2becd 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -256,10 +256,9 @@ public void testQueryGraph() {
         graph.freeze();
         chGraph.shortcut(0, 1, PrepareEncoder.getScDirMask(), 10, NO_EDGE, NO_EDGE);
 
-        QueryGraph qGraph = new QueryGraph(chGraph);
         QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
         QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
-        qGraph.lookup(fromRes, toRes);
+        QueryGraph qGraph = QueryGraph.lookup(chGraph, Arrays.asList(fromRes, toRes));
 
         Graph baseGraph = qGraph.getBaseGraph();
         EdgeExplorer explorer = baseGraph.createEdgeExplorer();
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
index 7aacb8315d..360db094ff 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
@@ -36,7 +36,7 @@
     public GraphHopperStorageForDataFlagEncoderTest() {
         properties = new PMap();
         encoder = new DataFlagEncoder(properties);
-        encodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).
+        encodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).
                 add(new OSMMaxWidthParser()).add(new OSMMaxHeightParser()).add(new OSMMaxWeightParser()).add(encoder).build();
     }
 
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 5578818678..5b3e140e6a 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.coll.GHIntLongHashMap;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -67,6 +68,19 @@ Graph initUnsorted(Graph g) {
         return g;
     }
 
+    double getLengthOfAllEdges(Graph graph) {
+        double distance = 0;
+        DistanceCalc calc = new DistanceCalc2D();
+        AllEdgesIterator iter = graph.getAllEdges();
+        while (iter.next()) {
+            // This is meant to verify that all of the same edges (including tower nodes)
+            // are included in the copied graph. Can not use iter.getDistance() since it
+            // does not verify new geometry. See #1732
+            distance += iter.fetchWayGeometry(3).calcDistance(calc);
+        }
+        return distance;
+    }
+
     @Test
     public void testSort() {
         Graph g = initUnsorted(createGraph());
@@ -80,6 +94,7 @@ public void testSort() {
         assertEquals(3.0, na.getLatitude(4), 1e-4); // 3
         assertEquals(5.0, na.getLatitude(5), 1e-4); // 7
         assertEquals(4.2, na.getLatitude(6), 1e-4); // 5
+        assertEquals(getLengthOfAllEdges(g), getLengthOfAllEdges(newG), 1e-4);
     }
 
     @Test
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 2e1ff69096..5e6f36bb81 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -6,7 +6,6 @@
 
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md).
-People with IDE knowledge can directly jump to [Start Development](#start-development).
 
 To proceed install `git` and `openjdk8` or `openjdk11`. Get the a jdk from your package manager, 
 [AdoptOpenJDK](https://adoptopenjdk.net/) or [Red Hat](https://github.com/ojdkbuild/ojdkbuild/releases).
@@ -15,7 +14,7 @@ Then do:
 
 ```bash
 git clone git://github.com/graphhopper/graphhopper.git
-cd graphhopper; git checkout master
+cd graphhopper; git checkout 0.13
 # fetches main.js, can be omitted if no UI is needed
 cd web/src/main/resources/ && ZFILE=/tmp/gh.jar && wget -O $ZFILE "https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.graphhopper&a=graphhopper-web&v=LATEST" && unzip $ZFILE assets/js/main.js && rm $ZFILE && cd ../../../..
 ./graphhopper.sh -a web -i europe_germany_berlin.pbf
@@ -48,7 +47,9 @@ before running `graphhopper.sh`.
 
 ## Start Development
 
-Open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
+First you need to run the commands given in section [Try out](#try-out), if you have not done so yet.
+
+Then open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
 
 ### Running & Debbuging with IntelliJ
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index df65883599..4faa72dad0 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -465,8 +465,7 @@ public GHResponse route(Request request) {
                     tostation.setClosestNode(tonode);
                     points.add(graphHopperStorage.getNodeAccess().getLat(tonode), graphHopperStorage.getNodeAccess().getLon(tonode));
 
-                    QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
-                    queryGraph.lookup(Collections.emptyList());
+                    QueryGraph queryGraph = QueryGraph.lookup(graphHopperStorage, Collections.emptyList());
                     final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, true, 5.0);
 
                     MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index 97eaa2cf1d..a21ba16aa3 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -25,8 +25,6 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
-import com.graphhopper.util.shapes.GHPoint;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -54,7 +52,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()));
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index c35bbf9b46..1832730587 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -65,7 +65,7 @@ public static void init() {
         final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
 
-        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder));
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 7a9c7eb406..612044459b 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -53,7 +53,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()));
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
diff --git a/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
index da31774cc7..947c8b074d 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
@@ -54,7 +54,7 @@
         final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
 
-        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder));
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 8940037718..4c09bb88d4 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -59,7 +59,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), ptFlagEncoder, new FootFlagEncoder()), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), ptFlagEncoder, new FootFlagEncoder()));
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
index 5aba5806ed..1c025ae60e 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -37,6 +37,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import static org.assertj.core.util.Lists.emptyList;
 import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
 import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
 import static org.hamcrest.core.StringContains.containsString;
@@ -52,7 +53,7 @@
     public GraphExplorerTest() {
         pt = new PtFlagEncoder();
         foot = new FootFlagEncoder();
-        encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
+        encodingManager = EncodingManager.create(Arrays.asList(pt, foot));
     }
 
     @Test
@@ -67,8 +68,7 @@ public void testNonEmptyGraph() {
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
 
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.emptyList());
+        QueryGraph queryGraph = QueryGraph.lookup(graph, Collections.emptyList());
         GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
 
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
@@ -93,8 +93,7 @@ public void testExtraEdgesWithEmptyGraph() {
         extraEdges.add(g);
 
         WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
-        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
-        queryGraph.lookup(Collections.emptyList());
+        QueryGraph queryGraph = QueryGraph.lookup(wrapperGraph, Collections.emptyList());
         GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
@@ -129,8 +128,7 @@ public void testExtraEdgesWithNonEmptyGraph() {
         extraEdges.add(h);
 
         WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
-        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
-        queryGraph.lookup(Collections.emptyList());
+        QueryGraph queryGraph = QueryGraph.lookup(wrapperGraph, emptyList());
         GraphExplorer forward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains("0->1"));
@@ -181,7 +179,6 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         extraEdges.add(h);
 
         WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
-        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
 
         QueryResult point1 = new QueryResult(3.5, 3.5);
         QueryResult point2 = new QueryResult(4.5, 4.5);
@@ -195,7 +192,7 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         point2.setWayIndex(0);
         point2.setSnappedPosition(QueryResult.Position.EDGE);
         point2.calcSnappedPoint(new DistanceCalc2D());
-        queryGraph.lookup(point1, point2);
+        QueryGraph queryGraph = QueryGraph.lookup(wrapperGraph, Arrays.asList(point1, point2));
 
         GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
index 9fd42f3775..0ebc71548f 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
@@ -39,7 +39,7 @@
     public WrapperGraphTest() {
         pt = new PtFlagEncoder();
         foot = new FootFlagEncoder();
-        encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
+        encodingManager = EncodingManager.create(Arrays.asList(pt, foot));
     }
 
     @Test
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index fee1d8ddb6..c49fab4060 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -201,10 +201,12 @@ void preProcess(File osmFile) {
     }
 
     private void prepareRestrictionRelation(ReaderRelation relation) {
-        OSMTurnRelation turnRelation = createTurnRelation(relation);
-        if (turnRelation != null) {
-            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
-            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+        List<OSMTurnRelation> turnRelations = createTurnRelations(relation);
+        for (OSMTurnRelation turnRelation : turnRelations) {
+            if (turnRelation != null) {
+                getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+                getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+            }
         }
     }
 
@@ -412,11 +414,11 @@ void processWay(ReaderWay way) {
 
     public void processRelation(ReaderRelation relation) {
         if (relation.hasTag("type", "restriction")) {
-            OSMTurnRelation turnRelation = createTurnRelation(relation);
-            if (turnRelation != null) {
-                GraphExtension extendedStorage = graph.getExtension();
-                if (extendedStorage instanceof TurnCostExtension) {
-                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+            GraphExtension extendedStorage = graph.getExtension();
+            if (extendedStorage instanceof TurnCostExtension) {
+                TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+                List<OSMTurnRelation> turnRelations = createTurnRelations(relation);
+                for (OSMTurnRelation turnRelation : turnRelations) {
                     Collection<TurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
                     for (TurnCostTableEntry entry : entries) {
                         tcs.addTurnInfo(entry.edgeFrom, entry.nodeVia, entry.edgeTo, entry.flags);
@@ -861,17 +863,10 @@ private long createNewNodeId() {
      *
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
-    OSMTurnRelation createTurnRelation(ReaderRelation relation) {
-        String tagRestriction = "";
-        String vehicleTypeRestricted = "";
+    List<OSMTurnRelation> createTurnRelations(ReaderRelation relation) {
+        List<OSMTurnRelation> osmTurnRelations = new ArrayList<>();
+        String vehicleTypeRestricted= "";
         List<String> vehicleTypesExcept = new ArrayList<>();
-        if (relation.hasTag("restriction")) {
-            tagRestriction = relation.getTag("restriction");
-        } else if (relation.hasTagStartsWith("restriction:")) {
-            vehicleTypeRestricted = relation.getKeyStartsWith("restriction:");
-            tagRestriction = relation.getTag(vehicleTypeRestricted);
-            vehicleTypeRestricted = vehicleTypeRestricted.replace("restriction:", "").trim();
-        }
         if (relation.hasTag("except")) {
             String tagExcept = relation.getTag("except");
             if (!Helper.isEmpty(tagExcept)) {
@@ -880,7 +875,29 @@ OSMTurnRelation createTurnRelation(ReaderRelation relation) {
                     vehicleTypesExcept.add(vehicleType.trim());
             }
         }
-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(tagRestriction);
+        if (relation.hasTag("restriction")) {
+            OSMTurnRelation osmTurnRelation = createTurnRelation(relation.getTag("restriction"), relation, vehicleTypeRestricted, vehicleTypesExcept);
+            if (osmTurnRelation != null) {
+                osmTurnRelations.add(osmTurnRelation);
+            }
+            return osmTurnRelations;
+        }
+        if (relation.hasTagWithKeyPrefix("restriction:")) {
+            List<String> vehicleTypesRestricted = relation.getKeysWithPrefix("restriction:");
+            for (String vehicleType : vehicleTypesRestricted) {
+                String restrictionType = relation.getTag(vehicleType);
+                vehicleTypeRestricted = vehicleType.replace("restriction:", "").trim();
+                OSMTurnRelation osmTurnRelation = createTurnRelation(restrictionType, relation, vehicleTypeRestricted, vehicleTypesExcept);
+                if (osmTurnRelation != null) {
+                    osmTurnRelations.add(osmTurnRelation);
+                }
+            }
+        }
+        return osmTurnRelations;
+    }
+
+    OSMTurnRelation createTurnRelation(String restrictionType, ReaderRelation relation, String vehicleTypeRestricted, List<String> vehicleTypesExcept) {
+        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(restrictionType);
         if (type != OSMTurnRelation.Type.UNSUPPORTED) {
             long fromWayID = -1;
             long viaNodeID = -1;
@@ -900,7 +917,7 @@ OSMTurnRelation createTurnRelation(ReaderRelation relation) {
             if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0) {
                 OSMTurnRelation osmTurnRelation = new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
                 osmTurnRelation.setVehicleTypeRestricted(vehicleTypeRestricted);
-                osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+                osmTurnRelation.setVehicleTypesExcept(vehicleTypesExcept);
                 return osmTurnRelation;
             }
         }
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 6f99e72414..6275d5dd27 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -37,6 +37,8 @@
 import java.util.*;
 
 import static com.graphhopper.util.Parameters.Algorithms.*;
+import static com.graphhopper.util.Parameters.CurbSides.*;
+import static java.util.Arrays.asList;
 import static org.junit.Assert.*;
 
 /**
@@ -244,14 +246,14 @@ public void testPointHint() {
         GHRequest req = new GHRequest(49.46553, 11.154669, 49.465244, 11.152577).
                 setVehicle("car").setWeighting("fastest");
 
-        req.setPointHints(new ArrayList<>(Arrays.asList("Laufamholzstraße, 90482, Nürnberg, Deutschland", "")));
+        req.setPointHints(new ArrayList<>(asList("Laufamholzstraße, 90482, Nürnberg, Deutschland", "")));
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         GHPoint snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465686, snappedPoint.getLat(), .000001);
         assertEquals(11.154605, snappedPoint.getLon(), .000001);
 
-        req.setPointHints(new ArrayList<>(Arrays.asList("", "")));
+        req.setPointHints(new ArrayList<>(asList("", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         snappedPoint = rsp.getBest().getWaypoints().get(0);
@@ -259,7 +261,7 @@ public void testPointHint() {
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
 
         // Match to closest edge, since hint was not found
-        req.setPointHints(new ArrayList<>(Arrays.asList("xy", "")));
+        req.setPointHints(new ArrayList<>(asList("xy", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         snappedPoint = rsp.getBest().getWaypoints().get(0);
@@ -273,7 +275,7 @@ public void testNorthBayreuthDestination() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).addAll(new DefaultFlagEncoderFactory(), "car,generic").build());
+                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).addAll(new DefaultFlagEncoderFactory(), "car,generic").build());
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest(49.985307, 11.50628, 49.985731, 11.507465).
@@ -297,7 +299,7 @@ public void testNorthBayreuthBlockedEdges() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new CarFlagEncoder()).build());
+                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).add(new CarFlagEncoder()).build());
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest(49.985272, 11.506151, 49.986107, 11.507202);
@@ -619,7 +621,7 @@ public void testSRTMWithInstructions() {
     public void testSRTMWithoutTunnelInterpolation() {
         GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
-                .setEncodingManager(EncodingManager.create(importVehicles, 8));
+                .setEncodingManager(EncodingManager.create(importVehicles));
 
         tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
@@ -645,7 +647,7 @@ public void testSRTMWithoutTunnelInterpolation() {
     public void testSRTMWithTunnelInterpolation() {
         GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
-                .setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).addAll(new DefaultFlagEncoderFactory(), genericImportVehicles).build());
+                .setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).addAll(new DefaultFlagEncoderFactory(), genericImportVehicles).build());
 
         tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
@@ -1154,4 +1156,100 @@ public void testEncoderWithTurnCostSupport_stillAllows_nodeBasedRouting() {
         assertEquals("there should not be an error, but was: " + rsp.getErrors(), 0, rsp.getErrors().size());
     }
 
+    @Test
+    public void testCurbSides() {
+        GraphHopper h = new GraphHopperOSM().
+                setOSMFile(DIR + "/north-bayreuth.osm.gz").
+                setCHEnabled(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
+        h.getCHFactoryDecorator()
+                .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE);
+        h.importOrLoad();
+
+        // depending on the curbside parameters we take very different routes
+        GHPoint p = new GHPoint(50.015072, 11.499145);
+        GHPoint q = new GHPoint(50.014141, 11.497552);
+        final String itz = "Itzgrund";
+        final String rotmain = "An den Rotmainauen";
+        final String bayreuth = "Bayreuther Straße, KU 18";
+        final String kulmbach = "Kulmbacher Straße, KU 18";
+        final String adamSeiler = "Adam-Seiler-Straße";
+        final String friedhof = "Friedhofsweg";
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_RIGHT), 344, asList(itz, rotmain, rotmain));
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_LEFT), 1564, asList(itz, rotmain, rotmain, bayreuth, kulmbach, adamSeiler, adamSeiler, friedhof, kulmbach, rotmain));
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_RIGHT), 1199, asList(itz, bayreuth, kulmbach, adamSeiler, adamSeiler, friedhof, kulmbach, itz, rotmain, rotmain));
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_LEFT), 266, asList(itz, bayreuth, rotmain));
+        // without restricting anything we get the shortest path
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_ANY, CURBSIDE_ANY), 266, asList(itz, bayreuth, rotmain));
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_ANY, ""), 266, asList(itz, bayreuth, rotmain));
+        assertCurbSidesPath(h, p, q, Collections.<String>emptyList(), 266, asList(itz, bayreuth, rotmain));
+    }
+
+    @Test
+    public void testForceCurbSides() {
+        GraphHopper h = new GraphHopperOSM().
+                setOSMFile(DIR + "/monaco.osm.gz").
+                setCHEnabled(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
+        h.getCHFactoryDecorator()
+                .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE);
+        h.importOrLoad();
+
+        // depending on the curbside parameters we take very different routes
+        //    p
+        //    ---->----
+        //            q
+        GHPoint p = new GHPoint(43.738399, 7.420782);
+        GHPoint q = new GHPoint(43.737949, 7.423523);
+        final String boulevard = "Boulevard de Suisse";
+        final String avenue = "Avenue de la Costa";
+        assertCurbSidesPathError(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_RIGHT), "Impossible curbside constraint: 'curbside=right' at point 0", true);
+        assertCurbSidesPathError(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_LEFT), "Impossible curbside constraint: 'curbside=right' at point 0", true);
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_RIGHT), 463, asList(boulevard, avenue, avenue));
+        assertCurbSidesPathError(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_LEFT), "Impossible curbside constraint: 'curbside=left' at point 1", true);
+        // without restricting anything we get the shortest path
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_ANY, CURBSIDE_ANY), 463, asList(boulevard, avenue, avenue));
+        assertCurbSidesPath(h, p, q, Collections.<String>emptyList(), 463, asList(boulevard, avenue, avenue));
+        // if we set force_curbside to false impossible curbside constraints will be ignored
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_RIGHT), 463, asList(boulevard, avenue, avenue), false);
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_RIGHT, CURBSIDE_LEFT), 463, asList(boulevard, avenue, avenue), false);
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_RIGHT), 463, asList(boulevard, avenue, avenue), false);
+        assertCurbSidesPath(h, p, q, asList(CURBSIDE_LEFT, CURBSIDE_LEFT), 463, asList(boulevard, avenue, avenue), false);
+    }
+
+    private void assertCurbSidesPath(GraphHopper tmpHopper, GHPoint source, GHPoint target, List<String> curbSides, int expectedDistance, List<String> expectedStreets) {
+        assertCurbSidesPath(tmpHopper, source, target, curbSides, expectedDistance, expectedStreets, true);
+    }
+
+    private void assertCurbSidesPath(GraphHopper tmpHopper, GHPoint source, GHPoint target, List<String> curbSides, int expectedDistance, List<String> expectedStreets, boolean force) {
+        GHResponse rsp = calcCurbSidePath(tmpHopper, source, target, curbSides, force);
+        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
+        PathWrapper path = rsp.getBest();
+        List<String> streets = new ArrayList<>(path.getInstructions().size());
+        for (Instruction instruction : path.getInstructions()) {
+            if (!Helper.isEmpty(instruction.getName())) {
+                streets.add(instruction.getName());
+            }
+        }
+        assertEquals(expectedStreets, streets);
+        assertEquals(expectedDistance, path.getDistance(), 1);
+    }
+
+    private void assertCurbSidesPathError(GraphHopper tmpHopper, GHPoint source, GHPoint target, List<String> curbSides, String errorMessage, boolean force) {
+        GHResponse rsp = calcCurbSidePath(tmpHopper, source, target, curbSides, force);
+        assertTrue(rsp.hasErrors());
+        assertTrue("unexpected error. expected message containing: " + errorMessage + ", but got: " +
+                rsp.getErrors(), rsp.getErrors().toString().contains(errorMessage));
+    }
+
+    private GHResponse calcCurbSidePath(GraphHopper tmpHopper, GHPoint source, GHPoint target, List<String> curbSides, boolean force) {
+        GHRequest req = new GHRequest(source, target);
+        req.getHints().put(Routing.EDGE_BASED, true);
+        req.getHints().put(Routing.FORCE_CURBSIDE, force);
+        req.setCurbSides(curbSides);
+        return tmpHopper.route(req);
+    }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index 087b20de8c..1b1158a25c 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -446,22 +446,6 @@ public void testFailsForWrongConfig() {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
 
-        // different bytesForFlags should fail to load
-        instance = new GraphHopperOSM().init(
-                new CmdArgs().
-                        put("datareader.file", testOsm3).
-                        put("datareader.dataaccess", "RAM").
-                        put("graph.flag_encoders", "foot,car").
-                        put("graph.bytes_for_flags", 8).
-                        put(Parameters.CH.PREPARE + "weightings", "no")).
-                setDataReaderFile(testOsm3);
-        try {
-            instance.load(ghLoc);
-            fail();
-        } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.bytes_for_flags (8) is not equal to loaded 4"));
-        }
-
         // different order is no longer okay, see #350
         try {
             GraphHopper tmpGH = new GraphHopperOSM().init(new CmdArgs().
@@ -918,7 +902,7 @@ public void testMultipleCHPreparationsInParallel() {
         // try all parallelization modes        
         for (int threadCount = 1; threadCount < 6; threadCount++) {
             EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
-                    new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()), 8);
+                    new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()));
 
             GraphHopper tmpGH = new GraphHopperOSM().
                     setStoreOnFlush(false).
@@ -959,7 +943,7 @@ public void testMultipleLMPreparationsInParallel() {
         // try all parallelization modes
         for (int threadCount = 1; threadCount < 6; threadCount++) {
             EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
-                    new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()), 8);
+                    new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()));
 
             GraphHopper tmpGH = new GraphHopperOSM().
                     setStoreOnFlush(false).
@@ -1032,7 +1016,7 @@ public void testGetWeightingForCH() {
 
     @Test
     public void testGetMultipleWeightingsForCH() {
-        EncodingManager em = EncodingManager.create(Collections.singletonList(new CarFlagEncoder()), 8);
+        EncodingManager em = EncodingManager.create(Collections.singletonList(new CarFlagEncoder()));
 
         GraphHopper tmpGH = new GraphHopperOSM().
                 setStoreOnFlush(false).
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 9fdcd38584..77608f34da 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -67,6 +67,7 @@
     private final String fileTurnRestrictions = "test-restrictions.xml";
     private final String fileRoadAttributes = "test-road-attributes.xml";
     private final String fileConditionalTurnRestrictions = "test-conditional-turn-restrictions.xml";
+    private final String fileMultipleConditionalTurnRestrictions = "test-multiple-conditional-turn-restrictions.xml";
     private final String dir = "./target/tmp/test-db";
     private CarFlagEncoder carEncoder;
     private BooleanEncodedValue carAccessEnc;
@@ -562,7 +563,7 @@ public void testTurnRestrictions() {
     public void testRoadAttributes() {
         GraphHopper hopper = new GraphHopperFacade(fileRoadAttributes);
         DataFlagEncoder dataFlagEncoder = new DataFlagEncoder();
-        hopper.setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).
+        hopper.setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder()).
                 add(new OSMMaxWidthParser()).add(new OSMMaxHeightParser()).add(new OSMMaxWeightParser()).
                 add(dataFlagEncoder).build());
         hopper.importOrLoad();
@@ -732,7 +733,7 @@ public void testTurnFlagCombination() {
         CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
         FootFlagEncoder foot = new FootFlagEncoder();
         BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
-        EncodingManager manager = EncodingManager.create(Arrays.asList(bike, foot, car), 4);
+        EncodingManager manager = EncodingManager.create(Arrays.asList(bike, foot, car));
 
         GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
         OSMReader reader = new OSMReader(ghStorage) {
@@ -864,6 +865,45 @@ public void testConditionalTurnRestriction() {
         assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)));
     }
 
+    @Test
+    public void testMultipleTurnRestrictions() {
+        GraphHopper hopper = new GraphHopperFacade(fileMultipleConditionalTurnRestrictions, true, "").
+                importOrLoad();
+
+        Graph graph = hopper.getGraphHopperStorage();
+        assertEquals(5, graph.getNodes());
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
+
+        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
+        int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
+        int n3 = AbstractGraphStorageTester.getIdOf(graph, 52, 11);
+        int n4 = AbstractGraphStorageTester.getIdOf(graph, 52, 12);
+        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
+
+        int edge1_2 = GHUtility.getEdge(graph, n1, n2).getEdge();
+        int edge2_3 = GHUtility.getEdge(graph, n2, n3).getEdge();
+        int edge3_4 = GHUtility.getEdge(graph, n3, n4).getEdge();
+        int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
+        int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
+
+        // (1-2)->(2-3) no_right_turn for motorcar and bus
+        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_2, n2, edge2_3)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_2, n2, edge2_3)));
+
+        // (3-4)->(4-5) no_right_turn for motorcycle and motorcar
+        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge3_4, n4, edge4_5)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge3_4, n4, edge4_5)));
+
+        // (5-1)->(1-2) no_right_turn for bus and psv except for motorcar and bicycle
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)));
+
+        // (5-1)->(1-2) no_right_turn for motorcar and motorcycle except for bus and bicycle
+        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge5_1, n1, edge1_2)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge5_1, n1, edge1_2)));
+    }
+
     @Test
     public void testPreferredLanguage() {
         GraphHopper hopper = new GraphHopperFacade(file1, false, "de").importOrLoad();
@@ -936,7 +976,7 @@ protected DataReader importData() {
                     throw new RuntimeException(e);
                 }
             }
-        }.setEncodingManager(new EncodingManager.Builder(4).add(carEncoder = new CarFlagEncoder()).add(new OSMRoadClassParser()).build()).
+        }.setEncodingManager(new EncodingManager.Builder().add(carEncoder = new CarFlagEncoder()).add(new OSMRoadClassParser()).build()).
                 setGraphHopperLocation(dir).setCHEnabled(false).
                 importOrLoad();
 
@@ -970,7 +1010,7 @@ public GraphHopperFacade(String osmFile, boolean turnCosts, String prefLang) {
             }
 
             footEncoder = new FootFlagEncoder();
-            setEncodingManager(new EncodingManager.Builder(4).add(footEncoder).add(carEncoder).add(bikeEncoder).
+            setEncodingManager(new EncodingManager.Builder().add(footEncoder).add(carEncoder).add(bikeEncoder).
                     setPreferredLanguage(prefLang).build());
             carAccessEnc = carEncoder.getAccessEnc();
         }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
index 65fcb06154..3847f8284a 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
@@ -27,12 +27,17 @@
 import com.graphhopper.util.EdgeExplorer;
 import org.junit.Test;
 
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
@@ -98,4 +103,34 @@ public long getOsmIdOfInternalEdge(int edgeId) {
         assertEquals(3, entry.nodeVia);
     }
 
+    @Test
+    public void testAcceptsTurnRelation() {
+        List<String> vehicleTypes = new ArrayList<>(Arrays.asList("motorcar", "motor_vehicle", "vehicle"));
+        List<String> vehicleTypesExcept = new ArrayList<>();
+        OSMTurnRelation osmTurnRelation = new OSMTurnRelation(1, 1, 1, OSMTurnRelation.Type.NOT);
+        assertTrue(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+
+        vehicleTypesExcept.add("bus");
+        osmTurnRelation.setVehicleTypesExcept(vehicleTypesExcept);
+        assertTrue(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+
+        vehicleTypesExcept.clear();
+        vehicleTypesExcept.add("vehicle");
+        osmTurnRelation.setVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+
+        vehicleTypesExcept.clear();
+        vehicleTypesExcept.add("motor_vehicle");
+        vehicleTypesExcept.add("vehicle");
+        osmTurnRelation.setVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+
+        vehicleTypesExcept.clear();
+        osmTurnRelation.setVehicleTypeRestricted("bus");
+        osmTurnRelation.setVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+
+        osmTurnRelation.setVehicleTypeRestricted("vehicle");
+        assertTrue(osmTurnRelation.isVehicleTypeConcernedByTurnRestriction(vehicleTypes));
+    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index f3ef03f868..6f564e8e5f 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -556,7 +556,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
                     setCHEnabled(withCH).
                     setDataReaderFile(osmFile).
                     setGraphHopperLocation(graphFile).
-                    setEncodingManager(new EncodingManager.Builder(8).addAll(new DefaultFlagEncoderFactory(), importVehicles).build());
+                    setEncodingManager(new EncodingManager.Builder().addAll(new DefaultFlagEncoderFactory(), importVehicles).build());
 
             if (osmFile.contains("krautsand"))
                 hopper.setMinNetworkSize(0, 0);
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-multiple-conditional-turn-restrictions.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-multiple-conditional-turn-restrictions.xml
new file mode 100644
index 0000000000..c5bab554a3
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-multiple-conditional-turn-restrictions.xml
@@ -0,0 +1,96 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+    <!-- 
+       1~~~2
+       |   |
+       |   3
+       |   |
+       5~~~4
+       
+       
+      (1,2)->(2,3): no_right_turn
+      (3,4)->(4,5): no_right_turn
+      (4,5)->(5,1): no_right_turn
+      (5,1)->(1,2): no_right_turn
+    -->
+
+    <node id="1" lat="50" lon="10"> </node>
+    <node id="2" lat="52" lon="10"> </node>
+    <node id="3" lat="52" lon="11"> </node>
+    <node id="4" lat="52" lon="12"> </node>
+    <node id="5" lat="50" lon="12"> </node>
+                      
+    <!-- 1-2 -->
+    <way id="12">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <tag k="highway" v="motorway" />
+    </way>    
+    
+    <!-- 2-3 -->
+    <way id="23">
+        <nd ref="2"/>        
+        <nd ref="3"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 3-4 -->
+    <way id="34">
+        <nd ref="3"/>     
+        <nd ref="4"/>
+        <tag k="highway" v="motorway" />
+    </way>     
+    
+    <!-- 4-5 -->
+    <way id="45">
+        <nd ref="5"/>     
+        <nd ref="4"/>
+        <tag k="highway" v="motorway" />
+    </way>  
+    
+    <!-- 5-1 -->
+    <way id="51">
+        <nd ref="1"/>     
+        <nd ref="5"/>
+        <tag k="highway" v="motorway" />
+    </way>
+        
+    <relation id="1001">
+        <member type="way" ref="12" role="from"/>
+        <member type="way" ref="23" role="to"/>
+        <member type="node" ref="2" role="via"/>
+        <tag k="restriction:motorcar" v="no_right_turn"/>
+		<tag k="restriction:bus" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+    
+    <relation id="1002">
+        <member type="way" ref="34" role="from"/>
+        <member type="way" ref="45" role="to"/>
+        <member type="node" ref="4" role="via"/>
+        <tag k="restriction:motorcycle" v="no_right_turn"/>
+		<tag k="restriction:motorcar" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+
+    <relation id="1003">
+        <member type="way" ref="45" role="from"/>
+        <member type="way" ref="51" role="to"/>
+        <member type="node" ref="5" role="via"/>
+        <tag k="restriction:bus" v="no_right_turn"/>
+        <tag k="restriction:psv" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+        <tag k="except" v="motorcar;bicycle"/>
+    </relation>
+    
+    <relation id="1004">
+        <member type="way" ref="51" role="from"/>
+        <member type="way" ref="12" role="to"/>
+        <member type="node" ref="1" role="via"/>
+        <tag k="restriction:motorcar" v="no_right_turn"/>
+		<tag k="restriction:motorcycle" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+		<tag k="except" v="bus;bicycle"/>
+    </relation>
+    
+</osm>
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index e7b3316070..84fba8f53a 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -140,11 +140,14 @@ protected DataReader importData() throws IOException {
             maxNode = g.getNodes();
             boolean isCH = false;
             boolean isLM = false;
+            final boolean runSlow = args.getBool("measurement.run_slow_routing", true);
             GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
             printMiscUnitPerfTests(g, isCH, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
-            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr,
-                    true, false, -1, true, false);
+            if (runSlow) {
+                printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr,
+                        true, false, -1, true, false);
+            }
 
             if (hopper.getLMFactoryDecorator().isEnabled()) {
                 System.gc();
@@ -429,6 +432,7 @@ private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, f
 
         final EdgeExplorer edgeExplorer = g.createEdgeExplorer(DefaultEdgeFilter.allEdges(hopper.getEncodingManager().getEncoder(vehicle)));
         final AtomicLong visitedNodesSum = new AtomicLong(0);
+        final AtomicLong maxVisitedNodes = new AtomicLong(0);
 //        final AtomicLong extractTimeSum = new AtomicLong(0);
 //        final AtomicLong calcPointsTimeSum = new AtomicLong(0);
 //        final AtomicLong calcDistTimeSum = new AtomicLong(0);
@@ -496,7 +500,12 @@ else if (!toLowerCase(rsp.getErrors().get(0).getMessage()).contains("not found")
 
                 PathWrapper arsp = rsp.getBest();
                 if (!warmup) {
-                    visitedNodesSum.addAndGet(rsp.getHints().getLong("visited_nodes.sum", 0));
+                    long visitedNodes = rsp.getHints().getLong("visited_nodes.sum", 0);
+                    visitedNodesSum.addAndGet(visitedNodes);
+                    if (visitedNodes > maxVisitedNodes.get()) {
+                        maxVisitedNodes.set(visitedNodes);
+                    }
+
                     long dist = (long) arsp.getDistance();
                     distSum.addAndGet(dist);
 
@@ -532,6 +541,7 @@ else if (!toLowerCase(rsp.getErrors().get(0).getMessage()).contains("not found")
         put(prefix + ".air_distance_mean", (float) airDistSum.get() / count);
         put(prefix + ".distance_max", maxDistance.get());
         put(prefix + ".visited_nodes_mean", (float) visitedNodesSum.get() / count);
+        put(prefix + ".visited_nodes_max", (float) maxVisitedNodes.get());
 
 //        put(prefix + ".extractTime", (float) extractTimeSum.get() / count / 1000000f);
 //        put(prefix + ".calcPointsTime", (float) calcPointsTimeSum.get() / count / 1000000f);
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 53876812bb..5526fff8dd 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -44,6 +44,7 @@
 import java.awt.event.MouseEvent;
 import java.awt.event.MouseWheelEvent;
 import java.awt.event.MouseWheelListener;
+import java.util.Arrays;
 import java.util.Random;
 
 /**
@@ -323,7 +324,7 @@ public void paintComponent(final Graphics2D g2) {
                     return;
 
                 makeTransparent(g2);
-                QueryGraph qGraph = new QueryGraph(routingGraph).lookup(fromRes, toRes);
+                QueryGraph qGraph = QueryGraph.lookup(routingGraph, Arrays.asList(fromRes, toRes));
                 RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
                 if (algo instanceof DebugAlgo) {
                     ((DebugAlgo) algo).setGraphics2D(g2);
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index e18907c63e..52ed4f0f44 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -210,7 +210,7 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.get("graph.location", "target/tmp"));
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        final EncodingManager encodingManager = new EncodingManager.Builder(configuration.getInt("graph.bytes_for_flags", 8)).add(ptFlagEncoder).add(new FootFlagEncoder()).add(new CarFlagEncoder()).build();
+        final EncodingManager encodingManager = new EncodingManager.Builder().add(ptFlagEncoder).add(new FootFlagEncoder()).add(new CarFlagEncoder()).build();
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index f0aeb8f984..86d06b57a7 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -86,8 +86,7 @@ public Response doGet(
             throw new IllegalArgumentException("Point not found:" + point);
 
         Graph graph = graphHopper.getGraphHopperStorage();
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(graph, Collections.singletonList(qr));
 
         HintsMap hintsMap = new HintsMap();
         RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
index 48f6ef20c4..c30ac42da3 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -95,10 +95,9 @@ public Response doGet(
         double targetZ = initialTime.toEpochMilli() + seconds * 1000;
 
         GeometryFactory geometryFactory = new GeometryFactory();
-        QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
         final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
         QueryResult queryResult = locationIndex.findClosest(source.lat, source.lon, filter);
-        queryGraph.lookup(Collections.singletonList(queryResult));
+        QueryGraph queryGraph = QueryGraph.lookup(graphHopperStorage, Collections.singletonList(queryResult));
         if (!queryResult.isValid()) {
             throw new IllegalArgumentException("Cannot find point: " + source);
         }
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 55e4eeed1e..9eb2d694f7 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -84,6 +84,7 @@ public Response doGet(
             @QueryParam("algorithm") @DefaultValue("") String algoStr,
             @QueryParam("locale") @DefaultValue("en") String localeStr,
             @QueryParam(POINT_HINT) List<String> pointHints,
+            @QueryParam(CURBSIDE) List<String> curbSides,
             @QueryParam(SNAP_PREVENTION) List<String> snapPreventions,
             @QueryParam(PATH_DETAILS) List<String> pathDetails,
             @QueryParam("heading") List<Double> favoredHeadings,
@@ -105,7 +106,9 @@ public Response doGet(
             throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
                     + "or equal to the number of points (" + requestPoints.size() + ")");
         if (pointHints.size() > 0 && pointHints.size() != requestPoints.size())
-            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored");
+            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass exactly one hint for every point, empty hints will be ignored");
+        if (curbSides.size() > 0 && curbSides.size() != requestPoints.size())
+            throw new IllegalArgumentException("If you pass " + CURBSIDE + ", you need to pass exactly one curbside for every point, empty curbsides will be ignored");
 
         GHRequest request;
         if (favoredHeadings.size() > 0) {
@@ -123,11 +126,13 @@ public Response doGet(
 
         initHints(request.getHints(), uriInfo.getQueryParameters());
         translateTurnCostsParamToEdgeBased(request, uriInfo.getQueryParameters());
+        enableEdgeBasedIfThereAreCurbSides(curbSides, request);
         request.setVehicle(vehicleStr).
                 setWeighting(weighting).
                 setAlgorithm(algoStr).
                 setLocale(localeStr).
                 setPointHints(pointHints).
+                setCurbSides(curbSides).
                 setSnapPreventions(snapPreventions).
                 setPathDetails(pathDetails).
                 getHints().
@@ -164,6 +169,16 @@ public Response doGet(
         }
     }
 
+    private void enableEdgeBasedIfThereAreCurbSides(List<String> curbSides, GHRequest request) {
+        if (!curbSides.isEmpty()) {
+            if (!request.getHints().getBool(EDGE_BASED, true)) {
+                throw new IllegalArgumentException("Disabling '" + EDGE_BASED + "' when using '" + CURBSIDE + "' is not allowed");
+            } else {
+                request.getHints().put(EDGE_BASED, true);
+            }
+        }
+    }
+
     private void translateTurnCostsParamToEdgeBased(GHRequest request, MultivaluedMap<String, String> queryParams) {
         if (queryParams.containsKey(TURN_COSTS)) {
             List<String> turnCosts = queryParams.get(TURN_COSTS);
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
index 47238430f1..a70f1c1aea 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
@@ -72,8 +72,7 @@ public Response doGet(
             throw new IllegalArgumentException("Point not found:" + point);
 
         Graph graph = graphHopper.getGraphHopperStorage();
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.singletonList(qr));
+        QueryGraph queryGraph = QueryGraph.lookup(graph, Collections.singletonList(qr));
 
         HintsMap hintsMap = new HintsMap();
         RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());
diff --git a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
index c2ec7c75f2..a4d89acb5d 100644
--- a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
+++ b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
@@ -18,7 +18,6 @@
 
 package com.graphhopper.http.cli;
 
-import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.http.GraphHopperManaged;
 import com.graphhopper.http.GraphHopperServerConfiguration;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
@@ -48,7 +47,7 @@ protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespac
             final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
             final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.getGraphHopperConfiguration().get("graph.location", "target/tmp"));
             final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-            final EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 12);
+            final EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()));
             final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
                     configuration.getGraphHopperConfiguration().has("gtfs.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("gtfs.file", "").split(",")) : Collections.emptyList(),
                     configuration.getGraphHopperConfiguration().has("datareader.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("datareader.file", "").split(",")) : Collections.emptyList());
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
index b6e740421a..434721b14e 100644
--- a/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
@@ -64,7 +64,7 @@
         final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
 
-        EncodingManager encodingManager = new EncodingManager.Builder(12).add(carFlagEncoder).add(footFlagEncoder).add(ptFlagEncoder).build();
+        EncodingManager encodingManager = new EncodingManager.Builder().add(carFlagEncoder).add(footFlagEncoder).add(ptFlagEncoder).build();
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("../reader-gtfs/files/sample-feed.zip"), Collections.emptyList());
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index f87f415386..023205a334 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -43,6 +43,7 @@
 import javax.ws.rs.core.Response;
 import java.io.File;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -244,7 +245,7 @@ public void testPathDetailsNoConnection() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHRequest request = new GHRequest(42.542078, 1.45586, 42.537841, 1.439981);
-        request.setPathDetails(Arrays.asList("average_speed"));
+        request.setPathDetails(Collections.singletonList("average_speed"));
         GHResponse rsp = hopper.route(request);
         assertTrue(rsp.getErrors().toString(), rsp.hasErrors());
     }
@@ -299,7 +300,7 @@ public void testSnapPreventions() {
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         assertEquals(490, rsp.getBest().getDistance(), 2);
 
-        request.setSnapPreventions(Arrays.asList("tunnel"));
+        request.setSnapPreventions(Collections.singletonList("tunnel"));
         rsp = hopper.route(request);
         assertEquals(1081, rsp.getBest().getDistance(), 2);
     }
@@ -309,13 +310,13 @@ public void testSnapPreventionsAndPointHints() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHRequest request = new GHRequest(42.511139, 1.53285, 42.508165, 1.532271);
-        request.setSnapPreventions(Arrays.asList("tunnel"));
+        request.setSnapPreventions(Collections.singletonList("tunnel"));
         request.setPointHints(Arrays.asList("Avinguda Fiter i Rossell", ""));
         GHResponse rsp = hopper.route(request);
         assertEquals(1590, rsp.getBest().getDistance(), 2);
 
         // contradicting hints should still allow routing
-        request.setSnapPreventions(Arrays.asList("tunnel"));
+        request.setSnapPreventions(Collections.singletonList("tunnel"));
         request.setPointHints(Arrays.asList("Tunèl del Pont Pla", ""));
         rsp = hopper.route(request);
         assertEquals(490, rsp.getBest().getDistance(), 2);
