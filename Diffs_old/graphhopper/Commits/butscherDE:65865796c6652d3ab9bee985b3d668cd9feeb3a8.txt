diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 06f9f5a693..3dcda2db4b 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -10,6 +10,7 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.Translation;
+import com.sun.org.apache.xpath.internal.operations.String;
 import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 import java.util.ArrayList;
@@ -56,13 +57,6 @@ private void setCalcPathsParams(QueryGraph queryGraph, RoutingAlgorithmFactory a
         return this.pathList;
     }
 
-    private void extractBestPathCandidate() {
-        // TODO Maybe more? Dont know what happens in the gui then.
-        this.routeCandidates.sortByGainAscending();
-        final List<Path> bestPath = this.routeCandidates.getFirstAsPathList(1, this.graph, this.algorithmOptions);
-        this.pathList.addAll(bestPath);
-    }
-
     private void prepareRouteCandidateList() {
         this.findCandidateRoutes();
         this.routeCandidates.pruneDominatedCandidateRoutes();
@@ -78,6 +72,34 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
         }
     }
 
+    private void extractBestPathCandidate() {
+        // TODO Maybe more? Dont know what happens in the gui then.
+        this.routeCandidates.sortByGainAscending();
+        printAllCandidatesInSortedOrder();
+        deleteBestN(0);
+        final List<Path> bestPath = this.routeCandidates.getFirstAsPathList(1, this.graph, this.algorithmOptions);
+        this.pathList.addAll(bestPath);
+    }
+
+    private void printAllCandidatesInSortedOrder() {
+        final StringBuilder sb = new StringBuilder();
+        sb.append("All non pruned route Candidates: ");
+
+        for (int i = 0; i < this.routeCandidates.size(); i++) {
+            sb.append(this.routeCandidates.get(i).toString());
+            sb.append("\n");
+        }
+
+        System.out.println(sb.toString());
+    }
+
+    // TODO used for experimenting delete when no more needed.
+    private void deleteBestN(final int n) {
+        for (int i = 0; i < n; i++) {
+            this.routeCandidates.remove(this.routeCandidates.size() - 1);
+        }
+    }
+
     protected abstract void findCandidateRoutes();
 
     @Override
@@ -86,7 +108,6 @@ public boolean isReady(PathMerger pathMerger, Translation translation) {
 
         this.altResponse.setWaypoints(getWaypoints());
         this.ghResponse.add(this.altResponse);
-        System.out.println(this.pathList.get(0).getNodesInPathOrder().toString());
         pathMerger.doWork(this.altResponse, this.pathList, this.encodingManager, translation);
         return true;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index ecd4bf5e08..0d385c27ef 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -23,6 +23,9 @@
     private ManyToManyRouting pathSkeletonRouter;
     private final FlagEncoder flagEncoder;
     private LOTNodeExtractor lotNodes;
+    private List<Integer> nodesInPolygon;
+    private List<Integer> polygonEntryExitPoints;
+    private LOTNodeExtractor lotNodes1;
 
     public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex,
                                          EncodingManager encodingManager) {
@@ -32,37 +35,18 @@ public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, Loca
     }
 
     protected void findCandidateRoutes() {
-        StopWatch sw = new StopWatch("finding nodes in polygon");
-        sw.start();
-        final List<Integer> nodesInPolygon = getNodesInPolygon();
-        sw.stop();
-        System.out.println(sw.toString());
-        System.out.println("# nodes in Polygon: " + nodesInPolygon.size());
-
-        sw = new StopWatch("finding entry exit points");
-        sw.start();
-        final List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
-        sw.stop();
-        System.out.println(sw.toString());
-        System.out.println("# Entry/Exit Points: " + polygonEntryExitPoints.size());
-
-        final List<Integer> viaPointNodeIds = this.extractNodeIdsFromQueryResults();
-
-        sw = new StopWatch("LOT node generation");
-        sw.start();
-        lotNodes = LOTNodeExtractor.createExtractedData(this.graph, this.algoFactory, this.algorithmOptions, viaPointNodeIds, polygonEntryExitPoints);
-        sw.stop();
-        System.out.println(sw.toString());
-        System.out.println("# LOT nodes: " + lotNodes.getLotNodesFor(viaPointNodeIds.get(0)).size());
-
+        final StopWatch swFindNodesInPolygon = generateNodesInPolygonAndMeasureTime();
+        final StopWatch swFindEntryExitPoints = findPolygonEntryExitPointsAndMeasureTime();
+        final List<Integer> viaPointNodeIds = extractNodeIdsFromQueryResults();
+        final StopWatch swLOTNodes = findLotNodesAndMeasureTime(viaPointNodeIds);
         final List<QueryResult> queryResults = createQueryResults(polygonEntryExitPoints, flagEncoder);
+        final StopWatch swPathSkeleton = findPathSkeletonAndMeasureTime(queryResults);
 
-        sw = new StopWatch("Generate path skeleton");
-        sw.start();
-        this.pathSkeletonRouter = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, queryResults, this.algoFactory, this.algorithmOptions);
-        this.pathSkeletonRouter.findPathBetweenAllNodePairs();
-        sw.stop();
-        System.out.println(sw.toString());
+        System.out.println("Candidate Routes found\n" +
+                           "Nodes in polygon : " + nodesInPolygon.size() + " in " + swFindNodesInPolygon.getSeconds() + "\n" +
+                           "Entry/Exit points: " + polygonEntryExitPoints.size() + " in " + swFindEntryExitPoints.getSeconds() + "\n" +
+                           "LOT Nodes        : " + lotNodes.size() + " in " + swLOTNodes.getSeconds() + "\n" +
+                           "Path Skeleton    : " + "in " + swPathSkeleton.getSeconds());
 
         for (int i = 0; i < viaPointNodeIds.size() - 1; i++) {
             final int viaPointNodeId = viaPointNodeIds.get(i);
@@ -71,6 +55,39 @@ protected void findCandidateRoutes() {
         }
     }
 
+    private StopWatch findPathSkeletonAndMeasureTime(List<QueryResult> queryResults) {
+        final StopWatch swPathSkeleton = new StopWatch("Generate path skeleton");
+        swPathSkeleton.start();
+        this.pathSkeletonRouter = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, queryResults, this.algoFactory, this.algorithmOptions);
+        this.pathSkeletonRouter.findPathBetweenAllNodePairs();
+        swPathSkeleton.stop();
+        return swPathSkeleton;
+    }
+
+    private StopWatch findLotNodesAndMeasureTime(List<Integer> viaPointNodeIds) {
+        final StopWatch swLOTNodes = new StopWatch("LOT node generation");
+        swLOTNodes.start();
+        this.lotNodes = LOTNodeExtractor.createExtractedData(this.graph, this.algoFactory, this.algorithmOptions, viaPointNodeIds, polygonEntryExitPoints);
+        swLOTNodes.stop();
+        return swLOTNodes;
+    }
+
+    private StopWatch findPolygonEntryExitPointsAndMeasureTime() {
+        StopWatch swFindEntryExitPoints = new StopWatch("finding entry exit points");
+        swFindEntryExitPoints.start();
+        this.polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
+        swFindEntryExitPoints.stop();
+        return swFindEntryExitPoints;
+    }
+
+    private StopWatch generateNodesInPolygonAndMeasureTime() {
+        StopWatch swFindNodesInPolygon = new StopWatch("finding nodes in polygon");
+        swFindNodesInPolygon.start();
+        this.nodesInPolygon = getNodesInPolygon();
+        swFindNodesInPolygon.stop();
+        return swFindNodesInPolygon;
+    }
+
     private List<QueryResult> createQueryResults(final List<Integer> nodes, final FlagEncoder flagEncoder) {
         final List<GHPoint> points = nodeIdsToGhPoints(nodes);
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
index f7279f7533..7e73dda388 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
@@ -119,6 +119,8 @@ public void remove(Object o) {
         this.candidates.remove(o);
     }
 
+    public void remove(int i) { this.candidates.remove(i); }
+
     public void add(T o) {
         if (o.isLegalCandidate()) {
             this.candidates.add(o);
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
index 81f0756836..1573b45997 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
@@ -115,9 +115,9 @@ public String toString() {
                     "endNodeID: " + endNodeID + ", " +
                     "polygonEntryNodeID: " + polygonEntryNodeID + ", " +
                     "polygonExitNodeID: " + polygonExitNodeID + ", " +
-                    "Distance: " + this.getTime() + ", " +
-                    "DistanceInROI: " + getTimeInROI() + ", " +
-                    "detour distance: " + getDetourTime() + ", " +
+                    "Time: " + this.getTime() + ", " +
+                    "TimeInROI: " + getTimeInROI() + ", " +
+                    "TimeDetour: " + getDetourTime() + ", " +
                     "gain: " + this.getGain();
         return sb;
     }
