diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 81bd7a6ca9..ee339408c4 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -99,31 +99,73 @@ public Response doGet(
 
         StopWatch sw = new StopWatch().start();
 
-        if (requestPoints.isEmpty())
-            throw new IllegalArgumentException("You have to pass at least one point");
-        if (enableElevation && !hasElevation)
-            throw new IllegalArgumentException("Elevation not supported!");
-        if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
-            throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
-                    + "or equal to the number of points (" + requestPoints.size() + ")");
-        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size())
-            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored");
+        getRequestErrorHandling(requestPoints, enableElevation, pointHints, favoredHeadings);
 
-        GHRequest request;
-        if (favoredHeadings.size() > 0) {
-            // if only one favored heading is specified take as start heading
-            if (favoredHeadings.size() == 1) {
-                List<Double> paddedHeadings = new ArrayList<>(Collections.nCopies(requestPoints.size(), Double.NaN));
-                paddedHeadings.set(0, favoredHeadings.get(0));
-                request = new GHRequest(requestPoints, paddedHeadings);
+        GHRequest request = buildRequest(requestPoints, favoredHeadings);
+
+        initHints(request.getHints(), uriInfo.getQueryParameters());
+        setRequestParams(minPathPrecision, polygon, instructions, calcPoints, vehicleStr, weighting, algoStr, localeStr, pointHints, snapPreventions, pathDetails, request);
+
+        GHResponse ghResponse = graphHopper.route(request);
+
+        // TODO: Request logging and timing should perhaps be done somewhere outside
+        float took = sw.stop().getSeconds();
+        String infoStr = buildInfoString(httpReq);
+        String logStr = buildLogString(httpReq, requestPoints, vehicleStr, weighting, algoStr, took, infoStr);
+
+        if (ghResponse.hasErrors()) {
+            return handleErroneousResponse(ghResponse, logStr);
+        } else {
+            addResponserelatedLogEntry(ghResponse, logStr);
+
+            Response response;
+
+            if (writeGPX) {
+                response = buildGpxResponse(enableElevation, withRoute, withTrack, withWayPoints, trackName, timeString, ghResponse, took);
             } else {
-                request = new GHRequest(requestPoints, favoredHeadings);
+                response = buildOkResponse(instructions, calcPoints, enableElevation, pointsEncoded, ghResponse, took);
             }
-        } else {
-            request = new GHRequest(requestPoints);
+
+            return response;
         }
+    }
 
-        initHints(request.getHints(), uriInfo.getQueryParameters());
+    private Response buildOkResponse(@DefaultValue("true") @QueryParam(INSTRUCTIONS) boolean instructions, @DefaultValue("true") @QueryParam(CALC_POINTS) boolean calcPoints, @DefaultValue("false") @QueryParam("elevation") boolean enableElevation, @DefaultValue("true") @QueryParam("points_encoded") boolean pointsEncoded, GHResponse ghResponse, float took) {
+        return Response.ok(WebHelper.jsonObject(ghResponse, instructions, calcPoints, enableElevation, pointsEncoded, took)).
+                header("X-GH-Took", "" + Math.round(took * 1000)).
+                build();
+    }
+
+    private Response buildGpxResponse(@DefaultValue("false") @QueryParam("elevation") boolean enableElevation, @DefaultValue("true") @QueryParam("gpx.route") boolean withRoute, @DefaultValue("true") @QueryParam("gpx.track") boolean withTrack, @DefaultValue("false") @QueryParam("gpx.waypoints") boolean withWayPoints, @DefaultValue("GraphHopper Track") @QueryParam("gpx.trackname") String trackName, @QueryParam("gpx.millis") String timeString, GHResponse ghResponse, float took) {
+        return gpxSuccessResponseBuilder(ghResponse, timeString, trackName, enableElevation, withRoute, withTrack, withWayPoints, Constants.VERSION).
+                header("X-GH-Took", "" + Math.round(took * 1000)).
+                build();
+    }
+
+    private void addResponserelatedLogEntry(GHResponse ghResponse, String logStr) {
+        logger.info(logStr + ", alternatives: " + ghResponse.getAll().size()
+                + ", distance0: " + ghResponse.getBest().getDistance()
+                + ", weight0: " + ghResponse.getBest().getRouteWeight()
+                + ", time0: " + Math.round(ghResponse.getBest().getTime() / 60000f) + "min"
+                + ", points0: " + ghResponse.getBest().getPoints().getSize()
+                + ", debugInfo: " + ghResponse.getDebugInfo());
+    }
+
+    private Response handleErroneousResponse(GHResponse ghResponse, String logStr) {
+        logger.error(logStr + ", errors:" + ghResponse.getErrors());
+        throw new MultiException(ghResponse.getErrors());
+    }
+
+    private String buildLogString(@Context HttpServletRequest httpReq, @QueryParam("point") List<GHPoint> requestPoints, @DefaultValue("car") @QueryParam("vehicle") String vehicleStr, @DefaultValue("fastest") @QueryParam("weighting") String weighting, @DefaultValue("") @QueryParam("algorithm") String algoStr, float took, String infoStr) {
+        return httpReq.getQueryString() + " " + infoStr + " " + requestPoints + ", took:"
+                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+    }
+
+    private String buildInfoString(@Context HttpServletRequest httpReq) {
+        return httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+    }
+
+    private void setRequestParams(@DefaultValue("1") @QueryParam(WAY_POINT_MAX_DISTANCE) double minPathPrecision, @QueryParam("polygon") List<GHPoint> polygon, @DefaultValue("true") @QueryParam(INSTRUCTIONS) boolean instructions, @DefaultValue("true") @QueryParam(CALC_POINTS) boolean calcPoints, @DefaultValue("car") @QueryParam("vehicle") String vehicleStr, @DefaultValue("fastest") @QueryParam("weighting") String weighting, @DefaultValue("") @QueryParam("algorithm") String algoStr, @DefaultValue("en") @QueryParam("locale") String localeStr, @QueryParam(POINT_HINT) List<String> pointHints, @QueryParam(SNAP_PREVENTION) List<String> snapPreventions, @QueryParam(PATH_DETAILS) List<String> pathDetails, GHRequest request) {
         request.setVehicle(vehicleStr).
                 setWeighting(weighting).
                 setAlgorithm(algoStr).
@@ -136,34 +178,62 @@ public Response doGet(
                 put(CALC_POINTS, calcPoints).
                 put(INSTRUCTIONS, instructions).
                 put(WAY_POINT_MAX_DISTANCE, minPathPrecision);
+    }
 
-        GHResponse ghResponse = graphHopper.route(request);
-
-        // TODO: Request logging and timing should perhaps be done somewhere outside
-        float took = sw.stop().getSeconds();
-        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
-        String logStr = httpReq.getQueryString() + " " + infoStr + " " + requestPoints + ", took:"
-                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+    private GHRequest buildRequest(@QueryParam("point") List<GHPoint> requestPoints, @QueryParam("heading") List<Double> favoredHeadings) {
+        GHRequest request;
+        if (favoredHeadings.size() > 0) {
+            request = buildRequestIfFavoredHeadingsNonEmpty(requestPoints, favoredHeadings);
+        } else {
+            request = new GHRequest(requestPoints);
+        }
+        return request;
+    }
 
-        if (ghResponse.hasErrors()) {
-            logger.error(logStr + ", errors:" + ghResponse.getErrors());
-            throw new MultiException(ghResponse.getErrors());
+    private GHRequest buildRequestIfFavoredHeadingsNonEmpty(@QueryParam("point") List<GHPoint> requestPoints, @QueryParam("heading") List<Double> favoredHeadings) {
+        GHRequest request;// if only one favored heading is specified take as start heading
+        if (favoredHeadings.size() == 1) {
+            request = buildRequestIfFavoredHeadingsSizeIsOne(requestPoints, favoredHeadings);
         } else {
-            logger.info(logStr + ", alternatives: " + ghResponse.getAll().size()
-                    + ", distance0: " + ghResponse.getBest().getDistance()
-                    + ", weight0: " + ghResponse.getBest().getRouteWeight()
-                    + ", time0: " + Math.round(ghResponse.getBest().getTime() / 60000f) + "min"
-                    + ", points0: " + ghResponse.getBest().getPoints().getSize()
-                    + ", debugInfo: " + ghResponse.getDebugInfo());
-            return writeGPX ?
-                    gpxSuccessResponseBuilder(ghResponse, timeString, trackName, enableElevation, withRoute, withTrack, withWayPoints, Constants.VERSION).
-                            header("X-GH-Took", "" + Math.round(took * 1000)).
-                            build()
-                    :
-                    Response.ok(WebHelper.jsonObject(ghResponse, instructions, calcPoints, enableElevation, pointsEncoded, took)).
-                            header("X-GH-Took", "" + Math.round(took * 1000)).
-                            build();
+            request = new GHRequest(requestPoints, favoredHeadings);
         }
+        return request;
+    }
+
+    private GHRequest buildRequestIfFavoredHeadingsSizeIsOne(@QueryParam("point") List<GHPoint> requestPoints, @QueryParam("heading") List<Double> favoredHeadings) {
+        GHRequest request;
+        List<Double> paddedHeadings = new ArrayList<>(Collections.nCopies(requestPoints.size(), Double.NaN));
+        paddedHeadings.set(0, favoredHeadings.get(0));
+        request = new GHRequest(requestPoints, paddedHeadings);
+        return request;
+    }
+
+    private void getRequestErrorHandling(@QueryParam("point") List<GHPoint> requestPoints, @DefaultValue("false") @QueryParam("elevation") boolean enableElevation, @QueryParam(POINT_HINT) List<String> pointHints, @QueryParam("heading") List<Double> favoredHeadings) {
+        exceptionOnNoPointsRequested(requestPoints);
+        exceptionOnElevationEnabledButNotPresent(enableElevation);
+        exceptionOnWrongNumberOfHeadings(requestPoints, favoredHeadings);
+        exceptionOnWrongNumberOfPointHints(requestPoints, pointHints);
+    }
+
+    private void exceptionOnWrongNumberOfPointHints(@QueryParam("point") List<GHPoint> requestPoints, @QueryParam(POINT_HINT) List<String> pointHints) {
+        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size())
+            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored");
+    }
+
+    private void exceptionOnWrongNumberOfHeadings(@QueryParam("point") List<GHPoint> requestPoints, @QueryParam("heading") List<Double> favoredHeadings) {
+        if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
+            throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
+                    + "or equal to the number of points (" + requestPoints.size() + ")");
+    }
+
+    private void exceptionOnElevationEnabledButNotPresent(@QueryParam("elevation") @DefaultValue("false") boolean enableElevation) {
+        if (enableElevation && !hasElevation)
+            throw new IllegalArgumentException("Elevation not supported!");
+    }
+
+    private void exceptionOnNoPointsRequested(@QueryParam("point") List<GHPoint> requestPoints) {
+        if (requestPoints.isEmpty())
+            throw new IllegalArgumentException("You have to pass at least one point");
     }
 
     private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index f87f415386..3d1dcdee6c 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -420,4 +420,5 @@ public void testTooManyHeadings() {
         assertEquals("The number of 'heading' parameters must be <= 1 or equal to the number of points (1)", json.get("message").asText());
     }
 
+    // TODO test for points and polygon points outside of the boundary
 }
