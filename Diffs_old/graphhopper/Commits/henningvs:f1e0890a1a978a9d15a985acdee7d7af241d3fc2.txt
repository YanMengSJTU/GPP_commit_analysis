diff --git a/.gitignore b/.gitignore
index d5c6eb8b7a..83ce38371f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,4 +26,10 @@ core/docs/
 .*#
 cgiarprovider/
 /nbactions.xml
-tools/nb-configuration.xml
\ No newline at end of file
+tools/nb-configuration.xml
+android/build/
+android/app/build/
+android/.gradle
+.settings/
+.classpath
+.project
diff --git a/.travis.yml b/.travis.yml
index b1b8faf3f1..178e6f4a75 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,4 +8,7 @@ install: true
 script: ./core/files/travis-build.sh
 notifications:
   email:
-    - github@graphhopper.com
\ No newline at end of file
+    - github@graphhopper.com
+
+# enable container-based stack
+sudo: false
\ No newline at end of file
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index d3264e5372..30a472952d 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -1,21 +1,23 @@
 [Members](https://github.com/graphhopper?tab=members) and [Contributors](https://github.com/graphhopper/graphhopper/contributors)
 
+ * AnahitaS
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * daisy1754, fixed usage of graphhopper.sh script
  * dardin88, instructions improved
+ * dewos
  * lmar, improved instructions information
  * fredao, translations
- * jansoe, algorithm improvements
+ * jansoe, one of the core developers
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
- * karussell, lead developer
- * khuebner, pushes turn instructions forward 
+ * karussell, one of the core developers
+ * khuebner, pushed turn instructions forward
  * lmar, improved instructions
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
- * ratrun, route relations, GPX information and bike handling
+ * ratrun, route relations, GPX information, bike handling etc
  * rodneyodonnell, improved dead end removal
  * rodo, more descriptions
 
diff --git a/NOTICE.md b/NOTICE.md
index 2da14a4df8..85b2bf59be 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -1,6 +1,6 @@
 GraphHopper licensed under the Apache license, Version 2.0
 
-Copyright 2012-2013 Peter Karich
+Copyright 2012-2015 Peter Karich
 
 The core product includes the following software
  * slf4j.org - SLF4J distributed under the MIT license. 
@@ -10,6 +10,7 @@ The core product includes the following software
  * protobuf - New BSD license
  * OSM-binary - LGPL license
  * Osmosis - public domain, see osmosis-copying.txt under core/files
+ * XMLGraphics-Commons for CGIAR elevation files - (Apache License)
 
 tools
  * apache-compress
diff --git a/README.md b/README.md
index 377c3f9495..177e708507 100644
--- a/README.md
+++ b/README.md
@@ -29,7 +29,7 @@ and [iOS](http://github.com/graphhopper/graphhopper-ios)
 Get Started
 ---------------
 
-Read through our [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), 
+Read through our Documentation ([0.4](https://github.com/graphhopper/graphhopper/blob/0.4/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
 and sign up to the [mailing list](http://graphhopper.com/#developers).
 
@@ -50,4 +50,4 @@ Features
  * Highly customizable
  * Works on the desktop, as a web service and offline on Android or iOS
  * Large test suite
- * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
+ * [... more](http://graphhopper.com/#overview)
diff --git a/android/.classpath b/android/.classpath
deleted file mode 100644
index 497def70c6..0000000000
--- a/android/.classpath
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/android/.project b/android/.project
deleted file mode 100644
index 9f2869b63c..0000000000
--- a/android/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>GraphHopper</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/android/.settings/org.eclipse.jdt.core.prefs b/android/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index b080d2ddc8..0000000000
--- a/android/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/android/app/build.gradle b/android/app/build.gradle
new file mode 100644
index 0000000000..f22f47f714
--- /dev/null
+++ b/android/app/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "com.graphhopper.android"
+        minSdkVersion 8
+        targetSdkVersion 19
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        /* CGIARProvider refers to java.awt
+         * Helper7 refers to java.lang.management
+         * HeightTile refers to javax.imageio and java.awt
+         * OSMElement refers to javax.xml.stream
+         */
+        disable 'InvalidPackage'
+    }
+}
+
+/** only necessary if you need to use latest SNAPSHOT
+configurations.all {
+    // check for updates every build
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+ **/
+
+dependencies {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.4-SNAPSHOT') {
+       exclude group: 'com.google.protobuf', module: 'protobuf-java'
+       exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
+       exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
+    }
+
+    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.0'
+
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.10'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.10'
+}
diff --git a/android/pom.xml b/android/app/pom.xml
similarity index 84%
rename from android/pom.xml
rename to android/app/pom.xml
index b257acaa32..dd631781c5 100644
--- a/android/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -13,15 +13,13 @@
     </organization>
     
     <parent>
+        <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
     <properties>
-        <!--
-        <mapsforge.version>0.3-0.4.0-SNAPSHOT</mapsforge.version>
-        -->
-        <mapsforge.version>0.4.3</mapsforge.version>
+        <mapsforge.version>0.5.0</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -35,12 +33,6 @@
             <version>${project.parent.version}</version>            
             <type>jar</type>
             <exclusions>
-                <!--
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-api</artifactId>                    
-                </exclusion> 
-                -->
                 <exclusion>
                     <groupId>com.google.protobuf</groupId>
                     <artifactId>protobuf-java</artifactId>                    
@@ -84,13 +76,13 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.10</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.10</version>
         </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
@@ -112,31 +104,24 @@
     </dependencies>
 
     <build>
-        <!-- 
-        1. Use src/test/java for JUnit tests that don't call any Android APIs (directly or transitively)
-        2. Use src/main/java for JUnit tests that call Android APIs  
-        -->
-        <sourceDirectory>src</sourceDirectory>        
         <finalName>${project.artifactId}</finalName>        
-
+        
         <plugins>     
-            <!-- android (apache harmony) is nearly java but not really 1.6 -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
                 <configuration>
                     <!-- <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
-                    <source>1.5</source>
-                    <target>1.5</target>
+                    <source>1.7</source>
+                    <target>1.7</target>
                 </configuration>
             </plugin>       
             <plugin>
                 <!-- See http://code.google.com/p/maven-android-plugin/ -->
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.0.0-rc.2</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
@@ -145,6 +130,7 @@
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
+		    
                     <!--
                     bug in maven plugin I think
                     <extractDuplicates>true</extractDuplicates>
diff --git a/android/project.properties b/android/app/project.properties
similarity index 96%
rename from android/project.properties
rename to android/app/project.properties
index 4ab125693c..00cf62bacc 100644
--- a/android/project.properties
+++ b/android/app/project.properties
@@ -11,4 +11,4 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-19
+target=android-22
diff --git a/android/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
similarity index 100%
rename from android/AndroidManifest.xml
rename to android/app/src/main/AndroidManifest.xml
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..63f874629a
--- /dev/null
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,58 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader {
+
+    public AndroidDownloader() {
+        super("GraphHopper Android");
+    }
+
+    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
+            @Override
+            public void update(long sumBytes) {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    private HttpEntity getEntity(String url) {
+        // there is something broken with HTTPS and Android HttpURLConnection
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public String downloadAsString(String url) throws IOException {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+}
diff --git a/android/src/com/graphhopper/android/AndroidHelper.java b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
similarity index 100%
rename from android/src/com/graphhopper/android/AndroidHelper.java
rename to android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
diff --git a/android/src/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
similarity index 99%
rename from android/src/com/graphhopper/android/GHAsyncTask.java
rename to android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index e1b0276a94..62923ec579 100644
--- a/android/src/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,8 +20,6 @@ protected C doInBackground( A... params )
         }
     }
 
-    ;
-
 	public boolean hasError()
     {
         return error != null;
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
similarity index 96%
rename from android/src/com/graphhopper/android/MainActivity.java
rename to android/app/src/main/java/com/graphhopper/android/MainActivity.java
index d6afb483a6..dd66542c54 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -52,7 +52,6 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
@@ -71,7 +70,7 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "https://graphhopper.com/public/maps/0.4/";
+    private String fileListURL = "https://graphhopper.com/public/maps/0.5/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
@@ -189,7 +188,7 @@ boolean isReady()
             logUser("Preparation still in progress");
             return false;
         }
-        log("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
         return false;
     }
 
@@ -239,8 +238,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").
-                        downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -261,8 +259,13 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (hasError() || nameList.isEmpty())
+                if(nameList.isEmpty())
                 {
+                    logUser("No maps created for your version!? " + fileListURL);
+                    return;
+                } else if (hasError())
+                {
+                    getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
@@ -273,10 +276,8 @@ protected void onPostExecute( List<String> nameList )
                     public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder, selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder, selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -357,7 +358,7 @@ protected Object saveDoInBackground( Void... _ignore )
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                Downloader downloader = new Downloader("GraphHopper Android");
+                AndroidDownloader downloader = new AndroidDownloader();
                 downloader.setTimeout(30000);
                 downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
@@ -401,6 +402,7 @@ void loadMap( File areaFolder )
         mapView.getLayerManager().getLayers().clear();
 
         TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapView.getModel().mapViewPosition,
+                false,
                 true, AndroidGraphicFactory.INSTANCE)
                 {
                     @Override
@@ -541,6 +543,7 @@ private void log( String str, Throwable t )
 
     private void logUser( String str )
     {
+        log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
diff --git a/android/res/drawable/flag_green.png b/android/app/src/main/res/drawable/flag_green.png
similarity index 100%
rename from android/res/drawable/flag_green.png
rename to android/app/src/main/res/drawable/flag_green.png
diff --git a/android/res/drawable/flag_red.png b/android/app/src/main/res/drawable/flag_red.png
similarity index 100%
rename from android/res/drawable/flag_red.png
rename to android/app/src/main/res/drawable/flag_red.png
diff --git a/android/res/drawable/logo.png b/android/app/src/main/res/drawable/logo.png
similarity index 100%
rename from android/res/drawable/logo.png
rename to android/app/src/main/res/drawable/logo.png
diff --git a/android/res/layout/main.xml b/android/app/src/main/res/layout/main.xml
similarity index 100%
rename from android/res/layout/main.xml
rename to android/app/src/main/res/layout/main.xml
diff --git a/android/res/values-large/dimens.xml b/android/app/src/main/res/values-large/dimens.xml
similarity index 100%
rename from android/res/values-large/dimens.xml
rename to android/app/src/main/res/values-large/dimens.xml
diff --git a/android/res/values/dimens.xml b/android/app/src/main/res/values/dimens.xml
similarity index 100%
rename from android/res/values/dimens.xml
rename to android/app/src/main/res/values/dimens.xml
diff --git a/android/res/values/strings.xml b/android/app/src/main/res/values/strings.xml
similarity index 100%
rename from android/res/values/strings.xml
rename to android/app/src/main/res/values/strings.xml
diff --git a/android/res/values/styles.xml b/android/app/src/main/res/values/styles.xml
similarity index 100%
rename from android/res/values/styles.xml
rename to android/app/src/main/res/values/styles.xml
diff --git a/android/build.gradle b/android/build.gradle
new file mode 100644
index 0000000000..fd24035602
--- /dev/null
+++ b/android/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+buildscript {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.0.0'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+}
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c71e760dc
--- /dev/null
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/android/gradlew b/android/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/android/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
new file mode 100644
index 0000000000..8a0b282aa6
--- /dev/null
+++ b/android/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/android/libs/mapsforge-core-0.4.3.jar b/android/libs/mapsforge-core-0.4.3.jar
deleted file mode 100644
index 82d62ee4f7..0000000000
Binary files a/android/libs/mapsforge-core-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-0.4.3.jar b/android/libs/mapsforge-map-0.4.3.jar
deleted file mode 100644
index eba6643ef4..0000000000
Binary files a/android/libs/mapsforge-map-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-android-0.4.3.jar b/android/libs/mapsforge-map-android-0.4.3.jar
deleted file mode 100644
index 0a6789d6c8..0000000000
Binary files a/android/libs/mapsforge-map-android-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-reader-0.4.3.jar b/android/libs/mapsforge-map-reader-0.4.3.jar
deleted file mode 100644
index 214bb5c8f3..0000000000
Binary files a/android/libs/mapsforge-map-reader-0.4.3.jar and /dev/null differ
diff --git a/android/libs/slf4j-android-1.6.1-RC1.jar b/android/libs/slf4j-android-1.6.1-RC1.jar
deleted file mode 100644
index 9bb01355a4..0000000000
Binary files a/android/libs/slf4j-android-1.6.1-RC1.jar and /dev/null differ
diff --git a/android/local.properties b/android/local.properties
new file mode 100644
index 0000000000..efc8662bc7
--- /dev/null
+++ b/android/local.properties
@@ -0,0 +1,7 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+#
+#Mon Jan 19 09:31:41 CET 2015
+sdk.dir=/home/peterk/Programme/adt-bundle-linux-x86/sdk
diff --git a/android/proguard-project.txt b/android/proguard-project.txt
deleted file mode 100644
index f2fe1559a2..0000000000
--- a/android/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/android/scripts/googlecode_upload.py b/android/scripts/googlecode_upload.py
deleted file mode 100644
index 16912361ee..0000000000
--- a/android/scripts/googlecode_upload.py
+++ /dev/null
@@ -1,256 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright 2006, 2007 Google Inc. All Rights Reserved.
-# Author: danderson@google.com (David Anderson)
-#
-# Script for uploading files to a Google Code project.
-#
-# This is intended to be both a useful script for people who want to
-# streamline project uploads and a reference implementation for
-# uploading files to Google Code projects.
-#
-# To upload a file to Google Code, you need to provide a path to the
-# file on your local machine, a small summary of what the file is, a
-# project name, and a valid account that is a member or owner of that
-# project.  You can optionally provide a list of labels that apply to
-# the file.  The file will be uploaded under the same name that it has
-# in your local filesystem (that is, the "basename" or last path
-# component).  Run the script with '--help' to get the exact syntax
-# and available options.
-#
-# Note that the upload script requests that you enter your
-# googlecode.com password.  This is NOT your Gmail account password!
-# This is the password you use on googlecode.com for committing to
-# Subversion and uploading files.  You can find your password by going
-# to http://code.google.com/hosting/settings when logged in with your
-# Gmail account. If you have already committed to your project's
-# Subversion repository, the script will automatically retrieve your
-# credentials from there (unless disabled, see the output of '--help'
-# for details).
-#
-# If you are looking at this script as a reference for implementing
-# your own Google Code file uploader, then you should take a look at
-# the upload() function, which is the meat of the uploader.  You
-# basically need to build a multipart/form-data POST request with the
-# right fields and send it to https://PROJECT.googlecode.com/files .
-# Authenticate the request using HTTP Basic authentication, as is
-# shown below.
-#
-# Licensed under the terms of the Apache Software License 2.0:
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Questions, comments, feature requests and patches are most welcome.
-# Please direct all of these to the Google Code users group:
-#  http://groups.google.com/group/google-code-hosting
-
-"""Google Code file uploader script.
-"""
-
-__author__ = 'danderson@google.com (David Anderson)'
-
-import httplib
-import os.path
-import optparse
-import getpass
-import base64
-import sys
-
-
-def upload(file, project_name, user_name, password, summary, labels=None):
-  """Upload a file to a Google Code project's file server.
-
-  Args:
-    file: The local path to the file.
-    project_name: The name of your project on Google Code.
-    user_name: Your Google account name.
-    password: The googlecode.com password for your account.
-              Note that this is NOT your global Google Account password!
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-
-  Returns: a tuple:
-    http_status: 201 if the upload succeeded, something else if an
-                 error occured.
-    http_reason: The human-readable string associated with http_status
-    file_url: If the upload succeeded, the URL of the file on Google
-              Code, None otherwise.
-  """
-  # The login is the user part of user@gmail.com. If the login provided
-  # is in the full user@domain form, strip it down.
-  if user_name.endswith('@gmail.com'):
-    user_name = user_name[:user_name.index('@gmail.com')]
-
-  form_fields = [('summary', summary)]
-  if labels is not None:
-    form_fields.extend([('label', l.strip()) for l in labels])
-
-  content_type, body = encode_upload_request(form_fields, file)
-
-  upload_host = '%s.googlecode.com' % project_name
-  upload_uri = '/files'
-  auth_token = base64.b64encode('%s:%s'% (user_name, password))
-  headers = {
-    'Authorization': 'Basic %s' % auth_token,
-    'User-Agent': 'Googlecode.com uploader v0.9.4',
-    'Content-Type': content_type,
-    }
-
-  server = httplib.HTTPSConnection(upload_host)
-  server.request('POST', upload_uri, body, headers)
-  resp = server.getresponse()
-  server.close()
-
-  if resp.status == 201:
-    location = resp.getheader('Location', None)
-  else:
-    location = None
-  return resp.status, resp.reason, location
-
-
-def encode_upload_request(fields, file_path):
-  """Encode the given fields and file into a multipart form body.
-
-  fields is a sequence of (name, value) pairs. file is the path of
-  the file to upload. The file will be uploaded to Google Code with
-  the same file name.
-
-  Returns: (content_type, body) ready for httplib.HTTP instance
-  """
-  BOUNDARY = '----------Googlecode_boundary_reindeer_flotilla'
-  CRLF = '\r\n'
-
-  body = []
-
-  # Add the metadata about the upload first
-  for key, value in fields:
-    body.extend(
-      ['--' + BOUNDARY,
-       'Content-Disposition: form-data; name="%s"' % key,
-       '',
-       value,
-       ])
-
-  # Now add the file itself
-  file_name = os.path.basename(file_path)
-  f = open(file_path, 'rb')
-  file_content = f.read()
-  f.close()
-
-  body.extend(
-    ['--' + BOUNDARY,
-     'Content-Disposition: form-data; name="filename"; filename="%s"'
-     % file_name,
-     # The upload server determines the mime-type, no need to set it.
-     'Content-Type: application/octet-stream',
-     '',
-     file_content,
-     ])
-
-  # Finalize the form body
-  body.extend(['--' + BOUNDARY + '--', ''])
-
-  return 'multipart/form-data; boundary=%s' % BOUNDARY, CRLF.join(body)
-
-
-def upload_find_auth(file_path, project_name, summary, labels=None,
-                     user_name=None, password=None, tries=3):
-  """Find credentials and upload a file to a Google Code project's file server.
-
-  file_path, project_name, summary, and labels are passed as-is to upload.
-
-  Args:
-    file_path: The local path to the file.
-    project_name: The name of your project on Google Code.
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-    config_dir: Path to Subversion configuration directory, 'none', or None.
-    user_name: Your Google account name.
-    tries: How many attempts to make.
-  """
-  if user_name is None or password is None:
-    from netrc import netrc
-    authenticators = netrc().authenticators("code.google.com")
-    if authenticators:
-      if user_name is None:
-        user_name = authenticators[0]
-      if password is None:
-        password = authenticators[2]
-
-  while tries > 0:
-    if user_name is None:
-      # Read username if not specified or loaded from svn config, or on
-      # subsequent tries.
-      sys.stdout.write('Please enter your googlecode.com username: ')
-      sys.stdout.flush()
-      user_name = sys.stdin.readline().rstrip()
-    if password is None:
-      # Read password if not loaded from svn config, or on subsequent tries.
-      print 'Please enter your googlecode.com password.'
-      print '** Note that this is NOT your Gmail account password! **'
-      print 'It is the password you use to access Subversion repositories,'
-      print 'and can be found here: http://code.google.com/hosting/settings'
-      password = getpass.getpass()
-
-    status, reason, url = upload(file_path, project_name, user_name, password,
-                                 summary, labels)
-    # Returns 403 Forbidden instead of 401 Unauthorized for bad
-    # credentials as of 2007-07-17.
-    if status in [httplib.FORBIDDEN, httplib.UNAUTHORIZED]:
-      # Rest for another try.
-      user_name = password = None
-      tries = tries - 1
-    else:
-      # We're done.
-      break
-
-  return status, reason, url
-
-
-def main():
-  parser = optparse.OptionParser(usage='googlecode-upload.py -s SUMMARY '
-                                 '-p PROJECT [options] FILE')
-  parser.add_option('-s', '--summary', dest='summary',
-                    help='Short description of the file')
-  parser.add_option('-p', '--project', dest='project',
-                    help='Google Code project name')
-  parser.add_option('-u', '--user', dest='user',
-                    help='Your Google Code username')
-  parser.add_option('-w', '--password', dest='password',
-                    help='Your Google Code password')
-  parser.add_option('-l', '--labels', dest='labels',
-                    help='An optional list of comma-separated labels to attach '
-                    'to the file')
-
-  options, args = parser.parse_args()
-
-  if not options.summary:
-    parser.error('File summary is missing.')
-  elif not options.project:
-    parser.error('Project name is missing.')
-  elif len(args) < 1:
-    parser.error('File to upload not provided.')
-  elif len(args) > 1:
-    parser.error('Only one file may be specified.')
-
-  file_path = args[0]
-
-  if options.labels:
-    labels = options.labels.split(',')
-  else:
-    labels = None
-
-  status, reason, url = upload_find_auth(file_path, options.project,
-                                         options.summary, labels,
-                                         options.user, options.password)
-  if url:
-    print 'The file was uploaded successfully.'
-    print 'URL: %s' % url
-    return 0
-  else:
-    print 'An error occurred. Your file was not uploaded.'
-    print 'Google Code upload server said: %s (%s)' % (reason, status)
-    return 1
-
-
-if __name__ == '__main__':
-  sys.exit(main())
diff --git a/android/scripts/maven-install-mapsforge.sh b/android/scripts/maven-install-mapsforge.sh
deleted file mode 100755
index f1fac1393c..0000000000
--- a/android/scripts/maven-install-mapsforge.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-# do the following
-# git clone https://code.google.com/p/mapsforge/
-# cd mapsforge; and fix http://code.google.com/p/mapsforge/issues/detail?id=461
-# mvn clean install
-# cp mapsforge-map/target/mapsforge-map-0.3.1-SNAPSHOT-jar-with-dependencies.jar graphhopper/android/libs/mapsforge-0.3.1-SNAPSHOT.jar
-
-# if we would do it via normal maven dependency management we run into strange things which I was not able to fix
-# http://stackoverflow.com/a/8315600/194609
-
-# MAVEN_HOME/bin/mvn
-MVN=mvn
-VERSION=0.4.0
-libs="map map-android map-reader core"
-
-for lib in $libs; do
-  FILE=$(ls ./libs/mapsforge-$lib-$VERSION.jar)
-  echo "installing file: $FILE"
-  ARGS="-DgroupId=com.graphhopper -DartifactId=mapsforge-$lib -Dversion=$VERSION -Dpackaging=jar -Dfile=$FILE"
-  $MVN install:install-file $ARGS
-done
diff --git a/android/settings.gradle b/android/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/android/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/config-example.properties b/config-example.properties
index 026338ae2c..29f56a2fcb 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,40 +1,49 @@
-#################
-### OSMReader ###
-
-graph.dataaccess=RAM_STORE
-# graph.dataaccess=MMAP_STORE_SYNC
-
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# Use chWeighting=no to disable it (more flexibility while querying) 
-# Java API usage is: GraphHopper.setCHWeighting("fastest")
-prepare.chWeighting=fastest
-
-# increase from 1 to 5, to reduce way geometry e.g. for android
-osmreader.wayPointMaxDistance=1
-
+##### Vehicles #####
+#
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together remeber to set "prepare.chWeighting=no" above.
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
-# and requires enabling graph.elevation.provider below, e.g. see #169
+# and requires enabling graph.elevation.provider below
 graph.flagEncoders=car
 
-# to enable turn restrictions for car do
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
 # graph.flagEncoders=car|turnCosts=true
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
-# osmreader.instructions=false
 
+##### Elevation #####
+#
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
-# default location for cache is used /tmp/srtm
+#
+# default location for cache is /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
-# If you have a slow disk or plenty of RAM change the default MMAP to
+#
+# If you have a slow disk or plenty of RAM change the default MMAP to:
 # graph.elevation.dataaccess=RAM_STORE
 
-# Location index lookup. Advanced customization. Resolution is in meter, the search specifies the 'radius' in number of tiles.
-# E.g. decrease resolution for a faster lookup and increase region search for a more dynamic search and less 'location not found' results
-# index.highResolution=300
-# index.maxRegionSearch=4
 
-# if you want to support jsonp response type you need to add it explicitely here:
-#web.jsonpAllowed=true
+
+##### Storage #####
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
+# MMAP_STORE_SYNC could be used otherwise but will be a lot slower
+graph.dataaccess=RAM_STORE
+
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
+# osmreader.instructions=false
+
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally a graph preparation via
+# contraction hierarchies is done to speed routing up. This requires more RAM/disc space for holding the
+# graph but less for every request. Also only the first vehicle of the flagEncoders list will be prepared.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
+
+
+##### Web #####
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index bc201d847c..7ffdcfced2 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,11 @@
-0.4.0
+0.4.0    
+    translation key turn changed and merged with left etc into turn_left, turn_right etc
+    create location index before preparation in the GraphHopper class
+    encodingManager.getSingle() is removed and flagEncoder list is no longer sorted, the first vehicle is used for CH preparation    
+    removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getBaseGraph(), directory) instead
+    getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
+    normal algorithms are now possible on prepared graph use getBaseGraph, see #116
+    GHResponse no longer has isFound method, use !hasErrors instead
     merged unused Edge class into EdgeEntry
     astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
     making GPX export according to the schema to support import from various tools like basecamp
@@ -14,11 +21,9 @@
     renamed less often used URL parameter 'min_path_precision' to way_point_max_distance which makes it identical to the setWayPointMaxDistance method used for simplification at OSMImport
     removed douglas.minprecision from Java API ghRequest.hints => use wayPointMaxDistance instead
     encoder.supportTurnCost is replaced by encoder.supports(TurnWeighting.class)
-    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call
+    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call, makes storing string vs. object less error-prone
     removed GHRequest.getHint, instead use the provided methods in GHRequest.getHints().getXY and GHRequest.getHints().put
-    graph incompatibility as properties cannot be loaded => version increase necessary
-        renamed osmreader.bytesForFlags to graph.bytesForFlags
-        renamed config property osmreader.acceptWay to graph.flagEncoders
+    important graph incompatibility as properties cannot be loaded. renamed osmreader.bytesForFlags to graph.bytesForFlags, renamed config property osmreader.acceptWay to graph.flagEncoders
     default weighting is now fastest, fixing #261
     moved method GraphHopper.main into tools module and class com.graphhopper.tools.Import, see #250
     refactored GraphHopper.createWeighting to accept more than one configuration option, see #237
@@ -26,13 +31,12 @@
     moving the boolean parameter of GraphHopper.setInMemory into a separate method setStoreOnFlush
     renaming of GraphHopper.setCHShortcuts to setCHWeighting, as well as the property prepare.chShortcuts to prepare.chWeighting
     jsonp is disabled by default. You need to enable it in the config.properties, see the config-example.properties
-    EncodingManager cannot be null in GraphHopperStorage since 0.4. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
+    EncodingManager cannot be null in GraphHopperStorage. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
     no reflection done in EncodingManager which improves portability and makes configuration of encoders possible before adding to manager
     removed dijkstraNativebi as no performance advantage but maintenance disadvantage and similar to oneToManyDijkstra
     to provide context for turn costs we needed to add prevEdgeId into Weighting.calcWeight, see new documentation
     with the introduction of lock protection mechanism (see #112) GraphHopper needs always write access, see also #217
-    new GraphHopper.clean method to remove the graph directory via Java API
-    FlagEncoder: replaced isFoward and isBackward with more generic isBool(flags, FlagEncoder.FORWARD|BACKWARD)
+    new GraphHopper.clean method to remove the graph directory via Java API    
 
 0.3.0
     introduced prefer bits, now bike uses more bits and 3 bike encoder do not fit into 32 bit anymore, will be fixed later
diff --git a/core/files/live_measurement.sh b/core/files/live_measurement.sh
deleted file mode 100755
index 1fbafd5ae6..0000000000
--- a/core/files/live_measurement.sh
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/bin/bash
-
-# before execution do
-# 1. cp files/measurement.sh files/live_measurement.sh
-#    to ensure that you have your customized measurement.sh file available and git has no problems to switch versions
-# 2. adapt memory usage in JAVA_OPTS
-# 3. adapt the OSM location GH_MAIN
-# 4. adapt last_commits
-
-GH_HOME=$(dirname $0)/..
-cd $GH_HOME
-
-JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
- JAVA=java
-fi
-
-VERSION=`grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1`
-JAR=target/graphhopper-$VERSION-jar-with-dependencies.jar
-
-# make sure this stays the same for all measurements
-JAVA_OPTS="-Xmx1000m -Xms1000m" 
-
-GH_MAIN=/media/SAMSUNG/maps/unterfranken
-
-# should we call?
-# mvn clean install assembly:single
-
-# import graph
-OSM_XML=$GH_MAIN.osm
-GL=$GH_MAIN-gh
-ARGS="osmreader.graph-location=$GL osmreader.osm=$OSM_XML osmreader.chWeighting=fastest osmreader.type=CAR"
-echo -e "\ncreate graph via $ARGS, $JAR"
-$JAVA $JAVA_OPTS -cp $JAR com.graphhopper.reader.OSMReader $ARGS osmreader.doPrepare=false
-
-function startMeasurement {
-  COUNT=5000
-  ARGS="$ARGS osmreader.doPrepare=true measurement.count=$COUNT measurement.location=$M_FILE_NAME"
-  echo -e "\nperform measurement via $ARGS, $JAR"
-  $JAVA $JAVA_OPTS -cp $JAR com.graphhopper.util.Measurement $ARGS
-}
-
-# use current version
-mvn -DskipTests clean install assembly:single  
-startMeasurement
-exit
-
-# use git
-last_commits=1
-commits=$(git rev-list HEAD -n $last_commits)
-for commit in $commits; do
-  git checkout $commit -q
-  M_FILE_NAME=`git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_"`
-  M_FILE_NAME="measurement$M_FILE_NAME.properties"
-  echo -e "\nusing commit $commit and $M_FILE_NAME"
-  
-  mvn -DskipTests clean install assembly:single
-  startMeasurement
-done
diff --git a/core/files/release.sh b/core/files/release.sh
deleted file mode 100755
index 4ecc63bdd1..0000000000
--- a/core/files/release.sh
+++ /dev/null
@@ -1,79 +0,0 @@
-#!/bin/bash
-
-# assumptions:
-# 1. you have run unit and integration tests successfully
-# 2. no changes on master
-
-# TODO when we understand the commands we can use the release plugin
-# mvn release:clean 
-# # Prepare: build, test, release version update, commit, tag, next snapshot version update, commit
-# mvn release:prepare -DgenerateBackupPoms=false
-# # Perform: export a release from SCM, run the deploy goal
-# mvn release:perform
-# https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
-
-GH_CORE_HOME=$(dirname $0)/..
-cd $GH_CORE_HOME
-VERSION=0.1
-NEW_VERSION=0.2-SNAPSHOT
-TARGET=./target
-GIT_E=true
-
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-# as android is not referenced in parent we need to do it manually
-cd android
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-cd ..
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout -b $VERSION
-  git add .
-  git commit -m "releasing $VERSION"
-fi
-
-
-##############################
-# create jar and android files
-mvn -DskipTests=true clean install assembly:single
-
-if [ $? -ne 0 ]; then
-  echo "cannot install jars?"
-  exit
-fi  
-
-# now create binary distribution where no maven is necessary to run import
-cp ../graphhopper.sh $TARGET/graphhopper.sh
-JAR=`cd $TARGET && ls -1 *-with-dependencies.jar`
-# use @ instead of the common / to avoid problems with paths in $JAR
-sed -i "s@JAR=.*@JAR=$JAR@g" $TARGET/graphhopper.sh
-# if you use -x option use backslash avoids shell substitution e.g. -x \*~
-zip -j $TARGET/graphhopper-$VERSION-bin.zip $TARGET/graphhopper.sh $TARGET/$JAR ../config-example.properties ../*.txt ../*.md
-
-
-########################
-# deployment to sonatype
-$MVN install deploy
-
-if [ $? -ne 0 ]; then
-  echo "cannot deploy to sonatype?"
-  exit
-fi    
-
-cd android
-export ANDROID_HOME=/install/android/sdk
-$MVN clean install deploy
-cd ..
-
-
-##########################
-# deployment to our server
-
-# TODO
-
-mvn versions:set -DnewVersion=$NEW_VERSION -DgenerateBackupPoms=false
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout master
-  git add .
-  git commit -m "new development version $NEW_VERSION"
-fi
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
index fd46e3dd5a..5f7138d9b3 100755
--- a/core/files/travis-build.sh
+++ b/core/files/travis-build.sh
@@ -1,20 +1,22 @@
 HOME=$(dirname $0)
 cd $HOME/../..
 
-modules="core web tools"
-for module in $modules; do
-  echo "====== INSTALL $module ====="
-  mvn -pl $module clean install -DskipTests=true
-  EXIT_VAL="$?"    
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi 
-  
-  echo "====== TEST $module ====="
-  # verify necessary for failsafe, otherwise it won't fail the build!?
-  mvn -pl $module test failsafe:integration-test verify  
-  EXIT_VAL="$?"
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi
-done
+mvn clean test verify
+
+#modules="core web tools"
+#for module in $modules; do
+#  echo "====== INSTALL $module ====="
+#  mvn -pl $module clean install -DskipTests=true
+#  EXIT_VAL="$?"    
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi 
+#  
+#  echo "====== TEST $module ====="
+#  # verify necessary for failsafe, otherwise it won't fail the build!?
+#  mvn -pl $module test failsafe:integration-test verify  
+#  EXIT_VAL="$?"
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi
+#done
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index ecf782503d..c9e090a465 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk vi_VI"
+translations="en_US SKIP bg ca de_DE el es fa fil fi fr gl he it ja ne nl pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 574cd0d1cd..451f8706ad 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper</artifactId>
     <name>GraphHopper</name>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging> 
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine 
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
         
     <properties>  
@@ -76,13 +76,22 @@
         <dependency>
             <groupId>com.google.protobuf</groupId>
             <artifactId>protobuf-java</artifactId>
-            <version>2.6.0</version>
+            <version>2.6.1</version>
         </dependency>        
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <!-- keep oldish version as we want to support 1.5 for a while -->
+            <version>20140107</version>
+            <scope>test</scope>
+        </dependency>
+        
     </dependencies>
         
     <build>
@@ -91,46 +100,18 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.4.1</version>
                     <configuration>                     
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
                     </configuration>
-                </plugin>
-                <plugin>
-                    <groupId>org.apache.maven.plugins</groupId>
-                    <artifactId>maven-site-plugin</artifactId>
-                    <version>3.4</version>
-                    <configuration>
-                        <reportPlugins>
-                            <plugin>
-                                <!-- either call mvn compile site or mvn findbugs:gui -->
-                                <groupId>org.codehaus.mojo</groupId>
-                                <artifactId>findbugs-maven-plugin</artifactId>
-                                <version>2.5.2</version>
-                                <configuration>
-                                    <!-- <xmlOutput>true</xmlOutput> -->
-                                    <!-- Optional directory to put FindBugs xdoc xml report -->
-                                    <xmlOutputDirectory>target/site</xmlOutputDirectory>
-                                    <threshold>Normal</threshold>
-                                    <effort>Default</effort>
-                                    <!--
-                                    <threshold>High|Normal|Low|Exp|Ignore</threshold>
-                                    <effort>Min|Default|Max</effort>
-                                    -->
-                                </configuration>
-                            </plugin>
-                        </reportPlugins>
-                    </configuration>
-                </plugin>
+                </plugin>                
                 
                 <!-- create jar with test classes to be reused in other projects -->                
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>2.4</version>
                     <executions>
                         <execution>
                             <goals>
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 9237a4342d..0d6f70f1b9 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -37,7 +37,6 @@
     private double routeWeight;
     private long time;
     private InstructionList instructions = null;
-    private boolean found;
 
     public GHResponse()
     {
@@ -131,6 +130,7 @@ public GHResponse setMillis( long timeInMillis )
      */
     public long getMillis()
     {
+        check("getMillis");
         return time;
     }
 
@@ -151,25 +151,13 @@ public double getRouteWeight()
         return routeWeight;
     }
 
-    public GHResponse setFound( boolean found )
-    {
-        this.found = found;
-        return this;
-    }
-
-    public boolean isFound()
-    {
-        check("isFound");
-        return found;
-    }
-
     /**
      * Calculates the bounding box of this route response
      */
     public BBox calcRouteBBox( BBox _fallback )
     {
         check("calcRouteBBox");
-        BBox bounds = BBox.INVERSE.clone();
+        BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = list.getSize();
         if (len == 0)
             return _fallback;
@@ -178,17 +166,14 @@ public BBox calcRouteBBox( BBox _fallback )
         {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (lat > bounds.maxLat)
-                bounds.maxLat = lat;
-
-            if (lat < bounds.minLat)
-                bounds.minLat = lat;
-
-            if (lon > bounds.maxLon)
-                bounds.maxLon = lon;
-
-            if (lon < bounds.minLon)
-                bounds.minLon = lon;
+            if (bounds.hasElevation())
+            {
+                double ele = list.getEle(i);
+                bounds.update(lat, lon, ele);
+            } else
+            {
+                bounds.update(lat, lon);
+            }
         }
         return bounds;
     }
@@ -196,7 +181,7 @@ public BBox calcRouteBBox( BBox _fallback )
     @Override
     public String toString()
     {
-        String str = "found:" + isFound() + ", nodes:" + list.getSize() + ": " + list.toString();
+        String str = "nodes:" + list.getSize() + ": " + list.toString();
         if (!instructions.isEmpty())
             str += ", " + instructions.toString();
 
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index bc2d6cc363..a3c390778e 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -63,6 +63,7 @@
     boolean enableInstructions = true;
     private boolean fullyLoaded = false;
     // for routing
+    private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
     private RoutingAlgorithmFactory algoFactory;
@@ -72,11 +73,11 @@
     private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
+    private String chWeightingStr = "fastest";
     private int periodicUpdates = -1;
     private int lazyUpdates = -1;
     private int neighborUpdates = -1;
@@ -114,9 +115,22 @@ public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
         this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
+    FlagEncoder getDefaultVehicle()
+    {
+        if (encodingManager == null)
+        {
+            throw new IllegalStateException("No encoding manager specified or loaded");
+        }
+
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
     public EncodingManager getEncodingManager()
     {
         return encodingManager;
@@ -173,18 +187,18 @@ public TraversalMode getTraversalMode()
     }
 
     /**
-     * Configures the underlying storage to be used on a well equipped server.
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
         setSimplifyResponse(true);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer with enough RAM but no
-     * network latency.
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
      */
     public GraphHopper forDesktop()
     {
@@ -193,8 +207,8 @@ public GraphHopper forDesktop()
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine like Android and
-     * Raspberry Pi with only few RAM.
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
      */
     public GraphHopper forMobile()
     {
@@ -214,6 +228,12 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
     /**
      * This method call results in an in-memory graph.
      */
@@ -261,15 +281,6 @@ private GraphHopper setUnsafeMemory()
         return this;
     }
 
-    /**
-     * Disables "CH-preparation". Use only if you know what you do.
-     */
-    public GraphHopper setDoPrepare( boolean doPrepare )
-    {
-        this.doPrepare = doPrepare;
-        return this;
-    }
-
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
@@ -279,17 +290,31 @@ public GraphHopper setDoPrepare( boolean doPrepare )
     public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+        return chWeightingStr;
+    }
+
+    /**
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
+     */
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
+        this.doPrepare = doPrepare;
+        return this;
     }
 
     /**
-     * Enables or disables contraction hierarchies. Enabled by default.
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+     * Disabling CH is only recommended for short routes or in combination with
+     * setDefaultWeightLimit and called flexibility mode
+     * <p>
+     * @see #setDefaultWeightLimit(double)
      */
     public GraphHopper setCHEnable( boolean enable )
     {
@@ -299,6 +324,17 @@ public GraphHopper setCHEnable( boolean enable )
         return this;
     }
 
+    /**
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
+     */
+    public void setDefaultWeightLimit( double defaultWeightLimit )
+    {
+        this.defaultWeightLimit = defaultWeightLimit;
+    }
+
     public boolean isCHEnabled()
     {
         return chEnabled;
@@ -516,7 +552,7 @@ public GraphHopper init( CmdArgs args )
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
@@ -532,16 +568,19 @@ public GraphHopper init( CmdArgs args )
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        String flagEncoders = args.get("graph.flagEncoders", "");
+        if (!flagEncoders.isEmpty())
+            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
@@ -687,7 +726,7 @@ public boolean load( String graphHopperFolder )
         setGraphHopperLocation(graphHopperFolder);
 
         if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
+            setEncodingManager(EncodingManager.create(ghLocation));
 
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
@@ -746,7 +785,7 @@ public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
      */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
+        initLocationIndex();
         if (chEnabled)
             algoFactory = createPrepare();
         else
@@ -754,7 +793,6 @@ protected void postProcessing()
 
         if (!isPrepared())
             prepare();
-        initLocationIndex();
     }
 
     private boolean isPrepared()
@@ -764,9 +802,10 @@ private boolean isPrepared()
 
     protected RoutingAlgorithmFactory createPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+        FlagEncoder defaultVehicle = getDefaultVehicle();
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
@@ -780,15 +819,15 @@ protected RoutingAlgorithmFactory createPrepare()
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
      * <p>
-     * @see Weighting.Params.create
-     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
-     * GHRequest
+     * @see WeightingMap
+     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
      * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
      */
-    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
-        String weighting = wMap.getWeighting();
+        String weighting = weightingMap.getWeighting();
         Weighting result;
 
         if ("shortest".equalsIgnoreCase(weighting))
@@ -820,12 +859,6 @@ public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEnco
     @Override
     public GHResponse route( GHRequest request )
     {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
-
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
@@ -848,9 +881,15 @@ public GHResponse route( GHRequest request )
 
     protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
+        if (graph == null || !fullyLoaded)
+            throw new IllegalStateException("Call load or importOrLoad before routing");
+
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+            vehicle = getDefaultVehicle().toString();
 
         if (!encodingManager.supports(vehicle))
         {
@@ -898,7 +937,19 @@ public GHResponse route( GHRequest request )
             return Collections.emptyList();
 
         String debug = "idLookup:" + sw.stop().getSeconds() + "s";
-        QueryGraph queryGraph = new QueryGraph(graph);
+
+        QueryGraph queryGraph;
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+        {
+            // fall back to normal traversing
+            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            queryGraph = new QueryGraph(graph.getBaseGraph());
+        } else
+        {
+            queryGraph = new QueryGraph(graph);
+        }
+
         queryGraph.lookup(qResults);
 
         List<Path> paths = new ArrayList<Path>(points.size() - 1);
@@ -906,14 +957,18 @@ public GHResponse route( GHRequest request )
         Weighting weighting = createWeighting(request.getHints(), encoder);
         weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                build();
 
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
             QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
-            RoutingAlgorithm algo = getAlgorithmFactory().createAlgo(queryGraph, algoOpts);
+            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
             sw = new StopWatch().start();
@@ -940,17 +995,9 @@ public GHResponse route( GHRequest request )
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-        {
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        } else
-        {
-            tmpIndex = new LocationIndexTree(graph, dir);
-        }
+        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
         tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
-
+        tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
         {
             ensureWriteAccess();
@@ -961,10 +1008,7 @@ protected LocationIndex createLocationIndex( Directory dir )
     }
 
     /**
-     * Initializes the location index. Currently this has to be done after the ch-preparation!
-     * Because - to improve performance - certain edges won't be available in a ch-graph and the
-     * index needs to know this and selects the correct nodes which still see the correct neighbors.
-     * See #116
+     * Initializes the location index after the import is done.
      */
     protected void initLocationIndex()
     {
@@ -1000,11 +1044,7 @@ protected void prepare()
         if (tmpPrepare)
         {
             ensureWriteAccess();
-            if (encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
-
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
+            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
             ((PrepareContractionHierarchies) algoFactory).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
@@ -1016,7 +1056,7 @@ protected void cleanUp()
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
@@ -1090,7 +1130,7 @@ protected void ensureWriteAccess()
      * Returns the current sum of the visited nodes while routing. Mainly for statistic and
      * debugging purposes.
      */
-    public long getVisitedSum()
+    long getVisitedSum()
     {
         return visitedSum.get();
     }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 5f81b8344f..9f76e601b5 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -20,27 +20,6 @@
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
  * <p/>
- * Usage:
- * <pre>
- *
- * // init offline graph
- * GraphHopperAPI gh = new GraphHopper().setInMemory(true);
- * gh.load("graph-hopper-folder");
- *
- * // init online service
- * GraphHopperAPI gh = new GraphHopperWeb();
- * gh.load("http://your-graphhopper-service.com");
- *
- * gh.algorithm("astar");
- * GHResponse ph = gh.route(new GHRequest(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon)));
- * print(ph.distance() + " " + ph.time());
- * PointList points = response.getPoints();
- * for(int i = 0; i &lt; points.size(); i++) {
- *    add(point.latitude(i), point.longitude(i));
- * }
- *
- * </pre>
- * <p/>
  * @author Peter Karich
  */
 public interface GraphHopperAPI
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 3b6e167958..06f694cbae 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -61,7 +61,7 @@ public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double min
 
     public LinearKeyAlgo setBounds( BBox bounds )
     {
-        setBounds(bounds.minLon, bounds.maxLat, bounds.minLat, bounds.maxLat);
+        setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
@@ -115,4 +115,5 @@ public double getLonDelta()
     {
         return lonDelta;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index 9820bbee00..00de04f07b 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -197,4 +197,10 @@ public boolean isType( int type )
     {
         return this.type == type;
     }
+
+    @Override
+    public String toString()
+    {
+        return properties.toString();
+    }        
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMWay.java b/core/src/main/java/com/graphhopper/reader/OSMWay.java
index a4e0bfcee9..3f713757b1 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMWay.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMWay.java
@@ -23,7 +23,6 @@
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
-import java.util.Map;
 
 /**
  * Represents an OSM Way
@@ -75,6 +74,6 @@ public TLongList getNodes()
     @Override
     public String toString()
     {
-        return "Way (" + getId() + ", " + nodes.size() + " nodes)";
+        return "Way id:" + getId() + ", nodes:" + nodes.size() + ", tags:" + super.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 2edee09bc7..0c612d5e7b 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -57,26 +57,28 @@ public int getDimension()
     }
 
     @Override
-    public void setNode( int id, double lat, double lon )
+    public void ensureNode( int nodeId )
     {
-//        if (is3D())
-//            throw new IllegalStateException("Can only be called if 3D is disabled");
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.ensureCapacity(tmp + rowSizeInBytes);
+    }        
 
-        _setNode(id, lat, lon, Double.NaN);
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        _setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int id, double lat, double lon, double ele )
+    public void setNode( int nodeId, double lat, double lon, double ele )
     {
-//        if (!is3D())
-//            throw new IllegalStateException("Can only be called if 3D is enabled");
-        _setNode(id, lat, lon, ele);
+        _setNode(nodeId, lat, lon, ele);
     }
 
-    private void _setNode( int id, double lat, double lon, double ele )
+    private void _setNode( int nodeId, double lat, double lon, double ele )
     {
-        long tmp = (long) id * rowSizeInBytes;
-        da.ensureCapacity(tmp + rowSizeInBytes);
+        ensureNode(nodeId);
+        long tmp = (long) nodeId * rowSizeInBytes;
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
         da.setInt(tmp + LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 12301de6c9..0de2549665 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -59,8 +59,8 @@
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
     private File cacheDir = new File("/tmp/cgiar");
-    // String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
-    private String baseUrl = "http://droppr.org/srtm/v4.1/6_5x5_TIFs";
+    // for alternatives see #346
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";    
     private Directory dir;
     private DAType daType = DAType.MMAP;
     final double precision = 1e7;
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 5f9cd07277..56ba796d60 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -96,6 +96,9 @@ private Path runAlgo()
         {
             int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitReached())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
@@ -109,7 +112,7 @@ private Path runAlgo()
                 int traversalId = traversalMode.createTraversalId(iter, false);
                 // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
                 float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
-                                                      + currEdge.weightOfVisitedPath);
+                        + currEdge.weightOfVisitedPath);
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
@@ -124,7 +127,7 @@ private Path runAlgo()
                         fromMap.put(traversalId, ase);
                     } else
                     {
-                        assert(ase.weight > distEstimation): "Inconsistent distance estimate";
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
@@ -173,6 +176,11 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index fd854eb62e..f8a92e1bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -162,6 +162,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -178,8 +181,13 @@ protected boolean finished()
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight();
-        return currFrom.weight + currTo.weight >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index c2fb75debd..2a047c7434 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,6 +40,8 @@
 
     protected abstract Path createAndInitPath();
 
+    protected abstract boolean isWeightLimitReached();
+
     abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
 
     abstract boolean fillEdgesFrom();
@@ -62,9 +64,9 @@ public Path calcPath( int from, int to )
         return extractPath();
     }
 
-    void runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitReached())
         {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 8c13e4e0df..62349b3d81 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -38,6 +38,7 @@
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
     protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
@@ -57,6 +58,12 @@ public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting wei
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
     }
 
+    @Override
+    public void setWeightLimit( double weight )
+    {
+        this.weightLimit = weight;
+    }
+       
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
     {
         this.additionalEdgeFilter = additionalEdgeFilter;
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 031fe22b6c..16d7cd0df6 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -38,11 +38,11 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
     public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
@@ -66,16 +66,17 @@ public Path calcPath( int from, int to )
         {
             fromMap.put(from, currEdge);
         }
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitReached() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
@@ -111,13 +112,12 @@ private Path runAlgo()
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
@@ -129,20 +129,26 @@ protected boolean finished()
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitReached() || !finished())
             return createEmptyPath();
+
         return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
     {
-        return AlgorithmOptions.DIJKSTRA;
+        return visitedNodes;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 24e62ba052..71bbe643d8 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -36,8 +36,7 @@
  * Calculates best path in bidirectional way.
  * <p/>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p/>
- * @see DijkstraBidirection for an array based but more complicated version
+ * <p>
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -129,6 +128,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -177,6 +179,12 @@ public boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
             TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
@@ -252,12 +260,6 @@ protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurre
         }
     }
 
-    @Override
-    public String getName()
-    {
-        return AlgorithmOptions.DIJKSTRA_BI;
-    }
-
     TIntObjectMap<EdgeEntry> getBestFromMap()
     {
         return bestWeightMapFrom;
@@ -302,4 +304,10 @@ void setBestPath( PathBidirRef bestPath )
     {
         this.bestPath = bestPath;
     }
+
+    @Override
+    public String getName()
+    {
+        return AlgorithmOptions.DIJKSTRA_BI;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 5056a82dfa..0efde326a6 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -22,7 +22,6 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
@@ -45,7 +44,6 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
@@ -68,12 +66,6 @@ public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting,
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
@@ -95,8 +87,9 @@ public Path extractPath()
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitReached())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
@@ -145,7 +138,7 @@ public int findEndNode( int from, int to )
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode != EMPTY_PARENT && weights[to] < weights[currNode])
+            if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
                 return to;
 
             if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
@@ -164,7 +157,7 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                int adjNode = iter.getAdjNode();                
+                int adjNode = iter.getAdjNode();
                 int prevEdgeId = edgeIds[adjNode];
                 if (!accept(iter, prevEdgeId))
                     continue;
@@ -192,7 +185,7 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitReached())
                 return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
@@ -207,7 +200,12 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return weights[currNode] >= weightLimit;
     }
 
     public void close()
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index ae76e32ae9..db99ddd34a 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -34,6 +35,7 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
@@ -214,10 +216,10 @@ protected void processEdge( int edgeId, int adjNode )
      */
     protected long calcMillis( double distance, long flags, boolean revert )
     {
-        if (revert && !encoder.isBool(flags, FlagEncoder.K_BACKWARD)
-                || !revert && !encoder.isBool(flags, FlagEncoder.K_FORWARD))
+        if (revert && !encoder.isBackward(flags)
+                || !revert && !encoder.isForward(flags))
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
-                    + "Reverse:" + revert + ", fwd:" + encoder.isBool(flags, FlagEncoder.K_FORWARD) + ", bwd:" + encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
 
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
@@ -256,7 +258,7 @@ private void forEveryEdge( EdgeVisitor visitor )
                         + ", array index:" + i + ", edges:" + edgeIds.size());
 
             tmpNode = edgeBase.getBaseNode();
-            // later: more efficient swap
+            // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
             edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
@@ -384,22 +386,29 @@ public InstructionList calcInstructions( final Translation tr )
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
                 long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -408,86 +417,178 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                    updatePointsAndInstruction(edge, wayGeo);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                     ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                    if ((!name.equals(tmpName))
-                            || (!annotation.equals(tmpAnnotation)))
+                    if (isRoundabout)
+                    // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                    annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // check if there is an exit at the same node the roundabout was entered
+                                EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                while (edgeIter.next()) 
+                                {
+                                    if ((edgeIter.getAdjNode() != prevNode) 
+                                         && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
+                                    {
+                                        roundaboutInstruction.increaseExitNumber();
+                                        break;
+                                    }
+                                }
+
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
+
+                        // Add passed exits to instruction. A node is countet if there is at least one outgoing edge
+                        // out of the roundabout
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        while (edgeIter.next())
+                        {
+                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            {
+                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                                break;
+                            }
+                        }
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
+                    {
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                                .setRadian(deltaInOut)
+                                .setDirOfRotation(deltaOut)
+                                .setExited();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        annotation = tmpAnnotation;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11°
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, annotation, points);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                         ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
-                else
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                } else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong = wayGeo.getLongitude(beforeLast);
                 }
+                
+                prevInRoundabout = isRoundabout;
+                prevNode = baseNode;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
                     ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -496,7 +597,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index e60c3fd638..ffbb943041 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,10 +19,7 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -54,6 +51,8 @@
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
+    private final QueryGraph baseGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
@@ -66,8 +65,6 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = Helper.DIST_PLANE;
-    private final GraphExtension wrappedExtension;
 
     public QueryGraph( Graph graph )
     {
@@ -80,11 +77,22 @@ public QueryGraph( Graph graph )
             wrappedExtension = new QueryGraphTurnExt(this);
         else
             wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this);
     }
 
-    public Graph getOriginalGraph()
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
     {
-        return mainGraph;
+        mainGraph = graph;
+        baseGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
     }
 
     /**
@@ -108,9 +116,13 @@ public void lookup( List<QueryResult> resList )
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
+        // initialize all none-final variables
         virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        baseGraph.virtualEdges = virtualEdges;
+        baseGraph.virtualNodes = virtualNodes;
+        baseGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
@@ -196,8 +208,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -263,6 +275,25 @@ public int compare( QueryResult o1, QueryResult o2 )
         });
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        return baseGraph;
+    }
+
+    public boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
+    public boolean isVirtualNode( int nodeId )
+    {
+        return nodeId >= mainNodes;
+    }
+
     class QueryGraphTurnExt extends TurnCostExtension
     {
         private final TurnCostExtension mainTurnExtension;
@@ -283,7 +314,7 @@ public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
                 if (isVirtualEdge(edgeFrom))
                 {
                     edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
-                }                
+                }
                 if (isVirtualEdge(edgeTo))
                 {
                     edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
@@ -312,7 +343,7 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
         PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
         int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
@@ -337,18 +368,14 @@ public NodeAccess getNodeAccess()
         return nodeAccess;
     }
 
-    private boolean isVirtualNode( int node )
-    {
-        return node >= mainNodes;
-    }
-
-    private boolean isVirtualEdge( int edgeId )
-    {
-        return edgeId >= mainEdges;
-    }
-
     private final NodeAccess nodeAccess = new NodeAccess()
     {
+        @Override
+        public void ensureNode( int nodeId )
+        {
+            mainNodeAccess.ensureNode(nodeId);
+        }
+
         @Override
         public boolean is3D()
         {
@@ -495,7 +522,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
             //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
@@ -503,7 +530,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
@@ -559,7 +586,7 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
     void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
     {
         if (isVirtualNode(towerNode))
-            throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
+            throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
         TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index 1e5436f154..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -34,6 +34,12 @@
      */
     Path calcPath( int from, int to );
 
+    /**
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
+     */
+    void setWeightLimit( double weight );
+
     /**
      * @return name of this algorithm
      */
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index ce088beeee..ae6609148f 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -32,7 +32,7 @@
 {
     @Override
     public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {
+    {        
         AbstractRoutingAlgorithm algo;
         String algoStr = opts.getAlgorithm();
         if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 54807733e7..fe8163b088 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -30,17 +30,20 @@
  */
 public class Path4CH extends PathBidirRef
 {
-    public Path4CH( Graph g, FlagEncoder encoder )
+    private final Graph routingGraph;
+
+    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
     {
-        super(g, encoder);
+        super(baseGraph, encoder);
+        this.routingGraph = routingGraph;
     }
 
     @Override
-    protected void processEdge( int tmpEdge, int endNode )
+    protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) graph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
     }
 
     private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
@@ -58,6 +61,8 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         int skippedEdge1 = mainEdgeState.getSkippedEdge1();
         int skippedEdge2 = mainEdgeState.getSkippedEdge2();
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
+
+        // get properties like speed of the edge in the correct direction
         if (reverse)
         {
             int tmp = from;
@@ -68,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index fd3006faf1..9fa3bf8ed4 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -37,13 +37,13 @@ public PreparationWeighting( Weighting userWeighting )
     }
 
     @Override
-    public double getMinWeight( double distance )
+    public final double getMinWeight( double distance )
     {
         return userWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         if (edgeState instanceof EdgeSkipIterState)
         {
@@ -60,9 +60,4 @@ public String toString()
     {
         return "PREPARE+" + userWeighting.toString();
     }
-
-    Weighting getUserWeighting()
-    {
-        return userWeighting;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 5c97aa8cd0..9d2bd2f7e4 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -25,13 +25,7 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import java.util.*;
 import org.slf4j.Logger;
@@ -60,7 +54,10 @@
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
+    private final LevelEdgeFilter levelFilter;
+    private int maxLevel;
     private final LevelGraph prepareGraph;
+
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
@@ -68,7 +65,6 @@
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
     private DijkstraOneToMany prepareAlgo;
-    private boolean removesHigher2LowerEdges = true;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
@@ -83,20 +79,20 @@
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
 
-    public PrepareContractionHierarchies( LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
+    public PrepareContractionHierarchies( Directory dir, LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
         this.prepareGraph = g;
         this.traversalMode = traversalMode;
         this.prepareFlagEncoder = encoder;
         long scFwdDir = encoder.setAccess(0, true, false);
+        levelFilter = new LevelEdgeFilter(prepareGraph);
 
         // shortcuts store weight in flags where we assume bit 1 and 2 are used for access restriction
         if ((scFwdDir & PrepareEncoder.getScFwdDir()) == 0)
-            throw new IllegalArgumentException("Currently only one vehicle is supported if you enable CH. "
-                    + "It seems that you have imported more than one.");
+            throw new IllegalArgumentException("Enabling the speed-up mode is currently only supported for the first vehicle.");
 
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = new GHDirectory("", DAType.RAM_INT).find("originalEdges");
+        originalEdges = dir.find("original_edges");
         originalEdges.create(1000);
     }
 
@@ -182,18 +178,6 @@ public void setInitialCollectionSize( int initialCollectionSize )
         this.initialCollectionSize = initialCollectionSize;
     }
 
-    /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
-     */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
-    {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
-    }
-
     @Override
     public void doWork()
     {
@@ -228,15 +212,15 @@ boolean prepareEdges()
         return c > 0;
     }
 
-    // TODO we can avoid node level if we store this into a temporary array and 
-    // disconnect all edges which goes from higher to lower level
-    // uninitialized nodes have a level of 0
-    // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = prepareGraph.getNodes();
+        int nodes = prepareGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            prepareGraph.setLevel(node, maxLevel);
+        }
 
-        for (int node = 0; node < len; node++)
+        for (int node = 0; node < nodes; node++)
         {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
@@ -269,7 +253,7 @@ void contractNodes()
 
         // disable as preparation is slower and query time does not benefit
         long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0l
+                ? 0L
                 : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
@@ -285,7 +269,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) prepareGraph);
+        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -293,10 +277,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = lg.getNodes();
+                int len = prepareGraph.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (lg.getLevel(node) != 0)
+                    if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -345,25 +329,18 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            lg.setLevel(polledNode, level);
+            prepareGraph.setLevel(polledNode, level);
             level++;
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
-            {
-                while (!sortedNodes.isEmpty())
-                {
-                    polledNode = sortedNodes.pollKey();
-                    lg.setLevel(polledNode, level);
-                }
+                // skipped nodes are already set to maxLevel
                 break;
-            }
 
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (lg.getLevel(nn) != 0)
-                    // already contracted no update necessary
+                if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
@@ -377,8 +354,7 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                if (removesHigher2LowerEdges)
-                    lg.disconnect(vehicleAllTmpExplorer, iter);
+                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
@@ -389,7 +365,6 @@ void contractNodes()
                 + ", new shortcuts: " + newShortcuts
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
-                + ", removeHigher2LowerEdges:" + removesHigher2LowerEdges
                 + ", dijkstras:" + dijkstraCount
                 + ", t(dijk):" + (int) dijkstraSW.getSeconds()
                 + ", t(period):" + (int) periodSW.getSeconds()
@@ -486,8 +461,6 @@ public void foundShortcut( int u_fromNode, int w_toNode,
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            // minor improvement: if (shortcuts.containsKey(sc) 
-            // then two shortcuts with the same nodes (u<->n.adjNode) exists => check current shortcut against both
             Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
                 return;
@@ -579,7 +552,7 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (prepareGraph.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
                 continue;
 
             double v_u_dist = incomingEdges.getDistance();
@@ -595,7 +568,7 @@ void findShortcuts( ShortcutHandler sch )
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (prepareGraph.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
+                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
@@ -607,11 +580,12 @@ void findShortcuts( ShortcutHandler sch )
                             + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
                             + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
 
-                if (existingDirectWeight >= Double.MAX_VALUE)
+                if (Double.isInfinite(existingDirectWeight))
                     continue;
+
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                prepareAlgo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
                         .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
@@ -710,14 +684,32 @@ PrepareContractionHierarchies initFromGraph()
     {
         vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
         vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        vehicleAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph);
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
+        {
+            @Override
+            public final boolean accept( EdgeIteratorState edgeState )
+            {
+                if (!super.accept(edgeState))
+                    return false;
+
+                return allFilter.accept(edgeState);
+            }
+        };
+
+        maxLevel = prepareGraph.getNodes() + 1;
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
         // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        //      Important because Graph is increasing until the end.
         //   2. is slightly faster
-        //   but we need additional priorities array to keep old value which is necessary for update method
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
         oldPriorities = new int[prepareGraph.getNodes()];
         prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
@@ -732,11 +724,13 @@ public int getShortcuts()
     static class IgnoreNodeFilter implements EdgeFilter
     {
         int avoidNode;
+        int maxLevel;
         LevelGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g )
+        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
         {
             this.graph = g;
+            this.maxLevel = maxLevel;
         }
 
         public IgnoreNodeFilter setAvoidNode( int node )
@@ -748,9 +742,9 @@ public IgnoreNodeFilter setAvoidNode( int node )
         @Override
         public final boolean accept( EdgeIteratorState iter )
         {
-            // ignore if it is skipNode or a adjNode already contracted
+            // ignore if it is skipNode or adjNode is already contracted
             int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == 0;
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
         }
     }
 
@@ -791,15 +785,18 @@ protected boolean finished()
                     if (finishedFrom && finishedTo)
                         return true;
 
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
+
                     // changed finish condition for CH
-                    double tmpWeight = bestPath.getWeight();
-                    return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
                 }
 
                 @Override
+
                 protected Path createAndInitPath()
                 {
-                    bestPath = new Path4CH(graph, flagEncoder);
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
                     return bestPath;
                 }
 
@@ -810,6 +807,7 @@ public String getName()
                 }
 
                 @Override
+
                 public String toString()
                 {
                     return getName() + "|" + prepareWeighting;
@@ -834,6 +832,9 @@ public boolean finished()
                     if (finishedFrom && finishedTo)
                         return true;
 
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
+
                     // changed also the final finish condition for CH                
                     return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
                 }
@@ -841,7 +842,7 @@ public boolean finished()
                 @Override
                 protected Path createAndInitPath()
                 {
-                    bestPath = new Path4CH(graph, flagEncoder);
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
                     return bestPath;
                 }
 
@@ -862,9 +863,7 @@ public String toString()
             throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
         }
 
-        if (!removesHigher2LowerEdges)
-            algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
-
+        algo.setEdgeFilter(levelFilter);
         return algo;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index f5ccd483c7..409bc6a307 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -17,18 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.Collection;
 import java.util.HashSet;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.util.*;
 import java.util.*;
 
@@ -44,7 +40,7 @@
 public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
 {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-
+    private final static int K_FORWARD = 0, K_BACKWARD = 1;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
@@ -643,6 +639,18 @@ protected boolean isAccept( long internalFlags )
         return (internalFlags & acceptBit) != 0;
     }
 
+    @Override
+    public boolean isBackward( long flags )
+    {
+        return (flags & backwardBit) != 0;
+    }
+
+    @Override
+    public boolean isForward( long flags )
+    {
+        return (flags & forwardBit) != 0;
+    }
+
     @Override
     public long setBool( long flags, int key, boolean value )
     {
@@ -665,9 +673,9 @@ public boolean isBool( long flags, int key )
         switch (key)
         {
             case K_FORWARD:
-                return (flags & forwardBit) != 0;
+                return isForward(flags);
             case K_BACKWARD:
-                return (flags & backwardBit) != 0;
+                return isBackward(flags);
             case K_ROUNDABOUT:
                 return (flags & roundaboutBit) != 0;
             default:
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 4fe1beb474..886c62c6a0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -199,7 +199,7 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
             double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
             double maxSpeed = getHighwaySpeed("cycleway");
-            if (isBool(flags, K_FORWARD))
+            if (isForward(flags))
             {
                 // use weighted mean so that longer incline infuences speed more than shorter
                 double speed = getSpeed(flags);
@@ -211,7 +211,7 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
                 flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
 
-            if (isBool(flags, K_BACKWARD))
+            if (isBackward(flags))
             {
                 double speedReverse = getReverseSpeed(flags);
                 double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 084b956469..8f4383e2aa 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -65,6 +65,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
@@ -84,6 +85,9 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
+        // make intermodal connections possible but mark as pushing section
+        acceptedRailways.add("platform");
+
         unpavedSurfaceTags.add("unpaved");
         unpavedSurfaceTags.add("gravel");
         unpavedSurfaceTags.add("ground");
@@ -224,6 +228,11 @@ public long acceptWay( OSMWay way )
                 if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
                     return acceptBit | ferryBit;
             }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                return acceptBit;
+
             return 0;
         }
 
@@ -256,6 +265,9 @@ public long acceptWay( OSMWay way )
         String sacScale = way.getTag("sac_scale");
         if (sacScale != null)
         {
+            if ((way.hasTag("highway", "cycleway"))
+                    && (way.hasTag("sac_scale", "hiking")))
+                return acceptBit;
             if (!allowedSacScale(sacScale))
                 return 0;
         }
@@ -264,8 +276,8 @@ public long acceptWay( OSMWay way )
 
     boolean allowedSacScale( String sacScale )
     {
-        // other scales are nearly impossible by bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
-        return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale);
+        // other scales are nearly impossible by an ordinary bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale);
     }
 
     @Override
@@ -309,6 +321,12 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             encoded = handleSpeed(way, speed, encoded);
             encoded = handleBikeRelated(way, encoded, relationFlags > UNCHANGED.getValue());
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way,
@@ -458,8 +476,12 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
                 weightToPrioMap.put(40d, UNCHANGED.getValue());
         }
 
-        if (pushingSections.contains(highway) || "parking_aisle".equals(service))
+        if (pushingSections.contains(highway)
+                || way.hasTag("bicycle", "use_sidepath")
+                || "parking_aisle".equals(service))
+        {
             weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+        }
 
         if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
         {
@@ -574,19 +596,26 @@ public long setLong( long flags, int key, long value )
 
     boolean isPushingSection( OSMWay way )
     {
-        return way.hasTag("highway", pushingSections);
+        return way.hasTag("highway", pushingSections) || way.hasTag("railway", "platform");
     }
 
     protected long handleSpeed( OSMWay way, double speed, long encoded )
     {
         encoded = setSpeed(encoded, speed);
 
-        // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+        // handle oneways        
+        boolean isOneway = way.hasTag("oneway", oneways)
+                || way.hasTag("vehicle:backward")
+                || way.hasTag("vehicle:forward");
+
+        if ((isOneway || way.hasTag("junction", "roundabout"))
                 && !way.hasTag("oneway:bicycle", "no")
+                && !way.hasTag("bicycle:backward")
                 && !way.hasTag("cycleway", oppositeLanes))
         {
-            if (way.hasTag("oneway", "-1"))
+            boolean isBackward = way.hasTag("oneway", "-1")
+                    || way.hasTag("vehicle:forward", "no");
+            if (isBackward)
                 encoded |= backwardBit;
             else
                 encoded |= forwardBit;
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 32dc4a7a49..4916bd8126 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -68,6 +68,7 @@ boolean isPushingSection( OSMWay way )
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return way.hasTag("highway", pushingSections)
+                || way.hasTag("railway", "platform")
                 || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index f2ca16fcbe..6bf97ce87a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -69,6 +69,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         restrictedValues.add("no");
         restrictedValues.add("restricted");
         restrictedValues.add("delivery");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("permissive");
@@ -144,7 +145,7 @@ protected double getSpeed( OSMWay way )
         String highwayValue = way.getTag("highway");
         Integer speed = defaultSpeedMap.get(highwayValue);
         if (speed == null)
-            throw new IllegalStateException(toString() + ", no speed found for:" + highwayValue);
+            throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
 
         if (highwayValue.equals("track"))
         {
@@ -236,9 +237,18 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             if (isRoundabout)
                 encoded = setBool(encoded, K_ROUNDABOUT, true);
 
-            if (way.hasTag("oneway", oneways) || isRoundabout)
+            boolean isOneway = way.hasTag("oneway", oneways)
+                    || way.hasTag("vehicle:backward")
+                    || way.hasTag("vehicle:forward")
+                    || way.hasTag("motor_vehicle:backward")
+                    || way.hasTag("motor_vehicle:forward");
+
+            if (isOneway || isRoundabout)
             {
-                if (way.hasTag("oneway", "-1"))
+                boolean isBackward = way.hasTag("oneway", "-1")
+                        || way.hasTag("vehicle:forward", "no")
+                        || way.hasTag("motor_vehicle:forward", "no");
+                if (isBackward)
                     encoded |= backwardBit;
                 else
                     encoded |= forwardBit;
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index 1cdd5bada9..e86ca2c43d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -47,7 +47,7 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     public final boolean accept( EdgeIteratorState iter )
     {
         long flags = iter.getFlags();
-        return out && encoder.isBool(flags, FlagEncoder.K_FORWARD) || in && encoder.isBool(flags, FlagEncoder.K_BACKWARD);
+        return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 8823be538b..a108e4826c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -29,12 +29,12 @@
     /**
      * @return true if the current edge should be processed and false otherwise.
      */
-    boolean accept( EdgeIteratorState edgeIterState );
+    boolean accept( EdgeIteratorState edgeState );
 
     static final EdgeFilter ALL_EDGES = new EdgeFilter()
     {
         @Override
-        public final boolean accept( EdgeIteratorState edgeIterState )
+        public final boolean accept( EdgeIteratorState edgeState )
         {
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index e2c2d6c18e..4b2aa8a183 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -26,6 +26,7 @@
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
+import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import java.util.*;
@@ -100,19 +101,13 @@ public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEd
             throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
         this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
-
-        Collections.sort(flagEncoders, new Comparator<FlagEncoder>()
-        {
-            @Override
-            public int compare( FlagEncoder o1, FlagEncoder o2 )
-            {
-                return o1.toString().compareTo(o2.toString());
-            }
-        });
         for (FlagEncoder flagEncoder : flagEncoders)
         {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
     public int getBytesForFlags()
@@ -272,11 +267,6 @@ public long handleWayTags( OSMWay way, long includeWay, long relationFlags )
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
@@ -308,17 +298,6 @@ public String toDetailsString()
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
-
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("No encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
@@ -415,6 +394,9 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
         }
     }
 
+    /**
+     * The returned list is never empty.
+     */
     public List<FlagEncoder> fetchEdgeEncoders()
     {
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 789e41a269..3a5a7f1632 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -38,7 +38,7 @@
     public FastestWeighting( FlagEncoder encoder )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed() * SPEED_CONV;
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
     @Override
@@ -53,7 +53,7 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / (speed * SPEED_CONV);
+        return edge.getDistance() / speed * SPEED_CONV;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index b68eb0740f..96b6a599d3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -69,19 +69,21 @@
      */
     long setProperties( double speed, boolean forward, boolean backward );
 
-    /*
-     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
-     * uses a minimum value which is two magnitudes higher than in the super class. 
-     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
-     */
     /**
      * Reports wether the edge is available in forward direction for a certain vehicle
      */
-    static final int K_FORWARD = 0;
+    boolean isForward( long flags );
+
     /**
      * Reports wether the edge is available in backward direction for a certain vehicle
      */
-    static final int K_BACKWARD = 1;
+    boolean isBackward( long flags );
+
+    /*
+     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
+     * uses a minimum value which is two magnitudes higher than in the super class. 
+     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
+     */
     /**
      * Reports wether this edge is part of a roundabout.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index e72d4688f0..b12a5fa846 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -67,6 +67,7 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
@@ -81,7 +82,6 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         setBlockByDefault(false);
         potentialBarriers.add("gate");
 
-        acceptedRailways.add("station");
         acceptedRailways.add("platform");
 
         safeHighwayTags.add("footway");
@@ -99,10 +99,12 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         avoidHighwayTags.add("primary_link");
         avoidHighwayTags.add("tertiary");
         avoidHighwayTags.add("tertiary_link");
-        avoidHighwayTags.add("cycleway");
+        // for now no explicit avoiding #257
+        //avoidHighwayTags.add("cycleway"); 
 
         allowedHighwayTags.addAll(safeHighwayTags);
         allowedHighwayTags.addAll(avoidHighwayTags);
+        allowedHighwayTags.add("cycleway");
         allowedHighwayTags.add("secondary");
         allowedHighwayTags.add("secondary_link");
         allowedHighwayTags.add("unclassified");
@@ -191,6 +193,11 @@ public long acceptWay( OSMWay way )
                 if (footTag == null || "yes".equals(footTag))
                     return acceptBit | ferryBit;
             }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                return acceptBit;
+
             return 0;
         }
 
@@ -279,6 +286,12 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
 
             encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
@@ -353,16 +366,24 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
             weightToPrioMap.put(100d, PREFER.getValue());
 
         double maxSpeed = getMaxSpeed(way);
-        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20
-                || way.hasTag("sidewalk", sidewalks))
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20)
         {
             weightToPrioMap.put(40d, PREFER.getValue());
-
             if (way.hasTag("tunnel", intendedValues))
                 weightToPrioMap.put(40d, UNCHANGED.getValue());
         }
 
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 50 || way.hasTag("bicycle", "official"))
+        if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
+        {
+            weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
+        }
+
+        if (way.hasTag("sidewalk", sidewalks))
+        {
+            weightToPrioMap.put(45d, PREFER.getValue());
+        }
+
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
         {
             weightToPrioMap.put(50d, REACH_DEST.getValue());
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 0f5954ad1e..985a4477d5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.EdgeSkipIterator;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -28,21 +30,25 @@
 public class LevelEdgeFilter implements EdgeFilter
 {
     private final LevelGraph graph;
-    private final int nodes;
+    private final int maxNodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
-        nodes = g.getNodes();
+        maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIter )
+    public boolean accept( EdgeIteratorState edgeIterState )
     {
-        int base = edgeIter.getBaseNode();
-        int adj = edgeIter.getAdjNode();
-        // for now workaround for #288
-        if (base >= nodes || adj >= nodes)
+        int base = edgeIterState.getBaseNode();
+        int adj = edgeIterState.getAdjNode();
+        // always accept virtual edges, see #288
+        if (base >= maxNodes || adj >= maxNodes)
+            return true;
+
+        // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
+        if (((EdgeSkipIterState) edgeIterState).isShortcut())
             return true;
 
         return graph.getLevel(base) <= graph.getLevel(adj);
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 1a2293824c..a02bf36a83 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -43,21 +43,19 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final EncodingManager encodingManager;
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
-        this.encodingManager = em;
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -66,9 +64,9 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
-    public PrepareRoutingSubnetworks setMinOnewayNetworkSize( int minOnewayNetworkSize )
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
     {
-        this.minOnewayNetworkSize = minOnewayNetworkSize;
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
         return this;
     }
 
@@ -78,9 +76,9 @@ public void doWork()
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
 
-        int unvisitedDeadEnds = 0;
-        if ((this.minOnewayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+        int unvisitedDeadEnds = -1;
+        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
@@ -231,9 +229,9 @@ int removeZeroDegreeNodes()
 
     /**
      * Clean small networks that will be never be visited by this explorer See #86 For example,
-     * small areas like parking lots are sometimes connected to the whole network through a one-way road.
-     * This is clearly an error - but is causes the routing to fail when point get connected to this
-     * small area. This routines removed all these points from the graph.
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when point get connected
+     * to this small area. This routines removed all these points from the graph.
      * <p/>
      * @return number of removed nodes;
      */
@@ -245,12 +243,14 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
 
         // remove components less than minimum size
         int removed = 0;
-        for (TIntArrayList component : components) {
-
-            if (component.size() < minOnewayNetworkSize) {
-                for (int i = 0; i < component.size(); i++) {
+        for (TIntArrayList component : components)
+        {
+            if (component.size() < minOneWayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
                     g.markNodeRemoved(component.get(i));
-                    removed ++;
+                    removed++;
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index 9ccb9e1855..3d2119d059 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -141,6 +141,7 @@ boolean isPushingSection( OSMWay way )
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return way.hasTag("highway", pushingSections)
+                || way.hasTag("railway", "platform")
                 || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
deleted file mode 100644
index b88bc1e5fe..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Integration tests for one bigger area - at the moment Unterfranken (Germany). Execute via
- * ./graphhopper.sh test unterfranken.osm
- * <p/>
- * @author Peter Karich
- */
-public class RoutingAlgorithmSpecialAreaTests
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Graph unterfrankenGraph;
-    private final LocationIndex idx;
-
-    public RoutingAlgorithmSpecialAreaTests( GraphHopper graphhopper )
-    {
-        this.unterfrankenGraph = graphhopper.getGraph();
-        StopWatch sw = new StopWatch().start();
-        idx = graphhopper.getLocationIndex();
-        logger.info(idx.getClass().getSimpleName() + " index. Size:"
-                + (float) idx.getCapacity() / (1 << 20) + " MB, took:" + sw.stop().getSeconds());
-    }
-
-    public void start()
-    {
-        testIndex();
-        testAlgos();
-    }
-
-    void testAlgos()
-    {
-        if (unterfrankenGraph instanceof LevelGraph)
-        {
-            throw new IllegalStateException("run testAlgos only with a none-LevelGraph. Use prepare.chWeighting=no "
-                    + "Or use prepare.chWeighting=shortest and avoid the preparation");
-        }
-
-        TestAlgoCollector testCollector = new TestAlgoCollector("testAlgos");
-        final EncodingManager encodingManager = new EncodingManager("CAR", 4);
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        boolean ch = true;
-        Collection<AlgoHelperEntry> prepares = createAlgos(unterfrankenGraph, idx,
-                carEncoder, ch, TraversalMode.NODE_BASED, new ShortestWeighting(), encodingManager);
-        EdgeFilter ef = new DefaultEdgeFilter(carEncoder);
-
-        for (AlgoHelperEntry entry : prepares)
-        {
-            int failed = testCollector.errors.size();
-
-            OneRun or = new OneRun(50.0314, 10.5105, 50.0303, 10.5070, 571, 22);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(49.51451, 9.967346, 50.2920, 10.4650, 107909, 1929);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(50.0780, 9.1570, 49.5860, 9.9750, 95562, 1556);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(50.2800, 9.7190, 49.8960, 10.3890, 81016, 1724);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(49.8020, 9.2470, 50.4940, 10.1970, 134767, 2295);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(49.72449, 9.23482, 50.4140, 10.2750, 140809, 2680);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-            or = new OneRun(50.1100, 10.7530, 49.6500, 10.3410, 77381, 1863);
-            testCollector.assertDistance(entry, or.getList(idx, ef), or);
-
-            System.out.println("unterfranken " + entry + ", " + (testCollector.errors.size() - failed) + " failed");
-        }
-
-        testCollector.printSummary();
-    }
-
-    public static Collection<AlgoHelperEntry> createAlgos( Graph g,
-            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
-            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
-    {
-        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
-        // later: include dijkstraOneToMany        
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
-
-        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
-        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
-        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
-        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
-        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
-
-        if (withCh)
-        {
-            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(graphCH, encoder, weighting, tMode);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
-            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo( Graph qGraph )
-                {
-                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
-                }
-            });
-
-            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo( Graph qGraph )
-                {
-                    return prepareCH.createAlgo(qGraph, astarbiOpts);
-                }
-            });
-        }
-        return prepare;
-    }
-
-    void testIndex()
-    {
-        TestAlgoCollector testCollector = new TestAlgoCollector("testIndex");
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.080539, 10.125854, 63.35);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.081146, 10.124496, 0.0);
-        testCollector.queryIndex(unterfrankenGraph, idx, 49.68243, 9.933271, 436.29);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.066495, 10.191836, 14.63);
-
-        testCollector.printSummary();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index ea502b4fcc..66d437d1ac 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -48,7 +48,7 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
-        QueryGraph queryGraph = new QueryGraph(algoEntry.originalGraph);
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
         queryGraph.lookup(queryList);
         AlgorithmOptions opts = algoEntry.opts;
         FlagEncoder encoder = opts.getFlagEncoder();
@@ -70,10 +70,10 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
         GHResponse rsp = new GHResponse();
         pathMerger.doWork(rsp, viaPaths, trMap.getWithFallBack(Locale.US));
 
-        if (!rsp.isFound())
+        if (rsp.hasErrors())
         {
-            errors.add(algoEntry + " returns no path! expected distance: " + rsp.getDistance()
-                    + ", expected points: " + oneRun + ". " + queryList);
+            errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
+                    + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
         }
 
@@ -148,17 +148,27 @@ void printSummary()
 
     public static class AlgoHelperEntry
     {
-        private Graph originalGraph;
+        private Graph queryGraph;
         private final LocationIndex idx;
         private AlgorithmOptions opts;
 
         public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
         {
-            this.originalGraph = g;
+            this.queryGraph = g;
             this.opts = opts;
             this.idx = idx;
         }
 
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
         public void setAlgorithmOptions( AlgorithmOptions opts )
         {
             this.opts = opts;
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
similarity index 60%
rename from core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
rename to core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 57d8dbc81b..21fbf67926 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -1,71 +1,91 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage.index;
+package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.*;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
 
 /**
- * The LevelGraph has some edges disconnected (to be more efficient), but this happens before the
- * index is created! So we need to take care of this and also ignore the introduced shortcuts e.g.
- * for calculating closest edges.
- * <p/>
- * TODO avoid some of the tricks if we move a disconnected edge to the end of the edge-list (instead
- * of just disconnecting them). And then while accessing them break iteration if we encounter the
- * first of those disconnected edges (this should have the same speed). Therefor we also need to
- * change the EdgeFilter interface and add a stop(EdgeIterator) method or similar.
- * <p/>
  * @author Peter Karich
  */
-public class LocationIndexTreeSC extends LocationIndexTree
+class BaseGraph implements Graph
 {
-    private final static EdgeFilter NO_SHORTCUT = new EdgeFilter()
-    {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
-        {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
-        }
-    };
     private final LevelGraph lg;
 
-    public LocationIndexTreeSC( LevelGraph g, Directory dir )
+    BaseGraph( LevelGraph lg )
+    {
+        this.lg = lg;
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return lg.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return lg.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return lg.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b )
+    {
+        return lg.edge(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        super(g, dir);
-        lg = g;
+        return lg.edge(a, b, distance, bothDirections);
     }
 
     @Override
-    protected int pickBestNode( int nodeA, int nodeB )
+    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
     {
-        // return lower level nodes as those nodes are always connected to higher ones
-        // (high level nodes are potentially disconnected from lower ones in order to improve performance on Android)
-        if (lg.getLevel(nodeA) < lg.getLevel(nodeB))
-            return nodeA;
-        return nodeB;
+        if (lg.isShortcut(edgeId))
+            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+
+        return lg.getEdgeProps(edgeId, adjNode);
     }
 
     @Override
-    protected AllEdgesIterator getAllEdges()
+    public AllEdgesIterator getAllEdges()
     {
         final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
         return new AllEdgesIterator()
@@ -182,8 +202,48 @@ public EdgeIteratorState detach( boolean reverse )
     }
 
     @Override
-    protected EdgeFilter getEdgeFilter()
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
+        return lg.createEdgeExplorer(new EdgeFilter()
+        {
+            @Override
+            public boolean accept( EdgeIteratorState edgeIterState )
+            {
+                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                    return false;
+
+                return filter.accept(edgeIterState);
+            }
+        });
+    }
+
+    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    {
+        @Override
+        public boolean accept( EdgeIteratorState edgeIterState )
+        {
+            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+        }
+    };
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return lg.createEdgeExplorer(NO_SHORTCUTS);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
-        return NO_SHORTCUT;
+        return lg.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index d3a50c7956..b075f3864f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -36,6 +36,12 @@ public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
         this.elevation = withElevation;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        that.ensureNodeIndex(nodeId);
+    }
+
     @Override
     public final void setNode( int nodeId, double lat, double lon )
     {
@@ -43,10 +49,10 @@ public final void setNode( int nodeId, double lat, double lon )
     }
 
     @Override
-    public final void setNode( int index, double lat, double lon, double ele )
+    public final void setNode( int nodeId, double lat, double lon, double ele )
     {
-        that.ensureNodeIndex(index);
-        long tmp = (long) index * that.nodeEntryBytes;
+        that.ensureNodeIndex(nodeId);
+        long tmp = (long) nodeId * that.nodeEntryBytes;
         that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
         that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
 
@@ -54,25 +60,13 @@ public final void setNode( int index, double lat, double lon, double ele )
         {
             // meter precision is sufficient for now
             that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
-            if (ele > that.bounds.maxEle)
-                that.bounds.maxEle = ele;
+            that.bounds.update(lat, lon, ele);
 
-            if (ele < that.bounds.minEle)
-                that.bounds.minEle = ele;
+        } else
+        {
+            that.bounds.update(lat, lon);
         }
 
-        if (lat > that.bounds.maxLat)
-            that.bounds.maxLat = lat;
-
-        if (lat < that.bounds.minLat)
-            that.bounds.minLat = lat;
-
-        if (lon > that.bounds.maxLon)
-            that.bounds.maxLon = lon;
-
-        if (lon < that.bounds.minLon)
-            that.bounds.minLon = lon;
-
         // set the default value for the additional field of this node
         if (that.extStorage.isRequireNodeField())
             that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index c259176a2a..65e9c63b26 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -31,6 +31,12 @@
  */
 public interface Graph
 {
+    /**
+     * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
+     * Dijkstra or any graph traversal algorithm can be executed.
+     */
+    Graph getBaseGraph();
+
     /**
      * @return the number of created locations - via setNode() or edge()
      */
diff --git a/core/src/main/java/com/graphhopper/storage/GraphExtension.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
index 56fc19d237..380bf4ec82 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,7 +21,7 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface GraphExtension
+public interface GraphExtension extends Storable<GraphExtension>
 {
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
@@ -48,36 +48,11 @@
      */
     void init( GraphStorage graph );
 
-    /**
-     * creates all additional data storages
-     */
-    void create( long initSize );
-
-    /**
-     * loads from existing data storages
-     */
-    boolean loadExisting();
-
     /**
      * sets the segment size in all additional data storages
      */
     void setSegmentSize( int bytes );
 
-    /**
-     * flushes all additional data storages
-     */
-    void flush();
-
-    /**
-     * closes all additional data storages
-     */
-    void close();
-
-    /**
-     * returns the sum of all additional data storages capacity
-     */
-    long getCapacity();
-
     /**
      * creates a copy of this extended storage
      */
@@ -121,9 +96,10 @@ public void init( GraphStorage grap )
         }
 
         @Override
-        public void create( long initSize )
+        public GraphExtension create( long byteCount )
         {
             // noop
+            return this;
         }
 
         @Override
@@ -168,6 +144,12 @@ public GraphExtension copyTo( GraphExtension extStorage )
         public String toString()
         {
             return "NoExt";
-        }       
+        }
+
+        @Override
+        public boolean isClosed()
+        {
+            return false;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 291e025005..ca0dddb46c 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -120,11 +120,17 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.INVERSE.clone();
+        this.bounds = BBox.createInverse(withElevation);
         this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
     void checkInit()
     {
         if (initialized)
@@ -142,7 +148,7 @@ protected final int nextEdgeEntryIndex( int sizeInBytes )
     protected final int nextNodeEntryIndex( int sizeInBytes )
     {
         int tmp = nodeEntryIndex;
-        nodeEntryIndex += 4;
+        nodeEntryIndex += sizeInBytes;
         return tmp;
     }
 
@@ -799,13 +805,13 @@ public final boolean next()
                 adjNode = getOtherNode(baseNode, edgePointer);
                 reverse = baseNode > adjNode;
 
-                // position to next edge
+                // position to next edge                
                 nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
                 if (nextEdge == edgeId)
                     throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
                             + ", " + edgePointer + ", " + edgeId);
 
-                foundNext = filter == null || filter.accept(this);
+                foundNext = filter.accept(this);
                 if (foundNext)
                     break;
             }
@@ -903,7 +909,7 @@ public EdgeIteratorState detach( boolean reverseArg )
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
 
-            EdgeIterable iter = iter = new EdgeIterable(filter);
+            EdgeIterable iter = new EdgeIterable(filter);
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
@@ -1139,7 +1145,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1289,7 +1295,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1484,6 +1490,13 @@ protected int loadNodesHeader()
         bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
         bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
         bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }
+
         return 7;
     }
 
@@ -1496,6 +1509,12 @@ protected int setNodesHeader()
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
         return 7;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
index 8bca2098a9..d7917c32ef 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
@@ -23,16 +23,29 @@
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node.
+ * Extended graph interface which supports storing and retrieving the level for a node and creating
+ * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
 public interface LevelGraph extends Graph
 {
-    void setLevel( int index, int level );
-
-    int getLevel( int index );
-
+    /**
+     * This methods sets the level of the specified node.
+     */
+    void setLevel( int nodeId, int level );
+
+    /**
+     * @return the level of the specified node.
+     */
+    int getLevel( int nodeId );
+
+    boolean isShortcut( int edgeId );
+
+    /**
+     * This method creates a shortcut between a to b which is nearly identical to creating an edge
+     * except that it can be excluded or included for certain traversals or algorithms.
+     */
     EdgeSkipIterState shortcut( int a, int b );
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index 1b666abd0c..a4f7477a90 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -42,10 +42,18 @@
     // after the last edge only shortcuts are stored
     private int lastEdgeIndex = -1;
     private final long scDirMask = PrepareEncoder.getScDirMask();
+    private final Graph baseGraph;
 
     public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
     {
         super(dir, encodingManager, enabled3D);
+        baseGraph = new BaseGraph(this);
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        return edgeId > lastEdgeIndex;
     }
 
     @Override
@@ -59,17 +67,22 @@ protected void initStorage()
     }
 
     @Override
-    public final void setLevel( int index, int level )
+    public final void setLevel( int nodeIndex, int level )
     {
-        ensureNodeIndex(index);
-        nodes.setInt((long) index * nodeEntryBytes + I_LEVEL, level);
+        if (nodeIndex >= getNodes())
+            return;
+
+        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int index )
+    public final int getLevel( int nodeIndex )
     {
-        ensureNodeIndex(index);
-        return nodes.getInt((long) index * nodeEntryBytes + I_LEVEL);
+        // automatically allocate new nodes only via creating edges or setting node properties
+        if (nodeIndex >= getNodes())
+            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
+
+        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
     }
 
     @Override
@@ -82,7 +95,7 @@ public EdgeSkipIterState shortcut( int a, int b )
     public EdgeSkipIterState edge( int a, int b )
     {
         if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create after shortcut was created");
+            throw new IllegalStateException("Cannot create edge after first shortcut was created");
 
         lastEdgeIndex = edgeCount;
         return createEdge(a, b);
@@ -267,25 +280,20 @@ long reverseFlags( long edgePointer, long flags )
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
     {
-        // search edge with opposite direction        
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
         // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
         EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        boolean found = false;
         while (tmpIter.next())
         {
-            // If we disconnect shortcuts only we could run normal algos on the graph too
-            // BUT CH queries will be 10-20% slower and preparation will be 10% slower
-            if (/*tmpIter.isShortcut() &&*/tmpIter.getEdge() == edgeState.getEdge())
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
             {
-                found = true;
+                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
                 break;
             }
 
             tmpPrevEdge = tmpIter.getEdge();
         }
-        if (found)
-            internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
     }
 
     @Override
@@ -431,4 +439,10 @@ protected int setEdgesHeader()
         edges.setHeader(next * 4, lastEdgeIndex);
         return next + 1;
     }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index 152cc78179..84f77a6513 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -65,7 +65,7 @@ public void init( GraphStorage graph )
 
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turnCosts");
+        this.turnCosts = this.graph.getDirectory().find("turn_costs");
     }
 
     private int nextTurnCostEntryIndex()
@@ -81,9 +81,10 @@ public void setSegmentSize( int bytes )
     }
 
     @Override
-    public void create( long initBytes )
+    public TurnCostExtension create( long initBytes )
     {
         turnCosts.create((long) initBytes * turnCostsEntryBytes);
+        return this;
     }
 
     @Override
@@ -249,6 +250,12 @@ public GraphExtension copyTo( GraphExtension clonedStorage )
         return clonedStorage;
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return turnCosts.isClosed();
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 87096def80..c609eca201 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -77,7 +77,7 @@ void writeByte( byte b )
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
      * <p>
-     * The format is described further in {@link DataOutput#writeVInt(int)}.
+     * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
      */
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index d0d82b92f3..b75690f26f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -47,14 +47,18 @@
     int findID( double lat, double lon );
 
     /**
+     * This method returns the closest QueryResult for the specified location (lat, lon) and only if
+     * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
+     * search)
+     * <p>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
-     *   new DefaultEdgeFilter(new FootFlagEncoder());
+     *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
      * <p>
      * @return An object containing the closest node and edge for the specfied location. The node id
-     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found it
-     * returns null.
+     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
+     * the method QueryResult.isValid will return false.
      */
     QueryResult findClosest( double lat, double lon, EdgeFilter edgeFilter );
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 2e1193735e..eee2f2f80c 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -20,11 +20,11 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -74,12 +74,19 @@
      */
     private double equalNormedDelta;
 
+    /**
+     * @param g the graph for which this index should do the lookup based on latitude,longitude.
+     * @param dir
+     */
     public LocationIndexTree( Graph g, Directory dir )
     {
+        if (g instanceof LevelGraph)
+            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("locationIndex");
+        dataAccess = dir.find("location_index");
     }
 
     public int getMinResolutionInMeter()
@@ -124,8 +131,11 @@ void prepareAlgo()
         // if we assume a minimum resolution like 0.5km for a leaf-tile                
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
-        if (graph.getNodes() == 0 || !bounds.check())
-            throw new IllegalStateException("Bounds of graph are invalid: " + bounds);
+        if (graph.getNodes() == 0)
+            throw new IllegalStateException("Cannot create location index of empty graph!");
+
+        if (!bounds.isValid())
+            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
 
         double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
         double maxDistInMeter = Math.max(
@@ -235,27 +245,6 @@ public int findID( double lat, double lon )
         return res.getClosestNode();
     }
 
-    @Override
-    public boolean loadExisting()
-    {
-        if (initialized)
-            throw new IllegalStateException("Call loadExisting only once");
-
-        if (!dataAccess.loadExisting())
-            return false;
-
-        if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
-
-        if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph");
-
-        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
-        prepareAlgo();
-        initialized = true;
-        return true;
-    }
-
     @Override
     public LocationIndex setResolution( int minResolutionInMeter )
     {
@@ -282,10 +271,32 @@ public LocationIndexTree create( long size )
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
+    @Override
+    public boolean loadExisting()
+    {
+        if (initialized)
+            throw new IllegalStateException("Call loadExisting only once");
+
+        if (!dataAccess.loadExisting())
+            return false;
+
+        if (dataAccess.getHeader(0) != MAGIC_INT)
+            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
+
+        if (dataAccess.getHeader(1 * 4) != calcChecksum())
+            throw new IllegalStateException("location2id index was opened with incorrect graph: "
+                    + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
+
+        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
+        prepareAlgo();
+        initialized = true;
+        return true;
+    }
+
     @Override
     public void flush()
     {
-        dataAccess.setHeader(0, MAGIC_INT);
+        dataAccess.setHeader(0, MAGIC_INT);        
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
 
@@ -321,6 +332,7 @@ public LocationIndex prepareIndex()
                 + ", leafs:" + Helper.nf(inMem.leafs)
                 + ", precision:" + minResolutionInMeter
                 + ", depth:" + entries.length
+                + ", checksum:" + calcChecksum()
                 + ", entries:" + Arrays.toString(entries)
                 + ", entriesPerLeaf:" + entriesPerLeaf);
 
@@ -371,7 +383,7 @@ public InMemConstructionIndex( int noOfSubEntries )
 
         void prepare()
         {
-            final EdgeIterator allIter = getAllEdges();
+            final EdgeIterator allIter = graph.getAllEdges();
             try
             {
                 while (allIter.next())
@@ -415,7 +427,7 @@ public void set( double lat, double lon )
                     long key = keyAlgo.encode(lat, lon);
                     long keyPart = createReverseKey(key);
                     // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, pickBestNode(nodeA, nodeB), 0, keyPart, key);
+                    addNode(root, nodeA, 0, keyPart, key);
                 }
             };
             BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
@@ -784,7 +796,7 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
         // clone storedIds to avoid interference with forEach
         final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
         // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer(getEdgeFilter());
+        final EdgeExplorer explorer = graph.createEdgeExplorer();
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
@@ -935,23 +947,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
         protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
     }
 
-    protected int pickBestNode( int nodeA, int nodeB )
-    {
-        // For normal graph the node does not matter because if nodeA is conntected to nodeB
-        // then nodeB is also connect to nodeA, but for a LevelGraph this does not apply.
-        return nodeA;
-    }
-
-    protected EdgeFilter getEdgeFilter()
-    {
-        return EdgeFilter.ALL_EDGES;
-    }
-
-    protected AllEdgesIterator getAllEdges()
-    {
-        return graph.getAllEdges();
-    }
-
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     static interface InMemEntry
     {
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 5e98e3ca80..800bc7c14d 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,6 +17,9 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.cos;
+import static java.lang.Math.toRadians;
+
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
@@ -58,7 +61,8 @@ static final double atan2( double y, double x )
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
     {
-        return atan2((lat2 - lat1), (lon2 - lon1));
+        double shrinkFactor = cos(toRadians((lat1 + lat2) / 2));
+        return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 09756dad5f..11957181dd 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -195,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -275,7 +278,7 @@ public final int getIntHigh( long longValue )
         return (int) (longValue >> 32);
     }
 
-    public final long combineIntsToLong( int intLow, int intHigh)
+    public final long combineIntsToLong( int intLow, int intHigh )
     {
         return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
     }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 7eac90a65e..2da8f5e766 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -50,8 +50,8 @@
     public static final String OS_ARCH = System.getProperty("os.arch");
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
-    public static final int VERSION_NODE = 3;
-    public static final int VERSION_EDGE = 9;
+    public static final int VERSION_NODE = 4;
+    public static final int VERSION_EDGE = 12;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 7e21bb6055..3502bb7a85 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -133,15 +133,16 @@ public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
+
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -168,7 +169,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return calcNormalizedDist(c_lat, c_lon / shrink_factor, r_lat_deg, r_lon_deg);
+        return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
     @Override
@@ -176,15 +177,15 @@ public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -211,7 +212,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return new GHPoint(c_lat, c_lon / shrink_factor);
+        return new GHPoint(c_lat, c_lon / shrinkFactor);
     }
 
     @Override
@@ -219,15 +220,15 @@ public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double ar_x = r_lon - a_lon;
         double ar_y = r_lat - a_lat;
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index 95f5181be9..dbe2737226 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.PathBidir;
 import gnu.trove.map.hash.TIntIntHashMap;
 import java.util.Arrays;
 
@@ -24,7 +25,7 @@
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
  * <p/>
- * @see DijkstraBidirection
+ * @see PathBidir
  * @author Peter Karich
  */
 @NotThreadSafe
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index b59f453b7b..a4ca0d21c6 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -17,15 +17,11 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.NodeAccess;
-
 /**
  * @author Peter Karich
  */
 public class FinishInstruction extends Instruction
 {
-    private int count = -1;
-
     public FinishInstruction( final double lat, final double lon, final double ele )
     {
         super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
@@ -36,20 +32,18 @@ public FinishInstruction( final double lat, final double lon, final double ele )
         });
     }
 
-    public FinishInstruction( NodeAccess nodeAccess, int node )
+    public FinishInstruction( PointAccess pointAccess, int node )
     {
-        this(nodeAccess.getLatitude(node), nodeAccess.getLongitude(node),
-                nodeAccess.is3D() ? nodeAccess.getElevation(node) : 0);
+        this(pointAccess.getLatitude(node), pointAccess.getLongitude(node),
+                pointAccess.is3D() ? pointAccess.getElevation(node) : 0);
     }
 
-    void setVia( int i )
+    @Override
+    public String getTurnDescription( Translation tr )
     {
-        sign = REACHED_VIA;
-        count = i;
-    }
+        if (rawName)
+            return getName();
 
-    public int getViaPosition()
-    {
-        return count;
+        return tr.tr("finish");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 25902783fb..a3623be0a3 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -139,8 +139,8 @@ public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
                 AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
-            String fwdStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD) ? "fwd" : "   ";
-            String bckStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD) ? "bckwd" : "";
+            String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
+            String bckStr = encoder.isBackward(iter.getFlags()) ? "bckwd" : "";
             System.out.println(sc + " " + iter + " " + fwdStr + " " + bckStr);
         }
     }
@@ -231,7 +231,7 @@ protected GHBitSet createBitSet()
                 @Override
                 protected boolean goFurther( int nodeId )
                 {
-                    list.set(nodeId, ref.incrementAndGet());                    
+                    list.set(nodeId, ref.incrementAndGet());
                     return super.goFurther(nodeId);
                 }
             }.start(explorer, startNode);
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 599ca36916..5e56078c64 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -358,6 +358,8 @@ public static final int degreeToInt( double deg )
     {
         if (deg >= Double.MAX_VALUE)
             return Integer.MAX_VALUE;
+        if (deg <= -Double.MAX_VALUE)
+            return -Integer.MAX_VALUE;
         return (int) (deg * DEGREE_FACTOR);
     }
 
@@ -370,6 +372,8 @@ public static final double intToDegree( int storedInt )
     {
         if (storedInt == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
+        if (storedInt == -Integer.MAX_VALUE)
+            return -Double.MAX_VALUE;
         return (double) storedInt / DEGREE_FACTOR;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index b5792db8c4..feef36b489 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,11 +17,15 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -31,12 +35,15 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
+    protected boolean rawName;
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
@@ -50,24 +57,48 @@ public Instruction( int sign, String name, InstructionAnnotation ia, PointList p
         this.annotation = ia;
     }
 
+    /**
+     * This method does not perform translation or combination with the sign - it just uses the
+     * provided name as instruction.
+     */
+    public void setUseRawName()
+    {
+        rawName = true;
+    }
+
     public InstructionAnnotation getAnnotation()
     {
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName( String name )
+    {
+        this.name = name;
+    }
+
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo( String key, Object value )
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -188,8 +219,9 @@ String calcDirection( Instruction nextI )
     }
 
     /**
-     * Return the azimuth in degree based on the first tracksegment of the instruction. If
-     * Instruction does not contain enough coordinate points, an empty string will be returned.
+     * Return the azimuth in degree based on the first tracksegment of this instruction. If this
+     * instruction contains less than 2 points then NaN will be returned or the specified
+     * instruction will be used if that is the finish instruction.
      */
     public double calcAzimuth( Instruction nextI )
     {
@@ -222,46 +254,43 @@ void checkOne()
 
     public String getTurnDescription( Translation tr )
     {
+        if (rawName)
+            return getName();
+
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
-        if (indi == Instruction.FINISH)
-        {
-            str = tr.tr("finish");
-        } else if (indi == Instruction.REACHED_VIA)
-        {
-            str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
-        } else if (indi == Instruction.CONTINUE_ON_STREET)
+        if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
             switch (indi)
             {
                 case Instruction.TURN_SHARP_LEFT:
-                    dir = tr.tr("sharp_left");
+                    dir = tr.tr("turn_sharp_left");
                     break;
                 case Instruction.TURN_LEFT:
-                    dir = tr.tr("left");
+                    dir = tr.tr("turn_left");
                     break;
                 case Instruction.TURN_SLIGHT_LEFT:
-                    dir = tr.tr("slight_left");
+                    dir = tr.tr("turn_slight_left");
                     break;
                 case Instruction.TURN_SLIGHT_RIGHT:
-                    dir = tr.tr("slight_right");
+                    dir = tr.tr("turn_slight_right");
                     break;
                 case Instruction.TURN_RIGHT:
-                    dir = tr.tr("right");
+                    dir = tr.tr("turn_right");
                     break;
                 case Instruction.TURN_SHARP_RIGHT:
-                    dir = tr.tr("sharp_right");
+                    dir = tr.tr("turn_sharp_right");
                     break;
             }
             if (dir == null)
-                throw new IllegalStateException("Indication not found " + indi);
+                throw new IllegalStateException("Turn indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? dir : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 51eedba419..8a5a878492 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -46,6 +46,14 @@ public InstructionList( int cap, Translation tr )
         this.tr = tr;
     }
 
+    public void replaceLast( Instruction instr )
+    {
+        if (instructions.isEmpty())
+            throw new IllegalStateException("Cannot replace last instruction as list is empty");
+
+        instructions.set(instructions.size() - 1, instr);
+    }
+
     public void add( Instruction instr )
     {
         instructions.add(instr);
@@ -61,47 +69,6 @@ public int size()
         return instructions.size();
     }
 
-    /**
-     * Returns the descriptions of the distance per instruction.
-     */
-    public List<String> createDistances( boolean mile )
-    {
-        List<String> labels = new ArrayList<String>(instructions.size());
-        for (int i = 0; i < instructions.size(); i++)
-        {
-            double distInMeter = instructions.get(i).getDistance();
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) Helper.round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(Helper.round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
-            {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(Helper.round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
-            }
-        }
-        return labels;
-    }
-
     public List<Map<String, Object>> createJson()
     {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
@@ -119,13 +86,14 @@ public int size()
             instrJson.put("text", Helper.firstBig(str));
             if (!ia.isEmpty())
             {
-                instrJson.put("annotationText", ia.getMessage());
-                instrJson.put("annotationImportance", ia.getImportance());
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
             }
 
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 24cb8cd371..590c89b2fa 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -63,25 +63,33 @@ public MiniPerfTest setIterations( int counts )
         return this;
     }
 
-    // in ms
+    /**
+     * @return minimum time of every call, in ms
+     */
     public double getMin()
     {
         return min / 1e6;
     }
 
-    // in ms
+    /**
+     * @return maximum time of every calls, in ms
+     */
     public double getMax()
     {
         return max / 1e6;
     }
 
-    // in ms
+    /**
+     * @return time for all calls accumulated, in ms
+     */
     public double getSum()
     {
         return fullTime / 1e6;
     }
 
-    // in ms
+    /**
+     * @return mean time per call, in ms
+     */
     public double getMean()
     {
         return getSum() / counts;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 5141534f13..2aa1237ab1 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -31,9 +31,9 @@
 public class PathMerger
 {
     private boolean enableInstructions = true;
-    private boolean simplifyResponse = false;
+    private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker;
-    private boolean calcPoints;
+    private boolean calcPoints = true;
 
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
@@ -60,7 +60,11 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (!il.isEmpty())
                 {
                     if (fullPoints.isEmpty())
-                        fullPoints = createSimilarPL(il.get(0).getPoints());
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
 
                     for (Instruction i : il)
                     {
@@ -77,8 +81,9 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                     // if not yet reached finish replace with 'reached via'
                     if (pathIndex + 1 < paths.size())
                     {
-                        FinishInstruction fi = (FinishInstruction) fullInstructions.get(fullInstructions.size() - 1);
-                        fi.setVia(pathIndex + 1);
+                        ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
+                        newInstr.setViaCount(pathIndex + 1);
+                        fullInstructions.replaceLast(newInstr);
                     }
                 }
 
@@ -86,7 +91,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             {
                 PointList tmpPoints = path.calcPoints();
                 if (fullPoints.isEmpty())
-                    fullPoints = createSimilarPL(tmpPoints);
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
                 if (simplifyResponse)
                 {
@@ -110,18 +115,17 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
         if (enableInstructions)
             rsp.setInstructions(fullInstructions);
 
-        rsp.setFound(allFound).
-                setPoints(fullPoints).
+        if (!allFound)
+        {
+            rsp.addError(new RuntimeException("Not found"));
+        }
+
+        rsp.setPoints(fullPoints).
                 setRouteWeight(fullWeight).
                 setDistance(fullDistance).
                 setMillis(fullMillis);
     }
 
-    PointList createSimilarPL( PointList pl )
-    {
-        return new PointList(pl.size(), pl.is3D());
-    }
-
     public PathMerger setCalcPoints( boolean calcPoints )
     {
         this.calcPoints = calcPoints;
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index e8a395192d..5d3068a599 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -23,7 +23,6 @@
  */
 public interface PointAccess
 {
-
     /**
      * @return true if elevation data is stored and can be retrieved
      */
@@ -34,6 +33,12 @@
      */
     int getDimension();
 
+    /**
+     * This method ensures that the node with the specified index exists i.e. allocates space for
+     * it.
+     */
+    void ensureNode( int nodeId );
+
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 1d25102e5b..d3ecbf0087 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -22,6 +22,7 @@
 import com.graphhopper.util.shapes.GHPoint3D;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -29,7 +30,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class PointList implements PointAccess
+public class PointList implements Iterable<GHPoint3D>, PointAccess
 {
     private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private static String ERR_MSG = "Tried to access PointList with too big index!";
@@ -67,6 +68,12 @@ public int getDimension()
         return 2;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        incCap(nodeId + 1);
+    }
+
     @Override
     public void setNode( int nodeId, double lat, double lon )
     {
@@ -94,7 +101,7 @@ else if (!Double.isNaN(ele))
 
     private void incCap( int newSize )
     {
-        if (newSize < latitudes.length)
+        if (newSize <= latitudes.length)
             return;
 
         int cap = newSize * 2;
@@ -567,4 +574,33 @@ int getCapacity()
     {
         return latitudes.length;
     }
+
+    @Override
+    public Iterator<GHPoint3D> iterator()
+    {
+        return new Iterator<GHPoint3D>()
+        {
+            int counter = 0;
+
+            @Override
+            public boolean hasNext()
+            {
+                return counter < PointList.this.getSize();
+            }
+
+            @Override
+            public GHPoint3D next()
+            {
+                GHPoint3D point = PointList.this.toGHPoint(counter);
+                counter++;
+                return point;
+            }
+
+            @Override
+            public void remove()
+            {
+                throw new UnsupportedOperationException("Not supported.");
+            }
+        };
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..78b759471a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,133 @@
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+    private int exitNumber = 0;
+    // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private int clockwise = 0;
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber( int exitNumber )
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation( double deltaIn )
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        } else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        } else
+        {
+            double tmpRadian = Math.PI - clockwise * radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian( double radian )
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (!Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+
+        return tmpMap;
+
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        if (rawName)
+            return getName();
+
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else
+            {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber())
+                        : tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 8b3bb36dca..d6f385dfc1 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -32,9 +32,9 @@
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
-            "fr", "gl", "he", "it", "ja", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
-            "vi_VI");
+    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es",
+            "fa", "fil", "fi", "fr", "gl", "he", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru",
+            "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
new file mode 100644
index 0000000000..028a21541a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class ViaInstruction extends Instruction
+{
+    private int viaPosition = -1;
+
+    public ViaInstruction( String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(REACHED_VIA, name, ia, pl);
+    }
+
+    public ViaInstruction( Instruction instr )
+    {
+        this(instr.getName(), instr.getAnnotation(), instr.getPoints());
+        setDistance(instr.getDistance());
+        setTime(instr.getTime());
+    }
+
+    public void setViaCount( int count )
+    {
+        this.viaPosition = count;
+    }
+
+    public int getViaCount()
+    {
+        if (viaPosition < 0)
+            throw new IllegalStateException("Uninitialized via count in instruction " + getName());
+
+        return viaPosition;
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        if (rawName)
+            return getName();
+
+        return tr.tr("stopover", viaPosition);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 09e46810ca..d0eb1ebb46 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -34,20 +34,7 @@
  */
 public class BBox implements Shape, Cloneable
 {
-    /**
-     * A bounding box which prefills the values with minimum values so that it can increase.
-     */
-    public static final BBox INVERSE = new BBox();
 
-    static
-    {
-        INVERSE.minLon = Double.MAX_VALUE;
-        INVERSE.maxLon = -Double.MAX_VALUE;
-        INVERSE.minLat = Double.MAX_VALUE;
-        INVERSE.maxLat = -Double.MAX_VALUE;
-        INVERSE.minEle = Double.MAX_VALUE;
-        INVERSE.maxEle = -Double.MAX_VALUE;
-    }
     // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
@@ -55,17 +42,7 @@
     public double maxLat;
     public double minEle;
     public double maxEle;
-    private final boolean is3D;
-
-    private BBox()
-    {
-        this.is3D = false;
-    }
-
-    private BBox( boolean is3D )
-    {
-        this.is3D = is3D;
-    }
+    private final boolean elevation;
 
     public BBox( double minLon, double maxLon, double minLat, double maxLat )
     {
@@ -77,9 +54,9 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean is3D )
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
     {
-        this.is3D = is3D;
+        this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
         this.minLat = minLat;
@@ -88,28 +65,73 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this.maxEle = maxEle;
     }
 
-    public boolean check()
+    public boolean hasElevation()
     {
-        // second longitude should be bigger than the first
-        if (minLon >= maxLon)
-            return false;
+        return elevation;
+    }
 
-        // second latitude should be smaller than the first
-        if (minLat >= maxLat)
-            return false;
+    /**
+     * Prefills BBox with minimum values so that it can increase.
+     */
+    public static BBox createInverse( boolean elevation )
+    {
+        if (elevation)
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.MAX_VALUE, -Double.MAX_VALUE, true);
+        } else
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.NaN, Double.NaN, false);
+        }
+    }
 
-        // second elevation should be smaller than the first
-        if (is3D && minEle >= maxEle)
-            return false;
+    public void update( double lat, double lon )
+    {
+        if (lat > maxLat)
+        {
+            maxLat = lat;
+        }
+
+        if (lat < minLat)
+        {
+            minLat = lat;
+        }
 
-        return true;
+        if (lon > maxLon)
+        {
+            maxLon = lon;
+        }
+        if (lon < minLon)
+        {
+            minLon = lon;
+        }
+    }
+
+    public void update( double lat, double lon, double elev )
+    {
+        if (elevation)
+        {
+            if (elev > maxEle)
+            {
+                maxEle = elev;
+            }
+            if (elev < minEle)
+            {
+                minEle = elev;
+            }
+        } else
+        {
+            throw new IllegalStateException("No BBox with elevation to update");
+        }
+        update(lat, lon);
 
     }
 
     @Override
     public BBox clone()
     {
-        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, is3D);
+        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
@@ -172,7 +194,7 @@ public boolean contains( Circle c )
     public String toString()
     {
         String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
-        if (is3D)
+        if (elevation)
             str += "," + minEle + "," + maxEle;
 
         return str;
@@ -214,10 +236,29 @@ public int hashCode()
 
     public boolean isValid()
     {
-        return Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(INVERSE.maxLat)
-                && Double.doubleToLongBits(minLat) != Double.doubleToLongBits(INVERSE.minLat)
-                && Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(INVERSE.maxLon)
-                && Double.doubleToLongBits(minLon) != Double.doubleToLongBits(INVERSE.minLon);
+        // second longitude should be bigger than the first
+        if (minLon >= maxLon)
+            return false;
+
+        // second latitude should be smaller than the first
+        if (minLat >= maxLat)
+            return false;
+
+        if (elevation)
+        {
+            // equal elevation is okay
+            if (minEle > maxEle)
+                return false;
+
+            if (Double.compare(maxEle, -Double.MAX_VALUE) == 0
+                    || Double.compare(minEle, Double.MAX_VALUE) == 0)
+                return false;
+        }
+
+        return Double.compare(maxLat, -Double.MAX_VALUE) != 0
+                && Double.compare(minLat, Double.MAX_VALUE) != 0
+                && Double.compare(maxLon, -Double.MAX_VALUE) != 0
+                && Double.compare(minLon, Double.MAX_VALUE) != 0;
     }
 
     /**
@@ -230,12 +271,12 @@ public boolean isValid()
         list.add(Helper.round6(minLon));
         list.add(Helper.round6(minLat));
         // hmh
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(minEle));
 
         list.add(Helper.round6(maxLon));
         list.add(Helper.round6(maxLat));
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(maxEle));
 
         return list;
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index 12647784c2..6051b86336 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=рязко наляво
-sharp_right=рязко надясно
-left=наляво
-right=надясно
-slight_left=леко наляво
-slight_right=леко надясно
 continue=продължи
 continue_onto=продължи по %1$s
-turn=завий %1$s
-turn_onto=завий %1$s по %2$s
+turn_left=завий наляво
+turn_right=завий надясно
+turn_slight_left=завий леко наляво
+turn_slight_right=завий леко надясно
+turn_sharp_left=завий рязко наляво
+turn_sharp_right=завий рязко надясно
+turn_onto=%1$s по %2$s
 web.searchButton=Търсене
 web.fromHint=От
 web.viaHint=през
@@ -24,7 +23,7 @@ web.mtb=Планинско колело
 web.car=Автомобил
 web.foot=Пеш
 web.staticlink=статична връзка
-web.motorcycle=
+web.motorcycle=Мотоциклет
 via=през
 finish=Крайна цел!
 hourAbbr=ч
@@ -41,5 +40,6 @@ way=път
 paved=асфалтиран
 unpaved=черен
 stopover=прехвърляне %1$s
-roundaboutInstruction=Влез в кръговото и използвай изход %1$s
-roundaboutInstructionWithDir=Влез в кръговото и използвай изход %1$s в посока %2$s
+roundaboutEnter=Влез в кръговото кръстовище
+roundaboutExit=На кръговото кръстовище използвайте изход %1$s
+roundaboutExitOnto=На кръговото кръстовище използвайте изход %1$s по %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index e1a812b703..512ca12aa6 100644
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=just a l'esquerra
-sharp_right=just a la dreta
-left=a l'esquerra
-right=a la dreta
-slight_left=lleugerament a l'esquerra
-slight_right=lleugerament a la dreta
 continue=continua
 continue_onto=continua per %1$s
-turn=gira %1$s
-turn_onto=gira %1$s per %2$s
+turn_left=gira a l'esquerra
+turn_right=gira a la dreta
+turn_slight_left=gira lleugerament a l'esquerra
+turn_slight_right=gira lleugerament a la dreta
+turn_sharp_left=gira just a l'esquerra
+turn_sharp_right=gira just a la dreta
+turn_onto=%1$s per %2$s
 web.searchButton=Buscar
 web.fromHint=Des de
 web.viaHint=passant per
@@ -24,7 +23,7 @@ web.mtb=Bicicleta de montanya
 web.car=Cotxe
 web.foot=A peu
 web.staticlink=Enllaç
-web.motorcycle=
+web.motorcycle=Motocicleta
 via=passant per
 finish=Has arribat !!
 hourAbbr=h
@@ -41,5 +40,6 @@ way=camí
 paved=pavimentat
 unpaved=sense pavimentar
 stopover=passant per %1$s
-roundaboutInstruction=Entra a la rotonda y agafa la %1$ sortida
-roundaboutInstructionWithDir=Entra a la rotonda y agafa la %1$s sortida direcció %2$s
+roundaboutEnter=Entra a la rotonda
+roundaboutExit=A la rotonda, agafa la %1$s sortida
+roundaboutExitOnto=A la rotonda, agafa la sortida %1$s cap a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index f9b8831bc9..e778c5cc28 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=scharf links
-sharp_right=scharf rechts
-left=links
-right=rechts
-slight_left=leicht links
-slight_right=leicht rechts
 continue=geradeaus
 continue_onto=geradeaus auf %1$s
-turn=%1$s abbiegen
-turn_onto=%1$s abbiegen auf %2$s
+turn_left=links abbiegen
+turn_right=rechts abbiegen
+turn_slight_left=leicht links abbiegen
+turn_slight_right=leicht rechts abbiegen
+turn_sharp_left=scharf links abbiegen
+turn_sharp_right=scharf rechts abbiegen
+turn_onto=%1$s auf %2$s
 web.searchButton=Suche
 web.fromHint=Von
 web.viaHint=Über
@@ -41,5 +40,6 @@ way=Weg
 paved=befestigt
 unpaved=unbefestigt
 stopover=Zwischenziel %1$s
-roundaboutInstruction=In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen
-roundaboutInstructionWithDir=In den Kreisverkehr einfahren und Ausfahrt %1$s in Richtung %2$s nehmen
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index e3a9288ae0..b60ca9b5cd 100644
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -1,21 +1,20 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=κλειστά αριστερά
-sharp_right=κλειστά δεξιά
-left=αριστερά
-right=δεξιά
-slight_left=λοξά αριστερά
-slight_right=λοξά δεξιά
 continue=συνεχίστε
 continue_onto=συνεχίστε στην %1$s
-turn=στρίψτε %1$s
-turn_onto=στρίψτε %1$s στην %2$s
+turn_left=στρίψτε αριστερά
+turn_right=στρίψτε δεξιά
+turn_slight_left=στρίψτε λοξά αριστερά
+turn_slight_right=στρίψτε λοξά δεξιά
+turn_sharp_left=στρίψτε κλειστά αριστερά
+turn_sharp_right=στρίψτε κλειστά δεξιά
+turn_onto=%1$s στην %2$s
 web.searchButton=Αναζήτηση
 web.fromHint=Αφετηρία
-web.viaHint=μέσω
+web.viaHint=Μέσω
 web.toHint=Προορισμός
 web.moreButton=περισσότερα
-web.gpxExportButton=GPX εξαγωγή
+web.gpxExportButton=Εξαγωγή GPX
 web.routeInfo=%1$s σε %2$s
 web.locationsNotFound=Η δρομολόγηση δεν είναι δυνατή. Οι τοποθεσίες δεν βρέθηκαν στην περιοχή.
 web.bike=Ποδήλατο
@@ -24,7 +23,7 @@ web.mtb=Ποδήλατο βουνού
 web.car=Αυτοκίνητο
 web.foot=Πεζός
 web.staticlink=στατική διεύθυνση
-web.motorcycle=
+web.motorcycle=Μοτοσυκλέτα
 via=μέσω
 finish=Τέρμα!
 hourAbbr=h
@@ -41,5 +40,6 @@ way=δρόμος
 paved=ασφαλτοστρωμένος
 unpaved=χωματόδρομος
 stopover=ενδιάμεση στάση %1$s
-roundaboutInstruction=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s
-roundaboutInstructionWithDir=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s στην κατεύθυνση %2$s
+roundaboutEnter=Μπείτε στον κυκλικό κόμβο
+roundaboutExit=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s
+roundaboutExitOnto=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s στην %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 150064e709..c886850443 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sharp left
-sharp_right=sharp right
-left=left
-right=right
-slight_left=slight left
-slight_right=slight right
 continue=continue
 continue_onto=continue onto %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn_left=turn left
+turn_right=turn right
+turn_slight_left=turn slight left
+turn_slight_right=turn slight right
+turn_sharp_left=turn sharp left
+turn_sharp_right=turn sharp right
+turn_onto=%1$s onto %2$s
 web.searchButton=Search
 web.fromHint=From
 web.viaHint=Via
@@ -41,5 +40,6 @@ way=way
 paved=paved
 unpaved=unpaved
 stopover=stopover %1$s
-roundaboutInstruction=Enter roundabout and use exit %1$s
-roundaboutInstructionWithDir=Enter roundabout and use exit %1$s in direction %2$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index b63805492a..487ae279b0 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -1,19 +1,18 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=justo a la izquierda
-sharp_right=justo a la derecha
-left=izquierda
-right=derecha
-slight_left=gire a la izquierda
-slight_right=gire a la derecha
 continue=continúe
 continue_onto=continúe por %1$s
-turn=gire a la %1$s
-turn_onto=gire a la %1$s por %2$s
+turn_left=gire a la izquierda
+turn_right=gire a la derecha
+turn_slight_left=gire leve a la izquierda
+turn_slight_right=gire leve a la derecha
+turn_sharp_left=gire fuerte a la izquierda
+turn_sharp_right=gire fuerte a la derecha
+turn_onto=%1$s por %2$s
 web.searchButton=Buscar
 web.fromHint=Desde
 web.viaHint=Pasando por
-web.toHint=hasta
+web.toHint=Hasta
 web.moreButton=más
 web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s tardará %2$s 
@@ -26,7 +25,7 @@ web.foot=A pie
 web.staticlink=enlace estático
 web.motorcycle=Motocicleta
 via=pasando por
-finish=¡Objetivo logrado!
+finish=¡Fin del recorrido!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -35,11 +34,12 @@ mAbbr=m
 miAbbr=mi
 ftAbbr=ft
 road=carretera
-off_bike=bajarse de la bicicleta
-cycleway=vía ciclista
+off_bike=bájese de la bicicleta
+cycleway=Ciclovía 
 way=camino
 paved=pavimentado
 unpaved=no pavimentado
 stopover=pasando por %1$s
-roundaboutInstruction=Entre a la rotonda y tome la salida %1$s
-roundaboutInstructionWithDir=Entre a la rotonda y tome la salida %1$s en dirección a %2$s
+roundaboutEnter=Entre en la rotonda
+roundaboutExit=En la rotonda, tome la salida %1$s
+roundaboutExitOnto=En la rotonda, tome la salida %1$s hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fa.txt b/core/src/main/resources/com/graphhopper/util/fa.txt
new file mode 100644
index 0000000000..3c73dff23f
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fa.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue= ادامه دهید
+continue_onto=تا %1$s ادامه دهید
+turn_left=به چپ بپیچید
+turn_right=به راست بپیچید
+turn_slight_left=کمی به چپ بپیچید
+turn_slight_right=کمی به راست بپیچید
+turn_sharp_left=کاملا به چپ بپیچید
+turn_sharp_right=کاملا به راست بپیچید
+turn_onto= از %1$s به %2$s
+web.searchButton=جستجو
+web.fromHint=از
+web.viaHint=از طریق
+web.toHint=به
+web.moreButton=بیشتر
+web.gpxExportButton=دریافت به صورت GPX
+web.routeInfo=طی مسافت %1$s به مدت %2$s طول خواهد کشید
+web.locationsNotFound=مسیریابی ممکن نیست. محل مورد نظردرناحیه پیدا نشد.
+web.bike=دوچرخه
+web.racingbike=دوچرخه کورسی
+web.mtb=دوچرخه کوهستان
+web.car=ماشین
+web.foot=پیاده
+web.staticlink=مسیر ثابت
+web.motorcycle=موتورسیکلت
+via=از طریق
+finish=پایان!
+hourAbbr=ساعت
+dayAbbr=روز
+minAbbr=دقیقه
+kmAbbr=کیلومتر
+mAbbr=متر
+miAbbr=مایل
+ftAbbr=فوت
+road=جاده
+off_bike=از دوچرخه پیاده شوید
+cycleway=مسیر دوچرخه
+way=مسیر
+paved=خط کشی شده
+unpaved=خط کشی نشده
+stopover=توقفگاه  %1$s
+roundaboutEnter=وارد میدان می شوید
+roundaboutExit=در میدان خروجی  %1$s را انتخاب کنید
+roundaboutExitOnto=در میدان خروجی  %1$s به %2$s را انتخاب کنید
diff --git a/core/src/main/resources/com/graphhopper/util/fi.txt b/core/src/main/resources/com/graphhopper/util/fi.txt
new file mode 100644
index 0000000000..b5d23f834a
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fi.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=jatka
+continue_onto=jatka tielle %1$S
+turn_left=käänny vasemmalle
+turn_right=käänny oikealle
+turn_slight_left=käänny loivasti vasemmalle
+turn_slight_right=käänny loivasti oikealle
+turn_sharp_left=käänny jyrkästi vasemmalle
+turn_sharp_right=käänny jyrkästi oikealle
+turn_onto=%1$S tielle %2$S
+web.searchButton=Etsi
+web.fromHint=Lähtöpaikka
+web.viaHint=Reittipiste
+web.toHint=Määränpää
+web.moreButton=lisää
+web.gpxExportButton=GPX-tuonti
+web.routeInfo=%1$s kestää %2$s
+web.locationsNotFound=Reittiohjeiden luonti epäonnistui. Paikkaa ei löydy tältä alueelta.
+web.bike=Pyörällä
+web.racingbike=Kilpapyörällä
+web.mtb=Maastopyörällä
+web.car=Autolla
+web.foot=Kävellen
+web.staticlink=
+web.motorcycle=Moottoripyörällä
+via=kautta
+finish=Olet perillä!
+hourAbbr=h
+dayAbbr=pv
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=tie
+off_bike=taluta pyörää
+cycleway=pyörätie
+way=tie
+paved=päällystetty
+unpaved=päällystämätön
+stopover=%1$s. pysähdys
+roundaboutEnter=Aja liikenneympyrään
+roundaboutExit=Liikenneympyrästä poistu %1$s. liittymästä
+roundaboutExitOnto=Liikenneympyrästä poistu %1$s. liittymästä suuntaan %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
index 8c51819ca8..31b7c554cd 100644
--- a/core/src/main/resources/com/graphhopper/util/fil.txt
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=matalim kaliwa 
-sharp_right=matalim karapatan 
-left=kaliwa 
-right=karapatan 
-slight_left=bahagyang kaliwa
-slight_right=bahagyang kanan
 continue=tuwirín ang daán
 continue_onto=magpatuloy papunta sa %1$s
-turn=pagliko %1$s
-turn_onto=lumiko %1$s papunta sa %2$s
+turn_left=pagliko kaliwa
+turn_right=pagliko karapatan
+turn_slight_left=pagliko bahagyang kaliwa
+turn_slight_right=pagliko bahagyang kanan
+turn_sharp_left=pagliko matalim kaliwa
+turn_sharp_right=pagliko matalim karapatan
+turn_onto=%1$s papunta sa %2$s
 web.searchButton=Paghahanap
 web.fromHint=mula sa 
 web.viaHint=
@@ -23,9 +22,9 @@ web.racingbike=RacingBike
 web.mtb=MountainBike
 web.car=kotse
 web.foot=lumakad
-web.staticlink=
-web.motorcycle=
-via=
+web.staticlink=static link
+web.motorcycle=motorsiklo
+via=sa pamamagitan ng
 finish=Tapusin!
 hourAbbr=h
 dayAbbr=d
@@ -41,5 +40,6 @@ way=landas
 paved=aspaltado 
 unpaved=hindi aspaltado
 stopover=pamahingahan %1$s
-roundaboutInstruction=Lpasok rotonda at gamitin %1$s
-roundaboutInstructionWithDir=Epasok rotonda at gamitin %1$s direksyon %2$s
+roundaboutEnter=Lpasok Rotonda
+roundaboutExit=Sa rotonda, lumabas sa exit %1$s
+roundaboutExitOnto=Sa rotonda, lumabas sa exit papunta %1$s %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index bee3ecfe7b..7f77887d4f 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=fort à gauche
-sharp_right=fort à droite
-left=à gauche
-right=à droite
-slight_left=légèrement à gauche
-slight_right=légèrement à droite
 continue=continuez
 continue_onto=continuez sur %1$s
-turn=tournez %1$s
-turn_onto=tournez %1$s sur %2$s
+turn_left=tournez à gauche
+turn_right=tournez à droite
+turn_slight_left=tournez légèrement à gauche
+turn_slight_right=tournez légèrement à droite
+turn_sharp_left=tournez fort à gauche
+turn_sharp_right=tournez fort à droite
+turn_onto=%1$s sur %2$s
 web.searchButton=Rechercher
 web.fromHint=De
 web.viaHint=via
@@ -24,7 +23,7 @@ web.mtb=VTT
 web.car=Voiture
 web.foot=À pied
 web.staticlink=Lien
-web.motorcycle=
+web.motorcycle=Vélo
 via=via
 finish=Fini!
 hourAbbr=h
@@ -41,5 +40,6 @@ way=chemin
 paved=pavé
 unpaved=non-pavé
 stopover=escale %1$s
-roundaboutInstruction=empruntez le rond point et prenez la sortie %1$s
-roundaboutInstructionWithDir=empruntez le rond point et prenez la sortie %1$s, en direction de %2$s
+roundaboutEnter=Empruntez le rond-point
+roundaboutExit=Au rond-point, prennez la %1$s sortie
+roundaboutExitOnto=Au rond-point, prennez la %1$s sortie vers %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
index a03eda11a4..8a91be54a8 100644
--- a/core/src/main/resources/com/graphhopper/util/gl.txt
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=xusto á esquerda
-sharp_right=xusto á dereita
-left=esquerda
-right=dereita
-slight_left=vire á esquerda
-slight_right=vire á dereita
 continue=continúe
 continue_onto=continúe por %1$s
-turn=vire por %1$s
-turn_onto=vire %1$s por %2$s
+turn_left=vire por esquerda
+turn_right=vire por dereita
+turn_slight_left=vire á esquerda
+turn_slight_right=vire á dereita
+turn_sharp_left=vire por xusto á esquerda
+turn_sharp_right=vire por xusto á dereita
+turn_onto=%1$s por %2$s
 web.searchButton=buscar
 web.fromHint=dende
 web.viaHint=Vía
@@ -41,5 +40,6 @@ way=vía
 paved=asfaltada
 unpaved=non pavimentada
 stopover=escala%1$s
-roundaboutInstruction= Entre na rotonda e tome a saída %1$s
-roundaboutInstructionWithDir= Entre na rotonda e tome a saída %1$s en dirección%2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index e565afe2b1..963ba6a920 100644
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=שמאלה בחדות
-sharp_right=ימינה בחדות
-left=שמאלה
-right=ימינה
-slight_left=מעט שמאלה
-slight_right=מעט ימינה
 continue=להמשיך
 continue_onto=להמשיך לתוך %1$s
-turn=נא לפנות %1$s
-turn_onto=נא לפנות %1$s לתוך %2$s
+turn_left=שמאלה
+turn_right=ימינה
+turn_slight_left=מעט שמאלה
+turn_slight_right=מעט ימינה
+turn_sharp_left=שמאלה בחדות
+turn_sharp_right=ימינה בחדות
+turn_onto=יש לפנות %1$s לתוך %2$s
 web.searchButton=חיפוש
 web.fromHint=מוצא
 web.viaHint=דרך
@@ -24,7 +23,7 @@ web.mtb=אופני הרים
 web.car=מכונית
 web.foot=רגל
 web.staticlink=קישור קבוע
-web.motorcycle=
+web.motorcycle=אופנוע
 via=דרך
 finish=סיימת!
 hourAbbr=שע׳
@@ -41,5 +40,6 @@ way=דרך
 paved=סלולה
 unpaved=לא סלולה
 stopover=נקודת עצירה מס׳ %1$s
-roundaboutInstruction=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s
-roundaboutInstructionWithDir=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s בכיוון %2$s
+roundaboutEnter=יש להיכנס לכיכר
+roundaboutExit=בכיכר, יש לצאת ביציאה %1$s
+roundaboutExitOnto=בכיכר, יש לצאת ביציאה %1$s לתוך %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index c9ad8dfcb8..869881f239 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=nettamente a sinistra
-sharp_right=nettamente a destra
-left=a sinistra
-right=a destra
-slight_left=leggermente a sinistra
-slight_right=leggermente a destra
 continue=continua
 continue_onto=continua su %1$s
-turn=gira %1$s
-turn_onto=gira %1$s su %2$s
+turn_left=gira a sinistra
+turn_right=gira a destra
+turn_slight_left=gira leggermente a sinistra
+turn_slight_right=gira leggermente a destra
+turn_sharp_left=gira nettamente a sinistra
+turn_sharp_right=gira nettamente a destra
+turn_onto=%1$s su %2$s
 web.searchButton=Ricerca
 web.fromHint=Da
 web.viaHint=attraverso
@@ -24,7 +23,7 @@ web.mtb=Mountainbike
 web.car=Auto
 web.foot=A piedi
 web.staticlink=permalink
-web.motorcycle=
+web.motorcycle=Moto
 via=attraverso
 finish=Arrivo!
 hourAbbr=hh
@@ -41,5 +40,6 @@ way=via
 paved=pavimentata
 unpaved=non pavimentata
 stopover=sosta %1$s
-roundaboutInstruction=Prendere l'uscita %1$s
-roundaboutInstructionWithDir=Prendere l'uscita %1$s in direzione %2$s
+roundaboutEnter=Entrare nella rotatoria
+roundaboutExit=Nella rotatoria, prendere l'uscita %1$s
+roundaboutExitOnto=Nella rotatoria, prendere l'uscita %1$s su %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index fa8095337d..08de85884e 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -1,14 +1,13 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=左
-sharp_right=右
-left=左
-right=右
-slight_left=左
-slight_right=右
 continue=進む
 continue_onto=%1$sまで進む
-turn=%1$sに曲がる
+turn_left=左に曲がる
+turn_right=右に曲がる
+turn_slight_left=左に曲がる
+turn_slight_right=右に曲がる
+turn_sharp_left=左に曲がる
+turn_sharp_right=右に曲がる
 turn_onto=%1$sに曲がって%2$sに入る
 web.searchButton=検索
 web.fromHint=出発地点
@@ -23,9 +22,9 @@ web.racingbike=レースバイク
 web.mtb=マウンテンバイク
 web.car=車
 web.foot=徒歩
-web.staticlink=
-web.motorcycle=
-via=
+web.staticlink=パーマリンク
+web.motorcycle=オートバイ
+via=経由
 finish=目標達成
 hourAbbr=時間
 dayAbbr=日
@@ -41,5 +40,6 @@ way=道
 paved=舗装された道
 unpaved=未舗装の道
 stopover=%1$sで降りる
-roundaboutInstruction=円形交差点の%1$s出口から
-roundaboutInstructionWithDir=円形交差点の%1$s出口から%2$s方向へ
+roundaboutEnter=円形交差点に入る
+roundaboutExit=円形交差点の出口%1$sへ
+roundaboutExitOnto=円形交差点の出口%1$sから%2$sへ
diff --git a/core/src/main/resources/com/graphhopper/util/ne.txt b/core/src/main/resources/com/graphhopper/util/ne.txt
new file mode 100644
index 0000000000..e502256a5e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ne.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=गहिरख्नुहोस
+continue_onto=%1$s गहिरख्नुहोस
+turn_left=बाया मोड्नुहोस 
+turn_right=दाया मोड्नुहोस 
+turn_slight_left=थोरै बाया मोड्नुहोस 
+turn_slight_right=थोरै दाया मोड्नुहोस 
+turn_sharp_left=धेरै बाया मोड्नुहोस 
+turn_sharp_right=धेरै दाया मोड्नुहोस 
+turn_onto=%2$s मा %1$s मोड्नुहोस 
+web.searchButton=खोज 
+web.fromHint=सुरु 
+web.viaHint=बाट
+web.toHint=अन्त्य
+web.moreButton=अझै
+web.gpxExportButton=GPX मा परिबर्तन गर्नुहोस
+web.routeInfo=%1$s को लागि %2$s लाग्नेछ
+web.locationsNotFound=ठाउँ नभेटीनाले बाटो पत्ता लगाउन सकिएन
+web.bike=बाईक 
+web.racingbike=छिटो गतिका बाईक
+web.mtb=माउन्टेन बाईक
+web.car=गाडी
+web.foot=पैदल
+web.staticlink=ईस्ट्यातिक लिंक
+web.motorcycle=मोटरसाइकल 
+via=बाट
+finish=सकियो
+hourAbbr=घण्टा
+dayAbbr=दिन
+minAbbr=मिनेट
+kmAbbr=किलोमीटर 
+mAbbr=मीटर
+miAbbr=माइल्स
+ftAbbr=फुट
+road=सडक
+off_bike=बाईक बाट ओर्लनुहोस
+cycleway=साइकल हिड्ने बाटो
+way=बाटो
+paved=पक्कि
+unpaved=कच्ची
+stopover=%1$s रोकिने ठाउँ 
+roundaboutEnter=घुम्ती मा छिर्नुहोस
+roundaboutExit=घुम्तीमा %1$s नम्बर को मोडबाट निस्कनुहोस 
+roundaboutExitOnto=घुम्तीमा %1$s नम्बर को मोडबाट निस्केर %2$s मा जानुहोस
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index cca8ce0924..059c334c4a 100644
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=draai naar links
-sharp_right=draai naar rechts
-left=links
-right=rechts
-slight_left=houd links aan
-slight_right=houd rechts aan
 continue=neem 
 continue_onto=blijf op %1$s
-turn=%1$s afbuigen
-turn_onto=sla %1$s af naar %2$s
+turn_left=links afbuigen
+turn_right=rechts afbuigen
+turn_slight_left=houd links aan afbuigen
+turn_slight_right=houd rechts aan afbuigen
+turn_sharp_left=ga linksaf afbuigen
+turn_sharp_right=ga rechtsaf afbuigen
+turn_onto=%1$s af naar %2$s
 web.searchButton=zoek
 web.fromHint=van
 web.viaHint=via
@@ -40,6 +39,7 @@ cycleway=fietspad
 way=weg
 paved=verhard
 unpaved=onverhard
-stopover=tussenbestemming %1$s
-roundaboutInstruction=ga de rotonde op en neem afrit %1$s
-roundaboutInstructionWithDir=ga de rotonde op en neem afrit %1$s richting %2$s
+stopover=tussenstop %1$s
+roundaboutEnter=ga de rotonde op
+roundaboutExit=neem afslag %1$s op de rotonde 
+roundaboutExitOnto=neem afslag %1$s naar %2$s op de rotonde 
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index 145acf0f6f..9672f19f3f 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva acentuada à esquerda
-sharp_right=curva acentuada à direita
-left=esquerda
-right=direita
-slight_left=curva suave à esquerda
-slight_right=curva suave à direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire à %1$s
-turn_onto=vire à %1$s em %2$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva suave à esquerda
+turn_slight_right=vire à curva suave à direita
+turn_sharp_left=vire à curva acentuada à esquerda
+turn_sharp_right=vire à curva acentuada à direita
+turn_onto=%1$s em %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Via
@@ -41,5 +40,6 @@ way=caminho
 paved=pavimentada
 unpaved=não pavimentada
 stopover=parada %1$s
-roundaboutInstruction=Entre na rotatória e saia na saída número %1$s
-roundaboutInstructionWithDir=Entre na rotatória e saia na saída número %1$s em direção a %2$s
+roundaboutEnter=Entre na rotatória
+roundaboutExit=Na rotatória, saia na %1$ saída
+roundaboutExitOnto=Na rotatória, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index cd0cb6b61c..1103e54ae1 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva apertada à esquerda
-sharp_right=curva apertada à direita
-left=esquerda
-right=direita
-slight_left=curva ligeira à esquerda
-slight_right=curva ligeira à direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire à %1$s
-turn_onto=vire à %1$s para %2$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva ligeira à esquerda
+turn_slight_right=vire à curva ligeira à direita
+turn_sharp_left=vire à curva apertada à esquerda
+turn_sharp_right=vire à curva apertada à direita
+turn_onto=%1$s para %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Por
@@ -41,5 +40,6 @@ way=caminho
 paved=pavimentado
 unpaved=não pavimentada
 stopover=paragem %1$s
-roundaboutInstruction=Entre na rotunda e saia na saída número %1$s
-roundaboutInstructionWithDir=Entre na rotunda e saia na saída número %1$s em direção a %2$s
+roundaboutEnter=Entre na rotunda
+roundaboutExit=Na rotunda, saia na %1$ saída
+roundaboutExitOnto=Na rotunda, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index 3b95d3528a..67e0da87ad 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=brusc la stânga
-sharp_right=brusc la dreapta
-left=stânga
-right=dreapta
-slight_left=ușor la stânga
-slight_right=ușor la dreapta
 continue=continuă
 continue_onto=continuă pe %1$s
-turn=schimbați direcția la %1$s
-turn_onto=schimbați direcția la %1$s pe %2$s
+turn_left=schimbați direcția la stânga
+turn_right=schimbați direcția la dreapta
+turn_slight_left=schimbați direcția la ușor la stânga
+turn_slight_right=schimbați direcția la ușor la dreapta
+turn_sharp_left=schimbați direcția la brusc la stânga
+turn_sharp_right=schimbați direcția la brusc la dreapta
+turn_onto=%1$s pe %2$s
 web.searchButton=Caută
 web.fromHint=De la
 web.viaHint=Prin
@@ -41,5 +40,6 @@ way=cale
 paved=pavat
 unpaved=nepavat
 stopover=escala %1$s
-roundaboutInstruction= Intrați în giratoriu și folosiți ieșirea %1$s
-roundaboutInstructionWithDir= Intrați în giratoriu și folosiți ieșirea %1$s în direcția %2$s
+roundaboutEnter=Intrați în giratoriu 
+roundaboutExit=La giratoriu folosiți ieșirea %1$
+roundaboutExitOnto=La giratoriu folosiți ieșirea %1$ către %2$
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index a32caa5a95..d5b796eae4 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=резко налево
-sharp_right=резко направо
-left=налево
-right=направо
-slight_left=немного левее
-slight_right=немного правее
 continue=продолжайте
 continue_onto=продолжайте по %1$s
-turn=Поверните на %1$s
-turn_onto=Поверните на %1$s на %2$s
+turn_left=Поверните налево
+turn_right=Поверните направо
+turn_slight_left=Поверните немного левее
+turn_slight_right=Поверните немного правее
+turn_sharp_left=Поверните резко налево
+turn_sharp_right=Поверните резко направо
+turn_onto=%1$s на %2$s
 web.searchButton=Поиск
 web.fromHint=От
 web.viaHint=Через
@@ -41,5 +40,6 @@ way=путь
 paved=с покрытием
 unpaved=без покрытия
 stopover=остановка %1$s
-roundaboutInstruction=Въезжайте на кольцо и используйте съезд %1$s
-roundaboutInstructionWithDir=Въезжайте на кольцо и используйте съезд %1$s в направлении %2$s
+roundaboutEnter=Въезжайте на кольцо
+roundaboutExit=У кольца используйте съезд %1$s
+roundaboutExitOnto=У кольца используйте съезд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index 349143a802..7276fc5fa4 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro levo
-sharp_right=ostro desno
-left=levo
-right=desno
-slight_left=rahlo levo
-slight_right=rahlo desno
 continue=nadaljujte
 continue_onto=nadaljujte po %1$s
-turn=zavite %1$s
-turn_onto=zavite %1$s na %2$s
+turn_left=zavite levo
+turn_right=zavite desno
+turn_slight_left=zavite rahlo levo
+turn_slight_right=zavite rahlo desno
+turn_sharp_left=zavite ostro levo
+turn_sharp_right=zavite ostro desno
+turn_onto=%1$s na %2$s
 web.searchButton=Išči
 web.fromHint=Od 
 web.viaHint=
@@ -23,9 +22,9 @@ web.racingbike=cestno kolo
 web.mtb=gorsko kolo
 web.car=Avto
 web.foot=Peš
-web.staticlink=
-web.motorcycle=
-via=
+web.staticlink=povezava
+web.motorcycle=motorno kolo
+via=preko
 finish=Konec!
 hourAbbr=h
 dayAbbr=d
@@ -41,5 +40,6 @@ way=smer
 paved=tlakovana
 unpaved=netlakovana
 stopover=postanek %1$s
-roundaboutInstruction=zapelji v krožišče in izberi izhod %1$
-roundaboutInstructionWithDir=zapelji v krožišče in izberi izhod %1$ v smeri %2$s
+roundaboutEnter=zapeljite v krožišče
+roundaboutExit=v krožišču izberite izhod %1$s
+roundaboutExitOnto=v krožišču izberite izhod %1$s na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 89f40e77fb..623154278c 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro doľava
-sharp_right=ostro doprava
-left=doľava
-right=doprava
-slight_left=mierne doľava
-slight_right=mierne doprava
 continue=pokračujte
 continue_onto=pokračujte na %1$s
-turn=odbočte %1$s
-turn_onto=odbočte %1$s na %2$s
+turn_left=odbočte doľava
+turn_right=odbočte doprava
+turn_slight_left=odbočte mierne doľava
+turn_slight_right=odbočte mierne doprava
+turn_sharp_left=odbočte ostro doľava
+turn_sharp_right=odbočte ostro doprava
+turn_onto=%1$s na %2$s
 web.searchButton=Vyhľadať
 web.fromHint=Z
 web.viaHint=Cez
@@ -24,7 +23,7 @@ web.mtb=Horský bicykel
 web.car=Automobil
 web.foot=Pešo
 web.staticlink=nemenný odkaz
-web.motorcycle=
+web.motorcycle=Motocykel
 via=cez
 finish=Cieľ!
 hourAbbr=Horský bicykel
@@ -41,5 +40,6 @@ way=smer
 paved=spevnená
 unpaved=nespevnená
 stopover=zastávka %1$s
-roundaboutInstruction=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd
-roundaboutInstructionWithDir=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd v smere %2$s
+roundaboutEnter=Vojdite na kruhový objazd
+roundaboutExit=Na kruhovom objazde, ho opustite cez %1$s. výjazd
+roundaboutExitOnto=Na kruhovom objazde, ho opustite cez %1$s. výjazd na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
index 2be5c3d179..07d7aba218 100644
--- a/core/src/main/resources/com/graphhopper/util/sv_SE.txt
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=kraftigt vänster
-sharp_right=kraftigt höger
-left=vänster
-right=höger
-slight_left=svagt vänster
-slight_right=svagt höger
 continue=fortsätt
 continue_onto=fortsätt in på %1$s
-turn=sväng %1$s
-turn_onto=sväng %1$s in på %2$s
+turn_left=sväng vänster
+turn_right=sväng höger
+turn_slight_left=sväng svagt vänster
+turn_slight_right=sväng svagt höger
+turn_sharp_left=sväng kraftigt vänster
+turn_sharp_right=sväng kraftigt höger
+turn_onto=%1$s in på %2$s
 web.searchButton=Sök
 web.fromHint=Från
 web.viaHint=Via
@@ -41,5 +40,6 @@ way=väg
 paved=belagd
 unpaved=obelagd
 stopover=delmål %1$s
-roundaboutInstruction=Kör in i rondellen och ta avfart %1$s
-roundaboutInstructionWithDir=Kör in i rondellen och ta avfart %1$s mot %2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index 802ae88134..2b774ce29a 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sola keskin dönüş
-sharp_right=sağa keskin dönüş
-left=sol 
-right=sağ 
-slight_left=hafif sola
-slight_right=hafif sağa
 continue=devam
 continue_onto=-e devam %1$s
-turn=dön %1$s
-turn_onto=-e dön %1$s %2$s
+turn_left=dön sol 
+turn_right=dön sağ 
+turn_slight_left=dön hafif sola
+turn_slight_right=dön hafif sağa
+turn_sharp_left=dön sola keskin dönüş
+turn_sharp_right=dön sağa keskin dönüş
+turn_onto=%1$s %2$s
 web.searchButton=ara
 web.fromHint=-den 
 web.viaHint=araciligi ile
@@ -41,5 +40,6 @@ way=yol
 paved=kaldırım
 unpaved=kaldırımsız yol
 stopover=mola yeri %1$s
-roundaboutInstruction=döner kavsağa girin ve cıkışı kullanın %1$
-roundaboutInstructionWithDir=döner kavşağa girin ve çıkışı kullanın %1$ - %2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index f0bd0b35d5..a356a96217 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=різко наліво
-sharp_right=різко направо
-left=наліво
-right=направо
-slight_left=трохи лівіше
-slight_right=трохи правіше
 continue=продовжуйте
 continue_onto=продовжуйте по „%1$s“
-turn=поверніть %1$s
-turn_onto=поверніть %1$s на „%2$s“
+turn_left=Поверніть наліво
+turn_right=Поверніть направо
+turn_slight_left=Поверніть трохи лівіше
+turn_slight_right=Поверніть трохи правіше
+turn_sharp_left=Поверніть різко наліво
+turn_sharp_right=Поверніть різко направо
+turn_onto=%1$s на „%2$s“
 web.searchButton=Пошук
 web.fromHint=Від
 web.viaHint=через
@@ -24,7 +23,7 @@ web.mtb=Гірський велосипед
 web.car=Автомобіль
 web.foot=Пішки
 web.staticlink=статичне посилання
-web.motorcycle=
+web.motorcycle=Мотоцикл
 via=через
 finish=Ви прибули до пункту призначення!
 hourAbbr= год
@@ -35,11 +34,12 @@ mAbbr= м
 miAbbr= милі
 ftAbbr= фути
 road=дорога
-off_bike=секція, що відкривається натисканням
+off_bike=злізьте з велосипеда
 cycleway=велосипедна доріжка
 way=шлях
 paved=з покриттям
 unpaved=без покриття
 stopover=зупинка %1$s
-roundaboutInstruction=в’їзд на кільце та виїзд по %1$s
-roundaboutInstructionWithDir=в’їзд на кільце та виїзд по %1$s у напрямку %2$s
+roundaboutEnter=В’їжджайте на кільце
+roundaboutExit=На кільці використовуйте з’їзд %1$s
+roundaboutExitOnto=На кільці використовуйте з’їзд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
index d31c14d228..015af51a0e 100644
--- a/core/src/main/resources/com/graphhopper/util/vi_VI.txt
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=rẽ trái ngay
-sharp_right=rẽ phải ngay
-left=rẽ trái
-right=rẽ phải
-slight_left=rẽ nhẹ trái
-slight_right=rẽ nhẹ phải
 continue=tiếp tục
 continue_onto=tiếp tục theo %1$s
-turn=rẽ %1$s
-turn_onto=rẽ %1$s theo %1$s
+turn_left=rẽ trái
+turn_right=rẽ phải
+turn_slight_left=rẽ nhẹ trái
+turn_slight_right=rẽ nhẹ phải
+turn_sharp_left=rẽ trái ngay
+turn_sharp_right=rẽ phải ngay
+turn_onto=%1$s theo %1$s
 web.searchButton=Tìm
 web.fromHint=Từ
 web.viaHint=Qua
@@ -41,5 +40,6 @@ way=đường
 paved=đường lát
 unpaved=đường không lát
 stopover=điểm nghỉ %1$s
-roundaboutInstruction=Vào vòng xoay và tìm lối ra %1$s
-roundaboutInstructionWithDir=Vào vòng xoay và tìm lối ra %1$s theo hướng %2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..1a5809a030
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=继续
+continue_onto=继续行驶到 %1$s
+turn_left=左转
+turn_right=右转
+turn_slight_left=偏左转
+turn_slight_right=偏右转
+turn_sharp_left=左急转
+turn_sharp_right=右急转
+turn_onto=%1$s 到  %2$s
+web.searchButton=搜索
+web.fromHint=起点
+web.viaHint=途经点
+web.toHint=终点
+web.moreButton=更多
+web.gpxExportButton=GPX导出
+web.routeInfo=%1$s 的路线，需要 %2$s 时间
+web.locationsNotFound=地点未找到
+web.bike=自行车
+web.racingbike=竞技自行车
+web.mtb=山地自行车
+web.car=驾车
+web.foot=步行
+web.staticlink=静态链接
+web.motorcycle=摩托车
+via=途经
+finish=终点到达
+hourAbbr=小时
+dayAbbr=天
+minAbbr=分钟
+kmAbbr=公里
+mAbbr=米
+miAbbr=英里
+ftAbbr=英尺
+road=道路
+off_bike=下自行车
+cycleway=自行车道
+way=路
+paved=路面铺就
+unpaved=路面未铺就
+stopover=途中休息 %1$s
+roundaboutEnter=进入环岛
+roundaboutExit=在环岛内，使用%1$s出口出环岛
+roundaboutExitOnto=在环岛内，使用%1$s出口出环岛，进入%2$s
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 03e770c979..fd7d4a3721 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -54,14 +54,14 @@ public void testLoad()
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10.4, 42, 10));
-        assertTrue(ph.isFound());
-        assertEquals(80, ph.getDistance(), 1e-6);
-        assertEquals(42, ph.getPoints().getLatitude(0), 1e-5);
-        assertEquals(10.4, ph.getPoints().getLongitude(0), 1e-5);
-        assertEquals(41.9, ph.getPoints().getLatitude(1), 1e-5);
-        assertEquals(10.2, ph.getPoints().getLongitude(1), 1e-5);
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(42, 10.4, 42, 10));
+        assertFalse(rsp.hasErrors());
+        assertEquals(80, rsp.getDistance(), 1e-6);
+        assertEquals(42, rsp.getPoints().getLatitude(0), 1e-5);
+        assertEquals(10.4, rsp.getPoints().getLongitude(0), 1e-5);
+        assertEquals(41.9, rsp.getPoints().getLatitude(1), 1e-5);
+        assertEquals(10.2, rsp.getPoints().getLongitude(1), 1e-5);
+        assertEquals(3, rsp.getPoints().getSize());
         instance.close();
     }
 
@@ -77,15 +77,23 @@ public void testDisconnected179()
 
         graph.edge(0, 1, 10, true);
         graph.edge(2, 3, 10, true);
-        
+
         GraphHopper instance = new GraphHopper().
                 setStoreOnFlush(false).
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10, 42, 10.4));
-        assertFalse(ph.isFound());
-        assertEquals(0, ph.getPoints().getSize());        
+        GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
+        assertTrue(rsp.hasErrors());
+
+        try
+        {
+            rsp.getPoints();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
         instance.close();
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
similarity index 55%
rename from core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
rename to core/src/test/java/com/graphhopper/GraphHopperIT.java
index 61e00f2f72..0d74a52e0b 100644
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -15,12 +15,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing;
+package com.graphhopper;
 
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -28,49 +27,64 @@
 import java.io.File;
 import java.util.List;
 import java.util.Map;
-import org.junit.After;
-import org.junit.Test;
+import org.junit.*;
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
  * @author Peter Karich
  */
 public class GraphHopperIT
 {
-    String graphFile = "target/graph-GraphHopperIT";
-    String osmFile = "files/monaco.osm.gz";
-    String vehicle = "FOOT";
-    String importVehicles = "FOOT";
-    String weightCalcStr = "shortest";
+    private static GraphHopper hopper;
+    private static final String graphFileFoot = "target/graphhopperIT-foot";
+    private static final String osmFile = "files/monaco.osm.gz";
+    private static final String importVehicles = "FOOT";
+    private static final String vehicle = "FOOT";
+    private static final String weightCalcStr = "shortest";
+
+    private final String tmpGraphFile = "target/graphhopperIT-tmp";
 
     @Before
     public void setUp()
     {
-        // make sure we are using fresh graphhopper files with correct vehicle
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
     @After
     public void tearDown()
     {
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
-    @Test
-    public void testMonacoWithInstructions() throws Exception
+    @BeforeClass
+    public static void beforeClass()
     {
-        GraphHopper hopper = new GraphHopper().
+        // make sure we are using fresh graphhopper files with correct vehicle
+        Helper.removeDir(new File(graphFileFoot));
+
+        hopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(graphFileFoot).
                 setEncodingManager(new EncodingManager(importVehicles)).
                 importOrLoad();
+    }
 
+    @AfterClass
+    public static void afterClass()
+    {
+        Helper.removeDir(new File(graphFileFoot));
+    }
+
+    @Test
+    public void testMonacoWithInstructions() throws Exception
+    {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
+        // identify the number of counts to compare with CH foot route
+        assertEquals(698, hopper.getVisitedSum());
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
 
@@ -80,7 +94,7 @@ public void testMonacoWithInstructions() throws Exception
         List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
         assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
         assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
         assertEquals("Turn left", resultJson.get(3).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
@@ -106,20 +120,89 @@ public void testMonacoWithInstructions() throws Exception
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
+    @Test
+    public void testMonacoVia()
+    {
+        GHResponse rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(6875.1, rsp.getDistance(), .1);
+        assertEquals(179, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(26, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+
+        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
+        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
+        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Finish!", resultJson.get(25).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+    }
+
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
-        GraphHopper hopper = new GraphHopper().
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
-        hopper.importOrLoad();
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(1626.8, rsp.getDistance(), .1);
@@ -142,8 +225,8 @@ public void testSRTMWithInstructions() throws Exception
                 str.substring(0, 662));
 
         assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
-                + "(43.727680946587874,7.4191987684222065,11.0)",
-                str.substring(str.length() - 133));
+                + "(43.727680946587874,7.419198768422206,11.0)",
+                str.substring(str.length() - 132));
 
         List<GPXEntry> list = rsp.getInstructions().createGPXList();
         assertEquals(60, list.size());
@@ -160,134 +243,142 @@ public void testSRTMWithInstructions() throws Exception
     public void testKremsCyclewayInstructionsWithWayTypeInfo()
     {
         String tmpOsmFile = "files/krems.osm.gz";
-        String tmpGraphFile = "target/graph-krems";
         String tmpVehicle = "BIKE";
         String tmpImportVehicles = "CAR,BIKE";
         String tmpWeightCalcStr = "fastest";
 
-        try
-        {
-            // make sure we are using fresh graphhopper files with correct vehicle
-            Helper.removeDir(new File(tmpGraphFile));
-            GraphHopper hopper = new GraphHopper().
-                    setStoreOnFlush(true).
-                    setOSMFile(tmpOsmFile).
-                    setCHEnable(false).
-                    setGraphHopperLocation(tmpGraphFile).
-                    setEncodingManager(new EncodingManager(tmpImportVehicles)).
-                    importOrLoad();
-
-            GHResponse rsp = hopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
-                    setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
-
-            assertEquals(6932.24, rsp.getDistance(), .1);
-            assertEquals(110, rsp.getPoints().getSize());
-
-            InstructionList il = rsp.getInstructions();
-            assertEquals(19, il.size());
-            List<Map<String, Object>> resultJson = il.createJson();
-
-            assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
-            assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
-            assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
-            assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
-
-            assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
-            assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-            assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
-            assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
-            assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
-            assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
-            assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
-            assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
-            assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
-            //..
-            assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
-            assertEquals("cycleway", resultJson.get(15).get("annotationText"));
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("cannot handle osm file " + tmpOsmFile, ex);
-        } finally
-        {
-            Helper.removeDir(new File(tmpGraphFile));
-        }
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        assertEquals(6932.24, rsp.getDistance(), .1);
+        assertEquals(110, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(19, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+
+        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
+        assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
+        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
+
+        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
+        assertEquals("Turn slight left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
+        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
+        assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
+        assertEquals("Turn slight left onto Austraße", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+        //..
+        assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+        assertEquals("cycleway", resultJson.get(15).get("annotation_text"));
     }
 
     @Test
-    public void testMonacoVia()
+    public void testRoundaboutInstructionsWithCH()
     {
-        GraphHopper hopper = new GraphHopper().
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "car,bike";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles)).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
                 importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.74958, 7.436566)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
+        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
 
-        assertEquals(6875.1, rsp.getDistance(), .1);
-        assertEquals(179, rsp.getPoints().getSize());
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        InstructionList il = rsp.getInstructions();
-        assertEquals(26, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left", resultJson.get(3).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745968, 7.42907, 43.745832, 7.428614)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
-        assertEquals("Turn left", resultJson.get(21).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
-        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
-        assertEquals("Finish!", resultJson.get(25).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.735817, 7.417096, 43.735666, 7.416587)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+    }
 
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+    @Test
+    public void testMultipleVehiclesAndDoCHForBike()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "bike,car";
 
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+        assertEquals("bike", tmpHopper.getDefaultVehicle().toString());
 
-        // special case of identical start and end point
-        rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
-        assertEquals(0, rsp.getDistance(), .1);
-        assertEquals(0, rsp.getRouteWeight(), .1);
-        assertEquals(1, rsp.getPoints().getSize());
-        assertEquals(1, rsp.getInstructions().size());
-        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
-        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
-        
-        rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
-        assertEquals(0, rsp.getDistance(), .1);
-        assertEquals(0, rsp.getRouteWeight(), .1);
-        assertEquals(2, rsp.getPoints().getSize());
-        assertEquals(2, rsp.getInstructions().size());
-        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
-        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("car"));
+        assertEquals(207, rsp.getMillis() / 1000f, 1);
+        assertEquals(2838, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("bike"));
+        assertEquals(494, rsp.getMillis() / 1000f, 1);
+        assertEquals(2192, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("foot"));
+        assertTrue("only bike and car were imported. foot request should fail", rsp.hasErrors());
+    }
+
+    @Test
+    public void testIfCHIsUsed() throws Exception
+    {
+        // route directly after import
+        executeCHFootRoute();
+
+        // now only load is called
+        executeCHFootRoute();
+    }
+
+    private void executeCHFootRoute()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "foot";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHWeighting(weightCalcStr).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        // same query as in testMonacoWithInstructions
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
+                setVehicle(vehicle));
+
+        // identify the number of counts to compare with none-CH foot route which had nearly 700 counts
+        assertTrue("Too many nodes visited " + tmpHopper.getVisitedSum(), tmpHopper.getVisitedSum() < 120);
+        assertEquals(3437.6, rsp.getDistance(), .1);
+        assertEquals(89, rsp.getPoints().getSize());
+        tmpHopper.close();
     }
 }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index b6e86c5647..fe5e04f20c 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -69,22 +69,23 @@ public void testLoadOSM()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         closableInstance.importOrLoad();
-        GHResponse ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
-        closableInstance = new GraphHopper().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("CAR"));
+
+        // no encoding manager necessary
+        closableInstance = new GraphHopper().setStoreOnFlush(true);
         assertTrue(closableInstance.load(ghLoc));
-        ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
         try
         {
-            ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+            rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -110,18 +111,18 @@ public void testLoadOSMNoCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         gh.importOrLoad();
-        GHResponse ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
         gh = new GraphHopper().setStoreOnFlush(true).
                 setCHEnable(false).
                 setEncodingManager(new EncodingManager("CAR"));
         assertTrue(gh.load(ghLoc));
-        ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
     }
@@ -227,11 +228,11 @@ public void testPrepare()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
                 setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
-        assertTrue(ph.isFound());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", ph.getPoints().toString());
-        assertEquals(3, ph.getPoints().getSize());
+        assertFalse(rsp.hasErrors());
+        assertEquals(Helper.createPointList(51.249215, 9.431716, 52.0, 9.0, 51.2, 9.4), rsp.getPoints());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -244,13 +245,13 @@ public void testSortedGraph_noCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
                 setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), ph.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), ph.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), ph.getPoints().toGHPoint(2));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
 
         GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
         boolean old = instance.enableInstructions;
@@ -278,33 +279,33 @@ public void testFootAndCar()
         assertEquals(8, instance.getGraph().getAllEdges().getCount());
 
         // A to D
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
-        assertFalse(res.hasErrors());
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
         // => found A and D
-        assertEquals(50, res.getPoints().getLongitude(0), 1e-3);
-        assertEquals(11.1, res.getPoints().getLatitude(0), 1e-3);
-        assertEquals(51, res.getPoints().getLongitude(2), 1e-3);
-        assertEquals(11.3, res.getPoints().getLatitude(2), 1e-3);
+        assertEquals(50, rsp.getPoints().getLongitude(0), 1e-3);
+        assertEquals(11.1, rsp.getPoints().getLatitude(0), 1e-3);
+        assertEquals(51, rsp.getPoints().getLongitude(2), 1e-3);
+        assertEquals(11.3, rsp.getPoints().getLatitude(2), 1e-3);
 
         // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT        
-        res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().getSize());
         // => found a point on edge A-B        
-        assertEquals(11.680, res.getPoints().getLatitude(1), 1e-3);
-        assertEquals(50.644, res.getPoints().getLongitude(1), 1e-3);
+        assertEquals(11.680, rsp.getPoints().getLatitude(1), 1e-3);
+        assertEquals(50.644, rsp.getPoints().getLongitude(1), 1e-3);
 
         // A to E only for foot
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().size());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().size());
 
         // A D E for car
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -321,31 +322,36 @@ public void testFailsForWrongConfig() throws IOException
         assertEquals(5, instance.getGraph().getNodes());
         instance.close();
 
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("graph.flagEncoders", "FOOT").
-                put("prepare.chWeighting", "no")).
-                setOSMFile(testOsm3);
+        // different config (flagEncoder list)
         try
         {
-            instance.load(ghLoc);
+            GraphHopper tmpGH = new GraphHopper().init(
+                    new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("graph.flagEncoders", "FOOT").
+                    put("prepare.chWeighting", "no")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
 
-        // different order should be ok
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("prepare.chWeighting", "no").
-                put("graph.flagEncoders", "CAR,FOOT")).
-                setOSMFile(testOsm3);
-        assertTrue(instance.load(ghLoc));
-        assertEquals(5, instance.getGraph().getNodes());
+        // different order is no longer okay, see #350
+        try
+        {
+            GraphHopper tmpGH = new GraphHopper().init(new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("prepare.chWeighting", "no").
+                    put("graph.flagEncoders", "CAR,FOOT")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
     }
 
     @Test
@@ -451,7 +457,7 @@ public void testFootOnly()
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
+        assertFalse(res.hasErrors());
         assertEquals(3, res.getPoints().getSize());
     }
 
@@ -499,7 +505,7 @@ public void testVia()
                 init(new CmdArgs().
                         put("osmreader.osm", testOsm3).
                         put("prepare.minNetworkSize", "1").
-                        put("graph.acceptWay", "CAR")).
+                        put("graph.flagEncoders", "CAR")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
@@ -508,16 +514,16 @@ public void testVia()
         GHPoint second = new GHPoint(12, 51);
         GHPoint third = new GHPoint(11.2, 51.9);
         GHResponse rsp12 = instance.route(new GHRequest().addPoint(first).addPoint(second));
-        assertTrue("should find 1->2", rsp12.isFound());
+        assertFalse("should find 1->2", rsp12.hasErrors());
         assertEquals(147930.5, rsp12.getDistance(), .1);
         GHResponse rsp23 = instance.route(new GHRequest().addPoint(second).addPoint(third));
-        assertTrue("should find 2->3", rsp23.isFound());
+        assertFalse("should find 2->3", rsp23.hasErrors());
         assertEquals(176608.9, rsp23.getDistance(), .1);
 
         GHResponse rsp = instance.route(new GHRequest().addPoint(first).addPoint(second).addPoint(third));
 
         assertFalse(rsp.hasErrors());
-        assertTrue("should find 1->2->3", rsp.isFound());
+        assertFalse("should find 1->2->3", rsp.hasErrors());
         assertEquals(rsp12.getDistance() + rsp23.getDistance(), rsp.getDistance(), 1e-6);
         assertEquals(5, rsp.getPoints().getSize());
         assertEquals(5, rsp.getInstructions().size());
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index cb8e34888f..36dfb74cd2 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.geohash;
 
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import static org.junit.Assert.*;
 import org.junit.Test;
@@ -67,4 +68,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+    /*
+    * Test if different constructors yield same results
+     */
+    @Test
+    public void testInstantiation()
+    {
+        double minLon = 0; 
+        double minLat = 2;
+        double maxLat = 6;
+        double maxLon = 5;
+        
+        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+        assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
+        assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 6fc02eeeea..7cdfdf5867 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -172,8 +172,8 @@ public void testMain()
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
         FlagEncoder flags = carEncoder;
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(flags.isForward(iter.getFlags()));
+        assertTrue(flags.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals("route 666", iter.getName());
@@ -185,8 +185,8 @@ public void testMain()
         assertEquals(n10, iter.getAdjNode());
         assertEquals(88643, iter.getDistance(), 1);
 
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(flags.isForward(iter.getFlags()));
+        assertTrue(flags.isBackward(iter.getFlags()));
         assertFalse(iter.next());
 
         // get third added location id=30
@@ -292,27 +292,27 @@ public void testOneWay()
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(iter.getFlags()));
+        assertFalse(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n22, iter.getAdjNode());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(iter.getFlags()));
+        assertFalse(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n10, iter.getAdjNode());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index ef82bc6dfa..ea30e4233c 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 1b83e2d881..92c5a2b0a7 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -36,7 +36,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index c3523399bb..5b09bd3268 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -21,12 +21,12 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import java.util.Random;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -38,9 +38,18 @@
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
-    protected AlgorithmOptions defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new ShortestWeighting()).build();
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
+    }
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -68,25 +77,37 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 7);
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
         assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
     }
 
+    @Test
+    public void testCalcShortestPathWithLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
+    }
+
     // see calc-fastest-graph.svg
     @Test
     public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = createAlgo(graphShortest, defaultOpts).
-                calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 144823, p1.getMillis());
 
         Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest,
                 AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
                 calcPath(0, 3);
@@ -100,28 +121,28 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(carEncoder.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setFlags(carEncoder.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setFlags(carEncoder.setProperties(100, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -141,14 +162,15 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).weighting(new ShortestWeighting()).build()).
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -578,7 +600,7 @@ public void testViaEdges_SpecialCases()
     public void testQueryGraphAndFastest()
     {
         Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph);
+        initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
@@ -592,12 +614,7 @@ Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat
 
     Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index;
-        if (graph instanceof LevelGraph)
-            index = new LocationIndexTreeSC((LevelGraph) graph, new RAMDirectory());
-        else
-            index = new LocationIndexTree(graph, new RAMDirectory());
-
+        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
@@ -662,7 +679,7 @@ public void testTwoWeightsPerEdge()
 //        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(85124371, p.getMillis());
         assertEquals(425622, p.getDistance(), 1);
-        assertEquals(6568, p.getWeight(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index a90beaace4..0f67d59627 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index c9d6e2d3b0..4092c96b44 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -28,6 +28,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
  *
@@ -39,7 +40,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameterized.Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
@@ -122,7 +123,7 @@ public void testIssue182()
     }
 
     @Test
-    public void testIssue239()
+    public void testIssue239_and362()
     {
         Graph g = createGraph(false);
         g.edge(0, 1, 1, true);
@@ -136,6 +137,9 @@ public void testIssue239()
         DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         assertEquals(-1, algo.findEndNode(0, 4));
         assertEquals(-1, algo.findEndNode(0, 4));
+
+        assertEquals(1, algo.findEndNode(0, 1));
+        assertEquals(1, algo.findEndNode(0, 1));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 539dfd7e2d..fb8c479901 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index b640f438ae..1bbc864885 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -130,9 +130,9 @@ private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncod
         tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
     }
 
-    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs )
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
     {
-        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs);
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
     }
 
     @Test
@@ -142,16 +142,25 @@ public void testBasicTurnRestriction()
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
-        Path p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
         assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 7);
         assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
 
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(7, 5);
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -168,21 +177,26 @@ public void testUTurns()
         // force u-turn via lowering the cost for it
         EdgeIteratorState e3_6 = getEdge(g, 3, 6);
         e3_6.setDistance(0.1);
-        getEdge(g, 3, 2).setDistance(8642);
-        getEdge(g, 1, 0).setDistance(8642);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
 
         tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
         tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
-        Path p = createAlgo(g,
-                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build()).
-                calcPath(7, 5);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);        
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
-        // no u-turn    from 6-3
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build()).
-                calcPath(7, 5);
+        p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -193,7 +207,10 @@ public void testBasicTurnCosts()
         GraphStorage g = createGraph(createEncodingManager(false));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        Path p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
 
         // no restriction and costs
@@ -205,7 +222,10 @@ public void testBasicTurnCosts()
         long tflags = carEncoder.getTurnFlags(false, 2);
         tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
 
-        p = createAlgo(g, AlgorithmOptions.start().flagEncoder(carEncoder).weighting(createWeighting(carEncoder, tcs)).traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
         assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
     }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 4e6b9e423f..6b684c5120 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -40,10 +37,14 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
+    private final EncodingManager mixedEncoders = new EncodingManager(
+            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
+    private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
 
     @Test
     public void testFound()
@@ -213,4 +214,308 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
+    private class RoundaboutGraph
+    {
+        private EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
+        final public NodeAccess na = g.getNodeAccess();
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
+
+        private RoundaboutGraph()
+        {
+            //                          
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.35);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+            na.setNode(9, 52.513, 13.351);
+          
+           
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            
+            // roundabout
+            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+            roundaboutEdges.add(tmpEdge.detach(false));
+
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge3to6 = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
+            edge3to9 = tmpEdge.detach(false);
+            
+            setRoundabout(clockwise);
+            inverse3to9();
+            
+        }
+        
+        public void setRoundabout(boolean clockwise)
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                for (EdgeIteratorState edge : roundaboutEdges)
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                }
+            }    
+            this.clockwise = clockwise;
+        }
+        
+        public void inverse3to9()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+            }
+        }
+
+        public void inverse3to6()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+            }
+        }
+        
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    /**
+     * Test roundabout instructions for different profiles
+     */
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        {
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                    .calcPath(1, 8);
+            InstructionList wayList = p.calcInstructions(tr);
+            // Test instructions
+            List<String> tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 3 onto 5-8",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+            RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+
+            // case of continuing a street through a roundabout
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            wayList = p.calcInstructions(tr);
+            tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 2 onto MainStreet",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            delta = roundaboutGraph.getAngle(1, 2, 4, 7);
+            instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+        }
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case with one node being containig already exit 
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutDirectExit()
+    {
+        roundaboutGraph.inverse3to9();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        roundaboutGraph.inverse3to9();
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        roundaboutGraph.inverse3to6();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+        roundaboutGraph.inverse3to6();
+
+    }
+
+
+    /**
+     * see https://github.com/graphhopper/graphhopper/issues/353
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutIssue353()
+    {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+
+        //
+        //          8
+        //           \
+        //            5
+        //           /  \
+        //  11- 1 - 2    4 - 7
+        //      |     \  /
+        //      10 -9 -3
+        //       \    |
+        //        --- 6
+
+        na.setNode(1, 52.514, 13.348);
+        na.setNode(2, 52.514, 13.349);
+        na.setNode(3, 52.5135,13.35);
+        na.setNode(4, 52.514, 13.351);
+        na.setNode(5, 52.5145,13.351);
+        na.setNode(6, 52.513, 13.35);
+        na.setNode(7, 52.514, 13.352);
+        na.setNode(8, 52.515, 13.351);
+
+        // Sidelane
+        na.setNode(9, 52.5135, 13.349);
+        na.setNode(10, 52.5135, 13.348);
+        na.setNode(11, 52.514, 13.347);
+
+
+        EdgeIteratorState tmpEdge;
+        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
+        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
+
+
+         // roundabout
+        tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+
+        
+        
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 11);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        roundaboutGraph.setRoundabout(true);
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index c8607c1f5e..bf667e82dd 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -36,12 +36,15 @@
  */
 public class QueryGraphTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
     private GraphStorage g;
 
     @Before
     public void setUp()
     {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
     }
 
@@ -325,8 +328,7 @@ public void testOneWayLoop_Issue162()
         // | x
         // 0<-\
         // |
-        // 1
-        FlagEncoder carEncoder = encodingManager.getSingle();
+        // 1        
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
@@ -349,12 +351,12 @@ public void testOneWayLoop_Issue162()
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
         EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
         iter.next();
-        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertFalse(iter.toString(), carEncoder.isBackward(iter.getFlags()));
 
         iter.next();
-        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertTrue(iter.toString(), carEncoder.isBackward(iter.getFlags()));
     }
 
     @Test
@@ -520,13 +522,13 @@ public void testTurnCostsProperlyPropagated_Issue282()
         QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
         FastestWeighting weighting = new FastestWeighting(encoder);
         TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
-        
+
         assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
 
         // now use turn costs and QueryGraph
         turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
         assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
-        
+
         QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
         QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
 
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 6d71b76245..6252757154 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -21,13 +21,14 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
@@ -93,6 +94,57 @@ public void testMonaco()
         assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
+    }
+
     @Test
     public void testOneWayCircleBug()
     {
@@ -131,7 +183,7 @@ public void testMoscow()
     public void testMoscowTurnCosts()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));        
+        list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
         list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
         // TODO include CH
         boolean testAlsoCH = false, is3D = false;
@@ -190,10 +242,10 @@ public void testMonacoFoot()
                 createMonacoFoot(), "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
 
-        // see testMonaco for similar ID test
-        assertEquals(GHUtility.asSet(2, 906, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
-        assertEquals(GHUtility.asSet(443, 952, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
-        assertEquals(GHUtility.asSet(909, 580, 912), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
+        // see testMonaco for a similar ID test
+        assertEquals(GHUtility.asSet(2, 908, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(443, 954, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
+        assertEquals(GHUtility.asSet(910, 403, 122, 913), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
 
         assertEquals(43.743705, g.getNodeAccess().getLat(100), 1e-6);
         assertEquals(7.426362, g.getNodeAccess().getLon(701), 1e-6);
@@ -464,9 +516,8 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
             Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<AlgoHelperEntry> prepares = RoutingAlgorithmSpecialAreaTests.
-                    createAlgos(hopper.getGraph(), hopper.getLocationIndex(), encoder, testAlsoCH,
-                            tMode, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
             for (AlgoHelperEntry entry : prepares)
             {
@@ -506,9 +557,9 @@ public void testPerformance() throws IOException
         Graph graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile), 8 * (1 << 10))).read();
-        Collection<AlgoHelperEntry> prepares = RoutingAlgorithmSpecialAreaTests.
-                createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED, new ShortestWeighting(), eManager);
+        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+                new ShortestWeighting(), eManager);
         for (AlgoHelperEntry entry : prepares)
         {
             StopWatch sw = new StopWatch();
@@ -608,4 +659,48 @@ public void run()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
         hopper.close();
     }
+
+    static List<AlgoHelperEntry> createAlgos( Graph g,
+            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+    {
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        // later: include dijkstraOneToMany        
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+
+        if (withCh)
+        {
+            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
+                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
+                    graphCH, encoder, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
+
+            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
+        }
+        return prepare;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 5f0e744c8b..83ce7950ff 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -18,16 +18,8 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.EdgeSkipIterState;
 import com.graphhopper.util.Helper;
@@ -42,7 +34,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
@@ -66,16 +58,15 @@ protected LevelGraph createGraph( EncodingManager em, boolean is3D )
 
     @Override
     public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {        
-        return createFactory(g instanceof QueryGraph ? ((QueryGraph) g).getOriginalGraph() : g, opts).
-                createAlgo(g, opts);
+    {
+        return createFactory(g, opts).createAlgo(g, opts);
     }
 
     @Override
     public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
     {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies((LevelGraph) g,
-                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                (LevelGraph) g, opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
         // hack: prepare matrixGraph only once
         if (g != preparedMatrixGraph)
             ch.doWork();
@@ -123,7 +114,8 @@ public void testPathRecursiveUnpacking()
 
         ShortestWeighting weighting = new ShortestWeighting();
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
-        Path p = new PrepareContractionHierarchies(g2, encoder, weighting, TraversalMode.NODE_BASED).
+        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
+                g2, encoder, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
@@ -146,9 +138,60 @@ public long setProperties( double speed, boolean forward, boolean backward )
             }
         };
 
-        footEncoder = new EncodingManager("FOOT").getSingle();
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+
         super.testCalcFootPath();
         footEncoder = tmpFootEncoder;
         carEncoder = tmpCarEncoder;
     }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getMillis());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getMillis());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index b8a1d90ddb..7cacf0bfca 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -20,14 +20,12 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import java.util.Collection;
 import java.util.Iterator;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -38,7 +36,8 @@
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     private final Weighting weighting = new ShortestWeighting();
-    private TraversalMode tMode = TraversalMode.NODE_BASED;
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private Directory dir;
 
     LevelGraph createGraph()
     {
@@ -64,6 +63,11 @@ LevelGraph createExampleGraph()
         g.edge(5, 1, 2, true);
         return g;
     }
+    
+    @Before
+    public void setUp() {
+        dir = new GHDirectory("", DAType.RAM_INT);
+    }
 
     @Test
     public void testShortestPathSkipNode()
@@ -71,8 +75,11 @@ public void testShortestPathSkipNode()
         LevelGraph g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -87,11 +94,14 @@ public void testShortestPathSkipNode2()
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -100,8 +110,11 @@ public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
@@ -111,7 +124,7 @@ public void testAddShortcuts()
     {
         LevelGraph g = createExampleGraph();
         int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 1, g.getAllEdges().getCount());
     }
@@ -121,7 +134,7 @@ public void testMoreComplexGraph()
     {
         LevelGraph g = initShortcutsGraph(createGraph());
         int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 10, g.getAllEdges().getCount());
     }
@@ -137,7 +150,7 @@ public void testDirectedGraph()
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
@@ -152,7 +165,7 @@ public void testDirectedGraph2()
         LevelGraph g = createGraph();
         initDirected2(g);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
@@ -185,8 +198,9 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
+        prepare.prepareNodes();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -202,12 +216,11 @@ public void testDirectedGraph3()
 
         // both dirs
         assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isBool(sc1.flags, FlagEncoder.K_FORWARD)
-                && carEncoder.isBool(sc1.flags, FlagEncoder.K_BACKWARD));
+        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
 
         // directed
         assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
-        assertTrue(sc2.toString(), carEncoder.isBool(sc2.flags, FlagEncoder.K_FORWARD));
+        assertTrue(sc2.toString(), carEncoder.isForward(sc2.flags));
 
         assertEquals(sc1.toString(), 4, sc1.weight, 1e-4);
         assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
@@ -271,7 +284,7 @@ public void testRoundaboutUnpacking()
         LevelGraph g = createGraph();
         initRoundaboutGraph(g);
         int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 22, g.getAllEdges().getCount());
         RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
@@ -290,12 +303,8 @@ public void testFindShortcuts_Roundabout()
         EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
         EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
         g.edge(8, 4, 1, false);
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
@@ -311,6 +320,12 @@ public void testFindShortcuts_Roundabout()
         tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
 
         prepare.initFromGraph();
+        prepare.prepareNodes();
+        g.setLevel(3, 3);
+        g.setLevel(5, 5);
+        g.setLevel(7, 7);
+        g.setLevel(8, 8);
+
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
@@ -366,7 +381,7 @@ public void testUnpackingOrder()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
         initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
@@ -380,7 +395,7 @@ public void testUnpackingOrder_Fastest()
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
@@ -398,7 +413,7 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -422,7 +437,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 5485a7a5bd..30475dd3f9 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -190,7 +190,7 @@ public void testTramStations()
         way.setTag("railway", "station");
         way.setTag("bicycle", "yes");
         // allow stations if explicitely tagged
-        assertNotSame(0, encoder.acceptWay(way));
+        assertNotEquals(0, encoder.acceptWay(way));
 
         way = new OSMWay(1);
         way.setTag("highway", "secondary");
@@ -198,6 +198,24 @@ public void testTramStations()
         way.setTag("bicycle", "no");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
+
+        way = new OSMWay(1);
+        way.setTag("railway", "platform");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        way.setTag("bicycle", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(0, flags);
     }
 
     @Test
@@ -287,6 +305,17 @@ public void testHandleCommonWayTags()
         way.setTag("surface", "grass");
         wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("railway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index ebe46f48cc..1e8b6c5acf 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -141,8 +141,71 @@ public void testHandleWayTags()
         way.setTag("tracktype", "grade2");
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("motor_vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        // attention bicycle:backward=no/yes has a completely different meaning!
+        // https://wiki.openstreetmap.org/wiki/Key:access#One-way_restrictions
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("bicycle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));        
+
+        way.setTag("bicycle:backward", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+    }
+    
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
@@ -222,6 +285,32 @@ public void testUnchangedRelationShouldNotInfluencePriority()
         assertPriority(REACH_DEST.getValue(), osmWay, relFlags);
     }
 
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertEquals(1, encoder.acceptWay(way));
+
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+    }
+
     @Test
     public void testCalcPriority()
     {
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index c4d697d037..5581ed84a0 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -51,9 +51,9 @@ public void testAccess()
         // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
-        way.setTag("tracktype", "grade2");        
+        way.setTag("tracktype", "grade2");
         assertTrue(encoder.acceptWay(way) > 0);
-        way.setTag("tracktype", "grade4");        
+        way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
         way.clearTags();
@@ -86,40 +86,74 @@ public void testAccess()
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
         assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+    }
 
-        way.clearTags();
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
         way.setTag("oneway", "yes");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+    }
+
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
     }
 
     @Test
     public void testSetAccess()
     {
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
 
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, false)));
+        assertFalse(encoder.isBackward(encoder.setProperties(0, true, false)));
 
-        assertFalse(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
 
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
+        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
 
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
+        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
 
         long flags = encoder.flagsDefault(true, true);
         // disable access
-        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(encoder.setAccess(flags, false, false)));
+        assertFalse(encoder.isBackward(encoder.setAccess(flags, false, false)));
     }
 
     @Test
@@ -204,25 +238,25 @@ public void testRoundabout()
         long flags = encoder.setAccess(0, true, true);
         long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
         assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
 
         resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
         assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
 
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway");
         flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
         assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
 
         way.setTag("junction", "roundabout");
         flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
         assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
@@ -242,8 +276,8 @@ public void testRailway()
 
         // on disallowed highway, railway is allowed, sometimes incorrectly mapped
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);        
-        
+        assertTrue(encoder.acceptWay(way) > 0);
+
         // this is fully okay as sometimes old rails are on the road
         way.setTag("highway", "primary");
         way.setTag("railway", "historic");
@@ -274,13 +308,13 @@ public void testRailway()
     public void testSwapDir()
     {
         long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
 
         swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
 
-        assertFalse(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
 
         assertEquals(0, encoder.reverseFlags(0));
     }
@@ -435,14 +469,30 @@ public void testFordAccess()
         assertFalse(encoder.acceptWay(way) > 0);
         assertTrue(encoder.handleNodeTags(node) > 0);
 
-        try {
+        try
+        {
             // Now they are passable
             encoder.setBlockFords(false);
             assertTrue(encoder.acceptWay(way) > 0);
             assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally {
+        } finally
+        {
             encoder.setBlockFords(true);
         }
     }
 
+    @Test
+    public void testCombination()
+    {
+        OSMWay way = new OSMWay(123);
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");        
+
+        long flags = em.acceptWay(way);
+        long edgeFlags = em.handleWayTags(way, flags, 0);
+        assertFalse(encoder.isBackward(edgeFlags));
+        assertFalse(encoder.isForward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isForward(edgeFlags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 1b45cb56ac..c6ec097254 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,18 +22,11 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Collection;
-import java.util.Collections;
-
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
-import java.util.*;
 
 /**
  *
@@ -198,7 +191,7 @@ public void testCompatibilityBug()
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
-        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
         long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index ce145c8b57..36478a9343 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -60,12 +60,12 @@ public void testCombined()
         FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
         long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
-        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_FORWARD));
-        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
+        assertTrue(footEncoder.isForward(fl));
+        assertTrue(footEncoder.isBackward(fl));
 
         assertEquals(100, carEncoder.getSpeed(fl), 1e-1);
-        assertTrue(carEncoder.isBool(fl, FlagEncoder.K_FORWARD));
-        assertFalse(carEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(fl));
+        assertFalse(carEncoder.isBackward(fl));
 
         assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)), 1e-1);
     }
@@ -148,6 +148,27 @@ public void testAccess()
         assertFalse(footEncoder.acceptWay(way) > 0);
     }
 
+    @Test
+    public void testRailPlatformIssue366()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("railway", "platform");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+        
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+        
+        way.clearTags();
+        // only tram, no highway => no access
+        way.setTag("railway", "tram");
+        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertEquals(0, flags);
+    }
+
     @Test
     public void testMixSpeedAndSafe()
     {
@@ -171,11 +192,15 @@ public void testPriority()
     {
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "cycleway");
-        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+        assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
 
         way.setTag("highway", "track");
         way.setTag("bicycle", "official");
-        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "designated");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
     }
 
     @Test
@@ -251,4 +276,14 @@ public void testBarrierAccess()
         // barrier!
         assertTrue(footEncoder.handleNodeTags(node) > 0);
     }
+
+    @Test
+    public void handleWayTagsRoundabout()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 81df2aac3c..92f737654c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -27,8 +27,8 @@
  */
 public class MotorcycleFlagEncoderTest
 {
-    private final EncodingManager em = new EncodingManager("CAR,BIKE,FOOT");
-    private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("CAR");
+    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
     @Test
     public void testHandleWayTags()
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index cc4bc85b83..6fcd32a6f8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -19,7 +19,6 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import com.graphhopper.routing.util.PriorityCode;
 import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -89,12 +88,15 @@ public void testSacScale()
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
-        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
         assertTrue(encoder.acceptWay(way) > 0);
 
         way.setTag("sac_scale", "alpine_hiking");
         assertTrue(encoder.acceptWay(way) > 0);
-        
+
         way.setTag("sac_scale", "demanding_alpine_hiking");
         assertTrue(encoder.acceptWay(way) == 0);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 36b2489024..61a2936111 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -28,13 +28,14 @@
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
+
 /**
  *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -197,8 +198,9 @@ public void testRemoveDeadEndUnvisitedNetworks()
         GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
 
@@ -212,7 +214,7 @@ public void testTarjan()
         GraphStorage g = createSubnetworkTestGraph();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getSingle();
+        final FlagEncoder flagEncoder = em.getEncoder("car");
         final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
@@ -220,24 +222,36 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
-        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
-        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            9
+        }), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression() {
+    public void testNodeOrderingRegression()
+    {
         // 1 -> 2 -> 0
         GraphStorage g = createGraph(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
-        
         assertEquals(3, removed);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index b7b00c2ff5..6012124c1a 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -74,9 +74,25 @@ public void testSacScale()
     {
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+        
+        way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
+        
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // but allow this as there is no reason for not allowing it
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        // This looks to be tagging error:
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // we are coutious and disallow this
+        assertEquals(0, encoder.acceptWay(way));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index beba510ca5..b16536a2c3 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -686,7 +686,7 @@ public void testBounds()
     {
         graph = createGraph();
         BBox b = graph.getBounds();
-        assertEquals(BBox.INVERSE.maxLat, b.maxLat, 1e-6);
+        assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 10, 20);
@@ -800,14 +800,14 @@ public void testCreateDuplicateEdges()
         EdgeIteratorState oneIter = graph.getEdgeProps(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
-        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(oneIter.getFlags()));
+        assertFalse(carEncoder.isBackward(oneIter.getFlags()));
 
         oneIter = graph.getEdgeProps(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
-        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(carEncoder.isForward(oneIter.getFlags()));
+        assertTrue(carEncoder.isBackward(oneIter.getFlags()));
 
         graph.edge(3, 2, 14, true);
         assertEquals(4, GHUtility.count(carOutExplorer.setBaseNode(2)));
@@ -1044,8 +1044,8 @@ public void test8BytesFlags()
         assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
         long flags = GHUtility.getEdge(graph, 1, 0).getFlags();
         assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
-        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(list.get(0).isForward(flags));
+        assertTrue(list.get(0).isBackward(flags));
         edge = graph.edge(2, 3);
         edge.setFlags(list.get(1).setProperties(44.123, true, false));
         assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
@@ -1053,8 +1053,8 @@ public void test8BytesFlags()
         flags = GHUtility.getEdge(graph, 3, 2).getFlags();
         assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
         assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
-        assertFalse(list.get(1).isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(list.get(1).isBool(flags, FlagEncoder.K_BACKWARD));
+        assertFalse(list.get(1).isForward(flags));
+        assertTrue(list.get(1).isBackward(flags));
     }
 
     @Test
@@ -1098,13 +1098,13 @@ public void testDetachEdge()
         assertEquals(2, iter.getAdjNode());
         assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
         assertEquals(2, edgeState2.getAdjNode());
-        assertTrue(carEncoder.isBool(edgeState2.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
 
         EdgeIteratorState edgeState3 = iter.detach(true);
         assertEquals(0, edgeState3.getAdjNode());
         assertEquals(2, edgeState3.getBaseNode());
         assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isBool(edgeState3.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
         assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
         assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 1c0900623a..ff4bdbacc0 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -67,16 +67,17 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -88,7 +89,7 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -96,14 +97,17 @@ public void testSave_and_fileFormat() throws IOException
 
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
-        assertEquals(new BBox(10, 20, 10, 12), g.getBounds());
+        assertTrue(na.is3D());
+        assertTrue(g.getBounds().isValid());
+        
+        assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutFilter);
@@ -112,12 +116,12 @@ protected void checkGraph( Graph g )
 
         EdgeIterator iter = explorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(3.5, 4.5, 5, 6), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0), iter.fetchWayGeometry(0));
 
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3), iter.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(10, 10, 1.5, 1, 2, 3), iter.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3, 11, 20), iter.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 10, 0, 1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0, 11, 20, 1), iter.fetchWayGeometry(2));
 
         assertEquals(11, na.getLatitude(1), 1e-2);
         assertEquals(20, na.getLongitude(1), 1e-2);
@@ -131,9 +135,9 @@ protected void checkGraph( Graph g )
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
 
         EdgeIteratorState eib = GHUtility.getEdge(g, 1, 2);
-        assertEquals(Helper.createPointList(), eib.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(11, 20), eib.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(12, 12), eib.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(), eib.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(11, 20, 1), eib.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(12, 12, 0.4), eib.fetchWayGeometry(2));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index f58cd0ed11..e624d5ce83 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -48,19 +48,21 @@ protected GraphStorage newRAMGraph()
         return newGraph(new RAMDirectory(), false);
     }
 
+    @Override
     @Test
-    public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
+    public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -76,7 +78,7 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -90,12 +92,13 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
         assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     @Test
-    public void testEnsureCapacity() throws IOException {
+    public void testEnsureCapacity() throws IOException
+    {
         graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
@@ -106,7 +109,8 @@ public void testEnsureCapacity() throws IOException {
         Random r = new Random();
 
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++)
+        {
             double randomLat = 90 * r.nextDouble();
             double randomLon = 180 * r.nextDouble();
 
@@ -114,15 +118,18 @@ public void testEnsureCapacity() throws IOException {
         }
 
         // Make node 50 the 'center' node
-        for (int nodeId = 51; nodeId < 100; nodeId++) {
+        for (int nodeId = 51; nodeId < 100; nodeId++)
+        {
             graph.edge(50, nodeId, r.nextDouble(), true);
         }
-        for (int nodeId = 0; nodeId < 50; nodeId++) {
+        for (int nodeId = 0; nodeId < 50; nodeId++)
+        {
             graph.edge(nodeId, 50, r.nextDouble(), true);
         }
 
         // add 100 turn cost entries around node 50
-        for (int edgeId = 0; edgeId < 50; edgeId++) {
+        for (int edgeId = 0; edgeId < 50; edgeId++)
+        {
             turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
             turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
         }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index cad468fb81..b7c216b4fb 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,14 +17,15 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -46,7 +47,7 @@ public GraphStorage newGraph( Directory dir, boolean is3D )
     }
 
     @Test
-    public void testCannotBeLoadedViaDifferentClass()
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     {
         GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         g.flush();
@@ -63,12 +64,15 @@ public void testCannotBeLoadedViaDifferentClass()
 
         g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
         assertTrue(g.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(g.getBounds(), BBox.createInverse(false));
     }
 
     @Test
     public void testPriosWhileDeleting()
     {
         LevelGraphStorage g = createGraph();
+        g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
             g.setLevel(i, i);
@@ -77,13 +81,14 @@ public void testPriosWhileDeleting()
         g.optimize();
         assertEquals(9, g.getLevel(9));
         assertNotSame(10, g.getLevel(10));
-        assertEquals(19, g.getNodes());
     }
 
     @Test
     public void testPrios()
     {
         LevelGraph g = createGraph();
+        g.getNodeAccess().ensureNode(30);
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -174,15 +179,15 @@ public void testGetWeight()
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
         assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
 
         flags = carEncoder.setProperties(10, false, true);
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);        
-        assertFalse(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertFalse(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
     }
 
     @Test
@@ -207,4 +212,47 @@ public void testGetWeightIfAdvancedEncoder()
         sc1.setWeight(1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+        
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index cf996add31..e447b1c058 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -74,7 +74,7 @@ public void testSimpleGraph()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 8);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -128,7 +128,7 @@ public void testSimpleGraph2()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 28);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -153,7 +153,7 @@ public void testGrid()
         Graph g = createSampleGraph(new EncodingManager("CAR"));
         int locs = g.getNodes();
 
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
         // if we would use less array entries then some points gets the same key so avoid that for this test
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
@@ -211,7 +211,7 @@ boolean testGridIgnore( int i )
     public void testSinglePoints120()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
 
         assertEquals(1, idx.findID(1.637, 2.23));
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -227,7 +227,7 @@ public void testSinglePoints120()
     public void testSinglePoints32()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -355,7 +355,7 @@ public void testDifferentVehicles()
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
         Graph g = createGraph(encodingManager);
         initSimpleGraph(g);
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
 
         // now make all edges from node 1 accessible for CAR only
@@ -367,7 +367,7 @@ public void testDifferentVehicles()
         }
         idx.close();
 
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 801367d298..bb43cef11b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -33,13 +33,16 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).setResolution(resolution).prepareIndex();
+        if(resolution < 0)
+            resolution = 120;
+        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
+                setResolution(resolution).prepareIndex();
     }
 
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 0b59bcb6c9..0f3c93d92b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -40,15 +40,23 @@
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeSCTest extends LocationIndexTreeTest
+public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
 {
     @Override
-    public LocationIndexTreeSC createIndex( Graph g, int resolution )
+    public LocationIndexTree createIndex( Graph g, int resolution )
+    {
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
+    }
+
+    @Override
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTreeSC idx = new LocationIndexTreeSC((LevelGraph) g, dir);
-        idx.setResolution(1000000).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        tmpIdx.setResolution(resolution);
+        return tmpIdx;
     }
 
     @Override
@@ -99,6 +107,7 @@ public void testLevelGraph()
     public void testSortHighLevelFirst()
     {
         final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
         lg.setLevel(3, 20);
@@ -135,7 +144,7 @@ public void testLevelGraphBug()
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
         EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        EdgeIteratorState iter2 = lg.edge(2, 3, 100, true);
+        lg.edge(2, 3, 100, true);
 
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -147,15 +156,17 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTreeSC index = new LocationIndexTreeSC(lg, new RAMDirectory());
-        index.setResolution(100000);
-        index.prepareIndex();
+        LocationIndexTree index = createIndex(lg, 100000);
+
         // very close to 2, but should match the edge 0--1
         TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
-        expectedSet.add(1);
+        expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
-        assertEquals(0, index.findID(0.51, 0.2));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 8fcb543aad..f4a24cfc41 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -42,14 +42,16 @@
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
-        return internalCreateIndex(g, 500000);
+        if (resolution < 0)
+            resolution = 500000;        
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
-        tmpIDX.setResolution(minMeter).prepareIndex();
+        tmpIDX.setResolution(resolution);
         return tmpIDX;
     }
 
@@ -87,7 +89,7 @@ Graph createTestGraph()
     public void testSnappedPointAndGeometry()
     {
         Graph graph = createTestGraph();
-        LocationIndex index = createIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
@@ -103,8 +105,8 @@ public void testSnappedPointAndGeometry()
     public void testInMemIndex()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 50000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
@@ -144,8 +146,8 @@ public void testInMemIndex()
     public void testInMemIndex2()
     {
         Graph graph = createTestGraph2();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(500).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
         assertEquals(3, inMemIndex.getEntriesOf(0).size());
@@ -181,9 +183,8 @@ public void testInMemIndex2()
     @Test
     public void testInMemIndex3()
     {
-        Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(10000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
@@ -202,8 +203,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = new LocationIndexTree(createTestGraph(), new RAMDirectory());
-        index.setMinResolutionInMeter(200).prepareAlgo();
+        LocationIndexTree index = createIndex(createTestGraph(), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -224,7 +224,7 @@ public void testMoreReal()
         graph.edge(1, 0, 1000, true);
         graph.edge(0, 2, 1000, true);
         graph.edge(0, 3, 1000, true).setWayGeometry(Helper.createPointList(51.21, 9.43));
-        LocationIndex index = internalCreateIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         assertEquals(2, index.findID(51.2, 9.4));
     }
 
@@ -261,7 +261,7 @@ private Graph createTestGraphWithWayGeometry()
     public void testWayGeometry()
     {
         Graph g = createTestGraphWithWayGeometry();
-        LocationIndex index = createIndex(g, 1000);
+        LocationIndex index = createIndex(g, -1);
         assertEquals(1, index.findID(0, 0));
         assertEquals(1, index.findID(0, 0.1));
         assertEquals(1, index.findID(0.1, 0.1));
@@ -289,7 +289,7 @@ public void testFindingWayGeometry()
     public void testEdgeFilter()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = createIndex(graph, 1000);
+        LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
         assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
@@ -402,9 +402,7 @@ Graph createTestGraph2()
     public void testRMin()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMaxRegionSearch(1);
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndex(graph, 50000);
 
         //query: 0.05 | -0.3
         DistanceCalc distCalc = new DistancePlaneProjection();
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index e47b52da9d..f41b24ae4b 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -31,11 +31,15 @@
     @Test
     public void testOrientation()
     {
-        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.001);
-        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.001);
-        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.001);
-        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, 10)), 0.001);
-        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.001);
+        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 0)), 0.01);
+        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 1)), 0.01);
+        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 1)), 0.01);
+        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, 1)), 0.01);
+        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, -1)), 0.01);
+
+        // is symetric?
+        assertEquals(90 - 32.76, Math.toDegrees(ac.calcOrientation(49.942, 11.580, 49.944, 11.582)), 0.01);
+        assertEquals(-90 - 32.76, Math.toDegrees(ac.calcOrientation(49.944, 11.582, 49.942, 11.580)), 0.01);
     }
 
     @Test
@@ -51,19 +55,19 @@ public void testAlignOrientation()
     public void testCombined()
     {
         double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
-        assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+        assertEquals(132.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
 
         orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
-        assertEquals(-149.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+        assertEquals(-136.38, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
     }
 
     @Test
     public void testCalcAzimuth()
     {
-        assertEquals(45.0, ac.calcAzimuth(0, 0, 10, 10), 0.001);
-        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.001);
-        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.001);
-        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.001);
+        assertEquals(45.0, ac.calcAzimuth(0, 0, 1, 1), 0.001);
+        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 1), 0.001);
+        assertEquals(180.0, ac.calcAzimuth(0, 0, -1, 0), 0.001);
+        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -1), 0.001);
         assertEquals(0.0, ac.calcAzimuth(49.942, 11.580, 49.944, 11.580), 0.001);
     }
 
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index d86e375a8f..79b9fc9f95 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -35,8 +35,11 @@
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
@@ -48,12 +51,19 @@
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {                
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -99,17 +109,13 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
                 "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
-        List<String> distStrings = wayList.createDistances(true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"),
-                distStrings);
-
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
@@ -117,9 +123,6 @@ public void testWayList()
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
-        distStrings = wayList.createDistances(false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"),
-                distStrings);
 
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
@@ -136,7 +139,6 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        FlagEncoder carEncoder = carManager.getSingle();
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
@@ -150,7 +152,7 @@ public void testWayList()
                 wayList.createStartPoints());
 
         // special case of identical start and end
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 0);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
         wayList = p.calcInstructions(usTR);
         assertEquals(1, wayList.size());
         assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
@@ -211,7 +213,6 @@ void compare( List<List<Double>> expected, List<List<Double>> was )
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -233,14 +234,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -251,7 +252,6 @@ public void testWayList2()
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -273,7 +273,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -282,7 +282,6 @@ public void testNoInstructionIfSameStreet()
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -301,7 +300,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -344,6 +343,56 @@ public void testInstructionsWithTimeAndPlace()
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
     @Test
     public void testCreateGPXWithEle()
     {
@@ -413,10 +462,9 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {        
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index f65170813b..70d8a5f83a 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -46,7 +46,7 @@ public void testCalcAzimuthAndGetDirection()
         p2.add(49.944, 11.582);
         Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
 
-        assertEquals(45, i2.calcAzimuth(null), .1);
+        assertEquals(32.76, i2.calcAzimuth(null), .1);
         assertEquals("NE", i2.calcDirection(null));
 
         PointList p3 = new PointList();
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index f5314e557f..f517e9c3fd 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -18,6 +18,7 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -87,4 +88,19 @@ public void testAddPL()
             assertEquals(toAdd.getLatitude(i), instance.getLatitude(7 + i), 1e-1);
         }
     }
+
+    @Test
+    public void testIterable()
+    {
+        PointList toAdd = new PointList();
+        toAdd.add(1, 1);
+        toAdd.add(2, 2);
+        toAdd.add(3, 3);
+        int counter = 0;
+        for (GHPoint point : toAdd)
+        {
+            counter++;
+            assertEquals(counter, point.getLat(), 0.1);
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 8103d03698..7bd65b5213 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -41,6 +41,9 @@ public void testToString()
 
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("Пешком", ruMap.tr("web.FOOT"));
+        
+        Translation zhMap = SINGLETON.getWithFallBack(new Locale("vi", "VI"));
+        assertEquals("Đi bộ", zhMap.tr("web.FOOT"));
 
         trMap = SINGLETON.get("de_DE");
         assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
new file mode 100644
index 0000000000..2e455b0867
--- /dev/null
+++ b/docs/android/android-studio-setup.md
@@ -0,0 +1,20 @@
+# Open Demo App with Android Studio
+
+Get the [GraphHopper sources and demo](./index.md) before you proceed.
+
+## Setup
+
+[Download](http://developer.android.com/sdk/index.html) and start android studio
+
+Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
+
+![Open Existing](./images/android-studio-open-existing.png)
+
+Import project from Gradle, but make sure the 'Gradle project' points to graphhopper/android
+
+![Import project from Gradle](./images/android-studio-import-project-from-gradle.png)
+
+## Start Demo
+
+ 1. Connect your device in development mode (USB debugging)
+ 2. Then hit SHIFT+F10 or click Run->Run 'app' in the menu
diff --git a/docs/android/images/android-studio-import-project-from-gradle.png b/docs/android/images/android-studio-import-project-from-gradle.png
new file mode 100644
index 0000000000..2b4aacf171
Binary files /dev/null and b/docs/android/images/android-studio-import-project-from-gradle.png differ
diff --git a/docs/android/images/android-studio-open-existing.png b/docs/android/images/android-studio-open-existing.png
new file mode 100644
index 0000000000..9e5891ef3f
Binary files /dev/null and b/docs/android/images/android-studio-open-existing.png differ
diff --git a/docs/android/index.md b/docs/android/index.md
index ae02db1b3a..db67b378d7 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -1,11 +1,13 @@
-## Get Demo
+# Get Demo
 
 [Download GraphHopper Demo APK](http://graphhopper.com/#download)
 
-## Set-up Development
-As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) which can be used from Eclipse or NetBeans via maven command line.
+# Set-up Development
 
-### Before installation
+As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) 
+which can be used from Android Studio, NetBeans, gradle or maven.
+
+Before the installation fetch the source, the OpenStreetMap data and the dependencies:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git graphhopper
@@ -13,21 +15,29 @@ $ cd graphhopper
 $ ./graphhopper.sh import your-area.pbf
 ```
 
-And go to the Android SDK Manager and install at least 2.3 (API 9)
+## Android Studio
+
+Please read [here](./android-studio-setup.md) for a detailed instruction.
+
+## None-Android Studio
+
+Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and 
+go to the Android SDK Manager and install at least 2.3 (API 9).
 
-**Either via Maven and Command line -> use this for NetBeans**
+### Maven or NetBeans
  1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
  2. Now do `./graphhopper.sh android`
 
-**Or Eclipse**
+### Gradle
 
-Import Sources as Android project. If you want to customize graphhopper itself do:
- 1. `cd graphhopper; ./graphhopper.sh eclipse`
- 2. Refresh your Eclipse project and use it.
-
-See [this](https://lists.openstreetmap.org/pipermail/graphhopper/2013-November/000501.html) for the discussion.
+```bash
+$ cd graphhopper/android
+$ ./gradlew clean build
+# push to device, start manually
+$ gradle installDebug
+```
 
-**Maps**
+## Maps
 
 Now that you have a running android app you need to copy somehow the routing and maps data. 
 
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 32cdbda276..4d55a5c847 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -6,14 +6,6 @@ In GraphHopper CH is enabled by default but can be easily disabled.
 To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
 is necessary which allows to store shortcuts too.
 
-After a graph is prepared it cannot be used for graph exploration anymore, this is
-a limitation of the preparation and storage and is handled in issue #116.
-Due to that limitation a special location index is necessary (LocationIndexTreeSC).
-
-Also at the moment only one vehicle can be used if CH is enabled, see issue #111.
-
-So, if you still need graph exploration for your LevelGraphStorage you can specify 
-graphHopper.doPrepare(false) before you call importOrLoad, which avoids the CH preparation.
-Then do your graph explorations or whatever and store the graph.
-If you call importOrLoad next time without doPrepare(false) the CH-preparation will be done.
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
 
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
new file mode 100644
index 0000000000..eb2093e9a2
--- /dev/null
+++ b/docs/core/eclipse-setup.md
@@ -0,0 +1,153 @@
+Getting started with GraphHopper in Eclipse
+=========
+This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
+Instructions for Android branch will be provided in future.
+
+The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. Setting up Apache Tomcat server and configuring it to run GraphHopper will be covered in subsequent documents.
+
+###1. Download Eclipse
+
+The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
+
+**Note:** Make sure you grab the correct 32-bit or 64-bit version, depending on your machine and the version of the java installed in your computer. If for example you have a 32 bit java in your x64 machine, you still need to download a 32 bit version of eclipse or you may get an error while trying to open the eclipse.exe file.
+
+**Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
+
+
+###2.	Eclipse Addition al Plugins
+Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
+
+*	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
+*	The Eclipse Maven plugin, [m2eclipse](http://www.eclipse.org/m2e/) which adds Maven support to Eclipse, for editing project models and (automatically) running builds
+*	If you want to work on the web interfaces you also need [Web Tools Platform (WTP)](http://www.eclipse.org/webtools/)
+
+**Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
+
+###3.	Configuring Eclipse with additional plugins
+Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
+
+####3.1. Using Eclipse Marketplace
+The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
+
+You should take the below steps to install your needed components:
+
+* In Eclipse, under _help_ menu, choose _Eclipse Marketplace_. 
+
+* In the opened window, search all _markets/all categories_ and in the _find_ dialoge box type the name of the needed component and click on _Go_ button:
+
+ * Search for “egit” if you need “EGIT” and “EGit – Git Team Provider” should be among first items to appear.
+ 
+ * Search for “maven” or “m2eclipse” if you need “m2eclipse” and “m2eclipse – "Maven Integration for Eclipse” should be among first items to appear. 
+   
+ * Search for “wtp” if you need “m2e-wtp” and “m2eclipse – "Maven Integration for Eclipse WTP” should be among first items to appear. 
+
+*   Click on _Install_ button. Please note if the component is already installed then there are two other buttons available instead of _Install_. _Update_ if there is an update for the component and _Uninstall_. For example in picture below the user has tried to install EGit using market place, while it has already been included in the package. 
+
+![](./images/egit.png)
+
+*	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
+
+
+####3.2. Using “Install New Software…” Option
+Alternatively, you can use the “Install New Software” option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try “Install New Software Option” instead of the “Marketplace”. 
+
+Based on needed components take the below steps:
+ 
+*	To install “EGit” in the "Work with:" dialog box, type the EGit server address  at http://download.eclipse.org/egit/updates. Select Eclipse Git Team Provider and JGit form option and click _Next_ and _Finish_ install.
+ 
+![](./images/egit2.png)  
+
+*	To install “m2e” In the "Work with:" dialog box, type the me2eclipse server address at http://download.eclipse.org/technology/m2e/releases. Select Maven Integration for Eclipse form option and click _Next_ and _Finish_ install. 
+
+![](./images/maven.png) 
+
+*	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
+
+
+###4.	Clone and import the GraphHopper Source
+At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
+
+1. EGit Repositories View from within Eclipse
+
+2. Command-line Git tools. Once they are cloned into the local filesystem, the Maven projects in the GraphHopper Git repository can then be imported into Eclipse. 
+
+3. The clone and import operations can be done together using _File -> Import -> Maven -> Import Maven projects from SCM in Eclipse_.
+ 
+**Note:** When the initial clone operation is not done using the clone button in the EGit Repositories View (For example if it is done using command-line Git or "Import Maven projects from SCM"), you  need to inform Eclipse that your project is under Git version control if you want to do pull / push / commit operations from within Eclipse. In any case you can just perform these operations using command-line Git tools.
+
+**Note:**  It is suggested that repositories should be cloned somewhere outside your Eclipse workspace to avoid any misinterpretation or misuse of Git metadata by Eclipse and vice-versa. 
+
+Below we talk more about the first and third approaches of cloning.
+
+
+####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+
+* Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
+If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
+
+![](./images/clone1.png)
+
+The "Repository Exploring perspective" is preconfigured to contain the Git Repositories view. Alternatively, you can add the Git Repositories view to your main Java perspective: _Window -> Show View -> Other -> Git Repositories_. 
+
+* In the Git Repositories view, click on the "Clone a Git Repository and add clone to this view" button as shown below:
+
+![](./images/clone2.png)
+
+* Enter https://github.com/graphhopper/graphhopper/ for the URI, select "HTTPS" for the protocol. Entering the GitHub username and password is not necessary for cloning the repository. However, if you want to contribute edits back, you'll need to enter your GitHub username and password here too.
+
+![](./images/clone3.png)
+
+* Click _Next_, then select all branches (the “master” branch is probably what need).
+
+* Click _Next_, then select the directory where you want the code to be checked out to. Then click _Finish_. It will take Eclipse a minute or two to download the source to your computer, and then the GraphHopper repository should appear in the "Git Repositories" panel. 
+
+**Note:** An alternate and easy way to this approach is to manually download the GraphHopper zip file directly from GitHub and save it in a local drive in your machine.
+
+**Note:** You still need to import the GraphHopper Maven projects from the local clone of the repository into Eclipse (see Importing existing GraphHopper Maven projects into Eclipse part).
+
+
+
+####4.2. Importing existing GraphHopper Maven projects into Eclipse
+
+If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
+
+* Choose the menu option _File -> Import, and then browse to the Maven / Existing Maven Projects element_.
+
+![](./images/import1.png)
+
+* Browse to the local directory where you cloned the GraphHopper Git repository, and then select all the projects of interest.
+
+![](./images/import2.png)
+
+* Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
+
+####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+To use this method follow the below steps:
+* In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
+
+![](./images/clone4.png)
+
+* Click _Next_, then confirm that you are using the Git version control sytstem using the dropdown box next to the label "SCM URL". 
+
+**Note:** The first time you use this option, this "git" option will probably not be available because an m2e/git connector must be installed. Use the blue "m2e marketplace" link in the lower right corner of this dialog box to find and install the m2e Maven SCM handler for Egit,  and the 'git' option should become available in the drop-down box.
+
+* specify the "Target Location" (in this case, the URL of the remote Github repository that you want to clone locally), as shown in below figure. This URL should be https://github.com/graphhopper/graphhopper/
+
+![](./images/clone5.png)
+
+* Click _Next_, then uncheck "Use default workspace location" and specify a directory outside your Eclipse workspace (e.g. ~/git). Your cloned copy of the repository will be placed in a subdirectory of the specified directory, with a rather uninformative name (e.g. ~/git/ maven.1424033308371).
+
+* Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
+
+####4.4 Making Eclipse aware of your local GraphHopper Git repository
+
+If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
+
+*	Right-click the top-level GraphHopper project in the Project Explorer view and choose _Team -> Share Project_.
+
+*	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
+
+Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
+
+
+
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/images/clone1.png b/docs/core/images/clone1.png
new file mode 100644
index 0000000000..b05ec6fc9f
Binary files /dev/null and b/docs/core/images/clone1.png differ
diff --git a/docs/core/images/clone2.png b/docs/core/images/clone2.png
new file mode 100644
index 0000000000..7a8297f4a1
Binary files /dev/null and b/docs/core/images/clone2.png differ
diff --git a/docs/core/images/clone3.png b/docs/core/images/clone3.png
new file mode 100644
index 0000000000..d5a76bfe93
Binary files /dev/null and b/docs/core/images/clone3.png differ
diff --git a/docs/core/images/clone4.png b/docs/core/images/clone4.png
new file mode 100644
index 0000000000..b89d2a0ee3
Binary files /dev/null and b/docs/core/images/clone4.png differ
diff --git a/docs/core/images/clone5.png b/docs/core/images/clone5.png
new file mode 100644
index 0000000000..abef84335e
Binary files /dev/null and b/docs/core/images/clone5.png differ
diff --git a/docs/core/images/egit.png b/docs/core/images/egit.png
new file mode 100644
index 0000000000..b7b9ab7a61
Binary files /dev/null and b/docs/core/images/egit.png differ
diff --git a/docs/core/images/egit2.png b/docs/core/images/egit2.png
new file mode 100644
index 0000000000..1fad659389
Binary files /dev/null and b/docs/core/images/egit2.png differ
diff --git a/docs/core/images/import1.png b/docs/core/images/import1.png
new file mode 100644
index 0000000000..76c746f7ba
Binary files /dev/null and b/docs/core/images/import1.png differ
diff --git a/docs/core/images/import2.png b/docs/core/images/import2.png
new file mode 100644
index 0000000000..a384664bb6
Binary files /dev/null and b/docs/core/images/import2.png differ
diff --git a/docs/core/images/maven.png b/docs/core/images/maven.png
new file mode 100644
index 0000000000..2177c5296f
Binary files /dev/null and b/docs/core/images/maven.png differ
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index 9fa25b7c7a..69a18b839a 100644
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -12,19 +12,12 @@ QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
 EdgeIteratorState edge = qr.getClosestEdge();
 ```
 
-If you don't use the GraphHopper class you have to handle every case on your own to build a location index.
-E.g. if it is a LevelGraph you need LocationIndexTreeSC otherwise LocationIndexTree:
+If you don't use the GraphHopper class you have to use the low level API:
 
 ```java
-LocationIndexTree tmpIndex;
-if (graph instanceof LevelGraph)
-   tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-else
-   tmpIndex = new LocationIndexTree(graph, dir);
-
-tmpIndex.setResolution(preciseIndexResolution);
-tmpIndex.setSearchRegion(searchRegion);
-// now build the index if it cannot be loaded
-if (!tmpIndex.loadExisting())
-   tmpIndex.prepareIndex();
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
 ```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index b552261124..a054535cc8 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -40,7 +40,7 @@ graph.flush();
 ...
 GraphStorage graph = gb.load();
 // Load index
-LocationIndex index = new LocationIndexTree(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location index cannot be loaded!");
 ```
@@ -50,7 +50,9 @@ if (!index.loadExisting())
 ```java
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
 QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
-Path path = new Dijkstra(graph, encoder).calcPath(fromQR, toQR);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
 ```
 
 ### Calculate Path without LocationIndex
@@ -69,13 +71,14 @@ GraphBuilder gb = new GraphBuilder(em).
     setStore(true).
     setLevelGraph(true);
 GraphStorage graph = gb.create();
-// Make a weighted edge between two nodes.
+// Create a new edge between two nodes, set access, distance, speed, geometry, ..
 EdgeIteratorState edge = graph.edge(fromId, toId);
 ...
 
 // Prepare the graph for fast querying ...
-PrepareContractionHierarchies pch = new PrepareContractionHierarchies();
-pch.setGraph(graph).doWork();
+TraversalMode tMode = TraversalMode.NODE_BASED;
+PrepareContractionHierarchies pch = new PrepareContractionHierarchies(graph, encoder, weighting, tMode);
+pch.doWork();
 
 // flush after preparation!
 graph.flush();
@@ -84,15 +87,20 @@ graph.flush();
 GraphStorage graph = gb.load();
 
  // Load index
-Location2IDIndex index = new LocationIndexTreeSC(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location2id index cannot be loaded!");
 
-// create the algorithm using the PrepareContractionHierarchies object
-RoutingAlgorithm algorithm = pch.createAlgo();
-
 // calculate path is identical
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
 QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
-Path path = new Dijkstra(graph, encoder).calcPath(fromQR, toQR);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+
+// create the algorithm using the PrepareContractionHierarchies object
+AlgorithmOptions algoOpts = AlgorithmOptions.start().
+   algorithm(AlgorithmOptions.DIJKSTRA_BI).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+   build();
+RoutingAlgorithm algorithm = pch.createAlgo(queryGraph, algoOpts);
+Path path = algorithm.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
 ```
\ No newline at end of file
diff --git a/docs/core/routing.md b/docs/core/routing.md
index dcdaf693c1..ae1fd60d9d 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -46,9 +46,12 @@ List<String> iList = il.createDescription(tr);
 List<GPXEntry> list = il.createGPXList();
 ```
 
-If you want a more flexible routing (but slower) you can disable contraction hierarchies
-and import multiple vehicles. Then pick one vehicle and optionally the algorithm like
-astar as algorithm:
+The default is to use the speed-up mode for one profile. If you need multiple profiles you 
+specify a list of profiles (e.g. car,bike) and the speed-up mode is applied to the first profile only (e.g. car).
+The other vehicles then use a more flexible routing.
+
+You can also completely disable the speed-up mode to make all vehicles using the flexibility mode.
+Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as algorithm:
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
@@ -60,14 +63,20 @@ hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
 GHResponse res = hopper.route(req);
 ```
 
-In case you need the online routing API in a Java or Android application the GraphHopperWeb comes handy - see the 'web' sub module.
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module.
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
 gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
 GHResponse rsp = gh.route(new GHRequest(...));
 ```
\ No newline at end of file
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 5cc0ea1372..4b45a58200 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -54,14 +54,12 @@ For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teachi
  we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
  shortcuts and get the edges recursivly, this is done in Path4CH.
 
-## 3.1 OriginalGraph
-
-See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
+## 3.1 Base Graph
 
 In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
-is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
-_LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
-or similar. See #116 for more information.
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
+_LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
+or similar. See issue #116 for more information.
 
 
 ### 4. Connecting the Real World to the Graph
diff --git a/docs/core/translations.md b/docs/core/translations.md
index 30b9265a18..4f7d6eb502 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -3,7 +3,11 @@
 You can help improve GraphHopper by adding your language!
 
 See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
-and add a column for your language. Revisit it regularly to update or add new items.
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
 
 ## Questions
 
@@ -33,4 +37,4 @@ want to try your changes or want to speed up the integration you can do the foll
 
 ## License Agreement
 
-Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
\ No newline at end of file
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/index.md b/docs/index.md
index a170ce92c4..5d6268d75c 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,17 +1,40 @@
-Users
----------------
+# Users
+
+ * [Quickstart](./web/quickstart.md) for users
  * [Read Overview](http://graphhopper.com/#overview)
  * [Add GraphHopper Maps to your Browser](./web/open-search.md)
- * [GraphHopper on Twitter](https://twitter.com/graphhopp)
- * [Quickstart](./web/quickstart.md) for users
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper)
+
+# Translators
+
+* [Translations](./core/translations.md)
+
+
+# Developers
+
+ * [Quickstart](./core/quickstart-from-source.md) for developers. Explains git checkout, IDE setup and commands for setting up a graphhopper server.
+ * [Android](./android/index.md)
+ * [Windows](./core/windows-setup.md)
+ * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md)
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/)
+
+## Core
+
+ * [Simple routing](./core/routing.md) to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md)
+ * [Elevation](./core/elevation.md)
+ * [Technical overview](./core/technical.md)
+ * [Slides from 2014](http://graphhopper.com/public/slides/)
+ * [Contraction Hierarchies](./core/ch.md)
+
+## Web
 
-Developers
---------------- 
- * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
-   * [Android](./android/index.md)
-   * [Windows](./core/windows-setup.md)
- * [Translations](./core/translations.md)
- * [Slides from FOSDEM 2014](http://graphhopper.com/public/slides/)
- * [World-Wide-Road-Network](./core/world-wide.md)
- * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
+ * [Routing API](./web/api-doc.md) Documentation of the Web API to communicate with any graphhopper server via http.
+ 
+## Advanced Topics
 
+ * [Low level API](./core/low-level-api.md) Use Graphhopper as a Java library.
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md) to create new routing profiles to influence which ways to favor and how the track-time is calculated.
+ * [LocationIndex](./core/location-index.md) to get the location index to get i.e. the nearest edge.
+ * [World-Wide-Road-Network](./core/world-wide.md) Details about using the whole world wide street data.
+ * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt) Latest changes.
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..f8a190dc4e 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -1,7 +1,7 @@
 ## Routing Web API Docs
 
 In order to communicate with your or [our](http://graphhopper.com/#enterprise) hosted GraphHopper 
-server you need to understand how to use it.
+server you need to understand how to use it. There is a separate [JavaScript](https://github.com/graphhopper/directions-api-js-client) and [Java](https://github.com/graphhopper/directions-api-java-client) client for this API or use the plain JSON response for your language.
 
 ### A simple example
 [http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959](http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959)
@@ -28,7 +28,28 @@ type               | json    | Specifies the resulting format of the route, for
 
 ## Example output for the case type=json
 
-Keep in mind that some attributes which are not documented here can be removed in the future - you should not rely on them!
+Keep in mind that some attributes which are not documented here can be removed in the future - 
+you should not rely on them! The JSON result contains the following structure:
+
+JSON path/attribute        | Description
+:--------------------------|:------------
+info.took                  | How many ms the request took on the server, of course without network latency taken into account.
+paths                      | An array of possible paths
+paths[0].distance          | The overall distance of the route, in meter
+paths[0].time              | The overall time of the route, in ms
+paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
+paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
+paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
+paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
+paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
+paths[0].instructions[0].distance             | The distance for this instruction, in meter
+paths[0].instructions[0].time                 | The duration for this instruction, in ms
+paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
+paths[0].instructions[0].annotation_text      | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
+paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
 
 ```json
 {
@@ -100,30 +121,9 @@ Keep in mind that some attributes which are not documented here can be removed i
 }
 ```
 
-The JSON result contains the following structure:
-
-JSON path/attribute        | Description
-:--------------------------|:------------
-info.took                  | How many ms the request took on the server, of course without network latency taken into account.
-paths                      | An array of possible paths
-paths[0].distance          | The overall distance of the route, in meter
-paths[0].time              | The overall time of the route, in ms
-paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
-paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
-paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
-paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
-paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
-paths[0].instructions[0].distance             | The distance for this instruction, in meter
-paths[0].instructions[0].time                 | The duration for this instruction, in ms
-paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
-paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
-paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
-
-
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -171,6 +171,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/graphhopper.sh b/graphhopper.sh
index b3e9393e4c..04aa03f6f2 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -3,13 +3,13 @@
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
+if [ "$JAVA_HOME" = "" ]; then
  JAVA=java
 fi
 
 vers=$($JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \")
 bit64=$($JAVA -version 2>&1 | grep "64-Bit")
-if [ "x$bit64" != "x" ]; then
+if [ "$bit64" != "" ]; then
   vers="$vers (64bit)"
 fi
 echo "## using java $vers from $JAVA_HOME"
@@ -22,13 +22,29 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
-if [ "x$ACTION" = "x" ]; then
- echo -e "## action $ACTION not found. try \n$USAGE"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
+if [ "$ACTION" = "" ]; then
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
-  if [ "x$OSM_FILE" = "x" ]; then
+  if [ "$OSM_FILE" = "" ]; then
     # skip
     return
   elif [ ! -s "$OSM_FILE" ]; then
@@ -61,17 +77,17 @@ function ensureOsmXml {
 
 function ensureMaven {
   # maven home existent?
-  if [ "x$MAVEN_HOME" = "x" ]; then
+  if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
     MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
-    if [ "x$MAVEN_HOME" = "x" ]; then
+    if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
         echo "No Maven found in the PATH. Now downloading+installing it to $MAVEN_HOME"
         cd "$GH_HOME"
         MVN_PACKAGE=apache-maven-3.2.5
-        wget -O maven.zip http://www.eu.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
+        wget -O maven.zip http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
         unzip maven.zip
         mv $MVN_PACKAGE maven
         rm maven.zip
@@ -111,45 +127,46 @@ function packageCoreJar {
 function prepareEclipse {
  ensureMaven   
  packageCoreJar
- cp core/target/graphhopper-*-android.jar android/libs/   
+ # cp core/target/graphhopper-*-android.jar android/libs/   
 }
 
 
 ## now handle actions which do not take an OSM file
-if [ "x$ACTION" = "xclean" ]; then
+if [ "$ACTION" = "clean" ]; then
  rm -rf ./*/target
  exit
 
-elif [ "x$ACTION" = "xeclipse" ]; then
+elif [ "$ACTION" = "eclipse" ]; then
  prepareEclipse
  exit
 
-elif [ "x$ACTION" = "xbuild" ]; then
+elif [ "$ACTION" = "build" ]; then
  prepareEclipse
  exit  
  
-elif [ "x$ACTION" = "xextract" ]; then
+elif [ "$ACTION" = "extract" ]; then
  echo use "./graphhopper.sh extract \"left,bottom,right,top\""
  URL="http://overpass-api.de/api/map?bbox=$2"
  #echo "$URL"
  wget -O extract.osm "$URL"
  exit
  
-elif [ "x$ACTION" = "xandroid" ]; then
+elif [ "$ACTION" = "android" ]; then
  prepareEclipse
  "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
  exit
 fi
 
-if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+if [ "$FILE" = "" ]; then
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
 # NAME = file without extension if any
 NAME="${FILE%.*}"
 
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    OSM_FILE=
 elif [ ${FILE: -4} == ".osm" ]; then
    OSM_FILE="$FILE"
@@ -175,7 +192,7 @@ VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<'
 JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
 LINK=$(echo $NAME | tr '_' '/')
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
@@ -188,7 +205,7 @@ else
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
-if [ "x$JAVA_OPTS" = "x" ]; then
+if [ "$JAVA_OPTS" = "" ]; then
   JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
@@ -199,9 +216,9 @@ packageCoreJar
 
 echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
-if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
+if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "x$JETTY_PORT" = "x" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then  
     JETTY_PORT=8989
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
@@ -217,7 +234,7 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
 
   RC_BASE=./web/src/main/webapp
 
-  if [ "x$GH_FOREGROUND" = "x" ]; then
+  if [ "$GH_FOREGROUND" = "" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
 	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
@@ -226,41 +243,34 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
     	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
-    if [ "x$GH_PID_FILE" != "x" ]; then
+    if [ "$GH_PID_FILE" != "" ]; then
        echo $! > $GH_PID_FILE
     fi
     exit $?                    
   fi
 
-elif [ "x$ACTION" = "ximport" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
-      config=$CONFIG \
+elif [ "$ACTION" = "import" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS config=$CONFIG \
       $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtest" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true config=$CONFIG \
- 	osmreader.wayPointMaxDistance=0 graph.location="$GRAPH" osmreader.osm="$OSM_FILE" prepare.chWeighting=false \
-	graph.testIT=true
-
-
-elif [ "x$ACTION" = "xtorture" ]; then
+elif [ "$ACTION" = "torture" ]; then
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "x$ACTION" = "xminiui" ]; then
- "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/tools/pom.xml" -DskipTests clean install assembly:single
+elif [ "$ACTION" = "xminiui" ]; then
+ "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
- "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" config=$CONFIG \
               graph.location="$GRAPH"
 
 
-elif [ "x$ACTION" = "xmeasurement" ]; then
+elif [ "$ACTION" = "measurement" ]; then
  ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
- # graph.doSort=true"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false
+ # avoid islands for measurement at all costs
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false prepare.minNetworkSize=10000 prepare.minOnewayNetworkSize=10000
  END=$(date +%s)
  IMPORT_TIME=$(($END - $START))
 
@@ -276,9 +286,9 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
  # use all <last_commits> versions starting from HEAD
  last_commits=$3
   
- if [ "x$last_commits" = "x" ]; then
+ if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    exit
  fi
@@ -291,7 +301,7 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
diff --git a/pom.xml b/pom.xml
index 5042897e07..0837ca65c5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>pom</packaging> 
     <url>http://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.7</slf4j.version>
+        <slf4j.version>1.7.10</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -57,6 +57,11 @@
             <name>Peter Karich</name>
             <email>my.name@graphhopper.com</email>
         </developer>
+        <developer>
+            <id>jansoe</id>
+            <name>Jan Sölter</name>
+            <email>my.name@graphhopper.com</email>
+        </developer>
     </developers>
     
     <mailingLists>
@@ -86,11 +91,13 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
+                <version>3.2</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
+                    
+                    <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                     <source>1.6</source>
@@ -102,7 +109,7 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -111,7 +118,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -130,13 +137,27 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.10</version>
+                <version>2.10.1</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
-                <version>2.3</version>
+                <version>2.4</version>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>
+                <version>2.5.3</version>                    
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <version>2.5</version>
+            </plugin>
+            <plugin>
+                <artifactId>maven-war-plugin</artifactId>
+                <version>2.6</version>                
+            </plugin>            
         </plugins>
     </build>    
     
@@ -144,7 +165,7 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.11</version>
+            <version>4.12</version>
             <scope>test</scope>
         </dependency>        
     </dependencies>
@@ -185,7 +206,7 @@
                 <activeByDefault>false</activeByDefault>
             </activation>
             <modules>
-                <module>android</module>
+                <module>android/app</module>
             </modules>
         </profile>
     </profiles>
diff --git a/tools/pom.xml b/tools/pom.xml
index 44f0ebd1ed..35aeb6f029 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -41,15 +41,14 @@
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
-            <version>1.8.1</version>
+            <version>1.9</version>
         </dependency>
     </dependencies>
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4.1</version>
+                <artifactId>maven-assembly-plugin</artifactId>                
                 <configuration>
                     <archive>
                         <manifest>
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index c9b5a98195..1627869017 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -1,7 +1,6 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.RoutingAlgorithmSpecialAreaTests;
 import com.graphhopper.util.CmdArgs;
 
 /**
@@ -14,12 +13,6 @@ public static void main( String[] strs ) throws Exception
         CmdArgs args = CmdArgs.read(strs);
         GraphHopper hopper = new GraphHopper().init(args);
         hopper.importOrLoad();
-        if (args.getBool("graph.testIT", false))
-        {
-            // important: use osmreader.wayPointMaxDistance=0
-            RoutingAlgorithmSpecialAreaTests tests = new RoutingAlgorithmSpecialAreaTests(hopper);
-            tests.start();
-        }
         hopper.close();
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 3be2bd3e4b..48fd784f85 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -108,7 +108,7 @@ void start( CmdArgs args )
         int count = args.getInt("measurement.count", 5000);
 
         MeasureHopper hopper = new MeasureHopper();
-        hopper.forDesktop().setEnableInstructions(false);
+        hopper.forDesktop();
         if (!hopper.load(graphLocation))
             throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
 
@@ -121,20 +121,21 @@ void start( CmdArgs args )
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
+            printGraphDetails(g, vehicleStr);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
             hopper.setCHEnable(false);
-            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr);
+            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
             hopper.setCHEnable(true);
             hopper.doPostProcessing();
-            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr);
+            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
+            printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
         } catch (Exception ex)
         {
@@ -160,13 +161,13 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private void printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
@@ -194,7 +195,8 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix, final String vehicle )
+    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
+            final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
@@ -224,28 +226,32 @@ public int doCalc( boolean warmup, int run )
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
                         setWeighting("fastest").
                         setVehicle(vehicle);
+                req.getHints().put("instructions", withInstructions);
                 GHResponse res;
                 try
                 {
                     res = hopper.route(req);
                 } catch (Exception ex)
                 {
+                    // 'not found' can happen if import creates more than one subnetwork
                     throw new RuntimeException("Error while calculating route! "
                             + "nodes:" + from + " -> " + to + ", request:" + req, ex);
                 }
 
                 if (res.hasErrors())
-                    throw new IllegalStateException("errors should NOT happen in Measurement! " + res.getErrors());
+                {
+                    if (!warmup)
+                        failedCount.incrementAndGet();
+
+                    if (!res.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                        logger.error("errors should NOT happen in Measurement! " + req + " => " + res.getErrors());
+
+                    return 0;
+                }
 
                 if (!warmup)
                 {
                     long dist = (long) res.getDistance();
-                    if (dist < 1)
-                    {
-                        failedCount.incrementAndGet();
-                        return 0;
-                    }
-
                     distSum.addAndGet(dist);
 
                     airDistSum.addAndGet((long) distCalc.calcDist(fromLat, fromLon, toLat, toLon));
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index e15a43fc5a..b5f0a20353 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -25,12 +25,12 @@
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.zip.GZIPInputStream;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -59,6 +59,7 @@ public static void main( String[] args )
     private int readQueries;
     private int maxQueries;
     private int timeout;
+    private int statusUpdateCnt;
 
     public QueryTorture()
     {
@@ -71,6 +72,7 @@ public void start( CmdArgs read )
         baseUrl = read.get("baseurl", "");
         maxQueries = read.getInt("maxqueries", 1000);
         timeout = read.getInt("timeout", 3000);
+        statusUpdateCnt = maxQueries / 10;
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
@@ -173,12 +175,17 @@ void execute( int workerNo ) throws InterruptedException
         Query query = queryQueue.take();
         try
         {
-            String url = baseUrl + query.queryString;
+            String url = baseUrl + query.createQueryString();
             String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
                 successfullQueries.incrementAndGet();
+
+            if (successfullQueries.get() % statusUpdateCnt == 0)
+            {
+                logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
+            }
         } catch (IOException ex)
         {
             // logger.error("Error while querying " + query.queryString, ex);
@@ -196,14 +203,18 @@ public void run()
             {
                 try
                 {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), Helper.UTF_CS));
+                    InputStream is;
+                    if (logFile.endsWith(".gz"))
+                        is = new GZIPInputStream(new FileInputStream(logFile));
+                    else
+                        is = new FileInputStream(logFile);
+
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, Helper.UTF_CS));
                     try
                     {
-                        int logLineNo = 0;
                         String logLine;
                         while ((logLine = reader.readLine()) != null)
                         {
-                            logLineNo++;
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
@@ -234,7 +245,8 @@ public void run()
                 {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
-                    service.shutdownNow();
+                    if (service != null)
+                        service.shutdownNow();
                 }
             }
         }.start();
@@ -242,9 +254,10 @@ public void run()
 
     static class Query
     {
-        String queryString;
         GHPoint start;
         GHPoint end;
+        List<String> points = new ArrayList<String>();
+        Map<String, String> params = new HashMap<String, String>();
 
         static Query parse( String logLine )
         {
@@ -259,25 +272,32 @@ static Query parse( String logLine )
                 return null;
 
             Query q = new Query();
-            q.queryString = logLine.substring(0, index);
-
-            for (String param : q.queryString.split("\\&"))
+            String queryString = logLine.substring(0, index);
+            String[] tmpStrings = queryString.split("\\&");
+            for (String paramStr : tmpStrings)
             {
-                if (!param.startsWith("point="))
+                int equalIndex = paramStr.indexOf("=");
+                if (equalIndex <= 0)
                     continue;
 
-                param = param.replace("%2C", ",");
-                GHPoint point = GHPoint.parse(param.substring(6));
+                String key = paramStr.substring(0, equalIndex);
+                String value = paramStr.substring(equalIndex + 1);
+                if (!paramStr.startsWith("point="))
+                {
+                    q.params.put(key, value);
+                    continue;
+                }
+
+                value = value.replace("%2C", ",");
+                GHPoint point = GHPoint.parse(value);
                 if (point == null)
                     continue;
 
+                q.points.add(value);
                 if (q.start == null)
                     q.start = point;
                 else if (q.end == null)
-                {
                     q.end = point;
-                    break;
-                }
             }
             if (q.start != null && q.end != null)
                 return q;
@@ -285,31 +305,47 @@ else if (q.end == null)
             return null;
         }
 
-        @Override
-        public int hashCode()
+        public void put( String key, String value )
         {
-            int hash = 5;
-            hash = 47 * hash + (this.queryString != null ? this.queryString.hashCode() : 0);
-            return hash;
+            params.put(key, value);
         }
 
-        @Override
-        public boolean equals( Object obj )
+        public String createQueryString()
         {
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            final Query other = (Query) obj;
-            if ((this.queryString == null) ? (other.queryString != null) : !this.queryString.equals(other.queryString))
-                return false;
-            return true;
+            String qStr = "";
+            for (String pointStr : points)
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += "point=" + pointStr;
+            }
+            for (Entry<String, String> e : params.entrySet())
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += e.getKey() + "=" + encodeURL(e.getValue());
+            }
+
+            return qStr;
+        }
+
+        static String encodeURL( String str )
+        {
+            try
+            {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore)
+            {
+                return str;
+            }
         }
 
         @Override
         public String toString()
         {
-            return queryString;
+            return createQueryString();
         }
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 6d8038ee2c..0049944ee0 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -76,7 +76,7 @@ public MiniGraphUI( GraphHopper hopper, boolean debug )
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
         algoFactory = hopper.getAlgorithmFactory();
-        encoder = hopper.getEncodingManager().getSingle();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
         algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index 708bb57c52..fa5d018259 100644
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -31,7 +31,7 @@
     public void testGetQuery()
     {
         Query result = Query.parse("2013-08-07 18:06:50,905 [qtp1329318374-81] INFO  graphhopper.http.GraphHopperServlet - point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp 46.4.67.134 en_US Wget/1.13.4 (linux-gnu) 51.076329, 13.738409->52.517037, 13.38886, distance: 189.4806800000001, time:123min, points:907, took:0.007393159, debug - idLookup:0.002483692s, algoInit:1.20837E-4s, dijkstraCH-routing:0.003138361s, extract time:1.66755E-4, simplify (1219->907):0.001040086s, instructions:2.26986E-4s, dijkstrabi, fastest, CAR");
-        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.queryString);
+        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.createQueryString());
         assertEquals(51.076329, result.start.lat, 1e-5);
         assertEquals(13.38886, result.end.lon, 1e-5);
     }
diff --git a/web/pom.xml b/web/pom.xml
index e324010ffa..8600391382 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
         
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>8.1.16.v20140903</jetty.version>
@@ -28,8 +28,8 @@
         
         <dependency>
             <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>20140107</version>            
+            <artifactId>json</artifactId>            
+            <version>20140107</version>
         </dependency>    
         
         <dependency>
@@ -94,34 +94,22 @@
             <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
-        <!--
-        <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpclient</artifactId>
-            <version>4.2.5</version>
-            <scope>test</scope>
-        </dependency>
-        -->
+      
     </dependencies>
 
     <build>
         <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.17</version>
-            </plugin>
             <!-- create a jar file too, so others can use it more easily -->
             <plugin>
-                <artifactId>maven-war-plugin</artifactId>
-                <version>2.4</version>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-war-plugin</artifactId>                
                 <configuration>
                     <attachClasses>true</attachClasses>
                 </configuration>
             </plugin>            
             <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4.1</version>
                 <configuration>
                     <archive>
                         <manifest>
@@ -144,52 +132,6 @@
                         </goals>
                     </execution>
                 </executions>
-
-<!--
-                <executions>
-                    <execution>
-                        <id>build-jar</id>
-                        <configuration>
-                            <archive>
-                                <manifest>
-                                    <mainClass>com.graphhopper.http.GHServer</mainClass>
-                                </manifest>
-                            </archive>
-                    
-                            <descriptorRefs>
-                                <descriptorRef>jar-with-dependencies</descriptorRef>
-                            </descriptorRefs>
-                        </configuration>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>single</goal>
-                        </goals>                        
-                    </execution>
-                    <execution>
-                        <id>build-zip</id>
-                        
-                        <configuration>
-                            <appendAssemblyId>false</appendAssemblyId>
-                            <descriptors>
-                                <descriptor>src/main/assembly/zip.xml</descriptor>                                        
-                            </descriptors>                            
-                        </configuration>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>single</goal>
-                        </goals>
-                    </execution>
-                </executions>
-                -->
-                <!--                <executions>
-                    <execution>
-                        <id>make-assembly</id>  this is used for inheritance merges 
-                        <phase>package</phase>  bind to the packaging phase 
-                        <goals>
-                            <goal>single</goal>
-                        </goals>
-                    </execution>
-                </executions>-->
             </plugin>
  
         </plugins>
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index cc14c274f0..e4dd2bc3f1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -24,6 +24,7 @@
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.IOException;
 import java.io.StringWriter;
@@ -72,20 +73,20 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         }
     }
 
-    void writePath( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
     {
-        List<GHPoint> infoPoints = getPoints(req);
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
 
         // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(req, "way_point_max_distance", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean elevation = getBooleanParam(req, "elevation", false);
-        String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-        String weighting = getParam(req, "weighting", "fastest");
-        String algoStr = getParam(req, "algorithm", "");
-        String localeStr = getParam(req, "locale", "en");
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        String vehicleStr = getParam(httpReq, "vehicle", "car");
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
 
         StopWatch sw = new StopWatch().start();
         GHResponse ghRsp;
@@ -100,7 +101,7 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
             GHRequest request = new GHRequest(infoPoints);
 
-            initHints(request, req.getParameterMap());
+            initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
                     setWeighting(weighting).
                     setAlgorithm(algoStr).
@@ -114,8 +115,8 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
         }
 
         float took = sw.stop().getSeconds();
-        String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-        String logStr = req.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
                 + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
         if (ghRsp.hasErrors())
@@ -126,9 +127,9 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
                     + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
-            writeResponse(res, createGPXString(req, res, ghRsp));
+            writeResponse(res, createGPXString(httpReq, res, ghRsp));
         else
-            writeJson(req, res, new JSONObject(createJson(req, ghRsp, took)));
+            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
@@ -199,12 +200,6 @@ String errorsToXML( List<Throwable> list ) throws Exception
                 list.add(map);
             }
             jsonInfo.put("errors", list);
-        } else if (!rsp.isFound())
-        {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put("message", "Not found");
-            map.put("details", "");
-            jsonInfo.put("errors", Collections.singletonList(map));
         } else
         {
             jsonInfo.put("took", Math.round(took * 1000));
@@ -219,7 +214,11 @@ String errorsToXML( List<Throwable> list ) throws Exception
 
                 PointList points = rsp.getPoints();
                 if (points.getSize() >= 2)
-                    jsonPath.put("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
+                {
+                    BBox maxBounds = hopper.getGraph().getBounds();
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
 
                 jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
@@ -245,25 +244,27 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
         return jsonPoints;
     }
 
-    private List<GHPoint> getPoints( HttpServletRequest req ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
     {
-        String[] pointsAsStr = getParams(req, "point");
+        String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
         for (String str : pointsAsStr)
         {
             String[] fromStrs = str.split(",");
             if (fromStrs.length == 2)
             {
-                GHPoint place = GHPoint.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                {
+                    infoPoints.add(point);
+                }
             }
         }
 
         return infoPoints;
     }
 
-    private void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
     {
         WeightingMap m = request.getHints();
         for (Entry<String, String[]> e : parameterMap.entrySet())
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 4730e231aa..0e9b5e951d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -28,28 +28,19 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Main wrapper of the offline API for a simple and efficient usage.
+ * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
  * <p/>
  * @author Peter Karich
  */
 public class GraphHopperWeb implements GraphHopperAPI
 {
-    public static void main( String[] args )
-    {
-        GraphHopperAPI gh = new GraphHopperWeb();
-        gh.load("http://localhost:8989/route");
-        //GHResponse ph = gh.route(new GHRequest(53.080827, 9.074707, 50.597186, 11.184082));
-        GHResponse ph = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180));
-        System.out.println(ph);
-    }
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private String serviceUrl;
-    private boolean pointsEncoded = true;
-    private Downloader downloader = new Downloader("GraphHopperWeb");
-    private boolean instructions = true;
+    private Downloader downloader = new Downloader("GraphHopper Java Client");
+    private String serviceUrl = "https://graphhopper.com/api/1/route";
     private String key = "";
-    private boolean withElevation = false;
-    private final TranslationMap trMap = new TranslationMap().doImport();
+    private boolean instructions = true;
+    private boolean calcPoints = true;
+    private boolean elevation = false;
 
     public GraphHopperWeb()
     {
@@ -60,37 +51,37 @@ public void setDownloader( Downloader downloader )
         this.downloader = downloader;
     }
 
-    /**
-     * Example url: http://localhost:8989 or http://217.92.216.224:8080
-     */
     @Override
-    public boolean load( String url )
+    public boolean load( String serviceUrl )
     {
-        this.serviceUrl = url;
+        this.serviceUrl = serviceUrl;
         return true;
     }
 
-    public GraphHopperWeb setPointsEncoded( boolean b )
+    public GraphHopperWeb setKey( String key )
     {
-        pointsEncoded = b;
+        if (key == null || key.isEmpty())
+            throw new IllegalStateException("Key cannot be empty");
+
+        this.key = key;
         return this;
     }
 
-    public GraphHopperWeb setInstructions( boolean b )
+    public GraphHopperWeb setCalcPoints( boolean calcPoints )
     {
-        instructions = b;
+        this.calcPoints = calcPoints;
         return this;
     }
 
-    public GraphHopperWeb setElevation( boolean withElevation )
+    public GraphHopperWeb setInstructions( boolean b )
     {
-        this.withElevation = withElevation;
+        instructions = b;
         return this;
     }
 
-    public GraphHopperWeb setKey( String key )
+    public GraphHopperWeb setElevation( boolean withElevation )
     {
-        this.key = key;
+        this.elevation = withElevation;
         return this;
     }
 
@@ -107,21 +98,32 @@ public GHResponse route( GHRequest request )
                 places += "point=" + p.lat + "," + p.lon + "&";
             }
 
+            boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
+            boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
+
+            if (tmpInstructions && !tmpCalcPoints)
+                throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
+                        + "Use calcPoints=false and instructions=false to disable point and instruction calculation");
+
+            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
+            String tmpKey = request.getHints().get("key", key);
+
             String url = serviceUrl
                     + "?"
                     + places
                     + "&type=json"
-                    + "&points_encoded=" + pointsEncoded
-                    + "&way_point_max_distance=" + request.getHints().getDouble("wayPointMaxDistance", 1)
+                    + "&instructions=" + tmpInstructions
+                    + "&points_encoded=true"
+                    + "&calc_points=" + tmpCalcPoints
                     + "&algo=" + request.getAlgorithm()
                     + "&locale=" + request.getLocale().toString()
-                    + "&elevation=" + withElevation;
+                    + "&elevation=" + tmpElevation;
 
             if (!request.getVehicle().isEmpty())
                 url += "&vehicle=" + request.getVehicle();
 
-            if (!key.isEmpty())
-                url += "&key=" + key;
+            if (!tmpKey.isEmpty())
+                url += "&key=" + tmpKey;
 
             String str = downloader.downloadAsString(url);
             JSONObject json = new JSONObject(str);
@@ -164,56 +166,69 @@ public GHResponse route( GHRequest request )
                 JSONObject firstPath = paths.getJSONObject(0);
                 double distance = firstPath.getDouble("distance");
                 int time = firstPath.getInt("time");
-                PointList pointList;
-                if (pointsEncoded)
+                if (tmpCalcPoints)
                 {
                     String pointStr = firstPath.getString("points");
-                    pointList = WebHelper.decodePolyline(pointStr, 100, withElevation);
-                } else
-                {
-                    JSONArray coords = firstPath.getJSONObject("points").getJSONArray("coordinates");
-                    pointList = new PointList(coords.length(), withElevation);
-                    for (int i = 0; i < coords.length(); i++)
-                    {
-                        JSONArray arr = coords.getJSONArray(i);
-                        double lon = arr.getDouble(0);
-                        double lat = arr.getDouble(1);
-                        if (withElevation)
-                            pointList.add(lat, lon, arr.getDouble(2));
-                        else
-                            pointList.add(lat, lon);
-                    }
-                }
-
-                if (instructions)
-                {
-                    JSONArray instrArr = firstPath.getJSONArray("instructions");
+                    PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
+                    res.setPoints(pointList);
 
-                    InstructionList il = new InstructionList(trMap.getWithFallBack(request.getLocale()));
-                    for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
+                    if (tmpInstructions)
                     {
-                        JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
-                        double instDist = jsonObj.getDouble("distance");
-                        String text = jsonObj.getString("text");
-                        long instTime = jsonObj.getLong("time");
-                        int sign = jsonObj.getInt("sign");
-                        JSONArray iv = jsonObj.getJSONArray("interval");
-                        int from = iv.getInt(0);
-                        int to = iv.getInt(1);
-                        PointList instPL = new PointList(to - from, withElevation);
-                        for (int j = from; j <= to; j++)
+                        JSONArray instrArr = firstPath.getJSONArray("instructions");
+
+                        InstructionList il = new InstructionList(null);
+                        int viaCount = 1;
+                        for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
                         {
-                            instPL.add(pointList, j);
+                            JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
+                            double instDist = jsonObj.getDouble("distance");
+                            String text = jsonObj.getString("text");
+                            long instTime = jsonObj.getLong("time");
+                            int sign = jsonObj.getInt("sign");
+                            JSONArray iv = jsonObj.getJSONArray("interval");
+                            int from = iv.getInt(0);
+                            int to = iv.getInt(1);
+                            PointList instPL = new PointList(to - from, tmpElevation);
+                            for (int j = from; j <= to; j++)
+                            {
+                                instPL.add(pointList, j);
+                            }
+
+                            InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                            if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
+                            {
+                                ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
+                            }
+
+                            Instruction instr;
+                            if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
+                            {
+                                instr = new RoundaboutInstruction(sign, text, ia, instPL);
+                            } else if (sign == Instruction.REACHED_VIA)
+                            {
+                                ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                                tmpInstr.setViaCount(viaCount);
+                                viaCount++;
+                                instr = tmpInstr;
+                            } else if (sign == Instruction.FINISH)
+                            {
+                                instr = new FinishInstruction(instPL, 0);
+                            } else
+                            {
+                                instr = new Instruction(sign, text, ia, instPL);
+                            }
+
+                            // The translation is done from the routing service so just use the provided string
+                            // instead of creating a combination with sign and name etc
+                            instr.setUseRawName();
+
+                            instr.setDistance(instDist).setTime(instTime);
+                            il.add(instr);
                         }
-
-                        // TODO way and payment type
-                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
-                                setDistance(instDist).setTime(instTime);
-                        il.add(instr);
+                        res.setInstructions(il);
                     }
-                    res.setInstructions(il);
                 }
-                return res.setPoints(pointList).setDistance(distance).setMillis(time);
+                return res.setDistance(distance).setMillis(time);
             }
         } catch (Exception ex)
         {
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index a8f092946e..294f52f9a5 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -53,6 +53,8 @@ GHRequest = function (host) {
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
+    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
+    this.api_params = [];
 
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
@@ -303,20 +305,26 @@ GHroute.prototype = {
     }
 };
 
-// todo
 GHRequest.prototype.init = function (params) {
-    //    for(var key in params) {
-    //        var val = params[key];
-    //        if(val === "false")
-    //            val = false;
-    //        else if(val === "true")
-    //            val = true;
-    //        else {            
-    //            if(parseFloat(val) != NaN)
-    //                val = parseFloat(val)
-    //        }
-    //        this[key] = val;
-    //    } 
+    for (var key in params) {
+        var val = params[key];
+        if (val === "false")
+            val = false;
+        else if (val === "true")
+            val = true;
+        else {
+            if (parseFloat(val) != NaN)
+                val = parseFloat(val)
+        }
+
+        // todo
+        // this[key] = val;
+
+        if (key.indexOf('api.') === 0) {
+            this.api_params[key.substring(4)] = val;
+        }
+    }
+
     if (params.minPathPrecision)
         this.minPathPrecision = params.minPathPrecision;
     if (params.vehicle)
@@ -385,50 +393,42 @@ GHRequest.prototype.hasElevation = function () {
     return this.elevation;
 };
 
-GHRequest.prototype.createGeocodeURL = function (host) {
+GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
     var tmpHost = this.host;
     if (host)
         tmpHost = host;
-    return this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key + "&locale=" + this.locale);
+
+    var path = this.createPath(tmpHost + "/geocode?limit=6&type=" + this.dataType + "&key=" + this.key);
+    if (prevIndex >= 0 && prevIndex < this.route.size()) {
+        var point = this.route.getIndex(prevIndex);
+        path += "&lat=" + point.lat + "&lon=" + point.lng;
+    }
+    return path;
 };
 
 GHRequest.prototype.createURL = function () {
-    return this.createPath(this.host + "/route?" + this.createParams() + "&type=" + this.dataType + "&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=" + this.dataType + "&key=" + this.key);
 };
 
 GHRequest.prototype.createGPXURL = function () {
-    // use points instead of strings
-    var str = "", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
-    }
-    return this.createPath(this.host + "/route?" + str + "&type=gpx&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx&key=" + this.key);
 };
 
 GHRequest.prototype.createHistoryURL = function () {
-    var str = "?", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.input);
-    }
-    return this.createPath(str);
+    return this.createPath("?" + this.createPointParams(true));
 };
 
-GHRequest.prototype.createParams = function () {
+GHRequest.prototype.createPointParams = function (useRawInput) {
     var str = "", point, i, l;
 
     for (i = 0, l = this.route.size(); i < l; i++) {
         point = this.route.getIndex(i);
         if (i > 0)
             str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
+        if (useRawInput)
+            str += "point=" + encodeURIComponent(point.input);
+        else
+            str += "point=" + encodeURIComponent(point.toString());
     }
     return (str);
 };
@@ -455,6 +455,10 @@ GHRequest.prototype.createPath = function (url) {
         url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+
+    for (var key in this.api_params) {
+        url += "&" + key + "=" + this.api_params[key];
+    }
     return url;
 };
 
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 06fc74901c..3e7bf456c9 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -15,7 +15,6 @@ if (!host) {
 }
 
 var ghRequest = new GHRequest(host);
-var tmpArgs = parseUrlWithHisto();
 var bounds = {};
 
 var nominatimURL = "https://nominatim.openstreetmap.org/search";
@@ -366,9 +365,9 @@ function initMap(selectLayer) {
     var mapLink = '<a href="http://www.esri.com/">Esri</a>';
     var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
     var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
-                attribution: osmAttr + '&copy; ' + mapLink + ', ' + wholink,
-                maxZoom: 18
-            });
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
+    });
 
     var baseMaps = {
         "Lyrk": lyrk,
@@ -392,7 +391,7 @@ function initMap(selectLayer) {
     map = L.map('map', {
         layers: [defaultLayer],
         contextmenu: true,
-        contextmenuWidth: 140,
+        contextmenuWidth: 145,
         contextmenuItems: [{
                 separator: true,
                 index: 3,
@@ -566,9 +565,9 @@ function setEndCoord(e) {
     routeIfAllResolved();
 }
 
-function routeIfAllResolved() {
+function routeIfAllResolved(doQuery) {
     if (ghRequest.route.isResolved()) {
-        routeLatLng(ghRequest);
+        routeLatLng(ghRequest, doQuery);
         return true;
     }
     return false;
@@ -599,7 +598,8 @@ function setFlag(coord, index) {
                     draggable: true,
                     contextmenu: true,
                     contextmenuItems: [{
-                            text: 'Marker ' + ((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')),
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
                             disabled: true,
                             index: 0,
                             state: 2
@@ -620,7 +620,8 @@ function setFlag(coord, index) {
                             state: 2
                         }],
                     contextmenuAtiveState: 2
-                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')));
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
         // intercept openPopup
         marker._openPopup = marker.openPopup;
         marker.openPopup = function () {
@@ -1062,11 +1063,14 @@ function routeLatLng(request, doQuery) {
 
             var exportLink = $("#export-link a");
             exportLink.attr('href', urlForHistory);
-            var startOsmLink = $("<a>start</a>");
-            startOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.from.lat + "&mlon=" + request.from.lng);
-            var endOsmLink = $("<a>end</a>");
-            endOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.to.lat + "&mlon=" + request.to.lng);
-            hiddenDiv.append("<br/><span>View on OSM: </span>").append(startOsmLink).append(endOsmLink);
+            var osmRouteLink = $("<br/><a>view on OSM</a>");
+
+            var osmVehicle = "bicycle";
+            if (request.vehicle.toUpperCase() === "FOOT") {
+                osmVehicle = "foot";
+            }
+            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
+            hiddenDiv.append(osmRouteLink);
 
             var osrmLink = $("<a>OSRM</a>");
             osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + request.from + "&loc=" + request.to);
@@ -1146,14 +1150,16 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "marker-icon-red";
     else if (sign === 5)
         sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
-    if (instr.annotationText) {
+    if (instr.annotation_text) {
         if (!title)
-            title = instr.annotationText;
+            title = instr.annotation_text;
         else
-            title = title + ", " + instr.annotationText;
+            title = title + ", " + instr.annotation_text;
     }
     var distance = instr.distance;
     var str = "<td class='instr_title'>" + title + "</td>";
@@ -1410,14 +1416,15 @@ function setAutoCompleteList(index) {
         },
         serviceUrl: function () {
             // see https://graphhopper.com/#directions-api
-            return ghRequest.createGeocodeURL(host);
+            return ghRequest.createGeocodeURL(host, index - 1);
         },
         transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
         onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
@@ -1439,7 +1446,7 @@ function setAutoCompleteList(index) {
             req.setCoord(point.lat, point.lng);
 
             req.input = suggestion.value;
-            if (!routeIfAllResolved())
+            if (!routeIfAllResolved(true))
                 focus(req, 15, index);
 
             myAutoDiv.autocomplete().enable();
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 10a09d601d..6f74987210 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -22,7 +22,10 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.File;
+import java.util.List;
+import java.util.Map;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -70,7 +73,7 @@ public void testJsonRounding() throws Exception
     {
         JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
-        assertTrue("unexpected precision!", cson.toString().indexOf("[1.536374,42.554839]") >= 0);
+        assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
 
     @Test
@@ -91,6 +94,19 @@ public void testGraphHopperWeb() throws Exception
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(42.554851, 1.536198)).
+                addPoint(new GHPoint(42.531896, 1.553278)).
+                addPoint(new GHPoint(42.510071, 1.548128)));
+        assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 20000);
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 21000);
+
+        List<Map<String, Object>> instructions = rsp.getInstructions().createJson();
+        assertEquals(23, instructions.size());
+        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
+        assertEquals("At roundabout, take exit 2", instructions.get(3).get("text"));
     }
 
     @Test
@@ -108,7 +124,7 @@ public void testGraphHopperWebRealExceptions()
 
         ex = rsp.getErrors().get(0);
         assertTrue("Wrong Exception found: " + ex.getClass().getName()
-            + ", IllegalStateException expected.", ex instanceof IllegalStateException);
+                + ", IllegalStateException expected.", ex instanceof IllegalStateException);
 
         // IllegalArgumentException (Wrong Points)
         rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index faa0205ede..7e5aa6af65 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -66,6 +66,10 @@ public void testElevation() throws Exception
 
         JSONObject cson = path.getJSONObject("points");
         assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+
+        // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
+        // or reading with and without elevation would be too complex for the client with no real use
+        assertEquals(4, path.getJSONArray("bbox").length());
     }
 
     @Test
@@ -80,7 +84,7 @@ public void testNoElevation() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance > 2500);
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
         JSONObject cson = path.getJSONObject("points");
-        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+        assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
 
         // disable elevation
         json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
@@ -88,6 +92,6 @@ public void testNoElevation() throws Exception
         assertFalse(infoJson.has("errors"));
         path = json.getJSONArray("paths").getJSONObject(0);
         cson = path.getJSONObject("points");
-        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+        assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index 6b29124e4d..c7c6de2be3 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -31,25 +31,7 @@
  */
 public class GraphHopperWebTest
 {
-
-    @Test
-    public void testReadUnencoded() throws Exception
-    {
-        Downloader downloader = new Downloader("GraphHopper Test")
-        {
-            @Override
-            public InputStream fetch( String url ) throws IOException
-            {
-                return getClass().getResourceAsStream("test.json");
-            }
-        };
-        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(false);
-        instance.setDownloader(downloader);
-        GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
-        assertEquals(2138.3, res.getDistance(), 1e-1);
-        assertEquals(17, res.getPoints().getSize());
-        assertEquals(5, res.getInstructions().getSize());
-    }
+    // see also GraphHopperServletIT.testGraphHopperWeb for real routes against local jetty service    
 
     @Test
     public void testReadEncoded() throws Exception
@@ -62,7 +44,7 @@ public InputStream fetch( String url ) throws IOException
                 return getClass().getResourceAsStream("test_encoded.json");
             }
         };
-        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(true);
+        GraphHopperWeb instance = new GraphHopperWeb();
         instance.setDownloader(downloader);
         GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
         assertEquals(2138.3, res.getDistance(), 1e-1);
diff --git a/web/src/test/resources/com/graphhopper/http/test.json b/web/src/test/resources/com/graphhopper/http/test.json
deleted file mode 100644
index 734968699f..0000000000
--- a/web/src/test/resources/com/graphhopper/http/test.json
+++ /dev/null
@@ -1,139 +0,0 @@
-{
-  "info": {"took": 0.004322056192904711},
-  "paths": [{
-    "bbox": [
-      13.362853824187303,
-      52.469481955531585,
-      13.385836736460217,
-      52.473849308838446
-    ],
-    "distance": 2138.3027624572337,
-    "instructions": [
-      {
-        "distance": 1268.519329705091,
-        "interval": [
-          0,
-          10
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf A 100",
-        "time": 65237
-      },
-      {
-        "distance": 379.74399999999997,
-        "interval": [
-          10,
-          11
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf Strasse",
-        "time": 24855
-      },
-      {
-        "distance": 16.451,
-        "interval": [
-          11,
-          11
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf Tempelhofer Damm",
-        "time": 1316
-      },
-      {
-        "distance": 473.58843275214315,
-        "interval": [
-          11,
-          12
-        ],
-        "sign": -2,
-        "text": "Links abbiegen auf Tempelhofer Damm, B 96",
-        "time": 37882
-      },
-      {
-        "distance": 0,
-        "interval": [
-          12,
-          12
-        ],
-        "sign": 4,
-        "text": "Ziel erreicht!",
-        "time": 0
-      }
-    ],
-    "points": {
-      "coordinates": [
-        [
-          13.362853824187303,
-          52.473849308838446
-        ],
-        [
-          13.36361795731525,
-          52.47361367509396
-        ],
-        [
-          13.365841769408624,
-          52.47262889458155
-        ],
-        [
-          13.368347585983893,
-          52.47146995674379
-        ],
-        [
-          13.369309455960455,
-          52.47115535597106
-        ],
-        [
-          13.370299824408438,
-          52.470938171541796
-        ],
-        [
-          13.372544498127949,
-          52.47050901808982
-        ],
-        [
-          13.373925277007936,
-          52.47029332377672
-        ],
-        [
-          13.374831267628773,
-          52.470171134252205
-        ],
-        [
-          13.375656233183806,
-          52.47009346194774
-        ],
-        [
-          13.378514089700149,
-          52.46991055019
-        ],
-        [
-          13.379928396193574,
-          52.46987162090551
-        ],
-        [
-          13.384775557773759,
-          52.46952423757742
-        ],
-        [
-          13.385498264107815,
-          52.46948735720264
-        ],
-        [
-          13.385740966776185,
-          52.469481955531585
-        ],
-        [
-          13.385832236390536,
-          52.47358033374504
-        ],
-        [
-          13.385836736460217,
-          52.47374048466245
-        ]
-      ],
-      "type": "LineString"
-    },
-    "points_encoded": false,
-    "time": 129290
-  }]
-}
\ No newline at end of file
