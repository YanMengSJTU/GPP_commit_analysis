diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
similarity index 83%
rename from reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
rename to reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
index 23013d7bfb..8dd43f049f 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
@@ -23,7 +23,7 @@
 /**
  * Created by isaac on 09/14/16.
  */
-public class parallelKSP {
+public class AlternativeRoutingExternalities {
 
     String city;
     String route_type;
@@ -46,22 +46,17 @@
     private ArrayList<float[]> inputPoints = new ArrayList<>();
     private ArrayList<String> id_to_points = new ArrayList<>();
     private ArrayList<String> optimizations = new ArrayList<>();
+    private String bannedGridCellsFn;
 
 
-    public parallelKSP(String city, String route_type) {
+    public AlternativeRoutingExternalities(String city, String route_type) {
 
         this.city = city;
         this.route_type = route_type;
         this.outputFiles = new HashMap<>();
         optimizations.add("beauty");
-        //optimizations.add("ugly");
         optimizations.add("simple");
-        //optimizations.add("besi");
         optimizations.add("fast");
-        //optimizations.add("short");
-        //optimizations.add("alt");
-        //optimizations.add("mindirections");
-
     }
 
     public void setCity(String city) {
@@ -211,12 +206,6 @@ else if (pointsList.size() > 0) {
         return results;
     }
 
-    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
-    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
-        return new PathWrapper();
-    }
-
-
     public void setDataSources() throws Exception {
         if (city.equals("sf")) {
             osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
@@ -225,6 +214,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
+            bannedGridCellsFn = gctfnStem + "06075_banned_grid_cells.csv";
         } else if (city.equals("nyc")) {
             osmFile = osmFile + "new-york_new-york.osm.pbf";
             graphFolder = graphFolder + "ghosm_nyc_noch";
@@ -236,6 +226,7 @@ public void setDataSources() throws Exception {
             gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
             gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
+            bannedGridCellsFn = gctfnStem + "nyc_banned_grid_cells.csv";
         } else if (city.equals("bos")) {
             osmFile = osmFile + "boston_massachusetts.osm.pbf";
             graphFolder = graphFolder + "ghosm_bos_noch";
@@ -243,6 +234,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
             gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
+            bannedGridCellsFn = "";
         } else if (city.equals("chi")) {
             osmFile = osmFile + "chicago_illinois.osm.pbf";
             graphFolder = graphFolder + "ghosm_chi_noch";
@@ -250,6 +242,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
+            bannedGridCellsFn = "";
         } else if (city.equals("sin")) {
             osmFile = osmFile + "singapore.osm.pbf";
             graphFolder = graphFolder + "ghosm_sin_noch";
@@ -257,6 +250,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "");
+            bannedGridCellsFn = "";
         } else if (city.equals("lon")) {
             osmFile = osmFile + "london_england.osm.pbf";
             graphFolder = graphFolder + "ghosm_lon_noch";
@@ -264,6 +258,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "");
+            bannedGridCellsFn = "";
         } else if (city.equals("man")) {
             osmFile = osmFile + "manila_philippines.osm.pbf";
             graphFolder = graphFolder + "ghosm_man_noch";
@@ -271,6 +266,7 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "");
+            bannedGridCellsFn = "";
         } else {
             throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
         }
@@ -410,20 +406,6 @@ public String writeOutput(int i, String optimized, String name, String od_id, Pa
 
     }
 
-    public int getNumCTs(PathWrapper path) {
-        if (gridCT.size() == 0) {
-            return -1;
-        }
-        HashSet<String> roundedPoints = path.roundPoints();
-        HashSet<Integer> cts = new HashSet<>();
-        for (String pt : roundedPoints) {
-            if (gridCT.containsKey(pt)) {
-                cts.add(gridCT.get(pt));
-            }
-        }
-        return cts.size();
-    }
-
     public float getBeauty(PathWrapper path) {
         HashSet<String> roundedPoints = path.roundPoints();
         float score = 0;
@@ -496,6 +478,28 @@ public void process_routes() throws Exception {
         }
         );
 
+        num_processed = new AtomicInteger();
+        // initialize banned edges
+        GHRequest req = new GHRequest(inputPoints.get(0)[0], inputPoints.get(0)[1], inputPoints.get(0)[2], inputPoints.get(0)[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("safest_fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("dijkstrabi");
+        GHResponse rsp = hopper.route(req);
+
+        optimizations.add("safety");
+        id_to_points.parallelStream().forEach(od_id -> {
+            System.out.println("Processing: " + od_id);
+            int route = id_to_points.indexOf(od_id);
+            HashMap<String, String> routes = process_route_safety(route);
+            results.get("safety").put(od_id, routes.getOrDefault("safety", "FAILURE"));
+            int i = num_processed.incrementAndGet();
+            if (i % 50 == 0) {
+                System.out.println(System.getProperty("line.separator") + i + " of " + num_odpairs + " o-d pairs processed." + System.getProperty("line.separator"));
+            }
+        }
+        );
+
         for (String optimization : optimizations) {
             for (String result : results.get(optimization).values()) {
                 outputFiles.get(optimization).write(result);
@@ -505,6 +509,79 @@ public void process_routes() throws Exception {
     }
 
 
+    public void print_banned_edges() throws IOException {
+        // Bring in origin-destination pair for processing
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
+        String line = sc_in.nextLine();
+        line = sc_in.nextLine();
+        String[] vals = line.split(",");
+        float loF = Float.valueOf(vals[1]);
+        float laF = Float.valueOf(vals[2]);
+        float loT = Float.valueOf(vals[3]);
+        float laT = Float.valueOf(vals[4]);
+
+        GHRequest req = new GHRequest(laF, loF, laT, loT).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("safest_fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("dijkstrabi");
+
+        // print banned edges
+        hopper.route(req);
+    }
+
+
+    public HashMap<String, String> process_route_safety(int route) {
+        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
+        float[] points;
+        String od_id;
+        HashMap<String, String> responses = new HashMap<>();
+
+        // Get Routes
+        points = inputPoints.get(route);
+        od_id = id_to_points.get(route);
+        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("safest_fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("dijkstrabi");
+        GHResponse rsp = hopper.route(req);
+
+        String defaultRow = od_id + ",main," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
+                + ")]\"," + "-1,-1,-1,[],-1,-1,-1,-1,-1,-1" + System.getProperty("line.separator");
+
+        // first check for errors
+        if (rsp.hasErrors()) {
+            // handle them!
+            System.out.println(rsp.getErrors().toString());
+            System.out.println(route + ": Error - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        // Get All Routes (up to 10K right now)
+        List<PathWrapper> paths = rsp.getAll();
+
+        if (paths.size() == 0) {
+            System.out.println(route + ": No paths - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        // Fastest Safest Route
+        PathWrapper bestPath = paths.get(0);
+        responses.put("safety", writeOutput(route, "Safe", "safe-fastest", od_id, bestPath, getBeauty(bestPath)));
+
+        return responses;
+    }
+
+
+
+
     public HashMap<String, String> process_route(int route) {
         // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
         float[] points;
@@ -549,7 +626,6 @@ public void process_routes() throws Exception {
         // Score each route on beauty to determine most beautiful
         int j = 0;
         float bestscore = -1000;
-        //float originalscore = getBeauty(paths.get(0));
         int routeidx = -1;
         for (PathWrapper path : paths) {
             float score = getBeauty(path);
@@ -559,35 +635,7 @@ public void process_routes() throws Exception {
             }
             j++;
         }
-        //System.out.println("Most beautiful route: " + routeidx);
         responses.put("beauty", writeOutput(route, "Beau", "beauty", od_id, paths.get(routeidx), bestscore));
-        //float maxBeauty = bestscore;
-
-        /*
-        // Find least-beautiful route within similar distance constraints
-        double beautyDistance = paths.get(routeidx).getDistance();
-        j = 0;
-        bestscore = 1000;
-        routeidx = -1;
-        double uglydistance;
-        for (PathWrapper path : paths) {
-            //if (j < capPathsPerMVT) {
-            uglydistance = path.getDistance();
-            if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
-                float score = getBeauty(path);
-                if (score < bestscore) {
-                    bestscore = score;
-                    routeidx = j;
-                }
-            }
-            j++;
-            //} else {
-            //    break;
-            //}
-        }
-        responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore)));
-
-        */
 
         // Simplest Route
         j = 0;
@@ -601,101 +649,12 @@ public void process_routes() throws Exception {
             }
             j++;
         }
-        //System.out.println("Simplest route: " + routeidx);
         responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx))));
-        //float minSimplicity = bestscore;
 
         // Fastest Route
         PathWrapper bestPath = paths.get(0);
         responses.put("fast", writeOutput(route, "Fast", "fastest", od_id, bestPath, getBeauty(bestPath)));
 
-        /*
-
-        // Beautifully simple route
-        j = 0;
-        bestscore = 0;
-        routeidx = 0;
-        float combined;
-        for (PathWrapper path : paths) {
-            combined = (minSimplicity / path.getSimplicity()) + (getBeauty(path) / maxBeauty);
-            if (combined > bestscore) {
-                bestscore = combined;
-                routeidx = j;
-            }
-            j++;
-        }
-        //System.out.println("Most beautiful-simple route: " + routeidx);
-        responses.put("besi", writeOutput(route, "BeSi", "beauty-simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
-
-        // Fewest # directions
-        j = 0;
-        bestscore = 10000;
-        routeidx = 0;
-        InstructionList il;
-        int numDirections;
-        for (PathWrapper path : paths) {
-            il = path.getInstructions();
-            numDirections = il.getSize();
-            if (numDirections < bestscore) {
-                bestscore = numDirections;
-                routeidx = j;
-            }
-            j++;
-        }
-        //System.out.println("Min directions route: " + routeidx);
-        responses.put("mindirections", writeOutput(route, "MnDi", "mindirections", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
-
-
-        // Shortest Route
-        req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("shortest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        rsp = hopper.route(req);
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Skipping shortest path.");
-            responses.put("short", defaultRow);
-        } else {
-            // Get shortest path
-            bestPath = rsp.getBest();
-            beauty = getBeauty(bestPath);
-            responses.put("short", writeOutput(route, "Shrt", "shortest", od_id, bestPath, beauty, getNumCTs(bestPath)));
-        }
-
-        // Alternative Route
-        req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("alternative_route");
-        rsp = hopper.route(req);
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            responses.put("alt", defaultRow.replace("main", "alternative"));
-
-        } else {
-            // Get Alt Routes (should be 2, of which first is the fastest path)
-            paths = rsp.getAll();
-            if (paths.size() < 2) {
-                System.out.println(route + ": Did not return an alternative path.");
-                responses.put("alt", defaultRow.replace("main", "alternative"));
-            } else {
-                PathWrapper altpath = paths.get(1);
-                beauty = getBeauty(altpath);
-                responses.put("alt", writeOutput(route, "Altn", "altn", od_id, altpath, beauty, getNumCTs(altpath)));
-            }
-        }
-
-        */
-
         return responses;
     }
 
@@ -708,7 +667,7 @@ public static void main(String[] args) throws Exception {
         //System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
         //String city = args[0];
         //String odtype = args[1];
-        parallelKSP ksp = new parallelKSP(city, odtype);
+        AlternativeRoutingExternalities ksp = new AlternativeRoutingExternalities(city, odtype);
         boolean matchexternal = false;
         boolean getghroutes = true;
 
@@ -742,7 +701,6 @@ public static void main(String[] args) throws Exception {
             ksp.setDataSources();
             ksp.getGridValues();
             ksp.prepareGraphHopper();
-            //ksp.getGridCTs();
             ksp.setODPairs();
             ksp.process_routes();  // get Graphhopper routes
         }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java
deleted file mode 100644
index 4bbeacc9e0..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java
+++ /dev/null
@@ -1,648 +0,0 @@
-package com.graphhopper.reader.osm;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.matching.MapMatching;
-import com.graphhopper.matching.MatchResult;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.*;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Created by isaac on 09/14/16.
- */
-public class parallelKSP_pctimprovements {
-
-    String city;
-    String route_type;
-    HashMap<String, FileWriter> outputFiles;
-    private String osmFile = "./reader-osm/files/";
-    private String graphFolder = "./reader-osm/target/tmp/";
-    private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/testing/";
-    private String gvfnStem = "../data/intermediate/";
-    private String gctfnStem = "../geometries/";
-    private ArrayList<String> gridValuesFNs = new ArrayList<>();
-    private ArrayList<String> gridCTsFNs = new ArrayList<>();
-    private HashMap<String, Integer> gvHeaderMap;
-    private HashMap<String, Float> gridBeauty;
-    private HashMap<String, Integer> gridCT;
-    private GraphHopper hopper;
-    private MapMatching mapMatching;
-    private String outputheader = "ID";
-    private ArrayList<float[]> inputPoints = new ArrayList<>();
-    private ArrayList<String> id_to_points = new ArrayList<>();
-    private ArrayList<String> optimizations = new ArrayList<>();
-    private int stepsize = 10;
-    private int maxstep = 500;
-
-
-    public parallelKSP_pctimprovements(String city, String route_type) {
-
-        this.city = city;
-        this.route_type = route_type;
-        this.outputFiles = new HashMap<>();
-        optimizations.add("beauty");
-        optimizations.add("simple");
-        for (int i = stepsize; i < maxstep + 1; i += stepsize) {
-            outputheader = outputheader + "," + i + "pct";
-        }
-        outputheader = outputheader + System.getProperty("line.separator");
-
-    }
-
-    public void setCity(String city) {
-        this.city = city;
-    }
-
-    public void setRouteType(String route_type) {
-        this.route_type = route_type;
-    }
-
-    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
-        PathWrapper matchGHRsp = new PathWrapper();
-        try {
-            MatchResult mr = mapMatching.doWork(gpxEntries);
-            Path path = mapMatching.calcPath(mr);
-            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
-        }
-        catch (RuntimeException e) {
-            System.out.println("Broken GPX trace.");
-            System.out.println(e.getMessage());
-        }
-        return matchGHRsp;
-    }
-
-    public void PointsToPath(String fin, String fout) throws IOException {
-        Scanner sc_in = new Scanner(new File(fin));
-        String[] pointsHeader = sc_in.nextLine().split(",");
-        int idIdx = -1;
-        int nameIdx = -1;
-        int latIdx = -1;
-        int lonIdx = -1;
-        int timeIdx = -1;
-        for (int i=0; i<pointsHeader.length; i++) {
-            if (pointsHeader[i].equalsIgnoreCase("ID")) {
-                idIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("name")) {
-                nameIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
-                latIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
-                lonIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
-                timeIdx = i;
-            }
-            else {
-                System.out.println("Unexpected header value: " + pointsHeader[i]);
-            }
-        }
-        String optimized = "";
-        if (fin.indexOf("google") > -1) {
-            optimized = optimized + "Goog";
-        } else if (fin.indexOf("mapquest") > -1) {
-            optimized = optimized + "MapQ";
-        } else {
-            System.out.println("Don't recognize platform: " + fin);
-        }
-        if (fin.indexOf("alt") > -1) {
-            optimized = optimized + " altn";
-        } else if (fin.indexOf("main") > -1) {
-            optimized = optimized + " main";
-        } else {
-            System.out.println("Don't recognize route type: " + fin);
-        }
-        String line;
-        String[] vals;
-        String routeID = "";
-        String prevRouteID = "";
-        String name = "";
-        String prevName = "";
-        String label = "";
-        String prevLabel = "";
-        double lat;
-        double lon;
-        long time;
-        HashMap<String, ArrayList<GPXEntry>> pointsLists = new HashMap<>();
-        HashMap<String, String> routeNames = new HashMap<>();
-        ArrayList<GPXEntry> pointsList = new ArrayList<>();
-        while (sc_in.hasNext()) {
-            line = sc_in.nextLine();
-            vals = line.split(",");
-            routeID = vals[idIdx];
-            name = vals[nameIdx];
-            if (name.equalsIgnoreCase("alternative 2") || name.equalsIgnoreCase("alternative 3")) {
-                continue;
-            }
-            lat = Double.valueOf(vals[latIdx]);
-            lon = Double.valueOf(vals[lonIdx]);
-            time = Long.valueOf(vals[timeIdx]);
-            label = routeID + "|" + name;
-            GPXEntry pt = new GPXEntry(lat, lon, time);
-            if (label.equalsIgnoreCase(prevLabel)) {
-                pointsList.add(pt);
-            }
-            else if (pointsList.size() > 0) {
-                pointsLists.put(prevRouteID, pointsList);
-                routeNames.put(prevRouteID, prevName);
-                pointsList = new ArrayList<>();
-                pointsList.add(pt);
-            } else {
-                System.out.println("First point.");
-                pointsList.add(pt);
-            }
-            prevRouteID = routeID;
-            prevName = name;
-            prevLabel = label;
-        }
-        if (pointsList.size() > 0) {
-            pointsLists.put(prevRouteID, pointsList);
-            routeNames.put(prevRouteID, prevName);
-        }
-        sc_in.close();
-
-        ConcurrentHashMap<String, String> results = getPaths(pointsLists, routeNames, optimized);
-        FileWriter sc_out = new FileWriter(fout, true);
-        sc_out.write(outputheader);
-        for (String result : results.values()) {
-            sc_out.write(result);
-        }
-        sc_out.close();
-    }
-
-    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists, HashMap<String, String> routeNames, String optimized) {
-
-        AtomicInteger num_processed = new AtomicInteger();
-        int num_routes = pointLists.size();
-        Set<String> routeIDs = pointLists.keySet();
-
-        ConcurrentHashMap<String, String> results = new ConcurrentHashMap<>();
-        routeIDs.parallelStream().forEach(routeID -> {
-            System.out.println("Processing: " + routeID);
-            int i = num_processed.incrementAndGet();
-            PathWrapper path = GPXToPath(pointLists.get(routeID));
-            if (path.getDistance() > 0) {
-                float score = getBeauty(path);
-                results.put(routeID, writeOutput(routeID, new float[1]));
-            }
-            if (i % 50 == 0) {
-                System.out.println(i + " of " + num_routes + " routes matched.");
-            }
-        }
-        );
-
-        return results;
-    }
-
-    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
-    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
-        return new PathWrapper();
-    }
-
-
-    public void setDataSources() throws Exception {
-        if (city.equals("sf")) {
-            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf_noch";
-            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
-        } else if (city.equals("nyc")) {
-            osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc_noch";
-            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
-        } else if (city.equals("bos")) {
-            osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos_noch";
-            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
-            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
-        } else if (city.equals("chi")) {
-            osmFile = osmFile + "chicago_illinois.osm.pbf";
-            graphFolder = graphFolder + "ghosm_chi_noch";
-            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
-        } else if (city.equals("sin")) {
-            osmFile = osmFile + "singapore.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sin_noch";
-            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else if (city.equals("lon")) {
-            osmFile = osmFile + "london_england.osm.pbf";
-            graphFolder = graphFolder + "ghosm_lon_noch";
-            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else if (city.equals("man")) {
-            osmFile = osmFile + "manila_philippines.osm.pbf";
-            graphFolder = graphFolder + "ghosm_man_noch";
-            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else {
-            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
-        }
-    }
-
-    public void getGridValues() throws Exception {
-        gvHeaderMap = new HashMap<>();
-        gridBeauty = new HashMap<>();
-
-        for (String fn : gridValuesFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                String[] gvHeader = sc_in.nextLine().split(",");
-                int i = 0;
-                for (String col : gvHeader) {
-                    gvHeaderMap.put(col, i);
-                    i++;
-                }
-                String line;
-                String[] vals;
-                String rc;
-                float beauty;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                        gridBeauty.put(rc, beauty);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-    public void getGridCTs() throws Exception {
-        gridCT = new HashMap<>();
-        for (String fn : gridCTsFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                sc_in.nextLine();
-                String line;
-                String[] vals;
-                String rc;
-                int ct;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[1] + "," + vals[0];
-                        ct = Integer.valueOf(vals[2]);
-                        gridCT.put(rc, ct);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-    public void prepareGraphHopper() {
-        // create one GraphHopper instance
-        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
-        hopper.setDataReaderFile(osmFile);
-        // where to store graphhopper files?
-        hopper.setGraphHopperLocation(graphFolder);
-        hopper.setEncodingManager(new EncodingManager("car"));
-
-        // now this can take minutes if it imports or a few seconds for loading
-        // of course this is dependent on the area you import
-        hopper.importOrLoad();
-    }
-
-    public void prepMapMatcher() {
-
-        // create MapMatching object, can and should be shared accross threads
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                algorithm(Parameters.Algorithms.DIJKSTRA).
-                traversalMode(hopper.getTraversalMode()).
-                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
-                build();
-        mapMatching = new MapMatching(hopper, algoOpts);
-        mapMatching.setTransitionProbabilityBeta(0.00959442);
-//        mapMatching.setTransitionProbabilityBeta(0.000959442);
-        mapMatching.setMeasurementErrorSigma(100);
-    }
-
-
-    public String writeOutput(String od_id, float[] tradeoffs) {
-        // preps output for CSV
-        String result = od_id;
-        int num_bins = tradeoffs.length;
-        for (int i = 0; i < num_bins; i++) {
-            if (tradeoffs[i] > 0) {
-                result = result + "," + tradeoffs[i];
-            } else {
-                result = result + ",";
-            }
-        }
-        System.out.println(result);
-        return result + System.getProperty("line.separator");
-    }
-
-    public int getNumCTs(PathWrapper path) {
-        if (gridCT.size() == 0) {
-            return -1;
-        }
-        HashSet<String> roundedPoints = path.roundPoints();
-        HashSet<Integer> cts = new HashSet<>();
-        for (String pt : roundedPoints) {
-            if (gridCT.containsKey(pt)) {
-                cts.add(gridCT.get(pt));
-            }
-        }
-        return cts.size();
-    }
-
-    public float getBeauty(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        float score = 0;
-        for (String pt : roundedPoints) {
-            if (gridBeauty.containsKey(pt)) {
-                score = score + gridBeauty.get(pt);
-            }
-        }
-        score = score / roundedPoints.size();
-        return score;
-    }
-
-    public void setODPairs() throws Exception {
-        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        for (String optimization : optimizations) {
-            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_tradeoffs" + optimization + ".csv"), true));
-        }
-
-        for (FileWriter fw : outputFiles.values()) {
-            fw.write(outputheader);
-        }
-
-        // Bring in origin-destination pairs for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String header = sc_in.nextLine();
-        String od_id;
-        float laF;
-        float loF;
-        float laT;
-        float loT;
-        float idx = 0;
-        System.out.println("Input data points header: " + header);
-        while (sc_in.hasNext()) {
-            idx = idx + 1;
-            String line = sc_in.nextLine();
-            String[] vals = line.split(",");
-            od_id = vals[0];
-            loF = Float.valueOf(vals[1]);
-            laF = Float.valueOf(vals[2]);
-            loT = Float.valueOf(vals[3]);
-            laT = Float.valueOf(vals[4]);
-            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
-            id_to_points.add(od_id);
-        }
-        int numPairs = inputPoints.size();
-        System.out.println(numPairs + " origin-destination pairs.");
-
-    }
-
-    public void process_routes() throws Exception {
-
-        AtomicInteger num_processed = new AtomicInteger();
-        int num_odpairs = id_to_points.size();
-
-        ConcurrentHashMap<String, ConcurrentHashMap<String, String>> results = new ConcurrentHashMap<>();
-        for (String optimization : optimizations) {
-            results.put(optimization, new ConcurrentHashMap<>());
-        }
-        id_to_points.parallelStream().forEach(od_id -> {
-            System.out.println("Processing: " + od_id);
-            int route = id_to_points.indexOf(od_id);
-            HashMap<String, String> routes = process_route(route);
-            for (String optimization : optimizations) {
-                results.get(optimization).put(od_id, routes.getOrDefault(optimization, "FAILURE"));
-            }
-            int i = num_processed.incrementAndGet();
-            if (i % 50 == 0) {
-                System.out.println(i + " of " + num_odpairs + " o-d pairs processed.");
-            }
-        }
-        );
-
-        for (String optimization : optimizations) {
-            for (String result : results.get(optimization).values()) {
-                outputFiles.get(optimization).write(result);
-            }
-            outputFiles.get(optimization).close();
-        }
-    }
-
-
-    public HashMap<String, String> process_route(int route) {
-        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
-        float[] points;
-        String od_id;
-        HashMap<String, String> responses = new HashMap<>();
-
-        // Get Routes
-        points = inputPoints.get(route);
-        od_id = id_to_points.get(route);
-        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("ksp");
-        GHResponse rsp = hopper.route(req);
-
-        String defaultRow = od_id;
-        for (int i = stepsize; i < maxstep + 1; i = i + stepsize) {
-            defaultRow = defaultRow + ",";
-        }
-        defaultRow = defaultRow + System.getProperty("line.separator");
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Error - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Get All Routes (up to 10K right now)
-        List<PathWrapper> paths = rsp.getAll();
-
-        if (paths.size() == 0) {
-            System.out.println(route + ": No paths - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        int numbinsteps = Math.floorDiv(maxstep, stepsize);
-        float[] tradeoffs = new float[numbinsteps];
-        long mintime = paths.get(0).getTime();
-        float defaultbeauty = getBeauty(paths.get(0));
-        if (defaultbeauty == 0) {
-            int i = 1;
-            while (defaultbeauty == 0) {
-                defaultbeauty = getBeauty(paths.get(i));
-                i++;
-            }
-            System.out.println("\tUsed beauty for " + (i-1) + "th path for " + od_id);
-        }
-        int defaultsimplicity = paths.get(0).getSimplicity();
-
-        // Score each route on beauty to determine most beautiful
-        int j = 0;
-        float bestscore = defaultbeauty;
-        int prevbinstep = 0;
-        for (PathWrapper path : paths) {
-            float score = getBeauty(path);
-            if (score > bestscore) {
-                bestscore = score;
-                int curbinstep = (int) (((bestscore / defaultbeauty * 100) - 100) / stepsize);
-                if (curbinstep > numbinsteps - 1) {
-                    curbinstep = numbinsteps - 1;
-                }
-                float time_tradeoff = (float) path.getTime() / mintime;
-                for (int i = prevbinstep; i < curbinstep; i++) {
-                    tradeoffs[i] = time_tradeoff;
-                }
-                prevbinstep = curbinstep;
-                if (curbinstep == numbinsteps - 1) {
-                    break;
-                }
-            }
-            j++;
-        }
-        responses.put("beauty", writeOutput(od_id, tradeoffs));
-
-        // Simplest Route
-        j = 0;
-        bestscore = defaultsimplicity;
-        prevbinstep = 0;
-        tradeoffs = new float[Math.floorDiv(maxstep, stepsize)];
-        for (PathWrapper path : paths) {
-            int score = path.getSimplicity();
-            if (score < bestscore) {
-                bestscore = score;
-                int curbinstep = (int) ((100 - (bestscore * 100.0 / defaultsimplicity)) / stepsize);
-                if (curbinstep > numbinsteps - 1) {
-                    curbinstep = numbinsteps;
-                }
-                float time_tradeoff = (float) path.getTime() / mintime;
-                for (int i = prevbinstep; i < curbinstep; i++) {
-                    tradeoffs[i] = time_tradeoff;
-                }
-                prevbinstep = curbinstep;
-                if (curbinstep == numbinsteps - 1) {
-                    break;
-                }
-            }
-            j++;
-        }
-        responses.put("simple", writeOutput(od_id, tradeoffs));
-
-        return responses;
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // PBFs from: https://mapzen.com/data/metro-extracts/
-        if (false) {
-            System.out.println((int) (((0.0035 / 0.0018 * 100) - 100) / 25));  // 3
-            System.out.println((int) (((0.0035 / 0.0017 * 100) - 100) / 25));  // 4
-            System.out.println((int) (((0.0035 / 0.0033 * 100) - 100) / 25));  // 0
-            System.out.println((int) ((100 - (79 * 100.0 / 100)) / 10));  // 2
-            System.out.println((int) ((100 - (81 * 100.0 / 100)) / 10));  // 1
-            System.out.println((int) ((100 - (80 * 100.0 / 87)) / 10));  // 0
-            System.out.println((int) ((100 - (90 * 100.0 / 100)) / 10));  // 1
-            return;
-        }
-        //String city = args[0];
-        String city = "sf";  // sf, nyc, chi, lon, man, sin
-        String odtype = "grid";  // grid, rand
-        parallelKSP_pctimprovements ksp = new parallelKSP_pctimprovements(city, odtype);
-        boolean matchexternal = false;
-        boolean getghroutes = true;
-
-        if (matchexternal) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.getGridCTs();
-            ksp.prepMapMatcher();  // score external API routes
-            String inputfolder = "../data/intermediate/";
-            String outputfolder = "../data/SCRATCH/";
-            ArrayList<String> platforms = new ArrayList<>();
-            platforms.add("google");
-            platforms.add("mapquest");
-            ArrayList<String> conditions = new ArrayList<>();
-            conditions.add("traffic");
-            conditions.add("notraffic");
-            ArrayList<String> routetypes = new ArrayList<>();
-            routetypes.add("main");
-            routetypes.add("alt");
-            for (String platform : platforms) {
-                for (String condition : conditions) {
-                    for (String routetype : routetypes) {
-                        ksp.PointsToPath(inputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
-                    }
-                }
-            }
-        }
-
-        if (getghroutes) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.setODPairs();
-            ksp.process_routes();  // get Graphhopper routes
-        }
-    }
-}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java
deleted file mode 100644
index fc3a321192..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java
+++ /dev/null
@@ -1,795 +0,0 @@
-package com.graphhopper.reader.osm;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.matching.MapMatching;
-import com.graphhopper.matching.MatchResult;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.*;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Created by isaac on 09/14/16.
- */
-public class parallelKSP_tradeoffs {
-
-    String city;
-    String route_type;
-    HashMap<String, FileWriter> outputFiles;
-    private String osmFile = "./reader-osm/files/";
-    private String graphFolder = "./reader-osm/target/tmp/";
-    private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/final/tradeoffs/";
-    private String gvfnStem = "../data/intermediate/";
-    private String gctfnStem = "../geometries/";
-    private ArrayList<String> gridValuesFNs = new ArrayList<>();
-    private ArrayList<String> gridCTsFNs = new ArrayList<>();
-    private HashMap<String, Integer> gvHeaderMap;
-    private HashMap<String, Float> gridBeauty;
-    private HashMap<String, Integer> gridCT;
-    private GraphHopper hopper;
-    private MapMatching mapMatching;
-    private String outputheader = "ID";
-    private ArrayList<float[]> inputPoints = new ArrayList<>();
-    private ArrayList<String> id_to_points = new ArrayList<>();
-    private ArrayList<String> optimizations = new ArrayList<>();
-    private int stepsize = 10;
-    private int maxstep = 100;
-
-    public parallelKSP_tradeoffs(String city, String route_type) {
-
-        this.city = city;
-        this.route_type = route_type;
-        this.outputFiles = new HashMap<>();
-        optimizations.add("beauty_time");
-        optimizations.add("simple_time");
-        optimizations.add("beauty_beauty");
-        optimizations.add("simple_simple");
-        for (int i = 0; i <= maxstep; i += stepsize) {
-            outputheader = outputheader + "," + i + "pct";
-        }
-        outputheader = outputheader + System.getProperty("line.separator");
-    }
-
-    public void setCity(String city) {
-        this.city = city;
-    }
-
-    public void setRouteType(String route_type) {
-        this.route_type = route_type;
-    }
-
-    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
-        PathWrapper matchGHRsp = new PathWrapper();
-        try {
-            MatchResult mr = mapMatching.doWork(gpxEntries);
-            Path path = mapMatching.calcPath(mr);
-            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
-        }
-        catch (RuntimeException e) {
-            System.out.println("Broken GPX trace.");
-            System.out.println(e.getMessage());
-        }
-        return matchGHRsp;
-    }
-
-    public void PointsToPath(String fin, String fout) throws IOException {
-        Scanner sc_in = new Scanner(new File(fin));
-        String[] pointsHeader = sc_in.nextLine().split(",");
-        int idIdx = -1;
-        int nameIdx = -1;
-        int latIdx = -1;
-        int lonIdx = -1;
-        int timeIdx = -1;
-        for (int i=0; i<pointsHeader.length; i++) {
-            if (pointsHeader[i].equalsIgnoreCase("ID")) {
-                idIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("name")) {
-                nameIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
-                latIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
-                lonIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
-                timeIdx = i;
-            }
-            else {
-                System.out.println("Unexpected header value: " + pointsHeader[i]);
-            }
-        }
-        String optimized = "";
-        if (fin.indexOf("google") > -1) {
-            optimized = optimized + "Goog";
-        } else if (fin.indexOf("mapquest") > -1) {
-            optimized = optimized + "MapQ";
-        } else {
-            System.out.println("Don't recognize platform: " + fin);
-        }
-        if (fin.indexOf("alt") > -1) {
-            optimized = optimized + " altn";
-        } else if (fin.indexOf("main") > -1) {
-            optimized = optimized + " main";
-        } else {
-            System.out.println("Don't recognize route type: " + fin);
-        }
-        String line;
-        String[] vals;
-        String routeID = "";
-        String prevRouteID = "";
-        String name = "";
-        String prevName = "";
-        String label = "";
-        String prevLabel = "";
-        double lat;
-        double lon;
-        long time;
-        HashMap<String, ArrayList<GPXEntry>> pointsLists = new HashMap<>();
-        HashMap<String, String> routeNames = new HashMap<>();
-        ArrayList<GPXEntry> pointsList = new ArrayList<>();
-        while (sc_in.hasNext()) {
-            line = sc_in.nextLine();
-            vals = line.split(",");
-            routeID = vals[idIdx];
-            name = vals[nameIdx];
-            if (name.equalsIgnoreCase("alternative 2") || name.equalsIgnoreCase("alternative 3")) {
-                continue;
-            }
-            lat = Double.valueOf(vals[latIdx]);
-            lon = Double.valueOf(vals[lonIdx]);
-            time = Long.valueOf(vals[timeIdx]);
-            label = routeID + "|" + name;
-            GPXEntry pt = new GPXEntry(lat, lon, time);
-            if (label.equalsIgnoreCase(prevLabel)) {
-                pointsList.add(pt);
-            }
-            else if (pointsList.size() > 0) {
-                pointsLists.put(prevRouteID, pointsList);
-                routeNames.put(prevRouteID, prevName);
-                pointsList = new ArrayList<>();
-                pointsList.add(pt);
-            } else {
-                System.out.println("First point.");
-                pointsList.add(pt);
-            }
-            prevRouteID = routeID;
-            prevName = name;
-            prevLabel = label;
-        }
-        if (pointsList.size() > 0) {
-            pointsLists.put(prevRouteID, pointsList);
-            routeNames.put(prevRouteID, prevName);
-        }
-        sc_in.close();
-
-        ConcurrentHashMap<String, String> results = getPaths(pointsLists, routeNames, optimized);
-        FileWriter sc_out = new FileWriter(fout, true);
-        sc_out.write(outputheader);
-        for (String result : results.values()) {
-            sc_out.write(result);
-        }
-        sc_out.close();
-    }
-
-    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists, HashMap<String, String> routeNames, String optimized) {
-
-        AtomicInteger num_processed = new AtomicInteger();
-        int num_routes = pointLists.size();
-        Set<String> routeIDs = pointLists.keySet();
-
-        ConcurrentHashMap<String, String> results = new ConcurrentHashMap<>();
-        routeIDs.parallelStream().forEach(routeID -> {
-            System.out.println("Processing: " + routeID);
-            int i = num_processed.incrementAndGet();
-            PathWrapper path = GPXToPath(pointLists.get(routeID));
-            if (path.getDistance() > 0) {
-                float score = getBeauty(path);
-                results.put(routeID, writeOutput(routeID, new float[1], new int[1]));
-            }
-            if (i % 50 == 0) {
-                System.out.println(i + " of " + num_routes + " routes matched.");
-            }
-        }
-        );
-
-        return results;
-    }
-
-    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
-    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
-        return new PathWrapper();
-    }
-
-
-    public void setDataSources() throws Exception {
-        if (city.equals("sf")) {
-            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf_noch";
-            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
-        } else if (city.equals("nyc")) {
-            osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc_noch";
-            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
-        } else if (city.equals("bos")) {
-            osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos_noch";
-            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
-            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
-        } else if (city.equals("chi")) {
-            osmFile = osmFile + "chicago_illinois.osm.pbf";
-            graphFolder = graphFolder + "ghosm_chi_noch";
-            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
-        } else if (city.equals("sin")) {
-            osmFile = osmFile + "singapore.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sin_noch";
-            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else if (city.equals("lon")) {
-            osmFile = osmFile + "london_england.osm.pbf";
-            graphFolder = graphFolder + "ghosm_lon_noch";
-            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else if (city.equals("man")) {
-            osmFile = osmFile + "manila_philippines.osm.pbf";
-            graphFolder = graphFolder + "ghosm_man_noch";
-            inputPointsFN = inputPointsFN + "man_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-        } else {
-            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
-        }
-    }
-
-    public void getGridValues() throws Exception {
-        gvHeaderMap = new HashMap<>();
-        gridBeauty = new HashMap<>();
-
-        for (String fn : gridValuesFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                String[] gvHeader = sc_in.nextLine().split(",");
-                int i = 0;
-                for (String col : gvHeader) {
-                    gvHeaderMap.put(col, i);
-                    i++;
-                }
-                String line;
-                String[] vals;
-                String rc;
-                float beauty;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                        gridBeauty.put(rc, beauty);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-    public void getGridCTs() throws Exception {
-        gridCT = new HashMap<>();
-        for (String fn : gridCTsFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                sc_in.nextLine();
-                String line;
-                String[] vals;
-                String rc;
-                int ct;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[1] + "," + vals[0];
-                        ct = Integer.valueOf(vals[2]);
-                        gridCT.put(rc, ct);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-    public void prepareGraphHopper() {
-        // create one GraphHopper instance
-        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
-        hopper.setDataReaderFile(osmFile);
-        // where to store graphhopper files?
-        hopper.setGraphHopperLocation(graphFolder);
-        hopper.setEncodingManager(new EncodingManager("car"));
-
-        // now this can take minutes if it imports or a few seconds for loading
-        // of course this is dependent on the area you import
-        hopper.importOrLoad();
-    }
-
-    public void prepMapMatcher() {
-
-        // create MapMatching object, can and should be shared accross threads
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                algorithm(Parameters.Algorithms.DIJKSTRA).
-                traversalMode(hopper.getTraversalMode()).
-                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
-                build();
-        mapMatching = new MapMatching(hopper, algoOpts);
-        mapMatching.setTransitionProbabilityBeta(0.00959442);
-//        mapMatching.setTransitionProbabilityBeta(0.000959442);
-        mapMatching.setMeasurementErrorSigma(100);
-    }
-
-
-    public String writeOutput(String od_id, float[] scores, int[] bestindices) {
-
-        // preps output for CSV
-        String result = od_id;
-        int num_bins = bestindices.length;
-        for (int i = 0; i < num_bins; i++) {
-            try {
-                result = result + "," + scores[bestindices[i]];
-            } catch (ArrayIndexOutOfBoundsException ai) {
-                result = result + ",";
-                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: beauty" + System.getProperty("line.separator") + System.getProperty("line.separator"));
-            }
-        }
-        System.out.println(result);
-        return result + System.getProperty("line.separator");
-
-
-    }
-
-    public String writeOutput(String od_id, long[] scores, int[] bestindices) {
-
-        // preps output for CSV
-        String result = od_id;
-        int num_bins = bestindices.length;
-        for (int i = 0; i < num_bins; i++) {
-            try {
-                result = result + "," + scores[bestindices[i]];
-            } catch (ArrayIndexOutOfBoundsException ai) {
-                result = result + ",";
-                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: time" + System.getProperty("line.separator") + System.getProperty("line.separator"));
-            }
-        }
-        System.out.println(result);
-        return result + System.getProperty("line.separator");
-
-
-    }
-
-    public String writeOutput(String od_id, int[] scores, int[] bestindices) {
-
-        // preps output for CSV
-        String result = od_id;
-        int num_bins = bestindices.length;
-        for (int i = 0; i < num_bins; i++) {
-            try {
-                result = result + "," + scores[bestindices[i]];
-            } catch (ArrayIndexOutOfBoundsException ai) {
-                result = result + ",";
-                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: simplicity" + System.getProperty("line.separator") + System.getProperty("line.separator"));
-            }
-        }
-        System.out.println(result);
-        return result + System.getProperty("line.separator");
-
-
-    }
-
-    public int getNumCTs(PathWrapper path) {
-        if (gridCT.size() == 0) {
-            return -1;
-        }
-        HashSet<String> roundedPoints = path.roundPoints();
-        HashSet<Integer> cts = new HashSet<>();
-        for (String pt : roundedPoints) {
-            if (gridCT.containsKey(pt)) {
-                cts.add(gridCT.get(pt));
-            }
-        }
-        return cts.size();
-    }
-
-    public float getBeauty(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        float score = 0;
-        for (String pt : roundedPoints) {
-            if (gridBeauty.containsKey(pt)) {
-                score = score + gridBeauty.get(pt);
-            }
-        }
-        score = score / roundedPoints.size();
-        return score;
-    }
-
-    public void setODPairs() throws Exception {
-        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        for (String optimization : optimizations) {
-            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_optimize" + optimization + "tradeoff.csv"), true));
-        }
-
-        for (FileWriter fw : outputFiles.values()) {
-            fw.write(outputheader);
-        }
-
-        // Bring in origin-destination pairs for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String header = sc_in.nextLine();
-        String od_id;
-        float laF;
-        float loF;
-        float laT;
-        float loT;
-        float idx = 0;
-        System.out.println("Input data points header: " + header);
-        while (sc_in.hasNext()) {
-            idx = idx + 1;
-            String line = sc_in.nextLine();
-            String[] vals = line.split(",");
-            od_id = vals[0];
-            loF = Float.valueOf(vals[1]);
-            laF = Float.valueOf(vals[2]);
-            loT = Float.valueOf(vals[3]);
-            laT = Float.valueOf(vals[4]);
-            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
-            id_to_points.add(od_id);
-        }
-        int numPairs = inputPoints.size();
-        System.out.println(numPairs + " origin-destination pairs.");
-
-    }
-
-    public void process_routes() throws Exception {
-
-        AtomicInteger num_processed = new AtomicInteger();
-        int num_odpairs = id_to_points.size();
-
-        ConcurrentHashMap<String, ConcurrentHashMap<String, String>> results = new ConcurrentHashMap<>();
-        for (String optimization : optimizations) {
-            results.put(optimization, new ConcurrentHashMap<>());
-        }
-        id_to_points.parallelStream().forEach(od_id -> {
-            System.out.println("Processing: " + od_id);
-            int route = id_to_points.indexOf(od_id);
-            HashMap<String, String> routes = process_route(route);
-            for (String optimization : optimizations) {
-                results.get(optimization).put(od_id, routes.getOrDefault(optimization, "FAILURE"));
-            }
-            int i = num_processed.incrementAndGet();
-            if (i % 50 == 0) {
-                System.out.println(i + " of " + num_odpairs + " o-d pairs processed.");
-            }
-        }
-        );
-
-        for (String optimization : optimizations) {
-            for (String result : results.get(optimization).values()) {
-                outputFiles.get(optimization).write(result);
-            }
-            outputFiles.get(optimization).close();
-        }
-    }
-
-
-    public HashMap<String, String> process_route(int route) {
-        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
-        float[] points;
-        String od_id;
-        HashMap<String, String> responses = new HashMap<>();
-
-        // Get Routes
-        points = inputPoints.get(route);
-        od_id = id_to_points.get(route);
-        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("ksp");
-        GHResponse rsp = hopper.route(req);
-
-        String defaultRow = od_id;
-        for (int i = 0; i <= maxstep; i = i + stepsize) {
-            defaultRow = defaultRow + ",";
-        }
-        defaultRow = defaultRow + System.getProperty("line.separator");
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Error - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Get All Routes (up to 10K right now)
-        List<PathWrapper> paths = rsp.getAll();
-        int numpaths = paths.size();
-
-        if (numpaths == 0) {
-            System.out.println(route + ": No paths - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        /**
-         *   Algorithm Order:
-         *   1. Most Beautiful
-         *   2. Fastest
-         *   3. Vary Beauty/Fastest by 10%
-         *   4. Simplest
-         *   5. Vary Simplicity/Fastest by 10%
-         *
-         *   Metrics:
-         *   1. Time
-         *   2. What's being optimized - beauty or simplicity
-         *
-         */
-        float[] beautyscores = new float[numpaths];
-        long[] timescores = new long[numpaths];
-        int numbins = Math.floorDiv(maxstep, stepsize) + 1;
-        int[] bestindices = new int[numbins];
-
-        // Store beauty values for all routes and min/max
-        int j = 0;
-        int bestidx = 0;
-        int worstidx = 0;
-        for (PathWrapper path : paths) {
-            beautyscores[j] = getBeauty(path);
-            timescores[j] = path.getTime();
-            if (beautyscores[j] > beautyscores[bestidx]) {
-                bestidx = j;
-            } else if (beautyscores[j] < beautyscores[worstidx]) {
-                worstidx = j;
-            }
-            j++;
-        }
-        // 100% beauty = most beautiful route idx; 0% beauty is by default already 0, the fastest path
-        bestindices[numbins - 1] = bestidx;
-        // fastest path = 1st, slowest path = last
-        long fastest = paths.get(0).getTime();
-        long slowest = paths.get(numpaths - 1).getTime();
-
-        /*
-        long baselinetime = paths.get(0).getTime();
-        float baselinebeauty = getBeauty(paths.get(0));
-        int baselinesimplicity = paths.get(0).getSimplicity();
-
-        if (baselinebeauty == 0) {
-            int i = 1;
-            while (baselinebeauty == 0) {
-                baselinebeauty = getBeauty(paths.get(i));
-                i++;
-            }
-            System.out.println("\tUsed beauty for " + (i-1) + "th path for " + od_id);
-        }
-        */
-
-        // Loop through 10% to 90% weightings, scoring each route on beauty to determine most beautiful
-        for (int i = 1; i < numbins - 1; i = i + 1) {
-            float bestscore = -1;
-            float combinedscore;
-            float beautyscore;
-            float timescore;
-            int bestcomboidx = -1;
-            for (j=0; j<numpaths; j++) {
-                beautyscore = (beautyscores[j] - beautyscores[worstidx]) / (beautyscores[bestidx] - beautyscores[worstidx]);
-                timescore = 1 - (((float) timescores[j] - fastest) / (slowest - fastest));
-                combinedscore = (i * beautyscore) + ((stepsize - i) * timescore);
-                if (combinedscore > bestscore) {
-                    bestscore = combinedscore;
-                    bestcomboidx = j;
-                }
-            }
-            bestindices[i] = bestcomboidx;
-        }
-        responses.put("beauty_beauty", writeOutput(od_id, beautyscores, bestindices));
-        responses.put("beauty_time", writeOutput(od_id, timescores, bestindices));
-
-
-        /* Find least-beautiful route within similar distance constraints
-        double beautyDistance = paths.get(routeidx).getDistance();
-        j = 0;
-        bestscore = 1000;
-        routeidx = -1;
-        double uglydistance;
-        for (PathWrapper path : paths) {
-            uglydistance = path.getDistance();
-            if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
-                float score = getBeauty(path);
-                if (score < bestscore) {
-                    bestscore = score;
-                    routeidx = j;
-                }
-            }
-            j++;
-        }
-        responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
-        */
-
-        // Simplest Route
-        int[] simplescores = new int[numpaths];
-        bestindices = new int[numbins];
-
-        // Store beauty values for all routes and min/max
-        j = 0;
-        bestidx = 0;
-        worstidx = 0;
-        for (PathWrapper path : paths) {
-            simplescores[j] = path.getSimplicity();
-            if (simplescores[j] < simplescores[bestidx]) {
-                bestidx = j;
-            } else if (simplescores[j] > simplescores[worstidx]) {
-                worstidx = j;
-            }
-            j++;
-        }
-        // 100% simple = simplest route idx; 0% simplicity is by default already 0, the fastest path
-        bestindices[numbins - 1] = bestidx;
-
-        // Loop through 10% to 90% weightings, scoring each route on beauty to determine most beautiful
-        for (int i = 1; i < numbins - 1; i = i + 1) {
-            float bestscore = -1;
-            float combinedscore;
-            float simplescore;
-            float timescore;
-            int bestcomboidx = -1;
-            for (j=0; j<numpaths; j++) {
-                simplescore = 1 - (((float) simplescores[j] - simplescores[bestidx]) / (simplescores[worstidx] - simplescores[bestidx]));
-                timescore = 1 - (((float) timescores[j] - fastest) / (slowest - fastest));
-                combinedscore = (i * simplescore) + ((stepsize - i) * timescore);
-                if (combinedscore > bestscore) {
-                    bestscore = combinedscore;
-                    bestcomboidx = j;
-                }
-            }
-            bestindices[i] = bestcomboidx;
-        }
-        responses.put("simple_simple", writeOutput(od_id, simplescores, bestindices));
-        responses.put("simple_time", writeOutput(od_id, timescores, bestindices));
-
-        /*
-        //System.out.println("Simplest route: " + routeidx);
-        responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), beauty, getNumCTs(paths.get(routeidx))));
-        float minSimplicity = bestscore;
-
-        // Fastest Route
-        PathWrapper bestPath = paths.get(0);
-        beauty = getBeauty(bestPath);
-        responses.put("fast", writeOutput(route, "Fast", "Fastest", od_id, bestPath, beauty, getNumCTs(bestPath)));
-
-        // Beautifully simple route
-        j = 0;
-        bestscore = 0;
-        routeidx = 0;
-        float combined;
-        for (PathWrapper path : paths) {
-            combined = (minSimplicity / path.getSimplicity()) + (getBeauty(path) / maxBeauty);
-            if (combined > bestscore) {
-                bestscore = combined;
-                routeidx = j;
-            }
-            j++;
-        }
-        //System.out.println("Most beautiful-simple route: " + routeidx);
-        responses.put("besi", writeOutput(route, "BeSi", "beauty-simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
-        */
-
-        /* Fewest # directions
-        j = 0;
-        bestscore = 10000;
-        routeidx = 0;
-        InstructionList il;
-        int numDirections;
-        for (PathWrapper path : paths) {
-            il = path.getInstructions();
-            numDirections = il.getSize();
-            if (numDirections < bestscore) {
-                bestscore = numDirections;
-                routeidx = j;
-            }
-            j++;
-        }
-        responses.put("mindirections", writeOutput(route, "MnDi", "mindirections", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
-        */
-
-        /* Shortest Route
-        req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("shortest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        rsp = hopper.route(req);
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Skipping shortest path.");
-            responses.put("short", defaultRow);
-        } else {
-            // Get shortest path
-            bestPath = rsp.getBest();
-            beauty = getBeauty(bestPath);
-            responses.put("short", writeOutput(route, "Shrt", "shortest", od_id, bestPath, beauty, getNumCTs(bestPath)));
-        }
-         */
-
-        return responses;
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // PBFs from: https://mapzen.com/data/metro-extracts/
-
-        //String city = args[0];
-        //String odtype = args[1];
-        String city = "lon";  // sf, nyc, chi, lon, man, sin
-        String odtype = "grid";  // grid, rand
-        parallelKSP_tradeoffs ksp = new parallelKSP_tradeoffs(city, odtype);
-        boolean getghroutes = true;
-
-        if (getghroutes) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            //ksp.getGridCTs();
-            ksp.setODPairs();
-            ksp.process_routes();  // get Graphhopper routes
-        }
-    }
-}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
deleted file mode 100644
index 79007bdef3..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ /dev/null
@@ -1,612 +0,0 @@
-package com.graphhopper.reader.osm;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.matching.MapMatching;
-import com.graphhopper.matching.MatchResult;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.*;
-
-import java.util.*;
-
-import java.io.*;
-import java.util.List;
-
-
-/**
- * Created by isaac on 09/14/16.
- */
-public class runKSP {
-
-    String city;
-    String route_type;
-    ArrayList<FileWriter> outputFiles;
-    private String osmFile = "./reader-osm/files/";
-    private String graphFolder = "./reader-osm/target/tmp/";
-    private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/testing/";
-    private String gvfnStem = "../data/intermediate/";
-    private String gctfnStem = "../geometries/";
-    private ArrayList<String> gridValuesFNs = new ArrayList<>();
-    private ArrayList<String> gridCTsFNs = new ArrayList<>();
-    private HashMap<String, Integer> gvHeaderMap;
-    private HashMap<String, Float> gridBeauty;
-    private HashMap<String, Integer> gridCT;
-    private GraphHopper hopper;
-    private MapMatching mapMatching;
-    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,numCTs" +
-            System.getProperty("line.separator");
-
-    public runKSP(String city, String route_type) {
-
-        this.city = city;
-        this.route_type = route_type;
-        this.outputFiles = new ArrayList<>(4);
-    }
-
-    public void setCity(String city) {
-        this.city = city;
-    }
-
-    public void setRouteType(String route_type) {
-        this.route_type = route_type;
-    }
-
-    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
-        PathWrapper matchGHRsp = new PathWrapper();
-        try {
-            MatchResult mr = mapMatching.doWork(gpxEntries);
-            Path path = mapMatching.calcPath(mr);
-            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
-        }
-        catch (RuntimeException e) {
-            System.out.println("Broken GPX trace.");
-            System.out.println(e.getMessage());
-        }
-        return matchGHRsp;
-    }
-
-    public void PointsToPath(String fin, String fout) throws IOException {
-        Scanner sc_in = new Scanner(new File(fin));
-        String[] pointsHeader = sc_in.nextLine().split(",");
-        int idIdx = -1;
-        int nameIdx = -1;
-        int latIdx = -1;
-        int lonIdx = -1;
-        int timeIdx = -1;
-        for (int i=0; i<pointsHeader.length; i++) {
-            if (pointsHeader[i].equalsIgnoreCase("ID")) {
-                idIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("name")) {
-                nameIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
-                latIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
-                lonIdx = i;
-            }
-            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
-                timeIdx = i;
-            }
-            else {
-                System.out.println("Unexpected header value: " + pointsHeader[i]);
-            }
-        }
-        String optimized = "";
-        if (fin.indexOf("google") > -1) {
-            optimized = optimized + "Goog";
-        } else if (fin.indexOf("mapquest") > -1) {
-            optimized = optimized + "MapQ";
-        } else {
-            System.out.println("Don't recognize platform: " + fin);
-        }
-        if (fin.indexOf("alt") > -1) {
-            optimized = optimized + " altn";
-        } else if (fin.indexOf("main") > -1) {
-            optimized = optimized + " main";
-        } else {
-            System.out.println("Don't recognize route type: " + fin);
-        }
-        String line;
-        String[] vals;
-        String routeID = "";
-        String prevRouteID = "";
-        String name = "";
-        String prevName = "";
-        String label = "";
-        String prevLabel = "";
-        double lat;
-        double lon;
-        long time;
-        ArrayList<GPXEntry> pointsList = new ArrayList<>();
-        PathWrapper path;
-        FileWriter sc_out = new FileWriter(fout, true);
-        sc_out.write(outputheader);
-        int i = 0;
-        float score;
-        while (sc_in.hasNext()) {
-            line = sc_in.nextLine();
-            vals = line.split(",");
-            routeID = vals[idIdx];
-            name = vals[nameIdx];
-            if (name.equalsIgnoreCase("alternative 2") || name.equalsIgnoreCase("alternative 3")) {
-                continue;
-            }
-            lat = Double.valueOf(vals[latIdx]);
-            lon = Double.valueOf(vals[lonIdx]);
-            time = Long.valueOf(vals[timeIdx]);
-            label = routeID + "|" + name;
-            GPXEntry pt = new GPXEntry(lat, lon, time);
-            if (label.equalsIgnoreCase(prevLabel)) {
-                pointsList.add(pt);
-            }
-            else if (pointsList.size() > 0) {
-                path = GPXToPath(pointsList);
-                if (path.getDistance() > 0) {
-                    score = getBeauty(path);
-                    writeOutput(sc_out, i, optimized, prevName, prevRouteID, path, score, getNumCTs(path));
-                }
-                pointsList.clear();
-                pointsList.add(pt);
-                i++;
-                if (i % 10 == 0) {
-                    for (FileWriter fw : outputFiles) {
-                        fw.flush();
-                    }
-                }
-            } else {
-                System.out.println("First point.");
-                pointsList.add(pt);
-            }
-            prevRouteID = routeID;
-            prevName = name;
-            prevLabel = label;
-        }
-        if (pointsList.size() > 0) {
-            path = GPXToPath(pointsList);
-            if (path.getDistance() > 0) {
-                score = getBeauty(path);
-                writeOutput(sc_out, i, optimized, prevName, prevRouteID, path, score, getNumCTs(path));
-            }
-        }
-        sc_out.close();
-        sc_in.close();
-    }
-
-    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
-    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
-        return new PathWrapper();
-    }
-
-
-    public void setDataSources() throws Exception {
-        if (city.equals("sf")) {
-            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf_noch";
-            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
-        } else if (city.equals("nyc")) {
-            osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc_noch";
-            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
-        } else if (city.equals("bos")) {
-            osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos_noch";
-            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
-            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
-        } else {
-            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
-        }
-    }
-
-    public void getGridValues() throws Exception {
-        gvHeaderMap = new HashMap<>();
-        gridBeauty = new HashMap<>();
-
-        for (String fn : gridValuesFNs) {
-            Scanner sc_in = new Scanner(new File(fn));
-            String[] gvHeader = sc_in.nextLine().split(",");
-            int i = 0;
-            for (String col : gvHeader) {
-                gvHeaderMap.put(col, i);
-                i++;
-            }
-            String line;
-            String[] vals;
-            String rc;
-            float beauty;
-            while (sc_in.hasNext()) {
-                line = sc_in.nextLine();
-                vals = line.split(",");
-                try {
-                    rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                    beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                    gridBeauty.put(rc, beauty);
-                } catch (NullPointerException ex) {
-                    System.out.println(ex.getMessage());
-                    System.out.println(line);
-                    continue;
-                }
-            }
-
-        }
-    }
-
-    public void getGridCTs() throws Exception {
-        gridCT = new HashMap<>();
-        for (String fn : gridCTsFNs) {
-            Scanner sc_in = new Scanner(new File(fn));
-            sc_in.nextLine();
-            String line;
-            String[] vals;
-            String rc;
-            int ct;
-            while (sc_in.hasNext()) {
-                line = sc_in.nextLine();
-                vals = line.split(",");
-                try {
-                    rc = vals[1] + "," + vals[0];
-                    ct = Integer.valueOf(vals[2]);
-                    gridCT.put(rc, ct);
-                } catch (NullPointerException ex) {
-                    System.out.println(ex.getMessage());
-                    System.out.println(line);
-                    continue;
-                }
-            }
-
-        }
-    }
-
-    public void prepareGraphHopper() {
-        // create one GraphHopper instance
-        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
-        hopper.setDataReaderFile(osmFile);
-        // where to store graphhopper files?
-        hopper.setGraphHopperLocation(graphFolder);
-        hopper.setEncodingManager(new EncodingManager("car"));
-
-        // now this can take minutes if it imports or a few seconds for loading
-        // of course this is dependent on the area you import
-        hopper.importOrLoad();
-    }
-
-    public void prepMapMatcher() {
-
-        // create MapMatching object, can and should be shared accross threads
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                algorithm(Parameters.Algorithms.DIJKSTRA).
-                traversalMode(hopper.getTraversalMode()).
-                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
-                build();
-        mapMatching = new MapMatching(hopper, algoOpts);
-        mapMatching.setTransitionProbabilityBeta(0.00959442);
-//        mapMatching.setTransitionProbabilityBeta(0.000959442);
-        mapMatching.setMeasurementErrorSigma(100);
-    }
-
-
-    public void writeOutput(FileWriter fw, int i, String optimized, String name, String od_id, PathWrapper bestPath, float score, int numCTs) throws IOException {
-
-        // points, distance in meters and time in seconds (convert from ms) of the full path
-        PointList pointList = bestPath.getPoints();
-        int simplicity = bestPath.getSimplicity();
-        double distance = Math.round(bestPath.getDistance() * 100) / 100;
-        long timeInSec = bestPath.getTime() / 1000;
-        InstructionList il = bestPath.getInstructions();
-        int numDirections = il.getSize();
-        // iterate over every turn instruction
-        ArrayList<String> maneuvers = new ArrayList<>();
-        for (Instruction instruction : il) {
-            maneuvers.add(instruction.getSimpleTurnDescription());
-        }
-
-        fw.write(od_id + "," + name + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                ",\"" + maneuvers.toString() + "\"" + "," + score + "," + simplicity + "," + numCTs + System.getProperty("line.separator"));
-        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score + ";\tNumCts: " + numCTs);
-
-    }
-
-    public int getNumCTs(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        HashSet<Integer> cts = new HashSet<>();
-        for (String pt : roundedPoints) {
-            if (gridCT.containsKey(pt)) {
-                cts.add(gridCT.get(pt));
-            }
-        }
-        return cts.size();
-    }
-
-    public float getBeauty(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        float score = 0;
-        for (String pt : roundedPoints) {
-            if (gridBeauty.containsKey(pt)) {
-                score = score + gridBeauty.get(pt);
-            }
-        }
-        score = score / roundedPoints.size();
-        return score;
-    }
-
-
-    public void process_routes() throws Exception {
-        ArrayList<float[]> inputPoints = new ArrayList<float[]>();
-        ArrayList<String> id_to_points = new ArrayList<String>();
-
-        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_beauty.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_ugly.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_simple.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_fast.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_shortest.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_alt.csv"), true));
-        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_besi.csv"), true));
-
-        for (FileWriter fw : outputFiles) {
-            fw.write(outputheader);
-        }
-
-        // Bring in origin-destination pairs for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String header = sc_in.nextLine();
-        String od_id;
-        float laF;
-        float loF;
-        float laT;
-        float loT;
-        float idx = 0;
-        System.out.println("Input data points header: " + header);
-        while (sc_in.hasNext()) {
-            idx = idx + 1;
-            String line = sc_in.nextLine();
-            String[] vals = line.split(",");
-            od_id = vals[0];
-            loF = Float.valueOf(vals[1]);
-            laF = Float.valueOf(vals[2]);
-            loT = Float.valueOf(vals[3]);
-            laT = Float.valueOf(vals[4]);
-            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
-            id_to_points.add(od_id);
-        }
-        int numPairs = inputPoints.size();
-        System.out.println(numPairs + " origin-destination pairs.");
-
-        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
-        float[] points;
-        int routes_skipped = 0;
-        for (int i=0; i<numPairs; i++) {
-
-            if (i % 50 == 0) {
-                for (FileWriter fw : outputFiles) {
-                    fw.flush();
-                }
-            }
-
-            // Get Routes
-            points = inputPoints.get(i);
-            od_id = id_to_points.get(i);
-            GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                    setWeighting("fastest").
-                    setVehicle("car").
-                    setLocale(Locale.US).
-                    setAlgorithm("ksp");
-            GHResponse rsp = hopper.route(req);
-
-            // first check for errors
-            if (rsp.hasErrors()) {
-                // handle them!
-                System.out.println(rsp.getErrors().toString());
-                System.out.println(i + ": Skipping.");
-                String outputRow = od_id + ",main," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                        + ")]\"," + "-1,-1,-1,[],-1,-1,-1" + System.getProperty("line.separator");
-                for (FileWriter fw: outputFiles) {
-                    fw.write(outputRow);
-                }
-                routes_skipped++;
-                continue;
-            }
-
-            // Get All Routes (up to 10K right now)
-            List<PathWrapper> paths = rsp.getAll();
-            System.out.println("Num Responses: " + paths.size());
-
-            // Score each route on beauty to determine most beautiful
-            int j = 0;
-            float bestscore = -1000;
-            int routeidx = -1;
-            for (PathWrapper path : paths) {
-                float score = getBeauty(path);
-                if (score > bestscore) {
-                    bestscore = score;
-                    routeidx = j;
-                }
-                j++;
-            }
-            writeOutput(outputFiles.get(0), i, "Best", "beauty", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx)));
-            float maxBeauty = bestscore;
-
-            // Find least-beautiful route within similar distance constraints
-            double beautyDistance = paths.get(routeidx).getDistance();
-            j = 0;
-            bestscore = 1000;
-            routeidx = -1;
-            double uglydistance;
-            for (PathWrapper path : paths) {
-                uglydistance = path.getDistance();
-                if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
-                    float score = getBeauty(path);
-                    if (score < bestscore) {
-                        bestscore = score;
-                        routeidx = j;
-                    }
-                }
-                j++;
-            }
-            writeOutput(outputFiles.get(1), i, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx)));
-
-            // Simplest Route
-            j = 0;
-            bestscore = 10000;
-            routeidx = 0;
-            float beauty = -1;
-            for (PathWrapper path : paths) {
-                int score = path.getSimplicity();
-                if (score < bestscore) {
-                    bestscore = score;
-                    routeidx = j;
-                    beauty = getBeauty(path);
-                }
-                j++;
-            }
-            writeOutput(outputFiles.get(2), i, "Simp", "simple", od_id, paths.get(routeidx), beauty, getNumCTs(paths.get(routeidx)));
-            float minSimplicity = bestscore;
-
-            // Fastest Route
-            PathWrapper bestPath = paths.get(0);
-            beauty = getBeauty(bestPath);
-            writeOutput(outputFiles.get(3), i, "Fast", "Fastest", od_id, bestPath, beauty, getNumCTs(bestPath));
-
-            // Beautifully simple route
-            j = 0;
-            bestscore = 0;
-            routeidx = 0;
-            float combined;
-            for (PathWrapper path : paths) {
-                combined = (minSimplicity / path.getSimplicity()) + (getBeauty(path) / maxBeauty);
-                if (combined > bestscore) {
-                    bestscore = combined;
-                    routeidx = j;
-                }
-                j++;
-            }
-            writeOutput(outputFiles.get(6), i, "BeSi", "beauty-simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx)));
-
-            // Shortest Route
-            req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                    setWeighting("shortest").
-                    setVehicle("car").
-                    setLocale(Locale.US).
-                    setAlgorithm("dijkstrabi");
-            rsp = hopper.route(req);
-
-            // first check for errors
-            if (rsp.hasErrors()) {
-                // handle them!
-                System.out.println(rsp.getErrors().toString());
-                System.out.println(i + ": Skipping shortest path.");
-                continue;
-            }
-
-            // Get shortest path
-            bestPath = rsp.getBest();
-            beauty = getBeauty(bestPath);
-            writeOutput(outputFiles.get(4), i, "Shrt", "shortest", od_id, bestPath, beauty, getNumCTs(bestPath));
-
-            // Alternative Route
-            req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                    setWeighting("fastest").
-                    setVehicle("car").
-                    setLocale(Locale.US).
-                    setAlgorithm("alternative_route");
-            rsp = hopper.route(req);
-
-            // first check for errors
-            if (rsp.hasErrors()) {
-                // handle them!
-                System.out.println(rsp.getErrors().toString());
-                System.out.println(i + ": Skipping alternative path.");
-                String outputRow = od_id + ",alternative," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                        + ")]\"," + "-1,-1,-1,[],-1,-1,-1" + System.getProperty("line.separator");
-                FileWriter fw = outputFiles.get(5);
-                fw.write(outputRow);
-                continue;
-            }
-
-            // Get Alt Routes (should be 2, of which first is the fastest path)
-            paths = rsp.getAll();
-            if (paths.size() < 2) {
-                System.out.println(i + ": Did not return an alternative path.");
-                String outputRow = od_id + ",alternative," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                        + ")]\"," + "-1,-1,-1,[],-1,-1,-1" + System.getProperty("line.separator");
-                outputFiles.get(5).write(outputRow);
-                continue;
-            }
-            PathWrapper altpath = paths.get(1);
-            beauty = getBeauty(altpath);
-            writeOutput(outputFiles.get(5), i, "Altn", "altn", od_id, altpath, beauty, getNumCTs(altpath));
-
-
-        }
-
-        // Finished analysis: close filewriters and indicate how many paths skipped
-        System.out.println(routes_skipped + " routes skipped out of " + numPairs);
-        for (FileWriter fw : outputFiles) {
-            fw.close();
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // PBFs from: https://mapzen.com/data/metro-extracts/
-
-        //String city = args[0];
-        String city = "nyc";
-        runKSP ksp = new runKSP(city.toUpperCase(), "grid");
-        boolean matchexternal = false;
-        boolean getghroutes = true;
-
-        if (matchexternal) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.getGridCTs();
-            ksp.prepMapMatcher();  // score external API routes
-            String inputfolder = "../data/intermediate/";
-            String outputfolder = "../data/output/";
-            ArrayList<String> platforms = new ArrayList<>();
-            platforms.add("google");
-            platforms.add("mapquest");
-            ArrayList<String> conditions = new ArrayList<>();
-            conditions.add("traffic");
-            conditions.add("notraffic");
-            ArrayList<String> routetypes = new ArrayList<>();
-            routetypes.add("main");
-            routetypes.add("alt");
-            for (String platform : platforms) {
-                for (String condition : conditions) {
-                    for (String routetype : routetypes) {
-                        ksp.PointsToPath(inputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
-                    }
-                }
-            }
-        }
-
-        if (getghroutes) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.getGridCTs();
-            ksp.process_routes();  // get Graphhopper routes
-        }
-    }
-}
