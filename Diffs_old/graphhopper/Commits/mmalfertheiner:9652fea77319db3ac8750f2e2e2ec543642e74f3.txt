diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 0c1f909574..bc8f46f57a 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -16,7 +16,7 @@
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
  * henningvs, doc improvements
- * jansoe, one of the core developers
+ * jansoe, many improvements regarding A* algorithm, forcing direction, roundabouts etc
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
  * karussell, one of the core developers
@@ -25,8 +25,10 @@
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
  * ratrun, route relations, GPX information, bike handling etc
+ * rajanski, script to do routing via PostGIS
  * rodneyodonnell, improved dead end removal and fords
  * rodo, more descriptions
+ * Svantulden, improved documentation and nearest API
 
 # Translations
 
diff --git a/README.md b/README.md
index 726eaf0a82..79523dd23d 100644
--- a/README.md
+++ b/README.md
@@ -12,10 +12,11 @@ See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
 
 [![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
-GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api), which provides 
-routing and matrix routing through GraphHopper and also a fast address search via [Photon](https://github.com/komoot/photon).
-Additionally the map tiles from various Providers are used and all is 
-available for free for a nice route planning experience!
+GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api) under the hood, which provides 
+a Routing API via GraphHopper, a Route Optimization API via [jsprit](http://jsprit.github.io/), a fast Matrix API
+and an address search via [Photon](https://github.com/komoot/photon). Additionally the map tiles from various providers are used 
+where the default is [Omniscale](http://omniscale.com/), and all is available for free, via encrypted connections and from German servers
+for a nice and private route planning experience!
 
 
 GraphHopper for Mobile
@@ -29,7 +30,7 @@ and [iOS](http://github.com/graphhopper/graphhopper-ios)
 Get Started
 ---------------
 
-Read through our Documentation ([0.4](https://github.com/graphhopper/graphhopper/blob/0.4/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
+Read through our Documentation ([0.5](https://github.com/graphhopper/graphhopper/blob/0.5/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
 and sign up to the [mailing list](http://graphhopper.com/#developers).
 
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 152d1dbb52..088d4f2d5c 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -35,16 +35,16 @@ configurations.all {
  **/
 
 dependencies {
-    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.5-SNAPSHOT') {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.6-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.1'
-    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.1'
-    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.1'
-    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.1'
+    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.2'
+    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.2'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.2'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.2'
 
     compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.12'
     compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.12'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index c76f32f7cc..5ac47188b4 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.5-SNAPSHOT</version>
+    <version>0.6-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -16,10 +16,10 @@
         <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.5-SNAPSHOT</version>
+        <version>0.6-SNAPSHOT</version>
     </parent>
     <properties>
-        <mapsforge.version>0.5.1</mapsforge.version>
+        <mapsforge.version>0.5.2</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index b75c9b5e46..d846fd1d9c 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -72,7 +72,7 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "https://graphhopper.com/public/maps/0.5/";
+    private String fileListURL = "https://graphhopper.com/public/maps/0.6/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
@@ -180,12 +180,7 @@ protected void onDestroy()
         System.gc();
 
         // Cleanup Mapsforge
-        this.mapView.getLayerManager().getLayers().remove(this.tileRendererLayer);
-        this.tileRendererLayer.onDestroy();
-        this.tileCache.destroy();
-        this.mapView.getModel().mapViewPosition.destroy();
-        this.mapView.destroy();
-        AndroidGraphicFactory.clearResourceMemoryCache();
+        this.mapView.destroyAll();
     }
 
     boolean isReady()
@@ -439,7 +434,7 @@ protected Path saveDoInBackground( Void... v ) throws Exception
             {
                 GraphHopper tmpHopp = new GraphHopper().forMobile();
                 tmpHopp.load(new File(mapsFolder, currentArea).getAbsolutePath());
-                log("found graph " + tmpHopp.getGraph().toString() + ", nodes:" + tmpHopp.getGraph().getNodes());
+                log("found graph " + tmpHopp.getGraphHopperStorage().toString() + ", nodes:" + tmpHopp.getGraphHopperStorage().getNodes());
                 hopper = tmpHopp;
                 return null;
             }
@@ -469,16 +464,13 @@ private Polyline createPolyline( GHResponse response )
     {
         Paint paintStroke = AndroidGraphicFactory.INSTANCE.createPaint();
         paintStroke.setStyle(Style.STROKE);
-        paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
+        paintStroke.setColor(Color.argb(128, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
                 {
                         25, 15
                 });
         paintStroke.setStrokeWidth(8);
 
-        // TODO: new mapsforge version wants an mapsforge-paint, not an android paint.
-        // This doesn't seem to support transparceny
-        //paintStroke.setAlpha(128);
         Polyline line = new Polyline((org.mapsforge.core.graphics.Paint) paintStroke, AndroidGraphicFactory.INSTANCE);
         List<LatLong> geoPoints = line.getLatLongs();
         PointList tmp = response.getPoints();
diff --git a/config-example.properties b/config-example.properties
index 29f56a2fcb..9464954028 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -36,7 +36,7 @@ graph.dataaccess=RAM_STORE
 #
 # By default the speed-up mode with the 'fastest' weighting is used. Internally a graph preparation via
 # contraction hierarchies is done to speed routing up. This requires more RAM/disc space for holding the
-# graph but less for every request. Also only the first vehicle of the flagEncoders list will be prepared.
+# graph but less for every request.
 # prepare.chWeighting=fastest
 #
 # Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 4504ea36df..f0775a9a96 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,15 @@
 0.5
+    Several names have changed see #466, #467, #468
+    GraphHopper.optimize removed use postProcessing instead
+    method GraphHopper.getGraph() changed to getGraphHopperStorage()
+    the interface GraphStorage does no longer extend from the Graph interface. Use GraphHopperStorage (which implements the Graph interface via the base graph) or only Graph instead
+    now it is necessary to call baseGraph/chGraph.freeze in order to use the chGraph (to simply determine when an edgeId is a shortcut)    
+    LevelGraphStorage is now a GraphHopperStorage with an additional ch graph (CHGraphImpl)
+    GraphHopperStorage implements now the Graph interface and delegates all necessary methods to the underlying base graph. To do routing you call getGraph(CHGraph.class or Graph.class) where the parameter Graph.class returns the base graph and the behaviour is identical to GraphHopperStorage itself
+    renamed LevelGraph* to CHGraph*
+    renamed NoGraphExtension to NoOpExtension
+    removed visitedNodes method in GraphHopper replaced with per response information: response.getHints().getLong("visited_nodes.sum", 0)
+    added ability to store hints in GHResponse which will be forwarded to the json too
     breaking change in HTTP API: error JSON format changed to be message:"" instead of within info.errors, see updated api documentation
     made GHResponse.getMillis, Path.getMillis, GPXEntry.getMillis deprecated, use getTime instead
     in AbstractFlagEncoder, parse*() and getStr() are now deprecated, use properties.get* instead
diff --git a/core/files/map-sidewalk-no.osm.gz b/core/files/map-sidewalk-no.osm.gz
new file mode 100644
index 0000000000..adf7ddd848
Binary files /dev/null and b/core/files/map-sidewalk-no.osm.gz differ
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index 253bd32cb4..aa503cff5e 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP ar bg ca cz de_DE el es fa fil fi fr gl he hsb hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
+translations="en_US SKIP ar ast bg ca cs_CZ da_DK de_DE el es fa fil fi fr gl he hsb hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 451f8706ad..b4ec077a2a 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper</artifactId>
     <name>GraphHopper</name>
-    <version>0.5-SNAPSHOT</version>
+    <version>0.6-SNAPSHOT</version>
     <packaging>jar</packaging> 
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine 
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.5-SNAPSHOT</version>
+        <version>0.6-SNAPSHOT</version>
     </parent>
         
     <properties>  
@@ -70,7 +70,7 @@
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
-            <version>1.5</version>
+            <version>2.0.1</version>
         </dependency>
         
         <dependency>
@@ -81,7 +81,7 @@
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
-            <version>0.43.1</version>
+            <version>0.44.1</version>
         </dependency>
 
         <dependency>
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index 4337f00b3d..86bbe96300 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -28,7 +28,7 @@
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
- * <p/>
+ * <p>
  *
  * @author Peter Karich
  * @author ratrun
@@ -60,8 +60,8 @@ public GHRequest( int size )
 
     /**
      * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
-     * with a preferred start and end heading.
-     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference.
+     * with a preferred start and end heading. Headings are north based azimuth (clockwise) in (0,
+     * 360) or NaN for equal preference.
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon,
                       double startHeading, double endHeading )
@@ -77,10 +77,9 @@ public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
-
     /**
-     * Set routing request from specified startPlace to endPlace with a preferred start and end heading.
-     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     * Set routing request from specified startPlace to endPlace with a preferred start and end
+     * heading. Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
     public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading )
     {
@@ -106,19 +105,19 @@ public GHRequest( GHPoint startPlace, GHPoint endPlace )
         this(startPlace, endPlace, Double.NaN, Double.NaN);
     }
 
-
     /**
      * Set routing request
-     *
-     * @param points          List of stopover points in order: start, 1st stop, 2nd stop, ..., end
-     * @param favoredHeadings List of favored headings for starting (start point) and arrival (via and end points)
-     *                        Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     * <p>
+     * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     * @param favoredHeadings List of favored headings for starting (start point) and arrival (via
+     * and end points) Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal
+     * preference
      */
     public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
     {
         if (points.size() != favoredHeadings.size())
-            throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size() +
-                    ") must match size of points (" + points.size() + ")");
+            throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size()
+                    + ") must match size of points (" + points.size() + ")");
 
         for (Double heading : favoredHeadings)
         {
@@ -130,7 +129,7 @@ public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
 
     /**
      * Set routing request
-     *
+     * <p>
      * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
      */
     public GHRequest( List<GHPoint> points )
@@ -140,19 +139,18 @@ public GHRequest( List<GHPoint> points )
 
     /**
      * Add stopover point to routing request.
-     *
-     * @param point          geographical position (see GHPoint)
+     * <p>
+     * @param point geographical position (see GHPoint)
      * @param favoredHeading north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest addPoint( GHPoint point, Double favoredHeading )
+    public GHRequest addPoint( GHPoint point, double favoredHeading )
     {
         if (point == null)
             throw new IllegalArgumentException("point cannot be null");
 
-
         if (!possibleToAdd)
             throw new IllegalStateException("Please call empty constructor if you intent to use "
-                    + "more than two places via addPlace method.");
+                    + "more than two places via addPoint method.");
 
         points.add(point);
         validateAzimuthValue(favoredHeading);
@@ -162,7 +160,7 @@ public GHRequest addPoint( GHPoint point, Double favoredHeading )
 
     /**
      * Add stopover point to routing request.
-     *
+     * <p>
      * @param point geographical position (see GHPoint)
      */
     public GHRequest addPoint( GHPoint point )
@@ -185,19 +183,16 @@ public double getFavoredHeading( int i )
     public boolean hasFavoredHeading( int i )
     {
         if (i >= favoredHeadings.size())
-            throw new IndexOutOfBoundsException("Index: " + i + " too large for list of size " + favoredHeadings.size());
+            return false;
 
         return !Double.isNaN(favoredHeadings.get(i));
     }
 
-    // validate Azimuth entry
-    private void validateAzimuthValue( Double heading )
+    private void validateAzimuthValue( double heading )
     {
-        // heading must be in (0, 360) oder Nan
+        // heading must be in (0, 360) oder NaN
         if (!Double.isNaN(heading) && ((Double.compare(heading, 360) > 0) || (Double.compare(heading, 0) < 0)))
-        {
             throw new IllegalArgumentException("Heading " + heading + " must be in range (0,360) or NaN");
-        }
     }
 
     public List<GHPoint> getPoints()
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 9aebf05720..0742ff772c 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -18,6 +18,7 @@
 package com.graphhopper;
 
 import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
@@ -26,7 +27,7 @@
 
 /**
  * Wrapper to simplify output of GraphHopper.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHResponse
@@ -37,7 +38,8 @@
     private double distance;
     private double routeWeight;
     private long time;
-    private InstructionList instructions = null;
+    private InstructionList instructions;
+    private final PMap hintsMap = new PMap();
 
     public GHResponse()
     {
@@ -111,7 +113,7 @@ public GHResponse setDistance( double distance )
     /**
      * This method returns the distance of the path. Always prefer this method over
      * getPoints().calcDistance
-     * <p/>
+     * <p>
      * @return distance in meter
      */
     public double getDistance()
@@ -215,4 +217,9 @@ public InstructionList getInstructions()
 
         return instructions;
     }
+
+    public PMap getHints()
+    {
+        return hintsMap;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f8017dabfd..9cbd014a1c 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -39,11 +39,11 @@
 import java.io.IOException;
 import java.text.SimpleDateFormat;
 import java.util.*;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.Map.Entry;
 
 /**
  * Easy to use access point to configure import and (offline) routing.
- * <p/>
+ * <p>
  *
  * @author Peter Karich
  * @see GraphHopperAPI
@@ -52,7 +52,7 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
-    private GraphStorage graph;
+    private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
     private int defaultSegmentSize = -1;
     private String ghLocation = "";
@@ -69,7 +69,7 @@
     private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private RoutingAlgorithmFactory algoFactory;
+    private final Map<Weighting, RoutingAlgorithmFactory> algoFactories = new LinkedHashMap<Weighting, RoutingAlgorithmFactory>();
     // for index
     private LocationIndex locationIndex;
     private int preciseIndexResolution = 300;
@@ -81,10 +81,11 @@
     private boolean doPrepare = true;
     private boolean chEnabled = true;
     private String chWeightingStr = "fastest";
-    private int periodicUpdates = -1;
-    private int lazyUpdates = -1;
-    private int neighborUpdates = -1;
-    private double logMessages = -1;
+    private int preparePeriodicUpdates = -1;
+    private int prepareLazyUpdates = -1;
+    private int prepareNeighborUpdates = -1;
+    private int prepareContractedNodes = -1;
+    private double prepareLogMessages = -1;
     // for OSM import
     private String osmFile;
     private double osmReaderWayPointMaxDistance = 1;
@@ -93,7 +94,6 @@
     // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final AtomicLong visitedSum = new AtomicLong(0);
 
     public GraphHopper()
     {
@@ -102,9 +102,9 @@ public GraphHopper()
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph( GraphHopperStorage g )
     {
-        this.graph = g;
+        this.ghStorage = g;
         fullyLoaded = true;
         initLocationIndex();
         return this;
@@ -124,6 +124,9 @@ public GraphHopper setEncodingManager( EncodingManager em )
         return this;
     }
 
+    /**
+     * @return the first flag encoder of the encoding manager
+     */
     FlagEncoder getDefaultVehicle()
     {
         if (encodingManager == null)
@@ -229,10 +232,11 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
-    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    public GraphHopper setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
     {
         this.minNetworkSize = minNetworkSize;
         this.minOneWayNetworkSize = minOneWayNetworkSize;
+        return this;
     }
 
     /**
@@ -249,7 +253,7 @@ public GraphHopper setInMemory()
      * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
-     * <p/>
+     * <p>
      *
      * @param storeOnFlush true by default
      */
@@ -285,10 +289,9 @@ private GraphHopper setUnsafeMemory()
 
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
-     * <p/>
+     * <p>
      *
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
-     * @see #setCHEnable(boolean)
      */
     public GraphHopper setCHWeighting( String weighting )
     {
@@ -306,6 +309,7 @@ public String getCHWeighting()
      * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
      * the full usage of CH use setCHEnable(false) instead.
      */
+    @Deprecated
     public GraphHopper setDoPrepare( boolean doPrepare )
     {
         this.doPrepare = doPrepare;
@@ -316,14 +320,13 @@ public GraphHopper setDoPrepare( boolean doPrepare )
      * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
      * Disabling CH is only recommended for short routes or in combination with
      * setDefaultWeightLimit and called flexibility mode
-     * <p/>
+     * <p>
      *
      * @see #setDefaultWeightLimit(double)
      */
     public GraphHopper setCHEnable( boolean enable )
     {
         ensureNotLoaded();
-        algoFactory = null;
         chEnabled = enable;
         return this;
     }
@@ -430,21 +433,21 @@ public String getOSMFile()
 
     /**
      * The underlying graph used in algorithms.
-     * <p/>
+     * <p>
      *
      * @throws IllegalStateException if graph is not instantiated.
      */
-    public GraphStorage getGraph()
+    public GraphHopperStorage getGraphHopperStorage()
     {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
+        if (ghStorage == null)
+            throw new IllegalStateException("GraphHopper storage not initialized");
 
-        return graph;
+        return ghStorage;
     }
 
-    public void setGraph( GraphStorage graph )
+    public void setGraphHopperStorage( GraphHopperStorage ghStorage )
     {
-        this.graph = graph;
+        this.ghStorage = ghStorage;
         fullyLoaded = true;
     }
 
@@ -455,7 +458,7 @@ protected void setLocationIndex( LocationIndex locationIndex )
 
     /**
      * The location index created from the graph.
-     * <p/>
+     * <p>
      *
      * @throws IllegalStateException if index is not initialized
      */
@@ -561,17 +564,19 @@ public GraphHopper init( CmdArgs args )
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
         minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
-        // prepare CH
+        // prepare CH        
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+
         String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
         chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
         if (chEnabled)
             setCHWeighting(tmpCHWeighting);
 
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
+        preparePeriodicUpdates = args.getInt("prepare.updates.periodic", preparePeriodicUpdates);
+        prepareLazyUpdates = args.getInt("prepare.updates.lazy", prepareLazyUpdates);
+        prepareNeighborUpdates = args.getInt("prepare.updates.neighbor", prepareNeighborUpdates);
+        prepareContractedNodes = args.getInt("prepare.contracted-nodes", prepareContractedNodes);
+        prepareLogMessages = args.getDouble("prepare.logmessages", prepareLogMessages);
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
@@ -594,8 +599,8 @@ public GraphHopper init( CmdArgs args )
     private void printInfo()
     {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+        if (ghStorage != null)
+            logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
     }
 
     /**
@@ -625,7 +630,7 @@ private GraphHopper process( String graphHopperLocation )
         Lock lock = null;
         try
         {
-            if (graph.getDirectory().getDefaultType().isStoring())
+            if (ghStorage.getDirectory().getDefaultType().isStoring())
             {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
@@ -636,13 +641,12 @@ private GraphHopper process( String graphHopperLocation )
             try
             {
                 importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+                ghStorage.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
             } catch (IOException ex)
             {
                 throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
             }
             cleanUp();
-            optimize();
             postProcessing();
             flush();
         } finally
@@ -656,7 +660,7 @@ private GraphHopper process( String graphHopperLocation )
     protected DataReader importData() throws IOException
     {
         ensureWriteAccess();
-        if (graph == null)
+        if (ghStorage == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
         if (osmFile == null)
@@ -664,15 +668,15 @@ protected DataReader importData() throws IOException
                     + " but also cannot import from OSM file as it wasn't specified!");
 
         encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+        DataReader reader = createReader(ghStorage);
+        logger.info("using " + ghStorage.toString() + ", memory:" + Helper.getMemInfo());
         reader.readGraph();
         return reader;
     }
 
-    protected DataReader createReader( GraphStorage tmpGraph )
+    protected DataReader createReader( GraphHopperStorage ghStorage )
     {
-        return initOSMReader(new OSMReader(tmpGraph));
+        return initOSMReader(new OSMReader(ghStorage));
     }
 
     protected OSMReader initOSMReader( OSMReader reader )
@@ -691,7 +695,7 @@ protected OSMReader initOSMReader( OSMReader reader )
 
     /**
      * Opens existing graph.
-     * <p/>
+     * <p>
      *
      * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
      * too)
@@ -740,21 +744,23 @@ public boolean load( String graphHopperFolder )
             dataAccessType = DAType.MMAP_RO;
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+        GraphExtension ext = encodingManager.needsTurnCostsSupport()
+                ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
         if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
-        else
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+        {
+            initCHAlgoFactories();
+            ghStorage = new GraphHopperStorage(new ArrayList<Weighting>(algoFactories.keySet()), dir, encodingManager, hasElevation(), ext);
+        } else
+            ghStorage = new GraphHopperStorage(dir, encodingManager, hasElevation(), ext);
 
-        graph.setSegmentSize(defaultSegmentSize);
+        ghStorage.setSegmentSize(defaultSegmentSize);
 
         Lock lock = null;
         try
         {
             // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
             // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+            if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites())
             {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
@@ -762,7 +768,7 @@ else if (encodingManager.needsTurnCostsSupport())
                     throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
             }
 
-            if (!graph.loadExisting())
+            if (!ghStorage.loadExisting())
                 return false;
 
             postProcessing();
@@ -775,17 +781,55 @@ else if (encodingManager.needsTurnCostsSupport())
         }
     }
 
-    public RoutingAlgorithmFactory getAlgorithmFactory()
+    public RoutingAlgorithmFactory getAlgorithmFactory( Weighting weighting )
+    {
+        RoutingAlgorithmFactory raf = algoFactories.get(weighting);
+        if (raf == null)
+            putAlgorithmFactory(weighting, raf = new RoutingAlgorithmFactorySimple());
+
+        return raf;
+    }
+
+    public Collection<RoutingAlgorithmFactory> getAlgorithmFactories()
     {
-        if (algoFactory == null)
-            this.algoFactory = new RoutingAlgorithmFactorySimple();
+        return algoFactories.values();
+    }
 
-        return algoFactory;
+    public GraphHopper putAlgorithmFactory( Weighting weighting, RoutingAlgorithmFactory algoFactory )
+    {
+        algoFactories.put(weighting, algoFactory);
+        return this;
+    }
+
+    private void initCHAlgoFactories()
+    {
+        if (algoFactories.isEmpty())
+            for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
+            {
+                Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), encoder);
+                algoFactories.put(weighting, null);
+            }
     }
 
-    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+    protected void createCHPreparations()
     {
-        this.algoFactory = algoFactory;
+        if (algoFactories.isEmpty())
+            throw new IllegalStateException("No algorithm factories found. Call load before?");
+
+        Set<Weighting> set = new LinkedHashSet<Weighting>(algoFactories.keySet());
+        algoFactories.clear();
+        for (Weighting weighting : set)
+        {
+            PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
+                    new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class, weighting),
+                    weighting.getFlagEncoder(), weighting, traversalMode);
+            tmpPrepareCH.setPeriodicUpdates(preparePeriodicUpdates).
+                    setLazyUpdates(prepareLazyUpdates).
+                    setNeighborUpdates(prepareNeighborUpdates).
+                    setLogMessages(prepareLogMessages);
+
+            algoFactories.put(weighting, tmpPrepareCH);
+        }
     }
 
     /**
@@ -793,69 +837,75 @@ public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
      */
     protected void postProcessing()
     {
-        initLocationIndex();
-        if (chEnabled)
+        // Later: move this into the GraphStorage.optimize method
+        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
+        if (sortGraph)
         {
-            if (algoFactory != null)
-                throw new IllegalStateException("Customizing of the routing algorithm factory is currently not supported");
+            if (ghStorage.isCHPossible() && isPrepared())
+                throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
 
-            algoFactory = createPrepare();
+            GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
+            GHUtility.sortDFS(ghStorage, newGraph);
+            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+            ghStorage = newGraph;
         }
 
+        initLocationIndex();
+        if (chEnabled)
+            createCHPreparations();
+
         if (!isPrepared())
             prepare();
     }
 
     private boolean isPrepared()
     {
-        return "true".equals(graph.getProperties().get("prepare.done"));
-    }
-
-    protected RoutingAlgorithmFactory createPrepare()
-    {
-        FlagEncoder defaultVehicle = getDefaultVehicle();
-        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
-                setLazyUpdates(lazyUpdates).
-                setNeighborUpdates(neighborUpdates).
-                setLogMessages(logMessages);
-
-        return tmpPrepareCH;
+        return "true".equals(ghStorage.getProperties().get("prepare.done"));
     }
 
     /**
      * Based on the weightingParameters and the specified vehicle a Weighting instance can be
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
-     * <p/>
+     * <p>
      *
      * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
-     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
+     * GHRequest.getHints or directly via "&amp;api.xy=" from the URL of the web UI
      * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
      * @see WeightingMap
      */
     public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
-        String weighting = weightingMap.getWeighting();
-        Weighting result;
+        String weighting = weightingMap.getWeighting().toLowerCase();
 
         if ("shortest".equalsIgnoreCase(weighting))
         {
-            result = new ShortestWeighting();
+            return new ShortestWeighting(encoder);
         } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
         {
             if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder, weightingMap);
+                return new PriorityWeighting(encoder, weightingMap);
             else
-                result = new FastestWeighting(encoder, weightingMap);
-        } else
+                return new FastestWeighting(encoder, weightingMap);
+        }
+
+        throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+    }
+
+    public Weighting getWeightingForCH( WeightingMap weightingMap, FlagEncoder encoder )
+    {
+        String encoderStr = encoder.toString().toLowerCase();
+        String weightingStr = weightingMap.getWeighting().toLowerCase();
+        for (Weighting w : algoFactories.keySet())
         {
-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+            // TODO too loose matching? see #490
+            String str = w.toString().toLowerCase();
+            if (str.contains(weightingStr) && str.contains(encoderStr))
+                return w;
         }
-        return result;
+
+        throw new IllegalStateException("No weighting found for request " + weightingMap + ", encoder:" + encoder + ", " + algoFactories);
     }
 
     /**
@@ -893,10 +943,10 @@ public GHResponse route( GHRequest request )
 
     protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
-        if (graph == null || !fullyLoaded)
+        if (ghStorage == null || !fullyLoaded)
             throw new IllegalStateException("Call load or importOrLoad before routing");
 
-        if (graph.isClosed())
+        if (ghStorage.isClosed())
             throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
         String vehicle = request.getVehicle();
@@ -928,8 +978,7 @@ public GHResponse route( GHRequest request )
             return Collections.emptyList();
         }
 
-        visitedSum.set(0);
-
+        long visitedNodesSum = 0;
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
 
@@ -950,35 +999,37 @@ public GHResponse route( GHRequest request )
 
         String debug = "idLookup:" + sw.stop().getSeconds() + "s";
 
-        QueryGraph queryGraph;
-        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+        Weighting weighting;
+        Graph routingGraph = ghStorage;
+
+        if (chEnabled)
         {
-            // fall back to normal traversing
-            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
-            queryGraph = new QueryGraph(graph.getBaseGraph());
+            boolean forceCHHeading = request.getHints().getBool("force_heading_ch", false);
+            if (!forceCHHeading && request.hasFavoredHeading(0))
+                throw new IllegalStateException("Heading is not (fully) supported for CHGraph. See issue #483");
+            weighting = getWeightingForCH(request.getHints(), encoder);
+            routingGraph = ghStorage.getGraph(CHGraph.class, weighting);
         } else
-        {
-            queryGraph = new QueryGraph(graph);
-        }
+            weighting = createWeighting(request.getHints(), encoder);
 
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(weighting);
+        QueryGraph queryGraph = new QueryGraph(routingGraph);
         queryGraph.lookup(qResults);
+        weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
         List<Path> paths = new ArrayList<Path>(points.size() - 1);
         QueryResult fromQResult = qResults.get(0);
-        Weighting weighting = createWeighting(request.getHints(), encoder);
-        weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
         double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
         AlgorithmOptions algoOpts = AlgorithmOptions.start().
                 algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                hints(request.getHints()).
                 build();
 
         boolean viaTurnPenalty = request.getHints().getBool("pass_through", false);
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
-
             if (placeIndex == 1)
             {
                 // enforce start direction
@@ -1011,7 +1062,7 @@ public GHResponse route( GHRequest request )
             // reset all direction enforcements in queryGraph to avoid influencing next path
             queryGraph.clearUnfavoredStatus();
 
-            visitedSum.addAndGet(algo.getVisitedNodes());
+            visitedNodesSum += algo.getVisitedNodes();
             fromQResult = toQResult;
         }
 
@@ -1022,12 +1073,14 @@ public GHResponse route( GHRequest request )
             throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
         rsp.setDebugInfo(debug);
+        rsp.getHints().put("visited_nodes.sum", visitedNodesSum);
+        rsp.getHints().put("visited_nodes.average", (float) visitedNodesSum / (points.size() - 1));
         return paths;
     }
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
+        LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
         tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
@@ -1047,63 +1100,54 @@ protected void initLocationIndex()
         if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
-        locationIndex = createLocationIndex(graph.getDirectory());
-    }
-
-    protected void optimize()
-    {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
-
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
-            if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
-
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
+        locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && getAlgorithmFactory() instanceof PrepareContractionHierarchies;
+        boolean tmpPrepare = doPrepare && chEnabled;
         if (tmpPrepare)
         {
             ensureWriteAccess();
-            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
-            ((PrepareContractionHierarchies) getAlgorithmFactory()).doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+            ghStorage.freeze();
+
+            int counter = 0;
+            for (Entry<Weighting, RoutingAlgorithmFactory> entry : algoFactories.entrySet())
+            {
+                logger.info((++counter) + "/" + algoFactories.entrySet().size() + " calling prepare.doWork for " + entry.getKey() + " ... (" + Helper.getMemInfo() + ")");
+                if (!(entry.getValue() instanceof PrepareContractionHierarchies))
+                    throw new IllegalStateException("RoutingAlgorithmFactory is not suited for CH preparation " + entry.getValue());
+
+                ((PrepareContractionHierarchies) entry.getValue()).doWork();
+            }
+            ghStorage.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
-        graph.getProperties().put("prepare.done", tmpPrepare);
+        ghStorage.getProperties().put("prepare.done", tmpPrepare);
     }
 
+    /**
+     * Internal method to clean up the graph.
+     */
     protected void cleanUp()
     {
-        int prevNodeCount = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
+        int prevNodeCount = ghStorage.getNodes();
+        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(ghStorage, encodingManager.fetchEdgeEncoders());
         preparation.setMinNetworkSize(minNetworkSize);
         preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
-        int currNodeCount = graph.getNodes();
-        int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + currNodeCount
-                + ", there were " + preparation.getSubNetworks()
+        int currNodeCount = ghStorage.getNodes();
+        logger.info("edges: " + ghStorage.getAllEdges().getMaxId() + ", nodes " + currNodeCount
+                + ", there were " + preparation.getMaxSubnetworks()
                 + " subnetworks. removed them => " + (prevNodeCount - currNodeCount)
-                + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+                + " less nodes");
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
+        logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
                 + Helper.getMemInfo() + ")");
-        graph.flush();
+        ghStorage.flush();
         fullyLoaded = true;
     }
 
@@ -1113,8 +1157,8 @@ protected void flush()
      */
     public void close()
     {
-        if (graph != null)
-            graph.close();
+        if (ghStorage != null)
+            ghStorage.close();
 
         if (locationIndex != null)
             locationIndex.close();
@@ -1159,13 +1203,4 @@ protected void ensureWriteAccess()
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
-
-    /**
-     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
-     * debugging purposes.
-     */
-    long getVisitedSum()
-    {
-        return visitedSum.get();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index f1bc8e66d8..11a9123a80 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -19,7 +19,7 @@
 
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface GraphHopperAPI
@@ -27,14 +27,14 @@
     /**
      * Connects to the specified service (graphhopper URL) or loads a graph from the graphhopper
      * folder.
-     * <p/>
+     * <p>
      * @return true if successfully connected or loaded
      */
     boolean load( String urlOrFile );
 
     /**
      * Calculates the path from specified request visiting the specified locations.
-     * <p/>
+     * <p>
      * @return the response with the route and possible errors
      */
     GHResponse route( GHRequest request );
diff --git a/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java b/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java
index 40b23f8dc2..58f79ab968 100644
--- a/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java
+++ b/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java
@@ -22,7 +22,7 @@
 
 /**
  * Segmented HashMap to make it possible to store more than Integer.MAX values.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BigLongIntMap implements LongIntMap
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 6fcb3fc3aa..72f839d30c 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -32,7 +32,7 @@
 /**
  * Stores the entries in compressed segments. The methods de(compress) are taken from lucene
  * CompressionTools. Before accessing the stored values be sure you called flush.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class CompressedArray
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSet.java b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
index 914b892b7a..2b07459703 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
@@ -20,7 +20,7 @@
 /**
  * Wrapper interface of an integer container for different implementations like OpenBitset, BitSet,
  * ...
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface GHBitSet
@@ -33,14 +33,9 @@
 
     void clear();
 
-    /**
-     * Ensures that the specified index is valid and can be accessed.
-     */
-    void ensureCapacity( int index );
-
     /**
      * Searches for a greater or equal entry and returns it.
-     * <p/>
+     * <p>
      * @return -1 if nothing found
      */
     int next( int index );
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index 7933a9f6f9..20ae8c5433 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -34,41 +34,36 @@ public GHBitSetImpl( int nbits )
     }
 
     @Override
-    public boolean contains( int index )
+    public final boolean contains( int index )
     {
         return super.get(index);
     }
 
     @Override
-    public void add( int index )
+    public final void add( int index )
     {
         super.set(index);
     }
 
     @Override
-    public int getCardinality()
+    public final int getCardinality()
     {
         return super.cardinality();
     }
 
     @Override
-    public void ensureCapacity( int size )
-    {
-    }
-
-    @Override
-    public int next( int index )
+    public final int next( int index )
     {
         return super.nextSetBit(index);
     }
 
-    public int nextClear( int index )
+    public final int nextClear( int index )
     {
         return super.nextClearBit(index);
     }
 
     @Override
-    public GHBitSet copyTo( GHBitSet bs )
+    public final GHBitSet copyTo( GHBitSet bs )
     {
         bs.clear();
         if (bs instanceof GHBitSetImpl)
@@ -77,7 +72,6 @@ public GHBitSet copyTo( GHBitSet bs )
         } else
         {
             int len = size();
-            bs.ensureCapacity(len);
             for (int index = super.nextSetBit(0); index >= 0;
                  index = super.nextSetBit(index + 1))
             {
diff --git a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
index 53e9a4684f..fbe6689334 100644
--- a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
+++ b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
@@ -27,7 +27,7 @@
 /**
  * An in-memory simple B-Tree. Later we'll use DataAccess to allow on-disc storage for very large
  * data sets. Delete not supported.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHLongIntBTree implements LongIntMap
diff --git a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
index 7b17fad7e7..41b097442f 100644
--- a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
+++ b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
@@ -26,7 +26,7 @@
 /**
  * A priority queue implemented by a treemap to allow fast key update. Or should we use a standard
  * b-tree?
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHSortedCollection
diff --git a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
index 74a0f512c9..ae25025648 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
@@ -22,7 +22,7 @@
 
 /**
  * Implements the bitset interface via a trove THashSet. More efficient for a few entries.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHTBitSet implements GHBitSet
@@ -45,42 +45,37 @@ public GHTBitSet()
     }
 
     @Override
-    public boolean contains( int index )
+    public final boolean contains( int index )
     {
         return tHash.contains(index);
     }
 
     @Override
-    public void add( int index )
+    public final void add( int index )
     {
         tHash.add(index);
     }
 
     @Override
-    public String toString()
+    public final String toString()
     {
         return tHash.toString();
     }
 
     @Override
-    public int getCardinality()
+    public final int getCardinality()
     {
         return tHash.size();
     }
 
     @Override
-    public void clear()
+    public final void clear()
     {
         tHash.clear();
     }
 
     @Override
-    public void ensureCapacity( int index )
-    {
-    }
-
-    @Override
-    public GHBitSet copyTo( GHBitSet bs )
+    public final GHBitSet copyTo( GHBitSet bs )
     {
         bs.clear();
         if (bs instanceof GHTBitSet)
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index 78bf9bc378..463c1fc99a 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -24,7 +24,7 @@
 /**
  * A priority queue implemented by a TreeMap. As the tree map does not allow duplicated we compose
  * the key via priority | nodeId.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHTreeMapComposed
diff --git a/core/src/main/java/com/graphhopper/coll/MapEntry.java b/core/src/main/java/com/graphhopper/coll/MapEntry.java
index 5c05ef30f5..b5fd9eec8f 100644
--- a/core/src/main/java/com/graphhopper/coll/MapEntry.java
+++ b/core/src/main/java/com/graphhopper/coll/MapEntry.java
@@ -22,7 +22,7 @@
 
 /**
  * Simple impl of Map.Entry. So that we can have ordered maps.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class MapEntry<K, V> implements Map.Entry<K, V>, Serializable
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 96c55d345f..0b5a30be18 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -24,8 +24,8 @@
 
 /**
  * This is a special purpose map for writing increasing OSM IDs with consecutive values. It stores
- * long->int in a memory friendly way and but does NOT provide O(1) access.
- * <p/>
+ * a map from long to int in a memory friendly way and but does NOT provide O(1) access.
+ * <p>
  * @author Peter Karich
  */
 public class OSMIDMap implements LongIntMap
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
index e1f451a42d..693149ee47 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
@@ -25,7 +25,7 @@
 /**
  * This is a special purpose map for writing increasing OSM IDs with consecutive values. It stores
  * the keys in vlong format and values are determined by the resulting index.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class OSMIDSegmentedMap implements LongIntMap
diff --git a/core/src/main/java/com/graphhopper/coll/SparseArray.java b/core/src/main/java/com/graphhopper/coll/SparseArray.java
index c9d9bf0392..76ab43aa7a 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseArray.java
@@ -19,7 +19,7 @@
 
 /**
  * Copied from Android project: android.util.SparseArray.java
- * <p/>
+ * <p>
  * SparseArrays map integers to Objects. Unlike a normal array of Objects, there can be gaps in the
  * indices. It is intended to be more efficient than using a HashMap to map Integers to Objects.
  */
diff --git a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
index b3e95ef529..584eadde6d 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
@@ -19,7 +19,7 @@
 
 /**
  * Copied from Android project. android.util.SparseArray.java
- * <p/>
+ * <p>
  * SparseArrays map ints to ints. Unlike a normal array of ints, there can be gaps in the indices.
  */
 public class SparseIntIntArray
@@ -67,7 +67,7 @@ public SparseIntIntArray( int cap )
 
     /**
      * Sets all supplied keys to the given unique value.
-     * <p/>
+     * <p>
      * @param keys Keys to set
      * @param uniqueValue Value to set all supplied keys to
      */
diff --git a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
index 2398eceec7..15577939ce 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
@@ -19,7 +19,7 @@
 
 /**
  * Copied from Android project. android.util.LongSparseArray.java
- * <p/>
+ * <p>
  * SparseArrays map longs to longs. Unlike a normal array of longs, there can be gaps in the
  * indices.
  */
@@ -68,7 +68,7 @@ public SparseLongLongArray( int cap )
 
     /**
      * Sets all supplied keys to the given unique value.
-     * <p/>
+     * <p>
      * @param keys Keys to set
      * @param uniqueValue Value to set all supplied keys to
      */
diff --git a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
index 6d8c2f96a2..d062fcf858 100644
--- a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
@@ -22,7 +22,7 @@
 /**
  * Defines the mapping between a one dimensional 'number' and a point (lat, lon) which is limited to
  * a defined bounds.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface KeyAlgo
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 06f694cbae..dfb2919aec 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -22,7 +22,7 @@
 
 /**
  * This class maps lat,lon to a (tile)number unlike SpatialKeyAlgo.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 // A 4*3 precision linear key will look like
@@ -78,7 +78,7 @@ public long encode( GHPoint coord )
 
     /**
      * Take latitude and longitude as input.
-     * <p/>
+     * <p>
      * @return the linear key
      */
     @Override
@@ -94,7 +94,7 @@ public final long encode( double lat, double lon )
 
     /**
      * This method returns latitude and longitude via latLon - calculated from specified linearKey
-     * <p/>
+     * <p>
      * @param linearKey is the input
      */
     @Override
diff --git a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
index 74d3b73abd..6c71d3c1ec 100644
--- a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
@@ -25,36 +25,36 @@
  * called 'spatial key'. The idea of mixing the latitude and longitude is also taken to allow
  * removing the insignificant (right side) bits to make a geo-query or the coordinate less precise.
  * E.g. for a 3 bit precision the spatial key would need 6 bits and look like:
- * <p/>
+ * <p>
  * lat0 lon0 | lat1 lon1 | lat2 lon2
- * <p/>
+ * <p>
  * This works similar to how BIG endianess works for bytes to int packing. Detailed information is
  * available in this blog post:
  * http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/
- * <p/>
+ * <p>
  * The bits are usable as key for hash tables like our SpatialKeyHashtable or for a spatial tree
  * like QuadTreeSimple. Also the binary form makes it relative simple for implementations using this
  * encoding scheme to expand to arbitrary dimension (e.g. shifting n-times if n would be the
  * dimension).
- * <p/>
+ * <p>
  * A 32 bit representation has a precision of approx 600 meters = 40000/2^16
- * <p/>
+ * <p>
  * There are different possibilities how to handle different precision and order of bits. Either:
- * <p/>
+ * <p>
  * lat0 lon0 | lat1 lon1 | lat2 lon2
- * <p/>
+ * <p>
  * 0 0 | lat0 lon0 | lat1 lon1
- * <p/>
+ * <p>
  * as it is done now. Advantage: A single shift is only necessary to make it less precise. Or:
- * <p/>
+ * <p>
  * lat2 lon2 | lat1 lon1 | lat0 lon0
- * <p/>
+ * <p>
  * 0 0 | lat1 lon1 | lat0 lon0
- * <p/>
+ * <p>
  * Advantage: the bit mask to get lat0 lon0 is simple: 000..0011 and independent of the precision!
  * But when stored e.g. as int one would need to (left) shift several times if precision is only
  * 3bits.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 // A 2 bit precision spatial key could look like
@@ -142,7 +142,7 @@ public long encode( GHPoint coord )
 
     /**
      * Take latitude and longitude as input.
-     * <p/>
+     * <p>
      * @return the spatial key
      */
     @Override
@@ -202,7 +202,7 @@ public final long encode( double lat, double lon )
 
     /**
      * This method returns latitude and longitude via latLon - calculated from specified spatialKey
-     * <p/>
+     * <p>
      * @param spatialKey is the input
      */
     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index c676cfad4a..eca6f50781 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -28,7 +28,7 @@
 
 /**
  * Base class for all OSM objects
- * <p/>
+ * <p>
  * @author Nop
  * @author Peter
  */
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index 43c5e70f38..97a7a0475e 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -34,7 +34,7 @@
 
 /**
  * A readable OSM file.
- * <p/>
+ * <p>
  * @author Nop
  */
 public class OSMInputFile implements Sink, Closeable
diff --git a/core/src/main/java/com/graphhopper/reader/OSMNode.java b/core/src/main/java/com/graphhopper/reader/OSMNode.java
index ea42f49425..f1752a9486 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMNode.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMNode.java
@@ -24,7 +24,7 @@
 
 /**
  * Represents an OSM Node
- * <p/>
+ * <p>
  * @author Nop
  */
 public class OSMNode extends OSMElement
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index e32247d2b3..09a90fa8b6 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -55,24 +55,24 @@
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
  * parsing processes in order to reduce memory usage compared to a single parsing processing.
- * <p/>
+ * <p>
  * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
  * osmNodeIdToIndexMap returns EMPTY.
- * <p/>
+ * <p>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
  * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
  * of the relation.
- * <p/>
+ * <p>
  * 2.a) Reads nodes from OSM file and stores lat+lon information either into the intermediate
  * datastructure for the pillar nodes (pillarLats/pillarLons) or, if a tower node, directly into the
  * graphStorage via setLatitude/setLongitude. It can also happen that a pillar node needs to be
  * transformed into a tower node e.g. via barriers or different speed values for one way.
- * <p/>
+ * <p>
  * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate datastructure will be
  * stored in the way geometry of that edge.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class OSMReader implements DataReader
@@ -85,7 +85,8 @@
     private static final Logger logger = LoggerFactory.getLogger(OSMReader.class);
     private long locations;
     private long skippedLocations;
-    private final GraphStorage graphStorage;
+    private final GraphStorage ghStorage;
+    private final Graph graph;
     private final NodeAccess nodeAccess;
     private EncodingManager encodingManager = null;
     private int workerThreads = -1;
@@ -116,20 +117,21 @@
     // negative but increasing to avoid clash with custom created OSM files
     private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private boolean exitOnlyPillarNodeException = true;
+    private final boolean exitOnlyPillarNodeException = true;
     private File osmFile;
-    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
-    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
-    public OSMReader( GraphStorage storage )
+    public OSMReader( GraphHopperStorage ghStorage )
     {
-        this.graphStorage = storage;
-        this.nodeAccess = graphStorage.getNodeAccess();
+        this.ghStorage = ghStorage;
+        this.graph = ghStorage;
+        this.nodeAccess = graph.getNodeAccess();
 
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        pillarInfo = new PillarInfo(nodeAccess.is3D(), ghStorage.getDirectory());
     }
 
     @Override
@@ -247,7 +249,7 @@ private TIntLongMap getEdgeIdToOsmWayIdMap()
     /**
      * Filter ways but do not analyze properties wayNodes will be filled with participating node
      * ids.
-     * <p/>
+     * <p>
      * @return true the current xml entry is a way entry and has nodes
      */
     boolean filterWay( OSMWay item )
@@ -270,7 +272,7 @@ private void writeOsm2Graph( File osmFile )
     {
         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
         logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-        graphStorage.create(tmp);
+        ghStorage.create(tmp);
         long wayStart = -1;
         long relationStart = -1;
         long counter = 1;
@@ -325,7 +327,7 @@ private void writeOsm2Graph( File osmFile )
         }
 
         finishedReading();
-        if (graphStorage.getNodes() == 0)
+        if (graph.getNodes() == 0)
             throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
     }
 
@@ -444,7 +446,7 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null)
             {
-                GraphExtension extendedStorage = graphStorage.getExtension();
+                GraphExtension extendedStorage = graph.getExtension();
                 if (extendedStorage instanceof TurnCostExtension)
                 {
                     TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
@@ -491,10 +493,10 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
 
         if (edgeOutExplorer == null || edgeInExplorer == null)
         {
-            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            edgeOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
             outExplorerMap.put(encoder, edgeOutExplorer);
 
-            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            edgeInExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
             inExplorerMap.put(encoder, edgeInExplorer);
         }
         return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
@@ -793,7 +795,8 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
             towerNodeDistance = 1;
         }
 
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+        EdgeIteratorState iter = graph.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+
         if (nodes > 2)
         {
             if (doSimplify)
@@ -901,7 +904,7 @@ private long createNewNodeId()
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
-     * <p/>
+     * <p>
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
@@ -1005,7 +1008,7 @@ public OSMReader setOSMFile( File osmFile )
 
     private void printInfo( String str )
     {
-        logger.info("finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+        logger.info("finished " + str + " processing." + " nodes: " + graph.getNodes()
                 + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
                 + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
                 + ", zeroCounter:" + zeroCounter
@@ -1017,9 +1020,4 @@ public String toString()
     {
         return getClass().getSimpleName();
     }
-
-    public GraphStorage getGraphStorage()
-    {
-        return graphStorage;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMRelation.java b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
index ff7ca2651f..2f897ae9dc 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
@@ -24,7 +24,7 @@
 
 /**
  * Represents an OSM Relation
- * <p/>
+ * <p>
  * @author Nop
  */
 public class OSMRelation extends OSMElement
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 27c5c7051a..db71dc1174 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -12,7 +12,7 @@
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
- * <p/>
+ * <p>
  * @author Karl Hübner
  */
 public class OSMTurnRelation
@@ -70,7 +70,7 @@ long getOsmIdTo()
 
     /**
      * Transforms this relation into a collection of turn cost entries
-     * <p/>
+     * <p>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
diff --git a/core/src/main/java/com/graphhopper/reader/OSMWay.java b/core/src/main/java/com/graphhopper/reader/OSMWay.java
index 3f713757b1..05b0349b58 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMWay.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMWay.java
@@ -26,7 +26,7 @@
 
 /**
  * Represents an OSM Way
- * <p/>
+ * <p>
  * @author Nop
  */
 public class OSMWay extends OSMElement
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 9ef7e4664e..591f979e86 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -25,7 +25,7 @@
 
 /**
  * This class helps to store lat,lon,ele for every node parsed in OSMReader
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PillarInfo implements PointAccess
diff --git a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
index 977337760a..a5077c7af8 100644
--- a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
@@ -26,7 +26,7 @@
 
 /**
  * Data taken from here http://algs4.cs.princeton.edu/44sp/
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PrinctonReader
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 51df165c52..e239cf4c63 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -43,14 +43,14 @@
  * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
  * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
  * http://graphhopper.com/public/license/CGIAR.txt
- * <p/>
+ * <p>
  * Every zip contains readme.txt with the necessary information e.g.:
  * <ol>
  * <li>
  * All GeoTiffs with 6000 x 6000 pixels.
  * </li>
  * </ol>
- * <p/>
+ * <p>
  * @author NopMap
  * @author Peter Karich
  */
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index 20c68e313c..79aee4c0cc 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -30,7 +30,7 @@
 
 /**
  * One rectangle of height data from Shuttle Radar Topography Mission.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class HeightTile
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 483e0b9978..6f37a69292 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -29,7 +29,7 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
+ * Elevation data from NASA (SRTM).
  * <p>
  * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
  * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
index a862aaf326..0af811724c 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
@@ -21,7 +21,7 @@
 /**
  * Converts PBF block data into decoded entities ready to be passed into an Osmosis pipeline. This
  * class is designed to be passed into a pool of worker threads to allow multi-threaded decoding.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfBlobDecoder implements Runnable
@@ -35,7 +35,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param blobType The type of blob.
      * @param rawBlob The raw data of the blob.
      * @param listener The listener for receiving decoding results.
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
index cd4c6eca52..ceec044dc8 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
@@ -7,14 +7,14 @@
 
 /**
  * Instances of this interface are used to receive results from PBFBlobDecoder.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public interface PbfBlobDecoderListener
 {
     /**
      * Provides the listener with the list of decoded entities.
-     * <p/>
+     * <p>
      * @param decodedEntities The decoded entities.
      */
     void complete( List<OSMElement> decodedEntities );
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
index e119944e7e..cc0265dc89 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
@@ -7,7 +7,7 @@
 
 /**
  * Stores the results for a decoded Blob.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfBlobResult
@@ -29,7 +29,7 @@ public PbfBlobResult()
 
     /**
      * Stores the results of a successful blob decoding operation.
-     * <p/>
+     * <p>
      * @param decodedEntities The entities from the blob.
      */
     public void storeSuccessResult( List<OSMElement> decodedEntities )
@@ -51,7 +51,7 @@ public void storeFailureResult( Exception ex )
 
     /**
      * Gets the complete flag.
-     * <p/>
+     * <p>
      * @return True if complete.
      */
     public boolean isComplete()
@@ -61,7 +61,7 @@ public boolean isComplete()
 
     /**
      * Gets the success flag. This is only valid after complete becomes true.
-     * <p/>
+     * <p>
      * @return True if successful.
      */
     public boolean isSuccess()
@@ -77,7 +77,7 @@ public Exception getException()
     /**
      * Gets the entities decoded from the blob. This is only valid after complete becomes true, and
      * if success is true.
-     * <p/>
+     * <p>
      * @return The list of decoded entities.
      */
     public List<OSMElement> getEntities()
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
index 6ff39041c0..e8d61cb6a0 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
@@ -16,7 +16,7 @@
 /**
  * Decodes all blocks from a PBF stream using worker threads, and passes the results to the
  * downstream sink.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfDecoder implements Runnable
@@ -31,7 +31,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param streamSplitter The PBF stream splitter providing the source of blobs to be decoded.
      * @param executorService The executor service managing the thread pool.
      * @param maxPendingBlobs The maximum number of blobs to have in progress at any point in time.
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
index a1921bed2e..4c5e9d68c5 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
@@ -7,9 +7,9 @@
 
 /**
  * Manages decoding of the lower level PBF data structures.
- * <p/>
+ * <p>
  * @author Brett Henderson
- *         <p/>
+ *         <p>
  */
 public class PbfFieldDecoder
 {
@@ -22,7 +22,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param primitiveBlock The primitive block containing the fields to be decoded.
      */
     public PbfFieldDecoder( Osmformat.PrimitiveBlock primitiveBlock )
@@ -42,7 +42,7 @@ public PbfFieldDecoder( Osmformat.PrimitiveBlock primitiveBlock )
 
     /**
      * Decodes a raw latitude value into degrees.
-     * <p/>
+     * <p>
      * @param rawLatitude The PBF encoded value.
      * @return The latitude in degrees.
      */
@@ -53,7 +53,7 @@ public double decodeLatitude( long rawLatitude )
 
     /**
      * Decodes a raw longitude value into degrees.
-     * <p/>
+     * <p>
      * @param rawLongitude The PBF encoded value.
      * @return The longitude in degrees.
      */
@@ -64,7 +64,7 @@ public double decodeLongitude( long rawLongitude )
 
     /**
      * Decodes a raw timestamp value into a Date.
-     * <p/>
+     * <p>
      * @param rawTimestamp The PBF encoded timestamp.
      * @return The timestamp as a Date.
      */
@@ -75,7 +75,7 @@ public Date decodeTimestamp( long rawTimestamp )
 
     /**
      * Decodes a raw string into a String.
-     * <p/>
+     * <p>
      * @param rawString The PBF encoding string.
      * @return The string as a String.
      */
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfRawBlob.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfRawBlob.java
index 1f2ff0cd9e..7cfa1f2cf5 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfRawBlob.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfRawBlob.java
@@ -4,7 +4,7 @@
 /**
  * Represents a single piece of raw blob data extracted from the PBF stream. It has not yet been
  * decoded into a PBF blob object.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfRawBlob
@@ -14,7 +14,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param type The type of data represented by this blob. This corresponds to the type field in
      * the blob header.
      * @param data The raw contents of the blob in binary undecoded form.
@@ -28,7 +28,7 @@ public PbfRawBlob( String type, byte[] data )
     /**
      * Gets the type of data represented by this blob. This corresponds to the type field in the
      * blob header.
-     * <p/>
+     * <p>
      * @return The blob type.
      */
     public String getType()
@@ -38,7 +38,7 @@ public String getType()
 
     /**
      * Gets the raw contents of the blob in binary undecoded form.
-     * <p/>
+     * <p>
      * @return The raw blob data.
      */
     public byte[] getData()
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfReader.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfReader.java
index 87a1cd9e40..9ab7ea9e86 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfReader.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfReader.java
@@ -8,7 +8,7 @@
 
 /**
  * An OSM data source reading from a PBF file. The entire contents of the file are read.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfReader implements Runnable
@@ -19,7 +19,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param in The file to read.
      * @param workers The number of worker threads for decoding PBF blocks.
      */
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfStreamSplitter.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfStreamSplitter.java
index 64576b914a..93e4e2dbc6 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfStreamSplitter.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfStreamSplitter.java
@@ -13,7 +13,7 @@
 /**
  * Parses a PBF data stream and extracts the raw data of each blob in sequence until the end of the
  * stream is reached.
- * <p/>
+ * <p>
  * @author Brett Henderson
  */
 public class PbfStreamSplitter implements Iterator<PbfRawBlob>
@@ -26,7 +26,7 @@
 
     /**
      * Creates a new instance.
-     * <p/>
+     * <p>
      * @param pbfStream The PBF data stream to be parsed.
      */
     public PbfStreamSplitter( DataInputStream pbfStream )
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 80b88f570f..82b9691b26 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -36,9 +36,9 @@
 /**
  * This class implements the A* algorithm according to
  * http://en.wikipedia.org/wiki/A*_search_algorithm
- * <p/>
+ * <p>
  * Different distance calculations can be used via setApproximation.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class AStar extends AbstractRoutingAlgorithm
@@ -92,7 +92,7 @@ public Path calcPath( int from, int to )
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation;
+        double currWeightToGoal, estimationFullWeight;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
@@ -112,27 +112,28 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
-                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
-                        + currEdge.weightOfVisitedPath);
+                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge)
+                        + currEdge.weightOfVisitedPath;
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
                 AStarEdge ase = fromMap.get(traversalId);
-                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
+                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
                     currWeightToGoal = weightApprox.approximate(neighborNode);
-                    distEstimation = alreadyVisitedWeight + currWeightToGoal;
+                    estimationFullWeight = alreadyVisitedWeight + currWeightToGoal;
                     if (ase == null)
                     {
-                        ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
+                        ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullWeight, alreadyVisitedWeight);
                         fromMap.put(traversalId, ase);
                     } else
                     {
-                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
+                        assert (ase.weight > 0.9999999 * estimationFullWeight) : "Inconsistent distance estimate "
+                                + ase.weight + " vs " + estimationFullWeight + " (" + ase.weight / estimationFullWeight + "), and:"
+                                + ase.weightOfVisitedPath + " vs " + alreadyVisitedWeight + " (" + ase.weightOfVisitedPath / alreadyVisitedWeight + ")";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
-                        ase.weight = distEstimation;
+                        ase.weight = estimationFullWeight;
                         ase.weightOfVisitedPath = alreadyVisitedWeight;
                     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 7fd97d3d22..e7e37f453e 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -32,24 +32,24 @@
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
  * for a bidirectional A* as the heuristic can not be as tight.
- * <p/>
+ * <p>
  * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
- * <p/>
+ * <p>
  * and
- * <p/>
+ * <p>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
  * pages 291–296.
- * <p/>
+ * <p>
  * 2. Whangbo, T. K. (2007). Efficient modified bidirectional a* algorithm for optimal route-
  * finding. In IEA/AIE, volume 4570, pages 344–353. Springer.
- * <p/>
+ * <p>
  * or could we even use this three phase approach?
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author jansoe
  */
@@ -237,7 +237,7 @@ boolean fillEdgesTo()
     }
 
     private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
-                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+                            TIntObjectMap<AStarEdge> bestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -251,26 +251,28 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
-                    + currEdge.weightOfVisitedPath);
+            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath;
             if (Double.isInfinite(alreadyVisitedWeight))
                 continue;
 
-            AStarEdge ase = shortestWeightMap.get(traversalId);
+            AStarEdge ase = bestWeightMap.get(traversalId);
             if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
                 double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
-                double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
+                double estimationFullWeight = alreadyVisitedWeight + currWeightToGoal;
                 if (ase == null)
                 {
-                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(traversalId, ase);
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullWeight, alreadyVisitedWeight);
+                    bestWeightMap.put(traversalId, ase);
                 } else
                 {
-                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
+                    assert (ase.weight > 0.999999 * estimationFullWeight) : "Inconsistent distance estimate "
+                                + ase.weight + " vs " + estimationFullWeight + " (" + ase.weight / estimationFullWeight + "), and:"
+                                + ase.weightOfVisitedPath + " vs " + alreadyVisitedWeight + " (" + ase.weightOfVisitedPath / alreadyVisitedWeight + ")";
                     prioQueueOpenSet.remove(ase);
                     ase.edge = iter.getEdge();
-                    ase.weight = estimationFullDist;
+                    ase.weight = estimationFullWeight;
                     ase.weightOfVisitedPath = alreadyVisitedWeight;
                 }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index c0c2fcd0f0..69d6d68bd1 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -24,7 +24,7 @@
 
 /**
  * Common subclass for bidirectional algorithms.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index e52e24dd5a..874f724b7a 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -98,7 +98,7 @@ protected EdgeEntry createEdgeEntry( int node, double weight )
     /**
      * To be overwritten from extending class. Should we make this available in RoutingAlgorithm
      * interface?
-     * <p/>
+     * <p>
      * @return true if finished.
      */
     protected abstract boolean finished();
@@ -106,7 +106,7 @@ protected EdgeEntry createEdgeEntry( int node, double weight )
     /**
      * To be overwritten from extending class. Should we make this available in RoutingAlgorithm
      * interface?
-     * <p/>
+     * <p>
      * @return true if finished.
      */
     protected abstract Path extractPath();
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
index 433ff9cff8..f34f4cf958 100644
--- a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -30,7 +30,7 @@
  *        weighting(weighting).
  *        build();
  * </pre>
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class AlgorithmOptions
@@ -186,6 +186,12 @@ public Builder flagEncoder( FlagEncoder flagEncoder )
             return this;
         }
 
+        public Builder hints( PMap hints )
+        {
+            this.opts.hints.put(hints);
+            return this;
+        }
+
         public AlgorithmOptions build()
         {
             return opts;
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index f207b85e86..ad902b90b8 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -33,7 +33,7 @@
 /**
  * Implements a single source shortest path algorithm
  * http://en.wikipedia.org/wiki/Dijkstra's_algorithm
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 0b770831d9..16e9a959e8 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -34,9 +34,9 @@
 
 /**
  * Calculates best path in bidirectional way.
- * <p/>
+ * <p>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -192,9 +192,8 @@ protected boolean isWeightLimitExceeded()
 
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
                     TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
-    {
-        int currNode = currEdge.adjNode;
-        EdgeIterator iter = explorer.setBaseNode(currNode);
+    {        
+        EdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);
         while (iter.next())
         {
             if (!accept(iter, currEdge.edge))
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index a114e7b61b..0c29fc7649 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -31,7 +31,7 @@
 /**
  * A simple dijkstra tuned to perform one to many queries more efficient than Dijkstra. Old data
  * structures are cached between requests and potentially reused. Useful for CH preparation.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DijkstraOneToMany extends AbstractRoutingAlgorithm
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 49137f0146..8cfe8ee8a5 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -33,7 +33,7 @@
  * Stores the nodes for the found path of an algorithm. It additionally needs the edgeIds to make
  * edge determination faster and less complex as there could be several edges (u,v) especially for
  * graphs with shortcuts.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Ottavio Campana
  * @author jan soe
@@ -200,7 +200,7 @@ public Path extract()
      */
     public EdgeIteratorState getFinalEdge()
     {
-        return graph.getEdgeProps(edgeIds.get(edgeIds.size() - 1), endNode);
+        return graph.getEdgeIteratorState(edgeIds.get(edgeIds.size() - 1), endNode);
     }
 
     /**
@@ -221,7 +221,7 @@ public String getDebugInfo()
      */
     protected void processEdge( int edgeId, int adjNode )
     {
-        EdgeIteratorState iter = graph.getEdgeProps(edgeId, adjNode);
+        EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
         double dist = iter.getDistance();
         distance += dist;
         time += calcMillis(dist, iter.getFlags(), false);
@@ -260,7 +260,7 @@ protected long calcMillis( double distance, long flags, boolean revert )
     /**
      * Iterates over all edges in this path sorted from start to end and calls the visitor callback
      * for every edge.
-     * <p/>
+     * <p>
      * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
      * be stored.
      */
@@ -270,14 +270,14 @@ private void forEveryEdge( EdgeVisitor visitor )
         int len = edgeIds.size();
         for (int i = 0; i < len; i++)
         {
-            EdgeIteratorState edgeBase = graph.getEdgeProps(edgeIds.get(i), tmpNode);
+            EdgeIteratorState edgeBase = graph.getEdgeIteratorState(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
                 throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode
                         + ", array index:" + i + ", edges:" + edgeIds.size());
 
             tmpNode = edgeBase.getBaseNode();
             // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
-            edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
+            edgeBase = graph.getEdgeIteratorState(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
     }
@@ -332,7 +332,7 @@ public void next( EdgeIteratorState eb, int i )
 
     /**
      * This method calculated a list of points for this path
-     * <p/>
+     * <p>
      * @return this path its geometry
      */
     public PointList calcPoints()
@@ -425,7 +425,7 @@ public void next( EdgeIteratorState edge, int index )
                 double latitude, longitude;
 
                 PointList wayGeo = edge.fetchWayGeometry(3);
-                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+                boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
 
                 if (wayGeo.getSize() <= 2)
                 {
@@ -499,7 +499,7 @@ public void next( EdgeIteratorState edge, int index )
                         EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
                         while (edgeIter.next())
                         {
-                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            if (!encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
                             {
                                 ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
                                 break;
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
index 09a27cad73..af397d52f8 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidir.java
@@ -23,7 +23,7 @@
 
 /**
  * This class creates a Path from two Edge's resulting from a BidirectionalDijkstra
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PathBidir extends Path
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 3ae0152479..efa934e5f2 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -24,7 +24,7 @@
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PathBidirRef extends Path
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
index 6089caa68d..5c776f8d62 100644
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ b/core/src/main/java/com/graphhopper/routing/PathNative.java
@@ -23,7 +23,7 @@
 
 /**
  * This class creates a Path from a DijkstraOneToMany node
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PathNative extends Path
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 0c7a41b8d8..8c15d50bdc 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,10 +19,7 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -41,7 +38,7 @@
  * A class which is used to query the underlying graph with real GPS points. It does so by
  * introducing virtual nodes and edges. It is lightweight in order to be created every time a new
  * query comes in, which makes the behaviour thread safe.
- * <p/>
+ * <p>
  *
  * @author Peter Karich
  */
@@ -73,7 +70,7 @@ public QueryGraph( Graph graph )
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getCount();
+        mainEdges = graph.getAllEdges().getMaxId();
 
         if (mainGraph.getExtension() instanceof TurnCostExtension)
             wrappedExtension = new QueryGraphTurnExt(this);
@@ -284,7 +281,7 @@ public int compare( QueryResult o1, QueryResult o2 )
     @Override
     public Graph getBaseGraph()
     {
-        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a 
         // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
         // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
         return baseGraph;
@@ -371,7 +368,7 @@ private void createEdges( int origTraversalKey, int origRevTraversalKey,
      * @param incoming if true, incoming edges are unfavored, else outgoing edges
      * @return boolean indicating if enforcement took place
      */
-    public boolean enforceHeading( int nodeId, Double favoredHeading, boolean incoming )
+    public boolean enforceHeading( int nodeId, double favoredHeading, boolean incoming )
     {
         if (!isInitialized())
             throw new IllegalStateException("QueryGraph.lookup has to be called in before heading enforcement");
@@ -410,11 +407,11 @@ public boolean enforceHeading( int nodeId, Double favoredHeading, boolean incomi
 
             if (Math.abs(delta) > 1.74) // penalize if a turn of more than 100°
             {
-                edge.setVirtualEdgePreference(true, false);
+                edge.setVirtualEdgePreference(true);
                 modifiedEdges.add(edge);
                 //also apply to opposite edge for reverse routing
                 VirtualEdgeIteratorState reverseEdge = virtualEdges.get(virtNodeIDintern * 4 + getPosOfReverseEdge(edgePos));
-                reverseEdge.setVirtualEdgePreference(true, true);
+                reverseEdge.setVirtualEdgePreference(true);
                 modifiedEdges.add(reverseEdge);
                 enforcementOccured = true;
             }
@@ -436,11 +433,11 @@ public boolean enforceHeadingByEdgeId( int nodeId, int edgeId, boolean incoming
         if (!isVirtualNode(nodeId))
             return false;
 
-        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, nodeId);
-        VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, incomingEdge.getBaseNode());
-        incomingEdge.setVirtualEdgePreference(true, !incoming);
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, nodeId);
+        VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, incomingEdge.getBaseNode());
+        incomingEdge.setVirtualEdgePreference(true);
         modifiedEdges.add(incomingEdge);
-        reverseEdge.setVirtualEdgePreference(true, incoming);
+        reverseEdge.setVirtualEdgePreference(true);
         modifiedEdges.add(reverseEdge);
         return true;
     }
@@ -452,10 +449,8 @@ public void clearUnfavoredStatus()
     {
         for (VirtualEdgeIteratorState edge : modifiedEdges)
         {
-            edge.setVirtualEdgePreference(false, false);
-            edge.setVirtualEdgePreference(false, true);
+            edge.setVirtualEdgePreference(false);
         }
-
     }
 
     @Override
@@ -566,10 +561,10 @@ public BBox getBounds()
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
+    public EdgeIteratorState getEdgeIteratorState( int origEdgeId, int adjNode )
     {
         if (!isVirtualEdge(origEdgeId))
-            return mainGraph.getEdgeProps(origEdgeId, adjNode);
+            return mainGraph.getEdgeIteratorState(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index b7a5abf53c..de03219886 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -21,7 +21,7 @@
 
 /**
  * Calculates the shortest path from the specified node ids. Can be used only once.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 @NotThreadSafe
@@ -29,7 +29,7 @@
 {
     /**
      * Calculates the best path between the specified nodes.
-     * <p/>
+     * <p>
      * @return the path. Call the method found() to make sure that the path is valid.
      */
     Path calcPath( int from, int to );
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index e3e11cef2b..b74fb8f681 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -25,7 +25,7 @@
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index b461ed4c7b..8291e6f727 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -15,6 +15,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.*;
 
 import java.util.ArrayList;
@@ -23,7 +24,7 @@
 /**
  * @author Peter Karich
  */
-class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
+class VirtualEdgeIterator implements EdgeIterator, CHEdgeIteratorState
 {
     private final List<EdgeIteratorState> edges;
     private int current;
@@ -132,7 +133,7 @@ public EdgeIteratorState setName( String name )
     }
 
     @Override
-    public boolean getBoolean(int key, boolean reverse, boolean _default)
+    public boolean getBoolean( int key, boolean reverse, boolean _default )
     {
         return edges.get(current).getBoolean(key, reverse, _default);
     }
@@ -161,22 +162,34 @@ public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
         return edges.get(current).copyPropertiesTo(edge);
     }
 
+    @Override
+    public boolean isBackward( FlagEncoder encoder )
+    {
+        return edges.get(current).isBackward(encoder);
+    }
+
+    @Override
+    public boolean isForward( FlagEncoder encoder )
+    {
+        return edges.get(current).isForward(encoder);
+    }
+
     @Override
     public boolean isShortcut()
     {
         EdgeIteratorState edge = edges.get(current);
-        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+        return edge instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) edge).isShortcut();
     }
 
     @Override
     public double getWeight()
     {
         // will be called only from PreparationWeighting and if isShortcut is true
-        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+        return ((CHEdgeIteratorState) edges.get(current)).getWeight();
     }
 
     @Override
-    public EdgeSkipIterState setWeight( double weight )
+    public CHEdgeIteratorState setWeight( double weight )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
@@ -199,4 +212,9 @@ public void setSkippedEdges( int edge1, int edge2 )
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    @Override
+    public boolean canBeOverwritten( long flags )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index 15b276508a..9992bf203f 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -15,15 +15,16 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.*;
 
 /**
  * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
- * <p/>
+ * <p>
  * Note, this class is not suited for public use and can change with minor releases unexpectedly or
  * even gets removed.
  */
-public class VirtualEdgeIteratorState implements EdgeIteratorState, EdgeSkipIterState
+public class VirtualEdgeIteratorState implements EdgeIteratorState, CHEdgeIteratorState
 {
     private final PointList pointList;
     private final int edgeId;
@@ -34,10 +35,8 @@
     private final int adjNode;
     private final int originalTraversalKey;
     // indication if edges are dispreferred as start/stop edge 
-    private boolean unfavoredReverseEdge;
     private boolean unfavored;
 
-
     public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
     {
         this.originalTraversalKey = originalTraversalKey;
@@ -53,7 +52,7 @@ public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseN
     /**
      * This method returns the original edge via its traversal key. I.e. also the direction is
      * already correctly encoded.
-     * <p/>
+     * <p>
      * @see GHUtility#createEdgeKey(int, int, int, boolean)
      */
     public int getOriginalTraversalKey()
@@ -144,33 +143,25 @@ public EdgeIteratorState setName( String name )
         this.name = name;
         return this;
     }
-    
+
     @Override
-    public boolean getBoolean(int key, boolean reverse, boolean _default )
+    public boolean getBoolean( int key, boolean reverse, boolean _default )
     {
         if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
-        {
-            if (reverse)
-                return unfavoredReverseEdge;
-            else
-                return unfavored;
-        }
+            return unfavored;
+
         // for non-existent keys return default
         return _default;
     }
 
     /**
-     * set edge to unfavored status for routing from/to start/stop points
-     * @param reverse indicates if forward or backward direction is affected
+     * This method sets edge to unfavored status for routing from or to the start/stop points.
      */
-    public void setVirtualEdgePreference( boolean unfavored, boolean reverse )
+    public void setVirtualEdgePreference( boolean unfavored )
     {
-        if (reverse)
-              unfavoredReverseEdge = unfavored;
-        else
-            this.unfavored = unfavored;
+        this.unfavored = unfavored;
     }
-    
+
     @Override
     public String toString()
     {
@@ -183,12 +174,30 @@ public boolean isShortcut()
         return false;
     }
 
+    @Override
+    public boolean isForward( FlagEncoder encoder )
+    {
+        return encoder.isForward(getFlags());
+    }
+
+    @Override
+    public boolean isBackward( FlagEncoder encoder )
+    {
+        return encoder.isBackward(getFlags());
+    }
+
     @Override
     public int getAdditionalField()
     {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    @Override
+    public boolean canBeOverwritten( long flags )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
     @Override
     public int getSkippedEdge1()
     {
@@ -226,7 +235,7 @@ public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
     }
 
     @Override
-    public EdgeSkipIterState setWeight( double weight )
+    public CHEdgeIteratorState setWeight( double weight )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 03a5aaeeb6..1d513589a6 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -20,11 +20,11 @@
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
  * Recursivly unpack shortcuts.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see PrepareContractionHierarchies
  */
@@ -43,10 +43,10 @@ protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
     }
 
-    private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
+    private void expandEdge( CHEdgeIteratorState mainEdgeState, boolean reverse )
     {
         if (!mainEdgeState.isShortcut())
         {
@@ -73,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
+            CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
+            CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 1c2ec4c4bf..662d58eda1 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -18,14 +18,16 @@
  */
 package com.graphhopper.routing.ch;
 
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
- * Used in CH preparation and therefor assumed that all edges are of type EdgeSkipIterState
- * <p/>
+ * Used in CH preparation and therefor assumed that all edges are of type CHEdgeIteratorState
+ * <p>
  * @author Peter Karich
+ * @see PrepareContractionHierarchies
  */
 public class PreparationWeighting implements Weighting
 {
@@ -45,16 +47,20 @@ public final double getMinWeight( double distance )
     @Override
     public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
-        if (edgeState instanceof EdgeSkipIterState)
-        {
-            EdgeSkipIterState tmp = (EdgeSkipIterState) edgeState;
-            if (tmp.isShortcut())
-                // if a shortcut is in both directions the weight is identical => no need for 'reverse'
-                return tmp.getWeight();
-        }
+        CHEdgeIteratorState tmp = (CHEdgeIteratorState) edgeState;
+        if (tmp.isShortcut())
+            // if a shortcut is in both directions the weight is identical => no need for 'reverse'
+            return tmp.getWeight();
+
         return userWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
     }
 
+    @Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return userWeighting.getFlagEncoder();
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index c7c900cd97..c516a28ce9 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -36,13 +36,13 @@
 /**
  * This class prepares the graph for a bidirectional algorithm supporting contraction hierarchies
  * ie. an algorithm returned by createAlgo.
- * <p/>
+ * <p>
  * There are several description of contraction hierarchies available. The following is one of the
  * more detailed: http://web.cs.du.edu/~sturtevant/papers/highlevelpathfinding.pdf
- * <p/>
+ * <p>
  * The only difference is that we use two skipped edges instead of one skipped node for faster
  * unpacking.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
@@ -51,14 +51,15 @@
     private final PreparationWeighting prepareWeighting;
     private final FlagEncoder prepareFlagEncoder;
     private final TraversalMode traversalMode;
-    private EdgeSkipExplorer vehicleInExplorer;
-    private EdgeSkipExplorer vehicleOutExplorer;
-    private EdgeSkipExplorer vehicleAllExplorer;
-    private EdgeSkipExplorer vehicleAllTmpExplorer;
-    private EdgeSkipExplorer calcPrioAllExplorer;
+    private CHEdgeExplorer vehicleInExplorer;
+    private CHEdgeExplorer vehicleOutExplorer;
+    private CHEdgeExplorer vehicleAllExplorer;
+    private CHEdgeExplorer vehicleAllTmpExplorer;
+    private CHEdgeExplorer calcPrioAllExplorer;
     private final LevelEdgeFilter levelFilter;
     private int maxLevel;
-    private final LevelGraph prepareGraph;
+    private final GraphHopperStorage ghStorage;
+    private final CHGraphImpl prepareGraph;
 
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
@@ -80,28 +81,30 @@
     private int initialCollectionSize = 5000;
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
-
-    public PrepareContractionHierarchies( Directory dir, LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
+    private double dijkstraTime;
+    private double periodTime;
+    private double lazyTime;
+    private double neighborTime;
+    private int maxEdgesCount;
+
+    public PrepareContractionHierarchies( Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
+                                          FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
-        this.prepareGraph = g;
+        this.ghStorage = ghStorage;
+        this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
         this.prepareFlagEncoder = encoder;
-        long scFwdDir = encoder.setAccess(0, true, false);
         levelFilter = new LevelEdgeFilter(prepareGraph);
 
-        // shortcuts store weight in flags where we assume bit 1 and 2 are used for access restriction
-        if ((scFwdDir & PrepareEncoder.getScFwdDir()) == 0)
-            throw new IllegalArgumentException("Enabling the speed-up mode is currently only supported for the first vehicle.");
-
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = dir.find("original_edges");
+        originalEdges = dir.find("original_edges_" + prepareGraph.weightingToFileName(weighting));
         originalEdges.create(1000);
     }
 
     /**
      * The higher the values are the longer the preparation takes but the less shortcuts are
      * produced.
-     * <p/>
+     * <p>
      * @param periodicUpdates specifies how often periodic updates will happen. Use something less
      * than 10.
      */
@@ -160,14 +163,18 @@ public PrepareContractionHierarchies setLogMessages( double logMessages )
 
     /**
      * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
-     * faster contraction duration. Not yet ready for prime time.
+     * faster contraction duration.
      */
-    void setNodesContracted( double nodesContracted )
+    public PrepareContractionHierarchies setContractedNodes( double nodesContracted )
     {
+        if (nodesContracted < 0)
+            return this;
+
         if (nodesContracted > 100)
             throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
 
         this.nodesContractedPercentage = nodesContracted;
+        return this;
     }
 
     /**
@@ -193,27 +200,12 @@ public void doWork()
         super.doWork();
 
         initFromGraph();
-        if (!prepareEdges())
-            return;
-
         if (!prepareNodes())
             return;
 
         contractNodes();
     }
 
-    boolean prepareEdges()
-    {
-        EdgeIterator iter = prepareGraph.getAllEdges();
-        int c = 0;
-        while (iter.next())
-        {
-            c++;
-            setOrigEdgeCount(iter.getEdge(), 1);
-        }
-        return c > 0;
-    }
-
     boolean prepareNodes()
     {
         int nodes = prepareGraph.getNodes();
@@ -236,7 +228,7 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getMaxId() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
@@ -253,10 +245,9 @@ void contractNodes()
         if (periodicUpdatesPercentage == 0)
             periodicUpdate = false;
 
-        // disable as preparation is slower and query time does not benefit
-        long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0L
-                : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+        // disable lazy updates for last x percentage of nodes as preparation is then a lot slower
+        // and query time does not really benefit
+        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
@@ -271,7 +262,6 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -296,17 +286,20 @@ void contractNodes()
 
             if (counter % logSize == 0)
             {
+                dijkstraTime += dijkstraSW.getSeconds();
+                periodTime += periodSW.getSeconds();
+                lazyTime += lazySW.getSeconds();
+                neighborTime += neighborSW.getSeconds();
+
                 logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
                         + ", shortcuts:" + Helper.nf(newShortcuts)
                         + ", dijkstras:" + Helper.nf(dijkstraCount)
-                        + ", t(dijk):" + (int) dijkstraSW.getSeconds()
-                        + ", t(period):" + (int) periodSW.getSeconds()
-                        + ", t(lazy):" + (int) lazySW.getSeconds()
-                        + ", t(neighbor):" + (int) neighborSW.getSeconds()
+                        + ", " + getTimesAsString()
                         + ", meanDegree:" + (long) meanDegree
                         + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
+
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
                 lazySW = new StopWatch();
@@ -315,11 +308,11 @@ void contractNodes()
 
             counter++;
             int polledNode = sortedNodes.pollKey();
-            if (sortedNodes.getSize() < lastNodesLazyUpdates)
+            if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates)
             {
                 lazySW.start();
                 int priority = oldPriorities[polledNode] = calculatePriority(polledNode);
-                if (!sortedNodes.isEmpty() && priority > sortedNodes.peekValue())
+                if (priority > sortedNodes.peekValue())
                 {
                     // current node got more important => insert as new value and contract it later
                     sortedNodes.insert(polledNode, priority);
@@ -338,7 +331,7 @@ void contractNodes()
                 // skipped nodes are already set to maxLevel
                 break;
 
-            EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
+            CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
@@ -356,22 +349,24 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
+                prepareGraph.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
         // Preparation works only once so we can release temporary data.
         // The preparation object itself has to be intact to create the algorithm.
         close();
+
+        dijkstraTime += dijkstraSW.getSeconds();
+        periodTime += periodSW.getSeconds();
+        lazyTime += lazySW.getSeconds();
+        neighborTime += neighborSW.getSeconds();
         logger.info("took:" + (int) allSW.stop().getSeconds()
-                + ", new shortcuts: " + newShortcuts
+                + ", new shortcuts: " + Helper.nf(newShortcuts)
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
                 + ", dijkstras:" + dijkstraCount
-                + ", t(dijk):" + (int) dijkstraSW.getSeconds()
-                + ", t(period):" + (int) periodSW.getSeconds()
-                + ", t(lazy):" + (int) lazySW.getSeconds()
-                + ", t(neighbor):" + (int) neighborSW.getSeconds()
+                + ", " + getTimesAsString()
                 + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
@@ -380,6 +375,31 @@ void contractNodes()
                 + ", " + Helper.getMemInfo());
     }
 
+    public long getDijkstraCount()
+    {
+        return dijkstraCount;
+    }
+
+    public double getLazyTime()
+    {
+        return lazyTime;
+    }
+
+    public double getPeriodTime()
+    {
+        return periodTime;
+    }
+
+    public double getDijkstraTime()
+    {
+        return dijkstraTime;
+    }
+
+    public double getNeighborTime()
+    {
+        return neighborTime;
+    }
+
     public void close()
     {
         prepareAlgo.close();
@@ -391,6 +411,14 @@ public void close()
     AddShortcutHandler addScHandler = new AddShortcutHandler();
     CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
 
+    private String getTimesAsString()
+    {
+        return "t(dijk):" + Helper.round2(dijkstraTime)
+                + ", t(period):" + Helper.round2(periodTime)
+                + ", t(lazy):" + Helper.round2(lazyTime)
+                + ", t(neighbor):" + Helper.round2(neighborTime);
+    }
+
     interface ShortcutHandler
     {
         void foundShortcut( int u_fromNode, int w_toNode,
@@ -522,7 +550,7 @@ int calculatePriority( int v )
         // number of already contracted neighbors of v
         int contractedNeighbors = 0;
         int degree = 0;
-        EdgeSkipIterator iter = calcPrioAllExplorer.setBaseNode(v);
+        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(v);
         while (iter.next())
         {
             degree++;
@@ -581,7 +609,7 @@ void findShortcuts( ShortcutHandler sch )
                 if (Double.isNaN(existingDirectWeight))
                     throw new IllegalStateException("Weighting should never return NaN values"
                             + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
-                            + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
+                            + ", dist:" + outgoingEdges.getDistance());
 
                 if (Double.isInfinite(existingDirectWeight))
                     continue;
@@ -628,11 +656,10 @@ int addShortcuts( int v )
         {
             boolean updatedInGraph = false;
             // check if we need to update some existing shortcut in the graph
-            EdgeSkipIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
+            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
             while (iter.next())
             {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to
-                        && PrepareEncoder.canBeOverwritten(iter.getFlags(), sc.flags))
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to && iter.canBeOverwritten(sc.flags))
                 {
                     if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE))
                         continue NEXT_SC;
@@ -643,8 +670,8 @@ int addShortcuts( int v )
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
                                 + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
                                 + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
@@ -661,7 +688,7 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
                 edgeState.setWeight(sc.weight);
@@ -685,6 +712,8 @@ String getCoords( EdgeIteratorState e, Graph g )
 
     PrepareContractionHierarchies initFromGraph()
     {
+        ghStorage.freeze();
+        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
         vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
         vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
         final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
@@ -728,9 +757,9 @@ public int getShortcuts()
     {
         int avoidNode;
         int maxLevel;
-        LevelGraph graph;
+        CHGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
+        public IgnoreNodeFilter( CHGraph g, int maxLevel )
         {
             this.graph = g;
             this.maxLevel = maxLevel;
@@ -751,17 +780,30 @@ public final boolean accept( EdgeIteratorState iter )
         }
     }
 
-    private void setOrigEdgeCount( int index, int value )
+    private void setOrigEdgeCount( int edgeId, int value )
     {
-        long tmp = (long) index * 4;
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+        {
+            // ignore setting as every normal edge has original edge count of 1            
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" + ghStorage.getAllEdges().getMaxId());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
         originalEdges.ensureCapacity(tmp + 4);
         originalEdges.setInt(tmp, value);
     }
 
-    private int getOrigEdgeCount( int index )
+    private int getOrigEdgeCount( int edgeId )
     {
-        // TODO possible memory usage improvement: avoid storing the value 1 for normal edges (does not change)!
-        long tmp = (long) index * 4;
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
         originalEdges.ensureCapacity(tmp + 4);
         return originalEdges.getInt(tmp);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index 7fed0cca87..9bb5145de5 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -19,16 +19,15 @@
 package com.graphhopper.routing.ch;
 
 /**
- * The flags are stored differently for shortcuts: just a weight and the direction flags. Currently
- * it is not allowed to store multiple vehicles.
- * <p/>
+ * The flags are stored differently for shortcuts: just one weight and the direction flags.
+ * <p>
  * @author Peter Karich
  */
 public class PrepareEncoder
 {
-    // shortcut is one direction, speed is only involved while recalculating the adjNode weights
-    // see PrepareContractionHierarchies.prepareEdges
+    // shortcut goes in one or both directions is also possible if weight is identical    
     private static final long scFwdDir = 0x1;
+    private static final long scBwdDir = 0x2;
     private static final long scDirMask = 0x3;
 
     public static final long getScDirMask()
@@ -41,10 +40,15 @@ public static final long getScFwdDir()
         return scFwdDir;
     }
 
+    public static final long getScBwdDir()
+    {
+        return scBwdDir;
+    }
+
     /**
      * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
      * changing the directions of flags1.
-     * <p/>
+     * <p>
      * @return true if flags2 is enabled in both directions or if both flags are pointing into the
      * same direction.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 03801d4a92..f92f3d595c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -31,7 +31,7 @@
  * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
  * EncodingManager to be usable. If you want the full long to be stored you need to enable this in
  * the GraphHopperStorage.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Nop
  * @see EncodingManager
@@ -81,6 +81,7 @@
     private boolean blockFords = true;
     protected final int speedBits;
     protected final double speedFactor;
+    private boolean registered;
 
     public AbstractFlagEncoder( PMap properties )
     {
@@ -114,6 +115,7 @@ protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
 
         acceptedRailways.add("tram");
         acceptedRailways.add("abandoned");
+        acceptedRailways.add("abandoned_tram");        
         acceptedRailways.add("disused");
 
         // http://wiki.openstreetmap.org/wiki/Demolished_Railway
@@ -123,6 +125,17 @@ protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
         acceptedRailways.add("obliterated");
     }
 
+    public void setRegistered( boolean registered )
+    {
+        this.registered = registered;
+    }
+
+    @Override
+    public boolean isRegistered()
+    {
+        return registered;
+    }
+
     /**
      * Should potential barriers block when no access limits are given?
      */
@@ -143,7 +156,7 @@ public boolean isBlockFords()
 
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
-     * <p/>
+     * <p>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineNodeBits( int index, int shift )
@@ -153,15 +166,17 @@ public int defineNodeBits( int index, int shift )
 
     /**
      * Defines bits used for edge flags used for access, speed etc.
-     * <p/>
+     * <p>
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineWayBits( int index, int shift )
     {
-        if (forwardBit != 0)
+        if (isRegistered())
             throw new IllegalStateException("You must not register a FlagEncoder (" + toString() + ") twice!");
 
+        setRegistered(true);
+        
         // define the first 2 speedBits in flags for routing
         forwardBit = 1L << shift;
         backwardBit = 2L << shift;
@@ -180,7 +195,7 @@ public int defineWayBits( int index, int shift )
 
     /**
      * Defines the bits which are used for relation flags.
-     * <p/>
+     * <p>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineRelationBits( int index, int shift )
@@ -191,14 +206,14 @@ public int defineRelationBits( int index, int shift )
     /**
      * Analyze the properties of a relation and create the routing flags for the second read step.
      * In the pre-parsing step this method will be called to determine the useful relation tags.
-     * <p/>
+     * <p>
      */
     public abstract long handleRelationTags( OSMRelation relation, long oldRelationFlags );
 
     /**
      * Decide whether a way is routable for a given mode of travel. This skips some ways before
      * handleWayTags is called.
-     * <p/>
+     * <p>
      * @return the encoded value to indicate if this encoder allows travel or not.
      */
     public abstract long acceptWay( OSMWay way );
@@ -449,7 +464,7 @@ protected double parseSpeed( String str )
     /**
      * This method parses a string ala "00:00" (hours and minutes) or "0:00:00" (days, hours and
      * minutes).
-     * <p/>
+     * <p>
      * @return duration value in minutes
      */
     protected static int parseDuration( String str )
@@ -578,7 +593,7 @@ long getNodeBitMask()
 
     /**
      * Defines the bits reserved for storing turn restriction and turn cost
-     * <p/>
+     * <p>
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
similarity index 87%
rename from core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java
rename to core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
index 5472f13182..ee52d98335 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.CHEdgeIterator;
 
 /**
  * @author Peter Karich
  */
-public interface AllEdgesSkipIterator extends AllEdgesIterator, EdgeSkipIterator
+public interface AllCHEdgesIterator extends AllEdgesIterator, CHEdgeIterator
 {
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3a88c83a7b..bde8fc1918 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -25,7 +25,7 @@
 public interface AllEdgesIterator extends EdgeIterator
 {
     /**
-     * @return the number of edges
+     * @return the maximum edgeId in the graph which is roughly the number of edges.
      */
-    int getCount();
+    int getMaxId();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
index 6164434da5..5e8c969ab4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -8,7 +8,7 @@
 /**
  * Approximates the distance to the goal node by weighting the beeline distance according to the
  * distance weighting
- * <p/>
+ * <p>
  * @author jansoe
  */
 public class BeelineWeightApproximator implements WeightApproximator
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 8f0d7eb0e4..a0d81fa620 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -28,7 +28,7 @@
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index af99b1f01e..7122cbc764 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -30,7 +30,7 @@
 
 /**
  * Defines bit layout of bicycles (not motorcycles) for speed, access and relations (network).
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Nop
  * @author ratrun
@@ -57,7 +57,7 @@
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
     protected EncodedValue relationCodeEncoder;
     private EncodedValue wayTypeEncoder;
-    private EncodedValue preferWayEncoder;
+    EncodedValue priorityWayEncoder;
 
     // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
     private int avoidSpeedLimit;
@@ -220,8 +220,8 @@ public int defineWayBits( int index, int shift )
         wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3, true);
         shift += wayTypeEncoder.getBits();
 
-        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
-        shift += preferWayEncoder.getBits();
+        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += priorityWayEncoder.getBits();
 
         return shift;
     }
@@ -328,11 +328,6 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
         if (!isFerry(allowed))
         {
             double speed = getSpeed(way);
-            int priorityFromRelation = 0;
-            if (relationFlags != 0)
-                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
-
-            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
 
             // bike maxspeed handling is different from car as we don't increase speed
             speed = applyMaxSpeed(way, speed, false);
@@ -353,6 +348,11 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
                     highwaySpeeds.get("primary"));
             encoded |= directionBitMask;
         }
+        int priorityFromRelation = 0;
+        if (relationFlags != 0)
+            priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+        encoded = priorityWayEncoder.setValue(encoded, handlePriority(way, priorityFromRelation));
         return encoded;
     }
 
@@ -465,7 +465,7 @@ String getWayName( int pavementType, int wayType, Translation tr )
     /**
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
-     * <p/>
+     * <p>
      * @return new priority based on priorityFromRelation and on the tags in OSMWay.
      */
     protected int handlePriority( OSMWay way, int priorityFromRelation )
@@ -539,7 +539,8 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
             }
         } else
         {
-            if (avoidHighwayTags.contains(highway) || ((maxSpeed >= avoidSpeedLimit) && (highway != "track")))
+            if (avoidHighwayTags.contains(highway)
+                    || maxSpeed >= avoidSpeedLimit && !"track".equals(highway))
             {
                 weightToPrioMap.put(50d, REACH_DEST.getValue());
                 if (way.hasTag("tunnel", intendedValues))
@@ -569,11 +570,8 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
         {
             String classBicycle = way.getTag("class:bicycle");
             if (classBicycle != null)
-            {
                 weightToPrioMap.put(100d, convertCallValueToPriority(classBicycle).getValue());
-            }
         }
-
     }
 
     /**
@@ -642,40 +640,12 @@ public double getDouble( long flags, int key )
         switch (key)
         {
             case PriorityWeighting.KEY:
-                double prio = preferWayEncoder.getValue(flags);
-                if (prio == 0)
-                    return (double) UNCHANGED.getValue() / BEST.getValue();
-
-                return prio / BEST.getValue();
+                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             default:
                 return super.getDouble(flags, key);
         }
     }
 
-    @Override
-    public long getLong( long flags, int key )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.getValue(flags);
-            default:
-                return super.getLong(flags, key);
-        }
-    }
-
-    @Override
-    public long setLong( long flags, int key, long value )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.setValue(flags, value);
-            default:
-                return super.setLong(flags, key, value);
-        }
-    }
-
     boolean isPushingSection( OSMWay way )
     {
         return way.hasTag("highway", pushingSections) || way.hasTag("railway", "platform");
@@ -781,5 +751,4 @@ public void setSpecificBicycleClass( String subkey )
     {
         specificBicycleClass = "class:bicycle:" + subkey.toString();
     }
-
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 3b635f04bb..e054be7b80 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -22,7 +22,7 @@
 
 /**
  * Specifies the settings for cycletouring/trekking
- * <p/>
+ * <p>
  * @author ratrun
  * @author Peter Karich
  */
@@ -42,7 +42,7 @@ public BikeFlagEncoder( PMap properties )
     {
         this((int) properties.getLong("speedBits", 4),
                 properties.getLong("speedFactor", 2),
-                properties.getBool("turnCosts", false) ? 3 : 0);
+                properties.getBool("turnCosts", false) ? 1 : 0);
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 39ae7d9d6c..d785ea0d34 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -31,7 +31,7 @@
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Nop
  */
@@ -58,7 +58,7 @@ public CarFlagEncoder( PMap properties )
     {
         this((int) properties.getLong("speedBits", 5),
                 properties.getDouble("speedFactor", 5),
-                properties.getBool("turnCosts", false) ? 3 : 0);
+                properties.getBool("turnCosts", false) ? 1 : 0);
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
index 483e4f837a..833ad56e11 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -2,11 +2,11 @@
 
 /**
  * Turns an unidirectional weight Approximation into a bidirectional consistent one.
- * <p/>
+ * <p>
  * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
  * pages 291–296.
- * <p/>
+ * <p>
  * @author jansoe
  */
 public class ConsistentWeightApproximator
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index e86ca2c43d..3722dfb5bf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -46,8 +46,7 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     @Override
     public final boolean accept( EdgeIteratorState iter )
     {
-        long flags = iter.getFlags();
-        return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
+        return out && iter.isForward(encoder) || in && iter.isBackward(encoder);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index a108e4826c..1e01d82984 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -21,7 +21,7 @@
 
 /**
  * Class used to traverse a graph.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface EdgeFilter
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index e5233e75f0..4b00e4aece 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -19,7 +19,7 @@
 
 /**
  * Encapsulates a bit-encoded value.
- * <p/>
+ * <p>
  * @author Nop
  */
 public class EncodedDoubleValue extends EncodedValue
@@ -80,7 +80,7 @@ public double getDoubleValue( long flags )
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p/>
+     * <p>
      * @return the new flags
      */
     public long swap( long flags, EncodedDoubleValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index d96090e13f..46de2dcb32 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -19,7 +19,7 @@
 
 /**
  * Encapsulates a bit-encoded value.
- * <p/>
+ * <p>
  * @author Nop
  */
 public class EncodedValue
@@ -35,7 +35,7 @@
 
     /**
      * Define a bit-encoded value
-     * <p/>
+     * <p>
      * @param name Description for debugging
      * @param shift bit index of this value
      * @param bits number of bits reserved
@@ -113,7 +113,7 @@ public long getMaxValue()
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p/>
+     * <p>
      * @return the new flags
      */
     public long swap( long flags, EncodedValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 573d1b4a99..6545a1b72e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -35,7 +35,7 @@
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
  * during parsing.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Nop
  */
@@ -62,7 +62,7 @@
     /**
      * Instantiate manager with the given list of encoders. The manager knows the default encoders:
      * CAR, FOOT and BIKE (ignoring the case).
-     * <p/>
+     * <p>
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
     public EncodingManager( String flagEncodersStr )
@@ -77,7 +77,7 @@ public EncodingManager( String flagEncodersStr, int bytesForFlags )
 
     /**
      * Instantiate manager with the given list of encoders.
-     * <p/>
+     * <p>
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
     public EncodingManager( FlagEncoder... flagEncoders )
@@ -87,7 +87,7 @@ public EncodingManager( FlagEncoder... flagEncoders )
 
     /**
      * Instantiate manager with the given list of encoders.
-     * <p/>
+     * <p>
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
     public EncodingManager( List<? extends FlagEncoder> flagEncoders )
@@ -262,7 +262,7 @@ public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     /**
      * Processes way properties of different kind to determine speed and direction. Properties are
      * directly encoded in 8 bytes.
-     * <p/>
+     * <p>
      * @param relationFlags The preprocessed relation flags is used to influence the way properties.
      * @return the encoded flags
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 2850ef17bb..1bb441021a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -23,7 +23,7 @@
 /**
  * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
  * in seconds.
- * <p/>
+ * <p>
  *
  * @author Peter Karich
  */
@@ -36,12 +36,15 @@
     protected final static double SPEED_CONV = 3.6;
     final static double DEFAULT_HEADING_PENALTY = 300; //[s]
     private final double heading_penalty;
-    protected final FlagEncoder encoder;
+    protected final FlagEncoder flagEncoder;
     private final double maxSpeed;
 
     public FastestWeighting( FlagEncoder encoder, PMap pMap )
     {
-        this.encoder = encoder;
+        if (!encoder.isRegistered())
+            throw new IllegalStateException("Make sure you add the FlagEncoder " + encoder + " to an EncodingManager before using it elsewhere");
+
+        this.flagEncoder = encoder;
         heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
         maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
@@ -60,7 +63,7 @@ public double getMinWeight( double distance )
     @Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
+        double speed = reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
 
@@ -74,9 +77,34 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         return time;
     }
 
+    @Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return flagEncoder;
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 7;
+        hash = 71 * hash + toString().hashCode();
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        final FastestWeighting other = (FastestWeighting) obj;
+        return toString().equals(other.toString());
+    }
+
     @Override
     public String toString()
     {
-        return "FASTEST|" + encoder;
+        return "FASTEST|" + flagEncoder;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index cb024b32d9..c70c7b9a3e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -23,13 +23,14 @@
 /**
  * This class provides methods to define how a value (like speed or direction) converts to a flag
  * (currently an integer value), which is stored in an edge .
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface FlagEncoder extends TurnCostEncoder
 {
     /**
-     * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are introduced
+     * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are
+     * introduced
      */
     int getVersion();
 
@@ -45,7 +46,7 @@
 
     /**
      * Sets the speed in km/h.
-     * <p/>
+     * <p>
      * @return modified setProperties
      */
     long setSpeed( long flags, double speed );
@@ -62,14 +63,14 @@
 
     /**
      * Sets the access of the edge.
-     * <p/>
+     * <p>
      * @return modified flags
      */
     long setAccess( long flags, boolean forward, boolean backward );
 
     /**
      * Sets speed and access properties.
-     * <p/>
+     * <p>
      * @return created flags
      */
     long setProperties( double speed, boolean forward, boolean backward );
@@ -110,8 +111,8 @@
     long setLong( long flags, int key, long value );
 
     /**
-     * Returns arbitrary double value identified by the specified key. E.g. can be used to return the
-     * maximum width or height allowed for an edge.
+     * Returns arbitrary double value identified by the specified key. E.g. can be used to return
+     * the maximum width or height allowed for an edge.
      */
     double getDouble( long flags, int key );
 
@@ -126,4 +127,9 @@
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
     InstructionAnnotation getAnnotation( long flags, Translation tr );
+
+    /**
+     * @return true if already registered in an EncodingManager
+     */
+    boolean isRegistered();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 2412ce41a8..c0c0d22362 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -30,7 +30,7 @@
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Nop
  * @author Karl Hübner
@@ -40,7 +40,7 @@
     static final int SLOW_SPEED = 2;
     static final int MEAN_SPEED = 5;
     static final int FERRY_SPEED = 10;
-    private EncodedValue preferWayEncoder;
+    private EncodedValue priorityWayEncoder;
     private EncodedValue relationCodeEncoder;
     protected HashSet<String> sidewalks = new HashSet<String>();
     private final Set<String> safeHighwayTags = new HashSet<String>();
@@ -109,16 +109,16 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         avoidHighwayTags.add("trunk_link");
         avoidHighwayTags.add("primary");
         avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
         avoidHighwayTags.add("tertiary");
         avoidHighwayTags.add("tertiary_link");
+
         // for now no explicit avoiding #257
         //avoidHighwayTags.add("cycleway"); 
-
         allowedHighwayTags.addAll(safeHighwayTags);
         allowedHighwayTags.addAll(avoidHighwayTags);
         allowedHighwayTags.add("cycleway");
-        allowedHighwayTags.add("secondary");
-        allowedHighwayTags.add("secondary_link");
         allowedHighwayTags.add("unclassified");
         allowedHighwayTags.add("road");
         // disallowed in some countries
@@ -147,8 +147,8 @@ public int defineWayBits( int index, int shift )
         speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, maxPossibleSpeed);
         shift += speedEncoder.getBits();
 
-        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
-        shift += preferWayEncoder.getBits();
+        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += priorityWayEncoder.getBits();
         return shift;
     }
 
@@ -170,7 +170,7 @@ public int defineTurnBits( int index, int shift )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p/>
+     * <p>
      * @return <code>false</code>
      */
     @Override
@@ -181,7 +181,7 @@ public boolean isTurnRestricted( long flag )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p/>
+     * <p>
      * @return 0
      */
     @Override
@@ -198,7 +198,7 @@ public long getTurnFlags( boolean restricted, double costs )
 
     /**
      * Some ways are okay but not separate for pedestrians.
-     * <p/>
+     * <p>
      */
     @Override
     public long acceptWay( OSMWay way )
@@ -283,40 +283,37 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
         if (!isAccept(allowed))
             return 0;
 
-        long encoded;
+        long encoded = 0;
         if (!isFerry(allowed))
         {
             String sacScale = way.getTag("sac_scale");
             if (sacScale != null)
             {
                 if ("hiking".equals(sacScale))
-                    encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
+                    encoded = speedEncoder.setDoubleValue(encoded, MEAN_SPEED);
                 else
-                    encoded = speedEncoder.setDoubleValue(0, SLOW_SPEED);
+                    encoded = speedEncoder.setDoubleValue(encoded, SLOW_SPEED);
             } else
             {
-                encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
+                encoded = speedEncoder.setDoubleValue(encoded, MEAN_SPEED);
             }
             encoded |= directionBitMask;
 
-            int priorityFromRelation = 0;
-            if (relationFlags != 0)
-                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
-
-            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
-
             boolean isRoundabout = way.hasTag("junction", "roundabout");
             if (isRoundabout)
-            {
                 encoded = setBool(encoded, K_ROUNDABOUT, true);
-            }
 
         } else
         {
-            encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
+            encoded = encoded | handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             encoded |= directionBitMask;
         }
 
+        int priorityFromRelation = 0;
+        if (relationFlags != 0)
+            priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+        encoded = priorityWayEncoder.setValue(encoded, handlePriority(way, priorityFromRelation));
         return encoded;
     }
 
@@ -326,40 +323,12 @@ public double getDouble( long flags, int key )
         switch (key)
         {
             case PriorityWeighting.KEY:
-                double prio = preferWayEncoder.getValue(flags);
-                if (prio == 0)
-                    return (double) UNCHANGED.getValue() / BEST.getValue();
-
-                return prio / BEST.getValue();
+                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             default:
                 return super.getDouble(flags, key);
         }
     }
 
-    @Override
-    public long getLong( long flags, int key )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.getValue(flags);
-            default:
-                return super.getLong(flags, key);
-        }
-    }
-
-    @Override
-    public long setLong( long flags, int key, long value )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.setValue(flags, value);
-            default:
-                return super.setLong(flags, key, value);
-        }
-    }
-
     protected int handlePriority( OSMWay way, int priorityFromRelation )
     {
         TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
@@ -389,26 +358,22 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
         {
             weightToPrioMap.put(40d, PREFER.getValue());
             if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(40d, UNCHANGED.getValue());
+            {
+                if (way.hasTag("sidewalk", "no"))
+                    weightToPrioMap.put(40d, REACH_DEST.getValue());
+                else
+                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+            }
+        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway))
+        {
+            if (way.hasTag("sidewalk", "no"))
+                weightToPrioMap.put(45d, WORST.getValue());
+            else
+                weightToPrioMap.put(45d, REACH_DEST.getValue());
         }
 
         if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
-        {
             weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
-        }
-
-        if (way.hasTag("sidewalk", sidewalks))
-        {
-            weightToPrioMap.put(45d, PREFER.getValue());
-        }
-
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
-        {
-            weightToPrioMap.put(50d, REACH_DEST.getValue());
-
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
-        }
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 985a4477d5..e7817d3c8b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -17,22 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    private final LevelGraph graph;
+    private final CHGraph graph;
     private final int maxNodes;
 
-    public LevelEdgeFilter( LevelGraph g )
+    public LevelEdgeFilter( CHGraph g )
     {
         graph = g;
         maxNodes = g.getNodes();
@@ -48,7 +47,7 @@ public boolean accept( EdgeIteratorState edgeIterState )
             return true;
 
         // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
-        if (((EdgeSkipIterState) edgeIterState).isShortcut())
+        if (((CHEdgeIteratorState) edgeIterState).isShortcut())
             return true;
 
         return graph.getLevel(base) <= graph.getLevel(adj);
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index 34d1da2056..c5e0c585da 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -27,13 +27,13 @@
 
 /**
  * Defines bit layout for motorbikes
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoder extends CarFlagEncoder
 {
     private EncodedDoubleValue reverseSpeedEncoder;
-    private EncodedValue preferWayEncoder;
+    private EncodedValue priorityWayEncoder;
     private final HashSet<String> avoidSet = new HashSet<String>();
     private final HashSet<String> preferSet = new HashSet<String>();
 
@@ -42,7 +42,7 @@ public MotorcycleFlagEncoder( PMap properties )
         this(
                 (int) properties.getLong("speedBits", 5),
                 properties.getDouble("speedFactor", 5),
-                properties.getBool("turnCosts", false) ? 3 : 0
+                properties.getBool("turnCosts", false) ? 1 : 0
         );
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
@@ -122,7 +122,7 @@ public int defineWayBits( int index, int shift )
                 defaultSpeedMap.get("secondary"), maxPossibleSpeed);
         shift += reverseSpeedEncoder.getBits();
 
-        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
+        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
         shift += reverseSpeedEncoder.getBits();
 
         return shift;
@@ -180,7 +180,7 @@ public long acceptWay( OSMWay way )
     }
 
     @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+    public long handleWayTags( OSMWay way, long allowed, long priorityFromRelation )
     {
         if (!isAccept(allowed))
             return 0;
@@ -188,8 +188,6 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
         long encoded = 0;
         if (!isFerry(allowed))
         {
-            encoded = setLong(encoded, PriorityWeighting.KEY, calcPriority(way, relationFlags));
-
             // get assumed speed from highway type
             double speed = getSpeed(way);
             speed = applyMaxSpeed(way, speed, true);
@@ -230,6 +228,8 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             encoded |= directionBitMask;
         }
 
+        // relations are not yet stored -> see BikeCommonFlagEncoder.defineRelationBits how to do this
+        encoded = priorityWayEncoder.setValue(encoded, handlePriority(way, priorityFromRelation));
         return encoded;
     }
 
@@ -301,41 +301,13 @@ public double getDouble( long flags, int key )
         switch (key)
         {
             case PriorityWeighting.KEY:
-                double prio = preferWayEncoder.getValue(flags);
-                if (prio == 0)
-                    return (double) UNCHANGED.getValue() / BEST.getValue();
-
-                return prio / BEST.getValue();
+                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
             default:
                 return super.getDouble(flags, key);
         }
     }
 
-    @Override
-    public long getLong( long flags, int key )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.getValue(flags);
-            default:
-                return super.getLong(flags, key);
-        }
-    }
-
-    @Override
-    public long setLong( long flags, int key, long value )
-    {
-        switch (key)
-        {
-            case PriorityWeighting.KEY:
-                return preferWayEncoder.setValue(flags, value);
-            default:
-                return super.setLong(flags, key, value);
-        }
-    }
-
-    private int calcPriority( OSMWay way, long relationFlags )
+    private int handlePriority( OSMWay way, long relationFlags )
     {
         String highway = way.getTag("highway", "");
         if (avoidSet.contains(highway))
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index 5f5c36b335..b2346d00c0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -30,7 +30,7 @@
 
 /**
  * Specifies the settings for mountain biking
- * <p/>
+ * <p>
  * @author ratrun
  * @author Peter Karich
  */
@@ -46,7 +46,7 @@ public MountainBikeFlagEncoder( PMap properties )
         this(
                 (int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 2),
-                properties.getBool("turnCosts", false) ? 3 : 0
+                properties.getBool("turnCosts", false) ? 1 : 0
         );
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index f061e27043..ead210ccbb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -19,11 +19,11 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.*;
+import gnu.trove.list.TIntList;
 
 import java.util.*;
-import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.slf4j.Logger;
@@ -35,28 +35,23 @@
  * Removes nodes which are not part of the largest network. Ie. mostly nodes with no edges at all
  * but also small subnetworks which are nearly always bugs in OSM data or indicate otherwise
  * disconnected areas e.g. via barriers - see #86.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworks
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final GraphStorage g;
-    private final EdgeFilter edgeFilter;
+    private final GraphHopperStorage ghStorage;
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
-    private int subNetworks = -1;
+    private int subnetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private FlagEncoder singleEncoder;
+    private final List<FlagEncoder> encoders;
 
-    public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
+    public PrepareRoutingSubnetworks( GraphHopperStorage ghStorage, Collection<FlagEncoder> encoders )
     {
-        this.g = g;
-        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
-        if (encoders.size() > 1)
-            edgeFilter = EdgeFilter.ALL_EDGES;
-        else
-            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
+        this.ghStorage = ghStorage;
+        this.encoders = new ArrayList<FlagEncoder>(encoders);
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -73,42 +68,52 @@ public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSi
 
     public void doWork()
     {
-        int del = removeZeroDegreeNodes();
-        Map<Integer, Integer> map = findSubnetworks();
-        keepLargeNetworks(map);
+        if (minNetworkSize <= 0 && minOneWayNetworkSize <= 0)
+            return;
 
-        int unvisitedDeadEnds = -1;
-        if (minOneWayNetworkSize > 0 && singleEncoder != null)
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
+        int unvisitedDeadEnds = 0;
+        for (FlagEncoder encoder : encoders)
+        {
+            // mark edges for one vehicle as inaccessible
+            PrepEdgeFilter filter = new PrepEdgeFilter(encoder);
+            if (minOneWayNetworkSize > 0)
+                unvisitedDeadEnds += removeDeadEndUnvisitedNetworks(filter);
+
+            List<TIntArrayList> components = findSubnetworks(filter);
+            keepLargeNetworks(filter, components);
+            subnetworks = Math.max(components.size(), subnetworks);
+        }
 
-        logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
-                + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
-                + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
-        g.optimize();
-        subNetworks = map.size();
-    }
+        markNodesRemovedIfUnreachable();
 
-    public int getSubNetworks()
-    {
-        return subNetworks;
+        logger.info("optimize to remove subnetworks (" + subnetworks + "), "
+                + "unvisited-dead-end-nodes (" + unvisitedDeadEnds + "), "
+                + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
+        ghStorage.optimize();
     }
 
-    public Map<Integer, Integer> findSubnetworks()
+    public int getMaxSubnetworks()
     {
-        return findSubnetworks(g.createEdgeExplorer(edgeFilter));
+        return subnetworks;
     }
 
-    private Map<Integer, Integer> findSubnetworks( final EdgeExplorer explorer )
+    /**
+     * This method finds the double linked components according to the specified filter.
+     */
+    List<TIntArrayList> findSubnetworks( PrepEdgeFilter filter )
     {
-        final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
-        final AtomicInteger integ = new AtomicInteger(0);
-        int locs = g.getNodes();
+        final FlagEncoder encoder = filter.getEncoder();
+        final EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
+        int locs = ghStorage.getNodes();
+        List<TIntArrayList> list = new ArrayList<TIntArrayList>(100);
         final GHBitSet bs = new GHBitSetImpl(locs);
         for (int start = 0; start < locs; start++)
         {
-            if (g.isNodeRemoved(start) || bs.contains(start))
+            if (bs.contains(start))
                 continue;
 
+            final TIntArrayList intList = new TIntArrayList(20);
+            list.add(intList);
             new BreadthFirstSearch()
             {
                 int tmpCounter = 0;
@@ -126,170 +131,192 @@ protected final boolean goFurther( int nodeId )
                         maxEdgesPerNode.set(tmpCounter);
 
                     tmpCounter = 0;
-                    integ.incrementAndGet();
+                    intList.add(nodeId);
                     return true;
                 }
 
                 @Override
-                protected final boolean checkAdjacent( EdgeIteratorState iter )
+                protected final boolean checkAdjacent( EdgeIteratorState edge )
                 {
-                    tmpCounter++;
-                    return true;
+                    if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags()))
+                    {
+                        tmpCounter++;
+                        return true;
+                    }
+                    return false;
                 }
 
             }.start(explorer, start);
-            map.put(start, integ.get());
-            integ.set(0);
+            intList.trimToSize();
         }
-        return map;
+        return list;
     }
 
     /**
      * Deletes all but the largest subnetworks.
      */
-    void keepLargeNetworks( Map<Integer, Integer> map )
+    int keepLargeNetworks( PrepEdgeFilter filter, List<TIntArrayList> components )
     {
-        if (map.size() <= 1)
-            return;
+        if (components.size() <= 1)
+            return 0;
 
-        int biggestStart = -1;
         int maxCount = -1;
+        TIntList oldComponent = null;
         int allRemoved = 0;
-        GHBitSetImpl bs = new GHBitSetImpl(g.getNodes());
-        for (Entry<Integer, Integer> e : map.entrySet())
+        FlagEncoder encoder = filter.getEncoder();
+        EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
+        for (TIntArrayList component : components)
         {
-            if (biggestStart < 0)
+            if (maxCount < 0)
             {
-                biggestStart = e.getKey();
-                maxCount = e.getValue();
+                maxCount = component.size();
+                oldComponent = component;
                 continue;
             }
 
-            int removed;
-            if (maxCount < e.getValue())
+            int removedEdges;
+            if (maxCount < component.size())
             {
                 // new biggest area found. remove old
-                removed = removeNetwork(biggestStart, maxCount, bs);
+                removedEdges = removeEdges(explorer, encoder, oldComponent, minNetworkSize);
 
-                biggestStart = e.getKey();
-                maxCount = e.getValue();
+                maxCount = component.size();
+                oldComponent = component;
             } else
             {
-                removed = removeNetwork(e.getKey(), e.getValue(), bs);
+                removedEdges = removeEdges(explorer, encoder, component, minNetworkSize);
             }
 
-            allRemoved += removed;
-            if (removed > g.getNodes() / 3)
-                throw new IllegalStateException("Too many nodes were removed: " + removed + ", all nodes:" + g.getNodes() + ", all removed:" + allRemoved);
+            allRemoved += removedEdges;
         }
 
-        if (allRemoved > g.getNodes() / 2)
-            throw new IllegalStateException("Too many total nodes were removed: " + allRemoved + ", all nodes:" + g.getNodes());
+        if (allRemoved > ghStorage.getAllEdges().getMaxId() / 2)
+            throw new IllegalStateException("Too many total edges were removed: " + allRemoved + ", all edges:" + ghStorage.getAllEdges().getMaxId());
+        return allRemoved;
     }
 
-    /**
-     * Deletes the complete subnetwork reachable through start
-     */
-    int removeNetwork( int start, int entries, final GHBitSet bs )
+    String toString( FlagEncoder encoder, EdgeIterator iter )
     {
-        if (entries >= minNetworkSize)
+        String str = "";
+        while (iter.next())
         {
-            // logger.info("did not remove large network (" + entries + ")");
-            return 0;
+            int adjNode = iter.getAdjNode();
+            str += adjNode + " (" + ghStorage.getNodeAccess().getLat(adjNode) + "," + ghStorage.getNodeAccess().getLon(adjNode) + "), ";
+            str += "speed  (fwd:" + encoder.getSpeed(iter.getFlags()) + ", rev:" + encoder.getReverseSpeed(iter.getFlags()) + "), ";
+            str += "access (fwd:" + encoder.isForward(iter.getFlags()) + ", rev:" + encoder.isBackward(iter.getFlags()) + "), ";
+            str += "distance:" + iter.getDistance();
+            str += ";\n ";
         }
+        return str;
+    }
+
+    /**
+     * This method removes networks that will be never be visited by this filter. See #235 for
+     * example, small areas like parking lots are sometimes connected to the whole network through a
+     * one-way road. This is clearly an error - but is causes the routing to fail when a point gets
+     * connected to this small area. This routine removes all these networks from the graph.
+     * <p>
+     * @return number of removed edges
+     */
+    int removeDeadEndUnvisitedNetworks( final PrepEdgeFilter bothFilter )
+    {
+        // partition ghStorage into strongly connected components using Tarjan's algorithm
+        final EdgeFilter outFilter = new DefaultEdgeFilter(bothFilter.getEncoder(), false, true);
+        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(ghStorage, outFilter).
+                findComponents();
+
+        return removeEdges(bothFilter, components, minOneWayNetworkSize);
+    }
 
-        final AtomicInteger removed = new AtomicInteger(0);
-        EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new BreadthFirstSearch()
+    /**
+     * This method removes the access to edges available from the nodes contained in the components.
+     * But only if a components' size is smaller then the specified min value.
+     * <p>
+     * @return number of removed edges
+     */
+    int removeEdges( final PrepEdgeFilter bothFilter, List<TIntArrayList> components, int min )
+    {
+        // remove edges determined from nodes but only if less than minimum size
+        FlagEncoder encoder = bothFilter.getEncoder();
+        EdgeExplorer explorer = ghStorage.createEdgeExplorer(bothFilter);
+        int removedEdges = 0;
+        for (TIntArrayList component : components)
         {
-            @Override
-            protected GHBitSet createBitSet()
-            {
-                return bs;
-            }
+            removedEdges += removeEdges(explorer, encoder, component, min);
+        }
+        return removedEdges;
+    }
 
-            @Override
-            protected boolean goFurther( int nodeId )
+    int removeEdges( EdgeExplorer explorer, FlagEncoder encoder, TIntList component, int min )
+    {
+        int removedEdges = 0;
+        if (component.size() < min)
+            for (int i = 0; i < component.size(); i++)
             {
-                g.markNodeRemoved(nodeId);
-                removed.incrementAndGet();
-                return super.goFurther(nodeId);
+                EdgeIterator edge = explorer.setBaseNode(component.get(i));
+                while (edge.next())
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), false, false));
+                    removedEdges++;
+                }
             }
-        }.start(explorer, start);
 
-        if (entries != removed.get())
-            throw new IllegalStateException("Did not expect " + removed.get() + " removed nodes; "
-                    + " Expected:" + entries + ", all nodes:" + g.getNodes() + "; "
-                    + " Neighbours:" + toString(explorer.setBaseNode(start)) + "; "
-                    + " Start:" + start + "  (" + g.getNodeAccess().getLat(start) + "," + g.getNodeAccess().getLon(start) + ")");
-
-        return removed.get();
+        return removedEdges;
     }
 
-    String toString( EdgeIterator iter )
+    /**
+     * Removes nodes if all edges are not accessible. I.e. removes zero degree nodes.
+     */
+    void markNodesRemovedIfUnreachable()
     {
-        String str = "";
-        while (iter.next())
+        EdgeExplorer edgeExplorer = ghStorage.createEdgeExplorer();
+        for (int nodeIndex = 0; nodeIndex < ghStorage.getNodes(); nodeIndex++)
         {
-            int adjNode = iter.getAdjNode();
-            str += adjNode + " (" + g.getNodeAccess().getLat(adjNode) + "," + g.getNodeAccess().getLon(adjNode) + "), ";
-            str += "speed  (fwd:" + singleEncoder.getSpeed(iter.getFlags()) + ", rev:" + singleEncoder.getReverseSpeed(iter.getFlags()) + "), ";
-            str += "access (fwd:" + singleEncoder.isForward(iter.getFlags()) + ", rev:" + singleEncoder.isBackward(iter.getFlags()) + "), ";
-            str += "distance:" + iter.getDistance();
-            str += ";\n ";
+            if (detectNodeRemovedForAllEncoders(edgeExplorer, nodeIndex))
+                ghStorage.markNodeRemoved(nodeIndex);
         }
-        return str;
     }
 
     /**
-     * To avoid large processing and a large HashMap remove nodes with no edges up front
-     * <p/>
-     * @return removed nodes
+     * This method checks if the node is removed or inaccessible for ALL encoders.
+     * <p>
+     * @return true if no edges are reachable from the specified nodeIndex for any flag encoder.
      */
-    int removeZeroDegreeNodes()
+    boolean detectNodeRemovedForAllEncoders( EdgeExplorer edgeExplorerAllEdges, int nodeIndex )
     {
-        int removed = 0;
-        int locs = g.getNodes();
-        EdgeExplorer explorer = g.createEdgeExplorer();
-        for (int start = 0; start < locs; start++)
+        // we could implement a 'fast check' for several previously marked removed nodes via GHBitSet 
+        // removedNodesPerVehicle. The problem is that we would need long-indices but BitSet only supports int (due to nodeIndex*numberOfEncoders)
+
+        // if no edges are reachable return true
+        EdgeIterator iter = edgeExplorerAllEdges.setBaseNode(nodeIndex);
+        while (iter.next())
         {
-            EdgeIterator iter = explorer.setBaseNode(start);
-            if (!iter.next())
+            // if at least on encoder allows one direction return false
+            for (FlagEncoder encoder : encoders)
             {
-                removed++;
-                g.markNodeRemoved(start);
+                if (encoder.isBackward(iter.getFlags())
+                        || encoder.isForward(iter.getFlags()))
+                    return false;
             }
         }
-        return removed;
+
+        return true;
     }
 
-    /**
-     * Clean small networks that will be never be visited by this explorer See #86 for example,
-     * small areas like parking lots are sometimes connected to the whole network through a one-way
-     * road. This is clearly an error - but is causes the routing to fail when a point gets
-     * connected to this small area. This routine removes all these points from the graph.
-     * <p/>
-     * @return number of removed nodes
-     */
-    public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
+    static class PrepEdgeFilter extends DefaultEdgeFilter
     {
-        // Partition g into strongly connected components using Tarjan's algorithm.
-        final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
-        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
 
-        // remove components less than minimum size
-        int removedNodes = 0;
-        for (TIntArrayList component : components)
+        FlagEncoder encoder;
+
+        public PrepEdgeFilter( FlagEncoder encoder )
         {
-            if (component.size() < minOneWayNetworkSize)
-            {
-                for (int i = 0; i < component.size(); i++)
-                {
-                    g.markNodeRemoved(component.get(i));
-                    removedNodes++;
-                }
-            }
+            super(encoder);
+            this.encoder = encoder;
+        }
+
+        public FlagEncoder getEncoder()
+        {
+            return encoder;
         }
-        return removedNodes;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index 4d1b653244..e21eab1310 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -20,7 +20,7 @@
 /**
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public enum PriorityCode
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
index fa0bae4eef..7e883a6041 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -23,13 +23,13 @@
 
 /**
  * Special weighting for (motor)bike
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PriorityWeighting extends FastestWeighting
 {
     /**
-     * For now used only in BikeCommonFlagEncoder and MotorcycleFlagEncoder
+     * For now used only in BikeCommonFlagEncoder, FootEncoder and MotorcycleFlagEncoder
      */
     public static final int KEY = 101;
 
@@ -49,6 +49,6 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
         double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
         if (Double.isInfinite(weight))
             return Double.POSITIVE_INFINITY;
-        return weight / (0.5 + encoder.getDouble(edgeState.getFlags(), KEY));
+        return weight / (0.5 + flagEncoder.getDouble(edgeState.getFlags(), KEY));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index 2d72a23410..bce6c2f116 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -26,7 +26,7 @@
 
 /**
  * Specifies the settings for racebikeing
- * <p/>
+ * <p>
  * @author ratrun
  * @author Peter Karich
  */
@@ -42,7 +42,7 @@ public RacingBikeFlagEncoder( PMap properties )
         this(
                 (int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 2),
-                properties.getBool("turnCosts", false) ? 3 : 0
+                properties.getBool("turnCosts", false) ? 1 : 0
         );
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index 3309065849..6ac03176b3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -22,11 +22,24 @@
 /**
  * Calculates the shortest route - independent of a vehicle as the calculation is based on the
  * distance only.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class ShortestWeighting implements Weighting
 {
+    private final FlagEncoder flagEncoder;
+
+    public ShortestWeighting( FlagEncoder flagEncoder )
+    {
+        this.flagEncoder = flagEncoder;
+    }
+
+    @Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return flagEncoder;
+    }
+
     @Override
     public double getMinWeight( double currDistToGoal )
     {
@@ -42,6 +55,6 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
     @Override
     public String toString()
     {
-        return "SHORTEST";
+        return "SHORTEST|" + flagEncoder;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
index 4d028882a8..8d6f116f34 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -1,7 +1,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.stack.array.TIntArrayStack;
@@ -11,17 +11,16 @@
 import java.util.Stack;
 
 /**
- * Implementation of Tarjan's algorithm using an explicit stack.
- * (The traditional recursive approach runs into stack overflow pretty quickly.)
- * <p/>
- * Used for finding strongly connected components to detect dead-ends.
- * <p/>
- * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
+ * Implementation of Tarjan's algorithm using an explicit stack. The traditional recursive approach
+ * runs into stack overflow pretty quickly. Used for finding strongly connected components to detect
+ * dead-ends.
+ * <p>
+ * See http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm. See
+ * http://www.timl.id.au/?p=327 and http://homepages.ecs.vuw.ac.nz/~djp/files/P05.pdf
  */
 public class TarjansStronglyConnectedComponentsAlgorithm
 {
-
-    private final GraphStorage g;
+    private final GraphHopperStorage graph;
     private final TIntArrayStack nodeStack;
     private final GHBitSetImpl onStack;
     private final int[] nodeIndex;
@@ -31,13 +30,13 @@
     private int index = 1;
     private final EdgeFilter edgeFilter;
 
-    public TarjansStronglyConnectedComponentsAlgorithm( final GraphStorage g, final EdgeFilter edgeFilter )
+    public TarjansStronglyConnectedComponentsAlgorithm( GraphHopperStorage graph, final EdgeFilter edgeFilter )
     {
-        this.g = g;
+        this.graph = graph;
         this.nodeStack = new TIntArrayStack();
-        this.onStack = new GHBitSetImpl(g.getNodes());
-        this.nodeIndex = new int[g.getNodes()];
-        this.nodeLowLink = new int[g.getNodes()];
+        this.onStack = new GHBitSetImpl(graph.getNodes());
+        this.nodeIndex = new int[graph.getNodes()];
+        this.nodeLowLink = new int[graph.getNodes()];
         this.edgeFilter = edgeFilter;
     }
 
@@ -46,11 +45,10 @@ public TarjansStronglyConnectedComponentsAlgorithm( final GraphStorage g, final
      */
     public List<TIntArrayList> findComponents()
     {
-
-        int nodes = g.getNodes();
+        int nodes = graph.getNodes();
         for (int start = 0; start < nodes; start++)
         {
-            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start))
+            if (nodeIndex[start] == 0 && !graph.isNodeRemoved(start))
             {
                 strongConnect(start);
             }
@@ -83,7 +81,7 @@ private void strongConnect( int firstNode )
                 nodeStack.push(start);
                 onStack.set(start);
 
-                iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
+                iter = graph.createEdgeExplorer(edgeFilter).setBaseNode(start);
 
             } else
             { // if (state.isResume()) {
@@ -125,6 +123,7 @@ private void strongConnect( int firstNode )
                     onStack.clear(node);
                 }
                 component.add(start);
+                component.trimToSize();
                 onStack.clear(start);
 
                 components.add(component);
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 9638077bd0..b34172516f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -20,6 +20,7 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -150,12 +151,14 @@ void printSummary()
     public static class AlgoHelperEntry
     {
         private Graph queryGraph;
+        private final Graph baseGraph;
         private final LocationIndex idx;
         private AlgorithmOptions opts;
 
-        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        public AlgoHelperEntry( Graph g, Graph baseGraph, AlgorithmOptions opts, LocationIndex idx )
         {
             this.queryGraph = g;
+            this.baseGraph = baseGraph;
             this.opts = opts;
             this.idx = idx;
         }
@@ -170,6 +173,11 @@ public void setQueryGraph( Graph queryGraph )
             this.queryGraph = queryGraph;
         }
 
+        public Graph getBaseGraph()
+        {
+            return baseGraph;
+        }
+
         public void setAlgorithmOptions( AlgorithmOptions opts )
         {
             this.opts = opts;
@@ -188,7 +196,7 @@ public RoutingAlgorithm createAlgo( Graph qGraph )
         @Override
         public String toString()
         {
-            return opts.getAlgorithm();
+            return opts.getAlgorithm() + (queryGraph instanceof CHGraph ? "CH" : "");
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index 97016e72c9..19b0b96bdf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -28,7 +28,7 @@
  * Different options define how precise turn restrictions and costs are taken into account, but
  * still all are without via-way support. BTW: this would not be done at runtime, this would be a
  * pre-processing step to avoid performance penalities.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public enum TraversalMode
@@ -74,7 +74,7 @@
      * Returns the identifier to access the map of the shortest path tree according to the traversal
      * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
      * in edge-based behavior
-     * <p/>
+     * <p>
      * @param iterState the current {@link EdgeIteratorState}
      * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
      * backward searches in bidirectional algorithms.
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index fa769794f9..ca8ce6cb7c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -19,7 +19,7 @@
 
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
- * <p/>
+ * <p>
  * @author Karl Hübner
  */
 public interface TurnCostEncoder
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index 9372701727..3fd4efd813 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -23,7 +23,7 @@
 
 /**
  * Provides methods to retrieve turn costs for a specific turn.
- * <p/>
+ * <p>
  * @author Karl Hübner
  * @author Peter Karich
  */
@@ -96,6 +96,12 @@ public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
         return turnCostEncoder.getTurnCost(turnFlags);
     }
 
+    @Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return superWeighting.getFlagEncoder();
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
index 9941a97067..9f8a980fe5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -2,7 +2,7 @@
 
 /**
  * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
- * <p/>
+ * <p>
  * @author jansoe
  */
 public interface WeightApproximator
diff --git a/core/src/main/java/com/graphhopper/routing/util/Weighting.java b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
index 412666bf54..04e3074c14 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Weighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
@@ -21,14 +21,14 @@
 
 /**
  * Specifies how the best route is calculated. E.g. the fastest or shortest route.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Weighting
 {
     /**
      * Used only for the heuristical estimation in A
-     * <p/>
+     * <p>
      * @return minimal weight. E.g. if you calculate the fastest way it is distance/maxVelocity
      */
     double getMinWeight( double distance );
@@ -43,4 +43,6 @@
      * +Infinity. Make sure your method does not return NaN which can e.g. occur for 0/0.
      */
     double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId );
+
+    FlagEncoder getFlagEncoder();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index 3caa6064ff..1df1e19c14 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -30,7 +30,7 @@ public WeightingMap()
 
     /**
      * Convenient constructor if only one parameter is provided
-     * <p/>
+     * <p>
      */
     public WeightingMap( String weighting )
     {
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index f1db4c9024..8f8e182068 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -23,7 +23,7 @@
 
 /**
  * Interface to convert from place names to points.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Geocoding
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 1332f2b5a8..5e96c480f0 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -23,7 +23,7 @@
 
 /**
  * Interface to convert from points to place names or node ids.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface ReverseGeocoding
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index e551b2f593..9dfe52fbb3 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -2,14 +2,14 @@
  *  Licensed to Peter Karich under one or more contributor license
  *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- *
+ * 
  *  Peter Karich licenses this file to you under the Apache License,
  *  Version 2.0 (the "License"); you may not use this file except
  *  in compliance with the License. You may obtain a copy of the
  *  License at
- *
+ * 
  *       http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,22 +18,143 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.coll.SparseIntIntArray;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.search.NameIndex;
 import com.graphhopper.util.*;
+import static com.graphhopper.util.Helper.nf;
 import com.graphhopper.util.shapes.BBox;
+import java.io.UnsupportedEncodingException;
 
 /**
- * @author Peter Karich
+ * The base graph handles nodes and edges file format. It can be used with different Directory
+ * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
+ * thread safe usage.
+ * <p>
+ * Note: A RAM DataAccess Object is thread-safe in itself but if used in this Graph implementation
+ * it is not write thread safe.
+ * <p>
+ * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
+ * loadExisting, (4) usage, (5) flush, (6) close
  */
 class BaseGraph implements Graph
 {
-    private final LevelGraph lg;
+    // Emergency stop. to detect if something went wrong with our storage system and to prevent us from an infinit loop.
+    // Road networks typically do not have nodes with plenty of edges!
+    private static final int MAX_EDGES = 1000;
 
-    BaseGraph( LevelGraph lg )
+    // edge memory layout not found in EdgeAccess:
+    int E_GEO, E_NAME, E_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per edge.
+     */
+    int edgeEntryBytes;
+    private boolean initialized = false;
+    final DataAccess edges;
+    /**
+     * interval [0,n)
+     */
+    protected int edgeCount;
+    // node memory layout:
+    protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per node
+     */
+    int nodeEntryBytes;
+    final DataAccess nodes;
+    /**
+     * interval [0,n)
+     */
+    private int nodeCount;
+    final BBox bounds;
+    // remove markers are not yet persistent!
+    private GHBitSet removedNodes;
+    private int edgeEntryIndex, nodeEntryIndex;
+    final NodeAccess nodeAccess;
+    final GraphExtension extStorage;
+    // length | nodeA | nextNode | ... | nodeB
+    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
+    final DataAccess wayGeometry;
+    private int maxGeoRef;
+    final NameIndex nameIndex;
+    final BitUtil bitUtil;
+    private final Directory dir;
+    final EncodingManager encodingManager;
+    private final InternalGraphEventListener listener;
+    private boolean frozen = false;
+    final EdgeAccess edgeAccess;
+
+    public BaseGraph( Directory dir, final EncodingManager encodingManager, boolean withElevation,
+                      InternalGraphEventListener listener, GraphExtension extendedStorage )
     {
-        this.lg = lg;
+        this.dir = dir;
+        this.encodingManager = encodingManager;
+        this.bitUtil = BitUtil.get(dir.getByteOrder());
+        this.wayGeometry = dir.find("geometry");
+        this.nameIndex = new NameIndex(dir);
+        this.nodes = dir.find("nodes");
+        this.edges = dir.find("edges");
+        this.listener = listener;
+        this.edgeAccess = new EdgeAccess(edges, bitUtil)
+        {
+            @Override
+            final EdgeIterable createSingleEdge( EdgeFilter filter )
+            {
+                return new EdgeIterable(BaseGraph.this, this, filter);
+            }
+
+            @Override
+            final int getEdgeRef( int nodeId )
+            {
+                return nodes.getInt((long) nodeId * nodeEntryBytes + N_EDGE_REF);
+            }
+
+            @Override
+            final void setEdgeRef( int nodeId, int edgeId )
+            {
+                nodes.setInt((long) nodeId * nodeEntryBytes + N_EDGE_REF, edgeId);
+            }
+
+            @Override
+            final int getEntryBytes()
+            {
+                return edgeEntryBytes;
+            }
+
+            @Override
+            final long toPointer( int edgeId )
+            {
+                assert isInBounds(edgeId) : "edgeId " + edgeId + " not in bounds [0," + edgeCount + ")";
+                return (long) edgeId * edgeEntryBytes;
+            }
+
+            @Override
+            final boolean isInBounds( int edgeId )
+            {
+                return edgeId < edgeCount && edgeId >= 0;
+            }
+
+            @Override
+            final long reverseFlags( long edgePointer, long flags )
+            {
+                return encodingManager.reverseFlags(flags);
+            }
+
+            @Override
+            public String toString()
+            {
+                return "base edge access";
+            }
+        };
+        this.bounds = BBox.createInverse(withElevation);
+        this.nodeAccess = new GHNodeAccess(this, withElevation);
+        this.extStorage = extendedStorage;
+        this.extStorage.init(this, dir);
     }
 
     @Override
@@ -42,211 +163,1140 @@ public Graph getBaseGraph()
         return this;
     }
 
+    void checkInit()
+    {
+        if (initialized)
+            throw new IllegalStateException("You cannot configure this GraphStorage "
+                    + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
+    }
+
+    protected int loadNodesHeader()
+    {
+        nodeEntryBytes = nodes.getHeader(1 * 4);
+        nodeCount = nodes.getHeader(2 * 4);
+        bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
+        bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
+        bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
+        bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }
+
+        frozen = nodes.getHeader(9 * 4) == 1;
+        return 10;
+    }
+
+    protected int setNodesHeader()
+    {
+        nodes.setHeader(1 * 4, nodeEntryBytes);
+        nodes.setHeader(2 * 4, nodeCount);
+        nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
+        nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
+        nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
+        nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
+        nodes.setHeader(9 * 4, isFrozen() ? 1 : 0);
+        return 10;
+    }
+
+    protected int loadEdgesHeader()
+    {
+        edgeEntryBytes = edges.getHeader(0 * 4);
+        edgeCount = edges.getHeader(1 * 4);
+        return 5;
+    }
+
+    protected int setEdgesHeader()
+    {
+        edges.setHeader(0, edgeEntryBytes);
+        edges.setHeader(1 * 4, edgeCount);
+        edges.setHeader(2 * 4, encodingManager.hashCode());
+        edges.setHeader(3 * 4, extStorage.hashCode());
+        return 5;
+    }
+
+    protected int loadWayGeometryHeader()
+    {
+        maxGeoRef = wayGeometry.getHeader(0);
+        return 1;
+    }
+
+    protected int setWayGeometryHeader()
+    {
+        wayGeometry.setHeader(0, maxGeoRef);
+        return 1;
+    }
+
+    void initStorage()
+    {
+        edgeEntryIndex = 0;
+        nodeEntryIndex = 0;
+        boolean flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
+        edgeAccess.init(nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(encodingManager.getBytesForFlags()),
+                flagsSizeIsLong);
+
+        E_GEO = nextEdgeEntryIndex(4);
+        E_NAME = nextEdgeEntryIndex(4);
+        if (extStorage.isRequireEdgeField())
+            E_ADDITIONAL = nextEdgeEntryIndex(4);
+        else
+            E_ADDITIONAL = -1;
+
+        N_EDGE_REF = nextNodeEntryIndex(4);
+        N_LAT = nextNodeEntryIndex(4);
+        N_LON = nextNodeEntryIndex(4);
+        if (nodeAccess.is3D())
+            N_ELE = nextNodeEntryIndex(4);
+        else
+            N_ELE = -1;
+
+        if (extStorage.isRequireNodeField())
+            N_ADDITIONAL = nextNodeEntryIndex(4);
+        else
+            N_ADDITIONAL = -1;
+
+        initNodeAndEdgeEntrySize();
+        listener.initStorage();
+        initialized = true;
+    }
+
+    /**
+     * Initializes the node area with the empty edge value and default additional value.
+     */
+    void initNodeRefs( long oldCapacity, long newCapacity )
+    {
+        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes)
+        {
+            nodes.setInt(pointer, EdgeIterator.NO_EDGE);
+        }
+        if (extStorage.isRequireNodeField())
+        {
+            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes)
+            {
+                nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());
+            }
+        }
+    }
+
+    protected final int nextEdgeEntryIndex( int sizeInBytes )
+    {
+        int tmp = edgeEntryIndex;
+        edgeEntryIndex += sizeInBytes;
+        return tmp;
+    }
+
+    protected final int nextNodeEntryIndex( int sizeInBytes )
+    {
+        int tmp = nodeEntryIndex;
+        nodeEntryIndex += sizeInBytes;
+        return tmp;
+    }
+
+    protected final void initNodeAndEdgeEntrySize()
+    {
+        nodeEntryBytes = nodeEntryIndex;
+        edgeEntryBytes = edgeEntryIndex;
+    }
+
+    /**
+     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
+     * extend byte capacity
+     */
+    final void ensureNodeIndex( int nodeIndex )
+    {
+        if (!initialized)
+            throw new AssertionError("The graph has not yet been initialized.");
+
+        if (nodeIndex < nodeCount)
+            return;
+
+        long oldNodes = nodeCount;
+        nodeCount = nodeIndex + 1;
+        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
+        if (capacityIncreased)
+        {
+            long newBytesCapacity = nodes.getCapacity();
+            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
+        }
+    }
+
     @Override
     public int getNodes()
     {
-        return lg.getNodes();
+        return nodeCount;
     }
 
     @Override
     public NodeAccess getNodeAccess()
     {
-        return lg.getNodeAccess();
+        return nodeAccess;
     }
 
     @Override
     public BBox getBounds()
     {
-        return lg.getBounds();
+        return bounds;
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirection )
+    {
+        return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
+    }
+
+    void setSegmentSize( int bytes )
+    {
+        checkInit();
+        nodes.setSegmentSize(bytes);
+        edges.setSegmentSize(bytes);
+        wayGeometry.setSegmentSize(bytes);
+        nameIndex.setSegmentSize(bytes);
+        extStorage.setSegmentSize(bytes);
+    }
+
+    void freeze()
+    {
+        if (isFrozen())
+            throw new IllegalStateException("base graph already frozen");
+
+        frozen = true;
+        listener.freeze();
+    }
+
+    boolean isFrozen()
+    {
+        return frozen;
+    }
+
+    public void checkFreeze()
+    {
+        if (isFrozen())
+            throw new IllegalStateException("Cannot add edge or node after baseGraph.freeze was called");
     }
 
+    void create( long initSize )
+    {
+        nodes.create(initSize);
+        edges.create(initSize);
+        wayGeometry.create(initSize);
+        nameIndex.create(1000);
+        extStorage.create(initSize);
+        initStorage();
+        // 0 stands for no separate geoRef
+        maxGeoRef = 4;
+
+        initNodeRefs(0, nodes.getCapacity());
+    }
+
+    String toDetailsString()
+    {
+        return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "MB), "
+                + "nodes:" + nf(getNodes()) + "(" + nodes.getCapacity() / Helper.MB + "MB), "
+                + "name:(" + nameIndex.getCapacity() / Helper.MB + "MB), "
+                + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "MB), "
+                + "bounds:" + bounds;
+    }
+
+    void flush()
+    {
+        setNodesHeader();
+        setEdgesHeader();
+        setWayGeometryHeader();
+
+        wayGeometry.flush();
+        nameIndex.flush();
+        edges.flush();
+        nodes.flush();
+        extStorage.flush();
+    }
+
+    void close()
+    {
+        wayGeometry.close();
+        nameIndex.close();
+        edges.close();
+        nodes.close();
+        extStorage.close();
+    }
+
+    long getCapacity()
+    {
+        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity()
+                + wayGeometry.getCapacity() + extStorage.getCapacity();
+    }
+
+    void loadExisting( String dim )
+    {
+        if (!nodes.loadExisting())
+            throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
+
+        if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
+            throw new IllegalStateException("Configured dimension (" + nodeAccess.getDimension() + ") is not equal "
+                    + "to dimension of loaded graph (" + dim + ")");
+
+        if (!edges.loadExisting())
+            throw new IllegalStateException("Cannot load edges. corrupt file or directory? " + dir);
+
+        if (!wayGeometry.loadExisting())
+            throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
+
+        if (!nameIndex.loadExisting())
+            throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
+
+        if (!extStorage.loadExisting())
+            throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
+
+        // first define header indices of this storage
+        initStorage();
+
+        // now load some properties from stored data
+        loadNodesHeader();
+        loadEdgesHeader();
+        loadWayGeometryHeader();
+    }
+
+    /**
+     * @return to
+     */
+    EdgeIteratorState copyProperties( CommonEdgeIterator from, EdgeIteratorState to )
+    {
+        to.setDistance(from.getDistance()).
+                setName(from.getName()).
+                setFlags(from.getDirectFlags()).
+                setWayGeometry(from.fetchWayGeometry(0));
+
+        if (E_ADDITIONAL >= 0)
+            to.setAdditionalField(from.getAdditionalField());
+        return to;
+    }
+
+    /**
+     * Create edge between nodes a and b
+     * <p>
+     * @return EdgeIteratorState of newly created edge
+     */
     @Override
-    public EdgeIteratorState edge( int a, int b )
+    public EdgeIteratorState edge( int nodeA, int nodeB )
+    {
+        if (isFrozen())
+            throw new IllegalStateException("Cannot create edge if graph is already frozen");
+
+        ensureNodeIndex(Math.max(nodeA, nodeB));
+        int edgeId = edgeAccess.internalEdgeAdd(nextEdgeId(), nodeA, nodeB);
+        EdgeIterable iter = new EdgeIterable(this, edgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(edgeId, nodeB);
+        assert ret;
+        if (extStorage.isRequireEdgeField())
+            iter.setAdditionalField(extStorage.getDefaultEdgeFieldValue());
+
+        return iter;
+    }
+
+    // for test only
+    void setEdgeCount( int cnt )
     {
-        return lg.edge(a, b);
+        edgeCount = cnt;
+    }
+
+    /**
+     * Determine next free edgeId and ensure byte capacity to store edge
+     * <p>
+     * @return next free edgeId
+     */
+    protected int nextEdgeId()
+    {
+        int nextEdge = edgeCount;
+        edgeCount++;
+        if (edgeCount < 0)
+            throw new IllegalStateException("too many edges. new edge id would be negative. " + toString());
+
+        edges.ensureCapacity(((long) edgeCount + 1) * edgeEntryBytes);
+        return nextEdge;
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    public EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
+    {
+        if (!edgeAccess.isInBounds(edgeId))
+            throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
+        checkAdjNodeBounds(adjNode);
+        return edgeAccess.getEdgeProps(edgeId, adjNode);
+    }
+
+    final void checkAdjNodeBounds( int adjNode )
     {
-        return lg.edge(a, b, distance, bothDirections);
+        if (adjNode < 0 && adjNode != Integer.MIN_VALUE || adjNode >= nodeCount)
+            throw new IllegalStateException("adjNode " + adjNode + " out of bounds [0," + nf(nodeCount) + ")");
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
     {
-        if (lg.isShortcut(edgeId))
-            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+        return new EdgeIterable(this, edgeAccess, filter);
+    }
 
-        return lg.getEdgeProps(edgeId, adjNode);
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
     public AllEdgesIterator getAllEdges()
     {
-        final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
-        return new AllEdgesIterator()
+        return new AllEdgeIterator(this, edgeAccess);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        initialized = true;
+        if (g.getClass().equals(getClass()))
         {
-            @Override
-            public int getCount()
-            {
-                return tmpIter.getCount();
-            }
+            _copyTo((BaseGraph) g);
+            return g;
+        } else
+        {
+            return GHUtility.copyTo(this, g);
+        }
+    }
 
-            @Override
-            public boolean next()
-            {
-                while (tmpIter.next())
-                {
-                    if (!tmpIter.isShortcut())
-                    {
-                        return true;
-                    }
-                }
-                return false;
-            }
+    void _copyTo( BaseGraph clonedG )
+    {
+        if (clonedG.edgeEntryBytes != edgeEntryBytes)
+            throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
 
-            @Override
-            public int getEdge()
-            {
-                return tmpIter.getEdge();
-            }
+        if (clonedG.nodeEntryBytes != nodeEntryBytes)
+            throw new IllegalStateException("nodeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeEntryBytes + " vs " + nodeEntryBytes);
 
-            @Override
-            public int getBaseNode()
-            {
-                return tmpIter.getBaseNode();
-            }
+        if (clonedG.nodeAccess.getDimension() != nodeAccess.getDimension())
+            throw new IllegalStateException("dimension cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeAccess.getDimension() + " vs " + nodeAccess.getDimension());
 
-            @Override
-            public int getAdjNode()
-            {
-                return tmpIter.getAdjNode();
-            }
+        // nodes
+        setNodesHeader();
+        nodes.copyTo(clonedG.nodes);
+        clonedG.loadNodesHeader();
 
-            @Override
-            public PointList fetchWayGeometry( int type )
-            {
-                return tmpIter.fetchWayGeometry(type);
-            }
+        // edges
+        setEdgesHeader();
+        edges.copyTo(clonedG.edges);
+        clonedG.loadEdgesHeader();
 
-            @Override
-            public EdgeIteratorState setWayGeometry( PointList list )
+        // name
+        nameIndex.copyTo(clonedG.nameIndex);
+
+        // geometry
+        setWayGeometryHeader();
+        wayGeometry.copyTo(clonedG.wayGeometry);
+        clonedG.loadWayGeometryHeader();
+
+        // extStorage
+        extStorage.copyTo(clonedG.extStorage);
+
+        if (removedNodes == null)
+            clonedG.removedNodes = null;
+        else
+            clonedG.removedNodes = removedNodes.copyTo(new GHBitSetImpl());
+    }
+
+    protected void trimToSize()
+    {
+        long nodeCap = (long) nodeCount * nodeEntryBytes;
+        nodes.trimTo(nodeCap);
+//        long edgeCap = (long) (edgeCount + 1) * edgeEntrySize;
+//        edges.trimTo(edgeCap * 4);
+    }
+
+    /**
+     * This methods disconnects all edges from removed nodes. It does no edge compaction. Then it
+     * moves the last nodes into the deleted nodes, where it needs to update the node ids in every
+     * edge.
+     */
+    void inPlaceNodeRemove( int removeNodeCount )
+    {
+        // Prepare edge-update of nodes which are connected to deleted nodes        
+        int toMoveNodes = getNodes();
+        int itemsToMove = 0;
+
+        // sorted map when we access it via keyAt and valueAt - see below!
+        final SparseIntIntArray oldToNewMap = new SparseIntIntArray(removeNodeCount);
+        GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
+        removedNodes.copyTo(toRemoveSet);
+
+        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
+        // create map of old node ids pointing to new ids        
+        for (int removeNode = removedNodes.next(0);
+                removeNode >= 0;
+                removeNode = removedNodes.next(removeNode + 1))
+        {
+            EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);
+            while (delEdgesIter.next())
             {
-                return tmpIter.setWayGeometry(list);
+                toRemoveSet.add(delEdgesIter.getAdjNode());
             }
 
-            @Override
-            public double getDistance()
+            toMoveNodes--;
+            for (; toMoveNodes >= 0; toMoveNodes--)
             {
-                return tmpIter.getDistance();
+                if (!removedNodes.contains(toMoveNodes))
+                    break;
             }
 
-            @Override
-            public EdgeIteratorState setDistance( double dist )
+            if (toMoveNodes >= removeNode)
+                oldToNewMap.put(toMoveNodes, removeNode);
+
+            itemsToMove++;
+        }
+
+        EdgeIterable adjNodesToDelIter = (EdgeIterable) createEdgeExplorer();
+        // now similar process to disconnectEdges but only for specific nodes
+        // all deleted nodes could be connected to existing. remove the connections
+        for (int removeNode = toRemoveSet.next(0);
+                removeNode >= 0;
+                removeNode = toRemoveSet.next(removeNode + 1))
+        {
+            // remove all edges connected to the deleted nodes
+            adjNodesToDelIter.setBaseNode(removeNode);
+            long prev = EdgeIterator.NO_EDGE;
+            while (adjNodesToDelIter.next())
             {
-                return tmpIter.setDistance(dist);
+                int nodeId = adjNodesToDelIter.getAdjNode();
+                // already invalidated
+                if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId))
+                {
+                    int edgeToRemove = adjNodesToDelIter.getEdge();
+                    long edgeToRemovePointer = edgeAccess.toPointer(edgeToRemove);
+                    edgeAccess.internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
+                    edgeAccess.invalidateEdge(edgeToRemovePointer);
+                } else
+                {
+                    prev = adjNodesToDelIter.edgePointer;
+                }
             }
+        }
 
-            @Override
-            public long getFlags()
+        GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);
+        EdgeExplorer movedEdgeExplorer = createEdgeExplorer();
+        // marks connected nodes to rewrite the edges
+        for (int i = 0; i < itemsToMove; i++)
+        {
+            int oldI = oldToNewMap.keyAt(i);
+            EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
+            while (movedEdgeIter.next())
             {
-                return tmpIter.getFlags();
+                int nodeId = movedEdgeIter.getAdjNode();
+                if (nodeId == EdgeAccess.NO_NODE)
+                    continue;
+
+                if (removedNodes.contains(nodeId))
+                    throw new IllegalStateException("shouldn't happen the edge to the node "
+                            + nodeId + " should be already deleted. " + oldI);
+
+                toMoveSet.add(nodeId);
             }
+        }
 
-            @Override
-            public EdgeIteratorState setFlags( long flags )
+        // move nodes into deleted nodes
+        for (int i = 0; i < itemsToMove; i++)
+        {
+            int oldI = oldToNewMap.keyAt(i);
+            int newI = oldToNewMap.valueAt(i);
+            long newOffset = (long) newI * nodeEntryBytes;
+            long oldOffset = (long) oldI * nodeEntryBytes;
+            for (long j = 0; j < nodeEntryBytes; j += 4)
             {
-                return tmpIter.setFlags(flags);
+                nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));
             }
+        }
 
-            @Override
-            public String getName()
+        // *rewrites* all edges connected to moved nodes
+        // go through all edges and pick the necessary <- this is easier to implement than
+        // a more efficient (?) breadth-first search
+        EdgeIterator iter = getAllEdges();
+        while (iter.next())
+        {
+            int nodeA = iter.getBaseNode();
+            int nodeB = iter.getAdjNode();
+            if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
+                continue;
+
+            // now overwrite exiting edge with new node ids 
+            // also flags and links could have changed due to different node order
+            int updatedA = oldToNewMap.get(nodeA);
+            if (updatedA < 0)
+                updatedA = nodeA;
+
+            int updatedB = oldToNewMap.get(nodeB);
+            if (updatedB < 0)
+                updatedB = nodeB;
+
+            int edgeId = iter.getEdge();
+            long edgePointer = edgeAccess.toPointer(edgeId);
+            int linkA = edgeAccess.getEdgeRef(nodeA, nodeB, edgePointer);
+            int linkB = edgeAccess.getEdgeRef(nodeB, nodeA, edgePointer);
+            long flags = edgeAccess.getFlags_(edgePointer, false);
+            edgeAccess.writeEdge(edgeId, updatedA, updatedB, linkA, linkB);
+            edgeAccess.setFlags_(edgePointer, updatedA > updatedB, flags);
+            if (updatedA < updatedB != nodeA < nodeB)
+                setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);
+        }
+
+        if (removeNodeCount >= nodeCount)
+            throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
+
+        // we do not remove the invalid edges => edgeCount stays the same!
+        nodeCount -= removeNodeCount;
+
+        EdgeExplorer explorer = createEdgeExplorer();
+        // health check
+        if (isTestingEnabled())
+        {
+            iter = getAllEdges();
+            while (iter.next())
             {
-                return tmpIter.getName();
+                int base = iter.getBaseNode();
+                int adj = iter.getAdjNode();
+                String str = iter.getEdge()
+                        + ", r.contains(" + base + "):" + removedNodes.contains(base)
+                        + ", r.contains(" + adj + "):" + removedNodes.contains(adj)
+                        + ", tr.contains(" + base + "):" + toRemoveSet.contains(base)
+                        + ", tr.contains(" + adj + "):" + toRemoveSet.contains(adj)
+                        + ", base:" + base + ", adj:" + adj + ", nodeCount:" + nodeCount;
+                if (adj >= nodeCount)
+                    throw new RuntimeException("Adj.node problem with edge " + str);
+
+                if (base >= nodeCount)
+                    throw new RuntimeException("Base node problem with edge " + str);
+
+                try
+                {
+                    explorer.setBaseNode(adj).toString();
+                } catch (Exception ex)
+                {
+                    org.slf4j.LoggerFactory.getLogger(getClass()).error("adj:" + adj);
+                }
+                try
+                {
+                    explorer.setBaseNode(base).toString();
+                } catch (Exception ex)
+                {
+                    org.slf4j.LoggerFactory.getLogger(getClass()).error("base:" + base);
+                }
             }
+            // access last node -> no error
+            explorer.setBaseNode(nodeCount - 1).toString();
+        }
+        removedNodes = null;
+    }
 
-            @Override
-            public EdgeIteratorState setName( String name )
+    @Override
+    public GraphExtension getExtension()
+    {
+        return extStorage;
+    }
+
+    public void setAdditionalEdgeField( long edgePointer, int value )
+    {
+        if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
+            edges.setInt(edgePointer + E_ADDITIONAL, value);
+        else
+            throw new AssertionError("This graph does not support an additional edge field.");
+    }
+
+    private void setWayGeometry_( PointList pillarNodes, long edgePointer, boolean reverse )
+    {
+        if (pillarNodes != null && !pillarNodes.isEmpty())
+        {
+            if (pillarNodes.getDimension() != nodeAccess.getDimension())
+                throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
+                        + "D for graph which is " + nodeAccess.getDimension() + "D");
+
+            int len = pillarNodes.getSize();
+            int dim = nodeAccess.getDimension();
+            int tmpRef = nextGeoRef(len * dim);
+            edges.setInt(edgePointer + E_GEO, tmpRef);
+            long geoRef = (long) tmpRef * 4;
+            byte[] bytes = new byte[len * dim * 4 + 4];
+            ensureGeometry(geoRef, bytes.length);
+            bitUtil.fromInt(bytes, len, 0);
+            if (reverse)
+                pillarNodes.reverse();
+
+            int tmpOffset = 4;
+            boolean is3D = nodeAccess.is3D();
+            for (int i = 0; i < len; i++)
             {
-                return tmpIter.setName(name);
+                double lat = pillarNodes.getLatitude(i);
+                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
+                tmpOffset += 4;
+                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
+                tmpOffset += 4;
+
+                if (is3D)
+                {
+                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
+                    tmpOffset += 4;
+                }
             }
 
-            @Override
-            public boolean getBoolean(int key, boolean reverse, boolean _default)
+            wayGeometry.setBytes(geoRef, bytes, bytes.length);
+        } else
+        {
+            edges.setInt(edgePointer + E_GEO, 0);
+        }
+    }
+
+    private PointList fetchWayGeometry_( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
+    {
+        long geoRef = edges.getInt(edgePointer + E_GEO);
+        int count = 0;
+        byte[] bytes = null;
+        if (geoRef > 0)
+        {
+            geoRef *= 4;
+            count = wayGeometry.getInt(geoRef);
+
+            geoRef += 4;
+            bytes = new byte[count * nodeAccess.getDimension() * 4];
+            wayGeometry.getBytes(geoRef, bytes, bytes.length);
+        } else if (mode == 0)
+            return PointList.EMPTY;
+
+        PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
+        if (reverse)
+        {
+            if ((mode & 2) != 0)
+                pillarNodes.add(nodeAccess, adjNode);
+        } else
+        {
+            if ((mode & 1) != 0)
+                pillarNodes.add(nodeAccess, baseNode);
+        }
+
+        int index = 0;
+        for (int i = 0; i < count; i++)
+        {
+            double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));
+            index += 4;
+            double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
+            index += 4;
+            if (nodeAccess.is3D())
             {
-                return tmpIter.getBoolean(key, reverse, _default);
+                pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
+                index += 4;
+            } else
+            {
+                pillarNodes.add(lat, lon);
             }
+        }
 
-            @Override
-            public int getAdditionalField()
+        if (reverse)
+        {
+            if ((mode & 1) != 0)
+                pillarNodes.add(nodeAccess, baseNode);
+            pillarNodes.reverse();
+        } else
+        {
+            if ((mode & 2) != 0)
+                pillarNodes.add(nodeAccess, adjNode);
+        }
+
+        return pillarNodes;
+    }
+
+    private void setName( long edgePointer, String name )
+    {
+        int nameIndexRef = (int) nameIndex.put(name);
+        if (nameIndexRef < 0)
+            throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+        edges.setInt(edgePointer + E_NAME, nameIndexRef);
+    }
+
+    GHBitSet getRemovedNodes()
+    {
+        if (removedNodes == null)
+            removedNodes = new GHBitSetImpl(getNodes());
+
+        return removedNodes;
+    }
+
+    private static boolean isTestingEnabled()
+    {
+        boolean enableIfAssert = false;
+        assert (enableIfAssert = true) : true;
+        return enableIfAssert;
+    }
+
+    private void ensureGeometry( long bytePos, int byteLength )
+    {
+        wayGeometry.ensureCapacity(bytePos + byteLength);
+    }
+
+    private int nextGeoRef( int arrayLength )
+    {
+        int tmp = maxGeoRef;
+        // one more integer to store also the size itself
+        maxGeoRef += arrayLength + 1;
+        return tmp;
+    }
+
+    protected static class EdgeIterable extends CommonEdgeIterator implements EdgeExplorer, EdgeIterator
+    {
+        final EdgeFilter filter;
+        int nextEdgeId;
+
+        public EdgeIterable( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
+        {
+            super(-1, edgeAccess, baseGraph);
+
+            if (filter == null)
+                throw new IllegalArgumentException("Instead null filter use EdgeFilter.ALL_EDGES");
+            this.filter = filter;
+        }
+
+        final void setEdgeId( int edgeId )
+        {
+            this.nextEdgeId = this.edgeId = edgeId;
+        }
+
+        final boolean init( int tmpEdgeId, int expectedAdjNode )
+        {
+            setEdgeId(tmpEdgeId);
+            if (tmpEdgeId != EdgeIterator.NO_EDGE)
             {
-                return tmpIter.getAdditionalField();
+                selectEdgeAccess();
+                this.edgePointer = edgeAccess.toPointer(tmpEdgeId);
             }
 
-            @Override
-            public EdgeIteratorState setAdditionalField( int value )
+            // expect only edgePointer is properly initialized via setEdgeId            
+            baseNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
+            if (baseNode == EdgeAccess.NO_NODE)
+                throw new IllegalStateException("content of edgeId " + edgeId + " is marked as invalid - ie. the edge is already removed!");
+
+            adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
+            // a next() call should return false
+            nextEdgeId = EdgeIterator.NO_EDGE;
+            if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE)
             {
-                return tmpIter.setAdditionalField(value);
+                reverse = false;
+                return true;
+            } else if (expectedAdjNode == baseNode)
+            {
+                reverse = true;
+                baseNode = adjNode;
+                adjNode = expectedAdjNode;
+                return true;
             }
+            return false;
+        }
 
-            @Override
-            public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        final void _setBaseNode( int baseNode )
+        {
+            this.baseNode = baseNode;
+        }
+
+        @Override
+        public EdgeIterator setBaseNode( int baseNode )
+        {
+            // always use base graph edge access
+            setEdgeId(baseGraph.edgeAccess.getEdgeRef(baseNode));
+            _setBaseNode(baseNode);
+            return this;
+        }
+
+        protected void selectEdgeAccess()
+        {
+        }
+
+        @Override
+        public final boolean next()
+        {
+            while (true)
             {
-                return tmpIter.copyPropertiesTo(edge);
+                if (nextEdgeId == EdgeIterator.NO_EDGE)
+                    return false;
+
+                selectEdgeAccess();
+                edgePointer = edgeAccess.toPointer(nextEdgeId);
+                edgeId = nextEdgeId;
+                adjNode = edgeAccess.getOtherNode(baseNode, edgePointer);
+                reverse = baseNode > adjNode;
+                freshFlags = false;
+
+                // position to next edge                
+                nextEdgeId = edgeAccess.getEdgeRef(baseNode, adjNode, edgePointer);
+                assert nextEdgeId != edgeId : ("endless loop detected for base node: " + baseNode + ", adj node: " + adjNode
+                        + ", edge pointer: " + edgePointer + ", edge: " + edgeId);
+
+                if (filter.accept(this))
+                    return true;
             }
+        }
 
-            @Override
-            public EdgeIteratorState detach( boolean reverse )
+        @Override
+        public EdgeIteratorState detach( boolean reverseArg )
+        {
+            if (edgeId == nextEdgeId || edgeId == EdgeIterator.NO_EDGE)
+                throw new IllegalStateException("call next before detaching or setEdgeId (edgeId:" + edgeId + " vs. next " + nextEdgeId + ")");
+
+            EdgeIterable iter = edgeAccess.createSingleEdge(filter);
+            boolean ret;
+            if (reverseArg)
             {
-                return tmpIter.detach(reverse);
-            }
-        };
+                ret = iter.init(edgeId, baseNode);
+                // for #162
+                iter.reverse = !reverse;
+            } else
+                ret = iter.init(edgeId, adjNode);
+            assert ret;
+            return iter;
+        }
     }
 
-    @Override
-    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    /**
+     * Include all edges of this storage in the iterator.
+     */
+    protected static class AllEdgeIterator extends CommonEdgeIterator implements AllEdgesIterator
     {
-        if (filter == EdgeFilter.ALL_EDGES)
-            return createEdgeExplorer();
+        public AllEdgeIterator( BaseGraph baseGraph )
+        {
+            this(baseGraph, baseGraph.edgeAccess);
+        }
 
-        return lg.createEdgeExplorer(new EdgeFilter()
+        private AllEdgeIterator( BaseGraph baseGraph, EdgeAccess edgeAccess )
         {
-            @Override
-            public boolean accept( EdgeIteratorState edgeIterState )
+            super(-1, edgeAccess, baseGraph);
+        }
+
+        @Override
+        public int getMaxId()
+        {
+            return baseGraph.edgeCount;
+        }
+
+        @Override
+        public boolean next()
+        {
+            while (true)
             {
-                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                edgeId++;
+                edgePointer = (long) edgeId * edgeAccess.getEntryBytes();
+                if (!checkRange())
                     return false;
 
-                return filter.accept(edgeIterState);
+                baseNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
+                // some edges are deleted and have a negative node
+                if (baseNode == EdgeAccess.NO_NODE)
+                    continue;
+
+                freshFlags = false;
+                adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
+                // this is always false because of 'getBaseNode() <= getAdjNode()'
+                reverse = false;
+                return true;
+            }
+        }
+
+        protected boolean checkRange()
+        {
+            return edgeId < baseGraph.edgeCount;
+        }
+
+        @Override
+        public final EdgeIteratorState detach( boolean reverseArg )
+        {
+            if (edgePointer < 0)
+                throw new IllegalStateException("call next before detaching");
+
+            AllEdgeIterator iter = new AllEdgeIterator(baseGraph, edgeAccess);
+            iter.edgeId = edgeId;
+            iter.edgePointer = edgePointer;
+            if (reverseArg)
+            {
+                iter.reverse = !this.reverse;
+                iter.baseNode = adjNode;
+                iter.adjNode = baseNode;
+            } else
+            {
+                iter.reverse = this.reverse;
+                iter.baseNode = baseNode;
+                iter.adjNode = adjNode;
             }
-        });
+            return iter;
+        }
     }
 
-    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    /**
+     * Common private super class for AllEdgesIteratorImpl and EdgeIterable
+     */
+    static abstract class CommonEdgeIterator implements EdgeIteratorState
     {
+        protected long edgePointer;
+        protected int baseNode;
+        protected int adjNode;
+        // we need reverse if detach is called 
+        boolean reverse = false;
+        protected EdgeAccess edgeAccess;
+        final BaseGraph baseGraph;
+        boolean freshFlags;
+        private long cachedFlags;
+        int edgeId = -1;
+
+        public CommonEdgeIterator( long edgePointer, EdgeAccess edgeAccess, BaseGraph baseGraph )
+        {
+            this.edgePointer = edgePointer;
+            this.edgeAccess = edgeAccess;
+            this.baseGraph = baseGraph;
+        }
+
         @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
+        public final int getBaseNode()
         {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+            return baseNode;
         }
-    };
 
-    @Override
-    public EdgeExplorer createEdgeExplorer()
-    {
-        return lg.createEdgeExplorer(NO_SHORTCUTS);
-    }
+        @Override
+        public final int getAdjNode()
+        {
+            return adjNode;
+        }
 
-    @Override
-    public Graph copyTo( Graph g )
-    {
-        throw new UnsupportedOperationException("Not supported yet.");
-    }
+        @Override
+        public final double getDistance()
+        {
+            return edgeAccess.getDist(edgePointer);
+        }
 
-    @Override
-    public GraphExtension getExtension()
-    {
-        return lg.getExtension();
+        @Override
+        public final EdgeIteratorState setDistance( double dist )
+        {
+            edgeAccess.setDist(edgePointer, dist);
+            return this;
+        }
+
+        final long getDirectFlags()
+        {
+            if (!freshFlags)
+            {
+                cachedFlags = edgeAccess.getFlags_(edgePointer, reverse);
+                freshFlags = true;
+            }
+            return cachedFlags;
+        }
+
+        @Override
+        public long getFlags()
+        {
+            return getDirectFlags();
+        }
+
+        @Override
+        public final EdgeIteratorState setFlags( long fl )
+        {
+            edgeAccess.setFlags_(edgePointer, reverse, fl);
+            cachedFlags = fl;
+            freshFlags = true;
+            return this;
+        }
+
+        @Override
+        public final int getAdditionalField()
+        {
+            return baseGraph.edges.getInt(edgePointer + baseGraph.E_ADDITIONAL);
+        }
+
+        @Override
+        public final EdgeIteratorState setAdditionalField( int value )
+        {
+            baseGraph.setAdditionalEdgeField(edgePointer, value);
+            return this;
+        }
+
+        @Override
+        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        {
+            return baseGraph.copyProperties(this, edge);
+        }
+
+        /**
+         * Reports wether the edge is available in forward direction for the specified encoder.
+         */
+        @Override
+        public boolean isForward( FlagEncoder encoder )
+        {
+            return encoder.isForward(getDirectFlags());
+        }
+
+        /**
+         * Reports wether the edge is available in backward direction for the specified encoder.
+         */
+        @Override
+        public boolean isBackward( FlagEncoder encoder )
+        {
+            return encoder.isBackward(getDirectFlags());
+        }
+
+        @Override
+        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
+        {
+            baseGraph.setWayGeometry_(pillarNodes, edgePointer, reverse);
+            return this;
+        }
+
+        @Override
+        public PointList fetchWayGeometry( int mode )
+        {
+            return baseGraph.fetchWayGeometry_(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
+        }
+
+        @Override
+        public int getEdge()
+        {
+            return edgeId;
+        }
+
+        @Override
+        public String getName()
+        {
+            int nameIndexRef = baseGraph.edges.getInt(edgePointer + baseGraph.E_NAME);
+            return baseGraph.nameIndex.get(nameIndexRef);
+        }
+
+        @Override
+        public EdgeIteratorState setName( String name )
+        {
+            baseGraph.setName(edgePointer, name);
+            return this;
+        }
+
+        @Override
+        public final boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
+        @Override
+        public final String toString()
+        {
+            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
similarity index 68%
rename from core/src/main/java/com/graphhopper/storage/LevelGraph.java
rename to core/src/main/java/com/graphhopper/storage/CHGraph.java
index d7917c32ef..68dcd4725b 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -17,18 +17,19 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.EdgeSkipExplorer;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeExplorer;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node and creating
- * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
- * <p/>
+ * Extended graph interface which supports Contraction Hierarchies. Ie. storing and retrieving the
+ * levels for a node and creating shortcuts, which are additional 'artificial' edges to speedup
+ * traversal in certain cases.
+ * <p>
  * @author Peter Karich
  */
-public interface LevelGraph extends Graph
+public interface CHGraph extends Graph
 {
     /**
      * This methods sets the level of the specified node.
@@ -46,17 +47,17 @@
      * This method creates a shortcut between a to b which is nearly identical to creating an edge
      * except that it can be excluded or included for certain traversals or algorithms.
      */
-    EdgeSkipIterState shortcut( int a, int b );
+    CHEdgeIteratorState shortcut( int a, int b );
 
     @Override
-    EdgeSkipIterState getEdgeProps( int edgeId, int endNode );
+    CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode );
 
     @Override
-    EdgeSkipExplorer createEdgeExplorer();
+    CHEdgeExplorer createEdgeExplorer();
 
     @Override
-    EdgeSkipExplorer createEdgeExplorer( EdgeFilter filter );
+    CHEdgeExplorer createEdgeExplorer( EdgeFilter filter );
 
     @Override
-    AllEdgesSkipIterator getAllEdges();
+    AllCHEdgesIterator getAllEdges();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
new file mode 100644
index 0000000000..64155fb13e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -0,0 +1,723 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.storage.BaseGraph.AllEdgeIterator;
+import com.graphhopper.storage.BaseGraph.CommonEdgeIterator;
+import com.graphhopper.storage.BaseGraph.EdgeIterable;
+import com.graphhopper.util.*;
+import static com.graphhopper.util.Helper.nf;
+import com.graphhopper.util.shapes.BBox;
+
+/**
+ * A Graph implementation necessary for Contraction Hierarchies. This class enables the storage to
+ * hold the level of a node and shortcut edges per edge.
+ * <p>
+ * @author Peter Karich
+ */
+public class CHGraphImpl implements CHGraph, Storable<CHGraph>
+{
+    private static final double WEIGHT_FACTOR = 1000f;
+    // 2 bits for access, for now only 32bit => not Long.MAX
+    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
+    private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
+    private int N_LEVEL;
+    int N_CH_REF;
+    // shortcut memory layout is synced with edges indices until E_FLAGS, then:
+    private int S_SKIP_EDGE1, S_SKIP_EDGE2;
+
+    int shortcutEntryBytes;
+    private int shortcutCount = 0;
+    final DataAccess shortcuts;
+    // the nodesCH storage is limited via baseGraph.nodeCount too
+    int nodeCHEntryBytes;
+    final DataAccess nodesCH;
+    final long scDirMask = PrepareEncoder.getScDirMask();
+    private final BaseGraph baseGraph;
+    private final EdgeAccess chEdgeAccess;
+    private final Weighting weighting;
+
+    CHGraphImpl( Weighting w, Directory dir, final BaseGraph baseGraph )
+    {
+        if (w == null)
+            throw new IllegalStateException("Weighting for CHGraph cannot be null");
+
+        this.weighting = w;
+        this.baseGraph = baseGraph;
+        final String name = weightingToFileName(w);
+        this.nodesCH = dir.find("nodes_ch_" + name);
+        this.shortcuts = dir.find("shortcuts_" + name);
+        this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil)
+        {
+            @Override
+            final EdgeIterable createSingleEdge( EdgeFilter edgeFilter )
+            {
+                return new CHEdgeIteratorImpl(baseGraph, this, edgeFilter);
+            }
+
+            @Override
+            final int getEdgeRef( int nodeId )
+            {
+                return nodesCH.getInt((long) nodeId * nodeCHEntryBytes + N_CH_REF);
+            }
+
+            @Override
+            final void setEdgeRef( int nodeId, int edgeId )
+            {
+                nodesCH.setInt((long) nodeId * nodeCHEntryBytes + N_CH_REF, edgeId);
+            }
+
+            @Override
+            final int getEntryBytes()
+            {
+                return shortcutEntryBytes;
+            }
+
+            @Override
+            final long toPointer( int shortcutId )
+            {
+                assert isInBounds(shortcutId) : "shortcutId " + shortcutId + " not in bounds [" + baseGraph.edgeCount + ", " + (baseGraph.edgeCount + shortcutCount) + ")";
+                return (long) (shortcutId - baseGraph.edgeCount) * shortcutEntryBytes;
+            }
+
+            @Override
+            final boolean isInBounds( int shortcutId )
+            {
+                int tmp = shortcutId - baseGraph.edgeCount;
+                return tmp < shortcutCount && tmp >= 0;
+            }
+
+            @Override
+            final long reverseFlags( long edgePointer, long flags )
+            {
+                boolean isShortcut = edgePointer >= toPointer(baseGraph.edgeCount);
+                if (!isShortcut)
+                    return baseGraph.edgeAccess.reverseFlags(edgePointer, flags);
+
+                // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
+                long dir = flags & scDirMask;
+                if (dir == scDirMask || dir == 0)
+                    return flags;
+
+                // swap the last bits with this mask
+                return flags ^ scDirMask;
+            }
+
+            @Override
+            public String toString()
+            {
+                return "ch edge access " + name;
+            }
+        };
+    }
+
+    public final Weighting getWeighting()
+    {
+        return weighting;
+    }
+
+    /**
+     * Replaces all characters which are not numbers, characters or underscores with underscores
+     */
+    public String weightingToFileName( Weighting w )
+    {
+        return w.toString().toLowerCase().replaceAll("\\W+", "_");
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        assert baseGraph.isFrozen() : "level graph not yet frozen";
+        return edgeId >= baseGraph.edgeCount;
+    }
+
+    @Override
+    public final void setLevel( int nodeIndex, int level )
+    {
+        checkNodeId(nodeIndex);
+        nodesCH.setInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL, level);
+    }
+
+    @Override
+    public final int getLevel( int nodeIndex )
+    {
+        checkNodeId(nodeIndex);
+        return nodesCH.getInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL);
+    }
+
+    final void checkNodeId( int nodeId )
+    {
+        assert nodeId < baseGraph.getNodes() : "node " + nodeId + " is invalid. Not in [0," + baseGraph.getNodes() + ")";
+    }
+
+    @Override
+    public CHEdgeIteratorState shortcut( int a, int b )
+    {
+        if (!baseGraph.isFrozen())
+            throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
+
+        checkNodeId(a);
+        checkNodeId(b);
+
+        int scId = chEdgeAccess.internalEdgeAdd(nextShortcutId(), a, b);
+        CHEdgeIteratorImpl iter = new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(scId, b);
+        assert ret;
+        iter.setSkippedEdges(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        return iter;
+    }
+
+    protected int nextShortcutId()
+    {
+        int nextSC = shortcutCount;
+        shortcutCount++;
+        if (shortcutCount < 0)
+            throw new IllegalStateException("too many shortcuts. new shortcut id would be negative. " + toString());
+
+        shortcuts.ensureCapacity(((long) shortcutCount + 1) * shortcutEntryBytes);
+        return nextSC + baseGraph.edgeCount;
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    {
+        return edge(a, b).setDistance(distance).setFlags(baseGraph.encodingManager.flagsDefault(true, bothDirections));
+    }
+
+    @Override
+    public CHEdgeIteratorState edge( int a, int b )
+    {
+        // increase edge array not for shortcuts
+        baseGraph.ensureNodeIndex(Math.max(a, b));
+        int edgeId = baseGraph.edgeAccess.internalEdgeAdd(baseGraph.nextEdgeId(), a, b);
+        CHEdgeIteratorImpl iter = new CHEdgeIteratorImpl(baseGraph, baseGraph.edgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(edgeId, b);
+        assert ret;
+        return iter;
+    }
+
+    @Override
+    public CHEdgeExplorer createEdgeExplorer()
+    {
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
+    }
+
+    @Override
+    public CHEdgeExplorer createEdgeExplorer( EdgeFilter filter )
+    {
+        return new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, filter);
+    }
+
+    @Override
+    public final CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode )
+    {
+        if (isShortcut(edgeId))
+        {
+            if (!chEdgeAccess.isInBounds(edgeId))
+                throw new IllegalStateException("shortcutId " + edgeId + " out of bounds");
+        } else
+        {
+            if (!baseGraph.edgeAccess.isInBounds(edgeId))
+                throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
+        }
+
+        return (CHEdgeIteratorState) chEdgeAccess.getEdgeProps(edgeId, endNode);
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return baseGraph.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return baseGraph.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return baseGraph.getBounds();
+    }
+
+    void _freeze()
+    {
+        long maxCapacity = ((long) getNodes()) * nodeCHEntryBytes;
+        nodesCH.ensureCapacity(maxCapacity);
+        long baseCapacity = baseGraph.nodes.getCapacity();
+
+        // copy normal edge refs into ch edge refs
+        for (long pointer = N_CH_REF, basePointer = baseGraph.N_EDGE_REF;
+                pointer < maxCapacity;
+                pointer += nodeCHEntryBytes, basePointer += baseGraph.nodeEntryBytes)
+        {
+            if (basePointer >= baseCapacity)
+                throw new IllegalStateException("Cannot copy edge refs into ch graph. "
+                        + "pointer:" + pointer + ", cap:" + maxCapacity + ", basePtr:" + basePointer + ", baseCap:" + baseCapacity);
+
+            nodesCH.setInt(pointer, baseGraph.nodes.getInt(basePointer));
+        }
+    }
+
+    String toDetailsString()
+    {
+        return toString() + ", shortcuts:" + nf(shortcutCount) + ", nodesCH:(" + nodesCH.getCapacity() / Helper.MB + "MB)";
+    }
+
+    class CHEdgeIteratorImpl extends EdgeIterable implements CHEdgeExplorer, CHEdgeIterator
+    {
+        public CHEdgeIteratorImpl( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
+        {
+            super(baseGraph, edgeAccess, filter);
+        }
+
+        @Override
+        public final long getFlags()
+        {
+            checkShortcut(false, "getFlags");
+            return super.getDirectFlags();
+        }
+
+        @Override
+        public final CHEdgeIterator setBaseNode( int baseNode )
+        {
+            assert baseGraph.isFrozen() : "Traversal CHGraph is only possible if BaseGraph is frozen";
+
+            // always use ch edge access
+            setEdgeId(chEdgeAccess.getEdgeRef(baseNode));
+            _setBaseNode(baseNode);
+            return this;
+        }
+
+        @Override
+        public final void setSkippedEdges( int edge1, int edge2 )
+        {
+            checkShortcut(true, "setSkippedEdges");
+            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2))
+            {
+                throw new IllegalStateException("Skipped edges of a shortcut needs "
+                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
+            }
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+        }
+
+        @Override
+        public final int getSkippedEdge1()
+        {
+            checkShortcut(true, "getSkippedEdge1");
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE1);
+        }
+
+        @Override
+        public final int getSkippedEdge2()
+        {
+            checkShortcut(true, "getSkippedEdge2");
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
+        }
+
+        @Override
+        public final boolean isShortcut()
+        {
+            // assert baseGraph.isFrozen() : "chgraph not yet frozen";
+            return edgeId >= baseGraph.edgeCount;
+        }
+
+        @Override
+        public boolean isBackward( FlagEncoder encoder )
+        {
+            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+            if (isShortcut())
+                return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
+
+            return encoder.isBackward(getDirectFlags());
+        }
+
+        @Override
+        public boolean isForward( FlagEncoder encoder )
+        {
+            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+            if (isShortcut())
+                return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
+
+            return encoder.isForward(getDirectFlags());
+        }
+
+        @Override
+        public final CHEdgeIteratorState setWeight( double weight )
+        {
+            checkShortcut(true, "setWeight");
+            CHGraphImpl.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            checkShortcut(true, "getWeight");
+            return CHGraphImpl.this.getWeight(this);
+        }
+
+        @Override
+        protected final void selectEdgeAccess()
+        {
+            if (nextEdgeId < baseGraph.edgeCount)
+                // iterate over edges
+                edgeAccess = baseGraph.edgeAccess;
+            else
+                // ... or shortcuts
+                edgeAccess = chEdgeAccess;
+        }
+
+        public void checkShortcut( boolean shouldBeShortcut, String methodName )
+        {
+            if (isShortcut())
+            {
+                if (!shouldBeShortcut)
+                    throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
+            } else
+            {
+                if (shouldBeShortcut)
+                    throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
+            }
+        }
+
+        @Override
+        public final String getName()
+        {
+            checkShortcut(false, "getName");
+            return super.getName();
+        }
+
+        @Override
+        public final EdgeIteratorState setName( String name )
+        {
+            checkShortcut(false, "setName");
+            return super.setName(name);
+        }
+
+        @Override
+        public final PointList fetchWayGeometry( int mode )
+        {
+            checkShortcut(false, "fetchWayGeometry");
+            return super.fetchWayGeometry(mode);
+        }
+
+        @Override
+        public final EdgeIteratorState setWayGeometry( PointList list )
+        {
+            checkShortcut(false, "setWayGeometry");
+            return super.setWayGeometry(list);
+        }
+
+        @Override
+        public boolean canBeOverwritten( long flags )
+        {
+            return PrepareEncoder.canBeOverwritten(getDirectFlags(), flags);
+        }
+    }
+
+    /**
+     * Disconnects the edges (higher to lower node) via the specified edgeState pointing from lower to
+     * higher node.
+     * <p>
+     * @param edgeState the edge from lower to higher
+     */
+    public void disconnect( CHEdgeExplorer explorer, EdgeIteratorState edgeState )
+    {
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
+        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
+        CHEdgeIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
+        int tmpPrevEdge = EdgeIterator.NO_EDGE;
+        while (tmpIter.next())
+        {
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
+            {
+                // TODO this is ugly, move this somehow into the underlying iteration logic
+                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
+                        : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
+                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer,
+                        edgeState.getAdjNode(), edgeState.getBaseNode());
+                break;
+            }
+
+            tmpPrevEdge = tmpIter.getEdge();
+        }
+    }
+
+    @Override
+    public AllCHEdgesIterator getAllEdges()
+    {
+        return new AllCHEdgesIteratorImpl(baseGraph);
+    }
+
+    class AllCHEdgesIteratorImpl extends AllEdgeIterator implements AllCHEdgesIterator
+    {
+        public AllCHEdgesIteratorImpl( BaseGraph baseGraph )
+        {
+            super(baseGraph);
+        }
+
+        @Override
+        protected final boolean checkRange()
+        {
+            if (isShortcut())
+                return edgeId < shortcutCount;
+
+            if (super.checkRange())
+                return true;
+
+            // iterate over shortcuts
+            edgeAccess = chEdgeAccess;
+            edgeId = 0;
+            edgePointer = (long) edgeId * shortcutEntryBytes;
+            return edgeId < shortcutCount;
+        }
+
+        @Override
+        public int getEdge()
+        {
+            if (isShortcut())
+                return baseGraph.edgeCount + edgeId;
+            return super.getEdge();
+        }
+
+        @Override
+        public boolean isBackward( FlagEncoder encoder )
+        {
+            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+            if (isShortcut())
+                return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
+
+            return encoder.isBackward(getDirectFlags());
+        }
+
+        @Override
+        public boolean isForward( FlagEncoder encoder )
+        {
+            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+            if (isShortcut())
+                return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
+
+            return encoder.isForward(getDirectFlags());
+        }
+
+        @Override
+        public final long getFlags()
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Shortcut should not need to return raw flags!");
+            return getDirectFlags();
+        }
+
+        @Override
+        public int getMaxId()
+        {
+            return super.getMaxId() + shortcutCount;
+        }
+
+        @Override
+        public final void setSkippedEdges( int edge1, int edge2 )
+        {
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+        }
+
+        @Override
+        public final int getSkippedEdge1()
+        {
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE1);
+        }
+
+        @Override
+        public final int getSkippedEdge2()
+        {
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE2);
+        }
+
+        @Override
+        public final boolean isShortcut()
+        {
+            assert baseGraph.isFrozen() : "level graph not yet frozen";
+            return edgeAccess == chEdgeAccess;
+        }
+
+        @Override
+        public final CHEdgeIteratorState setWeight( double weight )
+        {
+            CHGraphImpl.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            return CHGraphImpl.this.getWeight(this);
+        }
+
+        @Override
+        public boolean canBeOverwritten( long flags )
+        {
+            return PrepareEncoder.canBeOverwritten(getDirectFlags(), flags);
+        }
+    }
+
+    final void setWeight( CommonEdgeIterator edge, double weight )
+    {
+        if (weight < 0)
+            throw new IllegalArgumentException("weight cannot be negative but was " + weight);
+
+        long weightLong;
+        if (weight > MAX_WEIGHT)
+            weightLong = MAX_WEIGHT_LONG;
+        else
+            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
+
+        long accessFlags = edge.getDirectFlags() & scDirMask;
+        edge.setFlags(weightLong | accessFlags);
+    }
+
+    final double getWeight( CommonEdgeIterator edge )
+    {
+        // no need for reverseFlags call (shortcut has identical weight if both dies) and also no need for 64bit        
+        long flags32bit = edge.getDirectFlags();
+        double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
+        if (weight >= MAX_WEIGHT)
+            return Double.POSITIVE_INFINITY;
+
+        return weight;
+    }
+
+    protected int loadEdgesHeader()
+    {
+        shortcutCount = shortcuts.getHeader(0 * 4);
+        shortcutEntryBytes = shortcuts.getHeader(1 * 4);
+        return 3;
+    }
+
+    protected int setEdgesHeader()
+    {
+        shortcuts.setHeader(0 * 4, shortcutCount);
+        shortcuts.setHeader(1 * 4, shortcutEntryBytes);
+        return 3;
+    }
+
+    @Override
+    public GraphExtension getExtension()
+    {
+        return baseGraph.getExtension();
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        CHGraphImpl tmpG = ((CHGraphImpl) g);
+
+        nodesCH.copyTo(tmpG.nodesCH);
+        shortcuts.copyTo(tmpG.shortcuts);
+
+        tmpG.N_LEVEL = N_LEVEL;
+        tmpG.N_CH_REF = N_CH_REF;
+        tmpG.nodeCHEntryBytes = nodeCHEntryBytes;
+        return g;
+    }
+
+    void initStorage()
+    {
+        EdgeAccess ea = baseGraph.edgeAccess;
+        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS, false);
+        // shortcuts
+        S_SKIP_EDGE1 = ea.E_FLAGS + 4;
+        S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
+        shortcutEntryBytes = S_SKIP_EDGE2 + 4;
+
+        // node based data:
+        N_LEVEL = 0;
+        N_CH_REF = N_LEVEL + 4;
+        nodeCHEntryBytes = N_CH_REF + 4;
+    }
+
+    void setSegmentSize( int bytes )
+    {
+        nodesCH.setSegmentSize(bytes);
+        shortcuts.setSegmentSize(bytes);
+    }
+
+    @Override
+    public CHGraph create( long bytes )
+    {
+        nodesCH.create(bytes);
+        shortcuts.create(bytes);
+        return this;
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!nodesCH.loadExisting() || !shortcuts.loadExisting())
+            return false;
+
+        loadEdgesHeader();
+        return true;
+    }
+
+    @Override
+    public void flush()
+    {
+        nodesCH.flush();
+        shortcuts.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        nodesCH.close();
+        shortcuts.close();
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return nodesCH.isClosed();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return nodesCH.getCapacity() + shortcuts.getCapacity();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "CHGraph|" + getWeighting().toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index 13117929fd..53278d9428 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -19,7 +19,7 @@
 
 /**
  * Defines how a DataAccess object is created.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DAType
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index 0810cfe126..4538128065 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -21,10 +21,10 @@
  * Abstraction of the underlying datastructure with a unique id and location. To ensure that the id
  * is unique use a Directory.attach or findAttach, if you don't need uniqueness call
  * Directory.create. Current implementations are RAM and memory mapped access.
- * <p/>
+ * <p>
  * Life cycle: (1) object creation, (2) configuration (e.g. segment size), (3) create or
  * loadExisting, (4) usage and calling ensureCapacity if necessary, (5) close
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface DataAccess extends Storable<DataAccess>
@@ -37,7 +37,7 @@
     /**
      * Renames the underlying DataAccess object. (Flushing shouldn't be necessary before or
      * afterwards)
-     * <p/>
+     * <p>
      * @throws IllegalStateException if a rename is not possible
      */
     void rename( String newName );
@@ -69,7 +69,7 @@
 
     /**
      * Get bytes from position 'index'
-     * <p/>
+     * <p>
      * @param values acts as output
      */
     void getBytes( long bytePos, byte[] values, int length );
@@ -94,7 +94,7 @@
     /**
      * Ensures that the capacity of this object is at least the specified bytes. The first time you
      * have to call 'create' instead.
-     * <p/>
+     * <p>
      * @return true if size was increased
      * @see #create(long)
      */
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 43c1f7d36a..172c62499b 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -24,7 +24,7 @@
  * Maintains a collection of DataAccess objects stored at the same location. One GraphStorage per
  * Directory as we need one to maintain one DataAccess object for nodes, edges and location2id
  * index.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Directory
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
new file mode 100644
index 0000000000..c8a978d537
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -0,0 +1,243 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * @author Peter Karich
+ */
+abstract class EdgeAccess
+{
+    // distance of around +-1000 000 meter are ok
+    private static final double INT_DIST_FACTOR = 1000d;
+    static final int NO_NODE = -1;
+    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
+    final DataAccess edges;
+    private final BitUtil bitUtil;
+    private boolean flagsSizeIsLong;
+
+    EdgeAccess( DataAccess edges, BitUtil bitUtil )
+    {
+        this.edges = edges;
+        this.bitUtil = bitUtil;
+    }
+
+    final void init( int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS, boolean flagsSizeIsLong )
+    {
+        this.E_NODEA = E_NODEA;
+        this.E_NODEB = E_NODEB;
+        this.E_LINKA = E_LINKA;
+        this.E_LINKB = E_LINKB;
+        this.E_DIST = E_DIST;
+        this.E_FLAGS = E_FLAGS;
+        this.flagsSizeIsLong = flagsSizeIsLong;
+    }
+
+    abstract BaseGraph.EdgeIterable createSingleEdge( EdgeFilter edgeFilter );
+
+    abstract long toPointer( int edgeOrShortcutId );
+
+    abstract boolean isInBounds( int edgeOrShortcutId );
+
+    abstract long reverseFlags( long edgePointer, long flags );
+
+    abstract int getEdgeRef( int nodeId );
+
+    abstract void setEdgeRef( int nodeId, int edgeId );
+
+    abstract int getEntryBytes();
+
+    final void invalidateEdge( long edgePointer )
+    {
+        edges.setInt(edgePointer + E_NODEA, NO_NODE);
+    }
+
+    final void setDist( long edgePointer, double distance )
+    {
+        edges.setInt(edgePointer + E_DIST, distToInt(distance));
+    }
+
+    /**
+     * Translates double distance to integer in order to save it in a DataAccess object
+     */
+    private int distToInt( double distance )
+    {
+        int integ = (int) (distance * INT_DIST_FACTOR);
+        if (integ < 0)
+            throw new IllegalArgumentException("Distance cannot be empty: "
+                    + distance + ", maybe overflow issue? integer: " + integ);
+
+        // Due to rounding errors e.g. when getting the distance from another DataAccess object
+        // the following exception is not a good idea: 
+        // Allow integ to be 0 only if distance is 0
+        // if (integ == 0 && distance > 0)
+        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
+        //            distance + ", integer: " + integ);
+        return integ;
+    }
+
+    /**
+     * returns distance (already translated from integer to double)
+     */
+    final double getDist( long pointer )
+    {
+        int val = edges.getInt(pointer + E_DIST);
+        if (val == Integer.MAX_VALUE)
+            return Double.POSITIVE_INFINITY;
+
+        return val / INT_DIST_FACTOR;
+    }
+
+    final long getFlags_( long edgePointer, boolean reverse )
+    {
+        int low = edges.getInt(edgePointer + E_FLAGS);
+        long resFlags = low;
+        if (flagsSizeIsLong)
+        {
+            int high = edges.getInt(edgePointer + E_FLAGS + 4);
+            resFlags = bitUtil.combineIntsToLong(low, high);
+        }
+        if (reverse)
+            resFlags = reverseFlags(edgePointer, resFlags);
+
+        return resFlags;
+    }
+
+    final long setFlags_( long edgePointer, boolean reverse, long flags )
+    {
+        if (reverse)
+            flags = reverseFlags(edgePointer, flags);
+
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
+        if (flagsSizeIsLong)
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
+
+        return flags;
+    }
+
+    /**
+     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
+     */
+    final int internalEdgeAdd( int newEdgeId, int fromNodeId, int toNodeId )
+    {
+        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        connectNewEdge(fromNodeId, newEdgeId);
+        if (fromNodeId != toNodeId)
+            connectNewEdge(toNodeId, newEdgeId);
+        return newEdgeId;
+    }
+
+    final int getOtherNode( int nodeThis, long edgePointer )
+    {
+        int nodeA = edges.getInt(edgePointer + E_NODEA);
+        if (nodeA == nodeThis)
+            // return b
+            return edges.getInt(edgePointer + E_NODEB);
+        // return a
+        return nodeA;
+    }
+
+    private long _getLinkPosInEdgeArea( int nodeThis, int nodeOther, long edgePointer )
+    {
+        return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
+    }
+
+    final int getEdgeRef( int nodeThis, int nodeOther, long edgePointer )
+    {
+        return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
+    }
+
+    final void connectNewEdge( int fromNode, int newOrExistingEdge )
+    {
+        int edge = getEdgeRef(fromNode);
+        if (edge > EdgeIterator.NO_EDGE)
+        {
+            long edgePointer = toPointer(newOrExistingEdge);
+            int otherNode = getOtherNode(fromNode, edgePointer);
+            long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
+            edges.setInt(lastLink, edge);
+        }
+        setEdgeRef(fromNode, newOrExistingEdge);
+    }
+
+    final long writeEdge( int edgeId, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther )
+    {
+        if (nodeThis > nodeOther)
+        {
+            int tmp = nodeThis;
+            nodeThis = nodeOther;
+            nodeOther = tmp;
+            tmp = nextEdge;
+            nextEdge = nextEdgeOther;
+            nextEdgeOther = tmp;
+        }
+        if (edgeId < 0 || edgeId == EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("Cannot write edge with illegal ID:" + edgeId + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
+
+        long edgePointer = toPointer(edgeId);
+        edges.setInt(edgePointer + E_NODEA, nodeThis);
+        edges.setInt(edgePointer + E_NODEB, nodeOther);
+        edges.setInt(edgePointer + E_LINKA, nextEdge);
+        edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
+        return edgePointer;
+    }
+
+    /**
+     * This method disconnects the specified edge from the list of edges of the specified node. It
+     * does not release the freed space to be reused.
+     * <p>
+     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
+     * of nodes
+     */
+    final long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode )
+    {
+        long edgeToRemovePointer = toPointer(edgeToRemove);
+        // an edge is shared across the two nodes even if the edge is not in both directions
+        // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
+        int nextEdgeId = getEdgeRef(baseNode, adjNode, edgeToRemovePointer);
+        if (edgeToUpdatePointer < 0)
+        {
+            setEdgeRef(baseNode, nextEdgeId);
+        } else
+        {
+            // adjNode is different for the edge we want to update with the new link
+            long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
+                    ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
+            edges.setInt(link, nextEdgeId);
+        }
+        return edgeToRemovePointer;
+    }
+
+    final EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    {
+        if (edgeId <= EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("edgeId invalid " + edgeId + ", " + this);
+
+        BaseGraph.EdgeIterable edge = createSingleEdge(EdgeFilter.ALL_EDGES);
+        if (edge.init(edgeId, adjNode))
+            return edge;
+
+        // if edgeId exists but adjacent nodes do not match
+        return null;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index 184a4ba9fe..e2fc5e6fbd 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -19,7 +19,7 @@
 
 /**
  * This class is used to create the shortest-path-tree from linked entities.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class EdgeEntry implements Cloneable, Comparable<EdgeEntry>
@@ -59,7 +59,11 @@ public EdgeEntry cloneFull()
     @Override
     public int compareTo( EdgeEntry o )
     {
-        return Double.compare(weight, o.weight);
+        if (weight < o.weight)
+            return -1;
+
+        // assumption no NaN and no -0        
+        return weight > o.weight ? 1 : 0;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 4b01333f0f..aca723fd6b 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -27,7 +27,7 @@
 
 /**
  * Implements some common methods for the subclasses.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHDirectory implements Directory
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index 3aa1a0a5f5..42c771549b 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -22,15 +22,15 @@
 
 /**
  * A helper class for GraphHopperStorage for its node access.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 class GHNodeAccess implements NodeAccess
 {
-    private final GraphHopperStorage that;
+    private final BaseGraph that;
     private final boolean elevation;
 
-    public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
+    public GHNodeAccess( BaseGraph that, boolean withElevation )
     {
         this.that = that;
         this.elevation = withElevation;
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 7bdd3ce8ac..d18d5228a6 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -25,8 +25,8 @@
 
 /**
  * An interface to represent a (geo) graph - suited for efficient storage as it can be requested via
- * indices called node IDs. To get the lat,lon point you need to set up a Location2IDIndex instance.
- * <p/>
+ * indices called node IDs. To get the lat,lon point you need to set up a LocationIndex instance.
+ * <p>
  * @author Peter Karich
  */
 public interface Graph
@@ -55,7 +55,7 @@
     /**
      * Creates an edge between the nodes a and b. To set distance or access use the returned edge
      * and e.g. edgeState.setDistance
-     * <p/>
+     * <p>
      * @param a the index of the starting (tower) node of the edge
      * @param b the index of the ending (tower) node of the edge
      * @return the newly created edge
@@ -69,14 +69,14 @@
 
     /**
      * Returns a wrapper over the specified edgeId.
-     * <p/>
+     * <p>
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
-     * Integer.MIN_VALUE then the edge with undefined values for adjNode and baseNode will be
-     * returned.
-     * @return an edge iterator state
+     * Integer.MIN_VALUE then the edge with uncertain values for adjNode and baseNode (two
+     * possibilities) will be returned.
+     * @return an edge iterator state or potentially null if adjNode does not match
      * @throws IllegalStateException if edgeId is not valid
      */
-    EdgeIteratorState getEdgeProps( int edgeId, int adjNode );
+    EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode );
 
     /**
      * @return all edges in this graph, where baseNode will be the smaller node.
@@ -84,26 +84,24 @@
     AllEdgesIterator getAllEdges();
 
     /**
-     * Returns an iterator which makes it possible to traverse all edges of the specified node if
-     * the filter accepts the edge. Reduce calling this method as much as possible, e.g. create it
-     * before a for loop!
-     * <p/>
+     * Returns an EdgeExplorer which makes it possible to traverse all filtered edges of a specific
+     * node. Reduce calling this method as much as possible, e.g. create an explorer before a for
+     * loop!
+     * <p>
+     * @see EdgeExplorer
      * @see Graph#createEdgeExplorer()
      */
     EdgeExplorer createEdgeExplorer( EdgeFilter filter );
 
     /**
-     * Returns all the edges reachable from the specified index. Same behaviour as
-     * graph.getEdges(index, EdgeFilter.ALL_EDGES);
-     * <p/>
-     * @return all edges regardless of the vehicle type or direction.
+     * @see Graph#createEdgeExplorer(com.graphhopper.routing.util.EdgeFilter)
      */
     EdgeExplorer createEdgeExplorer();
 
     /**
      * Copy this Graph into the specified Graph g.
-     * <p/>
-     * @return the specified GraphStorage g
+     * <p>
+     * @return the specified Graph g
      */
     Graph copyTo( Graph g );
 
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index cfcbc63c83..5ca9841ae4 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -18,10 +18,13 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.Weighting;
+import java.util.Arrays;
+import java.util.Collections;
 
 /**
  * For now this is just a helper class to quickly create a GraphStorage.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GraphBuilder
@@ -30,9 +33,9 @@
     private String location;
     private boolean mmap;
     private boolean store;
-    private boolean level;
     private boolean elevation;
     private long byteCapacity = 100;
+    private Weighting singleCHWeighting;
 
     public GraphBuilder( EncodingManager encodingManager )
     {
@@ -40,13 +43,11 @@ public GraphBuilder( EncodingManager encodingManager )
     }
 
     /**
-     * If true builder will create a LevelGraph
-     * <p/>
-     * @see LevelGraph
+     * This method enables creating a CHGraph with the specified weighting.
      */
-    public GraphBuilder setLevelGraph( boolean level )
+    public GraphBuilder setCHGraph( Weighting singleCHWeighting )
     {
-        this.level = level;
+        this.singleCHWeighting = singleCHWeighting;
         return this;
     }
 
@@ -85,17 +86,12 @@ public boolean hasElevation()
         return elevation;
     }
 
-    public LevelGraphStorage levelGraphBuild()
-    {
-        return (LevelGraphStorage) setLevelGraph(true).build();
-    }
-
     /**
-     * Creates a LevelGraphStorage
+     * Creates a CHGraph
      */
-    public LevelGraphStorage levelGraphCreate()
+    public CHGraph chGraphCreate( Weighting singleCHWeighting )
     {
-        return (LevelGraphStorage) setLevelGraph(true).create();
+        return setCHGraph(singleCHWeighting).create().getGraph(CHGraph.class, singleCHWeighting);
     }
 
     /**
@@ -103,7 +99,7 @@ public LevelGraphStorage levelGraphCreate()
      * Afterwards you'll need to call GraphStorage.create to have a useable object. Better use
      * create.
      */
-    public GraphStorage build()
+    public GraphHopperStorage build()
     {
         Directory dir;
         if (mmap)
@@ -111,16 +107,11 @@ public GraphStorage build()
         else
             dir = new RAMDirectory(location, store);
 
-        GraphStorage graph;
-        if (level)
-            graph = new LevelGraphStorage(dir, encodingManager, elevation);
+        GraphHopperStorage graph;
+        if (encodingManager.needsTurnCostsSupport() || singleCHWeighting == null)
+            graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
         else
-        {
-            if (encodingManager.needsTurnCostsSupport())
-                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
-            else
-                graph = new GraphHopperStorage(dir, encodingManager, elevation);
-        }
+            graph = new GraphHopperStorage(Arrays.asList(singleCHWeighting), dir, encodingManager, elevation, new TurnCostExtension.NoOpExtension());
 
         return graph;
     }
@@ -128,7 +119,7 @@ public GraphStorage build()
     /**
      * Default graph is a GraphStorage with an in memory directory and disabled storing on flush.
      */
-    public GraphStorage create()
+    public GraphHopperStorage create()
     {
         return build().create(byteCapacity);
     }
@@ -136,9 +127,9 @@ public GraphStorage create()
     /**
      * @throws IllegalStateException if not loadable.
      */
-    public GraphStorage load()
+    public GraphHopperStorage load()
     {
-        GraphStorage gs = build();
+        GraphHopperStorage gs = build();
         if (!gs.loadExisting())
         {
             throw new IllegalStateException("Cannot load graph " + location);
diff --git a/core/src/main/java/com/graphhopper/storage/GraphExtension.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
index 380bf4ec82..b46355dfbe 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -44,9 +44,9 @@
     int getDefaultEdgeFieldValue();
 
     /**
-     * initializes the extended storage by giving the graph storage
+     * initializes the extended storage by giving the base graph
      */
-    void init( GraphStorage graph );
+    void init( Graph graph, Directory dir );
 
     /**
      * sets the segment size in all additional data storages
@@ -62,7 +62,7 @@
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements GraphExtension
+    public class NoOpExtension implements GraphExtension
     {
 
         @Override
@@ -90,7 +90,7 @@ public int getDefaultEdgeFieldValue()
         }
 
         @Override
-        public void init( GraphStorage grap )
+        public void init( Graph grap, Directory dir )
         {
             // noop
         }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index fc47fe77d2..553294aebd 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -17,140 +17,128 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.coll.GHBitSet;
-import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.coll.SparseIntIntArray;
-import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.*;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.shapes.BBox;
-
-import static com.graphhopper.util.Helper.nf;
-
-import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
 
 /**
- * The main implementation which handles nodes and edges file format. It can be used with different
- * Directory implementations like RAMDirectory for fast access or via MMapDirectory for
- * virtual-memory and not thread safe usage.
- * <p/>
- * Note: A RAM DataAccess Object is thread-safe in itself but if used in this Graph implementation
- * it is not write thread safe.
- * <p/>
- * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
- * loadExisting, (4) usage, (5) flush, (6) close
- * <p/>
+ * This class manages all storage related methods and delegates the calls to the associated graphs.
+ * The associated graphs manage their own necessary data structures and are used to provide e.g.
+ * different traversal methods. By default this class implements the graph interface and results in
+ * identical behavior as the Graph instance from getGraph(Graph.class)
+ * <p>
  * @author Peter Karich
- * @see GraphBuilder Use the GraphBuilder class to create a (Level)GraphStorage easier.
- * @see LevelGraphStorage
+ * @see GraphBuilder to create a (CH)Graph easier
+ * @see #getGraph(java.lang.Class)
  */
-public class GraphHopperStorage implements GraphStorage
+public final class GraphHopperStorage implements GraphStorage, Graph
 {
-    private static final int NO_NODE = -1;
-    // Emergency stop. to detect if something went wrong with our storage system and to prevent us from an infinit loop.
-    // Road networks typically do not have nodes with plenty of edges!
-    private static final int MAX_EDGES = 1000;
-    // distance of around +-1000 000 meter are ok
-    private static final double INT_DIST_FACTOR = 1000d;
     private final Directory dir;
-    // edge memory layout:
-    protected int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS, E_GEO, E_NAME, E_ADDITIONAL;
-    /**
-     * Specifies how many entries (integers) are used per edge.
-     */
-    protected int edgeEntryBytes;
-    protected final DataAccess edges;
-    /**
-     * interval [0,n)
-     */
-    protected int edgeCount;
-    // node memory layout:
-    protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
-    /**
-     * Specifies how many entries (integers) are used per node
-     */
-    protected int nodeEntryBytes;
-    protected final DataAccess nodes;
-    /**
-     * interval [0,n)
-     */
-    private int nodeCount;
-    final BBox bounds;
-    // remove markers are not yet persistent!
-    private GHBitSet removedNodes;
-    private int edgeEntryIndex, nodeEntryIndex;
-    // length | nodeA | nextNode | ... | nodeB
-    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
-    private final DataAccess wayGeometry;
-    private int maxGeoRef;
-    private boolean initialized = false;
     private EncodingManager encodingManager;
-    private final NameIndex nameIndex;
     private final StorableProperties properties;
-    private final BitUtil bitUtil;
-    private boolean flagsSizeIsLong;
-    final GraphExtension extStorage;
-    private final NodeAccess nodeAccess;
+    private final BaseGraph baseGraph;
+    // same flush order etc
+    private final Collection<CHGraphImpl> chGraphs = new ArrayList<CHGraphImpl>(5);
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
+    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage )
     {
-        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
+        this(Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
     }
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
-                               GraphExtension extendedStorage )
+    public GraphHopperStorage( List<? extends Weighting> chWeightings, Directory dir, final EncodingManager encodingManager,
+                               boolean withElevation, GraphExtension extendedStorage )
     {
-        if (encodingManager == null)
-            throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
-                    + "If you need to parse EncodingManager configuration from existing graph use EncodingManager.create");
+        if (extendedStorage == null)
+            throw new IllegalArgumentException("GraphExtension cannot be null, use NoOpExtension");
 
         this.encodingManager = encodingManager;
-        this.extStorage = extendedStorage;
         this.dir = dir;
-        this.bitUtil = BitUtil.get(dir.getByteOrder());
-        this.nodes = dir.find("nodes");
-        this.edges = dir.find("edges");
-        this.wayGeometry = dir.find("geometry");
-        this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.createInverse(withElevation);
-        this.nodeAccess = new GHNodeAccess(this, withElevation);
-        extendedStorage.init(this);
-    }
+        InternalGraphEventListener listener = new InternalGraphEventListener()
+        {
+            @Override
+            public void initStorage()
+            {
+                for (CHGraphImpl cg : chGraphs)
+                {
+                    cg.initStorage();
+                }
+            }
 
-    @Override
-    public Graph getBaseGraph()
-    {
-        return this;
+            @Override
+            public void freeze()
+            {
+                for (CHGraphImpl cg : chGraphs)
+                {
+                    cg._freeze();
+                }
+            }
+        };
+
+        this.baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
+        for (Weighting w : chWeightings)
+        {
+            chGraphs.add(new CHGraphImpl(w, dir, this.baseGraph));
+        }
     }
 
-    void checkInit()
+    /**
+     * This method returns the routing graph for the specified weighting, could be potentially
+     * filled with shortcuts.
+     */
+    public <T extends Graph> T getGraph( Class<T> clazz, Weighting weighting )
     {
-        if (initialized)
-            throw new IllegalStateException("You cannot configure this GraphStorage "
-                    + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
+        if (clazz.equals(Graph.class))
+            return (T) baseGraph;
+
+        if (chGraphs.isEmpty())
+            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
+
+        if (weighting == null)
+            throw new IllegalStateException("Cannot find CHGraph with null weighting");
+
+        List<Weighting> existing = new ArrayList<Weighting>();
+        for (CHGraphImpl cg : chGraphs)
+        {
+            if (cg.getWeighting() == weighting)
+                return (T) cg;
+
+            existing.add(cg.getWeighting());
+        }
+
+        throw new IllegalStateException("Cannot find CHGraph for specified weighting: " + weighting + ", existing:" + existing);
     }
 
-    protected final int nextEdgeEntryIndex( int sizeInBytes )
+    public <T extends Graph> T getGraph( Class<T> clazz )
     {
-        int tmp = edgeEntryIndex;
-        edgeEntryIndex += sizeInBytes;
-        return tmp;
+        if (clazz.equals(Graph.class))
+            return (T) baseGraph;
+
+        if (chGraphs.isEmpty())
+            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
+
+        CHGraph cg = chGraphs.iterator().next();
+        return (T) cg;
     }
 
-    protected final int nextNodeEntryIndex( int sizeInBytes )
+    public boolean isCHPossible()
     {
-        int tmp = nodeEntryIndex;
-        nodeEntryIndex += sizeInBytes;
-        return tmp;
+        return !chGraphs.isEmpty();
     }
 
-    protected final void initNodeAndEdgeEntrySize()
+    public List<Weighting> getCHWeightings()
     {
-        nodeEntryBytes = nodeEntryIndex;
-        edgeEntryBytes = edgeEntryIndex;
+        List<Weighting> list = new ArrayList<Weighting>(chGraphs.size());
+        for (CHGraphImpl cg : chGraphs)
+        {
+            list.add(cg.getWeighting());
+        }
+        return list;
     }
 
     /**
@@ -165,1479 +153,295 @@ public Directory getDirectory()
     @Override
     public void setSegmentSize( int bytes )
     {
-        checkInit();
-        nodes.setSegmentSize(bytes);
-        edges.setSegmentSize(bytes);
-        wayGeometry.setSegmentSize(bytes);
-        nameIndex.setSegmentSize(bytes);
-        extStorage.setSegmentSize(bytes);
+        baseGraph.setSegmentSize(bytes);
+
+        for (CHGraphImpl cg : chGraphs)
+        {
+            cg.setSegmentSize(bytes);
+        }
     }
 
     /**
      * After configuring this storage you need to create it explicitly.
      */
     @Override
-    public GraphStorage create( long byteCount )
+    public GraphHopperStorage create( long byteCount )
     {
-        checkInit();
+        baseGraph.checkInit();
         if (encodingManager == null)
             throw new IllegalStateException("EncodingManager can only be null if you call loadExisting");
 
         long initSize = Math.max(byteCount, 100);
-        nodes.create(initSize);
-        edges.create(initSize);
-        wayGeometry.create(initSize);
-        nameIndex.create(1000);
         properties.create(100);
-        extStorage.create(initSize);
 
         properties.put("graph.bytesForFlags", encodingManager.getBytesForFlags());
         properties.put("graph.flagEncoders", encodingManager.toDetailsString());
 
         properties.put("graph.byteOrder", dir.getByteOrder());
-        properties.put("graph.dimension", nodeAccess.getDimension());
+        properties.put("graph.dimension", baseGraph.nodeAccess.getDimension());
         properties.putCurrentVersions();
-        initStorage();
-        // 0 stands for no separate geoRef
-        maxGeoRef = 4;
 
-        initNodeRefs(0, nodes.getCapacity());
+        baseGraph.create(initSize);
+
+        for (CHGraphImpl cg : chGraphs)
+        {
+            cg.create(byteCount);
+        }
+
+        properties.put("graph.chWeightings", getCHWeightings().toString());
         return this;
     }
 
     @Override
-    public int getNodes()
+    public EncodingManager getEncodingManager()
     {
-        return nodeCount;
+        return encodingManager;
     }
 
     @Override
-    public NodeAccess getNodeAccess()
+    public StorableProperties getProperties()
     {
-        return nodeAccess;
+        return properties;
     }
 
-    /**
-     * Translates double distance to integer in order to save it in a DataAccess object
-     */
-    private int distToInt( double distance )
+    public void setAdditionalEdgeField( long edgePointer, int value )
     {
-        int integ = (int) (distance * INT_DIST_FACTOR);
-        if (integ < 0)
-            throw new IllegalArgumentException("Distance cannot be empty: "
-                    + distance + ", maybe overflow issue? integer: " + integ);
-
-        // Due to rounding errors e.g. when getting the distance from another DataAccess object
-        // the following exception is not a good idea: 
-        // Allow integ to be 0 only if distance is 0
-        // if (integ == 0 && distance > 0)
-        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
-        //            distance + ", integer: " + integ);
-        return integ;
+        baseGraph.setAdditionalEdgeField(edgePointer, value);
     }
 
-    /**
-     * returns distance (already translated from integer to double)
-     */
-    private double getDist( long pointer )
+    @Override
+    public void markNodeRemoved( int index )
     {
-        int val = edges.getInt(pointer + E_DIST);
-        if (val == Integer.MAX_VALUE)
-            return Double.POSITIVE_INFINITY;
-
-        return val / INT_DIST_FACTOR;
+        baseGraph.getRemovedNodes().add(index);
     }
 
     @Override
-    public BBox getBounds()
+    public boolean isNodeRemoved( int index )
     {
-        return bounds;
+        return baseGraph.getRemovedNodes().contains(index);
     }
 
-    /**
-     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
-     * extend byte capacity
-     */
-    final void ensureNodeIndex( int nodeIndex )
+    @Override
+    public void optimize()
     {
-        if (!initialized)
-            throw new AssertionError("The graph has not yet been initialized.");
+        if (isFrozen())
+            throw new IllegalStateException("do not optimize after graph was frozen");
 
-        if (nodeIndex < nodeCount)
+        int delNodes = baseGraph.getRemovedNodes().getCardinality();
+        if (delNodes <= 0)
             return;
 
-        long oldNodes = nodeCount;
-        nodeCount = nodeIndex + 1;
-        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
-        if (capacityIncreased)
-        {
-            long newBytesCapacity = nodes.getCapacity();
-            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
-            if (removedNodes != null)
-                getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
-        }
+        // Deletes only nodes.
+        // It reduces the fragmentation of the node space but introduces new unused edges.
+        baseGraph.inPlaceNodeRemove(delNodes);
 
+        // Reduce memory usage
+        baseGraph.trimToSize();
     }
 
-    /**
-     * Initializes the node area with the empty edge value and default additional value.
-     */
-    private void initNodeRefs( long oldCapacity, long newCapacity )
+    @Override
+    public boolean loadExisting()
     {
-        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes)
-        {
-            nodes.setInt(pointer, EdgeIterator.NO_EDGE);
-        }
-        if (extStorage.isRequireNodeField())
+        baseGraph.checkInit();
+        if (properties.loadExisting())
         {
-            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes)
+            properties.checkVersions(false);
+            // check encoding for compatiblity
+            String acceptStr = properties.get("graph.flagEncoders");
+
+            if (encodingManager == null)
+            {
+                if (acceptStr.isEmpty())
+                    throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
+                            + dir.getLocation());
+
+                int bytesForFlags = 4;
+                if ("8".equals(properties.get("graph.bytesForFlags")))
+                    bytesForFlags = 8;
+                encodingManager = new EncodingManager(acceptStr, bytesForFlags);
+            } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
             {
-                nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());
+                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
+                        + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
             }
-        }
-    }
 
-    private void ensureEdgeIndex( int edgeIndex )
-    {
-        edges.ensureCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
-    }
+            String byteOrder = properties.get("graph.byteOrder");
+            if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
+                throw new IllegalStateException("Configured byteOrder (" + byteOrder + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
 
-    private void ensureGeometry( long bytePos, int byteLength )
-    {
-        wayGeometry.ensureCapacity(bytePos + byteLength);
-    }
+            String dim = properties.get("graph.dimension");
+            baseGraph.loadExisting(dim);
 
-    @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirection )
-    {
-        return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
+            String loadedCHWeightings = properties.get("graph.chWeightings");
+            String configuredCHWeightings = getCHWeightings().toString();
+            if (!loadedCHWeightings.equals(configuredCHWeightings))
+                throw new IllegalStateException("Configured graph.chWeightings: " + configuredCHWeightings + " is not equal to loaded " + loadedCHWeightings);
+
+            for (CHGraphImpl cg : chGraphs)
+            {
+                if (!cg.loadExisting())
+                    throw new IllegalStateException("Cannot load " + cg);
+            }
+
+            return true;
+        }
+        return false;
     }
 
-    /**
-     * Create edge between nodes a and b
-     * <p/>
-     * @return EdgeIteratorState of newly created edge
-     */
     @Override
-    public EdgeIteratorState edge( int a, int b )
+    public void flush()
     {
-        ensureNodeIndex(Math.max(a, b));
-        int edge = internalEdgeAdd(a, b);
-        EdgeIterable iter = new EdgeIterable(EdgeFilter.ALL_EDGES);
-        iter.setBaseNode(a);
-        iter.setEdgeId(edge);
-        if (extStorage.isRequireEdgeField())
+        for (CHGraphImpl cg : chGraphs)
         {
-            iter.setAdditionalField(extStorage.getDefaultEdgeFieldValue());
+            cg.setEdgesHeader();
+            cg.flush();
         }
-        iter.next();
-        return iter;
-    }
 
-    private int nextGeoRef( int arrayLength )
-    {
-        int tmp = maxGeoRef;
-        // one more integer to store also the size itself
-        maxGeoRef += arrayLength + 1;
-        return tmp;
+        baseGraph.flush();
+        properties.flush();
     }
 
-    /**
-     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
-     */
-    int internalEdgeAdd( int fromNodeId, int toNodeId )
+    @Override
+    public void close()
     {
-        int newEdgeId = nextEdge();
-        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newEdgeId);
-        if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newEdgeId);
+        properties.close();
+        baseGraph.close();
 
-        return newEdgeId;
+        for (CHGraphImpl cg : chGraphs)
+        {
+            cg.close();
+        }
     }
 
-    // for test only
-    void setEdgeCount( int cnt )
+    @Override
+    public boolean isClosed()
     {
-        edgeCount = cnt;
+        return baseGraph.nodes.isClosed();
     }
 
-    /**
-     * Determine next free edgeId and ensure byte capacity to store edge
-     * <p/>
-     * @return next free edgeId
-     */
-    private int nextEdge()
+    @Override
+    public long getCapacity()
     {
-        int nextEdge = edgeCount;
-        edgeCount++;
-        if (edgeCount < 0)
-            throw new IllegalStateException("too many edges. new edge id would be negative. " + toString());
+        long cnt = baseGraph.getCapacity() + properties.getCapacity();
 
-        ensureEdgeIndex(edgeCount);
-        return nextEdge;
-    }
-
-    private void connectNewEdge( int fromNode, int newOrExistingEdge )
-    {
-        long nodePointer = (long) fromNode * nodeEntryBytes;
-        int edge = nodes.getInt(nodePointer + N_EDGE_REF);
-        if (edge > EdgeIterator.NO_EDGE)
+        for (CHGraphImpl cg : chGraphs)
         {
-            long edgePointer = (long) newOrExistingEdge * edgeEntryBytes;
-            int otherNode = getOtherNode(fromNode, edgePointer);
-            long lastLink = getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
-            edges.setInt(lastLink, edge);
+            cnt += cg.getCapacity();
         }
-
-        nodes.setInt(nodePointer + N_EDGE_REF, newOrExistingEdge);
+        return cnt;
     }
 
-    private long writeEdge( int edge, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther )
+    /**
+     * Avoid that edges and nodes of the base graph are further modified. Necessary as hook for e.g.
+     * ch graphs on top to initilize themself
+     */
+    public void freeze()
     {
-        if (nodeThis > nodeOther)
-        {
-            int tmp = nodeThis;
-            nodeThis = nodeOther;
-            nodeOther = tmp;
-
-            tmp = nextEdge;
-            nextEdge = nextEdgeOther;
-            nextEdgeOther = tmp;
-        }
-
-        if (edge < 0 || edge == EdgeIterator.NO_EDGE)
-            throw new IllegalStateException("Cannot write edge with illegal ID:" + edge
-                    + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
-
-        long edgePointer = (long) edge * edgeEntryBytes;
-        edges.setInt(edgePointer + E_NODEA, nodeThis);
-        edges.setInt(edgePointer + E_NODEB, nodeOther);
-        edges.setInt(edgePointer + E_LINKA, nextEdge);
-        edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
-        return edgePointer;
+        if (!baseGraph.isFrozen())
+            baseGraph.freeze();
     }
 
-    protected final long getLinkPosInEdgeArea( int nodeThis, int nodeOther, long edgePointer )
+    boolean isFrozen()
     {
-        return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
+        return baseGraph.isFrozen();
     }
 
-    public String getDebugInfo( int node, int area )
+    @Override
+    public String toDetailsString()
     {
-        String str = "--- node " + node + " ---";
-        int min = Math.max(0, node - area / 2);
-        int max = Math.min(nodeCount, node + area / 2);
-        long nodePointer = (long) node * nodeEntryBytes;
-        for (int i = min; i < max; i++)
+        String str = baseGraph.toDetailsString();
+        for (CHGraphImpl cg : chGraphs)
         {
-            str += "\n" + i + ": ";
-            for (int j = 0; j < nodeEntryBytes; j += 4)
-            {
-                if (j > 0)
-                {
-                    str += ",\t";
-                }
-                str += nodes.getInt(nodePointer + j);
-            }
+            str += ", " + cg.toDetailsString();
         }
-        int edge = nodes.getInt(nodePointer);
-        str += "\n--- edges " + edge + " ---";
-        int otherNode;
-        for (int i = 0; i < 1000; i++)
-        {
-            str += "\n";
-            if (edge == EdgeIterator.NO_EDGE)
-                break;
-
-            str += edge + ": ";
-            long edgePointer = (long) edge * edgeEntryBytes;
-            for (int j = 0; j < edgeEntryBytes; j += 4)
-            {
-                if (j > 0)
-                {
-                    str += ",\t";
-                }
-                str += edges.getInt(edgePointer + j);
-            }
 
-            otherNode = getOtherNode(node, edgePointer);
-            long lastLink = getLinkPosInEdgeArea(node, otherNode, edgePointer);
-            edge = edges.getInt(lastLink);
-        }
         return str;
     }
 
-    private int getOtherNode( int nodeThis, long edgePointer )
-    {
-        int nodeA = edges.getInt(edgePointer + E_NODEA);
-        if (nodeA == nodeThis)
-        // return b
-        {
-            return edges.getInt(edgePointer + E_NODEB);
-        }
-        // return a
-        return nodeA;
-    }
-
     @Override
-    public AllEdgesIterator getAllEdges()
+    public String toString()
     {
-        return new AllEdgeIterator();
+        return (isCHPossible() ? "CH|" : "")
+                + encodingManager
+                + "|" + getDirectory().getDefaultType()
+                + "|" + baseGraph.nodeAccess.getDimension() + "D"
+                + "|" + baseGraph.extStorage
+                + "|" + getProperties().versionsToString();
     }
 
+    // now all delegation graph method to avoid ugly programming flow ala
+    // GraphHopperStorage storage = ..;
+    // Graph g = storage.getGraph(Graph.class);
+    // instead directly the storage can be used to traverse the base graph
     @Override
-    public EncodingManager getEncodingManager()
+    public Graph getBaseGraph()
     {
-        return encodingManager;
+        return baseGraph;
     }
 
     @Override
-    public StorableProperties getProperties()
+    public final int getNodes()
     {
-        return properties;
+        return baseGraph.getNodes();
     }
 
-    /**
-     * Include all edges of this storage in the iterator.
-     */
-    protected class AllEdgeIterator implements AllEdgesIterator
+    @Override
+    public final NodeAccess getNodeAccess()
     {
-        protected long edgePointer = -edgeEntryBytes;
-        private final long maxEdges = (long) edgeCount * edgeEntryBytes;
-        private int nodeA;
-        private int nodeB;
-        private boolean reverse = false;
-
-        public AllEdgeIterator()
-        {
-        }
-
-        @Override
-        public int getCount()
-        {
-            return edgeCount;
-        }
-
-        @Override
-        public boolean next()
-        {
-            do
-            {
-                edgePointer += edgeEntryBytes;
-                nodeA = edges.getInt(edgePointer + E_NODEA);
-                nodeB = edges.getInt(edgePointer + E_NODEB);
-                reverse = getBaseNode() > getAdjNode();
-                // some edges are deleted and have a negative node
-            } while (nodeA == NO_NODE && edgePointer < maxEdges);
-            return edgePointer < maxEdges;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return nodeA;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return nodeB;
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return getDist(edgePointer);
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            edges.setInt(edgePointer + E_DIST, distToInt(dist));
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.getInt(edgePointer + E_ADDITIONAL);
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            GraphHopperStorage.this.setAdditionalEdgeField(edgePointer, value);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            GraphHopperStorage.this.setFlags(edgePointer, reverse, flags);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return GraphHopperStorage.this.copyProperties(this, edge);
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return (int) (edgePointer / edgeEntryBytes);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
-        {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
-            return this;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int type )
-        {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse,
-                    type, getBaseNode(), getAdjNode());
-        }
-
-        @Override
-        public String getName()
-        {
-            int nameIndexRef = edges.getInt(edgePointer + E_NAME);
-            return nameIndex.get(nameIndexRef);
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            GraphHopperStorage.this.setName(edgePointer, name);
-            return this;
-        }
-
-        @Override
-        public boolean getBoolean( int key, boolean reverse, boolean _default )
-        {
-            // for non-existent keys return default
-            return _default;
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgePointer < 0)
-                throw new IllegalStateException("call next before detaching");
-            AllEdgeIterator iter = new AllEdgeIterator();
-            iter.nodeA = nodeA;
-            iter.nodeB = nodeB;
-            iter.edgePointer = edgePointer;
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.nodeA = nodeB;
-                iter.nodeB = nodeA;
-            }
-            return iter;
-        }
-
-        @Override
-        public String toString()
-        {
-            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
-        }
+        return baseGraph.getNodeAccess();
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    public final BBox getBounds()
     {
-        if (edgeId <= EdgeIterator.NO_EDGE || edgeId >= edgeCount)
-            throw new IllegalStateException("edgeId " + edgeId + " out of bounds [0," + nf(edgeCount) + "]");
-
-        if (adjNode < 0 && adjNode != Integer.MIN_VALUE)
-            throw new IllegalStateException("adjNode " + adjNode + " out of bounds [0," + nf(nodeCount) + "]");
-
-        long edgePointer = (long) edgeId * edgeEntryBytes;
-        int nodeA = edges.getInt(edgePointer + E_NODEA);
-        if (nodeA == NO_NODE)
-            throw new IllegalStateException("edgeId " + edgeId + " is invalid - already removed!");
-
-        int nodeB = edges.getInt(edgePointer + E_NODEB);
-        SingleEdge edge;
-        if (adjNode == nodeB || adjNode == Integer.MIN_VALUE)
-        {
-            edge = createSingleEdge(edgeId, nodeA);
-            edge.reverse = false;
-            edge.adjNode = nodeB;
-            return edge;
-        } else if (adjNode == nodeA)
-        {
-            edge = createSingleEdge(edgeId, nodeB);
-            edge.adjNode = nodeA;
-            edge.reverse = true;
-            return edge;
-        }
-        // if edgeId exists but adjacent nodes do not match
-        return null;
+        return baseGraph.getBounds();
     }
 
-    protected SingleEdge createSingleEdge( int edgeId, int nodeId )
+    @Override
+    public final EdgeIteratorState edge( int a, int b )
     {
-        return new SingleEdge(edgeId, nodeId);
+        return baseGraph.edge(a, b);
     }
 
-    private long getFlags( long edgePointer, boolean reverse )
+    @Override
+    public final EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        int low = edges.getInt(edgePointer + E_FLAGS);
-        long res = low;
-        if (flagsSizeIsLong)
-        {
-            int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            res = bitUtil.combineIntsToLong(low, high);
-        }
-        if (reverse)
-            return reverseFlags(edgePointer, res);
-        return res;
+        return baseGraph.edge(a, b, distance, bothDirections);
     }
 
-    long reverseFlags( long edgePointer, long flags )
+    @Override
+    public final EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
     {
-        return encodingManager.reverseFlags(flags);
+        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
     }
 
-    private void setFlags( long edgePointer, boolean reverse, long flags )
+    @Override
+    public final AllEdgesIterator getAllEdges()
     {
-        if (reverse)
-            flags = reverseFlags(edgePointer, flags);
-
-        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
-
-        if (flagsSizeIsLong)
-            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
+        return baseGraph.getAllEdges();
     }
 
-    protected class SingleEdge extends EdgeIterable
+    @Override
+    public final EdgeExplorer createEdgeExplorer( EdgeFilter filter )
     {
-        public SingleEdge( int edgeId, int nodeId )
-        {
-            super(EdgeFilter.ALL_EDGES);
-            setBaseNode(nodeId);
-            setEdgeId(edgeId);
-            nextEdge = EdgeIterable.NO_EDGE;
-        }
+        return baseGraph.createEdgeExplorer(filter);
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
+    public final EdgeExplorer createEdgeExplorer()
     {
-        return new EdgeIterable(filter);
+        return baseGraph.createEdgeExplorer();
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer()
+    public final Graph copyTo( Graph g )
     {
-        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
+        return baseGraph.copyTo(g);
     }
 
-    protected class EdgeIterable implements EdgeExplorer, EdgeIterator
+    @Override
+    public final GraphExtension getExtension()
     {
-        final EdgeFilter filter;
-        int baseNode;
-        int adjNode;
-        int edgeId;
-        long edgePointer;
-        int nextEdge;
-        boolean reverse;
-
-        public EdgeIterable( EdgeFilter filter )
-        {
-            if (filter == null)
-                throw new IllegalArgumentException("Instead null filter use EdgeFilter.ALL_EDGES");
-
-            this.filter = filter;
-        }
-
-        protected void setEdgeId( int edgeId )
-        {
-            this.nextEdge = this.edgeId = edgeId;
-            this.edgePointer = (long) nextEdge * edgeEntryBytes;
-        }
-
-        @Override
-        public EdgeIterator setBaseNode( int baseNode )
-        {
-            int edge = nodes.getInt((long) baseNode * nodeEntryBytes + N_EDGE_REF);
-            setEdgeId(edge);
-            this.baseNode = baseNode;
-            return this;
-        }
-
-        @Override
-        public final int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public final int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public final boolean next()
-        {
-            int i = 0;
-            boolean foundNext = false;
-            for (; i < MAX_EDGES; i++)
-            {
-                if (nextEdge == EdgeIterator.NO_EDGE)
-                    break;
-
-                edgePointer = (long) nextEdge * edgeEntryBytes;
-                edgeId = nextEdge;
-                adjNode = getOtherNode(baseNode, edgePointer);
-                reverse = baseNode > adjNode;
-
-                // position to next edge                
-                nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
-                if (nextEdge == edgeId)
-                    throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
-                            + ", " + edgePointer + ", " + edgeId);
-
-                foundNext = filter.accept(this);
-                if (foundNext)
-                    break;
-            }
-
-            if (i > MAX_EDGES)
-                throw new IllegalStateException("something went wrong: no end of edge-list found");
-
-            return foundNext;
-        }
-
-        private long getEdgePointer()
-        {
-            return edgePointer;
-        }
-
-        @Override
-        public final double getDistance()
-        {
-            return getDist(edgePointer);
-        }
-
-        @Override
-        public final EdgeIteratorState setDistance( double dist )
-        {
-            edges.setInt(edgePointer + E_DIST, distToInt(dist));
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
-        }
-
-        @Override
-        public final EdgeIteratorState setFlags( long fl )
-        {
-            GraphHopperStorage.this.setFlags(edgePointer, reverse, fl);
-            return this;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.getInt(edgePointer + E_ADDITIONAL);
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            GraphHopperStorage.this.setAdditionalEdgeField(edgePointer, value);
-            return null;
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
-        {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
-            return this;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
-        }
-
-        @Override
-        public final int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public String getName()
-        {
-            int nameIndexRef = edges.getInt(edgePointer + E_NAME);
-            return nameIndex.get(nameIndexRef);
-        }
-
-        @Override
-        public boolean getBoolean( int key, boolean reverse, boolean _default )
-        {
-            // for non-existent keys return default
-            return _default;
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            GraphHopperStorage.this.setName(edgePointer, name);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgeId == nextEdge)
-                throw new IllegalStateException("call next before detaching");
-
-            EdgeIterable iter = new EdgeIterable(filter);
-            iter.setBaseNode(baseNode);
-            iter.setEdgeId(edgeId);
-            iter.next();
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.adjNode = baseNode;
-                iter.baseNode = adjNode;
-            }
-            return iter;
-        }
-
-        @Override
-        public final String toString()
-        {
-            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return GraphHopperStorage.this.copyProperties(this, edge);
-        }
-    }
-
-    /**
-     * @return to
-     */
-    EdgeIteratorState copyProperties( EdgeIteratorState from, EdgeIteratorState to )
-    {
-        to.setDistance(from.getDistance()).
-                setName(from.getName()).
-                setFlags(from.getFlags()).
-                setWayGeometry(from.fetchWayGeometry(0));
-
-        if (E_ADDITIONAL >= 0)
-            to.setAdditionalField(from.getAdditionalField());
-        return to;
-    }
-
-    public void setAdditionalEdgeField( long edgePointer, int value )
-    {
-        if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
-            edges.setInt(edgePointer + E_ADDITIONAL, value);
-        else
-            throw new AssertionError("This graph does not support an additional edge field.");
-    }
-
-    private void setWayGeometry( PointList pillarNodes, long edgePointer, boolean reverse )
-    {
-        if (pillarNodes != null && !pillarNodes.isEmpty())
-        {
-            if (pillarNodes.getDimension() != nodeAccess.getDimension())
-                throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
-                        + "D for graph which is " + nodeAccess.getDimension() + "D");
-
-            int len = pillarNodes.getSize();
-            int dim = nodeAccess.getDimension();
-            int tmpRef = nextGeoRef(len * dim);
-            edges.setInt(edgePointer + E_GEO, tmpRef);
-            long geoRef = (long) tmpRef * 4;
-            byte[] bytes = new byte[len * dim * 4 + 4];
-            ensureGeometry(geoRef, bytes.length);
-            bitUtil.fromInt(bytes, len, 0);
-            if (reverse)
-                pillarNodes.reverse();
-
-            int tmpOffset = 4;
-            boolean is3D = nodeAccess.is3D();
-            for (int i = 0; i < len; i++)
-            {
-                double lat = pillarNodes.getLatitude(i);
-                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
-                tmpOffset += 4;
-                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
-                tmpOffset += 4;
-
-                if (is3D)
-                {
-                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
-                    tmpOffset += 4;
-                }
-            }
-
-            wayGeometry.setBytes(geoRef, bytes, bytes.length);
-        } else
-        {
-            edges.setInt(edgePointer + E_GEO, 0);
-        }
-    }
-
-    private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
-    {
-        long geoRef = edges.getInt(edgePointer + E_GEO);
-        int count = 0;
-        byte[] bytes = null;
-        if (geoRef > 0)
-        {
-            geoRef *= 4;
-            count = wayGeometry.getInt(geoRef);
-
-            geoRef += 4;
-            bytes = new byte[count * nodeAccess.getDimension() * 4];
-            wayGeometry.getBytes(geoRef, bytes, bytes.length);
-        } else if (mode == 0)
-            return PointList.EMPTY;
-
-        PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
-        if (reverse)
-        {
-            if ((mode & 2) != 0)
-                pillarNodes.add(nodeAccess, adjNode);
-        } else
-        {
-            if ((mode & 1) != 0)
-                pillarNodes.add(nodeAccess, baseNode);
-        }
-
-        int index = 0;
-        for (int i = 0; i < count; i++)
-        {
-            double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));
-            index += 4;
-            double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
-            index += 4;
-            if (nodeAccess.is3D())
-            {
-                pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
-                index += 4;
-            } else
-            {
-                pillarNodes.add(lat, lon);
-            }
-        }
-
-        if (reverse)
-        {
-            if ((mode & 1) != 0)
-                pillarNodes.add(nodeAccess, baseNode);
-            pillarNodes.reverse();
-        } else
-        {
-            if ((mode & 2) != 0)
-                pillarNodes.add(nodeAccess, adjNode);
-        }
-
-        return pillarNodes;
-    }
-
-    private void setName( long edgePointer, String name )
-    {
-        long nameIndexRef = nameIndex.put(name);
-        if (nameIndexRef < 0)
-            throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
-
-        edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
-    }
-
-    @Override
-    public Graph copyTo( Graph g )
-    {
-        if (g.getClass().equals(getClass()))
-        {
-            return _copyTo((GraphHopperStorage) g);
-        } else
-        {
-            return GHUtility.copyTo(this, g);
-        }
-    }
-
-    Graph _copyTo( GraphHopperStorage clonedG )
-    {
-        if (clonedG.edgeEntryBytes != edgeEntryBytes)
-            throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
-
-        if (clonedG.nodeEntryBytes != nodeEntryBytes)
-            throw new IllegalStateException("nodeEntryBytes cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.nodeEntryBytes + " vs " + nodeEntryBytes);
-
-        if (clonedG.nodeAccess.getDimension() != nodeAccess.getDimension())
-            throw new IllegalStateException("dimension cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.nodeAccess.getDimension() + " vs " + nodeAccess.getDimension());
-
-        // nodes
-        setNodesHeader();
-        nodes.copyTo(clonedG.nodes);
-        clonedG.loadNodesHeader();
-
-        // edges
-        setEdgesHeader();
-        edges.copyTo(clonedG.edges);
-        clonedG.loadEdgesHeader();
-
-        // name
-        nameIndex.copyTo(clonedG.nameIndex);
-
-        // geometry
-        setWayGeometryHeader();
-        wayGeometry.copyTo(clonedG.wayGeometry);
-        clonedG.loadWayGeometryHeader();
-
-        // extStorage
-        extStorage.copyTo(clonedG.extStorage);
-
-        properties.copyTo(clonedG.properties);
-
-        if (removedNodes == null)
-            clonedG.removedNodes = null;
-        else
-            clonedG.removedNodes = removedNodes.copyTo(new GHBitSetImpl());
-
-        clonedG.encodingManager = encodingManager;
-        initialized = true;
-        return clonedG;
-    }
-
-    private GHBitSet getRemovedNodes()
-    {
-        if (removedNodes == null)
-            removedNodes = new GHBitSetImpl((int) (nodes.getCapacity() / 4));
-
-        return removedNodes;
-    }
-
-    @Override
-    public void markNodeRemoved( int index )
-    {
-        getRemovedNodes().add(index);
-    }
-
-    @Override
-    public boolean isNodeRemoved( int index )
-    {
-        return getRemovedNodes().contains(index);
-    }
-
-    @Override
-    public void optimize()
-    {
-        int delNodes = getRemovedNodes().getCardinality();
-        if (delNodes <= 0)
-            return;
-
-        // Deletes only nodes.
-        // It reduces the fragmentation of the node space but introduces new unused edges.
-        inPlaceNodeRemove(delNodes);
-
-        // Reduce memory usage
-        trimToSize();
-    }
-
-    private void trimToSize()
-    {
-        long nodeCap = (long) nodeCount * nodeEntryBytes;
-        nodes.trimTo(nodeCap);
-//        long edgeCap = (long) (edgeCount + 1) * edgeEntrySize;
-//        edges.trimTo(edgeCap * 4);
-    }
-
-    /**
-     * This method disconnects the specified edge from the list of edges of the specified node. It
-     * does not release the freed space to be reused.
-     * <p/>
-     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
-     * of nodes
-     */
-    long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode )
-    {
-        long edgeToRemovePointer = (long) edgeToRemove * edgeEntryBytes;
-        // an edge is shared across the two nodes even if the edge is not in both directions
-        // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
-        int nextEdgeId = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgeToRemovePointer));
-        if (edgeToUpdatePointer < 0)
-        {
-            nodes.setInt((long) baseNode * nodeEntryBytes, nextEdgeId);
-        } else
-        {
-            // adjNode is different for the edge we want to update with the new link
-            long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
-                    ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
-            edges.setInt(link, nextEdgeId);
-        }
-        return edgeToRemovePointer;
-    }
-
-    private void invalidateEdge( long edgePointer )
-    {
-        edges.setInt(edgePointer + E_NODEA, NO_NODE);
-    }
-
-    /**
-     * This methods disconnects all edges from removed nodes. It does no edge compaction. Then it
-     * moves the last nodes into the deleted nodes, where it needs to update the node ids in every
-     * edge.
-     */
-    private void inPlaceNodeRemove( int removeNodeCount )
-    {
-        // Prepare edge-update of nodes which are connected to deleted nodes        
-        int toMoveNodes = getNodes();
-        int itemsToMove = 0;
-
-        // sorted map when we access it via keyAt and valueAt - see below!
-        final SparseIntIntArray oldToNewMap = new SparseIntIntArray(removeNodeCount);
-        GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
-        removedNodes.copyTo(toRemoveSet);
-
-        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
-        // create map of old node ids pointing to new ids        
-        for (int removeNode = removedNodes.next(0);
-                removeNode >= 0;
-                removeNode = removedNodes.next(removeNode + 1))
-        {
-            EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);
-            while (delEdgesIter.next())
-            {
-                toRemoveSet.add(delEdgesIter.getAdjNode());
-            }
-
-            toMoveNodes--;
-            for (; toMoveNodes >= 0; toMoveNodes--)
-            {
-                if (!removedNodes.contains(toMoveNodes))
-                    break;
-            }
-
-            if (toMoveNodes >= removeNode)
-                oldToNewMap.put(toMoveNodes, removeNode);
-
-            itemsToMove++;
-        }
-
-        EdgeIterable adjNodesToDelIter = (EdgeIterable) createEdgeExplorer();
-        // now similar process to disconnectEdges but only for specific nodes
-        // all deleted nodes could be connected to existing. remove the connections
-        for (int removeNode = toRemoveSet.next(0);
-                removeNode >= 0;
-                removeNode = toRemoveSet.next(removeNode + 1))
-        {
-            // remove all edges connected to the deleted nodes
-            adjNodesToDelIter.setBaseNode(removeNode);
-            long prev = EdgeIterator.NO_EDGE;
-            while (adjNodesToDelIter.next())
-            {
-                int nodeId = adjNodesToDelIter.getAdjNode();
-                // already invalidated
-                if (nodeId != NO_NODE && removedNodes.contains(nodeId))
-                {
-                    int edgeToRemove = adjNodesToDelIter.getEdge();
-                    long edgeToRemovePointer = (long) edgeToRemove * edgeEntryBytes;
-                    internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
-                    invalidateEdge(edgeToRemovePointer);
-                } else
-                {
-                    prev = adjNodesToDelIter.getEdgePointer();
-                }
-            }
-        }
-
-        GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);
-        EdgeExplorer movedEdgeExplorer = createEdgeExplorer();
-        // marks connected nodes to rewrite the edges
-        for (int i = 0; i < itemsToMove; i++)
-        {
-            int oldI = oldToNewMap.keyAt(i);
-            EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
-            while (movedEdgeIter.next())
-            {
-                int nodeId = movedEdgeIter.getAdjNode();
-                if (nodeId == NO_NODE)
-                    continue;
-
-                if (removedNodes.contains(nodeId))
-                    throw new IllegalStateException("shouldn't happen the edge to the node "
-                            + nodeId + " should be already deleted. " + oldI);
-
-                toMoveSet.add(nodeId);
-            }
-        }
-
-        // move nodes into deleted nodes
-        for (int i = 0; i < itemsToMove; i++)
-        {
-            int oldI = oldToNewMap.keyAt(i);
-            int newI = oldToNewMap.valueAt(i);
-            long newOffset = (long) newI * nodeEntryBytes;
-            long oldOffset = (long) oldI * nodeEntryBytes;
-            for (long j = 0; j < nodeEntryBytes; j += 4)
-            {
-                nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));
-            }
-        }
-
-        // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement than
-        // a more efficient (?) breadth-first search
-        EdgeIterator iter = getAllEdges();
-        while (iter.next())
-        {
-            int nodeA = iter.getBaseNode();
-            int nodeB = iter.getAdjNode();
-            if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
-                continue;
-
-            // now overwrite exiting edge with new node ids 
-            // also flags and links could have changed due to different node order
-            int updatedA = oldToNewMap.get(nodeA);
-            if (updatedA < 0)
-                updatedA = nodeA;
-
-            int updatedB = oldToNewMap.get(nodeB);
-            if (updatedB < 0)
-                updatedB = nodeB;
-
-            int edge = iter.getEdge();
-            long edgePointer = (long) edge * edgeEntryBytes;
-            int linkA = edges.getInt(getLinkPosInEdgeArea(nodeA, nodeB, edgePointer));
-            int linkB = edges.getInt(getLinkPosInEdgeArea(nodeB, nodeA, edgePointer));
-            long flags = getFlags(edgePointer, false);
-            writeEdge(edge, updatedA, updatedB, linkA, linkB);
-            setFlags(edgePointer, updatedA > updatedB, flags);
-            if (updatedA < updatedB != nodeA < nodeB)
-                setWayGeometry(fetchWayGeometry(edgePointer, true, 0, -1, -1), edgePointer, false);
-        }
-
-        if (removeNodeCount >= nodeCount)
-            throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
-
-        // we do not remove the invalid edges => edgeCount stays the same!
-        nodeCount -= removeNodeCount;
-
-        EdgeExplorer explorer = createEdgeExplorer();
-        // health check
-        if (isTestingEnabled())
-        {
-            iter = getAllEdges();
-            while (iter.next())
-            {
-                int base = iter.getBaseNode();
-                int adj = iter.getAdjNode();
-                String str = iter.getEdge()
-                        + ", r.contains(" + base + "):" + removedNodes.contains(base)
-                        + ", r.contains(" + adj + "):" + removedNodes.contains(adj)
-                        + ", tr.contains(" + base + "):" + toRemoveSet.contains(base)
-                        + ", tr.contains(" + adj + "):" + toRemoveSet.contains(adj)
-                        + ", base:" + base + ", adj:" + adj + ", nodeCount:" + nodeCount;
-                if (adj >= nodeCount)
-                    throw new RuntimeException("Adj.node problem with edge " + str);
-
-                if (base >= nodeCount)
-                    throw new RuntimeException("Base node problem with edge " + str);
-
-                try
-                {
-                    explorer.setBaseNode(adj).toString();
-                } catch (Exception ex)
-                {
-                    org.slf4j.LoggerFactory.getLogger(getClass()).error("adj:" + adj);
-                }
-                try
-                {
-                    explorer.setBaseNode(base).toString();
-                } catch (Exception ex)
-                {
-                    org.slf4j.LoggerFactory.getLogger(getClass()).error("base:" + base);
-                }
-            }
-            // access last node -> no error
-            explorer.setBaseNode(nodeCount - 1).toString();
-        }
-        removedNodes = null;
-    }
-
-    private static boolean isTestingEnabled()
-    {
-        boolean enableIfAssert = false;
-        assert (enableIfAssert = true) : true;
-        return enableIfAssert;
-    }
-
-    @Override
-    public boolean loadExisting()
-    {
-        checkInit();
-        if (nodes.loadExisting())
-        {
-            String acceptStr = "";
-            if (properties.loadExisting())
-            {
-                properties.checkVersions(false);
-                // check encoding for compatiblity
-                acceptStr = properties.get("graph.flagEncoders");
-
-            } else
-                throw new IllegalStateException("cannot load properties. corrupt file or directory? " + dir);
-
-            if (encodingManager == null)
-            {
-                if (acceptStr.isEmpty())
-                    throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
-                            + dir.getLocation());
-
-                int bytesForFlags = 4;
-                if ("8".equals(properties.get("graph.bytesForFlags")))
-                    bytesForFlags = 8;
-                encodingManager = new EncodingManager(acceptStr, bytesForFlags);
-            } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
-            {
-                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
-                        + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
-            }
-
-            String dim = properties.get("graph.dimension");
-            if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
-                throw new IllegalStateException("Configured dimension (" + dim + ") is not equal to dimension of loaded graph (" + nodeAccess.getDimension() + ")");
-
-            String byteOrder = properties.get("graph.byteOrder");
-            if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
-                throw new IllegalStateException("Configured byteOrder (" + dim + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
-
-            if (!edges.loadExisting())
-                throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
-
-            if (!wayGeometry.loadExisting())
-                throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
-
-            if (!nameIndex.loadExisting())
-                throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
-
-            if (!extStorage.loadExisting())
-                throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
-
-            // first define header indices of this storage
-            initStorage();
-
-            // now load some properties from stored data
-            loadNodesHeader();
-            loadEdgesHeader();
-            loadWayGeometryHeader();
-            return true;
-        }
-        return false;
-    }
-
-    protected void initStorage()
-    {
-        edgeEntryIndex = 0;
-        nodeEntryIndex = 0;
-        E_NODEA = nextEdgeEntryIndex(4);
-        E_NODEB = nextEdgeEntryIndex(4);
-        E_LINKA = nextEdgeEntryIndex(4);
-        E_LINKB = nextEdgeEntryIndex(4);
-        E_DIST = nextEdgeEntryIndex(4);
-        this.flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
-        E_FLAGS = nextEdgeEntryIndex(encodingManager.getBytesForFlags());
-        E_GEO = nextEdgeEntryIndex(4);
-        E_NAME = nextEdgeEntryIndex(4);
-        if (extStorage.isRequireEdgeField())
-            E_ADDITIONAL = nextEdgeEntryIndex(4);
-        else
-            E_ADDITIONAL = -1;
-
-        N_EDGE_REF = nextNodeEntryIndex(4);
-        N_LAT = nextNodeEntryIndex(4);
-        N_LON = nextNodeEntryIndex(4);
-        if (nodeAccess.is3D())
-            N_ELE = nextNodeEntryIndex(4);
-        else
-            N_ELE = -1;
-
-        if (extStorage.isRequireNodeField())
-            N_ADDITIONAL = nextNodeEntryIndex(4);
-        else
-            N_ADDITIONAL = -1;
-
-        initNodeAndEdgeEntrySize();
-        initialized = true;
-    }
-
-    protected int loadNodesHeader()
-    {
-        int hash = nodes.getHeader(0);
-        if (hash != stringHashCode(getClass().getName()))
-            throw new IllegalStateException("Cannot load the graph when using instance of "
-                    + getClass().getName() + " and location: " + dir);
-
-        nodeEntryBytes = nodes.getHeader(1 * 4);
-        nodeCount = nodes.getHeader(2 * 4);
-        bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
-        bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
-        bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
-        bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
-
-        if (bounds.hasElevation())
-        {
-            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
-            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
-        }
-
-        return 7;
-    }
-
-    protected int setNodesHeader()
-    {
-        nodes.setHeader(0, stringHashCode(getClass().getName()));
-        nodes.setHeader(1 * 4, nodeEntryBytes);
-        nodes.setHeader(2 * 4, nodeCount);
-        nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
-        nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
-        nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
-        nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
-        if (bounds.hasElevation())
-        {
-            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
-            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
-        }
-
-        return 7;
-    }
-
-    protected int loadEdgesHeader()
-    {
-        edgeEntryBytes = edges.getHeader(0 * 4);
-        edgeCount = edges.getHeader(1 * 4);
-        return 4;
-    }
-
-    protected int setEdgesHeader()
-    {
-        edges.setHeader(0, edgeEntryBytes);
-        edges.setHeader(1 * 4, edgeCount);
-        edges.setHeader(2 * 4, encodingManager.hashCode());
-        edges.setHeader(3 * 4, extStorage.hashCode());
-        return 4;
-    }
-
-    protected int loadWayGeometryHeader()
-    {
-        maxGeoRef = wayGeometry.getHeader(0);
-        return 1;
-    }
-
-    protected int setWayGeometryHeader()
-    {
-        wayGeometry.setHeader(0, maxGeoRef);
-        return 1;
-    }
-
-    @Override
-    public void flush()
-    {
-        setNodesHeader();
-        setEdgesHeader();
-        setWayGeometryHeader();
-
-        properties.flush();
-        wayGeometry.flush();
-        nameIndex.flush();
-        edges.flush();
-        nodes.flush();
-        extStorage.flush();
-    }
-
-    @Override
-    public void close()
-    {
-        properties.close();
-        wayGeometry.close();
-        nameIndex.close();
-        edges.close();
-        nodes.close();
-        extStorage.close();
-    }
-
-    @Override
-    public boolean isClosed()
-    {
-        return nodes.isClosed();
-    }
-
-    @Override
-    public GraphExtension getExtension()
-    {
-        return extStorage;
-    }
-
-    @Override
-    public long getCapacity()
-    {
-        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity() + wayGeometry.getCapacity()
-                + properties.getCapacity() + extStorage.getCapacity();
-    }
-
-    @Override
-    public String toDetailsString()
-    {
-        return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
-                + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
-                + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
-                + "bounds:" + bounds;
-    }
-
-    // workaround for graphhopper-ios https://github.com/google/j2objc/issues/423
-    private int stringHashCode( String str )
-    {
-        try
-        {
-            return java.util.Arrays.hashCode(str.getBytes("UTF-8"));
-        } catch (UnsupportedEncodingException ex)
-        {
-            throw new UnsupportedOperationException(ex);
-        }
-    }
-
-    @Override
-    public String toString()
-    {
-        return getClass().getSimpleName()
-                + "|" + encodingManager
-                + "|" + getDirectory().getDefaultType()
-                + "|" + nodeAccess.getDimension() + "D"
-                + ((extStorage == null) ? "" : "|" + extStorage)
-                + "|" + getProperties().versionsToString();
+        return baseGraph.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage.java b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
index 4a556f3624..466656a4dd 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
@@ -1,11 +1,12 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
  * 
  *       http://www.apache.org/licenses/LICENSE-2.0
  * 
@@ -19,7 +20,7 @@
 
 import com.graphhopper.routing.util.EncodingManager;
 
-public interface GraphStorage extends Graph, Storable<GraphStorage>
+public interface GraphStorage extends Storable<GraphStorage>
 {
     Directory getDirectory();
 
diff --git a/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
new file mode 100644
index 0000000000..824aa60bf3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
@@ -0,0 +1,28 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+/**
+ * @author Peter Karich
+ */
+public interface InternalGraphEventListener
+{
+    void freeze();
+
+    void initStorage();
+}
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
deleted file mode 100644
index 571efa3eb2..0000000000
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.*;
-
-/**
- * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
- * storage to hold the level of a node and a shortcut edge per edge.
- * <p/>
- * @author Peter Karich
- * @see GraphBuilder
- */
-public class LevelGraphStorage extends GraphHopperStorage implements LevelGraph
-{
-    private static final double WEIGHT_FACTOR = 1000f;
-    // 2 bits for access, for now only 32bit => not Long.MAX
-    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
-    private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
-    private int I_SKIP_EDGE1;
-    private int I_SKIP_EDGE2;
-    private int I_LEVEL;
-    // after the last edge only shortcuts are stored
-    private int lastEdgeIndex = -1;
-    private final long scDirMask = PrepareEncoder.getScDirMask();
-    private final Graph baseGraph;
-
-    public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
-    {
-        super(dir, encodingManager, enabled3D);
-        baseGraph = new BaseGraph(this);
-    }
-
-    @Override
-    public boolean isShortcut( int edgeId )
-    {
-        return edgeId > lastEdgeIndex;
-    }
-
-    @Override
-    protected void initStorage()
-    {
-        super.initStorage();
-        I_SKIP_EDGE1 = nextEdgeEntryIndex(4);
-        I_SKIP_EDGE2 = nextEdgeEntryIndex(4);
-        I_LEVEL = nextNodeEntryIndex(4);
-        initNodeAndEdgeEntrySize();
-    }
-
-    @Override
-    public final void setLevel( int nodeIndex, int level )
-    {
-        if (nodeIndex >= getNodes())
-            return;
-
-        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
-    }
-
-    @Override
-    public final int getLevel( int nodeIndex )
-    {
-        // automatically allocate new nodes only via creating edges or setting node properties
-        if (nodeIndex >= getNodes())
-            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
-
-        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
-    }
-
-    @Override
-    public EdgeSkipIterState shortcut( int a, int b )
-    {
-        return createEdge(a, b);
-    }
-
-    @Override
-    public EdgeSkipIterState edge( int a, int b )
-    {
-        if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create edge after first shortcut was created");
-
-        lastEdgeIndex = edgeCount;
-        return createEdge(a, b);
-    }
-
-    private EdgeSkipIterState createEdge( int a, int b )
-    {
-        ensureNodeIndex(Math.max(a, b));
-        int edgeId = internalEdgeAdd(a, b);
-        EdgeSkipIteratorImpl iter = new EdgeSkipIteratorImpl(EdgeFilter.ALL_EDGES);
-        iter.setBaseNode(a);
-        iter.setEdgeId(edgeId);
-        iter.next();
-        iter.setSkippedEdges(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        return iter;
-    }
-
-    @Override
-    public EdgeSkipExplorer createEdgeExplorer()
-    {
-        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
-    }
-
-    @Override
-    public EdgeSkipExplorer createEdgeExplorer( EdgeFilter filter )
-    {
-        return new EdgeSkipIteratorImpl(filter);
-    }
-
-    @Override
-    public LevelGraphStorage create( long nodeCount )
-    {
-        super.create(nodeCount);
-        return this;
-    }
-
-    @Override
-    public final EdgeSkipIterState getEdgeProps( int edgeId, int endNode )
-    {
-        return (EdgeSkipIterState) super.getEdgeProps(edgeId, endNode);
-    }
-
-    class EdgeSkipIteratorImpl extends EdgeIterable implements EdgeSkipExplorer, EdgeSkipIterator
-    {
-        public EdgeSkipIteratorImpl( EdgeFilter filter )
-        {
-            super(filter);
-        }
-
-        @Override
-        public final EdgeSkipIterator setBaseNode( int baseNode )
-        {
-            super.setBaseNode(baseNode);
-            return this;
-        }
-
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2))
-            {
-                throw new IllegalStateException("Skipped edges of a shortcut needs "
-                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
-            }
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgeId > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-
-        @Override
-        public final EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgeId == nextEdge)
-                throw new IllegalStateException("call next before detaching");
-            EdgeSkipIteratorImpl iter = new EdgeSkipIteratorImpl(filter);
-            iter.setBaseNode(baseNode);
-            iter.setEdgeId(edgeId);
-            iter.next();
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.adjNode = baseNode;
-                iter.baseNode = adjNode;
-            }
-            return iter;
-        }
-
-        @Override
-        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            super.copyPropertiesTo(edge);
-
-//            EdgeSkipIterator eSkip = (EdgeSkipIterator) edge;
-//            setSkippedEdges(eSkip.getSkippedEdge1(), eSkip.getSkippedEdge2());
-            return edge;
-        }
-
-        @Override
-        public String getName()
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call getName on shortcut " + getEdge());
-            return super.getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call setName on shortcut " + getEdge());
-            return super.setName(name);
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call fetchWayGeometry on shortcut " + getEdge());
-            return super.fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call setWayGeometry on shortcut " + getEdge());
-            return super.setWayGeometry(list);
-        }
-    }
-
-    @Override
-    long reverseFlags( long edgePointer, long flags )
-    {
-        boolean isShortcut = edgePointer > (long) lastEdgeIndex * edgeEntryBytes;
-        if (!isShortcut)
-            return super.reverseFlags(edgePointer, flags);
-
-        // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
-        long dir = flags & scDirMask;
-        if (dir == scDirMask || dir == 0)
-            return flags;
-
-        // swap the last bits with this mask
-        return flags ^ scDirMask;
-    }
-
-    /**
-     * Disconnects the edges (higher->lower node) via the specified edgeState pointing from lower to
-     * higher node.
-     * <p/>
-     * @param edgeState the edge from lower to higher
-     */
-    public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
-    {
-        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
-        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
-        EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
-        int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        while (tmpIter.next())
-        {
-            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
-            {
-                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
-                break;
-            }
-
-            tmpPrevEdge = tmpIter.getEdge();
-        }
-    }
-
-    @Override
-    public AllEdgesSkipIterator getAllEdges()
-    {
-        return new AllEdgeSkipIterator();
-    }
-
-    class AllEdgeSkipIterator extends AllEdgeIterator implements AllEdgesSkipIterator
-    {
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgePointer / edgeEntryBytes > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-    }
-
-    @Override
-    protected SingleEdge createSingleEdge( int edge, int nodeId )
-    {
-        return new SingleLevelEdge(edge, nodeId);
-    }
-
-    class SingleLevelEdge extends SingleEdge implements EdgeSkipIterState
-    {
-        public SingleLevelEdge( int edge, int nodeId )
-        {
-            super(edge, nodeId);
-        }
-
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgeId > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-    }
-
-    final void setWeight( EdgeSkipIterState edge, double weight )
-    {
-        if (!edge.isShortcut())
-            throw new IllegalStateException("setWeight is only available for shortcuts");
-        if (weight < 0)
-            throw new IllegalArgumentException("weight cannot be negative! but was " + weight);
-
-        long weightLong;
-        if (weight > MAX_WEIGHT)
-            weightLong = MAX_WEIGHT_LONG;
-        else
-            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
-
-        long accessFlags = edge.getFlags() & PrepareEncoder.getScDirMask();
-        edge.setFlags(weightLong | accessFlags);
-    }
-
-    final double getWeight( EdgeSkipIterState edge )
-    {
-        if (!edge.isShortcut())
-            throw new IllegalStateException("getWeight is only available for shortcuts");
-
-        double weight = (edge.getFlags() >>> 2) / WEIGHT_FACTOR;
-        if (weight >= MAX_WEIGHT)
-            return Double.POSITIVE_INFINITY;
-
-        return weight;
-    }
-
-    @Override
-    protected int loadEdgesHeader()
-    {
-        int next = super.loadEdgesHeader();
-        lastEdgeIndex = edges.getHeader(next * 4);
-        return next + 1;
-    }
-
-    @Override
-    protected int setEdgesHeader()
-    {
-        int next = super.setEdgesHeader();
-        edges.setHeader(next * 4, lastEdgeIndex);
-        return next + 1;
-    }
-
-    @Override
-    public Graph getBaseGraph()
-    {
-        return baseGraph;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
index 471b1277ac..d316d9edb5 100644
--- a/core/src/main/java/com/graphhopper/storage/Lock.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -20,7 +20,7 @@
 
 /**
  * A write lock. Influenced by Lucene code
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Lock
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 989abf6218..b478d64035 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -34,7 +34,7 @@
 /**
  * This is a data structure which uses the operating system to synchronize between disc and memory.
  * Use {@link SynchedDAWrapper} if you intent to use this from multiple threads!
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 @NotThreadSafe
@@ -394,7 +394,7 @@ public int getSegments()
     /**
      * Cleans up MappedByteBuffers. Be sure you bring the segments list in a consistent state
      * afterwards.
-     * <p/>
+     * <p>
      * @param from inclusive
      * @param to exclusive
      */
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
index 4b31a627b3..8461288d8a 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
@@ -19,7 +19,7 @@
 
 /**
  * Manages memory mapped DataAccess objects.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see MMapDataAccess
  */
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index d794fa76fc..7df952a448 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -28,7 +28,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class NativeFSLockFactory implements LockFactory
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
index 0c0aaf1580..5221b1fb6b 100644
--- a/core/src/main/java/com/graphhopper/storage/NodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -24,7 +24,7 @@
  * This interface specifies how to access properties of the nodes in the graph. Similar to
  * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
  * for an additional iterator.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface NodeAccess extends PointAccess
@@ -38,7 +38,7 @@
 
     /**
      * Sets the additional value at the specified node index
-     * <p/>
+     * <p>
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
      * node field
      */
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index edad71b985..fff4af7ed4 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -28,7 +28,7 @@
 /**
  * This is an in-memory byte-based data structure with the possibility to be stored on flush().
  * Thread safe.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class RAMDataAccess extends AbstractDataAccess
@@ -99,12 +99,12 @@ public boolean ensureCapacity( long bytes )
             throw new IllegalArgumentException("new capacity has to be strictly positive");
 
         long cap = getCapacity();
-        long todoBytes = bytes - cap;
-        if (todoBytes <= 0)
+        long newBytes = bytes - cap;
+        if (newBytes <= 0)
             return false;
 
-        int segmentsToCreate = (int) (todoBytes / segmentSizeInBytes);
-        if (todoBytes % segmentSizeInBytes != 0)
+        int segmentsToCreate = (int) (newBytes / segmentSizeInBytes);
+        if (newBytes % segmentSizeInBytes != 0)
             segmentsToCreate++;
 
         try
@@ -118,7 +118,7 @@ public boolean ensureCapacity( long bytes )
         } catch (OutOfMemoryError err)
         {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
-                    + cap + ", new bytes:" + todoBytes + ", segmentSizeIntsPower:" + segmentSizePower
+                    + cap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizePower
                     + ", new segments:" + segmentsToCreate + ", existing:" + segments.length);
         }
         return true;
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
index 0288e5523d..d26fe83d88 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
@@ -19,7 +19,7 @@
 
 /**
  * Manages in-memory DataAccess objects.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see RAMDataAccess
  * @see RAMIntDataAccess
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index b2598102a5..e2c1060009 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -26,7 +26,7 @@
 /**
  * This is an in-memory data structure based on an integer array. With the possibility to be stored
  * on flush().
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 class RAMIntDataAccess extends AbstractDataAccess
@@ -101,12 +101,12 @@ public boolean ensureCapacity( long bytes )
             throw new IllegalArgumentException("new capacity has to be strictly positive");
 
         long cap = getCapacity();
-        long todoBytes = bytes - cap;
-        if (todoBytes <= 0)
+        long newBytes = bytes - cap;
+        if (newBytes <= 0)
             return false;
 
-        int segmentsToCreate = (int) (todoBytes / segmentSizeInBytes);
-        if (todoBytes % segmentSizeInBytes != 0)
+        int segmentsToCreate = (int) (newBytes / segmentSizeInBytes);
+        if (newBytes % segmentSizeInBytes != 0)
             segmentsToCreate++;
 
         try
@@ -121,7 +121,7 @@ public boolean ensureCapacity( long bytes )
         } catch (OutOfMemoryError err)
         {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
-                    + cap + ", new bytes:" + todoBytes + ", segmentSizeIntsPower:" + segmentSizeIntsPower
+                    + cap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizeIntsPower
                     + ", new segments:" + segmentsToCreate + ", existing:" + segments.length);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index e17d8838b4..54182e6f99 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -23,7 +23,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class SimpleFSLockFactory implements LockFactory
diff --git a/core/src/main/java/com/graphhopper/storage/Storable.java b/core/src/main/java/com/graphhopper/storage/Storable.java
index 8acef8afc8..a732431547 100644
--- a/core/src/main/java/com/graphhopper/storage/Storable.java
+++ b/core/src/main/java/com/graphhopper/storage/Storable.java
@@ -22,7 +22,7 @@
 /**
  * Interface for a storage abstraction. Currently is serves just the purpose to ensure the same
  * methods and names through all kind of 'storable' things in graphhopper.
- * <p/>
+ * <p>
  * Then the lifecycle is identical for all such objects:
  * <ol>
  * <li>object creation via new</li>
@@ -33,7 +33,7 @@
  * could require a call to increase memory while usage. E.g. DataAccess.ensureCapacity()</li>
  * <li>Finally do close() which does no flush()</li>
  * </ol>
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Storable<T> extends Closeable
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index c432160712..fc4f25cca3 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -28,7 +28,7 @@
 
 /**
  * Writes an in-memory HashMap into a file on flush.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class StorableProperties implements Storable<StorableProperties>
@@ -136,6 +136,7 @@ public void putCurrentVersions()
         put("geometry.version", Constants.VERSION_GEOMETRY);
         put("locationIndex.version", Constants.VERSION_LOCATION_IDX);
         put("nameIndex.version", Constants.VERSION_NAME_IDX);
+        put("shortcuts.version", Constants.VERSION_SHORTCUT);
     }
 
     public String versionsToString()
@@ -150,29 +151,25 @@ public String versionsToString()
     public boolean checkVersions( boolean silent )
     {
         if (!check("nodes", Constants.VERSION_NODE, silent))
-        {
             return false;
-        }
+
         if (!check("edges", Constants.VERSION_EDGE, silent))
-        {
             return false;
-        }
+
         if (!check("geometry", Constants.VERSION_GEOMETRY, silent))
-        {
             return false;
-        }
+
         if (!check("locationIndex", Constants.VERSION_LOCATION_IDX, silent))
-        {
             return false;
-        }
+
         if (!check("nameIndex", Constants.VERSION_NAME_IDX, silent))
-        {
             return false;
-        }
+
+        if (!check("shortcuts", Constants.VERSION_SHORTCUT, silent))
+            return false;
 
         // The check for the encoder version is done in EncoderManager, as this class does not know about the
         // registered encoders and their version
-
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index c157818730..e050f8163f 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -19,7 +19,7 @@
 
 /**
  * A simple wrapper to synchronize every DataAccess object.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 class SynchedDAWrapper implements DataAccess
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index f8de969dc4..147f81c875 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -23,7 +23,7 @@
  * Holds turn cost tables for each node. The additional field of a node will be used to point
  * towards the first entry within a node cost table to identify turn restrictions, or later, turn
  * getCosts.
- * <p/>
+ * <p>
  * @author Karl Hübner
  * @author Peter Karich
  */
@@ -43,8 +43,6 @@
     private int turnCostsEntryIndex = -4;
     private int turnCostsEntryBytes;
     private int turnCostsCount;
-
-    private GraphStorage graph;
     private NodeAccess nodeAccess;
 
     public TurnCostExtension()
@@ -58,14 +56,13 @@ public TurnCostExtension()
     }
 
     @Override
-    public void init( GraphStorage graph )
+    public void init( Graph graph, Directory dir )
     {
         if (turnCostsCount > 0)
             throw new AssertionError("The turn cost storage must be initialized only once.");
 
-        this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turn_costs");
+        this.turnCosts = dir.find("turn_costs");
     }
 
     private int nextTurnCostEntryIndex()
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index b0481339a6..97dbfb926f 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -29,13 +29,13 @@
  * This is a data structure which uses an unsafe access to native memory. The speed up compared to
  * RAMDataAccess is roughly 10% due to index calculations and BitUtil overhead in RAMDataAccess.
  * Notes:
- * <p/>
+ * <p>
  * 1. Highly experimental. Still some bugs and access through file/MMAP should work at some point
- * <p/>
+ * <p>
  * 2. Compared to MMAP no syncDAWrapper is need to make it read and write safe from multiple threads
- * <p/>
+ * <p>
  * 3. Cannot be used on Android as no memory allocation methods are available there
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 @NotThreadSafe
@@ -87,8 +87,8 @@ public final boolean ensureCapacity( long bytes )
     final boolean ensureCapacity( long bytes, boolean clearNewMem )
     {
         long oldCap = getCapacity();
-        long todoBytes = bytes - oldCap;
-        if (todoBytes <= 0)
+        long newBytes = bytes - oldCap;
+        if (newBytes <= 0)
             return false;
 
         // avoid frequent increase of allocation area, instead increase by segment size
@@ -103,7 +103,7 @@ final boolean ensureCapacity( long bytes, boolean clearNewMem )
         } catch (OutOfMemoryError err)
         {
             throw new OutOfMemoryError(err.getMessage() + " - problem when allocating new memory. Old capacity: "
-                    + oldCap + ", new bytes:" + todoBytes + ", segmentSizeIntsPower:" + segmentSizePower);
+                    + oldCap + ", new bytes:" + newBytes + ", segmentSizeIntsPower:" + segmentSizePower);
         }
 
         if (clearNewMem)
@@ -116,8 +116,7 @@ public DataAccess copyTo( DataAccess da )
     {
         if (da instanceof UnsafeDataAccess)
         {
-            // TODO
-            // unsafe.copyMemory(address, da.address, capacity);
+            // TODO unsafe.copyMemory(address, da.address, capacity);
             // return this;
         }
         return super.copyTo(da);
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 8595d5b49b..9b15d1d057 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -76,9 +76,9 @@ void writeByte( byte b )
     /**
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
-     * <p/>
+     * <p>
      * The format is described further in Lucene its DataOutput#writeVInt(int)
-     * <p/>
+     * <p>
      * See DataInput readVLong of Lucene
      */
     public final void writeVLong( long i )
@@ -95,8 +95,8 @@ public final void writeVLong( long i )
     /**
      * Reads a long stored in variable-length format. Reads between one and nine bytes. Smaller
      * values take fewer bytes. Negative numbers are not supported.
-     * <p/>
-     * The format is described further in DataOutput writeVInt(int) -> Lucene.
+     * <p>
+     * The format is described further in DataOutput writeVInt(int) from Lucene.
      */
     public long readVLong()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index 39550e04c6..f66e7db833 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -21,11 +21,11 @@
  * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
  * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
  * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
- * <p/>
+ * <p>
  * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
  * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
  * http://stackoverflow.com/q/24679963/194609
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BresenhamLine
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 8a0a88955f..a2d0db0d12 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -27,7 +27,7 @@
 
 /**
  * Very slow O(n) LocationIndex but no RAM/disc required.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class Location2IDFullIndex implements LocationIndex
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index a189adffd4..de12bed3c6 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -28,7 +28,7 @@
 
 /**
  * Same as full index but calculates distance to all edges too
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class Location2IDFullWithEdgesIndex implements LocationIndex
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 879fbf2a01..2ecb298e74 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -37,11 +37,11 @@
  * This class implements map matching and returns a node index from lat,lon coordinate. This
  * implementation is the a very memory efficient representation for areas with lots of node and
  * edges, but lacks precision. No edge distances are measured.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see LocationIndexTree which is more precise but more complicated and also slightly slower
  * implementation of LocationIndex.
- * <p/>
+ * <p>
  */
 class Location2IDQuadtree implements LocationIndex
 {
@@ -83,7 +83,7 @@ public long getCapacity()
     /**
      * Loads the index from disc if exists. Make sure you are using the identical graph which was
      * used while flusing this index.
-     * <p/>
+     * <p>
      * @return if loading from file was successfully.
      */
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index 7d4cf03a60..563d1d195f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -23,9 +23,9 @@
 /**
  * Provides a way to map realword data "lat,lon" to internal ids/indices of a memory efficient graph
  * - often just implemented as an array.
- * <p/>
+ * <p>
  * The implementations of findID needs to be thread safe!
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface LocationIndex extends Storable<LocationIndex>
@@ -50,12 +50,12 @@
      * This method returns the closest QueryResult for the specified location (lat, lon) and only if
      * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
      * search)
-     * <p/>
+     * <p>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
      *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
-     * <p/>
+     * <p>
      * @return An object containing the closest node and edge for the specfied location. The node id
      * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
      * the method QueryResult.isValid will return false.
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 34d3f9fca3..1d2cb44d82 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -24,7 +24,7 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -41,11 +41,11 @@
 
 /**
  * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
- * <p/>
+ * <p>
  * All leafs are at the same depth, otherwise it is quite complicated to calculate the bresenham
  * line for different resolutions, especially if a leaf node could be split into a tree-node and
  * resolution changes.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class LocationIndexTree implements LocationIndex
@@ -81,8 +81,8 @@
      */
     public LocationIndexTree( Graph g, Directory dir )
     {
-        if (g instanceof LevelGraph)
-            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+        if (g instanceof CHGraph)
+            throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
@@ -345,7 +345,7 @@ public LocationIndex prepareIndex()
 
     int calcChecksum()
     {
-        // do not include the edges as we could get problem with LevelGraph due to shortcuts
+        // do not include the edges as we could get problem with CHGraph due to shortcuts
         // ^ graph.getAllEdges().count();
         return graph.getNodes();
     }
@@ -632,7 +632,7 @@ final long createReverseKey( long key )
     /**
      * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
      * context of a spatial key tile.
-     * <p/>
+     * <p>
      */
     final double calculateRMin( double lat, double lon )
     {
@@ -710,56 +710,54 @@ GHPoint getCenter( double lat, double lon )
      * This method collects the node indices from the quad tree data structure in a certain order
      * which makes sure not too many nodes are collected as well as no nodes will be missing. See
      * discussion at issue #221.
+     * <p>
+     * @return true if no further call of this method is required. False otherwise, ie. a next
+     * iteration is necessary and no early finish possible.
      */
-    public final TIntHashSet findNetworkEntries( double queryLat, double queryLon, int maxIteration )
+    public final boolean findNetworkEntries( double queryLat, double queryLon,
+                                             TIntHashSet foundEntries, int iteration )
     {
-        TIntHashSet foundEntries = new TIntHashSet();
-
-        for (int iteration = 0; iteration < maxIteration; iteration++)
+        // find entries in border of searchbox
+        for (int yreg = -iteration; yreg <= iteration; yreg++)
         {
-            // find entries in border of searchbox
-            for (int yreg = -iteration; yreg <= iteration; yreg++)
-            {
-                double subqueryLat = queryLat + yreg * deltaLat;
-                double subqueryLonA = queryLon - iteration * deltaLon;
-                double subqueryLonB = queryLon + iteration * deltaLon;
-                findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
-
-                // minor optimization for iteration == 0
-                if (iteration > 0)
-                {
-                    findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
-                }
-            }
+            double subqueryLat = queryLat + yreg * deltaLat;
+            double subqueryLonA = queryLon - iteration * deltaLon;
+            double subqueryLonB = queryLon + iteration * deltaLon;
+            findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
+
+            // minor optimization for iteration == 0
+            if (iteration > 0)
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
+        }
 
-            for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
-            {
-                double subqueryLon = queryLon + xreg * deltaLon;
-                double subqueryLatA = queryLat - iteration * deltaLat;
-                double subqueryLatB = queryLat + iteration * deltaLat;
-                findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
-                findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
-            }
+        for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
+        {
+            double subqueryLon = queryLon + xreg * deltaLon;
+            double subqueryLatA = queryLat - iteration * deltaLat;
+            double subqueryLatB = queryLat + iteration * deltaLat;
+            findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
+            findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
+        }
 
-            // see #232
-            if (iteration % 2 == 1)
+        if (iteration % 2 == 1)
+        {
+            // Check if something was found already...
+            if (!foundEntries.isEmpty())
             {
-                // Check if something was found already...
-                if (foundEntries.size() > 0)
-                {
-                    double rMin = calculateRMin(queryLat, queryLon, iteration);
-                    double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
-
-                    if (minDistance < rMin)
-                    {   // resultEntries contains a nearest node for sure
-                        break;
-                    } // else: continue an undetected nearer node may sit in a neighbouring tile.
-                    // Now calculate how far we have to look outside to find any hidden nearest nodes
-                    // and repeat whole process with wider search area until this distance is covered.
-                }
+                double rMin = calculateRMin(queryLat, queryLon, iteration);
+                double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
+
+                if (minDistance < rMin)
+                    // early finish => foundEntries contains a nearest node for sure
+                    return true;
+                // else: continue as an undetected nearer node may sit in a neighbouring tile.
+                // Now calculate how far we have to look outside to find any hidden nearest nodes
+                // and repeat whole process with wider search area until this distance is covered.
             }
         }
-        return foundEntries;
+
+        // no early finish possible
+        return false;
     }
 
     final double calcMinDistance( double queryLat, double queryLon, TIntHashSet pointset )
@@ -792,50 +790,59 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
 
-        final TIntHashSet storedNetworkEntryIds = findNetworkEntries(queryLat, queryLon, maxRegionSearch);
+        TIntHashSet allCollectedEntryIds = new TIntHashSet();
         final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
-        if (storedNetworkEntryIds.isEmpty())
-            return closestMatch;
-
-        // clone storedIds to avoid interference with forEach
-        final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
-        // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer();
-        storedNetworkEntryIds.forEach(new TIntProcedure()
+        for (int iteration = 0; iteration < maxRegionSearch; iteration++)
         {
-            @Override
-            public boolean execute( int networkEntryNodeId )
+            TIntHashSet storedNetworkEntryIds = new TIntHashSet();
+            boolean earlyFinish = findNetworkEntries(queryLat, queryLon, storedNetworkEntryIds, iteration);
+            storedNetworkEntryIds.removeAll(allCollectedEntryIds);
+            allCollectedEntryIds.addAll(storedNetworkEntryIds);
+
+            // clone storedIds to avoid interference with forEach
+            final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
+            // find nodes from the network entries which are close to 'point'
+            final EdgeExplorer explorer = graph.createEdgeExplorer();
+            storedNetworkEntryIds.forEach(new TIntProcedure()
             {
-                new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
+                @Override
+                public boolean execute( int networkEntryNodeId )
                 {
-                    @Override
-                    protected double getQueryDistance()
+                    new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
                     {
-                        return closestMatch.getQueryDistance();
-                    }
+                        @Override
+                        protected double getQueryDistance()
+                        {
+                            return closestMatch.getQueryDistance();
+                        }
 
-                    @Override
-                    protected boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos )
-                    {
-                        if (normedDist < closestMatch.getQueryDistance())
+                        @Override
+                        protected boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos )
                         {
-                            closestMatch.setQueryDistance(normedDist);
-                            closestMatch.setClosestNode(node);
-                            closestMatch.setClosestEdge(edge.detach(false));
-                            closestMatch.setWayIndex(wayIndex);
-                            closestMatch.setSnappedPosition(pos);
-                            return true;
+                            if (normedDist < closestMatch.getQueryDistance())
+                            {
+                                closestMatch.setQueryDistance(normedDist);
+                                closestMatch.setClosestNode(node);
+                                closestMatch.setClosestEdge(edge.detach(false));
+                                closestMatch.setWayIndex(wayIndex);
+                                closestMatch.setSnappedPosition(pos);
+                                return true;
+                            }
+                            return false;
                         }
-                        return false;
-                    }
-                }.start(explorer, networkEntryNodeId);
-                return true;
-            }
-        });
+                    }.start(explorer, networkEntryNodeId);
+                    return true;
+                }
+            });
+
+            // do early finish only if something was found (#318)
+            if (earlyFinish && closestMatch.isValid())
+                break;
+        }
 
+        // denormalize distance and calculate snapping point only if closed match was found
         if (closestMatch.isValid())
         {
-            // denormalize distance            
             closestMatch.setQueryDistance(distCalc.calcDenormalizedDist(closestMatch.getQueryDistance()));
             closestMatch.calcSnappedPoint(distCalc);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index ac6619af5e..c371733f82 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -31,7 +31,7 @@
  * |
  * T--S----N
  * </pre>
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class QueryResult
@@ -49,7 +49,7 @@
      * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
      * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
      * a default precision of 1e-6.
-     * <p/>
+     * <p>
      * @see DistanceCalc#validEdgeDistance
      */
     public static enum Position
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index d995c2ee30..12eaeef5c4 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -24,7 +24,7 @@
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
- * <p/>
+ * <p>
  * @author Johannes Pelzer
  * @author Peter Karich
  */
@@ -58,7 +58,7 @@ static final double atan2( double y, double x )
 
     /**
      * Return orientation of line relative to east.
-     * <p/>
+     * <p>
      * @return Orientation in interval -pi to +pi where 0 is east
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index ef52addc82..ba99557d70 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -21,17 +21,12 @@
 
 /**
  * Examples for BIG endianess (default for Java and computer network).
- * <p/>
- * byte array: 0=>0100 0001 , 1=>1110 1011, 2=>...
- * <p/>
- * long: highest=>0100 0001 , 1110 1011, ..., lowest=> ...
- * <p/>
- * bits to string 0100 0001 , 1110 1011, ...
- * <p/>
- * LITTLE endianess (default for GraphHopper and most microprocessors)
- * <p/>
- * byte array ..., 6=>1110 1011, 7=>0100 0001
- * <p/>
+ * <pre>
+ * 0=&gt;0100 0001
+ * 1=&gt;1110 1011
+ * 2=&gt;...
+ * </pre> LITTLE endianess is default for GraphHopper and most microprocessors.
+ * <p>
  * @author Peter Karich
  */
 public abstract class BitUtil
@@ -221,7 +216,7 @@ public String toLastBitString( long value, int bits )
 
     /**
      * Higher order bits comes first in the returned string.
-     * <p/>
+     * <p>
      * @param bits how many bits should be returned.
      */
     public String toBitString( long value, int bits )
@@ -248,7 +243,7 @@ public String toBitString( long value, int bits )
     /**
      * Reverses the bits in the specified long value and it removes the remaining higher bits. See
      * also http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious
-     * <p/>
+     * <p>
      * @param maxBits the maximum number of recognized bits for reversal
      */
     public final long reverse( long value, int maxBits )
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilBig.java b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
index ee3dfcd59e..854eb1e9ea 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilBig.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
@@ -19,7 +19,7 @@
 
 /**
  * Conversion between "the memory" (integer/long/float/double/string) to bytes via BIG endianess.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BitUtilBig extends BitUtil
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index 55a815cde7..2d0ad85a2a 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -19,7 +19,7 @@
 
 /**
  * Conversion between "the memory" (integer/long/float/double/string) to bytes via little endianess.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BitUtilLittle extends BitUtil
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
index 05d3a3d009..d18586e05a 100644
--- a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -21,7 +21,7 @@
 
 /**
  * Implementattion of breadth first search (BFS)
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BreadthFirstSearch extends XFirstSearch
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
similarity index 81%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
index a7709a6c3c..8438c935f8 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
@@ -17,16 +17,16 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 
 /**
- * Support for skipped edge
- * <p/>
+ * The edge explorer for CHGraph
+ * <p>
  * @author Peter Karich
- * @see LevelGraph
+ * @see CHGraph
  */
-public interface EdgeSkipExplorer extends EdgeExplorer
+public interface CHEdgeExplorer extends EdgeExplorer
 {
     @Override
-    EdgeSkipIterator setBaseNode( int baseNode );
+    CHEdgeIterator setBaseNode( int baseNode );
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
index 11273da312..aacbafb98d 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
@@ -17,14 +17,14 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 
 /**
- * Support for skipped edge
- * <p/>
+ * Support for CH edges
+ * <p>
  * @author Peter Karich
- * @see LevelGraph
+ * @see CHGraph
  */
-public interface EdgeSkipIterator extends EdgeIterator, EdgeSkipIterState
+public interface CHEdgeIterator extends EdgeIterator, CHEdgeIteratorState
 {
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
similarity index 54%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
index 2ccdd75207..190fc01a41 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
@@ -18,20 +18,46 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.storage.CHGraph;
+
 /**
+ * The state returned from the EdgeIterator of a CHGraph
+ * <p>
  * @author Peter Karich
+ * @see CHGraph
+ * @see CHEdgeIterator
  */
-public interface EdgeSkipIterState extends EdgeIteratorState
+public interface CHEdgeIteratorState extends EdgeIteratorState
 {
     int getSkippedEdge1();
 
     int getSkippedEdge2();
 
+    /**
+     * Sets the edges that this shortcut skips. Those skipped edges can be shortcuts too.
+     */
     void setSkippedEdges( int edge1, int edge2 );
 
+    /**
+     * @return true if this edge is a shortcut, false otherwise.
+     */
     boolean isShortcut();
 
-    EdgeSkipIterState setWeight( double weight );
+    /**
+     * This method is only used on preparation.
+     * <p>
+     * @see PrepareEncoder#canBeOverwritten(long, long)
+     */
+    boolean canBeOverwritten( long flags );
+
+    /**
+     * Sets the weight calculated from Weighting.calcWeight, only applicable if isShortcut is true.
+     */
+    CHEdgeIteratorState setWeight( double weight );
 
+    /**
+     * Returns the weight of this shortcut.
+     */
     double getWeight();
 }
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 9109b37719..b7c01433fb 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -28,7 +28,7 @@
 
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class CmdArgs extends PMap
@@ -115,7 +115,7 @@ public static CmdArgs read( String[] args )
 
     /**
      * Command line configuration overwrites the ones in the config file.
-     * <p/>
+     * <p>
      * @return a new CmdArgs object if necessary.
      */
     public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index af5af167e5..796634dc59 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -4,9 +4,9 @@
  * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance with the License. You may obtain a
  * copy of the License at
- * <p/>
+ * <p>
  * http://www.apache.org/licenses/LICENSE-2.0
- * <p/>
+ * <p>
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
@@ -14,6 +14,7 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.GraphHopper;
 import static com.graphhopper.util.Helper.readFile;
 
 import java.io.InputStreamReader;
@@ -25,11 +26,11 @@
 public class Constants
 {
     /**
-     * The value of <tt>System.getProperty("java.version")<tt>. *
+     * The value of <tt>System.getProperty("java.version")</tt>. *
      */
     public static final String JAVA_VERSION = System.getProperty("java.version");
     /**
-     * The value of <tt>System.getProperty("os.name")<tt>. *
+     * The value of <tt>System.getProperty("os.name")</tt>. *
      */
     public static final String OS_NAME = System.getProperty("os.name");
     /**
@@ -53,6 +54,7 @@
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
     public static final int VERSION_NODE = 4;
     public static final int VERSION_EDGE = 12;
+    public static final int VERSION_SHORTCUT = 1;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
@@ -66,7 +68,7 @@
     public static String getVersions()
     {
         return VERSION_NODE + "," + VERSION_EDGE + "," + VERSION_GEOMETRY + "," + VERSION_LOCATION_IDX
-                + "," + VERSION_NAME_IDX;
+                + "," + VERSION_NAME_IDX + "," + VERSION_SHORTCUT;
     }
 
     static
@@ -74,7 +76,9 @@ public static String getVersions()
         String version = "0.0";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/version"), Helper.UTF_CS));
+            // see com/graphhopper/version file in resources which is modified in the maven packaging process 
+            // to contain the current version
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), Helper.UTF_CS));
             version = v.get(0);
         } catch (Exception ex)
         {
@@ -104,7 +108,7 @@ public static String getVersions()
         String buildDate = "";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/builddate"), Helper.UTF_CS));
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), Helper.UTF_CS));
             buildDate = v.get(0);
         } catch (Exception ex)
         {
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
index 987657798a..bd664193ff 100644
--- a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -22,7 +22,7 @@
 
 /**
  * Implementation of depth first search (DFS) by LIFO queue
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author Jan Sölter
  */
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 79c6fd89bf..0908b59f8f 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -23,9 +23,9 @@
 /**
  * Calculates the distance of two points or one point and an edge on earth via haversine formula.
  * Allows subclasses to implement less or more precise calculations.
- * <p/>
+ * <p>
  * See http://en.wikipedia.org/wiki/Haversine_formula
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface DistanceCalc
@@ -69,7 +69,7 @@
      *  .
      *    a-------b
      * </pre>
-     * <p/>
+     * <p>
      * @return true for case 1 which is "on edge" or the special case of 90° to the edge
      */
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
@@ -78,7 +78,7 @@ boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
 
     /**
      * This method calculates the distance from r to edge (a, b) where the crossing point is c
-     * <p/>
+     * <p>
      * @return the distance in normalized meter
      */
     double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
index 0e3a157fa2..2b615116c0 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
@@ -21,7 +21,7 @@
 
 /**
  * Calculates the distance of two points or one point and an edge in euclidean space.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DistanceCalc2D extends DistanceCalcEarth
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
index 5261e89702..2a526abb35 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
@@ -22,7 +22,7 @@
  * geometry mixed with Haversine formula used for the on earth distance. The haversine formula makes
  * not so much sense as it is only important for large distances where then the rather smallish
  * heights would becomes neglectable.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DistanceCalc3D extends DistanceCalcEarth
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index fbcab38d95..e911b9003c 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -43,7 +43,7 @@
 
     /**
      * Calculates distance of (from, to) in meter.
-     * <p/>
+     * <p>
      * http://en.wikipedia.org/wiki/Haversine_formula a = sin²(Δlat/2) +
      * cos(lat1).cos(lat2).sin²(Δlong/2) c = 2.atan2(√a, √(1−a)) d = R.c
      */
@@ -120,7 +120,7 @@ public double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
 
     /**
      * New edge distance calculation where no validEdgeDistance check would be necessary
-     * <p/>
+     * <p>
      * @return the normalized distance of the query point "r" to the project point "c" onto the line
      * segment a-b
      */
diff --git a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
index 112bbaa1ab..e7e73bfbda 100644
--- a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
+++ b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
@@ -22,14 +22,14 @@
 /**
  * Calculates the approximative distance of two points on earth. Very good results if delat_lon is
  * not too big (see DistanceCalcTest), e.g. the distance is small.
- * <p/>
+ * <p>
  * http://en.wikipedia.org/wiki/Geographical_distance#Spherical_Earth_projected_to_a_plane
- * <p/>
+ * <p>
  * http://stackoverflow.com/q/1006654
- * <p/>
+ * <p>
  * http://en.wikipedia.org/wiki/Mercator_projection#Mathematics_of_the_Mercator_projection
  * http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DistancePlaneProjection extends DistanceCalcEarth
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index 5612ac61e8..a37fa6a459 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -20,9 +20,9 @@
 /**
  * Simplyfies a list of 2D points which are not too far away.
  * http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
- * <p/>
+ * <p>
  * Calling simplify is thread safe.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DouglasPeucker
@@ -58,7 +58,7 @@ public DouglasPeucker setMaxDistance( double dist )
 
     /**
      * This method removes points which are close to the line (defined by maxDist).
-     * <p/>
+     * <p>
      * @return removed nodes
      */
     public int simplify( PointList points )
diff --git a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
index 5cf1a23893..b03232aac1 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
@@ -18,8 +18,9 @@
 package com.graphhopper.util;
 
 /**
- * Class to get EdgeIterator create it via graph.createEdgeExplorer(). Use one instance per thread.
- * <p/>
+ * Class to get an EdgeIterator. Create it via graph.createEdgeExplorer() use one instance per
+ * thread.
+ * <p>
  * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeIteratorState
@@ -27,11 +28,11 @@
 public interface EdgeExplorer
 {
     /**
-     * This method sets the base node for iteration through neighboring edges.
-     * <p/>
-     * @return EdgeIterator around specified baseNode. The resulting iterator can be a new instance
-     * or a reused instance returned in a previous call. So be sure you do not use the explorer from
-     * multiple threads or in a nested loop
+     * This method sets the base node for iteration through neighboring edges (EdgeIteratorStates).
+     * <p>
+     * @return EdgeIterator around the specified baseNode. The resulting iterator can be a new
+     * instance or a reused instance returned in a previous call. So be sure you do not use the
+     * EdgeExplorer from multiple threads or in a nested loop.
      */
     EdgeIterator setBaseNode( int baseNode );
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index b28b715223..b500d7b32a 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -21,9 +21,7 @@
  * Iterates through all edges of one node. Avoids object creation in-between via direct access
  * methods. If you want to access some properties of an 'edge' (i.e. the current state) for later
  * usage store it via edgeIterator.detach() or edgeIterator.getEdge() instead of the iterator
- * itself.
- * <p/>
- * Usage:
+ * itself. Usage:
  * <pre>
  * EdgeExplorer explorer = graph.createEdgeExplorer();
  * EdgeIterator iter = explorer.setBaseNode(nodeId);
@@ -33,6 +31,8 @@
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
  *   ...
  * }
+ * </pre>
+ * <p>
  * @author Peter Karich
  * @see EdgeIteratorState
  * @see EdgeExplorer
@@ -41,7 +41,7 @@
 {
     /**
      * To be called to go to the next edge state.
-     * <p/>
+     * <p>
      * @return true if an edge state is available
      */
     boolean next();
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index c5a78bbf55..d40219c8d0 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -17,9 +17,11 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.util.FlagEncoder;
+
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
@@ -27,7 +29,7 @@
 public interface EdgeIteratorState
 {
     final static int K_UNFAVORED_EDGE = -1;
-    
+
     /**
      * @return the edge id of the current edge. Do not make any assumptions about the concrete
      * values, except that for an implemention it is recommended that they'll be contiguous.
@@ -38,7 +40,7 @@
      * Returns the node used to instantiate the EdgeIterator. Example: "EdgeIterator iter =
      * graph.getEdges(baseNode)". Often only used for convenience reasons. Do not confuse this with
      * a <i>source node</i> of a directed edge.
-     * <p/>
+     * <p>
      * @return the requested node itself
      * @see EdgeIterator
      */
@@ -55,7 +57,7 @@
      * and are between tower nodes (which are used for routing), they are necessary to have a more
      * exact geometry. Updates to the returned list are not reflected in the graph, for that you've
      * to use setWayGeometry.
-     * <p/>
+     * <p>
      * @param mode can be <ul> <li>0 = only pillar nodes, no tower nodes</li> <li>1 = inclusive the
      * base tower node only</li> <li>2 = inclusive the adjacent tower node only</li> <li>3 =
      * inclusive the base and adjacent tower node</li> </ul>
@@ -85,13 +87,24 @@
      */
     int getAdditionalField();
 
+    /**
+     * @see FlagEncoder#isForward(long) and #472
+     */
+    boolean isForward( FlagEncoder encoder );
+
+    /**
+     * @see FlagEncoder#isBackward(long) and #472
+     */
+    boolean isBackward( FlagEncoder encoder );
+
     /**
      * get additional boolean edge information
-     * @param reverse  if property of reverse edge direction should be returned
+     * <p>
+     * @param reverse if property of reverse edge direction should be returned
      * @param _default default value if key is not found
      */
-    boolean getBoolean( int key, boolean reverse, boolean _default);
-    
+    boolean getBoolean( int key, boolean reverse, boolean _default );
+
     /**
      * Updates the additional field value for this edge
      */
@@ -103,7 +116,7 @@
 
     /**
      * Clones this EdgeIteratorState.
-     * <p/>
+     * <p>
      * @param reverse if true a detached edgeState with reversed properties is created where base
      * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
      * about why we need the new reverse parameter.
@@ -112,7 +125,7 @@
 
     /**
      * Copies the properties of this edge into the specified edge. Does not change nodes!
-     * <p/>
+     * <p>
      * @return the specified edge e
      */
     EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index d0dfd27057..896c6e71ed 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -25,7 +25,7 @@
 /**
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see PathBidir
  */
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 5332a4e3fc..1fd79d4b79 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -20,9 +20,8 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.*;
 import gnu.trove.list.TIntList;
@@ -34,13 +33,13 @@
 /**
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
  * methods are useful for unit tests or debugging only.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHUtility
 {
     /**
-     * @throws could throw exception if uncatched problems like index out of bounds etc
+     * This method could throw exception if uncatched problems like index out of bounds etc
      */
     public static List<String> getProblems( Graph g )
     {
@@ -131,18 +130,18 @@ public static int count( EdgeIterator iter )
 
     public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
     {
-        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
         while (iter.next())
         {
             String sc = "";
-            if (iter instanceof AllEdgesSkipIterator)
+            if (iter instanceof AllCHEdgesIterator)
             {
-                AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
+                AllCHEdgesIterator aeSkip = (AllCHEdgesIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
-            String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
-            String bckStr = encoder.isBackward(iter.getFlags()) ? "bckwd" : "";
+            String fwdStr = iter.isForward(encoder) ? "fwd" : "   ";
+            String bckStr = iter.isBackward(encoder) ? "bckwd" : "";
             System.out.println(sc + " " + iter + " " + fwdStr + " " + bckStr);
         }
     }
@@ -166,10 +165,10 @@ protected boolean goFurther( int nodeId )
         }.start(g.createEdgeExplorer(), startNode);
     }
 
-    public static String getNodeInfo( LevelGraph g, int nodeId, EdgeFilter filter )
+    public static String getNodeInfo( CHGraph g, int nodeId, EdgeFilter filter )
     {
-        EdgeSkipExplorer ex = g.createEdgeExplorer(filter);
-        EdgeSkipIterator iter = ex.setBaseNode(nodeId);
+        CHEdgeExplorer ex = g.createEdgeExplorer(filter);
+        CHEdgeIterator iter = ex.setBaseNode(nodeId);
         NodeAccess na = g.getNodeAccess();
         String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
         while (iter.next())
@@ -314,45 +313,34 @@ static Directory guessDirectory( GraphStorage store )
         return outdir;
     }
 
-    static GraphStorage guessStorage( Graph g, Directory outdir, EncodingManager encodingManager )
-    {
-        GraphStorage store;
-        boolean is3D = g.getNodeAccess().is3D();
-        if (g instanceof LevelGraphStorage)
-            store = new LevelGraphStorage(outdir, encodingManager, is3D);
-        else
-            store = new GraphHopperStorage(outdir, encodingManager, is3D);
-
-        return store;
-    }
-
     /**
      * Create a new storage from the specified one without copying the data.
      */
-    public static GraphStorage newStorage( GraphStorage store )
+    public static GraphHopperStorage newStorage( GraphHopperStorage store )
     {
-        return guessStorage(store, guessDirectory(store), store.getEncodingManager()).create(store.getNodes());
-    }
+        Directory outdir = guessDirectory(store);
+        boolean is3D = store.getNodeAccess().is3D();
 
-    /**
-     * @return the graph outGraph
-     */
-    public static Graph clone( Graph g, GraphStorage outGraph )
-    {
-        return g.copyTo(outGraph.create(g.getNodes()));
+        return new GraphHopperStorage(store.getCHWeightings(), outdir, store.getEncodingManager(),
+                is3D, store.getExtension()).
+                create(store.getNodes());
     }
 
     public static int getAdjNode( Graph g, int edge, int adjNode )
     {
         if (EdgeIterator.Edge.isValid(edge))
         {
-            EdgeIteratorState iterTo = g.getEdgeProps(edge, adjNode);
+            EdgeIteratorState iterTo = g.getEdgeIteratorState(edge, adjNode);
             return iterTo.getAdjNode();
         }
         return adjNode;
     }
 
-    public static class DisabledEdgeIterator implements EdgeSkipIterator
+    /**
+     * This edge iterator can be used in tests to mock specific iterator behaviour via overloading
+     * certain methods.
+     */
+    public static class DisabledEdgeIterator implements CHEdgeIterator
     {
         @Override
         public EdgeIterator detach( boolean reverse )
@@ -361,121 +349,133 @@ public EdgeIterator detach( boolean reverse )
         }
 
         @Override
-        public boolean isShortcut()
+        public EdgeIteratorState setDistance( double dist )
         {
-            return false;
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getSkippedEdge1()
+        public EdgeIteratorState setFlags( long flags )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getSkippedEdge2()
+        public boolean next()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public void setSkippedEdges( int edge1, int edge2 )
+        public int getEdge()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setDistance( double dist )
+        public int getBaseNode()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setFlags( long flags )
+        public int getAdjNode()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean next()
+        public double getDistance()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getEdge()
+        public long getFlags()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getBaseNode()
+        public PointList fetchWayGeometry( int type )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getAdjNode()
+        public EdgeIteratorState setWayGeometry( PointList list )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public double getDistance()
+        public String getName()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public long getFlags()
+        public EdgeIteratorState setName( String name )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public PointList fetchWayGeometry( int type )
+        public boolean getBoolean( int key, boolean reverse, boolean _default )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
+        public boolean isBackward( FlagEncoder encoder )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public String getName()
+        public boolean isForward( FlagEncoder encoder )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setName( String name )
+        public int getAdditionalField()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean getBoolean(int key, boolean reverse, boolean _default )
+        public EdgeIteratorState setAdditionalField( int value )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
-        
+
         @Override
-        public int getAdditionalField()
+        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setAdditionalField( int value )
+        public boolean isShortcut()
+        {
+            return false;
+        }
+
+        @Override
+        public int getSkippedEdge1()
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        public int getSkippedEdge2()
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public void setSkippedEdges( int edge1, int edge2 )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
@@ -487,7 +487,13 @@ public double getWeight()
         }
 
         @Override
-        public EdgeSkipIterState setWeight( double weight )
+        public CHEdgeIteratorState setWeight( double weight )
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public boolean canBeOverwritten( long flags )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index cad353c103..7b31ecb262 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -64,7 +64,7 @@ public void setTime( long time )
 
     /**
      * The time relative to the start time in milli seconds.
-     * <p/>
+     * <p>
      * @deprecated use getTime instead
      */
     public long getMillis()
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index b47030cc07..2f45828add 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -38,7 +38,7 @@
 
 /**
  * Several utility classes which are compatible with Java6 on Android.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @see Helper7 for none-Android compatible methods.
  */
@@ -357,7 +357,7 @@ public static PointList createPointList3D( double... list )
      * Converts into an integer to be compatible with the still limited DataAccess class (accepts
      * only integer values). But this conversion also reduces memory consumption where the precision
      * loss is accceptable. As +- 180° and +-90° are assumed as maximum values.
-     * <p/>
+     * <p>
      * @return the integer of the specified degree
      */
     public static final int degreeToInt( double deg )
@@ -371,7 +371,7 @@ public static final int degreeToInt( double deg )
 
     /**
      * Converts back the integer value.
-     * <p/>
+     * <p>
      * @return the degree value of the specified integer
      */
     public static final double intToDegree( int storedInt )
@@ -494,6 +494,6 @@ public static final double round4( double value )
 
     public static final double round2( double value )
     {
-        return Math.round(value * 100) / 100;
+        return Math.round(value * 100) / 100d;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Helper7.java b/core/src/main/java/com/graphhopper/util/Helper7.java
index 36a22f065b..87defe26db 100644
--- a/core/src/main/java/com/graphhopper/util/Helper7.java
+++ b/core/src/main/java/com/graphhopper/util/Helper7.java
@@ -23,7 +23,7 @@
 /**
  * Put the usage of proprietary "sun" classes and after jdk6 classes into this class. To use Helper
  * class under Android as well.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class Helper7
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index c0f1cd4c48..519419985e 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -156,7 +156,7 @@ public PointList getPoints()
     /**
      * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     * <p/>
+     * <p>
      * @return the time offset to add for the next instruction
      */
     long fillGPXList( List<GPXEntry> list, long time,
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index d4512f0436..fca3ec5bae 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -132,7 +132,7 @@ public String toString()
     /**
      * @return This method returns a list of gpx entries where the time (in millis) is relative to
      * the first which is 0.
-     * <p/>
+     * <p>
      */
     public List<GPXEntry> createGPXList()
     {
@@ -162,7 +162,7 @@ public String toString()
     /**
      * Creates the standard GPX string out of the points according to the schema found here:
      * https://graphhopper.com/public/schema/gpx-1.1.xsd
-     * <p/>
+     * <p>
      * @return string to be stored as gpx file
      */
     public String createGPX()
@@ -271,7 +271,7 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
-     * <p/>
+     * <p>
      * @param maxDistance the maximum acceptable distance to the instruction (in meter)
      * @return the next Instruction or null if too far away.
      */
diff --git a/core/src/main/java/com/graphhopper/util/NotThreadSafe.java b/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
index d38fdd7ae6..5ca8958d7d 100644
--- a/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
+++ b/core/src/main/java/com/graphhopper/util/NotThreadSafe.java
@@ -19,7 +19,7 @@
 
 /**
  * Marks classes or methods as none thread-safe
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public @interface NotThreadSafe
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
index 5b4b7ed146..1397c7aad5 100644
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -22,7 +22,7 @@
 
 /**
  * A properties map with convenient accessors
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PMap
@@ -60,6 +60,12 @@ public PMap( String propertiesString )
         }
     }
 
+    public PMap put( PMap map )
+    {
+        this.map.putAll(map.map);
+        return this;
+    }
+
     public PMap put( String key, Object str )
     {
         if (str == null)
@@ -159,6 +165,14 @@ String get( String key )
         return val;
     }
 
+    /**
+     * This method copies the underlying structur into a new Map object
+     */
+    public Map<String, String> toMap()
+    {
+        return new HashMap<String, String>(map);
+    }
+
     private Map<String, String> getMap()
     {
         return map;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index a33097d65b..29e483c7fa 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -25,7 +25,7 @@
 
 /**
  * This class merges a list of points into one point recognizing the specified places.
- * <p/>
+ * <p>
  * @author Peter Karich
  * @author ratrun
  */
@@ -39,7 +39,6 @@
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
         int origPoints = 0;
-        StopWatch sw;
         long fullTimeInMillis = 0;
         double fullWeight = 0;
         double fullDistance = 0;
@@ -56,7 +55,6 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             if (enableInstructions)
             {
                 InstructionList il = path.calcInstructions(tr);
-                sw = new StopWatch().start();
 
                 if (!il.isEmpty())
                 {
@@ -77,7 +75,6 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                         fullInstructions.add(i);
                         fullPoints.add(i.getPoints());
                     }
-                    sw.stop();
 
                     // if not yet reached finish replace with 'reached via'
                     if (pathIndex + 1 < paths.size())
@@ -97,9 +94,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (simplifyResponse)
                 {
                     origPoints = tmpPoints.getSize();
-                    sw = new StopWatch().start();
                     douglasPeucker.simplify(tmpPoints);
-                    sw.stop();
                 }
                 fullPoints.add(tmpPoints);
             }
@@ -118,7 +113,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
 
         if (!allFound)
         {
-            rsp.addError(new RuntimeException("Not found"));
+            rsp.addError(new RuntimeException("Connection between locations not found"));
         }
 
         rsp.setPoints(fullPoints).
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index ee93ad219b..5d3068a599 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -42,7 +42,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p/>
+     * <p>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon );
@@ -50,7 +50,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p/>
+     * <p>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon, double ele );
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 6cca560fee..a6f3f5ec33 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -28,7 +28,7 @@
 
 /**
  * Slim list to store several points (without the need for a point object).
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class PointList implements Iterable<GHPoint3D>, PointAccess
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index 185d7b480b..26d4ba9499 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -1,3 +1,20 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.util;
 
 import java.util.HashMap;
@@ -68,22 +85,24 @@ public int getExitNumber()
     }
 
     /**
-     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
-     * values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     * @return radian of angle -2PI &lt; x &lt; 2PI between roundabout entrance and exit values
+     * <ul>
+     * <li>&gt; 0 is for clockwise rotation</li>
+     * <li>&lt; 0 is for counterclockwise rotation</li>
+     * <li>NaN if direction of rotation is unclear</li>
+     * </ul>
      */
-    public double getRadian()
+    public double getTurnAngle()
     {
         if (Math.abs(clockwise) != 1)
-        {
             return Double.NaN;
-        } else
-        {
-            double tmpRadian = Math.PI - clockwise * radian;
-            tmpRadian *= clockwise;
-            return tmpRadian;
-        }
+        else
+            return Math.PI * clockwise - radian;
     }
 
+    /**
+     * The radian value between entrance (in) and exit (out) of this roundabout.
+     */
     public RoundaboutInstruction setRadian( double radian )
     {
         this.radian = radian;
@@ -95,11 +114,9 @@ public RoundaboutInstruction setRadian( double radian )
     {
         Map<String, Object> tmpMap = new HashMap<String, Object>(2);
         tmpMap.put("exit_number", getExitNumber());
-        double radian = getRadian();
-        if (!Double.isNaN(radian))
-        {
-            tmpMap.put("turn_angle", Helper.round(radian, 2));
-        }
+        double tmpAngle = getTurnAngle();
+        if (!Double.isNaN(tmpAngle))
+            tmpMap.put("turn_angle", Helper.round(tmpAngle, 2));
 
         return tmpMap;
 
diff --git a/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java b/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
index 8390f92b92..80f5d2a72e 100644
--- a/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
+++ b/core/src/main/java/com/graphhopper/util/SimpleIntDeque.java
@@ -21,7 +21,7 @@
 
 /**
  * push to end, pop from beginning
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class SimpleIntDeque
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index dbe55ede43..b829a1a9e8 100644
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -19,12 +19,11 @@
 
 /**
  * Make simple speed measurements possible.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class StopWatch
 {
-
     private long lastTime;
     private long nanoTime;
     private String name = "";
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index f50f46f3a7..3e7ee7fe33 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -24,16 +24,17 @@
 /**
  * A class which manages the translations in-memory. See here for more information:
  * ./docs/core/translations.md
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("ar", "bg", "ca", "cz", "de_DE", "el",
-            "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hsb", "hu_HU", "it", "ja",
-            "lt_LT", "ne", "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk",
-            "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
+    private static final List<String> LOCALES = Arrays.asList("ar", "ast", "bg", "ca",
+            "cs_CZ", "da_DK", "de_DE", "el", "en_US", "es", "fa", "fil", "fi", "fr",
+            "gl", "he", "hsb", "hu_HU", "it", "ja", "lt_LT", "ne", "nl", "pl_PL",
+            "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
+            "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index 31b56569a7..2640ee7ac0 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -22,7 +22,7 @@
 
 /**
  * This abstract class defines commonalities for BFS and DFS
- * <p/>
+ * <p>
  * @author Jan Sölter
  */
 public abstract class XFirstSearch
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 9b6eb95f22..c5461f962c 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -27,10 +27,10 @@
  * A simple bounding box defined as follows: minLon, maxLon followed by minLat which is south(!) and
  * maxLat. Equally to EX_GeographicBoundingBox in the ISO 19115 standard see
  * http://osgeo-org.1560.n6.nabble.com/Boundingbox-issue-for-discussion-td3875533.html
- * <p/>
+ * <p>
  * Nice German overview:
  * http://www.geoinf.uni-jena.de/fileadmin/Geoinformatik/Lehre/Diplomarbeiten/DA_Andres.pdf
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class BBox implements Shape, Cloneable
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
index 5d855629bc..918bb0df09 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
@@ -21,7 +21,7 @@
 
 /**
  * Specifies a place by its coordinates or name
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHPlace extends GHPoint
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Shape.java b/core/src/main/java/com/graphhopper/util/shapes/Shape.java
index f08cc439be..3e228408a1 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Shape.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Shape.java
@@ -19,7 +19,7 @@
 
 /**
  * A shape interface to implement circles or rectangles.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public interface Shape
@@ -36,7 +36,7 @@
 
     /**
      * @return true if the specified shape is fully contained in this shape. Only iff
-     * s1.contains(s2) && && s2.contains(s1) then s1 is equal to s2
+     * <pre> s1.contains(s2) &amp;&amp; s2.contains(s1) </pre> then s1 is equal to s2
      */
     boolean contains( Shape s );
 
diff --git a/core/src/main/resources/builddate b/core/src/main/resources/com/graphhopper/builddate
similarity index 100%
rename from core/src/main/resources/builddate
rename to core/src/main/resources/com/graphhopper/builddate
diff --git a/core/src/main/resources/com/graphhopper/util/ast.txt b/core/src/main/resources/com/graphhopper/util/ast.txt
new file mode 100644
index 0000000000..bde1af1863
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ast.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=sigue
+continue_onto=sigue per %1$s
+turn_left=xira a la izquierda
+turn_right=xira a la drecha
+turn_slight_left=xira llixeramente a la izquierda
+turn_slight_right=xira llixeramente a la drecha
+turn_sharp_left=xira fuerte a la izquierda
+turn_sharp_right=xira fuerte a la drecha
+turn_onto=%1$s per %2$s
+web.searchButton=Buscar
+web.fromHint=Dende
+web.viaHint=Pasando per
+web.toHint=Fasta
+web.moreButton=más
+web.gpxExportButton=Esportar GPX
+web.routeInfo=%1$s tardaràs %2$s
+web.locationsNotFound=Nun se puede trazar una ruta. Dalgún llugar nun s'alcuentra nel área
+web.bike=Bicicleta
+web.racingbike=Bici de carreres
+web.mtb=Bici de montaña
+web.car=Coche
+web.foot=A pie
+web.staticlink=enllaz estáticu
+web.motorcycle=Motocicleta
+via=pasando per
+finish=¡Aportasti!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=min
+ftAbbr=pies
+road=carretera
+off_bike=desmonta de la bici
+cycleway=carril bici
+way=vía
+paved=pavimentao
+unpaved=sin pavimentar
+stopover=pasando per %1$s
+roundaboutEnter=Entra na rotonda
+roundaboutExit=Na rotonda, toma la salida %1$s
+roundaboutExitOnto=Na rotonda, toma la salida %1$s haza %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/cz.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
similarity index 100%
rename from core/src/main/resources/com/graphhopper/util/cz.txt
rename to core/src/main/resources/com/graphhopper/util/cs_CZ.txt
diff --git a/core/src/main/resources/com/graphhopper/util/da_DK.txt b/core/src/main/resources/com/graphhopper/util/da_DK.txt
new file mode 100644
index 0000000000..5481277c10
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/da_DK.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=fortsæt
+continue_onto=fortsæt på %1$s
+turn_left=drej til venstre
+turn_right=drej til højre
+turn_slight_left=drej lidt til venstre
+turn_slight_right=drej lidt til højre
+turn_sharp_left=drej skarpt til venstre
+turn_sharp_right=drej skarpt til højre
+turn_onto=%1$s ind på %2$s
+web.searchButton=Søg
+web.fromHint=Fra 
+web.viaHint=Via
+web.toHint=Til
+web.moreButton=Mere
+web.gpxExportButton=Eksportér GPX-fil
+web.routeInfo=%1$s med køretid %2$s
+web.locationsNotFound=Kan ikke beregne ruten. Lokation(erne) kan ikke findes i området.
+web.bike=Cykel
+web.racingbike=Racercykel
+web.mtb=Mountain bike
+web.car=Bil
+web.foot=Gang
+web.staticlink=Direkte link
+web.motorcycle=Motorcykel
+via=via
+finish=Fremme!
+hourAbbr=tim
+dayAbbr= d
+minAbbr= min
+kmAbbr= km
+mAbbr= m
+miAbbr= mi
+ftAbbr=fod
+road=gade
+off_bike=hop af cyklen
+cycleway=cykelvej
+way=vej
+paved=brolagt
+unpaved=grusvej
+stopover=delmål %1$s
+roundaboutEnter=Kør ind i rundskørslen
+roundaboutExit=I rundkørslen, tag udkørsel %1$s
+roundaboutExitOnto=I rundskørslen, ta udkørsel %1$s ind på %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index 7f77887d4f..9b12e7af80 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -25,7 +25,7 @@ web.foot=À pied
 web.staticlink=Lien
 web.motorcycle=Vélo
 via=via
-finish=Fini!
+finish=Fini !
 hourAbbr=h
 dayAbbr=j
 minAbbr=min
diff --git a/core/src/main/resources/version b/core/src/main/resources/com/graphhopper/version
similarity index 100%
rename from core/src/main/resources/version
rename to core/src/main/resources/com/graphhopper/version
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index 97b761ae88..cf3047ab24 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -26,6 +26,7 @@
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 86df0df099..0e20dd8cb5 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -18,9 +18,7 @@
 package com.graphhopper;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -35,7 +33,7 @@
     @Test
     public void testLoad()
     {
-        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
         na.setNode(1, 42.1, 10.1);
@@ -68,7 +66,7 @@ public void testLoad()
     @Test
     public void testDisconnected179()
     {
-        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
         na.setNode(1, 42.1, 10.1);
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index e6d6673585..44a671ecaf 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -20,6 +20,7 @@
 import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
@@ -86,7 +87,7 @@ public void testMonacoWithInstructions() throws Exception
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         // identify the number of counts to compare with CH foot route
-        assertEquals(698, hopper.getVisitedSum());
+        assertEquals(698, rsp.getHints().getLong("visited_nodes.sum", 0));
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
 
@@ -201,7 +202,7 @@ public void testMonacoEnforcedDirection()
         req.getHints().put("heading_penalty", "300");
         GHResponse rsp = hopper.route(req);
 
-        assertEquals(873., rsp.getDistance(), 10.);
+        assertEquals(874., rsp.getDistance(), 10.);
         assertEquals(33, rsp.getPoints().getSize());
     }
 
@@ -220,7 +221,6 @@ public void testMonacoStraightVia()
         assertEquals(27, rsp.getPoints().getSize());
     }
 
-
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
@@ -247,17 +247,17 @@ public void testSRTMWithInstructions() throws Exception
 
         String str = rsp.getPoints().toString();
         assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
-                        + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
-                        + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
-                        + "(43.73125457162979,7.421274090288746,52.0), "
-                        + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
-                        + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
-                        + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
-                        + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
+                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
+                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
+                + "(43.73125457162979,7.421274090288746,52.0), "
+                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
+                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
+                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
+                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
                 str.substring(0, 662));
 
         assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
-                        + "(43.727680946587874,7.419198768422206,11.0)",
+                + "(43.727680946587874,7.419198768422206,11.0)",
                 str.substring(str.length() - 132));
 
         List<GPXEntry> list = rsp.getInstructions().createGPXList();
@@ -332,7 +332,12 @@ public void testRoundaboutInstructionsWithCH()
                 importOrLoad();
 
         assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
-        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
+
+        assertEquals(2, tmpHopper.getAlgorithmFactories().size());
+        for (RoutingAlgorithmFactory raf : tmpHopper.getAlgorithmFactories())
+        {
+            assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(raf.getClass()));
+        }
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
@@ -352,32 +357,58 @@ public void testRoundaboutInstructionsWithCH()
     }
 
     @Test
-    public void testMultipleVehiclesAndDoCHForBike()
+    public void testMultipleVehiclesWithCH()
     {
         String tmpOsmFile = "files/monaco.osm.gz";
-        String tmpImportVehicles = "bike,car";
-
         GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(tmpOsmFile).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                setEncodingManager(new EncodingManager("bike,car")).
                 importOrLoad();
         assertEquals("bike", tmpHopper.getDefaultVehicle().toString());
+        checkMultiVehiclesWithCH(tmpHopper);
+        tmpHopper.close();
+
+        tmpHopper.clean();
+        // new instance, try different order, resulting only in different default vehicle
+        tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager("car,bike")).
+                importOrLoad();
+        assertEquals("car", tmpHopper.getDefaultVehicle().toString());
+        checkMultiVehiclesWithCH(tmpHopper);
+        tmpHopper.close();
+    }
 
+    private void checkMultiVehiclesWithCH( GraphHopper tmpHopper )
+    {
+        String str = tmpHopper.getEncodingManager().toString();
         GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
                 .setVehicle("car"));
+        assertFalse("car routing for " + str + " should not have errors:" + rsp.getErrors(), rsp.hasErrors());
         assertEquals(207, rsp.getTime() / 1000f, 1);
         assertEquals(2838, rsp.getDistance(), 1);
 
         rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
                 .setVehicle("bike"));
+        assertFalse("bike routing for " + str + " should not have errors:" + rsp.getErrors(), rsp.hasErrors());
         assertEquals(494, rsp.getTime() / 1000f, 1);
         assertEquals(2192, rsp.getDistance(), 1);
 
         rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
                 .setVehicle("foot"));
         assertTrue("only bike and car were imported. foot request should fail", rsp.hasErrors());
+
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854), 0.).
+                addPoint(new GHPoint(43.744445, 7.429483), 190.).
+                setVehicle("bike").setWeighting("fastest");
+
+        rsp = hopper.route(req);
+        assertTrue("heading not allowed for CH enabled graph", rsp.hasErrors());
     }
 
     @Test
@@ -408,7 +439,9 @@ private void executeCHFootRoute()
                 setVehicle(vehicle));
 
         // identify the number of counts to compare with none-CH foot route which had nearly 700 counts
-        assertTrue("Too many nodes visited " + tmpHopper.getVisitedSum(), tmpHopper.getVisitedSum() < 120);
+        long sum = rsp.getHints().getLong("visited_nodes.sum", 0);
+        assertNotEquals(sum, 0);
+        assertTrue("Too many nodes visited " + sum, sum < 120);
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
         tmpHopper.close();
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 62b1d02bed..aea1581083 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -18,15 +18,12 @@
 package com.graphhopper;
 
 import com.graphhopper.reader.DataReader;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
@@ -36,9 +33,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.Assert.*;
@@ -133,6 +132,58 @@ public void testLoadOSMNoCH()
         gh.close();
     }
 
+    @Test
+    public void testLoadingWithDifferentCHConfig_issue471()
+    {
+        // with CH should not be loadable without CH configured
+        GraphHopper gh = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        gh.importOrLoad();
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        gh.close();
+
+        gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR"));
+        try
+        {
+            gh.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.chWeightings:"));
+        }
+
+        Helper.removeDir(new File(ghLoc));
+
+        // without CH should not be loadable with CH enabled
+        gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        gh.importOrLoad();
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        gh.close();
+
+        gh = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR"));
+        try
+        {
+            gh.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.chWeightings:"));
+        }
+    }
+
     @Test
     public void testAllowMultipleReadingInstances()
     {
@@ -281,8 +332,8 @@ public void testFootAndCar()
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
-        assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getCount());
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
+        assertEquals(8, instance.getGraphHopperStorage().getAllEdges().getMaxId());
 
         // A to D
         GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
@@ -325,7 +376,7 @@ public void testFailsForWrongConfig() throws IOException
                 put("prepare.chWeighting", "no")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
-        assertEquals(5, instance.getGraph().getNodes());
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
         instance.close();
 
         // different config (flagEncoder list)
@@ -458,13 +509,13 @@ public void testFootOnly()
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
-        assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getCount());
+        assertEquals(2, instance.getGraphHopperStorage().getNodes());
+        assertEquals(2, instance.getGraphHopperStorage().getAllEdges().getMaxId());
 
         // A to E only for foot
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
+        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52.01).setVehicle(EncodingManager.FOOT));
         assertFalse(res.hasErrors());
-        assertEquals(3, res.getPoints().getSize());
+        assertEquals(Helper.createPointList(11.1, 50, 10, 51, 11.2, 52), res.getPoints());
     }
 
     @Test
@@ -593,8 +644,6 @@ public void testGetPathsDirectionEnforcement2()
     @Test
     public void testGetPathsDirectionEnforcement3()
     {
-        // Test enforce via direction
-
         GraphHopper instance = initSquareGraphInstance(false);
 
         // Start in middle of edge 4-5 
@@ -690,21 +739,16 @@ public void testGetPathsDirectionEnforcement6()
         {
             2, 3, 4
         }, paths.get(1).calcNodes().toArray());
-
     }
 
     private GraphHopper initSquareGraphInstance( boolean withCH )
     {
-        EncodingManager encodingManager = new EncodingManager("car");
-
-        GraphStorage g;
-        if (withCH)
-        {
-            g = new LevelGraphStorage(new RAMDirectory(), encodingManager, false).create(20);
-        } else
-        {
-            g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(20);
-        }
+        CarFlagEncoder carEncoder = new CarFlagEncoder();
+        EncodingManager encodingManager = new EncodingManager(carEncoder);
+        Weighting weighting = new FastestWeighting(carEncoder);
+        GraphHopperStorage g = new GraphHopperStorage(Collections.singletonList(weighting), new RAMDirectory(), encodingManager,
+                false, new GraphExtension.NoOpExtension()).
+                create(20);
 
         //   2---3---4
         //  /    |    \
@@ -737,11 +781,12 @@ private GraphHopper initSquareGraphInstance( boolean withCH )
         g.edge(7, 8, 110, true);
 
         instance = new GraphHopper().
+                putAlgorithmFactory(weighting, null).
                 setCHEnable(withCH).
                 setCHWeighting("fastest").
                 setEncodingManager(encodingManager);
-        instance.setGraph(g);
-        instance.postProcessing();        
+        instance.setGraphHopperStorage(g);
+        instance.postProcessing();
 
         return instance;
     }
@@ -749,15 +794,35 @@ private GraphHopper initSquareGraphInstance( boolean withCH )
     @Test
     public void testCustomFactoryForNoneCH()
     {
+        CarFlagEncoder carEncoder = new CarFlagEncoder();
+        EncodingManager em = new EncodingManager(carEncoder);
+        Weighting weighting = new FastestWeighting(carEncoder);
         GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
                 setCHEnable(false).
-                setEncodingManager(new EncodingManager("CAR")).
+                setEncodingManager(em).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         RoutingAlgorithmFactory af = new RoutingAlgorithmFactorySimple();
-        closableInstance.setAlgorithmFactory(af);
+        closableInstance.putAlgorithmFactory(weighting, af);
         closableInstance.importOrLoad();
 
-        assertTrue(af == closableInstance.getAlgorithmFactory());
+        assertTrue(af == closableInstance.getAlgorithmFactory(weighting));
+
+        // test that hints are passwed to algorithm opts
+        final AtomicInteger cnt = new AtomicInteger(0);
+        closableInstance.putAlgorithmFactory(weighting, new RoutingAlgorithmFactorySimple()
+        {
+            @Override
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+            {
+                cnt.addAndGet(1);
+                assertFalse(opts.getHints().getBool("test", true));
+                return super.createAlgo(g, opts);
+            }
+        });
+        GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
+        req.getHints().put("test", false);
+        closableInstance.route(req);
+        assertEquals(1, cnt.get());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
index f923f29e0a..cce5484ab6 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
@@ -89,7 +89,7 @@ public void testEnsureCapacity()
         } catch (Throwable ex)
         {
         }
-        bs.ensureCapacity(16);
+        
         bs.add(8);
         bs.add(9);
         assertFalse(bs.contains(6));
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index bf9221c59d..4d70b50cb6 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -52,7 +52,7 @@
 
 /**
  * Tests the OSMReader with the normal helper initialized.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class OSMReaderTest
@@ -83,10 +83,10 @@ public void tearDown()
         Helper.removeDir(new File(dir));
     }
 
-    GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
+    GraphHopperStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
     {
-        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
-                is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
+        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager, is3D,
+                turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoOpExtension());
     }
 
     class GraphHopperTest extends GraphHopper
@@ -106,8 +106,8 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
 
             if (turnCosts)
             {
-                carEncoder = new CarFlagEncoder(5, 5, 3);
-                bikeEncoder = new BikeFlagEncoder(4, 2, 3);
+                carEncoder = new CarFlagEncoder(5, 5, 1);
+                bikeEncoder = new BikeFlagEncoder(4, 2, 1);
             } else
             {
                 carEncoder = new CarFlagEncoder();
@@ -120,7 +120,7 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
         }
 
         @Override
-        protected DataReader createReader( GraphStorage tmpGraph )
+        protected DataReader createReader( GraphHopperStorage tmpGraph )
         {
             return initOSMReader(new OSMReader(tmpGraph));
         }
@@ -128,8 +128,9 @@ protected DataReader createReader( GraphStorage tmpGraph )
         @Override
         protected DataReader importData() throws IOException
         {
-            GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(), getEncodingManager().needsTurnCostsSupport());
-            setGraph(tmpGraph);
+            GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
+                    getEncodingManager().needsTurnCostsSupport());
+            setGraphHopperStorage(tmpGraph);
 
             DataReader osmReader = createReader(tmpGraph);
             try
@@ -140,8 +141,8 @@ protected DataReader importData() throws IOException
                 throw new RuntimeException(e);
             }
             osmReader.readGraph();
-            carOutExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
-            carAllExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
+            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
             return osmReader;
         }
     }
@@ -155,7 +156,7 @@ InputStream getResource( String file )
     public void testMain()
     {
         GraphHopper hopper = new GraphHopperTest(file1).importOrLoad();
-        GraphStorage graph = (GraphStorage) hopper.getGraph();
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
 
         assertNotNull(graph.getProperties().get("osmreader.import.date"));
         assertNotEquals("", graph.getProperties().get("osmreader.import.date"));
@@ -174,9 +175,8 @@ public void testMain()
         assertEquals("street 123, B 122", iter.getName());
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
-        FlagEncoder flags = carEncoder;
-        assertTrue(flags.isForward(iter.getFlags()));
-        assertTrue(flags.isBackward(iter.getFlags()));
+        assertTrue(iter.isForward(carEncoder));
+        assertTrue(iter.isBackward(carEncoder));
 
         assertTrue(iter.next());
         assertEquals("route 666", iter.getName());
@@ -188,8 +188,8 @@ public void testMain()
         assertEquals(n10, iter.getAdjNode());
         assertEquals(88643, iter.getDistance(), 1);
 
-        assertTrue(flags.isForward(iter.getFlags()));
-        assertTrue(flags.isBackward(iter.getFlags()));
+        assertTrue(iter.isForward(carEncoder));
+        assertTrue(iter.isBackward(carEncoder));
         assertFalse(iter.next());
 
         // get third added location id=30
@@ -212,8 +212,7 @@ public void testMain()
     public void testSort()
     {
         GraphHopper hopper = new GraphHopperTest(file1).setSortGraph(true).importOrLoad();
-        Graph graph = hopper.getGraph();
-        NodeAccess na = graph.getNodeAccess();
+        NodeAccess na = hopper.getGraphHopperStorage().getNodeAccess();
         assertEquals(10, na.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
         assertEquals(51.249, na.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
     }
@@ -224,7 +223,7 @@ public void testWithBounds()
         GraphHopper hopper = new GraphHopperTest(file1)
         {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
+            protected DataReader createReader( GraphHopperStorage tmpGraph )
             {
                 return new OSMReader(tmpGraph)
                 {
@@ -239,7 +238,7 @@ public boolean isInBounds( OSMNode node )
 
         hopper.importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(4, graph.getNodes());
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
@@ -274,7 +273,7 @@ public boolean isInBounds( OSMNode node )
     public void testOneWay()
     {
         GraphHopper hopper = new GraphHopperTest(file2).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52.0);
         int n22 = AbstractGraphStorageTester.getIdOf(graph, 52.133);
@@ -295,27 +294,27 @@ public void testOneWay()
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
-        assertTrue(encoder.isForward(iter.getFlags()));
-        assertFalse(encoder.isBackward(iter.getFlags()));
+        assertTrue(iter.isForward(encoder));
+        assertFalse(iter.isBackward(encoder));
 
         assertTrue(iter.next());
         assertEquals(n22, iter.getAdjNode());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(iter.isForward(encoder));
+        assertTrue(iter.isBackward(encoder));
 
         assertTrue(iter.next());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(iter.isForward(encoder));
+        assertTrue(iter.isBackward(encoder));
 
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
-        assertTrue(encoder.isForward(iter.getFlags()));
-        assertFalse(encoder.isBackward(iter.getFlags()));
+        assertTrue(iter.isForward(encoder));
+        assertFalse(iter.isBackward(encoder));
 
         assertTrue(iter.next());
         assertEquals(n10, iter.getAdjNode());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(iter.isForward(encoder));
+        assertTrue(iter.isBackward(encoder));
     }
 
     @Test
@@ -328,7 +327,7 @@ public void cleanUp()
             {
             }
         }.importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n40 = AbstractGraphStorageTester.getIdOf(graph, 54.0);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 55.0);
@@ -357,7 +356,7 @@ public void cleanUp()
             {
             }
         }.importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56.0);
         EdgeIterator iter = carOutExplorer.setBaseNode(n60);
@@ -369,7 +368,7 @@ public void cleanUp()
     public void testWayReferencesNotExistingAdjNode()
     {
         GraphHopper hopper = new GraphHopperTest(file4).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         assertEquals(2, graph.getNodes());
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
@@ -382,7 +381,7 @@ public void testWayReferencesNotExistingAdjNode()
     public void testFoot()
     {
         GraphHopper hopper = new GraphHopperTest(file3).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 11.1);
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 12);
@@ -405,7 +404,7 @@ public void testFoot()
     public void testNegativeIds()
     {
         GraphHopper hopper = new GraphHopperTest(fileNegIds).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(4, graph.getNodes());
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
@@ -429,8 +428,11 @@ public void testNegativeIds()
     @Test
     public void testBarriers()
     {
-        GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
-        Graph graph = hopper.getGraph();
+        GraphHopper hopper = new GraphHopperTest(fileBarriers).
+                setMinNetworkSize(0, 0).
+                importOrLoad();
+
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(8, graph.getNodes());
 
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51);
@@ -464,8 +466,10 @@ public void testBarriers()
     @Test
     public void testBarriersOnTowerNodes()
     {
-        GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
-        Graph graph = hopper.getGraph();
+        GraphHopper hopper = new GraphHopperTest(fileBarriers).
+                setMinNetworkSize(0, 0).
+                importOrLoad();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(8, graph.getNodes());
 
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56);
@@ -487,7 +491,8 @@ public void testBarriersOnTowerNodes()
     public void testRelation()
     {
         EncodingManager manager = new EncodingManager("bike");
-        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager, false)).
+        GraphHopperStorage ghStorage = new GraphHopperStorage(new RAMDirectory(), manager, false, new GraphExtension.NoOpExtension());
+        OSMReader reader = new OSMReader(ghStorage).
                 setEncodingManager(manager);
         OSMRelation osmRel = new OSMRelation(1);
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 1, ""));
@@ -518,7 +523,8 @@ public void testTurnRestrictions()
     {
         GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
                 importOrLoad();
-        GraphStorage graph = hopper.getGraph();
+
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(15, graph.getNodes());
         assertTrue(graph.getExtension() instanceof TurnCostExtension);
         TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
@@ -604,7 +610,7 @@ public long handleNodeTags( OSMNode node )
             }
         };
         EncodingManager manager = new EncodingManager(encoder);
-        GraphStorage graph = newGraph(dir, manager, false, false);
+        GraphHopperStorage ghStorage = newGraph(dir, manager, false, false);
         final Map<Integer, Double> latMap = new HashMap<Integer, Double>();
         final Map<Integer, Double> lonMap = new HashMap<Integer, Double>();
         latMap.put(1, 1.1d);
@@ -613,7 +619,7 @@ public long handleNodeTags( OSMNode node )
         lonMap.put(1, 1.0d);
         lonMap.put(2, 1.0d);
         final AtomicInteger increased = new AtomicInteger(0);
-        OSMReader osmreader = new OSMReader(graph)
+        OSMReader osmreader = new OSMReader(ghStorage)
         {
             // mock data access
             @Override
@@ -661,7 +667,7 @@ public void testReadEleFromCustomOSM()
         GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
         {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
+            protected DataReader createReader( GraphHopperStorage tmpGraph )
             {
                 return initOSMReader(new OSMReader(tmpGraph)
                 {
@@ -674,7 +680,7 @@ protected double getElevation( OSMNode node )
             }
         }.setElevation(true).importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49);
 
@@ -692,7 +698,7 @@ public void testReadEleFromDataProvider()
         hopper.setElevationProvider(provider);
         hopper.importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 49.501);
         int n30 = AbstractGraphStorageTester.getIdOf(graph, 49.5011);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49.5001);
@@ -721,7 +727,8 @@ public void testTurnFlagCombination()
         BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
         EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
 
-        OSMReader reader = new OSMReader(new GraphBuilder(manager).create())
+        GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
+        OSMReader reader = new OSMReader(ghStorage)
         {
             @Override
             public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index ad83ce8f40..d9b52e6021 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -23,7 +23,7 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
 
 import java.util.Collection;
@@ -43,7 +43,7 @@
     @Test
     public void testGetRestrictionAsEntries()
     {
-        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 1);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
 
@@ -52,9 +52,9 @@ public void testGetRestrictionAsEntries()
         internalToOSMEdge.put(3, 3L);
         internalToOSMEdge.put(4, 4L);
 
-        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
-        EdgeBasedRoutingAlgorithmTest.initGraph(graph);
-        OSMReader osmReader = new OSMReader(graph)
+        GraphHopperStorage ghStorage = new GraphBuilder(new EncodingManager(encoder)).create();
+        EdgeBasedRoutingAlgorithmTest.initGraph(ghStorage);
+        OSMReader osmReader = new OSMReader(ghStorage)
         {
 
             @Override
@@ -73,7 +73,7 @@ public long getOsmIdOfInternalEdge( int edgeId )
             }
         };
 
-        EdgeExplorer edgeExplorer = graph.createEdgeExplorer();
+        EdgeExplorer edgeExplorer = ghStorage.createEdgeExplorer();
 
         // TYPE == ONLY
         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 87c5790246..95050deeb3 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -28,6 +28,7 @@
 
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -72,7 +73,7 @@ public AStarBidirectionTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
@@ -87,14 +88,14 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     @Test
     public void testInitFromAndTo()
     {
-        Graph g = createGraph(false);
+        Graph g = createGHStorage(false);
         g.edge(0, 1, 1, true);
         updateDistancesFor(g, 0, 0.00, 0.00);
         updateDistancesFor(g, 1, 0.01, 0.01);
 
         final AtomicReference<AStar.AStarEdge> fromRef = new AtomicReference<AStar.AStarEdge>();
         final AtomicReference<AStar.AStarEdge> toRef = new AtomicReference<AStar.AStarEdge>();
-        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(), traversalMode)
+        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(carEncoder), traversalMode)
         {
             @Override
             public void initFrom( int from, double weight )
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 492024905e..3e3f71d18d 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -27,6 +27,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
  * @author Peter Karich
@@ -57,7 +58,7 @@ public AStarTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 31fd0bda81..819dfad67f 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -24,8 +24,7 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
-
-import java.util.Random;
+import java.util.*;
 
 import static org.junit.Assert.*;
 
@@ -37,8 +36,6 @@
  */
 public abstract class AbstractRoutingAlgorithmTester
 {
-    // problem is: matrix graph is expensive to create to cache it in a static variable
-    private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
     protected FlagEncoder carEncoder;
     protected FlagEncoder footEncoder;
@@ -50,36 +47,41 @@ public void setUp()
         carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
         footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
-                weighting(new ShortestWeighting()).build();
+                weighting(new ShortestWeighting(carEncoder)).build();
+    }
+
+    protected Graph getGraph( GraphHopperStorage ghStorage, Weighting weighting )
+    {
+        return ghStorage.getGraph(Graph.class, weighting);
     }
 
-    protected Graph createGraph( EncodingManager em, boolean is3D )
+    protected GraphHopperStorage createGHStorage( EncodingManager em, List<? extends Weighting> weightings, boolean is3D )
     {
         return new GraphBuilder(em).set3D(is3D).create();
     }
 
-    protected Graph createGraph( boolean is3D )
+    protected GraphHopperStorage createGHStorage( boolean is3D )
     {
-        return createGraph(encodingManager, is3D);
+        return createGHStorage(encodingManager, Arrays.asList(defaultOpts.getWeighting()), is3D);
     }
 
-    public RoutingAlgorithm createAlgo( Graph g )
+    protected final RoutingAlgorithm createAlgo( GraphHopperStorage g )
     {
         return createAlgo(g, defaultOpts);
     }
 
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    protected final RoutingAlgorithm createAlgo( GraphHopperStorage ghStorage, AlgorithmOptions opts )
     {
-        return createFactory(g, opts).createAlgo(g, opts);
+        return createFactory(ghStorage, opts).createAlgo(getGraph(ghStorage, opts.getWeighting()), opts);
     }
 
-    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
+    public abstract RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
+        GraphHopperStorage ghStorage = createTestStorage();
+        RoutingAlgorithm algo = createAlgo(ghStorage);
         Path p = algo.calcPath(0, 7);
         assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
@@ -88,8 +90,8 @@ public void testCalcShortestPath()
     @Test
     public void testWeightLimit()
     {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
+        GraphHopperStorage ghStorage = createTestStorage();
+        RoutingAlgorithm algo = createAlgo(ghStorage);
         algo.setWeightLimit(10);
         Path p = algo.calcPath(0, 7);
         assertTrue(algo.getVisitedNodes() < 7);
@@ -100,7 +102,7 @@ public void testWeightLimit()
     @Test
     public void testWeightLimit_issue380()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initGraphWeightLimit(graph);
         RoutingAlgorithm algo = createAlgo(graph);
         algo.setWeightLimit(3);
@@ -119,7 +121,7 @@ public void testWeightLimit_issue380()
     @Test
     public void testCalcFastestPath()
     {
-        Graph graphShortest = createGraph(false);
+        GraphHopperStorage graphShortest = createGHStorage(false);
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
         Path p1 = createAlgo(graphShortest, defaultOpts).
                 calcPath(0, 3);
@@ -127,14 +129,15 @@ public void testCalcFastestPath()
         assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
-        Graph graphFastest = createGraph(false);
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+        GraphHopperStorage graphFastest = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), false);
         initDirectedAndDiffSpeed(graphFastest, carEncoder);
-        Path p2 = createAlgo(graphFastest,
-                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+        Path p2 = createAlgo(graphFastest, opts).
                 calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
         assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
-        assertEquals(p2.toString(), 111442, p2.getMillis());
+        assertEquals(p2.toString(), 111442, p2.getTime());
     }
 
     // 0-1-2-3
@@ -181,10 +184,11 @@ protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     @Test
     public void testCalcFootPath()
     {
-        Graph graphShortest = createGraph(false);
-        initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
-                weighting(new ShortestWeighting()).build()).
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting(footEncoder)).build();
+        GraphHopperStorage ghStorage = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), false);
+        initFootVsCar(ghStorage);
+        Path p1 = createAlgo(ghStorage, opts).
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
@@ -216,9 +220,9 @@ protected void initFootVsCar( Graph graph )
     }
 
     // see test-graph.svg !
-    protected Graph createTestGraph()
+    protected GraphHopperStorage createTestStorage()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 7, true);
         graph.edge(0, 4, 6, true);
@@ -257,9 +261,13 @@ protected Graph createTestGraph()
     @Test
     public void testNoPathFound()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
+        graph.edge(100, 101);
         assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
+        graph = createGHStorage(false);
+        graph.edge(100, 101);
+
         // two disconnected areas
         graph.edge(0, 1, 7, true);
 
@@ -272,7 +280,7 @@ public void testNoPathFound()
         // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
-        graph = createGraph(false);
+        graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
         assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
@@ -281,8 +289,8 @@ public void testNoPathFound()
     @Test
     public void testWikipediaShortestPath()
     {
-        Graph graph = createWikipediaTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 4);
+        GraphHopperStorage ghStorage = createWikipediaTestGraph();
+        Path p = createAlgo(ghStorage).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -290,16 +298,15 @@ public void testWikipediaShortestPath()
     @Test
     public void testCalcIf1EdgeAway()
     {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(1, 2);
+        Path p = createAlgo(createTestStorage()).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
-    protected Graph createWikipediaTestGraph()
+    protected GraphHopperStorage createWikipediaTestGraph()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 7, true);
         graph.edge(0, 2, 9, true);
         graph.edge(0, 5, 14, true);
@@ -364,12 +371,12 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
     @Test
     public void testBidirectional()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+        // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         Path p = createAlgo(graph).calcPath(0, 4);
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+        // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
         assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
@@ -387,7 +394,7 @@ public void testBidirectional()
     @Test
     public void testBidirectional2()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 100, true);
         graph.edge(1, 2, 1, true);
@@ -410,7 +417,8 @@ public void testBidirectional2()
     public void testRekeyBugOfIntBinHeap()
     {
         // using Dijkstra + IntBinHeap then rekey loops endlessly
-        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
+        GraphHopperStorage matrixGraph = createMatrixGraph();
+        Path p = createAlgo(matrixGraph).calcPath(36, 91);
         assertEquals(12, p.calcNodes().size());
 
         TIntList list = p.calcNodes();
@@ -420,21 +428,22 @@ public void testRekeyBugOfIntBinHeap()
             assertTrue("wrong locations: " + list.toString(), false);
         }
         assertEquals(66f, p.getDistance(), 1e-3);
+
+        testBug1(matrixGraph);
+        testCorrectWeight(matrixGraph);
     }
 
-    @Test
-    public void testBug1()
+    public void testBug1( GraphHopperStorage g )
     {
-        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
+        Path p = createAlgo(g).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
     }
 
-    @Test
-    public void testCorrectWeight()
+    public void testCorrectWeight( GraphHopperStorage g )
     {
-        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
+        Path p = createAlgo(g).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
@@ -442,7 +451,7 @@ public void testCorrectWeight()
     @Test
     public void testCannotCalculateSP()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
@@ -453,7 +462,7 @@ public void testCannotCalculateSP()
     @Test
     public void testDirectedGraphBug1()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 3, false);
         graph.edge(1, 2, 2.99, false);
 
@@ -470,7 +479,7 @@ public void testDirectedGraphBug1()
     @Test
     public void testDirectedGraphBug2()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
         graph.edge(2, 3, 1, false);
@@ -488,7 +497,8 @@ public void testDirectedGraphBug2()
     @Test
     public void testWithCoordinates()
     {
-        Graph graph = createGraph(false);
+        Weighting weighting = new ShortestWeighting(carEncoder);
+        GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
 
         graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(1.5, 1));
         graph.edge(2, 3, 2, true).setWayGeometry(Helper.createPointList(0, 1.5));
@@ -507,15 +517,14 @@ public void testWithCoordinates()
         updateDistancesFor(graph, 3, 0, 1);
         updateDistancesFor(graph, 4, 0, 2);
 
-        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting);
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
-        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
+        Path p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
         assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
         assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
+        p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(2, 1);
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
         assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
         assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
@@ -524,8 +533,7 @@ public void testWithCoordinates()
     @Test
     public void testCalcIfEmptyWay()
     {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 0);
+        Path p = createAlgo(createTestStorage()).calcPath(0, 0);
         assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
     }
@@ -533,23 +541,23 @@ public void testCalcIfEmptyWay()
     @Test
     public void testViaEdges_FromEqualsTo()
     {
-        Graph graph = createTestGraph();
+        GraphHopperStorage ghStorage = createTestStorage();
         // identical tower nodes
-        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        Path p = calcPathViaQuery(ghStorage, 0.001, 0.000, 0.001, 0.000);
         assertTrue(p.isFound());
         assertEquals(Helper.createTList(0), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // identical query points on edge
-        p = calcPath(graph, 0, 1, 0, 1);
+        p = calcPath(ghStorage, 0, 1, 0, 1);
         assertTrue(p.isFound());
         assertEquals(Helper.createTList(8), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // very close
-        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        p = calcPathViaQuery(ghStorage, 0.00092, 0, 0.00091, 0);
         assertEquals(Helper.createTList(8, 9), p.calcNodes());
         assertEquals(p.toString(), 1.11, p.getDistance(), .1);
     }
@@ -557,7 +565,7 @@ public void testViaEdges_FromEqualsTo()
     @Test
     public void testViaEdges_BiGraph()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
         // 0-7 to 4-3        
@@ -574,8 +582,8 @@ public void testViaEdges_BiGraph()
     @Test
     public void testViaEdges_WithCoordinates()
     {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 2, 3);
+        GraphHopperStorage ghStorage = createTestStorage();
+        Path p = calcPath(ghStorage, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
         assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
@@ -583,7 +591,7 @@ public void testViaEdges_WithCoordinates()
     @Test
     public void testViaEdges_SpecialCases()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         // 0->1\
         // |    2
         // 4<-3/
@@ -618,45 +626,42 @@ public void testViaEdges_SpecialCases()
     @Test
     public void testQueryGraphAndFastest()
     {
-        Graph graph = createGraph(false);
+        Weighting weighting = new FastestWeighting(carEncoder);
+        GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
         initDirectedAndDiffSpeed(graph, carEncoder);
-        Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
+        Path p = calcPathViaQuery(weighting, graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
     }
 
-    // Problem: for contraction hierarchy we cannot easily select egdes by nodes as some edges are skipped
-    Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+    Path calcPathViaQuery( GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
     {
-        return calcPathViaQuery("shortest", graph, fromLat, fromLon, toLat, toLon);
+        return calcPathViaQuery(defaultOpts.getWeighting(), ghStorage, fromLat, fromLon, toLat, toLon);
     }
 
-    Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+    Path calcPathViaQuery( Weighting weighting, GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
+        LocationIndex index = new LocationIndexTree(ghStorage, new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
-        Weighting w = new ShortestWeighting();
-        if (weighting.equalsIgnoreCase("fastest"))
-            w = new FastestWeighting(carEncoder);
 
         // correct order for CH: in factory do prepare and afterwards wrap in query graph
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
-        RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).build();
+        RoutingAlgorithmFactory factory = createFactory(ghStorage, opts);
+        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage, weighting)).lookup(from, to);
         return factory.createAlgo(qGraph, opts).
                 calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
-    Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
+    Path calcPath( GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int toNode1, int toNode2 )
     {
-        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
-        QueryResult from = newQR(graph, fromNode1, fromNode2);
-        QueryResult to = newQR(graph, toNode1, toNode2);
+        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2                
+        QueryResult from = newQR(ghStorage, fromNode1, fromNode2);
+        QueryResult to = newQR(ghStorage, toNode1, toNode2);
 
-        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        RoutingAlgorithmFactory factory = createFactory(ghStorage, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage, defaultOpts.getWeighting())).lookup(from, to);
         return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
@@ -688,13 +693,19 @@ QueryResult newQR( Graph graph, int node1, int node2 )
     public void testTwoWeightsPerEdge()
     {
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        Graph graph = initEleGraph(createGraph(new EncodingManager(encoder), true));
+        EncodingManager em = new EncodingManager(encoder);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(encoder).
+                weighting(new FastestWeighting(encoder)).build();
+        GraphHopperStorage graph = createGHStorage(em, Arrays.asList(opts.getWeighting()), true);
+        initEleGraph(graph);
         // force the other path
         GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
+        Path p = createAlgo(graph, opts).
+                calcPath(0, 10);
         assertEquals(85124371, p.getTime());
         assertEquals(425622, p.getDistance(), 1);
         assertEquals(85124.4, p.getWeight(), 1);
@@ -703,7 +714,7 @@ public void testTwoWeightsPerEdge()
     @Test
     public void test0SpeedButUnblocked_Issue242()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
 
         graph.edge(0, 1).setFlags(flags).setDistance(10);
@@ -724,12 +735,15 @@ public void test0SpeedButUnblocked_Issue242()
     public void testTwoWeightsPerEdge2()
     {
         // other direction should be different!
-        Graph graph = initEleGraph(createGraph(true));
-        Path p = createAlgo(graph).calcPath(0, 10);
-        // GHUtility.printEdgeInfo(graph, carEncoder);
-        assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
         Weighting fakeWeighting = new Weighting()
         {
+
+            @Override
+            public FlagEncoder getFlagEncoder()
+            {
+                return carEncoder;
+            }
+
             @Override
             public double getMinWeight( double distance )
             {
@@ -760,14 +774,22 @@ else if (adj == 4)
             }
         };
 
-        graph = initEleGraph(createGraph(true));
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(defaultOpts.getWeighting()).build();
+        GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(opts.getWeighting()), true);
+        initEleGraph(graph);
+        Path p = createAlgo(graph, opts).calcPath(0, 10);
+        // GHUtility.printEdgeInfo(graph, carEncoder);
+        assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
+
+        AlgorithmOptions fakeOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        graph = createGHStorage(encodingManager, Arrays.asList(fakeOpts.getWeighting()), true);
+        initEleGraph(graph);
         QueryResult from = newQR(graph, 3, 0);
         QueryResult to = newQR(graph, 10, 9);
 
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
-        RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
-        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
+        RoutingAlgorithmFactory factory = createFactory(graph, fakeOpts);
+        QueryGraph qGraph = new QueryGraph(getGraph(graph, fakeWeighting)).lookup(from, to);
+        p = factory.createAlgo(qGraph, fakeOpts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(37009621, p.getTime());
         assertEquals(616827, p.getDistance(), 1);
@@ -841,23 +863,15 @@ public static Graph initGraphWeightLimit( Graph g )
         return g;
     }
 
-    public Graph getMatrixGraph()
-    {
-        return getMatrixAlikeGraph();
-    }
-
-    public static Graph getMatrixAlikeGraph()
+    protected GraphHopperStorage createMatrixGraph()
     {
-        if (matrixGraph == null)
-            matrixGraph = createMatrixAlikeGraph();
-        return matrixGraph;
+        return createMatrixAlikeGraph(createGHStorage(false));
     }
 
-    private static Graph createMatrixAlikeGraph()
+    protected static GraphHopperStorage createMatrixAlikeGraph( GraphHopperStorage tmpGraph )
     {
         int WIDTH = 10;
         int HEIGHT = 15;
-        Graph tmpGraph = new GraphBuilder(encodingManager).create();
         int[][] matrix = new int[WIDTH][HEIGHT];
         int counter = 0;
         Random rand = new Random(12);
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index bd859f314e..66423237ab 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -27,6 +27,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
  * @author Peter Karich
@@ -57,7 +58,7 @@ public DijkstraBidirectionRefTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index c1c99dd41b..4a36ec4736 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -20,6 +20,7 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 
@@ -46,14 +47,14 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-                {
-                        {
-                                TraversalMode.NODE_BASED
-                        },
+        {
+            {
+                TraversalMode.NODE_BASED
+            },
 //            TODO { TraversalMode.EDGE_BASED_1DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
-                });
+        });
     }
 
     private final TraversalMode traversalMode;
@@ -64,7 +65,7 @@ public DijkstraOneToManyTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
@@ -115,7 +116,9 @@ public void testTwoWeightsPerEdge2()
     @Test
     public void testIssue182()
     {
-        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
+        GraphHopperStorage storage = createGHStorage(false);
+        initGraph(storage);
+        RoutingAlgorithm algo = createAlgo(storage);
         Path p = algo.calcPath(0, 8);
         assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
 
@@ -127,7 +130,7 @@ public void testIssue182()
     @Test
     public void testIssue239_and362()
     {
-        Graph g = createGraph(false);
+        GraphHopperStorage g = createGHStorage(false);
         g.edge(0, 1, 1, true);
         g.edge(1, 2, 1, true);
         g.edge(2, 0, 1, true);
@@ -147,7 +150,7 @@ public void testIssue239_and362()
     @Test
     public void testUseCache()
     {
-        RoutingAlgorithm algo = createAlgo(createTestGraph());
+        RoutingAlgorithm algo = createAlgo(createTestStorage());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
@@ -163,7 +166,7 @@ public void testUseCache()
     @Test
     public void testDifferentEdgeFilter()
     {
-        Graph g = new GraphBuilder(encodingManager).levelGraphCreate();
+        GraphHopperStorage g = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
         g.edge(4, 3, 10, true);
         g.edge(3, 6, 10, true);
 
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 9b51ac6fe5..f1ab5b196a 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -27,6 +27,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
  * @author Peter Karich
@@ -57,7 +58,7 @@ public DijkstraTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 81e75cc3c3..05cc670dd8 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -19,10 +19,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 
@@ -81,7 +78,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
         return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
-    protected GraphStorage createGraph( EncodingManager em )
+    protected GraphHopperStorage createStorage( EncodingManager em )
     {
         return new GraphBuilder(em).create();
     }
@@ -141,7 +138,7 @@ Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double tu
     @Test
     public void testBasicTurnRestriction()
     {
-        GraphStorage g = createGraph(createEncodingManager(true));
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
@@ -171,7 +168,7 @@ public void testBasicTurnRestriction()
     @Test
     public void testUTurns()
     {
-        GraphStorage g = createGraph(createEncodingManager(true));
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
@@ -207,7 +204,7 @@ public void testUTurns()
     @Test
     public void testBasicTurnCosts()
     {
-        GraphStorage g = createGraph(createEncodingManager(false));
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         Path p = createAlgo(g, AlgorithmOptions.start().
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 0048b97018..1085b7636a 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -42,8 +42,9 @@
 {
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
-    private final EncodingManager mixedEncoders = new EncodingManager(
-            new CarFlagEncoder(), new FootFlagEncoder(), new BikeFlagEncoder());
+//    private final EncodingManager mixedEncoders = new EncodingManager(
+//            new CarFlagEncoder(), new FootFlagEncoder(), new BikeFlagEncoder());
+    private final EncodingManager mixedEncoders = new EncodingManager(new CarFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final AngleCalc ac = new AngleCalc();
@@ -52,7 +53,7 @@
     @Test
     public void testFound()
     {
-        GraphStorage g = new GraphBuilder(carManager).create();
+        GraphHopperStorage g = new GraphBuilder(carManager).create();
         Path p = new Path(g, encoder);
         assertFalse(p.isFound());
         assertEquals(0, p.getDistance(), 1e-7);
@@ -64,7 +65,7 @@ public void testFound()
     public void testTime()
     {
         FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
-        GraphStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
+        GraphHopperStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
         Path p = new Path(g, tmpEnc);
         long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
         assertEquals(375 * 60 * 1000, p.calcMillis(100000, flags, false));
@@ -76,7 +77,7 @@ public void testTime()
     @Test
     public void testWayList()
     {
-        GraphStorage g = new GraphBuilder(carManager).create();
+        GraphHopperStorage g = new GraphBuilder(carManager).create();
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0.0, 0.1);
         na.setNode(1, 1.0, 0.1);
@@ -219,7 +220,7 @@ public void testFindInstruction()
 
     private class RoundaboutGraph
     {
-        private EdgeIteratorState edge3to6, edge3to9;
+        private final EdgeIteratorState edge3to6, edge3to9;
         boolean clockwise = false;
         final public Graph g = new GraphBuilder(mixedEncoders).create();
         final public NodeAccess na = g.getNodeAccess();
@@ -248,28 +249,19 @@ private RoundaboutGraph()
             na.setNode(8, 52.515, 13.351);
             na.setNode(9, 52.513, 13.351);
 
+            g.edge(1, 2, 5, true).setName("MainStreet 1 2");
 
-            EdgeIteratorState tmpEdge;
-            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            // roundabout            
+            roundaboutEdges.add(g.edge(3, 2, 5, false).setName("2-3"));
+            roundaboutEdges.add(g.edge(4, 3, 5, false).setName("3-4"));
+            roundaboutEdges.add(g.edge(5, 4, 5, false).setName("4-5"));
+            roundaboutEdges.add(g.edge(2, 5, 5, false).setName("5-2"));
 
-            // roundabout
-            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
-            roundaboutEdges.add(tmpEdge.detach(false));
-            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
-            roundaboutEdges.add(tmpEdge.detach(false));
-            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
-            roundaboutEdges.add(tmpEdge.detach(false));
-            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
-            roundaboutEdges.add(tmpEdge.detach(false));
+            g.edge(4, 7, 5, true).setName("MainStreet 4 7");
+            g.edge(5, 8, 5, true).setName("5-8");
 
-            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
-            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
-
-            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
-            edge3to6 = tmpEdge.detach(false);
-
-            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
-            edge3to9 = tmpEdge.detach(false);
+            edge3to6 = g.edge(3, 6, 5, true).setName("3-6");
+            edge3to9 = g.edge(3, 9, 5, false).setName("3-9");
 
             setRoundabout(clockwise);
             inverse3to9();
@@ -283,7 +275,7 @@ public void setRoundabout( boolean clockwise )
                 for (EdgeIteratorState edge : roundaboutEdges)
                 {
                     edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
-                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
                 }
             }
             this.clockwise = clockwise;
@@ -294,7 +286,7 @@ public void inverse3to9()
             for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to9.getFlags();
-                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+                edge3to9.setFlags(encoder.setAccess(flags, !edge3to9.isForward(encoder), false));
             }
         }
 
@@ -303,11 +295,10 @@ public void inverse3to6()
             for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to6.getFlags();
-                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+                edge3to6.setFlags(encoder.setAccess(flags, !edge3to6.isForward(encoder), true));
             }
         }
 
-
         private double getAngle( int n1, int n2, int n3, int n4 )
         {
             double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
@@ -327,32 +318,34 @@ public void testCalcInstructionsRoundabout()
     {
         for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
         {
-            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                     .calcPath(1, 8);
+            assertTrue(p.isFound());
             InstructionList wayList = p.calcInstructions(tr);
             // Test instructions
             List<String> tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet",
-                            "At roundabout, take exit 3 onto 5-8",
-                            "Finish!"),
+            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+                    "At roundabout, take exit 3 onto 5-8",
+                    "Finish!"),
                     tmpList);
             // Test Radian
             double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
             RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-            assertEquals(delta, instr.getRadian(), 0.01);
+            assertEquals(delta, instr.getTurnAngle(), 0.01);
 
             // case of continuing a street through a roundabout
-            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
+                    calcPath(1, 7);
             wayList = p.calcInstructions(tr);
             tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet",
-                            "At roundabout, take exit 2 onto MainStreet",
-                            "Finish!"),
+            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+                    "At roundabout, take exit 2 onto MainStreet 4 7",
+                    "Finish!"),
                     tmpList);
             // Test Radian
             delta = roundaboutGraph.getAngle(1, 2, 4, 7);
             instr = (RoundaboutInstruction) wayList.get(1);
-            assertEquals(delta, instr.getRadian(), 0.01);
+            assertEquals(delta, instr.getTurnAngle(), 0.01);
         }
     }
 
@@ -362,12 +355,13 @@ public void testCalcInstructionsRoundabout()
     @Test
     public void testCalcInstructionsRoundaboutBegin()
     {
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(2, 8);
+        assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
-                        "Finish!"),
+                "Finish!"),
                 tmpList);
     }
 
@@ -378,13 +372,14 @@ public void testCalcInstructionsRoundaboutBegin()
     public void testCalcInstructionsRoundaboutDirectExit()
     {
         roundaboutGraph.inverse3to9();
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 8);
+        assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-6",
-                        "At roundabout, take exit 3 onto 5-8",
-                        "Finish!"),
+                "At roundabout, take exit 3 onto 5-8",
+                "Finish!"),
                 tmpList);
         roundaboutGraph.inverse3to9();
     }
@@ -396,33 +391,28 @@ public void testCalcInstructionsRoundaboutDirectExit()
     public void testCalcInstructionsRoundabout2()
     {
         roundaboutGraph.inverse3to6();
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
+        assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 2 onto 5-8",
-                        "Finish!"),
+        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+                "At roundabout, take exit 2 onto 5-8",
+                "Finish!"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
+        assertEquals(delta, instr.getTurnAngle(), 0.01);
         roundaboutGraph.inverse3to6();
-
     }
 
-
-    /**
-     * see https://github.com/graphhopper/graphhopper/issues/353
-     */
     @Test
     public void testCalcInstructionsRoundaboutIssue353()
     {
         final Graph g = new GraphBuilder(carManager).create();
         final NodeAccess na = g.getNodeAccess();
 
-
         //
         //          8
         //           \
@@ -433,7 +423,6 @@ public void testCalcInstructionsRoundaboutIssue353()
         //      10 -9 -3
         //       \    |
         //        --- 6
-
         na.setNode(1, 52.514, 13.348);
         na.setNode(2, 52.514, 13.349);
         na.setNode(3, 52.5135, 13.35);
@@ -442,47 +431,44 @@ public void testCalcInstructionsRoundaboutIssue353()
         na.setNode(6, 52.513, 13.35);
         na.setNode(7, 52.514, 13.352);
         na.setNode(8, 52.515, 13.351);
-
-        // Sidelane
+        
         na.setNode(9, 52.5135, 13.349);
         na.setNode(10, 52.5135, 13.348);
         na.setNode(11, 52.514, 13.347);
-
-
-        EdgeIteratorState tmpEdge;
-        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
-        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
-
-
+        
+        g.edge(2, 1, 5, false).setName("MainStreet 2 1");
+        g.edge(1, 11, 5, false).setName("MainStreet 1 11");
+        
         // roundabout
+        EdgeIteratorState tmpEdge;
         tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
 
-        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
-        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
-        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+        g.edge(4, 7, 5, true).setName("MainStreet 4 7");
+        g.edge(5, 8, 5, true).setName("5-8");
+        g.edge(3, 6, 5, true).setName("3-6");
 
-
-        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 11);
+        assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
-                        "Finish!"),
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet 1 11",
+                "Finish!"),
                 tmpList);
     }
 
@@ -492,20 +478,20 @@ public void testCalcInstructionsRoundaboutIssue353()
     @Test
     public void testCalcInstructionsRoundaboutClockwise()
     {
-
         roundaboutGraph.setRoundabout(true);
-        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
+        assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 1 onto 5-8",
-                        "Finish!"),
+        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+                "At roundabout, take exit 1 onto 5-8",
+                "Finish!"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
+        assertEquals(delta, instr.getTurnAngle(), 0.01);
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index c45f2cc45f..99604b0651 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -28,6 +28,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 import org.junit.After;
 import org.junit.Test;
@@ -43,14 +44,14 @@
 {
     private EncodingManager encodingManager;
     private FlagEncoder carEncoder;
-    private GraphStorage g;
+    private GraphHopperStorage g;
 
     @Before
     public void setUp()
     {
         carEncoder = new CarFlagEncoder();
         encodingManager = new EncodingManager(carEncoder);
-        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
+        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false, new GraphExtension.NoOpExtension()).create(100);
     }
 
     @After
@@ -202,12 +203,12 @@ public void testMultipleVirtualNodes()
         assertEquals(new GHPoint(1, 2.5), pl.toGHPoint(1));
 
         EdgeIteratorState edge = GHUtility.getEdge(queryGraph, 3, 1);
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 3));
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 1));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 1));
 
         edge = GHUtility.getEdge(queryGraph, 3, 0);
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 3));
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 0));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 0));
 
         // snap again => new virtual node on same edge!
         iter = g.createEdgeExplorer().setBaseNode(1);
@@ -271,7 +272,7 @@ public void testVirtEdges()
     public void testUseMeanElevation()
     {
         g.close();
-        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, true).create(100);
+        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension()).create(100);
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0, 0);
         na.setNode(1, 0, 0.0001, 20);
@@ -356,12 +357,12 @@ public void testOneWayLoop_Issue162()
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
         EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
         iter.next();
-        assertTrue(iter.toString(), carEncoder.isForward(iter.getFlags()));
-        assertFalse(iter.toString(), carEncoder.isBackward(iter.getFlags()));
+        assertTrue(iter.toString(), iter.isForward(carEncoder));
+        assertFalse(iter.toString(), iter.isBackward(carEncoder));
 
         iter.next();
-        assertFalse(iter.toString(), carEncoder.isForward(iter.getFlags()));
-        assertTrue(iter.toString(), carEncoder.isBackward(iter.getFlags()));
+        assertFalse(iter.toString(), iter.isForward(carEncoder));
+        assertTrue(iter.toString(), iter.isBackward(carEncoder));
     }
 
     @Test
@@ -420,7 +421,7 @@ public void testGetEdgeProps()
         queryGraph.lookup(Arrays.asList(res1));
         // get virtual edge
         e1 = GHUtility.getEdge(queryGraph, res1.getClosestNode(), 0);
-        EdgeIteratorState e2 = queryGraph.getEdgeProps(e1.getEdge(), Integer.MIN_VALUE);
+        EdgeIteratorState e2 = queryGraph.getEdgeIteratorState(e1.getEdge(), Integer.MIN_VALUE);
         assertEquals(e1.getEdge(), e2.getEdge());
     }
 
@@ -513,7 +514,7 @@ public void testTurnCostsProperlyPropagated_Issue282()
         TurnCostExtension turnExt = new TurnCostExtension();
         FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
 
-        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+        GraphHopperStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
                 new EncodingManager(encoder), false, turnExt).
                 create(100);
         NodeAccess na = graphWithTurnCosts.getNodeAccess();
@@ -646,9 +647,9 @@ public void testEnforceHeadingByEdgeId()
         queryGraph.enforceHeadingByEdgeId(2, 1, false);
         // test penalized south
         boolean expect = true;
-        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, 2);
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, 2);
 
-        VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, incomingEdge.getBaseNode());
+        VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, incomingEdge.getBaseNode());
         // expect incoming edge in reverse direction to be unfavored
         assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
         // expect reverse incoming edge to be unfavored
@@ -682,11 +683,11 @@ public void testInternalAPIOriginalTraversalKey()
         assertTrue(iter.next());
         assertEquals(0, iter.getAdjNode());
         assertEquals(GHUtility.createEdgeKey(1, 0, origEdgeId, false),
-                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 0)).getOriginalTraversalKey());
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 0)).getOriginalTraversalKey());
 
         assertTrue(iter.next());
         assertEquals(1, iter.getAdjNode());
         assertEquals(GHUtility.createEdgeKey(0, 1, origEdgeId, false),
-                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 1)).getOriginalTraversalKey());
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 1)).getOriginalTraversalKey());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 43016f4f74..bc4a43d3e3 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -48,7 +48,7 @@
 
 /**
  * Try algorithms, indices and graph storages with real data
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class RoutingAlgorithmIT
@@ -120,7 +120,7 @@ public void testBike2_issue432()
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(52.349969, 8.013813, 52.349713, 8.013293, 56, 7));
         // reverse route avoids the location
-        list.add(new OneRun(52.349713, 8.013293, 52.349969, 8.013813, 293, 21));
+//        list.add(new OneRun(52.349713, 8.013293, 52.349969, 8.013813, 293, 21));
         runAlgo(testCollector, "files/map-bug432.osm.gz", "target/map-bug432-gh",
                 list, "bike2", true, "bike2", "fastest", true);
 
@@ -149,17 +149,17 @@ public void testMonacoAllAlgorithmsWithBaseGraph()
         FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
         Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
 
-        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraphHopperStorage(), hopper.getLocationIndex(),
                 encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
         AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
-        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
-            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+        if (!(chPrepare.getQueryGraph() instanceof CHGraph))
+            throw new IllegalStateException("Last prepared QueryGraph has to be a CHGraph");
 
         // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
-        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        Graph baseGraphOfCHPrepared = chPrepare.getBaseGraph();
         for (AlgoHelperEntry ahe : prepares)
         {
-            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            if (!(ahe.getQueryGraph() instanceof CHGraph))
             {
                 ahe.setQueryGraph(baseGraphOfCHPrepared);
             }
@@ -226,6 +226,22 @@ public void testMoscowTurnCosts()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testSidewalkNo()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // roundabout contains sidewalk=no which should be avoided
+        list.add(new OneRun(57.154888, -2.101822, 57.153445, -2.099869, 329, 31));
+        // longer path should go through tertiary, see discussion in #476
+        list.add(new OneRun(57.154888, -2.101822, 57.147299, -2.096286, 1118, 68));
+
+        boolean testAlsoCH = false, is3D = false;
+        runAlgo(testCollector, "files/map-sidewalk-no.osm.gz", "target/graph-sidewalkno",
+                list, "foot", testAlsoCH, "foot", "fastest", is3D);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoFastest()
     {
@@ -308,8 +324,8 @@ public void testNorthBayreuthFootFastestAnd3D()
         List<OneRun> list = new ArrayList<OneRun>();
         // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
         list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
-        // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach'
-        list.add(new OneRun(49.986111, 11.550407, 50.023182, 11.555386, 5165, 133));
+        // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach' but avoid tertiary highway from Pechgraben
+        list.add(new OneRun(49.990967, 11.545258, 50.023182, 11.555386, 5636, 97));
         runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
                 list, "FOOT", true, "FOOT", "fastest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
@@ -360,7 +376,7 @@ public void testMonacoMountainBike()
         list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2322, 110));
         list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3613, 178));
         list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2331, 121));
-        // hard to select between secondard and primary (both are AVOID for mtb)
+        // hard to select between secondary and primary (both are AVOID for mtb)
         list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1459, 88));
         runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "MTB", true, "MTB", "fastest", false);
@@ -393,6 +409,7 @@ public void testKremsBikeRelation()
     {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12491, 159));
+        // 3109m is better as cyclepath is used
         list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3113, 87));
         list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 94));
 
@@ -549,8 +566,8 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
             Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
-                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraphHopperStorage(),
+                    hopper.getLocationIndex(), encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
             for (AlgoHelperEntry entry : prepares)
             {
@@ -564,7 +581,7 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
                 }
             }
 
-            return hopper.getGraph();
+            return hopper.getGraphHopperStorage();
         } catch (Exception ex)
         {
             if (algoEntry == null)
@@ -587,12 +604,12 @@ public void testPerformance() throws IOException
         Random rand = new Random(0);
         EncodingManager eManager = new EncodingManager("CAR");
         FlagEncoder encoder = eManager.getEncoder("CAR");
-        Graph graph = new GraphBuilder(eManager).create();
+        GraphHopperStorage graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
         new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
         Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
-                new ShortestWeighting(), eManager);
+                new ShortestWeighting(encoder), eManager);
         for (AlgoHelperEntry entry : prepares)
         {
             StopWatch sw = new StopWatch();
@@ -634,7 +651,7 @@ public void testMonacoParallel() throws IOException
                 setOSMFile("files/monaco.osm.gz").
                 setGraphHopperLocation(graphFile).
                 importOrLoad();
-        final Graph g = hopper.getGraph();
+        final Graph g = hopper.getGraphHopperStorage();
         final LocationIndex idx = hopper.getLocationIndex();
         final List<OneRun> instances = createMonacoCar();
         List<Thread> threads = new ArrayList<Thread>();
@@ -645,7 +662,7 @@ public void testMonacoParallel() throws IOException
         // testing if algorithms are independent. should be. so test only two algorithms. 
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
-        final Weighting weighting = new ShortestWeighting();
+        final Weighting weighting = new ShortestWeighting(encodingManager.getEncoder("CAR"));
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
         for (int no = 0; no < MAX; no++)
         {
@@ -666,7 +683,7 @@ public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
                             AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
-                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                            testCollector.assertDistance(new AlgoHelperEntry(g, g, opts, idx),
                                     oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
@@ -693,30 +710,35 @@ public void run()
         hopper.close();
     }
 
-    static List<AlgoHelperEntry> createAlgos( Graph g,
+    static List<AlgoHelperEntry> createAlgos( GraphHopperStorage ghStorage,
                                               LocationIndex idx, final FlagEncoder encoder, boolean withCh,
-                                              final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+                                              final TraversalMode tMode, final Weighting weighting,
+                                              final EncodingManager manager )
     {
         List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
         // later: include dijkstraOneToMany        
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
 
         final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
         astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
         final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
-        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
-        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, dijkstrabiOpts, idx));
 
         if (withCh)
         {
-            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                    graphCH, encoder, weighting, tMode);
+            GraphHopperStorage storageCopy = new GraphBuilder(manager).
+                    set3D(ghStorage.getNodeAccess().is3D()).setCHGraph(weighting).
+                    create();
+            ghStorage.copyTo(storageCopy);
+            storageCopy.freeze();
+            final CHGraph graphCH = storageCopy.getGraph(CHGraph.class, weighting);
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(
+                    new GHDirectory("", DAType.RAM_INT), storageCopy, graphCH, encoder, weighting, tMode);
             prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
-            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            LocationIndex idxCH = new LocationIndexTree(storageCopy, new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, dijkstrabiOpts, idxCH)
             {
                 @Override
                 public RoutingAlgorithm createAlgo( Graph qGraph )
@@ -725,7 +747,7 @@ public RoutingAlgorithm createAlgo( Graph qGraph )
                 }
             });
 
-            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, astarbiOpts, idxCH)
             {
                 @Override
                 public RoutingAlgorithm createAlgo( Graph qGraph )
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index a7ad66405e..ed3850f7e6 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -21,8 +21,10 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.Helper;
+import java.util.Arrays;
+import java.util.List;
 
 import static org.junit.Assert.*;
 
@@ -31,58 +33,45 @@
 /**
  * Tests if a graph optimized by contraction hierarchies returns the same results as a none
  * optimized one. Additionally fine grained path unpacking is tested.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // matrix graph is expensive to create and to prepare!
-    private static Graph preparedMatrixGraph;
-
-    @Override
-    public Graph getMatrixGraph()
-    {
-        if (preparedMatrixGraph == null)
-        {
-            LevelGraph lg = (LevelGraph) createGraph(false);
-            getMatrixAlikeGraph().copyTo(lg);
-            createFactory(lg, defaultOpts);
-            preparedMatrixGraph = lg;
-        }
-        return preparedMatrixGraph;
-    }
-
     @Override
-    protected LevelGraph createGraph( EncodingManager em, boolean is3D )
+    protected CHGraph getGraph( GraphHopperStorage ghStorage, Weighting weighting )
     {
-        return new GraphBuilder(em).set3D(is3D).levelGraphCreate();
+        return ghStorage.getGraph(CHGraph.class, weighting);
     }
 
     @Override
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    protected GraphHopperStorage createGHStorage( EncodingManager em, 
+                                                  List<? extends Weighting> weightings, boolean is3D )
     {
-        return createFactory(g, opts).createAlgo(g, opts);
+        return new GraphHopperStorage(weightings, new RAMDirectory(),
+                em, is3D, new GraphExtension.NoOpExtension()).
+                create(1000);
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts )
     {
         PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                (LevelGraph) g, opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
-        // hack: prepare matrixGraph only once
-        if (g != preparedMatrixGraph)
-            ch.doWork();
-
+                ghStorage, getGraph(ghStorage, opts.getWeighting()),
+                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        ch.doWork();
         return ch;
     }
 
     @Test
     public void testPathRecursiveUnpacking()
     {
-        // use an encoder where it is possible to store 2 weights per edge
+        // use an encoder where it is possible to store 2 weights per edge        
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
+        ShortestWeighting weighting = new ShortestWeighting(encoder);
         EncodingManager em = new EncodingManager(encoder);
-        LevelGraphStorage g2 = (LevelGraphStorage) createGraph(em, false);
+        GraphHopperStorage ghStorage = createGHStorage(em, Arrays.asList(weighting), false);
+        CHGraphImpl g2 = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
         g2.edge(0, 1, 1, true);
         EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, false);
         EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, false);
@@ -98,11 +87,12 @@ public void testPathRecursiveUnpacking()
         EdgeIteratorState iter2_2 = g2.edge(5, 7);
         iter2_2.setDistance(1.4).setFlags(encoder.setProperties(10, true, false));
 
+        ghStorage.freeze();
         // simulate preparation
-        EdgeSkipIterState iter2_1 = g2.shortcut(0, 5);
+        CHEdgeIteratorState iter2_1 = g2.shortcut(0, 5);
         iter2_1.setDistance(2.8).setFlags(encoder.setProperties(10, true, false));
         iter2_1.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
-        EdgeSkipIterState tmp = g2.shortcut(0, 7);
+        CHEdgeIteratorState tmp = g2.shortcut(0, 7);
         tmp.setDistance(4.2).setFlags(encoder.setProperties(10, true, false));
         tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
         g2.setLevel(1, 0);
@@ -114,10 +104,9 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        ShortestWeighting weighting = new ShortestWeighting();
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
         Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                g2, encoder, weighting, TraversalMode.NODE_BASED).
+                ghStorage, g2, encoder, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
@@ -125,41 +114,21 @@ public void testPathRecursiveUnpacking()
         assertEquals(4.2, p.getDistance(), 1e-5);
     }
 
-    @Override
-    public void testCalcFootPath()
-    {
-        // disable car encoder and move foot to first position => workaround as CH does not allow multiple vehicles
-        FlagEncoder tmpFootEncoder = footEncoder;
-        FlagEncoder tmpCarEncoder = carEncoder;
-        carEncoder = new CarFlagEncoder()
-        {
-            @Override
-            public long setProperties( double speed, boolean forward, boolean backward )
-            {
-                return 0;
-            }
-        };
-
-        footEncoder = new FootFlagEncoder();
-        new EncodingManager(footEncoder);
-
-        super.testCalcFootPath();
-        footEncoder = tmpFootEncoder;
-        carEncoder = tmpCarEncoder;
-    }
-
     @Test
     public void testBaseGraph()
     {
         CarFlagEncoder carFE = new CarFlagEncoder();
-        Graph g = createGraph(new EncodingManager(carFE), false);
-        initDirectedAndDiffSpeed(g, carFE);
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carFE).
+                weighting(new ShortestWeighting(carFE)).build();
+        GraphHopperStorage ghStorage = createGHStorage(new EncodingManager(carFE),
+                Arrays.asList(opts.getWeighting()), false);
+        initDirectedAndDiffSpeed(ghStorage, carFE);
 
-        // do CH preparation for car
-        createFactory(g, defaultOpts);
+        // do CH preparation for car        
+        createFactory(ghStorage, opts);
 
         // use base graph for solving normal Dijkstra
-        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(ghStorage, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.29, p1.getDistance(), 1e-2);
         assertEquals(p1.toString(), 144823, p1.getTime());
@@ -168,32 +137,39 @@ public void testBaseGraph()
     @Test
     public void testBaseGraphMultipleVehicles()
     {
-        Graph g = createGraph(encodingManager, false);
-        initFootVsCar(g);
-
         AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
                 weighting(new FastestWeighting(footEncoder)).build();
         AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
                 weighting(new FastestWeighting(carEncoder)).build();
 
+        GraphHopperStorage g = createGHStorage(encodingManager,
+                Arrays.asList(footOptions.getWeighting(), carOptions.getWeighting()), false);
+        initFootVsCar(g);
+
         // do CH preparation for car
         RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
 
         // use contracted graph
-        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        Path p1 = contractedFactory.createAlgo(getGraph(g, carOptions.getWeighting()), carOptions).calcPath(0, 7);
         assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
         assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
 
         // use base graph for solving normal Dijkstra via car
-        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g, carOptions).calcPath(0, 7);
         assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
         assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
         assertEquals(p2.toString(), 2700 * 1000, p2.getTime());
 
         // use base graph for solving normal Dijkstra via foot
-        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g, footOptions).calcPath(0, 7);
         assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
         assertEquals(p3.toString(), 12240 * 1000, p3.getTime());
         assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
     }
+
+    @Override
+    public void testRekeyBugOfIntBinHeap()
+    {
+        super.testRekeyBugOfIntBinHeap(); //To change body of generated methods, choose Tools | Templates.
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 23dd327820..2bba811493 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -22,9 +22,12 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+import gnu.trove.list.TIntList;
+import java.util.Arrays;
 
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 
 import static org.junit.Assert.*;
 
@@ -36,20 +39,20 @@
  */
 public class PrepareContractionHierarchiesTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
-    private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    private final Weighting weighting = new ShortestWeighting();
+    private final CarFlagEncoder carEncoder = new CarFlagEncoder();
+    private final EncodingManager encodingManager = new EncodingManager(carEncoder);
+    private final Weighting weighting = new ShortestWeighting(carEncoder);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private Directory dir;
 
-    LevelGraph createGraph()
+    GraphHopperStorage createGHStorage()
     {
-        return new GraphBuilder(encodingManager).levelGraphCreate();
+        return new GraphBuilder(encodingManager).setCHGraph(weighting).create();
     }
 
-    LevelGraph createExampleGraph()
+    GraphHopperStorage createExampleGraph()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
 
         //5-1-----2
         //   \ __/|
@@ -76,12 +79,14 @@ public void setUp()
     @Test
     public void testShortestPathSkipNode()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        CHGraph lg = g.getGraph(CHGraph.class);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg,
+                carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(100);
         int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
@@ -94,13 +99,14 @@ public void testShortestPathSkipNode()
     @Test
     public void testShortestPathSkipNode2()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(10);
         int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
@@ -112,11 +118,13 @@ public void testShortestPathSkipNode2()
     @Test
     public void testShortestPathLimit()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
+
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(0));
         algo.setWeightLimit(2);
         int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
@@ -126,38 +134,46 @@ public void testShortestPathLimit()
     @Test
     public void testAddShortcuts()
     {
-        LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
+        int old = lg.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getCount());
+        assertEquals(old + 1, lg.getAllEdges().getMaxId());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
-        LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
+        initShortcutsGraph(lg);
+        int oldCount = g.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 7, g.getAllEdges().getCount());
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount + 7, lg.getAllEdges().getMaxId());
     }
 
     @Test
     public void testDirectedGraph()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         g.edge(5, 4, 3, false);
         g.edge(4, 5, 10, false);
         g.edge(2, 4, 1, false);
         g.edge(5, 2, 1, false);
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
-        int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        g.freeze();
+        int oldCount = GHUtility.count(lg.getAllEdges());
+        assertEquals(6, oldCount);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(2, prepare.getShortcuts());
+        assertEquals(oldCount + 2, GHUtility.count(lg.getAllEdges()));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -166,14 +182,21 @@ public void testDirectedGraph()
     @Test
     public void testDirectedGraph2()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         initDirected2(g);
-        int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        int oldCount = GHUtility.count(g.getAllEdges());
+        assertEquals(19, oldCount);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
-        assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
+
+        assertEquals(9, prepare.getShortcuts());
+        assertEquals(oldCount + 9, lg.getAllEdges().getMaxId());
+        assertEquals(oldCount + 9, GHUtility.count(lg.getAllEdges()));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -182,12 +205,13 @@ public void testDirectedGraph2()
     @Test
     public void testDirectedGraph3()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
         //5 6 7
         // \|/
-        //4-3_1<-
-        //    \_|_10
-        //   0__2_11
+        //4-3_1<-\ 10
+        //     \_|/
+        //   0___2_11
 
         g.edge(0, 2, 2, true);
         g.edge(10, 2, 2, true);
@@ -202,9 +226,10 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph();
         prepare.prepareNodes();
+
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -285,13 +310,15 @@ void initRoundaboutGraph( Graph g )
     @Test
     public void testRoundaboutUnpacking()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        int oldCount = g.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 23, g.getAllEdges().getCount());
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount + 23, lg.getAllEdges().getMaxId());
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -299,77 +326,93 @@ public void testRoundaboutUnpacking()
     @Test
     public void testFindShortcuts_Roundabout()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        EdgeIteratorState iter1_1 = g.edge(1, 3, 1, true);
-        EdgeIteratorState iter1_2 = g.edge(3, 4, 1, true);
-        EdgeIteratorState iter2_1 = g.edge(4, 5, 1, false);
-        EdgeIteratorState iter2_2 = g.edge(5, 6, 1, false);
-        EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
-        EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
-        g.edge(8, 4, 1, false);
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        EdgeSkipIterState tmp = g.shortcut(1, 4);
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        EdgeIteratorState iter1_3 = ghStorage.edge(1, 3, 1, true);
+        EdgeIteratorState iter3_4 = ghStorage.edge(3, 4, 1, true);
+        EdgeIteratorState iter4_5 = ghStorage.edge(4, 5, 1, false);
+        EdgeIteratorState iter5_6 = ghStorage.edge(5, 6, 1, false);
+        EdgeIteratorState iter6_8 = ghStorage.edge(6, 8, 2, false);
+        EdgeIteratorState iter8_4 = ghStorage.edge(8, 4, 1, false);
+        ghStorage.edge(6, 7, 1, true);
+        ghStorage.freeze();
+
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg,
+                carEncoder, weighting, tMode);
+        CHEdgeIteratorState tmp = lg.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
+        tmp.setSkippedEdges(iter1_3.getEdge(), iter3_4.getEdge());
         long f = PrepareEncoder.getScFwdDir();
-        tmp = g.shortcut(4, 6);
+        tmp = lg.shortcut(4, 6);
         tmp.setFlags(f);
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
-        tmp = g.shortcut(6, 4);
+        tmp.setSkippedEdges(iter4_5.getEdge(), iter5_6.getEdge());
+        tmp = lg.shortcut(6, 4);
         tmp.setFlags(f);
         tmp.setWeight(3);
-        tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
+        tmp.setSkippedEdges(iter6_8.getEdge(), iter8_4.getEdge());
 
         prepare.initFromGraph();
         prepare.prepareNodes();
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
+        lg.setLevel(3, 3);
+        lg.setLevel(5, 5);
+        lg.setLevel(7, 7);
+        lg.setLevel(8, 8);
 
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
+        Iterator<Shortcut> iter = sc.iterator();
+        Shortcut sc1 = iter.next();
+        Shortcut sc2 = iter.next();
+        if (sc1.from > sc2.from)
+        {
+            Shortcut tmpSc = sc1;
+            sc1 = sc2;
+            sc2 = tmpSc;
+        }
+
+        assertEquals("1->6, weight:4.0 (7,8)", sc1.toString());
+        assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
     }
 
-    void initUnpackingGraph( LevelGraphStorage g, Weighting w )
+    void initUnpackingGraph( GraphHopperStorage ghStorage, CHGraph g, Weighting w )
     {
         final long flags = carEncoder.setProperties(30, true, false);
         double dist = 1;
         g.edge(10, 0).setDistance(dist).setFlags(flags);
-        EdgeIteratorState iterTmp1 = g.edge(0, 1);
-        iterTmp1.setDistance(dist).setFlags(flags);
-        EdgeIteratorState iter2 = g.edge(1, 2).setDistance(dist).setFlags(flags);
-        EdgeIteratorState iter3 = g.edge(2, 3).setDistance(dist).setFlags(flags);
-        EdgeIteratorState iter4 = g.edge(3, 4).setDistance(dist).setFlags(flags);
-        EdgeIteratorState iter5 = g.edge(4, 5).setDistance(dist).setFlags(flags);
-        EdgeIteratorState iter6 = g.edge(5, 6).setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState01 = g.edge(0, 1);
+        edgeState01.setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState12 = g.edge(1, 2).setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState23 = g.edge(2, 3).setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState34 = g.edge(3, 4).setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState45 = g.edge(4, 5).setDistance(dist).setFlags(flags);
+        EdgeIteratorState edgeState56 = g.edge(5, 6).setDistance(dist).setFlags(flags);
         long oneDirFlags = PrepareEncoder.getScFwdDir();
 
-        int tmp = iterTmp1.getEdge();
-        EdgeSkipIterState sc1 = g.shortcut(0, 2);
+        int tmpEdgeId = edgeState01.getEdge();
+        ghStorage.freeze();
+        CHEdgeIteratorState sc0_2 = g.shortcut(0, 2);
         int x = EdgeIterator.NO_EDGE;
-        sc1.setWeight(w.calcWeight(iterTmp1, false, x) + w.calcWeight(iter2, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
-        sc1.setSkippedEdges(tmp, iter2.getEdge());
-        tmp = sc1.getEdge();
-        EdgeSkipIterState sc2 = g.shortcut(0, 3);
-        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter3, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
-        sc2.setSkippedEdges(tmp, iter3.getEdge());
-        tmp = sc2.getEdge();
-        sc1 = g.shortcut(0, 4);
-        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter4, false, x)).setDistance(4).setFlags(oneDirFlags);
-        sc1.setSkippedEdges(tmp, iter4.getEdge());
-        tmp = sc1.getEdge();
-        sc2 = g.shortcut(0, 5);
-        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter5, false, x)).setDistance(5).setFlags(oneDirFlags);
-        sc2.setSkippedEdges(tmp, iter5.getEdge());
-        tmp = sc2.getEdge();
-        sc1 = g.shortcut(0, 6);
-        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter6, false, x)).setDistance(6).setFlags(oneDirFlags);
-        sc1.setSkippedEdges(tmp, iter6.getEdge());
+        sc0_2.setWeight(w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
+        sc0_2.setSkippedEdges(tmpEdgeId, edgeState12.getEdge());
+        tmpEdgeId = sc0_2.getEdge();
+        CHEdgeIteratorState sc0_3 = g.shortcut(0, 3);
+        sc0_3.setWeight(sc0_2.getWeight() + w.calcWeight(edgeState23, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
+        sc0_3.setSkippedEdges(tmpEdgeId, edgeState23.getEdge());
+        tmpEdgeId = sc0_3.getEdge();
+        CHEdgeIteratorState sc0_4 = g.shortcut(0, 4);
+        sc0_4.setWeight(sc0_3.getWeight() + w.calcWeight(edgeState34, false, x)).setDistance(4).setFlags(oneDirFlags);
+        sc0_4.setSkippedEdges(tmpEdgeId, edgeState34.getEdge());
+        tmpEdgeId = sc0_4.getEdge();
+        CHEdgeIteratorState sc0_5 = g.shortcut(0, 5);
+        sc0_5.setWeight(sc0_4.getWeight() + w.calcWeight(edgeState45, false, x)).setDistance(5).setFlags(oneDirFlags);
+        sc0_5.setSkippedEdges(tmpEdgeId, edgeState45.getEdge());
+        tmpEdgeId = sc0_5.getEdge();
+        CHEdgeIteratorState sc0_6 = g.shortcut(0, 6);
+        sc0_6.setWeight(sc0_5.getWeight() + w.calcWeight(edgeState56, false, x)).setDistance(6).setFlags(oneDirFlags);
+        sc0_6.setSkippedEdges(tmpEdgeId, edgeState56.getEdge());
         g.setLevel(0, 10);
         g.setLevel(6, 9);
         g.setLevel(5, 8);
@@ -383,10 +426,11 @@ void initUnpackingGraph( LevelGraphStorage g, Weighting w )
     @Test
     public void testUnpackingOrder()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        initUnpackingGraph(ghStorage, lg, weighting);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -395,12 +439,13 @@ public void testUnpackingOrder()
     @Test
     public void testUnpackingOrder_Fastest()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
         Weighting w = new FastestWeighting(carEncoder);
-        initUnpackingGraph(g, w);
+        initUnpackingGraph(ghStorage, lg, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -409,7 +454,8 @@ public void testUnpackingOrder_Fastest()
     @Test
     public void testCircleBug()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         //  /--1
         // -0--/
         //  |
@@ -417,7 +463,7 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -430,7 +476,8 @@ public void testBug178()
         // 0-1->-2--3--4
         //   \-<-/
         //
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         g.edge(1, 2, 1, false);
         g.edge(2, 1, 1, false);
 
@@ -441,7 +488,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -515,12 +562,12 @@ public static void initDirected1( Graph g )
     }
 
     // prepare-routing.svg
-    public static LevelGraph initShortcutsGraph( LevelGraph g )
+    public static Graph initShortcutsGraph( Graph g )
     {
         g.edge(0, 1, 1, true);
         g.edge(0, 2, 1, true);
         g.edge(1, 2, 1, true);
-        g.edge(2, 3, 1, true);
+        g.edge(2, 3, 1.5, true);
         g.edge(1, 4, 1, true);
         g.edge(2, 9, 1, true);
         g.edge(9, 3, 1, true);
@@ -542,7 +589,7 @@ public static LevelGraph initShortcutsGraph( LevelGraph g )
         return g;
     }
 
-    //    public static void printEdges(LevelGraph g) {
+    //    public static void printEdges(CHGraph g) {
 //        RawEdgeIterator iter = g.getAllEdges();
 //        while (iter.next()) {
 //            EdgeSkipIterator single = g.getEdgeProps(iter.edge(), iter.nodeB());
@@ -564,4 +611,62 @@ public void testBits()
         assertEquals((BitUtil.BIG.toBitString(edgeId)),
                 BitUtil.BIG.toLastBitString(fromNode, 32) + BitUtil.BIG.toLastBitString(endNode, 32));
     }
+
+    @Test
+    public void testMultiplePreparationsIdenticalView()
+    {
+        CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
+        BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
+        EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
+
+        // FastestWeighting would lead to different shortcuts due to different default speeds for bike and car
+        Weighting carWeighting = new ShortestWeighting(tmpCarEncoder);
+        Weighting bikeWeighting = new ShortestWeighting(tmpBikeEncoder);
+
+        List<Weighting> chWeightings = Arrays.asList(carWeighting, bikeWeighting);
+        GraphHopperStorage ghStorage = new GraphHopperStorage(chWeightings, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
+        initShortcutsGraph(ghStorage);
+
+        ghStorage.freeze();
+
+        for (Weighting w : chWeightings)
+        {
+            checkPath(ghStorage, w, 7, 5, Helper.createTList(3, 9, 14, 16, 13, 12));
+        }
+    }
+
+    @Test
+    public void testMultiplePreparationsDifferentView()
+    {
+        CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
+        BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
+        EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
+
+        Weighting carWeighting = new FastestWeighting(tmpCarEncoder);
+        Weighting bikeWeighting = new FastestWeighting(tmpBikeEncoder);
+
+        List<Weighting> chWeightings = Arrays.asList(carWeighting, bikeWeighting);
+        GraphHopperStorage ghStorage = new GraphHopperStorage(chWeightings, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
+        initShortcutsGraph(ghStorage);
+        EdgeIteratorState edge = GHUtility.getEdge(ghStorage, 9, 14);
+        edge.setFlags(tmpBikeEncoder.setAccess(edge.getFlags(), false, false));
+
+        ghStorage.freeze();
+
+        checkPath(ghStorage, carWeighting, 7, 5, Helper.createTList(3, 9, 14, 16, 13, 12));
+        // detour around blocked 9,14
+        checkPath(ghStorage, bikeWeighting, 9, 5, Helper.createTList(3, 10, 14, 16, 13, 12));
+    }
+
+    void checkPath( GraphHopperStorage ghStorage, Weighting w, int expShortcuts, double expDistance, TIntList expNodes )
+    {
+        CHGraph lg = ghStorage.getGraph(CHGraph.class, w);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, w.getFlagEncoder(), w, tMode);
+        prepare.doWork();
+        assertEquals(w.toString(), expShortcuts, prepare.getShortcuts());
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, w.getFlagEncoder(), w, tMode));
+        Path p = algo.calcPath(3, 12);
+        assertEquals(w.toString(), expDistance, p.getDistance(), 1e-5);
+        assertEquals(w.toString(), expNodes, p.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index a67b0f1f62..a9ab59dadc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -388,10 +388,10 @@ public void testAvoidMotorway()
     @Test
     public void testPriority()
     {
-        long flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.BEST.getValue());
+        long flags = encoder.priorityWayEncoder.setValue(0, PriorityCode.BEST.getValue());
         assertEquals(1, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
 
-        flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.AVOID_IF_POSSIBLE.getValue());
+        flags = encoder.priorityWayEncoder.setValue(0, PriorityCode.AVOID_IF_POSSIBLE.getValue());
         assertEquals(3d / 7d, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index f559373833..922ce6164d 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -42,7 +42,7 @@ protected BikeCommonFlagEncoder createBikeEncoder()
 
     private Graph initExampleGraph()
     {
-        GraphStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
+        GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true, new GraphExtension.NoOpExtension()).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
         na.setNode(0, 51.1, 12.001, 50);
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 3368bc9805..1d70727f8f 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -80,6 +80,11 @@ public void testAccess()
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
         assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+        
+        way.clearTags();
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "service");
@@ -495,10 +500,10 @@ public void testMaxValue()
     public void testRegisterOnlyOnceAllowed()
     {
         CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
-        EncodingManager em = new EncodingManager(instance);
+        EncodingManager tmpEM = new EncodingManager(instance);
         try
         {
-            em = new EncodingManager(instance);
+            tmpEM = new EncodingManager(instance);
             assertTrue(false);
         } catch (IllegalStateException ex)
         {
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index 11464b6731..4f8d2cfaf3 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -45,24 +45,22 @@ public void testMinWeightHasSameUnitAs_getWeight()
     public void testWeightWrongHeading()
     {
         FastestWeighting instance = new FastestWeighting(encoder, new PMap().put("heading_penalty", "100"));
-
         VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
                 encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
         double time = instance.calcWeight(virtEdge, false, 0);
 
-        virtEdge.setVirtualEdgePreference(true, false);
+        virtEdge.setVirtualEdgePreference(true);
         // heading penalty on edge
         assertEquals(time + 100, instance.calcWeight(virtEdge, false, 0), 1e-8);
-        // but not in reverse heading
-        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
         // only after setting it
-        virtEdge.setVirtualEdgePreference(true, true);
+        virtEdge.setVirtualEdgePreference(true);
         assertEquals(time + 100, instance.calcWeight(virtEdge, true, 0), 1e-8);
         // but not after releasing it
-        virtEdge.setVirtualEdgePreference(false, true);
+        virtEdge.setVirtualEdgePreference(false);
         assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
-
+        
         // test default penalty
+        virtEdge.setVirtualEdgePreference(true);
         instance = new FastestWeighting(encoder);
         assertEquals(time + FastestWeighting.DEFAULT_HEADING_PENALTY, instance.calcWeight(virtEdge, false, 0), 1e-8);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index bf68dea26c..fb3e38cdff 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -202,6 +202,9 @@ public void testPriority()
         way.setTag("highway", "cycleway");
         assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
 
+        way.setTag("highway", "primary");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+
         way.setTag("highway", "track");
         way.setTag("bicycle", "official");
         assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
@@ -209,6 +212,32 @@ public void testPriority()
         way.setTag("highway", "track");
         way.setTag("bicycle", "designated");
         assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "cycleway");
+        way.setTag("bicycle", "designated");
+        way.setTag("foot", "designated");
+        assertEquals(PriorityCode.PREFER.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("sidewalk", "yes");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.clearTags();
+        way.setTag("highway", "cycleway");
+        way.setTag("sidewalk", "no");
+        assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.clearTags();
+        way.setTag("highway", "road");
+        way.setTag("bicycle", "official");
+        way.setTag("sidewalk", "no");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+        
+        way.clearTags();
+        way.setTag("highway", "residential");        
+        way.setTag("sidewalk", "yes");
+        assertEquals(PriorityCode.PREFER.getValue(), footEncoder.handlePriority(way, 0));                
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 81d5862083..aad3dcc96a 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -17,16 +17,19 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.util.PrepareRoutingSubnetworks.PrepEdgeFilter;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
 
 import gnu.trove.list.array.TIntArrayList;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 
 import org.junit.*;
 
@@ -37,16 +40,17 @@
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("car");
+    private final FlagEncoder carFlagEncoder = new CarFlagEncoder();
+    private final EncodingManager em = new EncodingManager(carFlagEncoder);
 
-    GraphStorage createGraph( EncodingManager eman )
+    GraphHopperStorage createStorage( EncodingManager eman )
     {
         return new GraphBuilder(eman).create();
     }
 
-    GraphStorage createSubnetworkTestGraph()
+    GraphHopperStorage createSubnetworkTestStorage()
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         // big network
         g.edge(1, 2, 1, true);
         g.edge(1, 4, 1, false);
@@ -72,40 +76,9 @@ GraphStorage createSubnetworkTestGraph()
         return g;
     }
 
-    @Test
-    public void testFindSubnetworks()
-    {
-        GraphStorage g = createSubnetworkTestGraph();
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
-        Map<Integer, Integer> map = instance.findSubnetworks();
-
-        assertEquals(3, map.size());
-        // start is at 0 => large network
-        assertEquals(5, (int) map.get(0));
-        // next smallest and unvisited node is 1 => big network
-        assertEquals(8, (int) map.get(1));
-        assertEquals(3, (int) map.get(6));
-    }
-
-    @Test
-    public void testKeepLargestNetworks()
-    {
-        GraphStorage g = createSubnetworkTestGraph();
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
-        Map<Integer, Integer> map = instance.findSubnetworks();
-        instance.keepLargeNetworks(map);
-        g.optimize();
-
-        assertEquals(8, g.getNodes());
-        assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
-        map = instance.findSubnetworks();
-        assertEquals(1, map.size());
-        assertEquals(8, (int) map.get(0));
-    }
-
-    GraphStorage createSubnetworkTestGraph2( EncodingManager em )
+    GraphHopperStorage createSubnetworkTestStorage2( EncodingManager em )
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         // large network
         g.edge(0, 1, 1, true);
         g.edge(1, 3, 1, true);
@@ -124,11 +97,48 @@ GraphStorage createSubnetworkTestGraph2( EncodingManager em )
         return g;
     }
 
+    @Test
+    public void testFindSubnetworks()
+    {
+        GraphHopperStorage g = createSubnetworkTestStorage();
+        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singleton(carFlagEncoder));
+        List<TIntArrayList> components = instance.findSubnetworks(filter);
+
+        assertEquals(3, components.size());
+
+        // start is at 0 => large network
+        assertEquals(Helper.createTList(0, 7, 3, 13, 5), components.get(0));
+        // next smallest and unvisited node is 1 => big network
+        assertEquals(Helper.createTList(1, 8, 4, 2, 11, 12, 9, 15), components.get(1));
+        assertEquals(Helper.createTList(6, 14, 10), components.get(2));
+    }
+
+    @Test
+    public void testKeepLargestNetworks()
+    {
+        GraphHopperStorage g = createSubnetworkTestStorage();
+        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singleton(carFlagEncoder));
+        List<TIntArrayList> components = instance.findSubnetworks(filter);
+        assertEquals(3, components.size());
+        int removedEdges = instance.keepLargeNetworks(filter, components);
+        assertEquals(8, removedEdges);
+        instance.markNodesRemovedIfUnreachable();
+        g.optimize();
+
+        assertEquals(8, g.getNodes());
+        assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
+
+        components = instance.findSubnetworks(filter);
+        assertEquals(1, components.size());
+    }
+
     @Test
     public void testRemoveSubnetworkIfOnlyOneVehicle()
     {
-        GraphStorage g = createSubnetworkTestGraph2(em);
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
+        GraphHopperStorage g = createSubnetworkTestStorage2(em);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em.fetchEdgeEncoders());
         instance.setMinNetworkSize(4);
         instance.doWork();
         g.optimize();
@@ -138,26 +148,73 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         assertEquals(GHUtility.asSet(2, 1, 5), GHUtility.getNeighbors(explorer.setBaseNode(3)));
 
         // do not remove because small network is big enough
-        g = createSubnetworkTestGraph2(em);
-        instance = new PrepareRoutingSubnetworks(g, em);
+        g = createSubnetworkTestStorage2(em);
+        instance = new PrepareRoutingSubnetworks(g, em.fetchEdgeEncoders());
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
         assertEquals(9, g.getNodes());
+    }
 
-        // do not remove because two two vehicles
-        EncodingManager em2 = new EncodingManager("CAR,BIKE");
-        g = createSubnetworkTestGraph2(em2);
-        instance = new PrepareRoutingSubnetworks(g, em2);
-        instance.setMinNetworkSize(3);
+    @Test
+    public void testRemoveNode()
+    {
+        FlagEncoder carEncoder = new CarFlagEncoder();
+        BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
+        EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
+        GraphHopperStorage g = createSubnetworkTestStorage2(em2);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
+
+        EdgeExplorer edgeExplorer = g.createEdgeExplorer();
+        assertFalse(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 4));
+        assertFalse(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 5));
+        assertFalse(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 6));
+
+        // mark certain edges inaccessible for all encoders
+        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(g, 5, 6), GHUtility.getEdge(g, 4, 5), GHUtility.getEdge(g, 4, 6)))
+        {
+            for (FlagEncoder encoders : em2.fetchEdgeEncoders())
+            {
+                edge.setFlags(encoders.setAccess(0, false, false));
+            }
+        }
+
+        assertTrue(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 4));
+        assertTrue(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 5));
+        assertTrue(instance.detectNodeRemovedForAllEncoders(edgeExplorer, 6));
+    }
+
+    @Test
+    public void testRemoveSubnetworkWhenMultipleVehicles()
+    {
+        FlagEncoder carEncoder = new CarFlagEncoder();
+        BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
+        EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
+        GraphHopperStorage g = createSubnetworkTestStorage2(em2);
+        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false) | bikeEncoder.setProperties(5, true, true));
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
+        instance.setMinNetworkSize(5);
         instance.doWork();
         g.optimize();
+        // remove nothing because of two vehicles with different subnetworks
         assertEquals(9, g.getNodes());
+
+        EdgeExplorer carExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(carEncoder));
+        assertEquals(GHUtility.asSet(7, 2, 1), GHUtility.getNeighbors(carExplorer.setBaseNode(3)));
+        EdgeExplorer bikeExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(bikeEncoder));
+        assertEquals(GHUtility.asSet(7, 2, 1, 4), GHUtility.getNeighbors(bikeExplorer.setBaseNode(3)));
+        
+        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false) | bikeEncoder.setProperties(5, false, false));
+        instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
+        instance.setMinNetworkSize(5);
+        instance.doWork();
+        g.optimize();
+        assertEquals(6, g.getNodes());
     }
 
-    GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
+    GraphHopperStorage createDeadEndUnvisitedNetworkStorage( EncodingManager em )
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
         g.edge(0, 1, 1, true);
         g.edge(1, 2, 1, true);
@@ -174,9 +231,9 @@ GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
         return g;
     }
 
-    GraphStorage createTarjanTestGraph()
+    GraphHopperStorage createTarjanTestStorage()
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
 
         g.edge(1, 2, 1, false);
         g.edge(2, 3, 1, false);
@@ -200,27 +257,27 @@ GraphStorage createTarjanTestGraph()
     @Test
     public void testRemoveDeadEndUnvisitedNetworks()
     {
-        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        GraphHopperStorage g = createDeadEndUnvisitedNetworkStorage(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singleton(carFlagEncoder)).
                 setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
+        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
 
         assertEquals(3, removed);
-
+        instance.markNodesRemovedIfUnreachable();
         g.optimize();
+
         assertEquals(8, g.getNodes());
     }
 
     @Test
     public void testTarjan()
     {
-        GraphStorage g = createSubnetworkTestGraph();
+        GraphHopperStorage g = createSubnetworkTestStorage();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getEncoder("car");
-        final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
+        final EdgeFilter filter = new DefaultEdgeFilter(carFlagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
 
@@ -250,13 +307,41 @@ public void testTarjan()
     public void testNodeOrderingRegression()
     {
         // 1 -> 2 -> 0
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singleton(carFlagEncoder)).
                 setMinOneWayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
+        int removedEdges = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        assertEquals(2, removedEdges);
+    }
 
-        assertEquals(3, removed);
+    @Test
+    public void test481()
+    {
+        // 0->1->3->4->5->6
+        //  2        7<--/
+        GraphHopperStorage g = createStorage(em);
+        g.edge(0, 1, 1, false);
+        g.edge(1, 2, 1, false);
+        g.edge(2, 0, 1, false);
+
+        g.edge(1, 3, 1, false);
+        g.edge(3, 4, 1, false);
+
+        g.edge(4, 5, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 7, 1, false);
+        g.edge(7, 4, 1, false);
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singleton(carFlagEncoder)).
+                setMinOneWayNetworkSize(2).
+                setMinNetworkSize(4);
+        instance.doWork();
+
+        // only one remaining network
+        List<TIntArrayList> components = instance.findSubnetworks(new PrepEdgeFilter(carFlagEncoder));
+        assertEquals(1, components.size());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index a49cc8c096..1da02770cd 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -37,7 +37,7 @@
 /**
  * Abstract test class to be extended for implementations of the Graph interface. Graphs
  * implementing GraphStorage should extend GraphStorageTest instead.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public abstract class AbstractGraphStorageTester
@@ -53,22 +53,22 @@
     EdgeExplorer carOutExplorer;
     EdgeExplorer carInExplorer;
     EdgeExplorer carAllExplorer;
-    protected GraphStorage graph;
+    protected GraphHopperStorage graph;
 
-    protected GraphStorage createGraph()
+    protected GraphHopperStorage createGHStorage()
     {
-        GraphStorage g = createGraph(defaultGraphLoc, false);
+        GraphHopperStorage g = createGHStorage(defaultGraphLoc, false);
         carOutExplorer = g.createEdgeExplorer(carOutFilter);
         carInExplorer = g.createEdgeExplorer(carInFilter);
         carAllExplorer = g.createEdgeExplorer();
         return g;
     }
 
-    abstract GraphStorage createGraph( String location, boolean is3D );
+    abstract GraphHopperStorage createGHStorage( String location, boolean is3D );
 
-    protected GraphStorage newRAMGraph()
+    protected final GraphHopperStorage newRAMGHStorage()
     {
-        return new GraphHopperStorage(new RAMDirectory(), encodingManager, false);
+        return new GraphHopperStorage(new RAMDirectory(), encodingManager, false, new GraphExtension.NoOpExtension());
     }
 
     @Before
@@ -87,7 +87,7 @@ public void tearDown()
     @Test
     public void testInfinityWeight()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState edge = graph.edge(0, 1);
         edge.setDistance(Double.POSITIVE_INFINITY);
         assertTrue(Double.isInfinite(edge.getDistance()));
@@ -96,7 +96,7 @@ public void testInfinityWeight()
     @Test
     public void testSetNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         for (int i = 0; i < defaultSize * 2; i++)
         {
@@ -110,7 +110,7 @@ public void testSetNodes()
     @Test
     public void testPropertiesWithNoInit()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         assertEquals(0, graph.edge(0, 1).getFlags());
         assertEquals(0, graph.edge(0, 2).getDistance(), 1e-6);
     }
@@ -118,7 +118,7 @@ public void testPropertiesWithNoInit()
     @Test
     public void testCreateLocation()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(3, 1, 50, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(1)));
 
@@ -129,7 +129,7 @@ public void testCreateLocation()
     @Test
     public void testEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(2)));
 
@@ -142,7 +142,7 @@ public void testEdges()
     @Test
     public void testUnidirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(1, 11, 12, false);
@@ -176,7 +176,7 @@ public void testUnidirectional()
     @Test
     public void testUnidirectionalEdgeFilter()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(1, 11, 12, false);
@@ -212,7 +212,7 @@ public void testUnidirectionalEdgeFilter()
     @Test
     public void testUpdateUnidirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(3, 2, 112, false);
@@ -236,7 +236,7 @@ public void testUpdateUnidirectional()
     @Test
     public void testClone()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 10, true);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
@@ -245,19 +245,19 @@ public void testClone()
         na.setNode(3, 5, 9);
         graph.edge(1, 3, 10, true);
 
-        Graph clone = graph.copyTo(createGraph(locationParent + "/clone", false));
-        assertEquals(graph.getNodes(), clone.getNodes());
-        assertEquals(count(carOutExplorer.setBaseNode(1)), count(clone.createEdgeExplorer(carOutFilter).setBaseNode(1)));
-        clone.edge(1, 4, 10, true);
-        assertEquals(3, count(clone.createEdgeExplorer(carOutFilter).setBaseNode(1)));
-        assertEquals(graph.getBounds(), clone.getBounds());
-        Helper.close((Closeable) clone);
+        Graph cloneGraph = graph.copyTo(AbstractGraphStorageTester.this.createGHStorage(locationParent + "/clone", false));
+        assertEquals(graph.getNodes(), cloneGraph.getNodes());
+        assertEquals(count(carOutExplorer.setBaseNode(1)), count(cloneGraph.createEdgeExplorer(carOutFilter).setBaseNode(1)));
+        cloneGraph.edge(1, 4, 10, true);
+        assertEquals(3, count(cloneGraph.createEdgeExplorer(carOutFilter).setBaseNode(1)));
+        assertEquals(graph.getBounds(), cloneGraph.getBounds());
+        Helper.close((Closeable) cloneGraph);
     }
 
     @Test
     public void testCopyProperties()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState edge = graph.edge(1, 3, 10, false).setName("testing").setWayGeometry(Helper.createPointList(1, 2));
 
         EdgeIteratorState newEdge = graph.edge(1, 3, 10, false);
@@ -271,7 +271,7 @@ public void testCopyProperties()
     @Test
     public void testGetLocations()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 22, 23);
@@ -284,16 +284,16 @@ public void testGetLocations()
         assertEquals(3, graph.getNodes());
         Helper.close((Closeable) graph);
 
-        graph = createGraph();
+        graph = createGHStorage();
         assertEquals(0, graph.getNodes());
     }
 
     @Test
     public void testCopyTo()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         initExampleGraph(graph);
-        GraphStorage gs = newRAMGraph();
+        GraphHopperStorage gs = newRAMGHStorage();
         gs.setSegmentSize(8000);
         gs.create(10);
         try
@@ -309,7 +309,7 @@ public void testCopyTo()
         try
         {
             Helper.close((Closeable) graph);
-            graph = createGraph();
+            graph = createGHStorage();
             gs.copyTo(graph);
             checkExampleGraph(graph);
         } catch (Exception ex)
@@ -323,7 +323,7 @@ public void testCopyTo()
     @Test
     public void testAddLocation()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         initExampleGraph(graph);
         checkExampleGraph(graph);
     }
@@ -374,7 +374,7 @@ private void checkExampleGraph( Graph graph )
     @Test
     public void testDirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         graph.edge(2, 3, 12, false);
         graph.edge(3, 4, 12, false);
@@ -405,7 +405,7 @@ public void testDirectional()
     @Test
     public void testDozendEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         assertEquals(1, count(carAllExplorer.setBaseNode(1)));
 
@@ -438,7 +438,7 @@ public void testDozendEdges()
     @Test
     public void testCheckFirstNode()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         assertEquals(0, count(carAllExplorer.setBaseNode(1)));
         graph.edge(0, 1, 12, true);
@@ -448,7 +448,7 @@ public void testCheckFirstNode()
     @Test
     public void testDeleteNodeForUnidir()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(10, 10, 1);
         na.setNode(6, 6, 1);
@@ -491,7 +491,7 @@ public void testComplexDeleteNode2()
 
     public void testDeleteNodes( int fillToSize )
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 38.33f, 135.3f);
@@ -563,7 +563,7 @@ public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
     @Test
     public void testSimpleDelete()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 38.33f, 135.3f);
@@ -594,7 +594,7 @@ public void testSimpleDelete()
     @Test
     public void testSimpleDelete2()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         assertEquals(-1, getIdOf(graph, 12));
         na.setNode(9, 9, 1);
@@ -643,7 +643,7 @@ public void testSimpleDelete2()
     @Test
     public void testSimpleDelete3()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(7, 7, 1);
         na.setNode(8, 8, 1);
@@ -675,7 +675,7 @@ public void testSimpleDelete3()
     @Test
     public void testDeleteAndOptimize()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(20, 10, 10);
         na.setNode(21, 10, 11);
@@ -687,7 +687,7 @@ public void testDeleteAndOptimize()
     @Test
     public void testBounds()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         BBox b = graph.getBounds();
         assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
@@ -706,7 +706,7 @@ public void testBounds()
     @Test
     public void testFlags()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(carEncoder.setProperties(100, true, true));
         graph.edge(2, 3).setDistance(10).setFlags(carEncoder.setProperties(10, true, false));
 
@@ -730,30 +730,30 @@ public void testFlags()
     @Test
     public void testEdgeProperties()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(0, 2, 20, true);
 
         int edgeId = iter1.getEdge();
-        EdgeIteratorState iter = graph.getEdgeProps(edgeId, 0);
+        EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, 0);
         assertEquals(10, iter.getDistance(), 1e-5);
 
         edgeId = iter2.getEdge();
-        iter = graph.getEdgeProps(edgeId, 0);
+        iter = graph.getEdgeIteratorState(edgeId, 0);
         assertEquals(2, iter.getBaseNode());
         assertEquals(0, iter.getAdjNode());
         assertEquals(20, iter.getDistance(), 1e-5);
 
-        iter = graph.getEdgeProps(edgeId, 2);
+        iter = graph.getEdgeIteratorState(edgeId, 2);
         assertEquals(0, iter.getBaseNode());
         assertEquals(2, iter.getAdjNode());
         assertEquals(20, iter.getDistance(), 1e-5);
 
-        iter = graph.getEdgeProps(edgeId, Integer.MIN_VALUE);
+        iter = graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE);
         assertFalse(iter == null);
         assertEquals(0, iter.getBaseNode());
         assertEquals(2, iter.getAdjNode());
-        iter = graph.getEdgeProps(edgeId, 1);
+        iter = graph.getEdgeIteratorState(edgeId, 1);
         assertTrue(iter == null);
 
         // delete
@@ -763,7 +763,7 @@ public void testEdgeProperties()
         // throw exception if accessing deleted edge
         try
         {
-            graph.getEdgeProps(iter1.getEdge(), -1);
+            graph.getEdgeIteratorState(iter1.getEdge(), -1);
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -773,26 +773,26 @@ public void testEdgeProperties()
     @Test
     public void testCreateDuplicateEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         graph.edge(2, 3, 12, true);
         graph.edge(2, 3, 13, false);
         assertEquals(3, GHUtility.count(carOutExplorer.setBaseNode(2)));
 
         // no exception        
-        graph.getEdgeProps(1, 3);
+        graph.getEdgeIteratorState(1, 3);
 
         // raise exception
         try
         {
-            graph.getEdgeProps(4, 3);
+            graph.getEdgeIteratorState(4, 3);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
         try
         {
-            graph.getEdgeProps(-1, 3);
+            graph.getEdgeIteratorState(-1, 3);
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -800,13 +800,13 @@ public void testCreateDuplicateEdges()
 
         EdgeIterator iter = carOutExplorer.setBaseNode(2);
         assertTrue(iter.next());
-        EdgeIteratorState oneIter = graph.getEdgeProps(iter.getEdge(), 3);
+        EdgeIteratorState oneIter = graph.getEdgeIteratorState(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
         assertTrue(carEncoder.isForward(oneIter.getFlags()));
         assertFalse(carEncoder.isBackward(oneIter.getFlags()));
 
-        oneIter = graph.getEdgeProps(iter.getEdge(), 2);
+        oneIter = graph.getEdgeIteratorState(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
         assertFalse(carEncoder.isForward(oneIter.getFlags()));
@@ -819,7 +819,7 @@ public void testCreateDuplicateEdges()
     @Test
     public void testIdenticalNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 0, 100, true);
         assertEquals(1, GHUtility.count(carAllExplorer.setBaseNode(0)));
     }
@@ -827,7 +827,7 @@ public void testIdenticalNodes()
     @Test
     public void testIdenticalNodes2()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 0, 100, false);
         graph.edge(0, 0, 100, false);
         assertEquals(2, GHUtility.count(carAllExplorer.setBaseNode(0)));
@@ -836,7 +836,7 @@ public void testIdenticalNodes2()
     @Test
     public void testEdgeReturn()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter = graph.edge(4, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false));
         assertEquals(4, iter.getBaseNode());
         assertEquals(10, iter.getAdjNode());
@@ -848,7 +848,7 @@ public void testEdgeReturn()
     @Test
     public void testPillarNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.01, 0.01);
         na.setNode(4, 0.4, 0.4);
@@ -898,7 +898,7 @@ public void testPillarNodes()
     @Test
     public void testFootMix()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         graph.edge(0, 2).setDistance(10).setFlags(carEncoder.setProperties(10, true, true));
         graph.edge(0, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true) | carEncoder.setProperties(10, true, true));
@@ -910,7 +910,7 @@ public void testFootMix()
     @Test
     public void testGetAllEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         graph.edge(3, 1, 1, false);
         graph.edge(3, 2, 1, false);
@@ -938,7 +938,7 @@ public void testGetAllEdges()
     @Test
     public void testGetAllEdgesWithDelete()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0, 5);
         na.setNode(1, 1, 5);
@@ -950,26 +950,26 @@ public void testGetAllEdgesWithDelete()
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getCount());
+        assertEquals(4, iter.getMaxId());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getCount());
+        assertEquals(4, iter.getMaxId());
 
         iter = graph.getAllEdges();
-        iter.next();
+        assertTrue(iter.next());
         EdgeIteratorState eState = iter.detach(false);
         assertEquals(iter.toString(), eState.toString());
-        iter.next();
+        assertTrue(iter.next());
         assertNotEquals(iter.toString(), eState.toString());
 
         EdgeIteratorState eState2 = iter.detach(true);
         assertEquals(iter.getAdjNode(), eState2.getBaseNode());
-        iter.next();
-        assertNotEquals(iter.getAdjNode(), eState2.getBaseNode());
+        assertEquals(iter.getBaseNode(), eState2.getAdjNode());
+        assertFalse(iter.next());
     }
 
     public static void assertPList( PointList expected, PointList list )
@@ -1013,15 +1013,15 @@ public static int getIdOf( Graph g, double latitude, double longitude )
     @Test
     public void testNameIndex()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         iter1.setName("named street1");
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 10, true);
         iter2.setName("named street2");
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
     }
 
     @Test
@@ -1032,7 +1032,7 @@ public void test8BytesFlags()
         list.add(new TmpCarFlagEncoder(29, 0.001, 0));
         list.add(new TmpCarFlagEncoder(29, 0.001, 0));
         EncodingManager manager = new EncodingManager(list, 8);
-        graph = new GraphHopperStorage(dir, manager, false).create(defaultSize);
+        graph = new GraphHopperStorage(dir, manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
 
         EdgeIteratorState edge = graph.edge(0, 1);
         edge.setFlags(Long.MAX_VALUE / 3);
@@ -1040,30 +1040,32 @@ public void test8BytesFlags()
         assertEquals(Long.MAX_VALUE / 3, edge.getFlags());
         graph.close();
 
-        graph = new GraphHopperStorage(dir, manager, false).create(defaultSize);
+        graph = new GraphHopperStorage(dir, manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
 
         edge = graph.edge(0, 1);
         edge.setFlags(list.get(0).setProperties(99.123, true, true));
         assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
-        long flags = GHUtility.getEdge(graph, 1, 0).getFlags();
+        EdgeIteratorState edgeIter = GHUtility.getEdge(graph, 1, 0);
+        long flags = edgeIter.getFlags();
         assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
-        assertTrue(list.get(0).isForward(flags));
-        assertTrue(list.get(0).isBackward(flags));
+        assertTrue(edgeIter.isForward(list.get(0)));
+        assertTrue(edgeIter.isBackward(list.get(0)));
         edge = graph.edge(2, 3);
         edge.setFlags(list.get(1).setProperties(44.123, true, false));
         assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
 
-        flags = GHUtility.getEdge(graph, 3, 2).getFlags();
+        edgeIter = GHUtility.getEdge(graph, 3, 2);
+        flags = edgeIter.getFlags();
         assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
         assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
-        assertFalse(list.get(1).isForward(flags));
-        assertTrue(list.get(1).isBackward(flags));
+        assertFalse(edgeIter.isForward(list.get(1)));
+        assertTrue(edgeIter.isBackward(list.get(1)));
     }
 
     @Test
     public void testEnabledElevation()
     {
-        graph = createGraph(defaultGraphLoc, true);
+        graph = createGHStorage(defaultGraphLoc, true);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 20, -10);
@@ -1080,7 +1082,7 @@ public void testEnabledElevation()
     @Test
     public void testDetachEdge()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         long flags = carEncoder.setProperties(10, true, false);
         graph.edge(0, 2, 2, true).setWayGeometry(Helper.createPointList(1, 2, 3, 4)).setFlags(flags);
@@ -1097,35 +1099,37 @@ public void testDetachEdge()
         }
 
         iter.next();
-        EdgeIteratorState edgeState2 = iter.detach(false);
+        EdgeIteratorState edgeState02 = iter.detach(false);
         assertEquals(2, iter.getAdjNode());
-        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertEquals(2, edgeState2.getAdjNode());
-        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
-
-        EdgeIteratorState edgeState3 = iter.detach(true);
-        assertEquals(0, edgeState3.getAdjNode());
-        assertEquals(2, edgeState3.getBaseNode());
-        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
-        assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
-        assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
+        assertEquals(1, edgeState02.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(2, edgeState02.getAdjNode());
+        assertTrue(carEncoder.isForward(edgeState02.getFlags()));
+
+        EdgeIteratorState edgeState20 = iter.detach(true);
+        assertEquals(0, edgeState20.getAdjNode());
+        assertEquals(2, edgeState20.getBaseNode());
+        assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertFalse(carEncoder.isForward(edgeState20.getFlags()));
+        assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState02.getFlags());
+        assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState20.getFlags());
 
         iter.next();
         assertEquals(1, iter.getAdjNode());
-        assertEquals(2, edgeState2.getAdjNode());
-        assertEquals(2, edgeState3.getBaseNode());
+        assertEquals(2, edgeState02.getAdjNode());
+        assertEquals(2, edgeState20.getBaseNode());
 
         assertEquals(0, iter.fetchWayGeometry(0).size());
-        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(1, edgeState02.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
 
         // #162 a directed self referencing edge should be able to reverse its state too
         graph.edge(3, 3, 2, true).setFlags(flags);
-        EdgeIterator iter2 = graph.createEdgeExplorer().setBaseNode(3);
-        iter2.next();
-        assertEquals(edgeState2.getFlags(), iter2.detach(false).getFlags());
-        assertEquals(edgeState3.getFlags(), iter2.detach(true).getFlags());
+        EdgeIterator edgeState33 = graph.createEdgeExplorer().setBaseNode(3);
+        edgeState33.next();
+        assertEquals(3, edgeState33.getBaseNode());
+        assertEquals(3, edgeState33.getAdjNode());
+        assertEquals(edgeState02.getFlags(), edgeState33.detach(false).getFlags());
+        assertEquals(edgeState20.getFlags(), edgeState33.detach(true).getFlags());
     }
 
     static class TmpCarFlagEncoder extends CarFlagEncoder
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
new file mode 100644
index 0000000000..5e979b8f5e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -0,0 +1,406 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperStorageCHTest extends GraphHopperStorageTest
+{
+    protected CHGraph getGraph( GraphHopperStorage ghStorage )
+    {
+        return ghStorage.getGraph(CHGraph.class);
+    }
+
+    @Override
+    public GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
+    {
+        return new GraphHopperStorage(Arrays.asList(new FastestWeighting(carEncoder)), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
+    }
+
+    @Test
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
+    {
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph.flush();
+        graph.close();
+
+        graph = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
+        try
+        {
+            graph.loadExisting();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
+        assertTrue(graph.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(graph.getBounds(), BBox.createInverse(false));
+    }
+
+    @Test
+    public void testPrios()
+    {
+        graph = createGHStorage();
+        CHGraph g = getGraph(graph);
+        g.getNodeAccess().ensureNode(30);
+        graph.freeze();
+
+        assertEquals(0, g.getLevel(10));
+
+        g.setLevel(10, 100);
+        assertEquals(100, g.getLevel(10));
+
+        g.setLevel(30, 100);
+        assertEquals(100, g.getLevel(30));
+    }
+
+    @Test
+    public void testEdgeFilter()
+    {
+        graph = createGHStorage();
+        CHGraph g = getGraph(graph);
+        g.edge(0, 1, 10, true);
+        g.edge(0, 2, 20, true);
+        g.edge(2, 3, 30, true);
+        g.edge(10, 11, 1, true);
+
+        graph.freeze();
+        CHEdgeIteratorState tmpIter = g.shortcut(3, 4);
+        tmpIter.setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
+        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
+
+        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        g.setLevel(0, 1);
+        g.setLevel(4, 1);
+
+        EdgeIterator iter = g.createEdgeExplorer(new LevelEdgeFilter(g)).setBaseNode(0);
+        assertEquals(1, GHUtility.count(iter));
+        iter = g.createEdgeExplorer().setBaseNode(2);
+        assertEquals(2, GHUtility.count(iter));
+
+        tmpIter = g.shortcut(5, 6);
+        tmpIter.setSkippedEdges(1, 2);
+        assertEquals(1, tmpIter.getSkippedEdge1());
+        assertEquals(2, tmpIter.getSkippedEdge2());
+    }
+
+    @Test
+    public void testDisconnectEdge()
+    {
+        graph = createGHStorage();
+        CHGraphImpl lg = (CHGraphImpl) getGraph(graph);
+
+        EdgeExplorer chCarOutExplorer = lg.createEdgeExplorer(carOutFilter);
+        EdgeExplorer tmpCarInExplorer = lg.createEdgeExplorer(carInFilter);
+
+        EdgeExplorer baseCarOutExplorer = graph.createEdgeExplorer(carOutFilter);
+
+        // only remove edges
+        long flags = carEncoder.setProperties(60, true, true);
+        long flags2 = carEncoder.setProperties(60, true, false);
+        lg.edge(4, 1, 30, true);
+        graph.freeze();
+        CHEdgeIteratorState tmp = lg.shortcut(1, 2);
+        tmp.setDistance(10).setFlags(flags);
+        tmp.setSkippedEdges(10, 11);
+        tmp = lg.shortcut(1, 0);
+        tmp.setDistance(20).setFlags(flags2);
+        tmp.setSkippedEdges(12, 13);
+        tmp = lg.shortcut(3, 1);
+        tmp.setDistance(30).setFlags(flags2);
+        tmp.setSkippedEdges(14, 15);
+        // create everytime a new independent iterator for disconnect method
+        EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(1);
+        iter.next();
+        assertEquals(3, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(chCarOutExplorer.setBaseNode(3)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(chCarOutExplorer.setBaseNode(3)));
+        // no shortcuts visible
+        assertEquals(0, GHUtility.count(baseCarOutExplorer.setBaseNode(3)));
+
+        // even directed ways change!
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(tmpCarInExplorer.setBaseNode(0)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(tmpCarInExplorer.setBaseNode(0)));
+
+        iter.next();
+        assertEquals(2, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(chCarOutExplorer.setBaseNode(2)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(chCarOutExplorer.setBaseNode(2)));
+
+        assertEquals(GHUtility.asSet(0, 2, 4), GHUtility.getNeighbors(chCarOutExplorer.setBaseNode(1)));
+        assertEquals(GHUtility.asSet(4), GHUtility.getNeighbors(baseCarOutExplorer.setBaseNode(1)));
+    }
+
+    @Test
+    public void testGetWeight()
+    {
+        graph = createGHStorage();
+        CHGraphImpl g = (CHGraphImpl) getGraph(graph);
+        assertFalse(g.edge(0, 1).isShortcut());
+        assertFalse(g.edge(1, 2).isShortcut());
+
+        graph.freeze();
+
+        // only remove edges
+        long flags = carEncoder.setProperties(10, true, true);
+        CHEdgeIteratorState sc1 = g.shortcut(0, 1);
+        assertTrue(sc1.isShortcut());
+        sc1.setWeight(2.001);
+        assertEquals(2.001, sc1.getWeight(), 1e-3);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        sc1.setWeight(Double.MAX_VALUE);
+        assertTrue(Double.isInfinite(sc1.getWeight()));
+
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertTrue(sc1.isForward(carEncoder));
+        assertTrue(sc1.isBackward(carEncoder));
+
+        flags = carEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertFalse(sc1.isForward(carEncoder));
+        assertTrue(sc1.isBackward(carEncoder));
+    }
+
+    @Test
+    public void testGetWeightIfAdvancedEncoder()
+    {
+        FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
+        EncodingManager em = new EncodingManager(customEncoder);
+        FastestWeighting weighting = new FastestWeighting(customEncoder);
+        GraphHopperStorage ghStorage = new GraphBuilder(em).setCHGraph(weighting).create();
+        ghStorage.edge(0, 2);
+        ghStorage.freeze();
+
+        CHGraphImpl lg = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
+        CHEdgeIteratorState sc1 = lg.shortcut(0, 1);
+        long flags = customEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
+
+        sc1 = lg.shortcut(1, 0);
+        assertTrue(sc1.isShortcut());
+        sc1.setFlags(PrepareEncoder.getScDirMask());
+        sc1.setWeight(1.011011);
+        assertEquals(1.011011, sc1.getWeight(), 1e-3);
+    }
+
+    @Test
+    public void testQueryGraph()
+    {
+        graph = createGHStorage();
+        CHGraph chGraph = getGraph(graph);
+        NodeAccess na = chGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = chGraph.edge(0, 1);
+        chGraph.edge(1, 2);
+        graph.freeze();
+        chGraph.shortcut(0, 1);
+
+        QueryGraph qGraph = new QueryGraph(chGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph baseGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = baseGraph.createEdgeExplorer();
+
+        assertTrue(chGraph.getNodes() < qGraph.getNodes());
+        assertTrue(baseGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
+
+    @Test
+    @Override
+    public void testSave_and_Freeze() throws IOException
+    {
+        // belongs to each other
+        super.testSave_and_Freeze();
+        graph.close();
+
+        // test freeze and shortcut creation & loading
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).
+                create(defaultSize);
+        graph.edge(1, 0);
+        graph.edge(8, 9);
+        graph.freeze();
+        CHGraph chGraph = getGraph(graph);
+
+        assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(1)));
+
+        chGraph.shortcut(2, 3);
+
+        // should be identical to access without shortcut
+        assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(1)));
+
+        // base graph does not see shortcut        
+        assertEquals(0, GHUtility.count(graph.createEdgeExplorer().setBaseNode(2)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(2)));
+
+        graph.flush();
+        graph.close();
+
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
+        assertTrue(graph.loadExisting());
+        assertTrue(graph.isFrozen());
+
+        chGraph = getGraph(graph);
+        assertEquals(10, chGraph.getNodes());
+        assertEquals(2, graph.getAllEdges().getMaxId());
+        assertEquals(3, chGraph.getAllEdges().getMaxId());
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(2)));
+
+        AllCHEdgesIterator iter = chGraph.getAllEdges();
+        assertTrue(iter.next());
+        assertFalse(iter.isShortcut());
+        assertEquals(0, iter.getEdge());
+
+        assertTrue(iter.next());
+        assertFalse(iter.isShortcut());
+        assertEquals(1, iter.getEdge());
+
+        assertTrue(iter.next());
+        assertTrue(iter.isShortcut());
+        assertEquals(2, iter.getEdge());
+        assertFalse(iter.next());
+    }
+
+    @Test
+    public void testSimpleShortcutCreationAndTraversal()
+    {
+        graph = createGHStorage();
+        graph.edge(1, 3, 10, true);
+        graph.edge(3, 4, 10, true);
+        graph.freeze();
+
+        CHGraph lg = graph.getGraph(CHGraph.class);
+        lg.shortcut(1, 4).setWeight(3).setFlags(carEncoder.setProperties(10, true, true));
+
+        EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+        // iteration should result in same nodes even if reusing the iterator
+        assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
+        assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
+    }
+
+    @Test
+    public void testShortcutCreationAndAccessForManyVehicles()
+    {
+        FlagEncoder tmpCar = new CarFlagEncoder();
+        FlagEncoder tmpBike = new Bike2WeightFlagEncoder();
+        EncodingManager em = new EncodingManager(tmpCar, tmpBike);
+        List<Weighting> chWeightings = new ArrayList<Weighting>();
+        chWeightings.add(new FastestWeighting(tmpCar));
+        chWeightings.add(new FastestWeighting(tmpBike));
+
+        graph = new GraphHopperStorage(chWeightings, new RAMDirectory(), em, false, new GraphExtension.NoOpExtension()).create(1000);
+        graph.edge(0, 1).setDistance(10).setFlags(tmpCar.setProperties(100, true, true) | tmpBike.setProperties(10, true, true));
+        graph.edge(1, 2).setDistance(10).setFlags(tmpCar.setProperties(100, true, true) | tmpBike.setProperties(10, true, true));
+
+        graph.freeze();
+
+        CHGraph carCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(0));
+        // enable forward directions for car
+        EdgeIteratorState carSC02 = carCHGraph.shortcut(0, 2).setWeight(10).setFlags(PrepareEncoder.getScFwdDir()).setDistance(20);
+
+        CHGraph bikeCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(1));
+        // enable both directions for bike
+        EdgeIteratorState bikeSC02 = bikeCHGraph.shortcut(0, 2).setWeight(10).setFlags(PrepareEncoder.getScDirMask()).setDistance(20);
+
+        // assert car CH graph
+        assertTrue(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpCar));
+        assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isBackward(tmpCar));
+
+        // throw exception for wrong encoder
+        try
+        {
+            assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpBike));
+            assertTrue(false);
+        } catch (AssertionError ex)
+        {
+        }
+
+        // assert bike CH graph
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isForward(tmpBike));
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpBike));
+
+        // throw exception for wrong encoder
+        try
+        {
+            assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpCar));
+            assertTrue(false);
+        } catch (AssertionError ex)
+        {
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 31c0a284b3..0215149cd6 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -32,27 +32,27 @@
 public class GraphHopperStorageTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, boolean enabled3D )
+    public GraphHopperStorage createGHStorage( String location, boolean enabled3D )
     {
         // reduce segment size in order to test the case where multiple segments come into the game
-        GraphStorage gs = newGraph(new RAMDirectory(location), enabled3D);
+        GraphHopperStorage gs = newGHStorage(new RAMDirectory(location), enabled3D);
         gs.setSegmentSize(defaultSize / 2);
         gs.create(defaultSize);
         return gs;
     }
 
-    protected GraphStorage newGraph( Directory dir, boolean enabled3D )
+    protected GraphHopperStorage newGHStorage( Directory dir, boolean enabled3D )
     {
-        return new GraphHopperStorage(dir, encodingManager, enabled3D);
+        return new GraphHopperStorage(dir, encodingManager, enabled3D, new GraphExtension.NoOpExtension());
     }
 
     @Test
     public void testNoCreateCalled() throws IOException
     {
-        GraphHopperStorage gs = (GraphHopperStorage) new GraphBuilder(encodingManager).build();
+        GraphHopperStorage gs = new GraphBuilder(encodingManager).build();
         try
         {
-            gs.ensureNodeIndex(123);
+            ((BaseGraph) gs.getGraph(Graph.class)).ensureNodeIndex(123);
             assertFalse("AssertionError should be raised", true);
         } catch (AssertionError err)
         {
@@ -69,7 +69,7 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 10, 0);
@@ -91,18 +91,34 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
         checkGraph(graph);
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
         graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
+    @Test
+    public void testSave_and_Freeze() throws IOException
+    {
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph.edge(1, 0);
+        graph.freeze();
+
+        graph.flush();
+        graph.close();
+
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
+        assertTrue(graph.loadExisting());
+        assertEquals(2, graph.getNodes());
+        assertTrue(graph.isFrozen());
+    }
+
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
@@ -146,7 +162,8 @@ protected void checkGraph( Graph g )
     @Test
     public void internalDisconnect()
     {
-        GraphHopperStorage graph = (GraphHopperStorage) createGraph();
+        GraphHopperStorage storage = createGHStorage();
+        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
         EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(1, 2, 10, true);
         EdgeIteratorState iter3 = graph.edge(0, 3, 10, true);
@@ -156,25 +173,27 @@ public void internalDisconnect()
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(2, 0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         // remove edge "1-2" but only from 1 not from 2
-        graph.internalEdgeDisconnect(iter2.getEdge(), -1, iter2.getBaseNode(), iter2.getAdjNode());
+        graph.edgeAccess.internalEdgeDisconnect(iter2.getEdge(), -1,
+                iter2.getBaseNode(), iter2.getAdjNode());
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(1), GHUtility.getNeighbors(explorer.setBaseNode(2)));
         // let 0 unchanged -> no side effects
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
 
         // remove edge "0-1" but only from 0
-        graph.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes, iter0.getBaseNode(), iter0.getAdjNode());
+        graph.edgeAccess.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes,
+                iter0.getBaseNode(), iter0.getAdjNode());
         assertEquals(GHUtility.asSet(3), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(3)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
-        graph.close();
+        storage.close();
     }
 
     @Test
     public void testEnsureSize()
     {
         Directory dir = new RAMDirectory();
-        graph = newGraph(dir, false).create(defaultSize);
+        graph = newGHStorage(dir, false).create(defaultSize);
         int testIndex = dir.find("edges").getSegmentSize() * 3;
         graph.edge(0, testIndex, 10, true);
 
@@ -186,9 +205,9 @@ public void testEnsureSize()
     public void testBigDataEdge()
     {
         Directory dir = new RAMDirectory();
-        GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false);
+        GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(defaultSize);
-        graph.setEdgeCount(Integer.MAX_VALUE / 2);
+        ((BaseGraph) graph.getGraph(Graph.class)).setEdgeCount(Integer.MAX_VALUE / 2);
         assertTrue(graph.getAllEdges().next());
         graph.close();
     }
@@ -196,19 +215,113 @@ public void testBigDataEdge()
     @Test
     public void testDoThrowExceptionIfDimDoesNotMatch()
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
         graph.create(1000);
         graph.flush();
         graph.close();
 
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
         try
         {
             graph.loadExisting();
             assertTrue(false);
         } catch (Exception ex)
         {
-
         }
     }
+
+    @Test
+    public void testIdentical()
+    {
+        GraphHopperStorage store = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension());
+        assertEquals(store.getNodes(), store.getGraph(Graph.class).getNodes());
+        assertEquals(store.getAllEdges().getMaxId(), store.getGraph(Graph.class).getAllEdges().getMaxId());
+    }
+
+    public void testAdditionalEdgeField()
+    {
+        GraphExtension extStorage = new GraphExtension()
+        {
+            @Override
+            public boolean isRequireNodeField()
+            {
+                return false;
+            }
+
+            @Override
+            public boolean isRequireEdgeField()
+            {
+                return true;
+            }
+
+            @Override
+            public int getDefaultNodeFieldValue()
+            {
+                throw new UnsupportedOperationException("Not supported.");
+            }
+
+            @Override
+            public int getDefaultEdgeFieldValue()
+            {
+                return 2;
+            }
+
+            @Override
+            public void init( Graph graph, Directory dir )
+            {
+            }
+
+            @Override
+            public void setSegmentSize( int bytes )
+            {
+
+            }
+
+            @Override
+            public GraphExtension copyTo( GraphExtension extStorage )
+            {
+                return this;
+            }
+
+            @Override
+            public boolean loadExisting()
+            {
+                return true;
+            }
+
+            @Override
+            public GraphExtension create( long byteCount )
+            {
+                return this;
+            }
+
+            @Override
+            public void flush()
+            {
+            }
+
+            @Override
+            public void close()
+            {
+            }
+
+            @Override
+            public boolean isClosed()
+            {
+                return false;
+            }
+
+            @Override
+            public long getCapacity()
+            {
+                return 0;
+            }
+        };
+
+        GraphHopperStorage storage = new GraphHopperStorage(new RAMDirectory(), encodingManager, false, extStorage);
+        storage.create(1000);
+        EdgeIteratorState iter = storage.edge(0, 1, 10, true);
+
+        assertEquals(extStorage.getDefaultEdgeFieldValue(), iter.getAdditionalField());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index 5865ca16ac..ba39137a23 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -35,23 +35,17 @@
     private TurnCostExtension turnCostStorage;
 
     @Override
-    protected GraphStorage newGraph( Directory dir, boolean is3D )
+    protected GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
     {
         turnCostStorage = new TurnCostExtension();
         return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
-    @Override
-    protected GraphStorage newRAMGraph()
-    {
-        return newGraph(new RAMDirectory(), false);
-    }
-
     @Override
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 10, 0);
@@ -77,14 +71,14 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
         checkGraph(graph);
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
 
         assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
         assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
@@ -98,7 +92,7 @@ public void testSave_and_fileFormat() throws IOException
     @Test
     public void testEnsureCapacity() throws IOException
     {
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
index 3a69d6c9af..adf8352501 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
@@ -23,9 +23,9 @@
 public class GraphStorageViaMMapTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, boolean is3D )
+    public GraphHopperStorage createGHStorage( String location, boolean is3D )
     {
-        GraphStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
+        GraphHopperStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
         gs.setSegmentSize(defaultSize / 2);
         gs.create(defaultSize);
         return gs;
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
deleted file mode 100644
index e2b10885a4..0000000000
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.BBox;
-
-import static org.junit.Assert.*;
-
-import org.junit.Test;
-
-/**
- * @author Peter Karich
- */
-public class LevelGraphStorageTest extends GraphHopperStorageTest
-{
-    @Override
-    protected LevelGraphStorage createGraph()
-    {
-        return (LevelGraphStorage) super.createGraph();
-    }
-
-    @Override
-    public GraphStorage newGraph( Directory dir, boolean is3D )
-    {
-        return new LevelGraphStorage(dir, encodingManager, is3D);
-    }
-
-    @Test
-    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
-    {
-        GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
-        g.flush();
-        g.close();
-
-        g = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
-        try
-        {
-            g.loadExisting();
-            assertTrue(false);
-        } catch (Exception ex)
-        {
-        }
-
-        g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
-        assertTrue(g.loadExisting());
-        // empty graph still has invalid bounds
-        assertEquals(g.getBounds(), BBox.createInverse(false));
-    }
-
-    @Test
-    public void testPriosWhileDeleting()
-    {
-        LevelGraphStorage g = createGraph();
-        g.getNodeAccess().ensureNode(19);
-        for (int i = 0; i < 20; i++)
-        {
-            g.setLevel(i, i);
-        }
-        g.markNodeRemoved(10);
-        g.optimize();
-        assertEquals(9, g.getLevel(9));
-        assertNotSame(10, g.getLevel(10));
-    }
-
-    @Test
-    public void testPrios()
-    {
-        LevelGraph g = createGraph();
-        g.getNodeAccess().ensureNode(30);
-
-        assertEquals(0, g.getLevel(10));
-
-        g.setLevel(10, 100);
-        assertEquals(100, g.getLevel(10));
-
-        g.setLevel(30, 100);
-        assertEquals(100, g.getLevel(30));
-    }
-
-    @Test
-    public void testEdgeFilter()
-    {
-        LevelGraph g = createGraph();
-        g.edge(0, 1, 10, true);
-        g.edge(0, 2, 20, true);
-        g.edge(2, 3, 30, true);
-        EdgeSkipIterState tmpIter = g.shortcut(3, 4);
-        tmpIter.setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
-
-        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
-        g.setLevel(0, 1);
-        g.setLevel(4, 1);
-
-        EdgeIterator iter = g.createEdgeExplorer(new LevelEdgeFilter(g)).setBaseNode(0);
-        assertEquals(1, GHUtility.count(iter));
-        iter = g.createEdgeExplorer().setBaseNode(2);
-        assertEquals(2, GHUtility.count(iter));
-    }
-
-    @Test
-    public void testDisconnectEdge()
-    {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        // only remove edges
-        long flags = carEncoder.setProperties(60, true, true);
-        long flags2 = carEncoder.setProperties(60, true, false);
-        g.edge(4, 1, 30, true);
-        EdgeSkipIterState tmp = g.shortcut(1, 2);
-        tmp.setDistance(10).setFlags(flags);
-        tmp.setSkippedEdges(10, 11);
-        tmp = g.shortcut(1, 0);
-        tmp.setDistance(20).setFlags(flags2);
-        tmp.setSkippedEdges(12, 13);
-        tmp = g.shortcut(3, 1);
-        tmp.setDistance(30).setFlags(flags2);
-        tmp.setSkippedEdges(14, 15);
-        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(1);
-        iter.next();
-        assertEquals(3, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carOutExplorer.setBaseNode(3)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carOutExplorer.setBaseNode(3)));
-
-        // even directed ways change!
-        assertTrue(iter.next());
-        assertEquals(0, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carInExplorer.setBaseNode(0)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carInExplorer.setBaseNode(0)));
-
-        iter.next();
-        assertEquals(2, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carOutExplorer.setBaseNode(2)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carOutExplorer.setBaseNode(2)));
-    }
-
-    @Test
-    public void testGetWeight()
-    {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        assertFalse(g.edge(0, 1).isShortcut());
-        assertFalse(g.edge(1, 2).isShortcut());
-
-        // only remove edges
-        long flags = carEncoder.setProperties(10, true, true);
-        EdgeSkipIterState sc1 = g.shortcut(0, 1);
-        assertTrue(sc1.isShortcut());
-        sc1.setWeight(2.001);
-        assertEquals(2.001, sc1.getWeight(), 1e-3);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        sc1.setWeight(Double.MAX_VALUE);
-        assertTrue(Double.isInfinite(sc1.getWeight()));
-
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isForward(sc1.getFlags()));
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-
-        flags = carEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertFalse(carEncoder.isForward(sc1.getFlags()));
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-    }
-
-    @Test
-    public void testGetWeightIfAdvancedEncoder()
-    {
-        FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
-        LevelGraphStorage g = new GraphBuilder(new EncodingManager(customEncoder)).levelGraphCreate();
-
-        EdgeSkipIterState sc1 = g.shortcut(0, 1);
-        long flags = customEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-
-        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
-        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
-        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
-        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
-
-        sc1 = g.shortcut(1, 0);
-        assertTrue(sc1.isShortcut());
-        sc1.setFlags(PrepareEncoder.getScDirMask());
-        sc1.setWeight(1.011011);
-        assertEquals(1.011011, sc1.getWeight(), 1e-3);
-    }
-
-    @Test
-    public void testQueryGraph()
-    {
-        LevelGraph levelGraph = createGraph();
-        NodeAccess na = levelGraph.getNodeAccess();
-        na.setNode(0, 1.00, 1.00);
-        na.setNode(1, 1.02, 1.00);
-        na.setNode(2, 1.04, 1.00);
-
-        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
-        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
-        levelGraph.shortcut(0, 1);
-
-        QueryGraph qGraph = new QueryGraph(levelGraph);
-        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
-        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
-        qGraph.lookup(fromRes, toRes);
-
-        Graph oGraph = qGraph.getBaseGraph();
-        EdgeExplorer explorer = oGraph.createEdgeExplorer();
-
-        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
-        assertTrue(oGraph.getNodes() == qGraph.getNodes());
-
-        // traverse virtual edges and normal edges but no shortcuts!
-        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
-        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
-
-        // get neighbors from virtual nodes
-        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
-        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
-    }
-
-    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
-    {
-        QueryResult res = new QueryResult(lat, lon);
-        res.setClosestEdge(edge);
-        res.setWayIndex(wayIndex);
-        res.setSnappedPosition(QueryResult.Position.EDGE);
-        res.calcSnappedPoint(Helper.DIST_PLANE);
-        return res;
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index fa925c1504..4e5c817602 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -21,12 +21,7 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.MMapDirectory;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeIterator;
@@ -53,6 +48,16 @@
 
     public abstract LocationIndex createIndex( Graph g, int resolution );
 
+    GraphHopperStorage createGHStorage( EncodingManager encodingManager )
+    {
+        return AbstractLocationIndexTester.this.createGHStorage(new RAMDirectory(), encodingManager, false);
+    }
+
+    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
+    {
+        return new GraphHopperStorage(dir, encodingManager, is3D, new GraphExtension.NoOpExtension()).create(100);
+    }
+
     public boolean hasEdgeSupport()
     {
         return false;
@@ -75,7 +80,7 @@ public void tearDown()
     @Test
     public void testSimpleGraph()
     {
-        Graph g = createGraph(new EncodingManager("CAR"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -129,7 +134,7 @@ public void initSimpleGraph( Graph g )
     @Test
     public void testSimpleGraph2()
     {
-        Graph g = createGraph(new EncodingManager("CAR"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -197,8 +202,8 @@ public void testGrid()
             }
 
             assertTrue(i + " orig:" + (float) lat + "," + (float) lon
-                            + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
-                            + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
+                    + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
+                    + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
                     Math.abs(fullDist - newDist) < 50000);
         }
         fullIndex.close();
@@ -252,7 +257,7 @@ public void testNoErrorOnEdgeCase_lastIndex()
     {
         final EncodingManager encodingManager = new EncodingManager("CAR");
         int locs = 10000;
-        Graph g = createGraph(new MMapDirectory(location), encodingManager, false);
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new MMapDirectory(location), encodingManager, false);
         NodeAccess na = g.getNodeAccess();
         Random rand = new Random(12);
         for (int i = 0; i < locs; i++)
@@ -263,19 +268,9 @@ public void testNoErrorOnEdgeCase_lastIndex()
         Helper.close((Closeable) g);
     }
 
-    Graph createGraph( EncodingManager encodingManager )
-    {
-        return createGraph(new RAMDirectory(), encodingManager, false);
-    }
-
-    Graph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
-    {
-        return new GraphHopperStorage(dir, encodingManager, is3D).create(100);
-    }
-
     public Graph createSampleGraph( EncodingManager encodingManager )
     {
-        Graph graph = createGraph(encodingManager);
+        Graph graph = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         // length does not matter here but lat,lon and outgoing edges do!
 
 //        
@@ -357,7 +352,7 @@ public Graph createSampleGraph( EncodingManager encodingManager )
     public void testDifferentVehicles()
     {
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-        Graph g = createGraph(encodingManager);
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         initSimpleGraph(g);
         idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index e192f7c8ee..bbc99eaeb4 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -43,7 +43,7 @@ public LocationIndex createIndex( Graph g, int resolution )
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGHStorage(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
similarity index 67%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
index 9df6bf1504..69abc98f6c 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
@@ -17,22 +17,20 @@
  */
 package com.graphhopper.storage.index;
 
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.TIntList;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 
@@ -43,7 +41,7 @@
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
+public class LocationIndexTreeCHTest extends LocationIndexTreeTest
 {
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
@@ -57,59 +55,63 @@ public LocationIndexTree createIndex( Graph g, int resolution )
     public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        LocationIndexTree tmpIdx = new LocationIndexTree(g, dir);
         tmpIdx.setResolution(resolution);
         return tmpIdx;
     }
 
     @Override
-    LevelGraph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
+    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
     {
-        return new LevelGraphStorage(dir, encodingManager, is3D).create(100);
+        return new GraphHopperStorage(Arrays.asList(new FastestWeighting(encodingManager.getEncoder("car"))), dir, encodingManager, is3D, new GraphExtension.NoOpExtension()).
+                create(100);
     }
 
     @Test
-    public void testLevelGraph()
+    public void testCHGraph()
     {
-        LevelGraph g = createGraph(new RAMDirectory(), encodingManager, false);
+        GraphHopperStorage ghStorage = createGHStorage(new RAMDirectory(), encodingManager, false);
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
         // 0
         // 1
         // 2
         //  3
         //   4
-        NodeAccess na = g.getNodeAccess();
+        NodeAccess na = ghStorage.getNodeAccess();
         na.setNode(0, 1, 0);
         na.setNode(1, 0.5, 0);
         na.setNode(2, 0, 0);
         na.setNode(3, -1, 1);
         na.setNode(4, -2, 2);
 
-        EdgeIteratorState iter1 = g.edge(0, 1, 10, true);
-        EdgeIteratorState iter2 = g.edge(1, 2, 10, true);
-        EdgeIteratorState iter3 = g.edge(2, 3, 14, true);
-        EdgeIteratorState iter4 = g.edge(3, 4, 14, true);
+        EdgeIteratorState iter1 = ghStorage.edge(0, 1, 10, true);
+        EdgeIteratorState iter2 = ghStorage.edge(1, 2, 10, true);
+        EdgeIteratorState iter3 = ghStorage.edge(2, 3, 14, true);
+        EdgeIteratorState iter4 = ghStorage.edge(3, 4, 14, true);
 
         // create shortcuts
+        ghStorage.freeze();
         FlagEncoder car = encodingManager.getEncoder("CAR");
         long flags = car.setProperties(60, true, true);
-        EdgeSkipIterState iter5 = g.shortcut(0, 2);
+        CHEdgeIteratorState iter5 = lg.shortcut(0, 2);
         iter5.setDistance(20).setFlags(flags);
         iter5.setSkippedEdges(iter1.getEdge(), iter2.getEdge());
-        EdgeSkipIterState iter6 = g.shortcut(2, 4);
+        CHEdgeIteratorState iter6 = lg.shortcut(2, 4);
         iter6.setDistance(28).setFlags(flags);
         iter6.setSkippedEdges(iter3.getEdge(), iter4.getEdge());
-        EdgeSkipIterState tmp = g.shortcut(0, 4);
+        CHEdgeIteratorState tmp = lg.shortcut(0, 4);
         tmp.setDistance(40).setFlags(flags);
         tmp.setSkippedEdges(iter5.getEdge(), iter6.getEdge());
 
-        LocationIndex index = createIndex(g, -1);
+        LocationIndex index = createIndex(ghStorage, -1);
         assertEquals(2, index.findID(0, 0.5));
     }
 
     @Test
     public void testSortHighLevelFirst()
     {
-        final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
+        final CHGraph lg = g.getGraph(CHGraph.class);
         lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
@@ -132,7 +134,7 @@ public int compare( Integer o1, Integer o2 )
     }
 
     @Test
-    public void testLevelGraphBug()
+    public void testCHGraphBug()
     {
         // 0
         // |
@@ -140,15 +142,17 @@ public void testLevelGraphBug()
         // |
         // 1
 
-        LevelGraphStorage lg = (LevelGraphStorage) createGraph(new RAMDirectory(), encodingManager, false);
-        NodeAccess na = lg.getNodeAccess();
+        GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = g.getNodeAccess();
         na.setNode(0, 1, 0);
         na.setNode(1, 0, 0);
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
-        EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        lg.edge(2, 3, 100, true);
+        EdgeIteratorState iter1 = g.edge(1, 0, 100, true);
+        g.edge(2, 3, 100, true);
 
+        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
+        g.freeze();
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
         // disconnect higher 0 from lower 1
@@ -159,17 +163,20 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTree index = createIndex(lg, 100000);
+        LocationIndexTree index = createIndex(g, 100000);
 
         // very close to 2, but should match the edge 0--1
-        TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
-        assertEquals(0, index.findID(0.51, 0.2));
-        assertEquals(1, index.findID(0.1, 0.1));
-        assertEquals(2, index.findID(0.51, 0.51));
-        assertEquals(3, index.findID(0.51, 1.1));
+        TIntHashSet set = new TIntHashSet();
+        index.findNetworkEntries(0.51, 0.2, set, 0);
+        index.findNetworkEntries(0.51, 0.2, set, 1);
         TIntSet expectedSet = new TIntHashSet();
         expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
+
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index cd4b223136..fe4cdd4d3e 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -17,8 +17,7 @@
  */
 package com.graphhopper.storage.index;
 
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
@@ -38,8 +37,7 @@
  */
 public class LocationIndexTreeTest extends AbstractLocationIndexTester
 {
-
-    protected final EncodingManager encodingManager = new EncodingManager("CAR");
+    protected final EncodingManager encodingManager = new EncodingManager("car");
 
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
@@ -66,11 +64,11 @@ public boolean hasEdgeSupport()
     //  0------\
     // /|       \
     // |1----3-\|
-    // |    /   4
-    // 2---/---/
-    Graph createTestGraph()
+    // |____/   4
+    // 2-------/
+    Graph createTestGraph( EncodingManager em )
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        Graph graph = createGHStorage(new RAMDirectory(), em, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
         na.setNode(1, -0.5, -0.5);
@@ -90,23 +88,27 @@ Graph createTestGraph()
     @Test
     public void testSnappedPointAndGeometry()
     {
-        Graph graph = createTestGraph();
+        Graph graph = createTestGraph(encodingManager);
         LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
+        assertTrue(res.isValid());
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
         res = index.findClosest(-0.6, 1.6, EdgeFilter.ALL_EDGES);
+        assertTrue(res.isValid());
         assertEquals(new GHPoint(-0.6, 1.6), res.getSnappedPoint());
 
-        // query the edge (1,3)
+        // query the edge (1,3). The edge (0,4) has 27674 as distance
         res = index.findClosest(-0.2, 0.3, EdgeFilter.ALL_EDGES);
+        assertTrue(res.isValid());
+        assertEquals(26936, res.getQueryDistance(), 1);
         assertEquals(new GHPoint(-0.441624, 0.317259), res.getSnappedPoint());
     }
 
     @Test
     public void testInMemIndex()
     {
-        Graph graph = createTestGraph();
+        Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndexNoPrepare(graph, 50000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
@@ -125,16 +127,23 @@ public void testInMemIndex()
 
         TIntHashSet set = new TIntHashSet();
         set.add(0);
-        assertEquals(set, index.findNetworkEntries(0.5, -0.5, 2));
+
+        TIntHashSet foundIds = new TIntHashSet();
+        index.findNetworkEntries(0.5, -0.5, foundIds, 0);
+        assertEquals(set, foundIds);
+
         set.add(1);
         set.add(2);
-        assertEquals(set, index.findNetworkEntries(-0.5, -0.9, 2));
+        foundIds.clear();
+        index.findNetworkEntries(-0.5, -0.9, foundIds, 0);
+        index.findNetworkEntries(-0.5, -0.9, foundIds, 1);
+        assertEquals(set, foundIds);
         assertEquals(2, index.findID(-0.5, -0.9));
 
         // The optimization if(dist > normedHalf) => feed nodeA or nodeB
         // although this reduces chance of nodes outside of the tile
         // in practice it even increases file size!?
-        // Is this due to the LevelGraph disconnect problem?
+        // Is this due to the CHGraph disconnect problem?
 //        set.clear();
 //        set.add(4);
 //        assertEquals(set, index.findNetworkEntries(-0.7, 1.5));
@@ -179,13 +188,16 @@ public void testInMemIndex2()
         // For compaction see: https://github.com/graphhopper/graphhopper/blob/5594f7f9d98d932f365557dc37b4b2d3b7abf698/core/src/main/java/com/graphhopper/storage/index/Location2NodesNtree.java#L277
         TIntHashSet set = new TIntHashSet();
         set.addAll(Arrays.asList(28, 27, 26, 24, 23, 21, 19, 18, 16, 14, 6, 5, 4, 3, 2, 1, 0));
-        assertEquals(set, index.findNetworkEntries(49.950, 11.5732, 1));
+
+        TIntHashSet foundIds = new TIntHashSet();
+        index.findNetworkEntries(49.950, 11.5732, foundIds, 0);
+        assertEquals(set, foundIds);
     }
 
     @Test
     public void testInMemIndex3()
     {
-        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
@@ -205,7 +217,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = createIndex(createTestGraph(), 200);
+        LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -216,7 +228,7 @@ public void testReverseSpatialKey()
     @Test
     public void testMoreReal()
     {
-        Graph graph = createGraph(new EncodingManager("CAR"));
+        Graph graph = createGHStorage(new EncodingManager("CAR"));
         NodeAccess na = graph.getNodeAccess();
         na.setNode(1, 51.2492152, 9.4317166);
         na.setNode(0, 52, 9);
@@ -241,7 +253,7 @@ public void testMoreReal()
     //  |
     private Graph createTestGraphWithWayGeometry()
     {
-        Graph graph = createGraph(encodingManager);
+        Graph graph = createGHStorage(encodingManager);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
         na.setNode(1, -0.5, -0.5);
@@ -273,7 +285,7 @@ public void testWayGeometry()
     @Test
     public void testFindingWayGeometry()
     {
-        Graph g = createGraph(encodingManager);
+        Graph g = createGHStorage(encodingManager);
         NodeAccess na = g.getNodeAccess();
         na.setNode(10, 51.2492152, 9.4317166);
         na.setNode(20, 52, 9);
@@ -290,7 +302,7 @@ public void testFindingWayGeometry()
     @Test
     public void testEdgeFilter()
     {
-        Graph graph = createTestGraph();
+        Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
@@ -307,7 +319,7 @@ public boolean accept( EdgeIteratorState iter )
     // see testgraph2.jpg
     Graph createTestGraph2()
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(8, 49.94553, 11.57214);
         na.setNode(9, 49.94553, 11.57314);
@@ -403,7 +415,7 @@ Graph createTestGraph2()
     @Test
     public void testRMin()
     {
-        Graph graph = createTestGraph();
+        Graph graph = createTestGraph(encodingManager);
         LocationIndexTree index = createIndex(graph, 50000);
 
         //query: 0.05 | -0.3
@@ -431,4 +443,56 @@ public void testRMin()
          Thread.sleep(4000);
          } catch(InterruptedException ie) {}*/
     }
+
+    @Test
+    public void testSearchWithFilter_issue318()
+    {
+        CarFlagEncoder carEncoder = new CarFlagEncoder();
+        BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
+
+        EncodingManager tmpEM = new EncodingManager(carEncoder, bikeEncoder);
+        Graph graph = createGHStorage(new RAMDirectory(), tmpEM, false);
+        NodeAccess na = graph.getNodeAccess();
+
+        // distance from point to point is roughly 1 km
+        int MAX = 5;
+        for (int latIdx = 0; latIdx < MAX; latIdx++)
+        {
+            for (int lonIdx = 0; lonIdx < MAX; lonIdx++)
+            {
+                int index = lonIdx * 10 + latIdx;
+                na.setNode(index, 0.01 * latIdx, 0.01 * lonIdx);
+                if (latIdx < MAX - 1)
+                    graph.edge(index, index + 1, 1000, true);
+
+                if (lonIdx < MAX - 1)
+                    graph.edge(index, index + 10, 1000, true);
+            }
+        }
+
+        // reduce access for bike to two edges only
+        AllEdgesIterator iter = graph.getAllEdges();
+        while (iter.next())
+        {
+            iter.setFlags(bikeEncoder.setAccess(iter.getFlags(), false, false));
+        }
+        for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(graph, 0, 1), GHUtility.getEdge(graph, 1, 2)))
+        {
+            edge.setFlags(bikeEncoder.setAccess(edge.getFlags(), true, true));
+        }
+
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareIndex();
+        index.setMaxRegionSearch(8);
+
+        EdgeFilter carFilter = new DefaultEdgeFilter(carEncoder, true, true);
+        QueryResult qr = index.findClosest(0.03, 0.03, carFilter);
+        assertTrue(qr.isValid());
+        assertEquals(33, qr.getClosestNode());
+
+        EdgeFilter bikeFilter = new DefaultEdgeFilter(bikeEncoder, true, true);
+        qr = index.findClosest(0.03, 0.03, bikeFilter);
+        assertTrue(qr.isValid());
+        assertEquals(2, qr.getClosestNode());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
similarity index 63%
rename from core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
rename to core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index 2f5f731492..e3817790e5 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -17,12 +17,10 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 import static org.junit.Assert.*;
 
@@ -31,32 +29,29 @@
 /**
  * @author Peter Karich
  */
-public class EdgeSkipIteratorTest
+public class CHEdgeIteratorTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
-    private CarFlagEncoder carFlagsEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    private EdgeFilter carOutFilter = new DefaultEdgeFilter(carFlagsEncoder, false, true);
-
-    LevelGraph createGraph()
-    {
-        return new GraphBuilder(encodingManager).levelGraphCreate();
-    }
-
     @Test
     public void testUpdateFlags()
     {
-        LevelGraph g = createGraph();
-        g.edge(0, 1).setDistance(12).setFlags(carFlagsEncoder.setProperties(10, true, true));
-        g.edge(0, 2).setDistance(13).setFlags(carFlagsEncoder.setProperties(20, true, true));
+        CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        EncodingManager encodingManager = new EncodingManager(carFlagEncoder);
+        FastestWeighting weighting = new FastestWeighting(carFlagEncoder);
+        EdgeFilter carOutFilter = new DefaultEdgeFilter(carFlagEncoder, false, true);
+        GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        CHGraph g = ghStorage.getGraph(CHGraph.class, weighting);
+        g.edge(0, 1).setDistance(12).setFlags(carFlagEncoder.setProperties(10, true, true));
+        g.edge(0, 2).setDistance(13).setFlags(carFlagEncoder.setProperties(20, true, true));
+        ghStorage.freeze();
 
         assertEquals(2, GHUtility.count(g.getAllEdges()));
         assertEquals(1, GHUtility.count(g.createEdgeExplorer(carOutFilter).setBaseNode(1)));
         EdgeIteratorState iter = GHUtility.getEdge(g, 0, 1);
         assertEquals(1, iter.getAdjNode());
-        assertEquals(carFlagsEncoder.setProperties(10, true, true), iter.getFlags());
+        assertEquals(carFlagEncoder.setProperties(10, true, true), iter.getFlags());
 
         // update setProperties
-        iter.setFlags(carFlagsEncoder.setProperties(20, true, false));
+        iter.setFlags(carFlagEncoder.setProperties(20, true, false));
         assertEquals(12, iter.getDistance(), 1e-4);
 
         // update distance
@@ -64,7 +59,7 @@ public void testUpdateFlags()
         assertEquals(10, iter.getDistance(), 1e-4);
         assertEquals(0, GHUtility.count(g.createEdgeExplorer(carOutFilter).setBaseNode(1)));
         iter = GHUtility.getEdge(g, 0, 1);
-        assertEquals(carFlagsEncoder.setProperties(20, true, false), iter.getFlags());
+        assertEquals(carFlagEncoder.setProperties(20, true, false), iter.getFlags());
         assertEquals(10, iter.getDistance(), 1e-4);
         assertEquals(1, GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(1)).size());
         assertEquals(0, GHUtility.getNeighbors(g.createEdgeExplorer(carOutFilter).setBaseNode(1)).size());
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 6a0def1aef..f26668e2c7 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.routing.util.FastestWeighting;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.*;
 
 import static org.junit.Assert.*;
 
@@ -32,13 +32,21 @@
  */
 public class GHUtilityTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private final FlagEncoder carEncoder = new CarFlagEncoder();
+    private final EncodingManager encodingManager = new EncodingManager(carEncoder);
 
     Graph createGraph()
     {
         return new GraphBuilder(encodingManager).create();
     }
 
+    // 7      8\
+    // | \    | 2
+    // |  5   | |
+    // 3    4 | |
+    //   6     \1
+    //   ______/
+    // 0/
     Graph initUnsorted( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
@@ -81,7 +89,6 @@ public void testSort2()
     {
         Graph g = initUnsorted(createGraph());
         Graph newG = GHUtility.sortDFS(g, createGraph());
-        // TODO does not handle subnetworks
         assertEquals(g.getNodes(), newG.getNodes());
         NodeAccess na = newG.getNodeAccess();
         assertEquals(0, na.getLatitude(0), 1e-4); // 0
@@ -109,23 +116,26 @@ public void testCopyWithSelfRef()
         Graph g = initUnsorted(createGraph());
         EdgeIteratorState eb = g.edge(0, 0, 11, true);
 
-        LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
+        CHGraph lg = new GraphBuilder(encodingManager).chGraphCreate(new FastestWeighting(carEncoder));
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
+        assertEquals(g.getAllEdges().getMaxId(), lg.getAllEdges().getMaxId());
     }
 
     @Test
     public void testCopy()
     {
         Graph g = initUnsorted(createGraph());
-        EdgeIteratorState eb = g.edge(6, 5, 11, true);
-        eb.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
-        LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
+        EdgeIteratorState edgeState = g.edge(6, 5, 11, true);
+        edgeState.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
+
+        GraphHopperStorage newStore = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
+        CHGraph lg = newStore.getGraph(CHGraph.class);
         GHUtility.copyTo(g, lg);
+        newStore.freeze();
 
-        eb = GHUtility.getEdge(lg, 5, 6);
-        assertEquals(Helper.createPointList(-1, 3, 12, 10), eb.fetchWayGeometry(0));
+        edgeState = GHUtility.getEdge(lg, 5, 6);
+        assertEquals(Helper.createPointList(-1, 3, 12, 10), edgeState.fetchWayGeometry(0));
 
         assertEquals(0, lg.getLevel(0));
         assertEquals(0, lg.getLevel(1));
@@ -138,10 +148,12 @@ public void testCopy()
         EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(8);
         iter.next();
         assertEquals(2.05, iter.getDistance(), 1e-6);
-        assertEquals("11", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
+        assertTrue(iter.isBackward(carEncoder));
+        assertTrue(iter.isForward(carEncoder));
         iter.next();
         assertEquals(0.5, iter.getDistance(), 1e-6);
-        assertEquals("11", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
+        assertTrue(iter.isBackward(carEncoder));
+        assertTrue(iter.isForward(carEncoder));
 
         iter = lg.createEdgeExplorer().setBaseNode(7);
         iter.next();
@@ -149,7 +161,8 @@ public void testCopy()
 
         iter.next();
         assertEquals(2.1, iter.getDistance(), 1e-6);
-        assertEquals("01", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
+        assertFalse(iter.isBackward(carEncoder));
+        assertTrue(iter.isForward(carEncoder));
         assertFalse(iter.next());
     }
 
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 1b163e036b..d851e5f0d4 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -112,7 +112,7 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
@@ -142,7 +142,7 @@ public void testWayList()
                         asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
 
@@ -155,7 +155,7 @@ public void testWayList()
                 wayList.createStartPoints());
 
         // special case of identical start and end
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
         wayList = p.calcInstructions(usTR);
         assertEquals(1, wayList.size());
         assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
@@ -237,14 +237,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -276,7 +276,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -303,7 +303,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -467,7 +467,7 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
     public void testEmptyList()
     {
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
@@ -521,7 +521,7 @@ public void testFind()
         g.edge(4, 5, 10000, true).setName("4-5");
 
 
-        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         
         // query on first edge, get instruction for second edge
diff --git a/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg b/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
index 8d8a6500a8..0367a06986 100644
--- a/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
+++ b/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
@@ -2,469 +2,477 @@
 <!-- Created with Inkscape (http://www.inkscape.org/) -->
 
 <svg
-    xmlns:dc="http://purl.org/dc/elements/1.1/"
-    xmlns:cc="http://creativecommons.org/ns#"
-    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-    xmlns:svg="http://www.w3.org/2000/svg"
-    xmlns="http://www.w3.org/2000/svg"
-    xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-    xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-    width="210mm"
-    height="297mm"
-    id="svg2"
-    version="1.1"
-    inkscape:version="0.48.0 r9654"
-    sodipodi:docname="prepare-routing.svg">
-    <defs
-        id="defs4" />
-    <sodipodi:namedview
-        id="base"
-        pagecolor="#ffffff"
-        bordercolor="#666666"
-        borderopacity="1.0"
-        inkscape:pageopacity="0.0"
-        inkscape:pageshadow="2"
-        inkscape:zoom="1.979899"
-        inkscape:cx="229.16243"
-        inkscape:cy="980.18743"
-        inkscape:document-units="px"
-        inkscape:current-layer="layer1"
-        showgrid="false"
-        inkscape:window-width="1440"
-        inkscape:window-height="850"
-        inkscape:window-x="0"
-        inkscape:window-y="0"
-        inkscape:window-maximized="1" />
-    <metadata
-        id="metadata7">
-        <rdf:RDF>
-            <cc:Work
-                rdf:about="">
-                <dc:format>image/svg+xml</dc:format>
-                <dc:type
-                    rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-                <dc:title></dc:title>
-            </cc:Work>
-        </rdf:RDF>
-    </metadata>
-    <g
-        inkscape:label="Ebene 1"
-        inkscape:groupmode="layer"
-        id="layer1">
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 110.76144,85.010117 133.62219,68.913306"
-            id="path3006"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 110.1697,84.959354 18.40173,20.974256"
-            id="path3008"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 132.14286,70.219325 -3.57143,35.714285 7.71717,36.09065"
-            id="path3010"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 131.79622,67.693944 171.38397,52.78676"
-            id="path3012"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="91.619301"
-            y="92.651894"
-            id="text3014"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3016"
-            x="91.619301"
-            y="92.651894">0</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="127.85714"
-            y="68.076469"
-            id="text3018"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3020"
-            x="127.85714"
-            y="68.076469">1</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="156.8593"
-            y="52.71497"
-            id="text3022"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3024"
-            x="156.8593"
-            y="52.71497">4</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="116.34191"
-            y="122.32629"
-            id="text3026"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3028"
-            x="116.34191"
-            y="122.32629">2</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="122.49308"
-            y="156.95247"
-            id="text3030"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3032"
-            x="122.49308"
-            y="156.95247">3</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 127.02031,107.15298 59.98151,9.21137"
-            id="path3034"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 187.33358,117.3745 -50.74911,25.65991"
-            id="path3036"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 137.33465,144.58554 112.76943,14.96155"
-            id="path3038"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 172.22081,52.909312 209.60665,40.694409"
-            id="path3040"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 210.61681,40.694409 13.63706,34.850263"
-            id="path3042"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="181.82747"
-            y="136.65891"
-            id="text3044"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3046"
-            x="181.82747"
-            y="136.65891">9</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="255.06351"
-            y="165.95334"
-            id="text3048"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3050"
-            x="255.06351"
-            y="165.95334">10</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="201.02036"
-            y="62.412685"
-            id="text3052"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3054"
-            x="201.02036"
-            y="62.412685">5</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="210.11172"
-            y="89.181732"
-            id="text3056"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3058"
-            x="210.11172"
-            y="89.181732">6</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 223.24371,76.049748 27.7792,14.142134"
-            id="path3060"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="232.84016"
-            y="107.86956"
-            id="text3062"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3064"
-            x="232.84016"
-            y="107.86956">7</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="253.04323"
-            y="118.47615"
-            id="text3066"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3068"
-            x="253.04323"
-            y="118.47615">8</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 189.4036,117.97108 64.1447,-3.53554 -3.53553,-24.748734"
-            id="path3070"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 173.24116,53.321316 4.54569,-38.890873 52.52793,2.020305"
-            id="path3072"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="159.60411"
-            y="11.399985"
-            id="text3074"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3076"
-            x="159.60411"
-            y="11.399985">11</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="214.65741"
-            y="12.410138"
-            id="text3078"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3080"
-            x="214.65741"
-            y="12.410138">12</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 185.36299,117.97107 88.89344,10.60661"
-            id="path3082"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 251.0229,159.89242 25.7589,-32.82996"
-            id="path3084"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="271.22595"
-            y="143.2249"
-            id="text3086"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3088"
-            x="271.22595"
-            y="143.2249">14</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 230.31478,15.945672 300.01531,5.3390703"
-            id="path3090"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 230.31478,15.440596 48.48733,47.477168"
-            id="path3092"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 277.79195,63.927917 36.87057,-0.505075"
-            id="path3094"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 300.01531,5.3390703 315.67267,65.948222"
-            id="path3096"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 277.28688,126.55737 316.68282,63.927918"
-            id="path3098"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="314.15744"
-            y="72.514214"
-            id="text3100"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3102"
-            x="314.15744"
-            y="72.514214">16</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="306.5813"
-            y="20.996435"
-            id="text3104"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3106"
-            x="306.5813"
-            y="20.996435">13</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="258.09399"
-            y="84.636047"
-            id="text3108"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3110"
-            x="258.09399"
-            y="84.636047">15</tspan></text>
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:12,12;stroke-dashoffset:0"
-            d="M 171.71875 52.8125 L 186.875 115.9375 L 171.71875 52.8125 z "
-            id="path3133" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:8,8;stroke-dashoffset:0"
-            d="M 136.37059,143.72997 272.23611,129.58783"
-            id="path3138"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:6,6;stroke-dashoffset:0"
-            d="M 316.68282,64.93807 233.85031,14.935519"
-            id="path3140"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:8,8;stroke-dashoffset:0"
-            d="M 231.32493,16.955824 172.73609,52.81624"
-            id="path3142"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="160.61426"
-            y="87.161423"
-            id="text3144"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3146"
-            x="160.61426"
-            y="87.161423"
-            style="font-size:12px;fill:#ff0000">(5)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="188.39345"
-            y="32.61319"
-            id="text3148"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3150"
-            x="188.39345"
-            y="32.61319"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="274.25644"
-            y="39.17918"
-            id="text3152"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3154"
-            x="274.25644"
-            y="39.17918"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="218.19295"
-            y="146.25536"
-            id="text3156"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3158"
-            x="218.19295"
-            y="146.25536"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="289.91379"
-            y="72.514214"
-            id="text3928"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930"
-            x="289.91379"
-            y="72.514214"
-            style="font-size:10px">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="248.19583"
-            y="54.672295"
-            id="text3928-8"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-1"
-            x="248.19583"
-            y="54.672295"
-            style="font-size:10px">(1)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="310.82529"
-            y="43.055542"
-            id="text3928-88"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-3"
-            x="310.82529"
-            y="43.055542"
-            style="font-size:10px">(1)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="263.34811"
-            y="7.1951294"
-            id="text3928-1"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-14"
-            x="263.34811"
-            y="7.1951294"
-            style="font-size:10px">(1)</tspan></text>
-    </g>
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="prepare-routing.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1.979899"
+     inkscape:cx="142.28931"
+     inkscape:cy="980.18743"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="1600"
+     inkscape:window-height="1147"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <rect
+       style="opacity:0.94827587999999996;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-opacity:1"
+       id="rect3055"
+       width="299.51022"
+       height="228.79955"
+       x="41.416256"
+       y="10.894916" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 77.931483,137.53805 100.79223,121.44124"
+       id="path3006"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 77.339743,137.48729 18.40173,20.97425"
+       id="path3008"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 99.312903,122.74726 -3.57143,35.71428 7.717167,36.09065"
+       id="path3010"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 98.966263,120.22188 138.55401,105.31469"
+       id="path3012"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="58.789345"
+       y="145.17982"
+       id="text3014"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3016"
+         x="58.789345"
+         y="145.17982">0</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="95.027184"
+       y="120.6044"
+       id="text3018"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3020"
+         x="95.027184"
+         y="120.6044">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="124.02934"
+       y="105.2429"
+       id="text3022"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3024"
+         x="124.02934"
+         y="105.2429">4</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="83.511955"
+       y="174.85422"
+       id="text3026"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3028"
+         x="83.511955"
+         y="174.85422">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="89.663124"
+       y="209.48041"
+       id="text3030"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3032"
+         x="89.663124"
+         y="209.48041">3</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 94.190353,159.68091 59.981507,9.21137"
+       id="path3034"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 154.50362,169.90243 -50.74911,25.65991"
+       id="path3036"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 104.50469,197.11347 112.76943,14.96155"
+       id="path3038"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 139.39085,105.43724 176.77669,93.222341"
+       id="path3040"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 177.78685,93.222341 191.42391,128.0726"
+       id="path3042"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="148.99751"
+       y="189.18684"
+       id="text3044"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3046"
+         x="148.99751"
+         y="189.18684">9</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="222.23355"
+       y="218.48128"
+       id="text3048"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3050"
+         x="222.23355"
+         y="218.48128">10</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="168.1904"
+       y="114.94062"
+       id="text3052"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3054"
+         x="168.1904"
+         y="114.94062">5</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="177.28177"
+       y="141.70967"
+       id="text3056"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3058"
+         x="177.28177"
+         y="141.70967">6</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 190.41375,128.57768 27.7792,14.14213"
+       id="path3060"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="200.01021"
+       y="160.39749"
+       id="text3062"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3064"
+         x="200.01021"
+         y="160.39749">7</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="220.21327"
+       y="171.00409"
+       id="text3066"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3068"
+         x="220.21327"
+         y="171.00409">8</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 156.57364,170.49901 64.1447,-3.53554 -3.53553,-24.74873"
+       id="path3070"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 140.4112,105.84925 4.54569,-38.890875 52.52793,2.020305"
+       id="path3072"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="126.77415"
+       y="63.927917"
+       id="text3074"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3076"
+         x="126.77415"
+         y="63.927917">11</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="181.82745"
+       y="64.938072"
+       id="text3078"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3080"
+         x="181.82745"
+         y="64.938072">12</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 152.53303,170.499 88.89344,10.60661"
+       id="path3082"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 218.19294,212.42035 25.7589,-32.82996"
+       id="path3084"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="238.396"
+       y="195.75284"
+       id="text3086"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3088"
+         x="238.396"
+         y="195.75284">14</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 197.48482,68.473604 267.18535,57.867002"
+       id="path3090"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 197.48482,67.968528 245.97215,115.4457"
+       id="path3092"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 244.96199,116.45585 36.87057,-0.50508"
+       id="path3094"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 267.18535,57.867002 15.65736,60.609148"
+       id="path3096"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 244.45692,179.0853 39.39594,-62.62945"
+       id="path3098"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="281.32748"
+       y="125.04214"
+       id="text3100"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3102"
+         x="281.32748"
+         y="125.04214">16</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="273.75134"
+       y="73.524368"
+       id="text3104"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3106"
+         x="273.75134"
+         y="73.524368">13</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="225.26404"
+       y="137.16399"
+       id="text3108"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3110"
+         x="225.26404"
+         y="137.16399">15</tspan></text>
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:12, 12;stroke-dashoffset:0"
+       d="m 138.88879,105.34043 15.15625,63.125 -15.15625,-63.125 z"
+       id="path3133"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:8, 8;stroke-dashoffset:0"
+       d="M 103.54063,196.2579 239.40615,182.11576"
+       id="path3138"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:6, 6;stroke-dashoffset:0"
+       d="M 283.85286,117.466 201.02035,67.463451"
+       id="path3140"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:8, 8;stroke-dashoffset:0"
+       d="M 198.49497,69.483756 139.90613,105.34417"
+       id="path3142"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="127.7843"
+       y="139.68936"
+       id="text3144"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3146"
+         x="127.7843"
+         y="139.68936"
+         style="font-size:12px;fill:#ff0000">(5)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="155.56349"
+       y="85.141121"
+       id="text3148"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3150"
+         x="155.56349"
+         y="85.141121"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="241.42648"
+       y="91.707115"
+       id="text3152"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3154"
+         x="241.42648"
+         y="91.707115"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="185.36299"
+       y="198.78329"
+       id="text3156"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3158"
+         x="185.36299"
+         y="198.78329"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="257.08383"
+       y="125.04214"
+       id="text3928"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930"
+         x="257.08383"
+         y="125.04214"
+         style="font-size:10px">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="215.36588"
+       y="107.20023"
+       id="text3928-8"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-1"
+         x="215.36588"
+         y="107.20023"
+         style="font-size:10px">(1)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="277.99533"
+       y="95.583473"
+       id="text3928-88"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-3"
+         x="277.99533"
+         y="95.583473"
+         style="font-size:10px">(1)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="230.51816"
+       y="59.723061"
+       id="text3928-1"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-14"
+         x="230.51816"
+         y="59.723061"
+         style="font-size:10px">(1)</tspan></text>
+  </g>
 </svg>
diff --git a/docs/android/index.md b/docs/android/index.md
index cf86b7f66a..474c29b75a 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -47,6 +47,14 @@ Now that you have a running android app you need to copy somehow the routing and
  4. Copy berlin.map into the created berlin-gh folder
  5. Optional Compression Step: Bundle a graphhopper zip file via `cd berlin-gh; zip -r berlin.ghz *`
  6. Now copy the berlin-gh folder from step 4 (or the .ghz file from step 5) to your Android device. /[download-folder]/graphhopper/maps, where the download-folder can e.g. be /mnt/sdcard/download or /storage/sdcard/Download/ - e.g. use [SSHDroid](https://play.google.com/store/apps/details?id=berserker.android.apps.sshdroid): `scp -P 2222 berlin.ghz root@$URL:/mnt/sdcard/download/graphhopper/maps/`
+  
+## Locus Add-On
+
+The developer of Locus has create a routing plugin for [locus](http://www.locusmap.eu/) the source code for the add-on is available [here](https://bitbucket.org/asamm/locus-add-on-graphhopper) and could be useful for other Map-apps too. The discussion is happing [here](http://forum.locusmap.eu/index.php?topic=4036.0).
+
+## Cruiser App
+
+The free offline map app [Cruiser](https://play.google.com/store/apps/details?id=gr.talent.cruiser) is using GraphHopper routing and allows also other things.
 
 ## Limitations
 
@@ -85,4 +93,4 @@ gnu.trove.stack.array.TIntArrayStack.class
 
 Routes for areas of up to 500km^2 are calculated in under 5s with the help of Contraction Hierarchies
 
-![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
\ No newline at end of file
+![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 4d55a5c847..f1e3ef6e8c 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -3,9 +3,9 @@
 CH is a post-import process which makes routing faster. 
 In GraphHopper CH is enabled by default but can be easily disabled.
 
-To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
-is necessary which allows to store shortcuts too.
+To make CH work in GraphHopper an additional logic is added to GraphHoppperStorage (CHGraphImpl) 
+which allows to store shortcuts too.
 
-A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
+A prepared graph can also be used for normal graph traversal IF you use chGraph.getBaseGraph().
 
 If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index 29d9875f11..a5fa64a68c 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -62,22 +62,22 @@ Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(),
 Path path = new Dijkstra(graph, encoder).calcPath(fromId, toId);
 ```
 
-### Use LevelGraph to make queries faster
+### Use CHGraph to make queries faster
 
 ```java
 // Creating and saving the graph
 GraphBuilder gb = new GraphBuilder(em).
     setLocation("graphhopper-folder").
     setStore(true).
-    setLevelGraph(true);
-GraphStorage graph = gb.create();
+    setCHGraph(true);
+GraphHopperStorage graph = gb.create();
 // Create a new edge between two nodes, set access, distance, speed, geometry, ..
 EdgeIteratorState edge = graph.edge(fromId, toId);
 ...
 
 // Prepare the graph for fast querying ...
 TraversalMode tMode = TraversalMode.NODE_BASED;
-PrepareContractionHierarchies pch = new PrepareContractionHierarchies(graph, encoder, weighting, tMode);
+PrepareContractionHierarchies pch = new PrepareContractionHierarchies(ghStorage, encoder, weighting, tMode);
 pch.doWork();
 
 // flush after preparation!
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 166b68d6bc..65d18c2e8a 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -67,7 +67,7 @@ GHResponse res = hopper.route(req);
 ```
 
 In the flexibility mode it is also possible to add a desired heading (north based azimuth between 0 and 360 degree)
-to any point,
+to any point:
 ```java
 GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
 ```
@@ -75,6 +75,10 @@ or to avoid u-turns at via points
 ```java
 req.getHints().put("pass_through", true);
 ```
+
+A heading with the value 'NaN' won't be enforced and a heading not within [0, 360] will trigger an IllegalStateException.
+It is important to note that if you force the heading at via or end points the outgoing heading needs to be specified.
+I.e. if you want to force "coming from south" to a destination you need to specify the resulting "heading towards north" instead, which is 0.
  
 In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
  see the 'web' sub module or [the Java client for the GraphHopper Directions API](https://github.com/graphhopper/directions-api-java-client).
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 4b45a58200..84e3b4f14d 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -38,9 +38,14 @@ Some explanations:
  * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
  * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
 
-For some algorithms there are special implementations of the Graph. E.g. there is a LevelGraphStorage which is a Graph with the possibility to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. For this the graph needs also some preprocessing (which can take several hours for bigger areas like Europe) which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from createAlgo() in the preparation class.
+For some algorithms there are special implementations of the Graph (CHGraph). You enable this in GraphHopperStorage
+to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. 
+For this the graph needs also some preprocessing (which can take several minutes for bigger areas) 
+which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. 
+In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from 
+createAlgo() in the preparation class.
 
-A LevelGraphStorage (and all subclasses of GraphStorage) cannot read files created with GraphStorage and vice versa. Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
 
 ### 3. The Algorithms
 
@@ -51,12 +56,12 @@ An algorithm needs a kind of path extraction: from the shortest-path-tree one ne
 (list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
 can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
 For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
- we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
+ we use the _CHGraph_ which additionally holds shortcuts. While path extraction we need to identify those
  shortcuts and get the edges recursivly, this is done in Path4CH.
 
 ## 3.1 Base Graph
 
-In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
+In order to traverse the _CHGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
 is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
 _LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
 or similar. See issue #116 for more information.
diff --git a/docs/core/windows-setup.md b/docs/core/windows-setup.md
index 0686ac25a8..53ccd01ee7 100644
--- a/docs/core/windows-setup.md
+++ b/docs/core/windows-setup.md
@@ -1,6 +1,6 @@
 # Windows Setup from Source
 
-Download [cygwin](http://www.cygwin.com/) to execute bash scripts. Click on the setup and select wget, git and unzip
+Either get [Babun](http://babun.github.io/) which comes preinstalled with git and more. Or download [cygwin](http://www.cygwin.com/) and click on the setup where you need to select wget, git and unzip.
 
 ```bash
 # go to your development area
@@ -24,4 +24,4 @@ Now graphhopper web should start. After this open [http://localhost:8989/](http:
    ```bash
    $ export JAVA_HOME=/cygdrive/c/Programme/Java/jdk1.7.0_17
    $ ./graphhopper.sh web europe_germany_berlin.osm
-   ```
\ No newline at end of file
+   ```
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index 30ae92802c..21c98c73ae 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -3,7 +3,7 @@
 If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
 The following steps are simpler and only need the JRE, a jar file and an OSM file.
 
- 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.4-SNAPSHOT/) (~7MB)
+ 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.6-SNAPSHOT/) (~9MB)
  2. Unzip it and copy an OSM file into the created directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
  3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf`
  4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
diff --git a/pom.xml b/pom.xml
index dadb688542..e6d4aae7dc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.5-SNAPSHOT</version>
+    <version>0.6-SNAPSHOT</version>
     <packaging>pom</packaging> 
     <url>http://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
@@ -59,11 +59,6 @@
             <name>Peter Karich</name>
             <email>my.name@graphhopper.com</email>
         </developer>
-        <developer>
-            <id>jansoe</id>
-            <name>Jan Sölter</name>
-            <email>my.name@graphhopper.com</email>
-        </developer>
     </developers>
     
     <mailingLists>
@@ -149,7 +144,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.5.4</version>                    
+                <version>2.5.5</version>                    
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
diff --git a/tools/pom.xml b/tools/pom.xml
index 35aeb6f029..ce86d6ab94 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.5-SNAPSHOT</version>
+    <version>0.6-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.5-SNAPSHOT</version>
+        <version>0.6-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 29e85fd9f9..1e66bd938b 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -20,19 +20,13 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.MiniPerfTest;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 
 import java.io.FileWriter;
@@ -78,16 +72,21 @@ protected void ensureNotLoaded()
             // skip check. we know what we are doing
         }
 
-        public void doPostProcessing()
+        public void doPostProcessing( Weighting w )
         {
-            // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
+            // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getCount();
-            setAlgorithmFactory(createPrepare());
+
+            // let algo routing factory convert simple to CH preparation
+            putAlgorithmFactory(w, null);
+            createCHPreparations();
             super.prepare();
+
             setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
+            int edges = getGraphHopperStorage().getAllEdges().getMaxId();
+            int edgesAndShortcuts = getGraphHopperStorage().getGraph(CHGraph.class, w).getAllEdges().getMaxId();
+            put("prepare.shortcuts", edgesAndShortcuts - edges);
         }
     }
 
@@ -113,30 +112,38 @@ void start( CmdArgs args )
         MeasureHopper hopper = new MeasureHopper();
         hopper.forDesktop();
         if (!hopper.load(graphLocation))
-            throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
-
-        GraphStorage g = hopper.getGraph();
+            throw new IllegalStateException("Cannot load existing graph at " + graphLocation);
+        
+        GraphHopperStorage g = hopper.getGraphHopperStorage();
         if ("true".equals(g.getProperties().get("prepare.done")))
             throw new IllegalStateException("Graph has to be unprepared but wasn't!");
 
-        String vehicleStr = args.get("graph.flagEncoders", "");
+        String chWeighting = args.get("prepare.chWeighting", "fastest");        
+        String vehicleStr = args.get("graph.flagEncoders", "car");
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicleStr);
+        Weighting weighting = hopper.getWeightingForCH(new WeightingMap(chWeighting), encoder);
         StopWatch sw = new StopWatch().start();
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g, vehicleStr);
+            GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
+            printMiscUnitPerfTests(false, g, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
-            hopper.setCHEnable(false);
+            hopper.setCHEnable(false);            
+            hopper.putAlgorithmFactory(weighting, new RoutingAlgorithmFactorySimple());
             printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
-            hopper.setCHEnable(true);
-            hopper.doPostProcessing();
+            hopper.setCHEnable(true);            
+            hopper.doPostProcessing(weighting);
+            CHGraph lg = g.getGraph(CHGraph.class, weighting);
+            fillAllowedEdges(lg.getAllEdges(), allowedEdges);
+            printMiscUnitPerfTests(true, lg, encoder, count * 100, allowedEdges);
             printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
             printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
@@ -164,13 +171,29 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g, String vehicleStr )
+    void fillAllowedEdges( AllEdgesIterator iter, GHBitSet bs )
+    {
+        bs.clear();
+        while (iter.next())
+        {
+            bs.add(iter.getEdge());
+        }
+    }
+
+    private GHBitSet printGraphDetails( GraphHopperStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getCount());
+        put("graph.edges", g.getAllEdges().getMaxId());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
         put("graph.encoder", vehicleStr);
+
+        AllEdgesIterator iter = g.getAllEdges();
+        final int maxEdgesId = g.getAllEdges().getMaxId();
+        final GHBitSet allowedEdges = new GHBitSetImpl(maxEdgesId);
+        fillAllowedEdges(iter, allowedEdges);
+        put("graph.valid_edges", allowedEdges.getCardinality());
+        return allowedEdges;
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
@@ -198,10 +221,92 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
+    private void printMiscUnitPerfTests( boolean isCH, final Graph graph, final FlagEncoder encoder,
+                                         int count, final GHBitSet allowedEdges )
+    {
+        final Random rand = new Random(seed);
+        String description = "";
+        if (isCH)
+        {
+            description = "CH";
+            CHGraph lg = (CHGraph) graph;
+            final CHEdgeExplorer chExplorer = lg.createEdgeExplorer(new LevelEdgeFilter(lg));
+            MiniPerfTest miniPerf = new MiniPerfTest()
+            {
+                @Override
+                public int doCalc( boolean warmup, int run )
+                {
+                    int nodeId = rand.nextInt(maxNode);
+                    return GHUtility.count(chExplorer.setBaseNode(nodeId));
+                }
+            }.setIterations(count).start();
+            print("unit_testsCH.level_edge_state_next", miniPerf);
+
+            final CHEdgeExplorer chExplorer2 = lg.createEdgeExplorer();
+            miniPerf = new MiniPerfTest()
+            {
+                @Override
+                public int doCalc( boolean warmup, int run )
+                {
+                    int nodeId = rand.nextInt(maxNode);
+                    CHEdgeIterator iter = chExplorer2.setBaseNode(nodeId);
+                    while (iter.next())
+                    {
+                        if (iter.isShortcut())
+                            nodeId += (int) iter.getWeight();
+                    }
+                    return nodeId;
+                }
+            }.setIterations(count).start();
+            print("unit_testsCH.get_weight", miniPerf);
+        }
+
+        EdgeFilter outFilter = new DefaultEdgeFilter(encoder, false, true);
+        final EdgeExplorer outExplorer = graph.createEdgeExplorer(outFilter);
+        MiniPerfTest miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(outExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".out_edge_state_next", miniPerf);
+
+        final EdgeExplorer allExplorer = graph.createEdgeExplorer();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(allExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".all_edge_state_next", miniPerf);
+
+        final int maxEdgesId = graph.getAllEdges().getMaxId();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                while (true)
+                {
+                    int edgeId = rand.nextInt(maxEdgesId);
+                    if (allowedEdges.contains(edgeId))
+                        return graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE).getEdge();
+                }
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".get_edge_state", miniPerf);
+    }
+
     private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
                                         final String vehicle, final boolean withInstructions )
     {
-        final Graph g = hopper.getGraph();
+        final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
         final AtomicLong distSum = new AtomicLong(0);
@@ -209,6 +314,7 @@ private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String
         final AtomicInteger failedCount = new AtomicInteger(0);
         final DistanceCalc distCalc = new DistanceCalcEarth();
 
+        final AtomicLong visitedNodesSum = new AtomicLong(0);
 //        final AtomicLong extractTimeSum = new AtomicLong(0);
 //        final AtomicLong calcPointsTimeSum = new AtomicLong(0);
 //        final AtomicLong calcDistTimeSum = new AtomicLong(0);
@@ -254,6 +360,7 @@ public int doCalc( boolean warmup, int run )
 
                 if (!warmup)
                 {
+                    visitedNodesSum.addAndGet(res.getHints().getLong("visited_nodes.sum", 0));
                     long dist = (long) res.getDistance();
                     distSum.addAndGet(dist);
 
@@ -281,6 +388,7 @@ public int doCalc( boolean warmup, int run )
         put(prefix + ".distanceMean", (float) distSum.get() / count);
         put(prefix + ".airDistanceMean", (float) airDistSum.get() / count);
         put(prefix + ".distanceMax", maxDistance.get());
+        put(prefix + ".visitedNodesMean", (float) visitedNodesSum.get() / count);
 
 //        put(prefix + ".extractTime", (float) extractTimeSum.get() / count / 1000000f);
 //        put(prefix + ".calcPointsTime", (float) calcPointsTimeSum.get() / count / 1000000f);
@@ -290,7 +398,7 @@ public int doCalc( boolean warmup, int run )
 
     void print( String prefix, MiniPerfTest perf )
     {
-        logger.info(perf.getReport());
+        logger.info(prefix + ": " + perf.getReport());
         put(prefix + ".sum", perf.getSum());
 //        put(prefix+".rms", perf.getRMS());
         put(prefix + ".min", perf.getMin());
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index 617ccf9b80..c33c1c3c6e 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -38,7 +38,7 @@
 
 /**
  * Reads log files and queries the live service
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class QueryTorture
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 30587d2d51..48f0e7d53d 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -41,10 +41,10 @@
 /**
  * A rough graphical user interface for visualizing the OSM graph. Mainly for debugging algorithms
  * and spatial datastructures.
- * <p/>
+ * <p>
  * Use the project at https://github.com/graphhopper/graphhopper-web for a
  * better/faster/userfriendly/... alternative!
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class MiniGraphUI
@@ -76,11 +76,11 @@ public static void main( String[] strs ) throws Exception
 
     public MiniGraphUI( GraphHopper hopper, boolean debug )
     {
-        this.graph = hopper.getGraph();
+        this.graph = hopper.getGraphHopperStorage();
         this.na = graph.getNodeAccess();
-        algoFactory = hopper.getAlgorithmFactory();
         encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
+        algoFactory = hopper.getAlgorithmFactory(weighting);
         algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
         logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
diff --git a/tools/src/test/java/com/graphhopper/bzip2plugin/AppTest.java b/tools/src/test/java/com/graphhopper/bzip2plugin/AppTest.java
index c30c73287a..39a71540e5 100644
--- a/tools/src/test/java/com/graphhopper/bzip2plugin/AppTest.java
+++ b/tools/src/test/java/com/graphhopper/bzip2plugin/AppTest.java
@@ -12,7 +12,7 @@
 {
     /**
      * Create the test case
-     * <p/>
+     * <p>
      * @param testName name of the test case
      */
     public AppTest( String testName )
diff --git a/web/nbactions.xml b/web/nbactions.xml
index 53ff82d694..ea475b1d35 100644
--- a/web/nbactions.xml
+++ b/web/nbactions.xml
@@ -28,7 +28,7 @@
             <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
         </goals>
         <properties>
-            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer jetty.port=8989 config=../config.properties osmreader.osm=../core/files/monaco.osm.gz</exec.args>
             <exec.executable>java</exec.executable>
         </properties>
     </action>
@@ -42,7 +42,7 @@
             <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
         </goals>
         <properties>
-            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.http.GHServer jetty.port=8989 config=../config.properties osmreader.osm=../core/files/monaco.osm.gz</exec.args>
             <exec.executable>java</exec.executable>
             <jpda.listen>true</jpda.listen>
         </properties>
@@ -57,7 +57,7 @@
             <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
         </goals>
         <properties>
-            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer jetty.port=8989 config=../config.properties osmreader.osm=../core/files/monaco.osm.gz</exec.args>
             <exec.executable>java</exec.executable>
         </properties>
     </action>
diff --git a/web/pom.xml b/web/pom.xml
index 9c8651a013..a59dfd05ae 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.5-SNAPSHOT</version>
+    <version>0.6-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
         
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.5-SNAPSHOT</version>
+        <version>0.6-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>8.1.16.v20140903</jetty.version>
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index 61e8f52dc0..b8e69a5a32 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -57,7 +57,7 @@ protected GraphHopper createGraphHopper( CmdArgs args )
         logger.info("loaded graph at:" + tmp.getGraphHopperLocation()
                 + ", source:" + tmp.getOSMFile()
                 + ", flagEncoders:" + tmp.getEncodingManager()
-                + ", class:" + tmp.getGraph().getClass().getSimpleName());
+                + ", class:" + tmp.getGraphHopperStorage().toDetailsString());
         return tmp;
     }
 
@@ -78,7 +78,7 @@ protected void configure()
 
             bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
 
-            bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraph().getBounds()));
+            bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraphHopperStorage().getBounds()));
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
index 2f8e9250da..3356708ae2 100644
--- a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
+++ b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
@@ -29,7 +29,7 @@
 
 /**
  * Just to check if response is really gzipped
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GHGZIPHook extends GzipFilter
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index f8733bf554..9089973977 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -49,7 +49,7 @@
  * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
  * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
  * used otherwise. See the full API response format in docs/web/api-doc.md
- * <p/>
+ * <p>
  *
  * @author Peter Karich
  */
@@ -63,7 +63,7 @@
     @Override
     public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
     {
-        List<GHPoint> infoPoints = getPoints(httpReq, "point");
+        List<GHPoint> requestPoints = getPoints(httpReq, "point");
         GHResponse ghRsp = new GHResponse();
 
         // we can reduce the path length based on the maximum differences to the original coordinates
@@ -95,9 +95,10 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
         } else if (enableElevation && !hopper.hasElevation())
         {
             ghRsp.addError(new IllegalArgumentException("Elevation not supported!"));
-        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != infoPoints.size())
+        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
         {
-            ghRsp.addError(new IllegalArgumentException("number of headings must be <= 1 or equal number of points"));
+            ghRsp.addError(new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
+                    + "or equal to the number of points (" + requestPoints.size() + ")"));
         }
         if (!ghRsp.hasErrors())
         {
@@ -109,17 +110,17 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
                 // if only one favored heading is specified take as start heading
                 if (favoredHeadings.size() == 1)
                 {
-                    List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(infoPoints.size(),
+                    List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(requestPoints.size(),
                             Double.NaN));
                     paddedHeadings.set(0, favoredHeadings.get(0));
-                    request = new GHRequest(infoPoints, paddedHeadings);
+                    request = new GHRequest(requestPoints, paddedHeadings);
                 } else
                 {
-                    request = new GHRequest(infoPoints, favoredHeadings);
+                    request = new GHRequest(requestPoints, favoredHeadings);
                 }
             } else
             {
-                request = new GHRequest(infoPoints);
+                request = new GHRequest(requestPoints);
             }
 
             initHints(request, httpReq.getParameterMap());
@@ -137,7 +138,7 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) thr
 
         float took = sw.stop().getSeconds();
         String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
-        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + requestPoints + ", took:"
                 + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
         httpRes.setHeader("X-GH-Took", "" + Math.round(took * 1000));
 
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index f75bdfee4a..9adbf0d577 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -32,7 +32,7 @@
 
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GraphHopperWeb implements GraphHopperAPI
diff --git a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
index 830e6e03cd..617828eb68 100644
--- a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
+++ b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
@@ -25,9 +25,9 @@
 
 /**
  * Replacement of web.xml used only for container deployment. Preferred method is to use GHServer.
- * <p/>
+ * <p>
  * http://code.google.com/p/google-guice/wiki/ServletModule
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class GuiceServletConfig extends GuiceServletContextListener
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 8b92431524..46777addb3 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -28,8 +28,6 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import static javax.servlet.http.HttpServletResponse.*;
-
 import org.json.JSONObject;
 
 /**
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
index b6076883a4..73762ceb69 100644
--- a/web/src/main/java/com/graphhopper/http/IPFilter.java
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -11,11 +11,11 @@
 
 /**
  * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
- * <p/>
+ * <p>
  * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
- * <p/>
+ * <p>
  * The internal ip filter from jetty did not work (NP exceptions)
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class IPFilter implements Filter
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 626ba5f6d8..9fe1792252 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -31,8 +31,6 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
 
 import org.json.JSONObject;
 
@@ -47,7 +45,7 @@
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        BBox bb = hopper.getGraph().getBounds();
+        BBox bb = hopper.getGraphHopperStorage().getBounds();
         List<Double> list = new ArrayList<Double>(4);
         list.add(bb.minLon);
         list.add(bb.minLat);
@@ -57,7 +55,7 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         JSONObject json = new JSONObject();
         json.put("bbox", list);
 
-        String[] vehicles = hopper.getGraph().getEncodingManager().toString().split(",");
+        String[] vehicles = hopper.getGraphHopperStorage().getEncodingManager().toString().split(",");
         json.put("supported_vehicles", vehicles);
         JSONObject features = new JSONObject();
         for (String v : vehicles)
@@ -71,7 +69,7 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         json.put("version", Constants.VERSION);
         json.put("build_date", Constants.BUILD_DATE);
 
-        StorableProperties props = hopper.getGraph().getProperties();
+        StorableProperties props = hopper.getGraphHopperStorage().getProperties();
         json.put("import_date", props.get("osmreader.import.date"));
 
         if (!Helper.isEmpty(props.get("prepare.date")))
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index 1890d9628b..d28ca157f9 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -35,7 +35,7 @@
 
 /**
  * Online request for (reverse) geocoding.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class NominatimGeocoder implements Geocoding, ReverseGeocoding
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
index 06cbe5cfe1..627b47b3a3 100644
--- a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -1,7 +1,19 @@
 /*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 package com.graphhopper.http;
 
@@ -14,7 +26,7 @@
 
 /**
  *
- * @author peterk
+ * @author Peter Karich
  */
 public class SimpleRouteSerializer implements RouteSerializer
 {
@@ -27,27 +39,28 @@ public SimpleRouteSerializer( BBox maxBounds )
 
     @Override
     public Map<String, Object> toJSON( GHResponse rsp,
-                                          boolean calcPoints, boolean pointsEncoded,
-                                          boolean includeElevation, boolean enableInstructions )
+                                       boolean calcPoints, boolean pointsEncoded,
+                                       boolean includeElevation, boolean enableInstructions )
     {
         Map<String, Object> json = new HashMap<String, Object>();
 
         if (rsp.hasErrors())
         {
             json.put("message", rsp.getErrors().get(0).getMessage());
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
+            List<Map<String, String>> errorHintList = new ArrayList<Map<String, String>>();
             for (Throwable t : rsp.getErrors())
             {
                 Map<String, String> map = new HashMap<String, String>();
                 map.put("message", t.getMessage());
                 map.put("details", t.getClass().getName());
-                list.add(map);
+                errorHintList.add(map);
             }
-            json.put("hints", list);
+            json.put("hints", errorHintList);
         } else
         {
             Map<String, Object> jsonInfo = new HashMap<String, Object>();
             json.put("info", jsonInfo);
+            json.put("hints", rsp.getHints().toMap());
             jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
             Map<String, Object> jsonPath = new HashMap<String, Object>();
             jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 8a5aaeba92..8497226780 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -27,11 +27,11 @@
 
 /**
  * Code which handles polyline encoding and other web stuff.
- * <p/>
+ * <p>
  * The necessary information for polyline encoding is in this answer:
  * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
  * good explanation.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class WebHelper
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 5dec96119a..c5a44745b2 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -37,24 +37,18 @@ if (!Function.prototype.bind) {
 }
 
 GHRequest = function (host) {
-    this.way_point_max_distance = 1;
     this.host = host;
     this.route = new GHroute(new GHInput(), new GHInput());
     this.from = this.route.first();
     this.to = this.route.last();
-    this.vehicle = "car";
-    this.weighting = "fastest";
-    this.points_encoded = true;
-    this.instructions = true;
-    this.elevation = false;
+
     this.features = {};
-    this.debug = false;
-    this.locale = "en";
+
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
-    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
-    this.api_params = [];
+
+    this.api_params = {"locale": "en", "vehicle": "car", "weighting": "fastest", "elevation": false};
 
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
@@ -78,11 +72,7 @@ GHRequest = function (host) {
         this.to = this.route.last();
         log("Foo just moved.");
     }.bind(this));
-//    this.route.addListener('route.set', function (evt) {
-//        this.from = this.route.first();
-//        this.to = this.route.last();
-//        log("Foo just moved.");
-//    }.bind(this));
+    
     this.route.addListener('route.reverse', function (evt) {
         this.from = this.route.first();
         this.to = this.route.last();
@@ -306,6 +296,7 @@ GHroute.prototype = {
 };
 
 GHRequest.prototype.init = function (params) {
+
     for (var key in params) {
         var val = params[key];
         if (val === "false")
@@ -313,45 +304,23 @@ GHRequest.prototype.init = function (params) {
         else if (val === "true")
             val = true;
 
-        // todo
-        // this[key] = val;
+        if (key === "point" || key === "mathRandom" || key === "do_zoom" || key === "layer")
+            continue;
 
-        if (key.indexOf('api.') === 0) {
-            key = key.substring(4);
-            if (GHroute.isArray(val))
-                this.api_params[key] = val;
-            else
-                this.api_params[key] = [val];
-        }
+        this.api_params[key] = val;
     }
 
-    if (params.minPathPrecision)
-        this.minPathPrecision = params.minPathPrecision;
-    if (params.vehicle)
-        this.vehicle = params.vehicle;
-    if (params.weighting)
-        this.weighting = params.weighting;
-    if (params.algorithm)
-        this.algorithm = params.algorithm;
-    if (params.locale)
-        this.locale = params.locale;
-    if (params.key)
-        this.key = params.key;
-
     if ('do_zoom' in params)
         this.do_zoom = params.do_zoom;
-    if ('instructions' in params)
-        this.instructions = params.instructions;
-    if ('points_encoded' in params)
-        this.points_encoded = params.points_encoded;
 
-    this.elevation = false;
-    var featureSet = this.features[this.vehicle];
+    // overwrite elevation e.g. important if not supported from feature set
+    this.api_params.elevation = false;
+    var featureSet = this.features[params.vehicle];
     if (featureSet && featureSet.elevation) {
         if ('elevation' in params)
-            this.elevation = params.elevation;
+            this.api_params.elevation = params.elevation;
         else
-            this.elevation = true;
+            this.api_params.elevation = true;
     }
 
     if (params.q) {
@@ -383,16 +352,21 @@ GHRequest.prototype.init = function (params) {
 };
 
 GHRequest.prototype.initVehicle = function (vehicle) {
-    this.vehicle = vehicle;
-    var featureSet = this.features[this.vehicle];
+    this.api_params.vehicle = vehicle;
+    var featureSet = this.features[vehicle];
+
     if (featureSet && featureSet.elevation)
-        this.elevation = true;
+        this.api_params.elevation = true;
     else
-        this.elevation = false;
+        this.api_params.elevation = false;
 };
 
 GHRequest.prototype.hasElevation = function () {
-    return this.elevation;
+    return this.api_params.elevation;
+};
+
+GHRequest.prototype.getVehicle = function () {
+    return this.api_params.vehicle;
 };
 
 GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
@@ -436,35 +410,15 @@ GHRequest.prototype.createPointParams = function (useRawInput) {
 };
 
 GHRequest.prototype.createPath = function (url) {
-    if (this.vehicle && this.vehicle !== "car")
-        url += "&vehicle=" + this.vehicle;
-    // fastest or shortest
-    if (this.weighting && this.weighting !== "fastest")
-        url += "&weighting=" + this.weighting;
-    if (this.locale && this.locale !== "en")
-        url += "&locale=" + this.locale;
-    // dijkstra, dijkstrabi, astar, astarbi
-    if (this.algorithm && this.algorithm !== "dijkstrabi")
-        url += "&algorithm=" + this.algorithm;
-    if (this.way_point_max_distance !== 1)
-        url += "&way_point_max_distance=" + this.way_point_max_distance;
-    if (!this.instructions)
-        url += "&instructions=false";
-    if (!this.points_encoded)
-        url += "&points_encoded=false";
-
-    if (this.elevation)
-        url += "&elevation=true";
-    if (this.debug)
-        url += "&debug=true";
-
     for (var key in this.api_params) {
-        // entries in api_params are all arrays
-        var arr = this.api_params[key];
-        if (GHroute.isArray(arr))
-            for (var keyIndex in arr) {
-                url += "&" + key + "=" + arr[keyIndex];
+        var val = this.api_params[key];
+        if (GHroute.isArray(val)) {
+            for (var keyIndex in val) {
+                url += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(val[keyIndex]);
             }
+        } else {
+            url += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(val);
+        }
     }
     return url;
 };
@@ -642,7 +596,7 @@ GHInput.prototype.toString = function () {
 
 GHRequest.prototype.setLocale = function (locale) {
     if (locale)
-        this.locale = locale;
+        this.api_params.locale = locale;
 };
 
 GHRequest.prototype.fetchTranslationMap = function (urlLocaleParam) {
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 8c6086c96a..3a1a7ea638 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -401,7 +401,7 @@ function initMap(selectLayer) {
 
     var defaultLayer = baseMaps[selectLayer];
     if (!defaultLayer)
-        defaultLayer = lyrk;
+        defaultLayer = omniscale;
 
     // default
     map = L.map('map', {
@@ -909,9 +909,7 @@ function doGeoCoding(input, limit, timeout) {
         type: "GET",
         dataType: "json",
         timeout: timeout
-    }).fail(
-            createCallback("[nominatim] Problem while looking up location " + input)
-            );
+    }).fail(createCallback("[nominatim] Problem while looking up location " + input));
 }
 
 function createCallback(errorFallback) {
@@ -971,7 +969,7 @@ function routeLatLng(request, doQuery) {
     map.contextmenu.setDisabled(menuIntermediate, false);
 
     $("#vehicles button").removeClass("selectvehicle");
-    $("button#" + request.vehicle.toLowerCase()).addClass("selectvehicle");
+    $("button#" + request.getVehicle().toLowerCase()).addClass("selectvehicle");
 
     var urlForAPI = request.createURL();
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
@@ -1089,10 +1087,11 @@ function routeLatLng(request, doQuery) {
             var osmRouteLink = $("<br/><a>view on OSM</a>");
 
             var osmVehicle = "bicycle";
-            if (request.vehicle.toUpperCase() === "FOOT") {
+            if (request.getVehicle().toUpperCase() === "FOOT") {
                 osmVehicle = "foot";
             }
-            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
+            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" 
+                    + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
             hiddenDiv.append(osmRouteLink);
 
             var osrmLink = $("<a>OSRM</a>");
@@ -1102,11 +1101,11 @@ function routeLatLng(request, doQuery) {
             var googleLink = $("<a>Google</a> ");
             var addToGoogle = "";
             var addToBing = "";
-            if (request.vehicle.toUpperCase() === "FOOT") {
+            if (request.getVehicle().toUpperCase() === "FOOT") {
                 addToGoogle = "&dirflg=w";
                 addToBing = "&mode=W";
-            } else if ((request.vehicle.toUpperCase().indexOf("BIKE") >= 0) ||
-                    (request.vehicle.toUpperCase() === "MTB")) {
+            } else if ((request.getVehicle().toUpperCase().indexOf("BIKE") >= 0) ||
+                    (request.getVehicle().toUpperCase() === "MTB")) {
                 addToGoogle = "&dirflg=b";
                 // ? addToBing = "&mode=B";
             }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index fef0887478..929367fab8 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -74,7 +74,7 @@ public void testBasicQuery() throws Exception
     public void testQuerywithDirections() throws Exception
     {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
-        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240", 200);
+        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240&force_heading_ch=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index ac1dcc44f0..e9bd301808 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -114,6 +114,17 @@ describe("utils", function () {
         ghRequest.features = {"car": {elevation: false}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
+
+        ghRequest = new GHRequest("http://test.de");
+        var params = {point: [[4, 3], [2, 3]], test: "x", test_array: [1, 2]};
+        ghRequest.init(params);
+        
+        // skip point, layer etc
+        expect(ghRequest.api_params.point).toEqual(undefined);
+
+        // include all other parameters
+        expect(ghRequest.api_params.test).toEqual("x");
+        expect(ghRequest.api_params.test_array).toEqual([1, 2]);
     });
 
     it("ghrequest should init correctly from params", function () {
