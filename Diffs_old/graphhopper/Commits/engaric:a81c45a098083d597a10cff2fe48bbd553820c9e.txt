diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index da915bd86f..3d8c8d9014 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,4 @@
-0.4.0    
+0.4.0
     astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
     making GPX export according to the schema to support import from various tools like basecamp
     refactoring: AllEdgesIterator.getMaxId is now named getCount
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index f4f37617b2..b552261124 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -4,6 +4,21 @@ If you just start to use GraphHopper please refer to [routing docs](./routing.md
 or [the quickstart for developers](./quickstart-from-source.md)
 and come back here later if the higher level API does not suit your needs.
 
+### What are pillar and tower nodes?
+
+From road network sources like OpenStreetMap we fetch all nodes and create the routing graph but 
+only a sub-set of them are actual junctions, which are the ones we are interested in while routing.
+
+Those junction nodes (and end-standing nodes of dead alleys) we call *tower nodes* which also 
+have a graphhopper node ID associated, going from 0 to graph.getNodes(). 
+The helper nodes between the junctions we call 'pillar nodes' which can be fetched via
+`edgeIteratorState.fetchWayGeometry(0)`. Avoiding the traversal of pillar nodes while routing makes 
+routing a lot faster (~8 times).
+
+That splitting into pillar and tower nodes is also the reason why there can't be a unique mapping from 
+one OSM node ID to exactly one GraphHopper node ID. And as one OSM Way is often splitted into multiple 
+edges the same applies for edge IDs too.
+
 ### Create and save the graph
 
 ```java
