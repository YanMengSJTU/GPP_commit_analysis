diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index 4335aa22d6..d15882dc6d 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -25,7 +25,7 @@
     <artifactId>directions-api-client-hc</artifactId>
     <version>0.10-SNAPSHOT</version>
     <packaging>jar</packaging>
-    <name>GraphHopper Directions API hand-crafted Java Client. For the Matrix and Routing API only</name>
+    <name>GraphHopper Directions API hand-crafted Java Client.</name>
      
     <parent>
         <groupId>com.graphhopper</groupId>
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
new file mode 100644
index 0000000000..c351156485
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
@@ -0,0 +1,138 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.api.model.GHGeocodingRequest;
+import com.graphhopper.api.model.GHGeocodingResponse;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Client implementation for the GraphHopper Directions API Geocoding. For details on how to use it, please consult
+ * the documentation at: https://graphhopper.com/api/1/docs/geocoding/.
+ * <p>
+ * Signup for a free API key at: https://graphhopper.com
+ *
+ * @author Robin Boldt
+ */
+public class GraphHopperGeocoding {
+
+    private final ObjectMapper objectMapper;
+    private OkHttpClient downloader;
+    private String routeServiceUrl;
+    private String key = "";
+
+    private final long DEFAULT_TIMEOUT = 5000;
+
+    public GraphHopperGeocoding() {
+        this("https://graphhopper.com/api/1/geocode");
+    }
+
+    /**
+     * This method allows you to point the client to a different URL than the default one.
+     *
+     * @param serviceUrl Geocoding endpoint that is compatible with the GraphHopper geocoding API
+     */
+    public GraphHopperGeocoding(String serviceUrl) {
+        this.routeServiceUrl = serviceUrl;
+        downloader = new OkHttpClient.Builder().
+                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                build();
+
+        objectMapper = new ObjectMapper();
+    }
+
+    /**
+     * Perform a geocoding request. Both forward and revers are possible, just configure the <code>request</code>
+     * accordingly.
+     *
+     * @param request the request to send to the API
+     * @return found results for your request
+     */
+    public GHGeocodingResponse geocode(GHGeocodingRequest request) {
+        String url = buildUrl(request);
+
+        try {
+            Request okRequest = new Request.Builder().url(url).build();
+            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            return objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem performing geocoding for " + url + ": " + ex.getMessage(), ex);
+        }
+    }
+
+    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {
+        this.downloader = downloader;
+        return this;
+    }
+
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    public OkHttpClient getDownloader() {
+        return downloader;
+    }
+
+    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {
+        OkHttpClient client = this.downloader;
+        if (request.hasTimeout()) {
+            long timeout = request.getTimeout();
+            client = client.newBuilder()
+                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .readTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .build();
+        }
+
+        return client;
+    }
+
+    private String buildUrl(GHGeocodingRequest request) {
+        String url = routeServiceUrl + "?";
+
+        if (request.isReverse()) {
+            if (!request.getPoint().isValid())
+                throw new IllegalArgumentException("For reverse geocoding you have to pass valid lat and long values");
+            url += "reverse=true";
+        } else {
+            if (request.getQuery() == null)
+                throw new IllegalArgumentException("For forward geocoding you have to a string for the query");
+            url += "reverse=false";
+            url += "&q=" + request.getQuery();
+        }
+
+        if (request.getPoint().isValid())
+            url += "&point=" + request.getPoint().getLat() + "," + request.getPoint().getLon();
+
+        url += "&limit=" + request.getLimit();
+        url += "&locale=" + request.getLocale();
+        url += "&provider=" + request.getProvider();
+
+        if (!key.isEmpty()) {
+            url += "&key=" + WebHelper.encodeURL(key);
+        }
+
+        return url;
+    }
+
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java
new file mode 100644
index 0000000000..c4242cfdef
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java
@@ -0,0 +1,210 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * Contains the results of a geocoding request.
+ * This is a copy of: https://github.com/graphhopper/geocoder-converter/blob/master/src/main/java/com/graphhopper/converter/api/GHResponse.java
+ *
+ * @author Robin Boldt
+ * @author Peter Karich
+ */
+@JsonInclude(JsonInclude.Include.NON_NULL)
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class GHGeocodingEntry {
+
+    private Long osmId;
+    private String osmType;
+
+    private Point point;
+
+    private String name;
+    private String country;
+    private String city;
+    private String state;
+    private String street;
+    private String houseNumber;
+    private String postcode;
+    private String osmValue;
+
+    public GHGeocodingEntry(Long osmId, String type, double lat, double lng, String name, String osmValue, String country, String city, String state, String street, String houseNumber, String postcode) {
+        this.osmId = osmId;
+        this.osmType = type;
+        this.point = new Point(lat, lng);
+        this.name = name;
+        this.country = country;
+        this.city = city;
+        this.state = state;
+        this.street = street;
+        this.houseNumber = houseNumber;
+        this.postcode = postcode;
+        this.osmValue = osmValue;
+    }
+
+    public GHGeocodingEntry() {
+    }
+
+    @JsonProperty
+    public String getName() {
+        return name;
+    }
+
+    @JsonProperty
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @JsonProperty
+    public String getCountry() {
+        return country;
+    }
+
+    @JsonProperty
+    public void setCountry(String country) {
+        this.country = country;
+    }
+
+    @JsonProperty
+    public void setState(String state) {
+        this.state = state;
+    }
+
+    @JsonProperty
+    public String getState() {
+        return state;
+    }
+
+    @JsonProperty
+    public String getCity() {
+        return city;
+    }
+
+    @JsonProperty
+    public void setCity(String city) {
+        this.city = city;
+    }
+
+    @JsonProperty
+    public Point getPoint() {
+        return point;
+    }
+
+    @JsonProperty
+    public void setPoint(Point point) {
+        this.point = point;
+    }
+
+    @JsonProperty("osm_id")
+    public Long getOsmId() {
+        return osmId;
+    }
+
+    @JsonProperty("osm_id")
+    public void setOsmId(Long osmId) {
+        this.osmId = osmId;
+    }
+
+    @JsonProperty("osm_type")
+    public String getOsmType() {
+        return osmType;
+    }
+
+    @JsonProperty("osm_type")
+    public void setOsmType(String type) {
+        this.osmType = type;
+    }
+
+    @JsonProperty
+    public String getStreet() {
+        return street;
+    }
+
+    @JsonProperty
+    public void setStreet(String street) {
+        this.street = street;
+    }
+
+    @JsonProperty("house_number")
+    public String getHouseNumber() {
+        return houseNumber;
+    }
+
+    @JsonProperty("house_number")
+    public void setHouseNumber(String houseNumber) {
+        this.houseNumber = houseNumber;
+    }
+
+    @JsonProperty
+    public String getPostcode() {
+        return postcode;
+    }
+
+    @JsonProperty
+    public void setPostcode(String postcode) {
+        this.postcode = postcode;
+    }
+
+    @JsonProperty("osm_value")
+    public String getOsmValue() {
+        return osmValue;
+    }
+
+    @JsonProperty("osm_value")
+    public void setOsmValue(String osmValue) {
+        this.osmValue = osmValue;
+    }
+
+    public class Point {
+
+        private double lat;
+        private double lng;
+
+        public Point(double lat, double lng) {
+            this.lat = lat;
+            this.lng = lng;
+        }
+
+        public Point() {
+        }
+
+        @JsonProperty
+        public double getLat() {
+            return lat;
+        }
+
+        @JsonProperty
+        public void setLat(double lat) {
+            this.lat = lat;
+        }
+
+        @JsonProperty
+        public double getLng() {
+            return lng;
+        }
+
+        @JsonProperty
+        public void setLng(double lng) {
+            this.lng = lng;
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java
new file mode 100644
index 0000000000..f966f15bf7
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java
@@ -0,0 +1,106 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+/**
+ * A geocoding request following https://graphhopper.com/api/1/docs/geocoding/
+ *
+ * @author Robin Boldt
+ */
+public class GHGeocodingRequest {
+
+    private final boolean reverse;
+
+    private final GHPoint point;
+
+    private final String query;
+
+    private final String locale;
+    private final int limit;
+    private final String provider;
+    private final long timeout;
+
+    /**
+     * This is a wrapper to build a reverse geocoding request
+     */
+    public GHGeocodingRequest(double lat, double lon, String locale, int limit) {
+        this(true, new GHPoint(lat, lon), null, locale, limit, "default", -1);
+    }
+
+    /**
+     * This is a wrapper to build a reverse geocoding request
+     */
+    public GHGeocodingRequest(GHPoint point, String locale, int limit) {
+        this(true, point, null, locale, limit, "default", -1);
+    }
+
+    /**
+     * This is a wrapper to build a forward geocoding request
+     */
+    public GHGeocodingRequest(String query, String locale, int limit) {
+        this(false, null, query, locale, limit, "default", -1);
+    }
+
+    public GHGeocodingRequest(boolean reverse, GHPoint point, String query, String locale, int limit, String provider, long timeout) {
+        this.reverse = reverse;
+        if (point == null) {
+            this.point = new GHPoint();
+        } else {
+            this.point = point;
+        }
+        this.query = query;
+        this.locale = locale;
+        this.limit = limit;
+        this.provider = provider;
+        this.timeout = timeout;
+    }
+
+    public boolean isReverse() {
+        return reverse;
+    }
+
+    public GHPoint getPoint() {
+        return point;
+    }
+
+    public String getQuery() {
+        return query;
+    }
+
+    public String getLocale() {
+        return locale;
+    }
+
+    public int getLimit() {
+        return limit;
+    }
+
+    public String getProvider() {
+        return provider;
+    }
+
+    public boolean hasTimeout() {
+        return this.timeout > 0;
+    }
+
+    public long getTimeout() {
+        return timeout;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java
new file mode 100644
index 0000000000..c69f04b82e
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java
@@ -0,0 +1,80 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains the results of a geocoding request.
+ * This is a copy of: https://github.com/graphhopper/geocoder-converter/blob/master/src/main/java/com/graphhopper/converter/api/GHResponse.java
+ *
+ * @author Robin Boldt
+ * @author Peter Karich
+ */
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class GHGeocodingResponse {
+
+    private List<String> copyrights = new ArrayList<String>(5);
+    private List<GHGeocodingEntry> hits;
+    private String locale = "en";
+
+    public GHGeocodingResponse() {
+        this(5);
+    }
+
+    public GHGeocodingResponse(int no) {
+        hits = new ArrayList<>(no);
+    }
+
+    public void setCopyrights(List<String> copyrights) {
+        this.copyrights = copyrights;
+    }
+
+    public List<String> getCopyrights() {
+        return copyrights;
+    }
+
+    public GHGeocodingResponse addCopyright(String cr) {
+        copyrights.add(cr);
+        return this;
+    }
+
+    public void setHits(List<GHGeocodingEntry> hits) {
+        this.hits = hits;
+    }
+
+    public void add(GHGeocodingEntry entry) {
+        hits.add(entry);
+    }
+
+    public List<GHGeocodingEntry> getHits() {
+        return hits;
+    }
+
+    public String getLocale() {
+        return locale;
+    }
+
+    public void setLocale(String locale) {
+        this.locale = locale;
+    }
+
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
new file mode 100644
index 0000000000..828f7d54c1
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
@@ -0,0 +1,71 @@
+package com.graphhopper.api;
+
+import com.graphhopper.api.model.GHGeocodingRequest;
+import com.graphhopper.api.model.GHGeocodingResponse;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.net.SocketTimeoutException;
+
+import static com.graphhopper.api.GraphHopperWebIT.KEY;
+import static org.junit.Assert.*;
+
+/**
+ * @author Robin Boldt
+ */
+public class GraphHopperGeocodingIT {
+
+    GraphHopperGeocoding geocoding = new GraphHopperGeocoding();
+
+    @Before
+    public void setUp() {
+        String key = System.getProperty("graphhopper.key", KEY);
+        geocoding.setKey(key);
+    }
+
+    @Test
+    public void testForwardGeocoding() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("Berlin", "en", 7));
+        assertEquals(7, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testForwardGeocodingNominatim() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "nominatim", 5000));
+        assertEquals(5, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testReverseGeocoding() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(52.5170365, 13.3888599, "en", 5));
+        assertEquals(5, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testTimeout() {
+        try {
+            // We set the timeout to 1ms, it shouldn't be possible for the API to answer that quickly => we will receive a SocketTimeout
+            geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "default", 1));
+        } catch (RuntimeException e) {
+            if (e.getCause() instanceof SocketTimeoutException) {
+                return;
+            }
+        }
+        fail();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testForwardException() {
+        geocoding.geocode(new GHGeocodingRequest(false, new GHPoint(1, 1), null, "en", 5, "default", 1));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testBackwadException() {
+        geocoding.geocode(new GHGeocodingRequest(true, null, "Berlin", "en", 5, "default", 1));
+    }
+
+}
