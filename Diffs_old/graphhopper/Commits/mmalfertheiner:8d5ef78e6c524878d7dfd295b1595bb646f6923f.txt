diff --git a/.gitignore b/.gitignore
index ab07f17340..3731f11fbf 100644
--- a/.gitignore
+++ b/.gitignore
@@ -36,3 +36,4 @@ android/.gradle
 .classpath
 .project
 local.properties
+tracks/
diff --git a/core/pom.xml b/core/pom.xml
index 949b694ccf..beae148e52 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -91,6 +91,20 @@
             <version>20140107</version>
             <scope>test</scope>
         </dependency>
+
+        <!-- for using profiles -->
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>map-matching</artifactId>
+            <!-- or 0.6-SNAPSHOT for the unstable -->
+            <version>0.5.0.0</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-math3</artifactId>
+            <version>3.5</version>
+        </dependency>
         
     </dependencies>
         
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 4aafec5530..652481f07c 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1110,7 +1110,7 @@ public GHResponse route( GHRequest request )
             Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
 
             //Update time to profile of user
-            path.updateTime();
+            path.updateTime(request.getHints());
 
             if (path.getTime() < 0)
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 40d0c00d30..fc4650df87 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -371,7 +371,8 @@ void processWay( OSMWay way )
             }
 
             //Kalman filter improves quality of elevation data - check for Kalman
-            if(true) {
+            boolean kalman = true;
+            if(kalman) {
 
                 double[] tmpElevations = new double[osmNodeIds.size()];
                 double[] tmpDistances = new double[osmNodeIds.size()-1];
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index e239cf4c63..a0a939e2f6 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -353,5 +353,7 @@ public static void main( String[] args )
 
         // 0
         System.out.println(provider.getEle(29.840644, -42.890625));
+
+        System.out.println(provider.getEle(50.477121, 8.051915));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 5d16cebe9a..da743c3580 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,14 +17,13 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.BikeGenericFlagEncoder;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.DynamicWeighting;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
 
@@ -370,16 +369,23 @@ public void next( EdgeIteratorState eb, int index )
         return points;
     }
 
-    public void updateTime(){
+    public void updateTime(PMap params){
 
         time = 0;
+        String profileName = params.get("profile", "");
+        RidersProfile ridersProfile = null;
+
+        if(!profileName.equals(""))
+            ridersProfile = new ProfileManager().getProfile(profileName);
+
+        final SpeedProvider speedProvider = new ProfileSpeedProvider(encoder, ridersProfile);
 
         forEveryEdge(new EdgeVisitor() {
 
             @Override
             public void next(EdgeIteratorState edgeBase, int index) {
 
-                double speed = encoder.getSpeed(edgeBase.getFlags());
+                double speed = speedProvider.calcSpeed(edgeBase, false);
 
                 if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
                     throw new IllegalStateException("Invalid speed stored in edge! " + speed);
@@ -387,9 +393,6 @@ public void next(EdgeIteratorState edgeBase, int index) {
                 if (speed == 0)
                     throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
 
-
-                speed = adjustSpeed(speed, edgeBase, false);
-
                 double edgeTime = edgeBase.getDistance() / speed * 3600;
 
                 // add direction penalties at start/stop/via points
@@ -403,40 +406,6 @@ public void next(EdgeIteratorState edgeBase, int index) {
 
     }
 
-    private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean reverse) {
-
-        double incElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY) / 100;
-        double decElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY) / 100;
-        double incDistPercentage = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
-
-
-        double incDist2DSum = edgeState.getDistance() * incDistPercentage;
-        double decDist2DSum = edgeState.getDistance() - incDist2DSum;
-
-        double adjustedSpeed = speed;
-
-        if (!reverse)
-        {
-            // use weighted mean so that longer incline infuences speed more than shorter
-            double fwdFaster = 1 + 30 * keepIn(decElevation, 0, 0.1);
-            fwdFaster = Math.sqrt(fwdFaster);
-            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
-            fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
-        } else {
-            double fwdFaster = 1 + 30 * keepIn(incElevation, 0, 0.1);
-            fwdFaster = Math.sqrt(fwdFaster);
-            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
-            fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
-        }
-        System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation +
-                ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage +
-                ", INC DIST: " + incDist2DSum + ", DEC DIST: " + decDist2DSum);
-
-        return adjustedSpeed;
-    }
-
     /**
      * @return the list of instructions for this path.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
index c8a3854c65..8e599ec7e0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
@@ -21,6 +21,10 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
+
+import java.util.Map;
 
 import static com.graphhopper.util.Helper.keepIn;
 
@@ -36,13 +40,11 @@
     final static double DEFAULT_HEADING_PENALTY = 300; //[s]
     private final double heading_penalty;
     protected final FlagEncoder flagEncoder;
-    private final double maxSpeed;
-    private String user = "martin";
+    protected RidersProfile profile;
 
     /**
      * For now used only in BikeGenericFlagEncoder
      */
-    public static final int PRIORITY_KEY = 101;
     public static final int INC_SLOPE_KEY = 102;
     public static final int DEC_SLOPE_KEY = 103;
     public static final int INC_DIST_PERCENTAGE_KEY = 104;
@@ -56,7 +58,9 @@ public DynamicWeighting(FlagEncoder encoder, PMap pMap)
 
         this.flagEncoder = encoder;
         heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
-        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
+        String user = pMap.get("profile", "");
+        profile = new ProfileManager().getProfile(user);
+
     }
 
     public DynamicWeighting(FlagEncoder encoder)
@@ -67,13 +71,13 @@ public DynamicWeighting(FlagEncoder encoder)
     @Override
     public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
-        double speed = flagEncoder.getSpeed(edgeState.getFlags());
+        SpeedProvider speedProvider = new ProfileSpeedProvider(flagEncoder, profile);
+
+        double speed = speedProvider.calcSpeed(edgeState, reverse);
 
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
 
-        speed = adjustSpeed(speed, edgeState, reverse);
-
         double time = edgeState.getDistance() / speed * SPEED_CONV;
 
         // add direction penalties at start/stop/via points
@@ -84,13 +88,6 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
         return time / (0.5 + getUserPreference(edgeState));
     }
 
-    private double getUserSpeed(EdgeIteratorState edgeState){
-        int wayType = (int) flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.WAY_TYPE_KEY);
-
-        return 0;
-    }
-
-
     private double getUserPreference(EdgeIteratorState edgeState) {
 
         int wayType = (int) flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.WAY_TYPE_KEY);
@@ -124,41 +121,9 @@ else if(wayType >= 10 && wayType <= 12) {
 
     }
 
-    private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean reverse) {
-
-        double incElevation = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY) / 100;
-        double decElevation = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY) / 100;
-        double incDistPercentage = flagEncoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
-
-        double incDist2DSum = edgeState.getDistance() * incDistPercentage;
-        double decDist2DSum = edgeState.getDistance() - incDist2DSum;
-
-        double adjustedSpeed = speed;
-
-        if (!reverse)
-        {
-            // use weighted mean so that longer incline infuences speed more than shorter
-            double fwdFaster = 1 + 30 * keepIn(decElevation, 0, 0.1);
-            fwdFaster = Math.sqrt(fwdFaster);
-            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
-            fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
-        } else {
-            double fwdFaster = 1 + 30 * keepIn(incElevation, 0, 0.1);
-            fwdFaster = Math.sqrt(fwdFaster);
-            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
-            fwdSlower = fwdSlower * fwdSlower;
-            adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
-        }
-
-        //System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation + ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage);
-
-        return adjustedSpeed;
-    }
-
     @Override
     public double getMinWeight(double distance) {
-        return distance / maxSpeed;
+        return distance / flagEncoder.getMaxSpeed();
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/ProfileSpeedProvider.java b/core/src/main/java/com/graphhopper/routing/util/ProfileSpeedProvider.java
new file mode 100644
index 0000000000..a5994af5a8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ProfileSpeedProvider.java
@@ -0,0 +1,108 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.profiles.RidersProfile;
+
+import java.util.Map;
+
+import static com.graphhopper.util.Helper.keepIn;
+
+public class ProfileSpeedProvider implements SpeedProvider {
+
+    protected final static double SPEED_CONV = 3.6;
+    protected final FlagEncoder encoder;
+    private final double maxSpeed;
+    private Map<Integer, double[]> userSpeeds;
+
+
+    public ProfileSpeedProvider(FlagEncoder flagEncoder, RidersProfile ridersProfile){
+        this.encoder = flagEncoder;
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
+
+        if(ridersProfile != null)
+            this.userSpeeds = ridersProfile.getFilterSpeeds();
+    }
+
+    @Override
+    public double calcSpeed(EdgeIteratorState edgeIteratorState, boolean reverse) {
+        return getUserSpeed(edgeIteratorState, reverse);
+    }
+
+    private double getUserSpeed(EdgeIteratorState edgeState, boolean reverse){
+
+        double speed = 0;
+        int wayType = (int) encoder.getDouble(edgeState.getFlags(), DynamicWeighting.WAY_TYPE_KEY);
+
+        if(userSpeeds != null){
+            double[] speeds = userSpeeds.get(wayType);
+            if(speeds != null){
+
+                int incElevation = (int)encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY);
+                int decElevation = (int)encoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY);
+                double incDistPercentage = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
+
+                int incIndex = incElevation > RidersProfile.SLOPES / 2 ? RidersProfile.SLOPES : RidersProfile.SLOPES / 2 + incElevation;
+                int decIndex = decElevation > RidersProfile.SLOPES / 2 ? 0 : RidersProfile.SLOPES / 2 - decElevation;
+
+                double incSpeed = speeds[incIndex];
+                double decSpeed = speeds[decIndex];
+
+                double incDist2DSum = edgeState.getDistance() * incDistPercentage;
+                double decDist2DSum = edgeState.getDistance() - incDist2DSum;
+
+                if (!reverse)
+                {
+                    speed = keepIn((incSpeed * incDist2DSum + decSpeed * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+                } else {
+                    speed = keepIn((decSpeed * incDist2DSum + incSpeed * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+                }
+
+            }
+
+        }
+
+        if(speed == 0){
+            speed = encoder.getSpeed(edgeState.getFlags());
+
+            if (speed == 0)
+                return 0;
+
+            speed = adjustSpeed(speed, edgeState, reverse);
+        }
+
+        return speed;
+    }
+
+    private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean reverse) {
+
+        double incElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_SLOPE_KEY) / 100;
+        double decElevation = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.DEC_SLOPE_KEY) / 100;
+        double incDistPercentage = encoder.getDouble(edgeState.getFlags(), DynamicWeighting.INC_DIST_PERCENTAGE_KEY) / 100;
+
+        double incDist2DSum = edgeState.getDistance() * incDistPercentage;
+        double decDist2DSum = edgeState.getDistance() - incDist2DSum;
+
+        double adjustedSpeed = speed;
+
+        if (!reverse)
+        {
+            // use weighted mean so that longer incline infuences speed more than shorter
+            double fwdFaster = 1 + 30 * keepIn(decElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
+            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
+            fwdSlower = fwdSlower * fwdSlower;
+            adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+        } else {
+            double fwdFaster = 1 + 30 * keepIn(incElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
+            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
+            fwdSlower = fwdSlower * fwdSlower;
+            adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
+        }
+
+        //System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation + ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage);
+
+        return adjustedSpeed;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/SpeedProvider.java b/core/src/main/java/com/graphhopper/routing/util/SpeedProvider.java
new file mode 100644
index 0000000000..fd9b414b92
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/SpeedProvider.java
@@ -0,0 +1,9 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public interface SpeedProvider {
+
+    double calcSpeed(EdgeIteratorState edgeIteratorState, boolean reverse);
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java b/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java
new file mode 100644
index 0000000000..043d2e7d78
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java
@@ -0,0 +1,199 @@
+package com.graphhopper.util.profiles;
+
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.matching.*;
+
+import com.graphhopper.reader.dem.HighPrecisionSRTMProvider;
+import com.graphhopper.routing.util.BikeGenericFlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class GPXDataExtractor {
+
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+
+    public static final int FILTER_KALMAN_FORWARD = 1;
+    public static final int FILTER_KALMAN_BACKWARD = 2;
+    public static final int FILTER_KALMAN_COMBINED = 3;
+    public static final int FILTER_MEAN = 4;
+
+    private List<GPXEntry> inputGPXEntries;
+    private List<TrackPart> trackParts;
+    private MapMatching mapMatching;
+    private BikeGenericFlagEncoder encoder;
+    private int filterType = FILTER_KALMAN_FORWARD;
+    private int filterDistance = 100;
+
+    private double[] distances;
+    private double[] elevations;
+
+    public GPXDataExtractor() {}
+
+    public void setFile(GPXFile gpxFile){
+        this.inputGPXEntries = gpxFile.getEntries();
+        this.distances = new double[inputGPXEntries.size() - 1];
+        this.elevations = new double[inputGPXEntries.size()];
+    }
+
+    public void configFilter(int filterType, int filterDistance) {
+        this.filterType = filterType;
+        this.filterDistance = filterDistance;
+    }
+
+    public void setupMapMatching(GraphHopper hopper){
+
+        // import OpenStreetMap data
+        /*CmdArgs args = CmdArgs.readFromConfig("config", "graphhopper.config");
+        GraphHopper hopper = new GraphHopper();
+        hopper.setOSMFile(pbfFileName);
+        String graphHopperLocation = Helper.pruneFileEnd(pbfFileName) + "-gh";
+        hopper.setGraphHopperLocation(graphHopperLocation);
+        encoder = new BikeGenericFlagEncoder();
+
+        hopper.setEncodingManager(new EncodingManager(encoder));
+        hopper.setElevation(true);
+        hopper.setElevationProvider(new HighPrecisionSRTMProvider());
+        hopper.setCHEnable(false);
+        hopper.setPreciseIndexResolution(300);
+        hopper.importOrLoad();
+        */
+
+        // create MapMatching object, can and should be shared accross threads
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
+        LocationIndexMatch locationIndex = new LocationIndexMatch(graph, (LocationIndexTree) hopper.getLocationIndex());
+        encoder = (BikeGenericFlagEncoder) hopper.getEncodingManager().getEncoder("generic_bike");
+
+        mapMatching = new MapMatching(graph, locationIndex, encoder);
+        mapMatching.setForceRepair(true);
+        mapMatching.setMaxSearchMultiplier(100);
+
+    }
+
+    public boolean isMapMatchingEnabled(){
+        return (mapMatching != null && encoder != null);
+    }
+
+    public List<TrackPart> extract(){
+
+        if(this.inputGPXEntries == null)
+            return Collections.emptyList();
+
+        processGPXData();
+
+        if(isMapMatchingEnabled())
+            processOSMData();
+
+        return trackParts;
+    }
+
+
+    private double[] filterMeasurements(final double[] measurements){
+
+        SmoothingFilter smoothingFilter;
+
+        switch(filterType){
+            case FILTER_KALMAN_FORWARD:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.FORWARD, 6, distances, filterDistance);
+                break;
+            case FILTER_KALMAN_BACKWARD:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.BACKWARD, 6, distances, filterDistance);
+                break;
+            case FILTER_KALMAN_COMBINED:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.COMBINED, 6, distances, filterDistance);
+                break;
+            case FILTER_MEAN:
+                smoothingFilter = new MeanFilter(distances, filterDistance);
+                break;
+            default:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.FORWARD, 6, distances, filterDistance);
+                break;
+        }
+
+        return smoothingFilter.smooth(measurements);
+
+    }
+
+
+    private void processGPXData(){
+
+        // 1. Step: Extract elevation and distance from GPX file
+
+        elevations[0] = inputGPXEntries.get(0).getEle();
+
+        for (int i = 1; i < inputGPXEntries.size(); i++) {
+
+            double firstLat = inputGPXEntries.get(i-1).getLat();
+            double firstLon = inputGPXEntries.get(i-1).getLon();
+            double secondLat = inputGPXEntries.get(i).getLat();
+            double secondLon = inputGPXEntries.get(i).getLon();
+
+            distances[i-1] = distCalc.calcDist(firstLat, firstLon, secondLat, secondLon);
+            System.out.print(", " + distances[i-1]);
+            elevations[i] = inputGPXEntries.get(i).getEle();
+
+        }
+
+        // 2. Step: Filter elevations
+        elevations = filterMeasurements(elevations);
+
+        // 3. Step: Split GPX into > 200 m track parts
+        List<GPXEntry> gpxEntryList;
+        trackParts = new ArrayList<TrackPart>();
+
+        for (int i = 0; i < inputGPXEntries.size(); i++){
+
+            int next = 1;
+            gpxEntryList = new ArrayList<GPXEntry>();
+            gpxEntryList.add(inputGPXEntries.get(i));
+            gpxEntryList.add(inputGPXEntries.get(i + next));
+
+            double distance = distances[i];
+            double elevation = elevations[i+next] - elevations[i];
+
+            while(distance < 200 && i+next+1 < inputGPXEntries.size()) {
+                next++;
+                gpxEntryList.add(inputGPXEntries.get(i+next));
+                distance += distances[i+next-1];
+                elevation += elevations[i+next] - elevations[i+next-1];
+            }
+
+            double slope = elevation / distance * 100;
+            distance = Math.sqrt((elevation * elevation) + (distance * distance)); // Update distance to 3D distance
+            double speed = distance / ((gpxEntryList.get(gpxEntryList.size() -1).getTime() - gpxEntryList.get(0).getTime()) / 1000) * 3.6;
+
+            trackParts.add(new TrackPart(gpxEntryList, distance, slope, speed));
+
+            if(i+next+1 == inputGPXEntries.size())
+                break;
+
+            i = i+next-1;
+
+        }
+
+    }
+
+    private void processOSMData() {
+
+        for (TrackPart tp : trackParts) {
+
+            try {
+                MatchResult mr = mapMatching.doWork(tp.getGpxEntryList());
+                List<EdgeMatch> matches = mr.getEdgeMatches();
+
+                for (EdgeMatch match : matches) {
+                    long flags = match.getEdgeState().getFlags();
+                    tp.setWayType((int) encoder.getWayType(flags));
+                }
+            } catch (Exception e) { // Skip track parts, which could not be matched to an edge in OSM}
+            }
+
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java b/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java
new file mode 100644
index 0000000000..86d8c274cd
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java
@@ -0,0 +1,124 @@
+package com.graphhopper.util.profiles;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.lang.ClassNotFoundException;
+import java.lang.Object;
+import java.lang.String;
+
+
+public class ProfileManager {
+
+
+    private RidersProfile ridersProfile;
+    private final String base = "profiles/";
+
+    public ProfileManager(){}
+
+    public void createProfile(String name) {
+        ridersProfile = new RidersProfile();
+
+        saveProfile(name);
+    }
+
+    public void readProfile(String name){
+
+        FileInputStream fileInputStream = null;
+        ObjectInputStream inputStream = null;
+        Object obj = null;
+
+        try {
+
+            fileInputStream = new FileInputStream(base + name);
+            inputStream = new ObjectInputStream (fileInputStream);
+            obj = inputStream.readObject();
+
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+
+            if(inputStream != null){
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if(fileInputStream != null){
+                try {
+                    fileInputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+        }
+
+
+        if (obj instanceof RidersProfile)
+        {
+            ridersProfile = (RidersProfile) obj;
+        }
+    }
+
+
+    public void saveProfile(String name){
+        if (ridersProfile == null)
+            return;
+
+        FileOutputStream fileOutputStream = null;
+        ObjectOutputStream outputStream = null;
+
+        try {
+            fileOutputStream = new FileOutputStream(base + name);
+            outputStream = new ObjectOutputStream(fileOutputStream);
+            outputStream.writeObject(ridersProfile);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if(outputStream != null) {
+                try {
+                    outputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if(fileOutputStream != null) {
+                try {
+                    fileOutputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+
+    public RidersProfile getProfile(String name){
+
+        if(name == null || name.equals(""))
+            return null;
+
+        if (ridersProfile == null) {
+            readProfile(name);
+        }
+
+        return ridersProfile;
+    }
+
+
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/Profiles.java b/core/src/main/java/com/graphhopper/util/profiles/Profiles.java
new file mode 100644
index 0000000000..31eeff26c6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/Profiles.java
@@ -0,0 +1,26 @@
+package com.graphhopper.util.profiles;
+
+import com.graphhopper.util.profiles.operations.*;
+
+public class Profiles {
+
+    public static void main(String[] args) {
+
+        String operationType = args[0];
+        Operation op = null;
+
+        System.out.println("Operation: " + args[0]);
+
+        if(operationType.equalsIgnoreCase("create")){
+            op = new CreateProfileOperation(args);
+        } else if (operationType.equalsIgnoreCase("add")){
+            op = new AddToProfileOperation(args);
+        } else if (operationType.equalsIgnoreCase("print")){
+            op = new PrintProfileOperation(args);
+        }
+
+        if(op != null)
+            op.run();
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java b/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java
new file mode 100644
index 0000000000..204f8183e0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java
@@ -0,0 +1,44 @@
+package com.graphhopper.util.profiles;
+
+import java.io.Serializable;
+import java.lang.IllegalArgumentException;
+import java.lang.String;
+
+public class RidersEntry implements Serializable{
+
+    private float speed = 0;
+    private float distance = 0;
+
+    public RidersEntry(){};
+
+    public void updateEntry(double speed, double distance) {
+
+        this.distance += distance;
+
+        if(this.distance == 0)
+            throw new IllegalArgumentException("Cannot update RidersEntry with distance equal to ZERO.");
+
+        this.speed = (float) ((this.speed * (this.distance - distance) + speed * distance) / this.distance);
+    }
+
+    @Override
+    public String toString() {
+        return "[s=" + speed + ", d=" + distance + "]";
+    }
+
+    public float getSpeed() {
+        return speed;
+    }
+
+    public void setSpeed(float speed) {
+        this.speed = speed;
+    }
+
+    public float getDistance() {
+        return distance;
+    }
+
+    public void setDistance(float distance) {
+        this.distance = distance;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java b/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java
new file mode 100644
index 0000000000..a7296fbdee
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java
@@ -0,0 +1,197 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.fitting.WeightedObservedPoint;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class RidersProfile implements Serializable{
+
+    public transient final static int WAY_TYPES = 16;
+    public transient final static int SLOPES = 60;
+
+    private RidersEntry[][] speedMatrix = new RidersEntry[WAY_TYPES][SLOPES+1]; // 16 Way types, Steigung von -30 % bis + 30 %
+    private double totalDistance;
+
+
+    public RidersProfile(){};
+
+    public RidersEntry getEntry(int wayType, int slope){
+        return speedMatrix[wayType][slope+(SLOPES/2)];
+    }
+
+    public RidersEntry[] getEntries(int wayType) {
+        return speedMatrix[wayType];
+    }
+
+    public Map<Integer, double[]> getFilterSpeeds(){
+
+        Map<Integer, double[]> speedMap = new HashMap<Integer, double[]>();
+
+        for( int i = 0; i < WAY_TYPES; i++ ){
+
+            if(getDistance(i) > 10000) {
+                speedMap.put(i, filterSpeeds(getEntries(i), i));
+            }
+
+        }
+
+        return speedMap;
+    }
+
+    private double[] filterSpeeds(RidersEntry[] ridersEntries, int wayType) {
+
+        ArrayList<WeightedObservedPoint> points = new ArrayList<WeightedObservedPoint>();
+
+        double maxSpeed = maxSpeed(wayType);
+
+        for ( int i = 0; i < ridersEntries.length; i++){
+            if(ridersEntries[i] != null) {
+                points.add(new WeightedObservedPoint(ridersEntries[i].getDistance(), i - SLOPES / 2, ridersEntries[i].getSpeed() / maxSpeed));
+            }
+        }
+
+        final double[] coef = new SigmoidalFitter(new double[]{1, 0.5, -1}).fit(points);
+        SigmoidFunction sigF = new SigmoidFunction();
+
+        double[] result = new double[SLOPES + 1];
+
+        int offset = SLOPES / 2;
+
+        for( int i = - offset; i < offset + 1; i++){
+            result[i + offset] = sigF.value(i, coef) * maxSpeed;
+        }
+
+        return result;
+    }
+
+    public double maxSpeed(int wayType){
+
+        double max = 0.0;
+
+        for (RidersEntry r : speedMatrix[wayType]){
+            if(r != null && r.getSpeed() > max)
+                max = r.getSpeed();
+        }
+
+        return max;
+    }
+
+
+    public double getSpeed(int wayType, int slope){
+
+        RidersEntry entry = getEntry(wayType, slope);
+
+        if(entry == null)
+            return Double.NaN;
+
+        return getEntry(wayType, slope).getSpeed();
+    }
+
+    public double getDistance(int wayType, int slope){
+
+        RidersEntry entry = getEntry(wayType, slope);
+
+        if(entry == null)
+            return 0.0;
+
+        return getEntry(wayType, slope).getDistance();
+    }
+
+    public double getDistance(int wayType){
+        double totalDist = 0;
+
+        for(int i = 0; i < speedMatrix[wayType].length; i++) {
+            if(speedMatrix[wayType][i] != null)
+                totalDist += speedMatrix[wayType][i].getDistance();
+        }
+
+        return totalDist;
+    }
+
+    public double getTotalDistance(){
+        return totalDistance;
+    }
+
+    public double[] getWayTypePriority(){
+
+        double[] distancesPerWayType = new double[WAY_TYPES];
+
+        for (int i = 0; i < speedMatrix.length; i++) {
+            for (int j = 0; j < speedMatrix[i].length; j++) {
+                distancesPerWayType[i] += getDistance(i, j - (SLOPES / 2));
+            }
+
+            distancesPerWayType[i] = distancesPerWayType[i] / totalDistance * 100;
+        }
+
+        return distancesPerWayType;
+
+    }
+
+    public void update(TrackPart trackPart) {
+
+        if(trackPart == null)
+            return;
+
+        int wayType = (int) trackPart.getWayType();
+        int slope = (int) trackPart.getSlope();
+
+        if (wayType < 0 || wayType > 15)
+            throw new IllegalArgumentException("Waytype must be between 0 and 15, but was: " + wayType);
+
+        if (slope < - (SLOPES/2))
+            slope = - (SLOPES/2);
+
+        if (slope > SLOPES/2)
+            slope = SLOPES/2;
+
+        RidersEntry ridersEntry = speedMatrix[wayType][slope+(SLOPES/2)];
+
+        if(ridersEntry == null) {
+            ridersEntry = new RidersEntry();
+            speedMatrix[wayType][slope+(SLOPES/2)] = ridersEntry;
+        }
+
+        ridersEntry.updateEntry(trackPart.getSpeed(), trackPart.getDistance());
+        totalDistance += trackPart.getDistance();
+
+    }
+
+    public int update(List<TrackPart> trackPartList) {
+
+        int skipped = 0;
+
+        for(TrackPart tp : trackPartList) {
+            try{
+                update(tp);
+            } catch(IllegalArgumentException i){
+                skipped++;
+            }
+        }
+
+        return skipped;
+
+    }
+
+    @Override
+    public java.lang.String toString() {
+
+        String riderString = "";
+
+        for (int i = 0; i < speedMatrix.length; i++) {
+            riderString += "-----[ " + i + " ]------ \n";
+            for (int j = 0; j < speedMatrix[i].length; j++) {
+                if(speedMatrix[i][j] != null)
+                    riderString += (j - SLOPES / 2) + ", " + speedMatrix[i][j].getSpeed() + ", " + speedMatrix[i][j].getDistance() + "\n";
+            }
+            riderString += "----------------------\n";
+        }
+
+        return riderString;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java b/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java
new file mode 100644
index 0000000000..a3bbc1c748
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java
@@ -0,0 +1,36 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.analysis.ParametricUnivariateFunction;
+import java.lang.Math;
+
+public class SigmoidFunction implements ParametricUnivariateFunction {
+
+    @Override
+    public double value(double x, double... params) {
+
+        double a = params[0];
+        double b = params[1];
+        double c = params[2];
+
+        double value = 1 - ( a / (1 + Math.exp(-b * (x - c))));
+
+        return value;
+    }
+
+    @Override
+    public double[] gradient(double x, double... params) {
+
+        double a = params[0];
+        double b = params[1];
+        double c = params[2];
+
+        double[] gradient = new double[3];
+
+        gradient[0] = - ( 1 / (Math.exp(b * ( c - x )) + 1));
+        gradient[1] = (a * ( c - x ) * Math.exp( -(b * ( x - c )))) / Math.pow(Math.exp( -(b * ( x - c ))) + 1, 2);
+        gradient[2] = (a * b * Math.exp( -(b * ( x - c )))) / Math.pow(Math.exp( -(b * ( x - c ))) + 1, 2);
+
+        return gradient;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java b/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java
new file mode 100644
index 0000000000..00f7ea0fef
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java
@@ -0,0 +1,116 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.fitting.AbstractCurveFitter;
+import org.apache.commons.math3.fitting.WeightedObservedPoint;
+import org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder;
+import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
+import org.apache.commons.math3.linear.DiagonalMatrix;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+
+public class SigmoidalFitter extends AbstractCurveFitter{
+
+    private double[] initialGuess;
+
+
+    public SigmoidalFitter(double[] initialGuess){
+        this.initialGuess = initialGuess;
+    }
+
+
+    @Override
+    protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> points) {
+
+
+        final int len = points.size();
+        final double[] target  = new double[len];
+        final double[] weights = new double[len];
+
+        int i = 0;
+
+        for(WeightedObservedPoint point : points) {
+            target[i]  = point.getY();
+            weights[i] = point.getWeight();
+            i += 1;
+        }
+
+        final AbstractCurveFitter.TheoreticalValuesFunction model = new
+                AbstractCurveFitter.TheoreticalValuesFunction(new SigmoidFunction(), points);
+
+        final DiagonalMatrix weightMatrix = new DiagonalMatrix(weights);
+
+        return new LeastSquaresBuilder().
+                maxEvaluations(Integer.MAX_VALUE).
+                maxIterations(Integer.MAX_VALUE).
+                start(initialGuess).
+                target(target).
+                weight(weightMatrix).
+                model(model.getModelFunction(), model.getModelFunctionJacobian()).
+                build();
+    }
+
+    public static void main(String[] args) {
+        SigmoidalFitter fitter = new SigmoidalFitter(new double[] {1, 0.5, -1});
+        ArrayList<WeightedObservedPoint> points = new ArrayList<WeightedObservedPoint>();
+
+        // Add points here; for instance,
+        WeightedObservedPoint point1 = new WeightedObservedPoint(222.0084, -11, 33.30126 / 37.36653);
+        WeightedObservedPoint point2 = new WeightedObservedPoint(409.9835, -10, 35.188465 / 37.36653);
+        WeightedObservedPoint point3 = new WeightedObservedPoint(1675.1172, -9, 35.625652 / 37.36653);
+        WeightedObservedPoint point4 = new WeightedObservedPoint(1075.3177, -8, 37.36653 / 37.36653);
+        WeightedObservedPoint point5 = new WeightedObservedPoint(60.274113, -7, 6.7808375 / 37.36653);
+        WeightedObservedPoint point6 = new WeightedObservedPoint(651.5845, -6, 28.758934 / 37.36653);
+        WeightedObservedPoint point7 = new WeightedObservedPoint(205.16458, -5, 30.774687 / 37.36653);
+        WeightedObservedPoint point8 = new WeightedObservedPoint(171.65067, -4, 30.89712 / 37.36653);
+        WeightedObservedPoint point9 = new WeightedObservedPoint(389.28305, -3, 24.898178 / 37.36653);
+        WeightedObservedPoint point10 = new WeightedObservedPoint(204.34619, -2, 13.880118 / 37.36653);
+        WeightedObservedPoint point11 = new WeightedObservedPoint(209.81961, -1, 11.989692 / 37.36653);
+        WeightedObservedPoint point12 = new WeightedObservedPoint(203.6042, 0, 15.595216 / 37.36653);
+        WeightedObservedPoint point13 = new WeightedObservedPoint(619.88995, 1, 14.0128 / 37.36653);
+        WeightedObservedPoint point14 = new WeightedObservedPoint(455.45798, 2, 10.182568 / 37.36653);
+        WeightedObservedPoint point15 = new WeightedObservedPoint(205.16792, 3, 12.9579735 / 37.36653);
+        WeightedObservedPoint point16 = new WeightedObservedPoint(451.05057, 4, 12.913956 / 37.36653);
+        WeightedObservedPoint point17 = new WeightedObservedPoint(471.85242, 5, 7.089638 / 37.36653);
+        WeightedObservedPoint point18 = new WeightedObservedPoint(646.1104, 6, 9.526044 / 37.36653);
+        WeightedObservedPoint point19 = new WeightedObservedPoint(689.3907, 7, 8.498449 / 37.36653);
+        WeightedObservedPoint point20 = new WeightedObservedPoint(208.12926, 8, 9.250189 / 37.36653);
+        WeightedObservedPoint point21 = new WeightedObservedPoint(1262.8378, 9, 7.8886223 / 37.36653);
+        WeightedObservedPoint point22 = new WeightedObservedPoint(214.3265, 10, 7.9543853 / 37.36653);
+        WeightedObservedPoint point23 = new WeightedObservedPoint(617.08203, 11, 7.3262196 / 37.36653);
+        WeightedObservedPoint point24 = new WeightedObservedPoint(219.78712, 12, 5.733577 / 37.36653);
+        WeightedObservedPoint point25 = new WeightedObservedPoint(202.69017, 13, 6.0807056 / 37.36653);
+        WeightedObservedPoint point26 = new WeightedObservedPoint(216.81699, 30, 6.7873144 / 37.36653);
+
+        points.add(point1);
+        points.add(point2);
+        points.add(point3);
+        points.add(point4);
+        points.add(point5);
+        points.add(point6);
+        points.add(point7);
+        points.add(point8);
+        points.add(point9);
+        points.add(point10);
+        points.add(point11);
+        points.add(point12);
+        points.add(point13);
+        points.add(point14);
+        points.add(point15);
+        points.add(point16);
+        points.add(point17);
+        points.add(point18);
+        points.add(point19);
+        points.add(point20);
+        points.add(point21);
+        points.add(point22);
+        points.add(point23);
+        points.add(point24);
+        points.add(point25);
+        points.add(point26);
+
+        final double coeffs[] = fitter.fit(points);
+        System.out.println(Arrays.toString(coeffs));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java b/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java
new file mode 100644
index 0000000000..75d9fe57d4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java
@@ -0,0 +1,61 @@
+package com.graphhopper.util.profiles;
+
+import com.graphhopper.util.GPXEntry;
+
+import java.util.List;
+
+public class TrackPart {
+
+    private double distance;
+    private List<GPXEntry> gpxEntryList;
+    private double slope;
+    private double speed;
+    private int wayType = -1;
+
+    public TrackPart(List<GPXEntry> gpxEntryList, double distance, double slope, double speed) {
+        this.gpxEntryList = gpxEntryList;
+        this.distance = distance;
+        this.slope = slope;
+        this.speed = speed;
+    }
+
+    public List<GPXEntry> getGpxEntryList() {
+        return gpxEntryList;
+    }
+
+    public void setGpxEntryList(List<GPXEntry> gpxEntryList) {
+        this.gpxEntryList = gpxEntryList;
+    }
+
+    public double getDistance() {
+        return distance;
+    }
+
+    public void setDistance(double distance) {
+        this.distance = distance;
+    }
+
+    public double getSlope() {
+        return slope;
+    }
+
+    public void setSlope(double slope) {
+        this.slope = slope;
+    }
+
+    public double getSpeed() {
+        return speed;
+    }
+
+    public void setSpeed(double speed) {
+        this.speed = speed;
+    }
+
+    public int getWayType() {
+        return wayType;
+    }
+
+    public void setWayType(int wayType) {
+        this.wayType = wayType;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java
new file mode 100644
index 0000000000..2473976de5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java
@@ -0,0 +1,53 @@
+package com.graphhopper.util.profiles.operations;
+
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.matching.LocationIndexMatch;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.profiles.GPXDataExtractor;
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
+import com.graphhopper.matching.GPXFile;
+
+public class AddToProfileOperation implements Operation {
+
+    String name;
+    String gpxFileName;
+
+    GraphHopper hopper;
+
+    public AddToProfileOperation(String[] args) {
+        name = args[1];
+        gpxFileName = args[2];
+
+        CmdArgs cmdArgs = CmdArgs.read(args);
+        cmdArgs = CmdArgs.readFromConfigAndMerge(cmdArgs, "config", "graphhopper.config");
+        hopper = new GraphHopper().init(cmdArgs);
+        hopper.importOrLoad();
+
+    }
+
+    @Override
+    public void run() {
+
+        ProfileManager profileManager = new ProfileManager();
+
+        RidersProfile ridersProfile = profileManager.getProfile(name);
+
+        if(ridersProfile == null) {
+            System.err.println("Could not load profile " + name + ". Please check your profile name.");
+            return;
+        }
+
+        GPXDataExtractor gpxDataExtractor = new GPXDataExtractor();
+        gpxDataExtractor.setupMapMatching(hopper);
+        gpxDataExtractor.configFilter(GPXDataExtractor.FILTER_KALMAN_COMBINED, 100);
+
+        GPXFile gpxFile = new GPXFile().doImport("./" + gpxFileName);
+        gpxDataExtractor.setFile(gpxFile);
+        ridersProfile.update(gpxDataExtractor.extract());
+
+        profileManager.saveProfile(name);
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java
new file mode 100644
index 0000000000..e95e1fefff
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java
@@ -0,0 +1,18 @@
+package com.graphhopper.util.profiles.operations;
+
+import com.graphhopper.util.profiles.ProfileManager;
+
+public class CreateProfileOperation implements Operation {
+
+    String name;
+
+    public CreateProfileOperation(String[] args){
+        this.name = args[1];
+    }
+
+    @Override
+    public void run() {
+        ProfileManager aProfileManager = new ProfileManager();
+        aProfileManager.createProfile(name);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java
new file mode 100644
index 0000000000..77d73c94f9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java
@@ -0,0 +1,8 @@
+package com.graphhopper.util.profiles.operations;
+
+
+public interface Operation {
+
+    void run();
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java
new file mode 100644
index 0000000000..4e60346f80
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java
@@ -0,0 +1,27 @@
+package com.graphhopper.util.profiles.operations;
+
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
+
+public class PrintProfileOperation implements Operation {
+
+    String name;
+
+    public PrintProfileOperation(String[] args) {
+        this.name = args[1];
+    }
+
+    @Override
+    public void run() {
+
+        ProfileManager profileManager = new ProfileManager();
+        RidersProfile ridersProfile = profileManager.getProfile(name);
+
+        System.out.println("Profile of: " + name);
+
+        if(ridersProfile != null){
+            System.out.println(ridersProfile.getFilterSpeeds());
+        }
+
+    }
+}
diff --git a/profiles.sh b/profiles.sh
new file mode 100755
index 0000000000..9f978cebd7
--- /dev/null
+++ b/profiles.sh
@@ -0,0 +1,14 @@
+#!/usr/bin/env bash
+
+GH_CLASS=com.graphhopper.util.profiles.Profiles
+
+ACTION=$1
+USER=$2
+FILE=$3
+LOCATION=$4
+
+CONFIG=config.properties
+VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1)
+JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
+
+java -cp "$JAR" "$GH_CLASS" "$ACTION" "$USER" config="$CONFIG" graph.location="$GRAPH" osmreader.osm="$LOCATION"
\ No newline at end of file
diff --git a/profiles/.gitignore b/profiles/.gitignore
new file mode 100644
index 0000000000..86d0cb2726
--- /dev/null
+++ b/profiles/.gitignore
@@ -0,0 +1,4 @@
+# Ignore everything in this directory
+*
+# Except this file
+!.gitignore
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 9fe1792252..e3ed435810 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -62,6 +62,7 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         {
             JSONObject perVehicleJson = new JSONObject();
             perVehicleJson.put("elevation", hopper.hasElevation());
+            perVehicleJson.put("weighting", getPreferredWeighting(v));
             features.put(v, perVehicleJson);
         }
         json.put("features", features);
@@ -77,4 +78,14 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
 
         writeJson(req, res, json);
     }
+
+    private String getPreferredWeighting(String v) {
+
+        String w = "fastest";
+
+        if(v.equalsIgnoreCase("generic_bike"))
+            w = "dynamic";
+
+        return w;
+    }
 }
diff --git a/web/src/main/webapp/img/generic_bike.png b/web/src/main/webapp/img/generic_bike.png
new file mode 100644
index 0000000000..3d7bb4bb10
Binary files /dev/null and b/web/src/main/webapp/img/generic_bike.png differ
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 7bfea1787c..22bb056873 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -316,6 +316,7 @@ GHRequest.prototype.init = function (params) {
     // overwrite elevation e.g. important if not supported from feature set
     this.api_params.elevation = false;
     var featureSet = this.features[this.api_params.vehicle];
+
     if (featureSet && featureSet.elevation) {
         if ('elevation' in params)
             this.api_params.elevation = params.elevation;
@@ -359,6 +360,10 @@ GHRequest.prototype.initVehicle = function (vehicle) {
         this.api_params.elevation = true;
     else
         this.api_params.elevation = false;
+
+    if (featureSet && featureSet.weighting)
+        this.api_params.weighting = featureSet.weighting;
+
 };
 
 GHRequest.prototype.hasElevation = function () {
