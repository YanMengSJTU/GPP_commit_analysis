diff --git a/config-example.properties b/config-example.properties
index c7ff4b326f..99552a5d13 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -8,7 +8,7 @@ graph.flag_encoders=car
 
 # Enable turn restrictions for car or motorcycle. 
 # Currently you need to additionally set prepare.ch.weightings=no before using this (see below and #270)
-# graph.flag_encoders=car|turn_costs=true
+#graph.flag_encoders=car|turn_costs=true
 
 
 
@@ -107,7 +107,7 @@ graph.dataaccess=RAM_STORE
 
 
 # will write way names in the preferred language (language code as defined in ISO 639-1 or ISO 639-2):
-# datareader.preferred_language=en
+datareader.preferred_language=en
 
 
 # Sort the graph after import to make requests roughly ~10% faster. Note that this requires significantly more RAM on import.
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 33e12de0b9..aef0f55c0d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
+import com.graphhopper.util.shapes.GHPoint;
 
 import java.util.*;
 
@@ -45,7 +46,7 @@
      * http://www.itoworld.com/map/124#fullscreen
      * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
      */
-    protected final Map<String, Integer> defaultSpeedMap = new HashMap<String, Integer>();
+    protected final Map<String, Integer> defaultSpeedMap = new HashMap<>();
 
     public CarFlagEncoder() {
         this(5, 5, 0);
@@ -167,9 +168,18 @@ protected double getSpeed(ReaderWay way) {
                 && highwayValue != "motorway" && highwayValue != "motorway_link") {
             highwayValue = "motorroad";
         }
-        Integer speed = defaultSpeedMap.get(highwayValue);
-        if (speed == null)
-            throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
+//        Integer speed = defaultSpeedMap.get(highwayValue);
+//        if (speed == null)
+//            throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
+
+		GHPoint point = way.getTag("estimated_center", null);
+        double speed = way.getTag("estimated_speed", (double) -1);//getSpeedForLocation(point);
+        if (speed == -1) {
+            Integer defaultSpeed = defaultSpeedMap.get(highwayValue);
+            if (defaultSpeed == null)
+                throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
+            speed = 1.0 * defaultSpeed;
+        }
 
         if (highwayValue.equals("track")) {
             String tt = way.getTag("tracktype");
@@ -235,6 +245,7 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
         return oldRelationFlags;
     }
 
+    // AG: TODO Handle way tags
     @Override
     public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         if (!isAccept(allowed))
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 79e90e624b..9b64c31a7d 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -43,6 +43,8 @@
 import javax.xml.stream.XMLStreamException;
 import java.io.File;
 import java.io.IOException;
+import java.sql.Connection;
+import java.sql.DriverManager;
 import java.util.*;
 
 import static com.graphhopper.util.Helper.nf;
@@ -118,6 +120,9 @@
     private File osmFile;
     private Date osmDataDate;
 
+    private long speedCnt = 0;
+    private long speedCntTotal = 0;
+
     public OSMReader(GraphHopperStorage ghStorage) {
         this.ghStorage = ghStorage;
         this.graph = ghStorage;
@@ -259,6 +264,11 @@ private void writeOsm2Graph(File osmFile) {
         long relationStart = -1;
         long counter = 1;
         OSMInputFile in = null;
+        Connection conn = getConnection();
+
+        speedCnt = 0;
+        speedCntTotal = 0;
+
         try {
             in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
             LongIntMap nodeFilter = getNodeMap();
@@ -272,12 +282,13 @@ private void writeOsm2Graph(File osmFile) {
                         }
                         break;
 
+                        // AG: TODO process way
                     case ReaderElement.WAY:
                         if (wayStart < 0) {
                             LOGGER.info(nf(counter) + ", now parsing ways");
                             wayStart = counter;
                         }
-                        processWay((ReaderWay) item);
+                        processWay((ReaderWay) item, conn);
                         break;
                     case ReaderElement.RELATION:
                         if (relationStart < 0) {
@@ -314,7 +325,7 @@ private void writeOsm2Graph(File osmFile) {
     /**
      * Process properties, encode flags and create edges for the way.
      */
-    void processWay(ReaderWay way) {
+    void processWay(ReaderWay way, Connection conn) {
         if (way.getNodes().size() < 2)
             return;
 
@@ -340,9 +351,14 @@ void processWay(ReaderWay way) {
             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
             if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
                 double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+                // AG: Here GH sets the GPS tags!
                 // Add artificial tag for the estimated distance and center
                 way.setTag("estimated_distance", estimatedDist);
                 way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+
+                double speed = conn != null ?
+                        lookupSpeed(conn, (firstLat + lastLat) / 2, (firstLon + lastLon) / 2) : -1;
+                way.setTag("estimated_speed", speed);
             }
         }
 
@@ -925,4 +941,127 @@ public Date getDataDate() {
     public String toString() {
         return getClass().getSimpleName();
     }
+
+    private double lookupSpeed(Connection conn, double lat, double lng) {
+//        String query = "SELECT " +
+//                "   speed," +
+//                "   ( 6371 * acos( cos( radians(?) ) * cos( radians( lat ) ) * " +
+//                "   cos( radians( lng ) - radians(?) ) + " +
+//                "   sin( radians(?) ) * " +
+//                "   sin( radians( lat ) ) ) ) " +
+//                "   AS distance " +
+//                "   FROM gh_markers " +
+//                "   HAVING distance < 2 " +
+//                "   ORDER BY distance " +
+//                "   LIMIT 1";
+//        LOGGER.info("SQL: " + query);
+
+        int ONE_DEGREE_CONSTANT;
+        int EARTH_RADIUS_CONSTANT;
+        double lon1, lon2, lat1, lat2;
+        ONE_DEGREE_CONSTANT   = 69;
+        EARTH_RADIUS_CONSTANT = 3959;
+
+        double maxDistance = 1.0;
+        lon1 = lng - maxDistance/Math.abs(Math.cos(Math.toRadians(lat))*ONE_DEGREE_CONSTANT);
+        lon2 = lng + maxDistance/Math.abs(Math.cos(Math.toRadians(lat))*ONE_DEGREE_CONSTANT);
+        lat1 = lat - (maxDistance/ONE_DEGREE_CONSTANT);
+        lat2 = lat + (maxDistance/ONE_DEGREE_CONSTANT);
+
+        String queryFmt = "SELECT m1.speed, ROUND((%d * acos(cos(radians(%.6f)) * cos(radians(m1.lat)) * " +
+                "cos(radians(m2.lng) - radians(%.6f)) +  sin(radians(%.6f)) * sin(radians(m1.lat)))) " +
+                "   , 3) AS distance " +
+                "   FROM gh_markers as m1, gh_markers as m2 " +
+                "   WHERE m1.id = m2.id AND m2.lng between %.6f and %.6f AND m1.lat between %.6f and %.6f" +
+                "   ORDER BY distance ASC" +
+                "   LIMIT 10";
+        String queryFmt2 = "SELECT speed, ROUND((%d * acos(cos(radians(%.6f)) * cos(radians(lat)) * " +
+                "cos(radians(lng) - radians(%.6f)) +  sin(radians(%.6f)) * sin(radians(lat)))) " +
+                "   , 3) AS distance " +
+                "   FROM gh_markers " +
+                "   WHERE lng between %.6f and %.6f AND lat between %.6f and %.6f" +
+                "   ORDER BY distance ASC" +
+                "   LIMIT 10";
+        String query = String.format(queryFmt, EARTH_RADIUS_CONSTANT, lat, lng, lat, lon1, lon2, lat1, lat2);
+        LOGGER.info("QUERY 1: " + query);
+
+        String query2 = String.format(queryFmt2, EARTH_RADIUS_CONSTANT, lat, lng, lat, lon1, lon2, lat1, lat2);
+        LOGGER.info("QUERY 2: " + query2);
+
+        speedCntTotal++;
+        LOGGER.info("NODES: " + speedCntTotal);
+
+        return -1;
+//
+//        try {
+//            Statement st = conn.createStatement();
+//
+//            ResultSet rs = st.executeQuery(query);
+//
+//            double speed = -1;
+//            double distance  = 0;
+//
+//            speedCntTotal++;
+//
+//            if (rs.next()) {
+//                speed = rs.getDouble("speed");
+//                distance = rs.getDouble("distance");
+//                speedCnt++;
+//                LOGGER.info(String.format("[%d out of %d] [%.6f, %.6f] SPEED: %.2f. DISTANCE: %.3f",
+//                        speedCnt, speedCntTotal, lat, lng, speed, distance));
+//            }
+//            return speed;
+//        } catch (Exception e) {
+//            return -1;
+//        }
+    }
+
+    private Connection getConnection() {
+        Connection conn = null;
+        try {
+            String url1 = "jdbc:mysql://greenride-api-v2.cuqltrp6td3j.eu-west-1.rds.amazonaws.com/ridematch3?verifyServerCertificate=false&useSSL=true";
+            String user = "greenride_api";
+            String password = "VTaztq5jHemf";
+
+            conn = DriverManager.getConnection(url1, user, password);
+            if (conn != null) {
+                System.out.println("Connected to the database");
+            } else {
+                System.out.println("NOT Connected to the database");
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return  conn;
+    }
+
+//    private void loadSpeedData() {
+//        CSVParser parser = null;
+//        List<CSVRecord> list;
+//        try {
+//            parser = new CSVParser(new FileReader("speeds/p0709.csv" ), CSVFormat.DEFAULT);
+//            list = parser.getRecords();
+//            list.sort(new Comparator<CSVRecord>() {
+//                @Override
+//                public int compare(CSVRecord o1, CSVRecord o2) {
+//                    float lat1 = Float.parseFloat(o1.get(1));
+//                    float lat2 = Float.parseFloat(o2.get(1));
+//                    if (lat1 > lat2)
+//                        return 1;
+//                    else if (lat1 < lat2)
+//                        return -1;
+//                    else
+//                        return 0;
+//                }
+//            });
+//            for( CSVRecord row : list ) {
+//                float lng = Float.parseFloat(row.get(0));
+//                float lat = Float.parseFloat(row.get(1));
+//                float speed = Float.parseFloat(row.get(2));
+//            }
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
+//    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 61efc52173..32ffe0b339 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -612,7 +612,7 @@ public long handleNodeTags(ReaderNode node) {
         way.setTag("highway", "motorway");
         osmreader.getNodeMap().put(1, 1);
         osmreader.getNodeMap().put(2, 2);
-        osmreader.processWay(way);
+        osmreader.processWay(way, null);
 
         GHPoint p = way.getTag("estimated_center", null);
         assertEquals(1.15, p.lat, 1e-3);
diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
index 988cc164b2..28b582f08b 100644
--- a/reader-shp/pom.xml
+++ b/reader-shp/pom.xml
@@ -56,7 +56,12 @@
             <artifactId>graphhopper-reader-osm</artifactId>
             <version>${project.parent.version}</version>
             <scope>test</scope>
-        </dependency>        
+        </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-csv</artifactId>
+            <version>1.4</version>
+        </dependency>
     </dependencies>
     <build>
         <plugins>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/Csv.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/Csv.java
new file mode 100755
index 0000000000..ed36621b48
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/Csv.java
@@ -0,0 +1,64 @@
+package com.graphhopper.reader.shp;
+
+/*
+ * Copyright (c) delight.im <info@delight.im>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+import java.lang.String;
+
+/** Provides CSV (comma-separated values) features such as encoding/decoding and escaping/unescaping */
+public class Csv {
+
+	protected static final String DELIMITER = ",";
+	protected static final String QUOTE = "\"";
+
+	public static String encode(final Iterable<?> iterable) {
+		StringBuilder out = new StringBuilder();
+
+		String str;
+		for (Object obj : iterable) {
+			if (out.length() > 0) {
+				out.append(DELIMITER);
+			}
+
+			if (obj instanceof String) {
+				str = (String) obj;
+			}
+			else {
+				str = obj.toString();
+			}
+
+			out.append(escape(str));
+		}
+
+		return out.toString();
+	}
+
+	public static String escape(final String str) {
+		if (containsReservedCharacter(str)) {
+			return QUOTE + str.replace(QUOTE, QUOTE + QUOTE) + QUOTE;
+		}
+		else {
+			return str;
+		}
+	}
+
+	protected static boolean containsReservedCharacter(final String str) {
+		return str.contains(DELIMITER) || str.contains(QUOTE) || str.contains("\r") || str.contains("\n");
+	}
+
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/EdgeAddedListener.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/EdgeAddedListener.java
new file mode 100644
index 0000000000..5b14ec8081
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/EdgeAddedListener.java
@@ -0,0 +1,11 @@
+package com.graphhopper.reader.shp;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Created by alexeygusev on 27/03/2017.
+ */
+public interface EdgeAddedListener {
+    void edgeAdded(ReaderWay way, EdgeIteratorState edge);
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperSHP.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
similarity index 75%
rename from reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperSHP.java
rename to reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
index 0d4edc4715..0c1939d4a0 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperSHP.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
@@ -21,8 +21,8 @@
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.shp.OSMShapeFileReader.EdgeAddedListener;
 import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.CmdArgs;
 
 /**
  * This class is the main entry point to import from OpenStreetMap shape files similar to GraphHopperOSM which imports
@@ -30,12 +30,24 @@
  *
  * @author Phil
  */
-public class GraphhopperSHP extends GraphHopper {
+public class GraphHopperSHP extends GraphHopper {
     private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
 
+    private final int shapeFileType;
+    private final String speedData;
+
+    public GraphHopperSHP(int shapeType, CmdArgs args) {
+        shapeFileType = shapeType;
+        speedData = args.get("speeds.file", null);
+    }
+
     @Override
     protected DataReader createReader(GraphHopperStorage ghStorage) {
-        OSMShapeFileReader reader = new OSMShapeFileReader(ghStorage);
+        ShapeFileReader reader;
+        if (shapeFileType == 0)
+            reader = new OSMShapeFileReader(ghStorage, speedData);
+        else
+            reader = new ITNShapeFileReader(ghStorage, speedData);
         for (EdgeAddedListener l : edgeAddedListeners) {
             reader.addListener(l);
         }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ITNShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ITNShapeFileReader.java
new file mode 100644
index 0000000000..96f3eb24f5
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/ITNShapeFileReader.java
@@ -0,0 +1,415 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.shp;
+
+import com.graphhopper.coll.GHObjectIntHashMap;
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.GHPoint;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.LineString;
+import com.vividsolutions.jts.geom.MultiLineString;
+import org.geotools.data.DataStore;
+import org.geotools.feature.FeatureIterator;
+import org.opengis.feature.simple.SimpleFeature;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.util.*;
+
+/**
+ * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
+ * extracts the data as per the structure of shape files
+ *
+ * @author Vikas Veshishth
+ * @author Philip Welch
+ */
+public class ITNShapeFileReader extends ShapeFileReader {
+    private static final int COORD_STATE_UNKNOWN = 0;
+    private static final int COORD_STATE_PILLAR = -2;
+    private static final int FIRST_NODE_ID = 1;
+    private static final String[] DIRECT_COPY_TAGS = new String[]{"name"};
+    private File roadsFile;
+    private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private static final Logger LOGGER = LoggerFactory.getLogger(ITNShapeFileReader.class);
+    private int nextNodeId = FIRST_NODE_ID;
+    private int totalSpeedsCnt = 0;
+
+    public ITNShapeFileReader(GraphHopperStorage ghStorage, String speedData) {
+        super(ghStorage, speedData);
+
+//        LOGGER.info("Number of nodes in speed map : " + speedMap.size());
+    }
+
+    private List<Coordinate[]> getCoords(Object o) {
+        ArrayList<Coordinate[]> ret = new ArrayList<>();
+        if (o == null) {
+            return ret;
+        }
+
+        if (o instanceof LineString) {
+            ret.add(((LineString) o).getCoordinates());
+        } else if (o instanceof MultiLineString) {
+            MultiLineString mls = (MultiLineString) o;
+            int n = mls.getNumGeometries();
+            for (int i = 0; i < n; i++) {
+                ret.add(mls.getGeometryN(i).getCoordinates());
+            }
+        }
+
+        return ret;
+    }
+
+    @Override
+    void processJunctions() {
+        DataStore dataStore = null;
+        FeatureIterator<SimpleFeature> roads = null;
+
+        try {
+            dataStore = openShapefileDataStore(roadsFile);
+            roads = getFeatureIterator(dataStore);
+
+            HashSet<Coordinate> tmpSet = new HashSet<>();
+            while (roads.hasNext()) {
+                SimpleFeature road = roads.next();
+
+                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
+                    tmpSet.clear();
+                    for (int i = 0; i < points.length; i++) {
+                        Coordinate c = points[i];
+
+                        // don't add the same coord twice for the same edge - happens with bad geometry, i.e.
+                        // duplicate coords or a road which forms a circle (e.g. roundabout)
+                        if (tmpSet.contains(c))
+                            continue;
+
+                        tmpSet.add(c);
+
+                        // skip if its already a node
+                        int state = coordState.get(c);
+                        if (state >= FIRST_NODE_ID) {
+                            continue;
+                        }
+
+                        if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
+                            // turn into a node if its the first or last
+                            // point, or already appeared in another edge
+                            int nodeId = nextNodeId++;
+                            coordState.put(c, nodeId);
+                            saveTowerPosition(nodeId, c);
+                        } else if (state == COORD_STATE_UNKNOWN) {
+                            // mark it as a pillar (which may get upgraded
+                            // to an edge later)
+                            coordState.put(c, COORD_STATE_PILLAR);
+                        }
+                    }
+                }
+
+            }
+        } finally {
+            if (roads != null) {
+                roads.close();
+            }
+            if (dataStore != null) {
+                dataStore.dispose();
+            }
+        }
+
+        if (nextNodeId == FIRST_NODE_ID)
+            throw new IllegalArgumentException("No data found for roads file " + roadsFile);
+
+        LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
+    }
+
+    @Override
+    void processRoads() {
+
+        DataStore dataStore = null;
+        FeatureIterator<SimpleFeature> roads = null;
+
+        try {
+            dataStore = openShapefileDataStore(roadsFile);
+            roads = getFeatureIterator(dataStore);
+
+            while (roads.hasNext()) {
+                SimpleFeature road = roads.next();
+
+                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
+
+                    // Parse all points in the geometry, splitting into
+                    // individual graphhopper edges
+                    // whenever we find a node in the list of points
+                    Coordinate startTowerPnt = null;
+                    List<Coordinate> pillars = new ArrayList<Coordinate>();
+                    for (Coordinate point : points) {
+                        if (startTowerPnt == null) {
+                            startTowerPnt = point;
+                        } else {
+                            int state = coordState.get(point);
+                            if (state >= FIRST_NODE_ID) {
+                                int fromTowerNodeId = coordState.get(startTowerPnt);
+                                int toTowerNodeId = state;
+
+                                // get distance and estimated centres
+                                double distance = getWayLength(startTowerPnt, pillars, point);
+                                GHPoint estmCentre = new GHPoint(
+                                        0.5 * (lat(startTowerPnt) + lat(point)),
+                                        0.5 * (lng(startTowerPnt) + lng(point)));
+                                PointList pillarNodes = new PointList(pillars.size(), false);
+
+                                for (Coordinate pillar : pillars) {
+                                    pillarNodes.add(lat(pillar), lng(pillar));
+                                }
+
+                                addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre,
+                                        pillarNodes);
+                                startTowerPnt = point;
+                                pillars.clear();
+                            } else {
+                                pillars.add(point);
+                            }
+                        }
+                    }
+                }
+
+            }
+        } finally {
+            if (roads != null) {
+                roads.close();
+            }
+
+            if (dataStore != null) {
+                dataStore.dispose();
+            }
+        }
+    }
+
+    private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
+        double distance = 0;
+
+        Coordinate previous = start;
+        for (Coordinate point : pillars) {
+            distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
+            previous = point;
+        }
+        distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
+
+        return distance;
+    }
+
+    @Override
+    public DataReader setFile(File file) {
+        this.roadsFile = file;
+        return this;
+    }
+
+    @Override
+    public DataReader setElevationProvider(ElevationProvider ep) {
+        // Elevation not supported
+        return this;
+    }
+
+    @Override
+    public DataReader setWorkerThreads(int workerThreads) {
+        // Its only single-threaded
+        return this;
+    }
+
+    @Override
+    public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
+        // TODO Auto-generated method stub
+        return this;
+    }
+
+    @Override
+    public Date getDataDate() {
+        return null;
+    }
+
+//    public static interface EdgeAddedListener {
+//        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
+//    }
+
+    private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,
+                         GHPoint estmCentre, PointList pillarNodes) {
+        EdgeIteratorState edge = graph.edge(fromTower, toTower);
+
+        // read the OSM id, should never be null
+        long id = getItnId(road);
+
+        // Make a temporary ReaderWay object with the properties we need so we
+        // can use the enocding manager
+        // We (hopefully don't need the node structure on here as we're only
+        // calling the flag
+        // encoders, which don't use this...
+        ReaderWay way = new ReaderWay(id);
+
+        way.setTag("estimated_distance", distance);
+        way.setTag("estimated_center", estmCentre);
+
+        // read the highway type
+        Object type = road.getAttribute("fclass");
+        if (type != null) {
+            way.setTag("highway", type.toString());
+        } else {
+            // AG
+            way.setTag("highway", translateHighwayType(Integer.parseInt(road.getAttribute(3).toString())));
+        }
+
+        Double speed = speedMap.get(String.valueOf(id));
+        if (speed != null) {
+            way.setTag("estimated_speed", speed);
+            totalSpeedsCnt++;
+            LOGGER.info(String.format("[%d] Found speed info: [%d] => %f KPH    ", totalSpeedsCnt, id, speed));
+        }
+
+        // read maxspeed filtering for 0 which for Geofabrik shapefiles appears
+        // to correspond to no tag
+        Object maxSpeed = road.getAttribute("maxspeed");
+        if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
+            way.setTag("maxspeed", maxSpeed.toString());
+        }
+
+        for (String tag : DIRECT_COPY_TAGS) {
+            Object val = road.getAttribute(tag);
+            if (val != null) {
+                way.setTag(tag, val.toString());
+            }
+        }
+
+        // read oneway
+        Object oneway = road.getAttribute("oneway");
+        if (oneway != null) {
+            // Geofabrik is using an odd convention for oneway field in
+            // shapefile.
+            // We map back to the standard convention so that tag can be dealt
+            // with correctly by the flag encoder.
+            String val = oneway.toString().trim().toLowerCase();
+            if (val.equals("b")) {
+                // both ways
+                val = "no";
+            } else if (val.equals("t")) {
+                // one way against the direction of digitisation
+                val = "-1";
+            } else if (val.equals("f")) {
+                // one way Forward in the direction of digitisation
+                val = "yes";
+            } else {
+                throw new RuntimeException("Unrecognised value of oneway field \"" + val
+                        + "\" found in road with OSM id " + id);
+            }
+
+            way.setTag("oneway", val);
+        } else {
+            oneway = road.getAttribute(2);
+            if (oneway != null) {
+                String val = oneway.toString().trim().toLowerCase();
+                if (val.equals("0")) {
+                    // both ways
+                    val = "no";
+                } else if (val.equals("-1")) {
+                    // one way against the direction of digitisation
+                    val = "-1";
+                } else if (val.equals("1")) {
+                    // one way Forward in the direction of digitisation
+                    val = "yes";
+                } else {
+                    throw new RuntimeException("Unrecognised value of oneway field \"" + val
+                            + "\" found in road with OSM id " + id);
+                }
+
+                LOGGER.debug("Oneway : ", val);
+                way.setTag("oneway", val);
+            }
+        }
+
+        // Process the flags using the encoders
+        long includeWay = encodingManager.acceptWay(way);
+        if (includeWay == 0) {
+            return;
+        }
+
+        // TODO we're not using the relation flags
+        long relationFlags = 0;
+
+        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+        if (wayFlags == 0)
+            return;
+
+        edge.setDistance(distance);
+        edge.setFlags(wayFlags);
+        edge.setWayGeometry(pillarNodes);
+
+        if (edgeAddedListeners.size() > 0) {
+            // check size first so we only allocate the iterator if we have
+            // listeners
+            for (EdgeAddedListener l : edgeAddedListeners) {
+                l.edgeAdded(way, edge);
+            }
+        }
+    }
+
+    private long getItnId(SimpleFeature road) {
+        String value = road.getAttribute(1).toString();
+        return Long.parseLong(value.substring(4));
+    }
+
+    private String translateHighwayType(Integer type) {
+        /*
+        3000       Motorway
+        3001       A Road
+        3002       B Road
+        3004       Minor Road
+        3006       Private Road Restricted Access
+        3007       Local Street
+        3008       Private Road Publicly Accessible
+        3009       Alley
+        3010       Footpath
+        3011       Canal Path
+         */
+        Map<Integer, String> roadTypes = new HashMap<Integer, String>()
+        {{
+            put(3000, "motorway");
+            put(3001, "motorway");
+            put(3002, "motorroad");
+            put(3004, "secondary_link");
+            put(3006, "tertiary");
+            put(3007, "residential");
+            put(3008, "tertiary");
+            put(3009, "unclassified");
+            put(3010, "unclassified");
+            put(3011, "unclassified");
+        }};
+
+        String highwayType = roadTypes.get(type);
+        if (highwayType == null) {
+            highwayType = "residential";
+        }
+
+        LOGGER.debug("Highway Type: ", highwayType);
+        return highwayType;
+    }
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
index f8ec5de28b..0e7a47cf45 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -58,11 +58,10 @@
     private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
-    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
     private int nextNodeId = FIRST_NODE_ID;
 
-    public OSMShapeFileReader(GraphHopperStorage ghStorage) {
-        super(ghStorage);
+    public OSMShapeFileReader(GraphHopperStorage ghStorage, String speedData) {
+        super(ghStorage, speedData);
     }
 
     private List<Coordinate[]> getCoords(Object o) {
@@ -250,9 +249,9 @@ public Date getDataDate() {
         return null;
     }
 
-    public static interface EdgeAddedListener {
-        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
-    }
+//    public interface EdgeAddedListener {
+//        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
+//    }
 
     private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,
                          GHPoint estmCentre, PointList pillarNodes) {
@@ -346,8 +345,4 @@ private long getOSMId(SimpleFeature road) {
         long id = Long.parseLong(road.getAttribute("osm_id").toString());
         return id;
     }
-
-    public void addListener(EdgeAddedListener l) {
-        edgeAddedListeners.add(l);
-    }
 }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
index 02eb1e4aee..fa3e83c679 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
@@ -17,10 +17,16 @@
  */
 package com.graphhopper.reader.shp;
 
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.vividsolutions.jts.geom.Coordinate;
+import org.apache.commons.csv.CSVFormat;
+import org.apache.commons.csv.CSVParser;
+import org.apache.commons.csv.CSVRecord;
 import org.geotools.data.DataStore;
 import org.geotools.data.DataStoreFinder;
 import org.geotools.data.FeatureSource;
@@ -29,14 +35,13 @@
 import org.opengis.feature.simple.SimpleFeature;
 import org.opengis.feature.simple.SimpleFeatureType;
 import org.opengis.filter.Filter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.vividsolutions.jts.geom.Coordinate;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.*;
 
 /**
  * ShapeFileReader takes care of reading a shape file and writing it to a road network graph
@@ -46,16 +51,28 @@
  */
 public abstract class ShapeFileReader implements DataReader {
 
+    protected final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
+    protected final String speedData;
+    protected final HashMap<String, Double> speedMap = new HashMap<>();
+
+    protected EncodingManager encodingManager;
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ITNShapeFileReader.class);
+
     private final GraphStorage graphStorage;
     private final NodeAccess nodeAccess;
     protected final Graph graph;
-    protected EncodingManager encodingManager;
 
-    public ShapeFileReader(GraphHopperStorage ghStorage) {
+    public ShapeFileReader(GraphHopperStorage ghStorage, String speedData) {
         this.graphStorage = ghStorage;
         this.graph = ghStorage;
         this.nodeAccess = graph.getNodeAccess();
         this.encodingManager = ghStorage.getEncodingManager();
+        this.speedData = speedData;
+
+        if (this.speedData != null) {
+            loadSpeedData("PeakAm0709MonFri_2");
+        }
     }
 
     @Override
@@ -65,6 +82,11 @@ public void readGraph() {
         processRoads();
     }
 
+    public void addListener(EdgeAddedListener l) {
+        edgeAddedListeners.add(l);
+    }
+
+
     abstract void processJunctions();
 
     abstract void processRoads();
@@ -118,4 +140,35 @@ protected double lat(Coordinate coordinate) {
     protected void saveTowerPosition(int nodeId, Coordinate point) {
         nodeAccess.setNode(nodeId, lat(point), lng(point));
     }
+
+    private void loadSpeedData(String columnName) {
+        CSVParser parser = null;
+        List<CSVRecord> list;
+        try {
+            parser = new CSVParser(new FileReader(speedData), CSVFormat.DEFAULT.withFirstRecordAsHeader());
+            list = parser.getRecords();
+//            list.sort((o1, o2) -> {
+//                float lat1 = Float.parseFloat(o1.get(1));
+//                float lat2 = Float.parseFloat(o2.get(1));
+//                if (lat1 > lat2)
+//                    return 1;
+//                else if (lat1 < lat2)
+//                    return -1;
+//                else
+//                    return 0;
+//            });
+            // Get speeds and convert to KPH (x 1.60934)
+            for( CSVRecord row : list ) {
+                String id = row.get("RoadLinkId");
+                double speed = Double.parseDouble(row.get(columnName)) * 1.60934;
+                if (speedMap.get(id) != null) {
+                    LOGGER.info("Key found: " + id);
+                }
+                speedMap.put(id.substring(4), speed);
+            }
+            LOGGER.info("Number of nodes in speed map : " + speedMap.size());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapefileParser.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapefileParser.java
new file mode 100755
index 0000000000..2d0157d7b4
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapefileParser.java
@@ -0,0 +1,128 @@
+package com.graphhopper.reader.shp;
+
+/*
+ * Copyright (c) delight.im <info@delight.im>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+import org.geotools.data.DataStore;
+import org.geotools.data.shapefile.ShapefileDataStore;
+import org.geotools.feature.FeatureIterator;
+import org.opengis.feature.Property;
+import org.opengis.feature.simple.SimpleFeature;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+
+/** Parses ESRI shapefiles and extracts all spatial/geometric data with attributes */
+public class ShapefileParser {
+
+	public static void main(String[] args) {
+		String filePath;
+		if (args.length == 1) {
+			filePath = args[0];
+		}
+		else {
+			throw new RuntimeException("Call with path to SHP file as single argument");
+		}
+
+		System.out.println(parse(filePath));
+	}
+
+	public static String parse(final String filePath) {
+		final LinkedList<LinkedList<String>> entries = extractRecords(filePath);
+
+		StringBuilder out = new StringBuilder();
+
+		for (LinkedList<String> entry : entries) {
+			out.append(Csv.encode(entry));
+			out.append("\n");
+		}
+
+		return out.toString();
+	}
+
+	protected static LinkedList<LinkedList<String>> extractRecords(final String filePath) {
+		final LinkedList<LinkedList<String>> out = new LinkedList<LinkedList<String>>();
+
+		try {
+			final DataStore dataStore = openDataStore(filePath);
+			final String[] typeNames = dataStore.getTypeNames();
+
+			final FeatureIterator<SimpleFeature> iterator = dataStore.getFeatureSource(typeNames[0]).getFeatures().features();
+
+			try {
+				SimpleFeature feature = null;
+				LinkedList<String> headers = null;
+				LinkedList<String> keys;
+				LinkedList<String> values;
+
+				while (iterator.hasNext()) {
+					feature = iterator.next();
+
+					keys = new LinkedList<String>();
+					values = new LinkedList<String>();
+
+					// feature.getDefaultGeometry().toString()
+
+					for (Property p : feature.getProperties()) {
+						keys.add(p.getName().toString());
+						values.add(p.getValue().toString());
+					}
+
+					out.add(values);
+
+					if (headers == null) {
+						headers = keys;
+					}
+					else {
+						if (!keys.equals(headers)) {
+							throw new RuntimeException("Keys vary in number, order or content");
+						}
+					}
+				}
+
+				if (headers != null) {
+					out.addFirst(headers);
+				}
+
+				return out;
+			}
+			finally {
+				iterator.close();
+				dataStore.dispose();
+			}
+
+		}
+		catch (Throwable e) {
+			e.printStackTrace();
+		}
+
+		return out;
+	}
+
+	protected static DataStore openDataStore(final String filePath) throws IOException {
+		final File file = new File(filePath);
+		return new ShapefileDataStore(file.toURI().toURL());
+
+		//final Map<String, Object> params = new HashMap<String, Object>();
+		//params.put(ShapefileDataStoreFactory.URLP.key, file.toURI().toURL());
+		//params.put(ShapefileDataStoreFactory.CREATE_SPATIAL_INDEX.key, Boolean.TRUE);
+		//return DataStoreFinder.getDataStore(params);
+	}
+
+}
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
index e200fa5f3d..9fddca61e6 100644
--- a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
+++ b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
@@ -50,7 +50,7 @@
  */
 public class ShapeFileReaderTest {
 
-    private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
+    private static final String shapefile = "/data/LondonITN_latL.shp";//"/data/gis.osm_roads_free_1.shp";
     private static final String pbf = "/data/malta-latest.osm.pbf";
     private static final String tempOutputDirFromShp = "target/test-db-shp";
     private static final String tempOutputDirFromPbf = "target/test-db-pbf";
@@ -127,7 +127,7 @@ public static void setupBeforeClass() {
             new File(tempOutputDirFromShp).mkdirs();
             new File(tempOutputDirFromPbf).mkdirs();
 
-            hopperShp = initHopper(new GraphhopperSHP(), shapefile, tempOutputDirFromShp);
+            hopperShp = initHopper(new GraphHopperSHP(0, null), shapefile, tempOutputDirFromShp);
 
             hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
 
diff --git a/web/pom.xml b/web/pom.xml
index 5ca45fbe63..bb48d8a472 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -100,7 +100,12 @@
             <version>3.4.2</version>
             <scope>test</scope>
         </dependency>
-        
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-reader-shp</artifactId>
+            <version>0.9-SNAPSHOT</version>
+        </dependency>
+
     </dependencies>
 
     <build>
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index 08e36b801f..5c94157c89 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -24,6 +24,7 @@
 import com.graphhopper.json.GHJsonBuilder;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.reader.shp.GraphHopperSHP;
 import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.lm.PrepareLandmarks;
 import com.graphhopper.routing.util.DataFlagEncoder;
@@ -74,31 +75,36 @@ static SpatialRuleLookup buildIndex(Reader reader, BBox graphBBox) {
      * @return an initialized GraphHopper instance
      */
     protected GraphHopper createGraphHopper(CmdArgs args) {
-        GraphHopper tmp = new GraphHopperOSM() {
-            @Override
-            protected void loadOrPrepareLM() {
-                if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
-                    return;
-
-                try {
-                    String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
-                    Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
-                    JsonFeatureCollection jsonFeatureCollection = new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class);
-                    if (!jsonFeatureCollection.getFeatures().isEmpty()) {
-                        SpatialRuleLookup ruleLookup = new SpatialRuleLookupBuilder().build("country",
-                                new SpatialRuleLookupBuilder.SpatialRuleDefaultFactory(), jsonFeatureCollection,
-                                getGraphHopperStorage().getBounds(), 0.1, true);
-                        for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
-                            prep.setSpatialRuleLookup(ruleLookup);
+        GraphHopper tmp;
+        if (args.get("datareader.file", "").endsWith(".pbf"))
+            tmp = new GraphHopperOSM() {
+                @Override
+                protected void loadOrPrepareLM() {
+                    if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
+                        return;
+
+                    try {
+                        String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
+                        Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
+                        JsonFeatureCollection jsonFeatureCollection = new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class);
+                        if (!jsonFeatureCollection.getFeatures().isEmpty()) {
+                            SpatialRuleLookup ruleLookup = new SpatialRuleLookupBuilder().build("country",
+                                    new SpatialRuleLookupBuilder.SpatialRuleDefaultFactory(), jsonFeatureCollection,
+                                    getGraphHopperStorage().getBounds(), 0.1, true);
+                            for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
+                                prep.setSpatialRuleLookup(ruleLookup);
+                            }
                         }
+                    } catch (IOException ex) {
+                        logger.error("Problem while reading border map GeoJSON. Skipping this.", ex);
                     }
-                } catch (IOException ex) {
-                    logger.error("Problem while reading border map GeoJSON. Skipping this.", ex);
-                }
 
-                super.loadOrPrepareLM();
-            }
-        }.forServer().init(args);
+                    super.loadOrPrepareLM();
+                }
+            };
+        else
+            tmp = new GraphHopperSHP(1, args);
+        tmp = tmp.forServer().init(args);
 
         String location = args.get("spatial_rules.location", "");
         if (!location.isEmpty()) {
