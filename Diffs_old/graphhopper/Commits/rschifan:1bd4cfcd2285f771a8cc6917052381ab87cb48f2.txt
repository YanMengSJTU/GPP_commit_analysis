diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index d027d726a9..9df5e0f9ad 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -67,6 +67,8 @@
  * @see GraphHopperAPI
  */
 public class GraphHopper implements GraphHopperAPI {
+
+
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final String fileLockName = "gh.lock";
     private final Set<RoutingAlgorithmFactoryDecorator> algoDecorators = new LinkedHashSet<>();
@@ -119,6 +121,7 @@
     private PathDetailsBuilderFactory pathBuilderFactory = new PathDetailsBuilderFactory();
 
     public GraphHopper() {
+
         chFactoryDecorator.setEnabled(true);
         lmFactoryDecorator.setEnabled(false);
 
@@ -921,11 +924,13 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         } else if ("curvature".equalsIgnoreCase(weightingStr)) {
             if (encoder.supports(CurvatureWeighting.class))
                 weighting = new CurvatureWeighting(encoder, hintsMap);
-
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
+        } else if ("happymaps".equalsIgnoreCase(weightingStr)) {
+            weighting = new HappyMapsWeighting(encoder);
         }
 
+
         if (weighting == null)
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
 
diff --git a/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java b/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java
new file mode 100644
index 0000000000..6a129ea40f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/HappyMapsGraphHopper.java
@@ -0,0 +1,28 @@
+package com.graphhopper;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.HappyMapsWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class HappyMapsGraphHopper extends GraphHopper {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    @Override
+    public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
+
+        String weightingStr = hintsMap.getWeighting().toLowerCase();
+
+        if ("happymaps".equals(weightingStr)) {
+            return new HappyMapsWeighting(encoder);
+        } else {
+            return super.createWeighting(hintsMap, encoder, graph);
+        }
+    }
+
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/HappyMapsFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/HappyMapsFlagEncoder.java
new file mode 100644
index 0000000000..a133127fb1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/HappyMapsFlagEncoder.java
@@ -0,0 +1,198 @@
+package com.graphhopper.routing.util;
+
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.util.HashMap;
+import java.util.Map;
+
+public class HappyMapsFlagEncoder extends FootFlagEncoder {
+    private final static Logger logger = LoggerFactory.getLogger(HappyMapsFlagEncoder.class);
+
+    static final int MAX_NATURE = 3;
+
+    protected EncodedDoubleValue natureEncoder;
+
+    private final Map<Long, Map<String, Double>> wayid2weights = new HashMap<>();
+
+
+    public HappyMapsFlagEncoder(PMap configuration) {
+        super(configuration);
+
+        loadCustomWeights();
+
+    }
+
+
+    @Override
+    public double getTurnCost(long flag) {
+        return 10;
+    }
+
+
+    /**
+     * Some ways are okay but not separate for pedestrians.
+     * <p>
+     */
+    @Override
+    public long acceptWay(ReaderWay way) {
+        String highwayValue = way.getTag("highway");
+
+        if (highwayValue == null) {
+
+            if ((way.hasTag("route", ferries)) ||
+                    (way.hasTag("railway", "platform")) ||
+                    (way.hasTag("man_made", "pier")))
+                return 0;
+        }
+
+        String sacScale = way.getTag("sac_scale");
+        if (sacScale != null) {
+            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
+                    && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
+                // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+                return 0;
+        }
+
+        // no need to evaluate ferries or fords - already included here
+        if (way.hasTag("foot", intendedValues))
+            return acceptBit;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+            return 0;
+
+        if (way.hasTag("sidewalk", sidewalkValues))
+            return acceptBit;
+
+        if (!allowedHighwayTags.contains(highwayValue))
+            return 0;
+
+        if (way.hasTag("motorroad", "yes"))
+            return 0;
+
+        // do not get our feet wet, "yes" is already included above
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
+            return 0;
+
+        if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
+            return 0;
+
+        return acceptBit;
+    }
+
+
+
+    @Override
+    public int defineWayBits(int index, int shift) {
+
+        shift = super.defineWayBits(index, shift);
+
+        natureEncoder = new EncodedDoubleValue("Nature", shift, 16, 0.001, 0, MAX_NATURE);
+
+        shift += natureEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags){
+
+        long flags = super.handleWayTags(way, allowed, relationFlags);
+
+        long wayid = way.getId();
+
+        double nature = this.getCustomWeightByWayId(wayid, "nature");
+
+        flags = natureEncoder.setDoubleValue(flags, nature);
+
+        return flags;
+    }
+
+    @Override
+    public String toString() {
+        return "happymaps";
+    }
+
+    private void loadCustomWeights() {
+        System.out.println("loadCustomWeights");
+
+        HashMap<String, Double> tagsHashMap;
+
+        try {
+
+            File inputF = new File("data/london_happy_maps_norms.csv");
+            InputStream inputFS = new FileInputStream(inputF);
+            BufferedReader br = new BufferedReader(new InputStreamReader(inputFS));
+
+            long wayid, nWayIds=0;
+            double nature;
+
+            // skip header
+//          String header = br.readLine();
+            String line = br.readLine();
+
+            while (line != null) {
+
+                String[] tt = line.split(",");
+
+                try {
+                    wayid = Long.valueOf(tt[0]);
+                    nature = Double.valueOf(tt[1]);
+
+                    tagsHashMap = new HashMap<String, Double>();
+                    tagsHashMap.put("nature", nature);
+                    this.getCustomWeights().put(wayid, tagsHashMap);
+
+                    nWayIds+=1;
+
+                } catch (NumberFormatException e) {
+                    System.out.println(e.getMessage());
+                }
+
+                line = br.readLine();
+            }
+
+            System.out.printf("Read %d custom weights wayids\n",nWayIds);
+
+            br.close();
+            inputFS.close();
+
+        } catch (FileNotFoundException e) {
+            System.out.println(e.getMessage());
+        } catch (IOException e) {
+            System.out.println(e.getMessage());
+        }
+
+    }
+
+    public double getNature(EdgeIteratorState edge) {
+        long flags = edge.getFlags();
+        return natureEncoder.getDoubleValue(flags);
+    }
+
+
+    public Map<String, Double> getCustomWeightsByWayId(long wayid) {
+        return this.getCustomWeights().get(new Long(wayid));
+    }
+
+
+    public Double getCustomWeightByWayId(long wayid, String key) {
+
+        Map<String, Double> wayidInfo = this.getCustomWeightsByWayId(wayid);
+
+        if (wayidInfo!=null)
+            return wayidInfo.get(key);
+        else
+            return (double)MAX_NATURE;
+    }
+
+    public Map<Long, Map<String, Double>> getCustomWeights() {
+        return wayid2weights;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java
new file mode 100644
index 0000000000..3b100f1a77
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/HappyMapsWeighting.java
@@ -0,0 +1,47 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HappyMapsFlagEncoder;
+import com.graphhopper.util.EdgeIteratorState;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+public class HappyMapsWeighting extends AbstractWeighting {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final HappyMapsFlagEncoder happymapsFlagEncoder;
+
+    public HappyMapsWeighting(FlagEncoder flagEncoder) {
+        super(flagEncoder);
+
+        happymapsFlagEncoder = (HappyMapsFlagEncoder) flagEncoder;
+
+        logger.info("\n\n\n\nHappyMapsWeighting: create\n\n\n\n");
+
+    }
+
+    @Override
+    public double getMinWeight(double currDistToGoal) {
+        return currDistToGoal;
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+
+        double weight;
+
+        weight = happymapsFlagEncoder.getNature(edgeState);
+        return weight;
+
+//        return edgeState.getDistance();
+    }
+
+    @Override
+    public String getName() {
+        return "happymaps";
+    }
+
+}
+
+
