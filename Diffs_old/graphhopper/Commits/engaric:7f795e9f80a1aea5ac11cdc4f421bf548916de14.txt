diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index b3f749525f..ca0dddb46c 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -1495,7 +1495,7 @@ protected int loadNodesHeader()
         {
             bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
             bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
-        }        
+        }
 
         return 7;
     }
@@ -1579,7 +1579,7 @@ public boolean isClosed()
     }
 
     @Override
-    public GraphExtension getExtension()    
+    public GraphExtension getExtension()
     {
         return extStorage;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index d16a114944..a4f7477a90 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -95,7 +95,7 @@ public EdgeSkipIterState shortcut( int a, int b )
     public EdgeSkipIterState edge( int a, int b )
     {
         if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create after shortcut was created");
+            throw new IllegalStateException("Cannot create edge after first shortcut was created");
 
         lastEdgeIndex = edgeCount;
         return createEdge(a, b);
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 73a559903a..eee2f2f80c 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -245,27 +245,6 @@ public int findID( double lat, double lon )
         return res.getClosestNode();
     }
 
-    @Override
-    public boolean loadExisting()
-    {
-        if (initialized)
-            throw new IllegalStateException("Call loadExisting only once");
-
-        if (!dataAccess.loadExisting())
-            return false;
-
-        if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
-
-        if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph");
-
-        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
-        prepareAlgo();
-        initialized = true;
-        return true;
-    }
-
     @Override
     public LocationIndex setResolution( int minResolutionInMeter )
     {
@@ -292,10 +271,32 @@ public LocationIndexTree create( long size )
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
+    @Override
+    public boolean loadExisting()
+    {
+        if (initialized)
+            throw new IllegalStateException("Call loadExisting only once");
+
+        if (!dataAccess.loadExisting())
+            return false;
+
+        if (dataAccess.getHeader(0) != MAGIC_INT)
+            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
+
+        if (dataAccess.getHeader(1 * 4) != calcChecksum())
+            throw new IllegalStateException("location2id index was opened with incorrect graph: "
+                    + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
+
+        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
+        prepareAlgo();
+        initialized = true;
+        return true;
+    }
+
     @Override
     public void flush()
     {
-        dataAccess.setHeader(0, MAGIC_INT);
+        dataAccess.setHeader(0, MAGIC_INT);        
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
 
@@ -331,6 +332,7 @@ public LocationIndex prepareIndex()
                 + ", leafs:" + Helper.nf(inMem.leafs)
                 + ", precision:" + minResolutionInMeter
                 + ", depth:" + entries.length
+                + ", checksum:" + calcChecksum()
                 + ", entries:" + Arrays.toString(entries)
                 + ", entriesPerLeaf:" + entriesPerLeaf);
 
