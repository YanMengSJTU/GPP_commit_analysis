diff --git a/.travis.yml b/.travis.yml
index a6a8dcb343..ac6a9d0113 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,10 +11,11 @@ env:
 
 matrix:
   include:
-    - jdk: oraclejdk8
     - jdk: openjdk8
     - env: JDK='OpenJDK 10'
       install: . ./install-jdk.sh -F 10 -C
+    - env: JDK='OpenJDK 11'
+      install: . ./install-jdk.sh -F 11 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
 install: true
diff --git a/api/src/main/java/com/graphhopper/GHRequest.java b/api/src/main/java/com/graphhopper/GHRequest.java
index 326ea176e3..38b40c2529 100644
--- a/api/src/main/java/com/graphhopper/GHRequest.java
+++ b/api/src/main/java/com/graphhopper/GHRequest.java
@@ -251,7 +251,7 @@ public GHRequest setPointHints(List<String> pointHints) {
     }
 
     public boolean hasPointHints() {
-        return pointHints.size() == points.size();
+        return pointHints.size() == points.size() && !points.isEmpty();
     }
 
     public GHRequest setPathDetails(List<String> pathDetails) {
diff --git a/api/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
index 8788410b5b..4891a52781 100644
--- a/api/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -122,11 +122,6 @@ public double getEle(int index) {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
-        @Override
-        public LineString toLineString(boolean includeElevation) {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
         @Override
         public void reverse() {
             throw new UnsupportedOperationException("cannot change EMPTY PointList");
diff --git a/api/src/test/java/com/graphhopper/util/PointListTest.java b/api/src/test/java/com/graphhopper/util/PointListTest.java
index 4df09a0a4b..f401da7cb7 100644
--- a/api/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/api/src/test/java/com/graphhopper/util/PointListTest.java
@@ -237,6 +237,8 @@ public void testToGeoJson() {
 
         assertEquals(3, pl.toLineString(true).getNumPoints());
         assertEquals(2, pl.shallowCopy(1, 3, false).toLineString(true).getNumPoints());
+
+        assertEquals(0, PointList.EMPTY.toLineString(false).getNumPoints());
     }
 
 
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
index e12881b346..469e460722 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
@@ -15,6 +15,8 @@
 
     private List<GHPoint> fromPoints;
     private List<GHPoint> toPoints;
+    private List<String> fromPointHints;
+    private List<String> toPointHints;
     boolean identicalLists = true;
     private final Set<String> outArrays = new HashSet<>(5);
 
@@ -26,6 +28,8 @@ public GHMRequest(int size) {
         super(0);
         fromPoints = new ArrayList<>(size);
         toPoints = new ArrayList<>(size);
+        fromPointHints = new ArrayList<>(size);
+        toPointHints = new ArrayList<>(size);
     }
 
     /**
@@ -51,7 +55,7 @@ public GHMRequest addAllPoints(List<GHPoint> points) {
 
     @Override
     public List<GHPoint> getPoints() {
-        throw new IllegalStateException("use getFromPlaces or getToPlaces");
+        throw new IllegalStateException("use getFromPoints or getToPoints");
     }
 
     public List<GHPoint> getFromPoints() {
@@ -63,7 +67,7 @@ public GHMRequest addAllPoints(List<GHPoint> points) {
     }
 
     /**
-     * This methods adds the places as 'from' and 'to' place to the request.
+     * This methods adds the coordinate as 'from' and 'to' to the request.
      */
     @Override
     public GHMRequest addPoint(GHPoint point) {
@@ -78,21 +82,68 @@ public GHMRequest addFromPoint(GHPoint point) {
         return this;
     }
 
-    public GHMRequest addFromPoints(List<GHPoint> points) {
+    public GHMRequest setFromPoints(List<GHPoint> points) {
         fromPoints = points;
         identicalLists = false;
         return this;
     }
 
+    public GHRequest addFromPointHint(String pointHint) {
+        this.fromPointHints.add(pointHint);
+        return this;
+    }
+
+    public GHRequest setFromPointHints(List<String> pointHints) {
+        this.fromPointHints = pointHints;
+        return this;
+    }
+
+    public List<String> getFromPointHints() {
+        return fromPointHints;
+    }
+
     public GHMRequest addToPoint(GHPoint point) {
         toPoints.add(point);
         identicalLists = false;
         return this;
     }
 
-    public GHMRequest addToPoints(List<GHPoint> points) {
+    public GHMRequest setToPoints(List<GHPoint> points) {
         toPoints = points;
         identicalLists = false;
         return this;
     }
+
+    public GHRequest addToPointHint(String pointHint) {
+        this.toPointHints.add(pointHint);
+        return this;
+    }
+
+    public GHRequest setToPointHints(List<String> pointHints) {
+        this.toPointHints = pointHints;
+        return this;
+    }
+
+    public List<String> getToPointHints() {
+        return toPointHints;
+    }
+
+    @Override
+    public GHRequest setPointHints(List<String> pointHints) {
+        super.setPointHints(pointHints);
+        this.fromPointHints = pointHints;
+        this.toPointHints = pointHints;
+        return this;
+    }
+
+    @Override
+    public List<String> getPointHints() {
+        throw new IllegalStateException("Use getFromPointHints or getToPointHints");
+    }
+
+    @Override
+    public boolean hasPointHints() {
+        return this.fromPointHints.size() == this.fromPoints.size() && !fromPoints.isEmpty() &&
+                this.toPointHints.size() == this.toPoints.size() && !toPoints.isEmpty();
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 9cb31ea57c..43a219b736 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -55,8 +55,6 @@ public GHMatrixBatchRequester setSleepAfterGET(long sleepAfterGETMillis) {
     @Override
     public MatrixResponse route(GHMRequest ghRequest) {
         ObjectNode requestJson = factory.objectNode();
-        ArrayNode fromPointList = createPointList(ghRequest.getFromPoints());
-        ArrayNode toPointList = createPointList(ghRequest.getToPoints());
 
         List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
         if (outArraysList.isEmpty()) {
@@ -69,8 +67,18 @@ public MatrixResponse route(GHMRequest ghRequest) {
         }
 
         boolean hasElevation = false;
-        requestJson.putArray("from_points").addAll(fromPointList);
-        requestJson.putArray("to_points").addAll(toPointList);
+        if (ghRequest.identicalLists) {
+            requestJson.putArray("points").addAll(createPointList(ghRequest.getFromPoints()));
+            requestJson.putArray("point_hints").addAll(createStringList(ghRequest.getFromPointHints()));
+        } else {
+            ArrayNode fromPointList = createPointList(ghRequest.getFromPoints());
+            ArrayNode toPointList = createPointList(ghRequest.getToPoints());
+            requestJson.putArray("from_points").addAll(fromPointList);
+            requestJson.putArray("from_point_hints").addAll(createStringList(ghRequest.getFromPointHints()));
+            requestJson.putArray("to_points").addAll(toPointList);
+            requestJson.putArray("to_point_hints").addAll(createStringList(ghRequest.getToPointHints()));
+        }
+
         requestJson.putArray("out_arrays").addAll(outArrayListJson);
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
@@ -102,7 +110,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
 
             JsonNode responseJson = toJSON(postUrl, postResponseStr);
             if (responseJson.has("message")) {
-                matrixResponse.addError(new RuntimeException(responseJson.get("message").asText()));
+                matrixResponse.addErrors(readErrors(responseJson));
                 return matrixResponse;
             }
             if (!responseJson.has("job_id")) {
@@ -167,8 +175,16 @@ public MatrixResponse route(GHMRequest ghRequest) {
         return matrixResponse;
     }
 
+    private final ArrayNode createStringList(List<String> list) {
+        ArrayNode outList = factory.arrayNode();
+        for (String str : list) {
+            outList.add(str);
+        }
+        return outList;
+    }
+
     protected final ArrayNode createPointList(List<GHPoint> list) {
-        ArrayNode outList = factory.arrayNode(); // new ArrayList<>(list.size())
+        ArrayNode outList = factory.arrayNode();
         for (GHPoint p : list) {
             ArrayNode entry = factory.arrayNode();
             entry.add(p.lon);
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index f535934f84..1761f05c59 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -36,18 +36,39 @@ private void initIgnore() {
         ignoreSet.add("vehicle");
         ignoreSet.add("point");
         ignoreSet.add("from_point");
+        ignoreSet.add("from_point_hint");
         ignoreSet.add("to_point");
+        ignoreSet.add("to_point_hint");
         ignoreSet.add("add_array");
     }
 
     @Override
     public MatrixResponse route(GHMRequest ghRequest) {
+        StringBuilder pointHintsStr = new StringBuilder();
+
         String pointsStr;
         if (ghRequest.identicalLists) {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "point");
+
+            for (String hint : ghRequest.getFromPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("point_hint=").append(encode(hint));
+            }
         } else {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "from_point");
             pointsStr += "&" + createPointQuery(ghRequest.getToPoints(), "to_point");
+
+            for (String hint : ghRequest.getFromPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("from_point_hint=").append(encode(hint));
+            }
+            for (String hint : ghRequest.getToPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("to_point_hint=").append(encode(hint));
+            }
         }
 
         String outArrayStr = "";
@@ -65,7 +86,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
         }
 
         String url = buildURL("", ghRequest);
-        url += "&" + pointsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
+        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
 
         boolean withTimes = outArraysList.contains("times");
         boolean withDistances = outArraysList.contains("distances");
@@ -94,14 +115,13 @@ public MatrixResponse route(GHMRequest ghRequest) {
     }
 
     private String createPointQuery(List<GHPoint> list, String pointName) {
-        String pointsStr = "";
+        StringBuilder pointsStr = new StringBuilder();
         for (GHPoint p : list) {
-            if (!pointsStr.isEmpty()) {
-                pointsStr += "&";
-            }
+            if (pointsStr.length() > 0)
+                pointsStr.append("&");
 
-            pointsStr += pointName + "=" + encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon));
+            pointsStr.append(pointName).append('=').append(encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon)));
         }
-        return pointsStr;
+        return pointsStr.toString();
     }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 525766a535..7253f480d9 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -128,7 +128,7 @@ PathWrapper createPathWrapper(JsonNode path, boolean tmpElevation, boolean turnD
             JsonNode descriptionNode = path.get("description");
             if (descriptionNode.isArray()) {
                 List<String> description = new ArrayList<>(descriptionNode.size());
-                for (JsonNode descNode: descriptionNode) {
+                for (JsonNode descNode : descriptionNode) {
                     description.add(descNode.asText());
                 }
                 pathWrapper.setDescription(description);
@@ -431,6 +431,10 @@ private Request createRequest(GHRequest request) {
             url += "&" + Parameters.DETAILS.PATH_DETAILS + "=" + details;
         }
 
+        for (String hint : request.getPointHints()) {
+            url += "&point_hint=" + WebHelper.encodeURL(hint);
+        }
+
         if (!key.isEmpty()) {
             url += "&key=" + WebHelper.encodeURL(key);
         }
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 8d175d5090..2b5e819f4e 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -6,6 +6,7 @@
 
 import java.util.Arrays;
 
+import static com.graphhopper.api.GraphHopperMatrixWeb.SERVICE_URL;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -65,10 +66,40 @@ public void testNxM_issue45() {
         ghmRequest.addOutArray("distances");
         ghmRequest.addOutArray("times");
         ghmRequest.setVehicle("car");
-        ghmRequest.addFromPoints(Arrays.asList(new GHPoint(52.557151, 13.515244)))
-                .addToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
+        ghmRequest.setFromPoints(Arrays.asList(new GHPoint(52.557151, 13.515244)))
+                .setToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
 
         MatrixResponse res = ghMatrix.route(ghmRequest);
         assertEquals(2437, res.getTime(0, 1) / 1000, 30);
     }
+
+    @Test
+    public void testPOSTMatrixQueryWithPointHints() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        req.addOutArray("distances");
+        MatrixResponse res = ghMatrix.route(req);
+        assertEquals(4833, res.getDistance(1, 2), 50);
+
+        req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        req.addOutArray("distances");
+        req.setPointHints(Arrays.asList("", "singerstr", ""));
+        res = ghMatrix.route(req);
+        assertEquals(3900, res.getDistance(1, 2), 50);
+
+        req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        // wrong count
+        req.setPointHints(Arrays.asList("", "singerstr"));
+        res = ghMatrix.route(req);
+        assertTrue(res.hasErrors());
+        assertEquals("Array length of point_hints must match length of points (or from/to equivalent)", res.getErrors().get(0).getMessage());
+    }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
index f205cd9d51..0b664d271a 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
@@ -32,4 +32,9 @@ public void testMatrix() {
         assertEquals(11000, res.getDistance(1, 2), 2000);
         assertEquals(2500, res.getTime(1, 2) / 1000, 1000);
     }
+
+    @Test
+    public void testPOSTMatrixQueryWithPointHints() {
+        // for now ignore
+    }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 012c0e8a2c..df6a5fad67 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -169,7 +169,6 @@ public void testCannotFindPointException() {
         assertTrue(res.getErrors().get(0) instanceof PointNotFoundException);
     }
 
-
     @Test
     public void testOutOfBoundsException() {
         GHRequest req = new GHRequest().
@@ -332,4 +331,15 @@ public void testPathDetails() {
         assertTrue((Double) details.get(0).getValue() > 20);
         assertTrue((Double) details.get(0).getValue() < 70);
     }
+
+    @Test
+    public void testPointHints() {
+        GHRequest ghRequest = new GHRequest();
+        ghRequest.addPoint(new GHPoint(52.50977, 13.371971));
+        ghRequest.addPoint(new GHPoint(52.509842, 13.369761));
+
+        ghRequest.setPointHints(Arrays.asList("Ben-Gurion", ""));
+        GHResponse response = gh.route(ghRequest);
+        assertTrue(response.getBest().getDistance() + "m", response.getBest().getDistance() < 500);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index dc8e804881..9df3034e10 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -63,19 +63,15 @@ public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex l
         queryResults = new ArrayList<>(points.size());
         for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
             GHPoint point = points.get(placeIndex);
-            QueryResult res;
-            if (ghRequest.hasPointHints()) {
-                res = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
-                if (!res.isValid()) {
-                    res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-                }
-            } else {
-                res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            }
-            if (!res.isValid())
+            QueryResult qr = null;
+            if (ghRequest.hasPointHints())
+                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
+            if (qr == null || !qr.isValid())
+                qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!qr.isValid())
                 ghResponse.addError(new PointNotFoundException("Cannot find point " + placeIndex + ": " + point, placeIndex));
 
-            queryResults.add(res);
+            queryResults.add(qr);
         }
 
         return queryResults;
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index f95e5a108a..90b64a75c7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -44,7 +44,7 @@
  */
 public class EncodingManager {
     private static final String ERR = "Encoders are requesting %s bits, more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags=8";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags: 8";
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<>();
     private final int bitsForEdgeFlags;
     private final int bitsForTurnFlags = 8 * 4;
diff --git a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
index 6550054f93..2e8d59375f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
@@ -21,8 +21,7 @@
 import com.graphhopper.debatty.java.stringsimilarity.JaroWinkler;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 import java.util.regex.Pattern;
 
 import static com.graphhopper.util.Helper.toLowerCase;
@@ -46,34 +45,64 @@
  */
 public class NameSimilarityEdgeFilter implements EdgeFilter {
 
-    private static final Pattern NON_WORD_CHAR = Pattern.compile("[^\\p{L}]+");
-    private final double JARO_WINKLER_ACCEPT_FACTOR = .79;
-    private final JaroWinkler jaroWinkler = new JaroWinkler();
 
+    private static final Map<String, String> DEFAULT_REWRITE_MAP = new HashMap<String, String>() {{
+        // two char words will be ignored but ignore certain longer phrases (or rename them)
+        for (String remove : Arrays.asList(
+                "ally", "alley",
+                "arc", "arcade",
+                "bvd", "bvd.", "boulevard",
+                "av.", "avenue", "avenida",
+                "calle",
+                "cl.", "close",
+                "crescend", "cres", "cres.",
+                "rd.", "road",
+                "ln.", "lane",
+                "pde.", "pde", "parade",
+                "pl.", "place", "plaza",
+                "str.", "str", "straße", "strasse", "st.", "street", "strada",
+                "sq.", "square",
+                "tr.", "track",
+                "via")) {
+            put(remove, "");
+        }
+    }};
+    private static final Pattern NON_WORD_CHAR = Pattern.compile("[^\\p{L}]+");
+    private static final JaroWinkler jaroWinkler = new JaroWinkler();
+    private static final double JARO_WINKLER_ACCEPT_FACTOR = .9;
     private final EdgeFilter edgeFilter;
     private final String pointHint;
+    private final Map<String, String> rewriteMap;
 
     public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint) {
+        this(edgeFilter, pointHint, DEFAULT_REWRITE_MAP);
+    }
+
+    /**
+     * @param rewriteMap maps abreviations to its longer form
+     */
+    public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint, Map<String, String> rewriteMap) {
         this.edgeFilter = edgeFilter;
-        this.pointHint = prepareName(pointHint == null ? "" : pointHint);
+        this.rewriteMap = rewriteMap;
+        this.pointHint = prepareName(removeRelation(pointHint == null ? "" : pointHint));
     }
 
     /**
      * Removes any characters in the String that we don't care about in the matching procedure
-     * TODO: Remove common street names like: street, road, avenue?
+     * TODO Currently limited to certain 'western' languages
      */
     private String prepareName(String name) {
-        // TODO make this better, also split at ',' and others?
-        // TODO This limits the approach to certain 'western' languages
         // \s = A whitespace character: [ \t\n\x0B\f\r]
         String[] arr = name.split("\\s");
-        String tmp;
         List<String> list = new ArrayList<>(arr.length);
         for (int i = 0; i < arr.length; i++) {
-            tmp = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
-            // Ignore matching short frases like, de, rue, st, etc.
-            if (!tmp.isEmpty() && tmp.length() > 3) {
-                list.add(tmp);
+            String rewrite = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
+            String tmp = rewriteMap.get(rewrite);
+            if (tmp != null)
+                rewrite = tmp;
+            // Ignore matching short frases like de, la, ...
+            if (!rewrite.isEmpty() && rewrite.length() > 2) {
+                list.add(rewrite);
             }
         }
         return listToString(list);
diff --git a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
index 2017be94f9..d2d30f41eb 100644
--- a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
@@ -63,7 +63,7 @@ public void testAccept() {
         edge = createTestEdgeIterator("Johannesstraße");
         assertTrue(edgeFilter.accept(edge));
 
-        edgeFilter = createNameSimilarityEdgeFilter("Hauptstraße, 39025, Naturns, Italien");
+        edgeFilter = createNameSimilarityEdgeFilter("Hauptstraße");
         edge = createTestEdgeIterator("Teststraße");
         assertFalse(edgeFilter.accept(edge));
 
@@ -75,7 +75,6 @@ public void testAccept() {
 
         edge = createTestEdgeIterator("Hauptstr.");
         assertTrue(edgeFilter.accept(edge));
-
     }
 
     /**
@@ -83,126 +82,83 @@ public void testAccept() {
      */
     @Test
     public void testAcceptFromNominatim() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edgeFilter = createNameSimilarityEdgeFilter("Wentworth Street, Caringbah South");
-        edge = createTestEdgeIterator("Wentworth Street");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = createNameSimilarityEdgeFilter("Zum Toffental, Altdorf bei Nürnnberg");
-        edge = createTestEdgeIterator("Zum Toffental");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Wentworth Street, Caringbah South").
+                accept(createTestEdgeIterator("Wentworth Street")));
+        assertTrue(createNameSimilarityEdgeFilter("Zum Toffental, Altdorf bei Nürnnberg").
+                accept(createTestEdgeIterator("Zum Toffental")));
     }
 
     @Test
     public void testAcceptFromGoogleMapsGeocoding() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edgeFilter = createNameSimilarityEdgeFilter("Rue Notre-Dame O Montréal");
-        edge = createTestEdgeIterator("Rue Dupré");
-        assertFalse(edgeFilter.accept(edge));
-
-        edge = createTestEdgeIterator("Rue Notre-Dame Ouest");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = createNameSimilarityEdgeFilter("227 Rue Saint-Antoine O, Montréal");
-        edge = createTestEdgeIterator("Rue Saint-Antoine O");
-        assertTrue(edgeFilter.accept(edge));
+        EdgeFilter edgeFilter = createNameSimilarityEdgeFilter("Rue Notre-Dame O Montréal");
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Dupré")));
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue Notre-Dame Ouest")));
 
-        edge = createTestEdgeIterator("Rue Saint-Jacques");
-        assertFalse(edgeFilter.accept(edge));
-
-        edgeFilter = createNameSimilarityEdgeFilter("1025 Rue de Bleury, Montréal, QC H2Z 1M7");
-        edge = createTestEdgeIterator("Rue de Bleury");
-        assertTrue(edgeFilter.accept(edge));
+        edgeFilter = createNameSimilarityEdgeFilter("Rue Saint-Antoine O, Montréal");
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue Saint-Antoine O")));
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Saint-Jacques")));
 
-        edge = createTestEdgeIterator("Rue Balmoral");
-        assertFalse(edgeFilter.accept(edge));
+        edgeFilter = createNameSimilarityEdgeFilter("Rue de Bleury");
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue de Bleury")));
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Balmoral")));
 
-        // Modified Test from Below
-        edgeFilter = createNameSimilarityEdgeFilter("257 Main Road, Claremont, Cape Town, 7708, Afrique du Sud");
-        edge = createTestEdgeIterator("Main Road");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Main Rd").accept(createTestEdgeIterator("Main Road")));
+        assertTrue(createNameSimilarityEdgeFilter("Main Road").accept(createTestEdgeIterator("Main Rd")));
 
-        edgeFilter = createNameSimilarityEdgeFilter("Cape Point Rd, Cape Peninsula, Cape Town, 8001, Afrique du Sud");
-        edge = createTestEdgeIterator("Cape Point / Cape of Good Hope");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point")));
+        assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point Road")));
 
-        edgeFilter = createNameSimilarityEdgeFilter("Viale Puglie, 26, 20137 Milano, Italy");
-        edge = createTestEdgeIterator("Viale Puglie");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Av. Juan Ramón Ramírez").accept(createTestEdgeIterator("Avenida Juan Ramón Ramírez")));
     }
 
     @Test
-    public void testAcceptMashup() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edge = createTestEdgeIterator("Augustine Street");
-
-        // Google Maps
-        edgeFilter = createNameSimilarityEdgeFilter("Augustine St, Hunters Hill NSW 2110, Australia");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Opencagedata
-        edgeFilter = createNameSimilarityEdgeFilter("Augustine Street, Sydney Neusüdwales 2110, Australien");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Nominatim
-        edgeFilter = createNameSimilarityEdgeFilter("Augustine Street, Sydney, Municipality of Hunters Hill, Neusüdwales, 2111, Australien");
-        assertTrue(edgeFilter.accept(edge));
+    public void testAcceptStForStreet() {
+        EdgeIteratorState edge = createTestEdgeIterator("Augustine Street");
+        assertTrue(createNameSimilarityEdgeFilter("Augustine St").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Augustine Street").accept(edge));
+
+        edge = createTestEdgeIterator("Augustine St");
+        assertTrue(createNameSimilarityEdgeFilter("Augustine St").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Augustine Street").accept(edge));
+    }
 
+    @Test
+    public void testWithDash() {
+        EdgeIteratorState edge = createTestEdgeIterator("Ben-Gurion-Straße");
+        assertTrue(createNameSimilarityEdgeFilter("Ben-Gurion").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Ben Gurion").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Ben Gurion Strasse").accept(edge));
+        assertFalse(createNameSimilarityEdgeFilter("Potsdamer Str.").accept(edge));
     }
 
     @Ignore
-    public void testThatShouldSucceed(){
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        // The Problem is that Rd vs Road is abreviated, if we have Road, it works
-        edgeFilter = createNameSimilarityEdgeFilter("257 Main Rd, Claremont, Cape Town, 7708, Afrique du Sud");
-        edge = createTestEdgeIterator("Main Road");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Just too much difference Between Google Maps and OSM @ 32.121435,-110.857969
-        edgeFilter = createNameSimilarityEdgeFilter("7202 S Wilmot Rd, Tucson, AZ 85701");
-        edge = createTestEdgeIterator("South Wilmot Road");
-        assertTrue(edgeFilter.accept(edge));
+    public void testThatShouldSucceed() {
+        // Google Maps vs OSM @ 32.121435,-110.857969
+        assertTrue(createNameSimilarityEdgeFilter("S Wilmot Rd").accept(createTestEdgeIterator("South Wilmot Road")));
 
         // @ 37.307774,13.581259
-        edgeFilter = createNameSimilarityEdgeFilter("Via Manzoni, 50/52, 92100 Agrigento AG, Italy");
-        edge = createTestEdgeIterator("Via Alessandro Manzoni");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = createNameSimilarityEdgeFilter("Av. Juan Ramón Ramírez, 12, 02630 La Roda, Albacete, Spain");
-        edge = createTestEdgeIterator("Avenida Juan Ramón Ramírez");
-        assertTrue(edgeFilter.accept(edge));
-
-
+        assertTrue(createNameSimilarityEdgeFilter("Via Manzoni").accept(createTestEdgeIterator("Via Alessandro Manzoni")));
     }
 
-
     /**
      * We ignore Typos for now, most GeoCoders return pretty good results, we might allow some typos
      */
-    @Ignore
+    @Test
     public void testAcceptWithTypos() {
         EdgeFilter edgeFilter = createNameSimilarityEdgeFilter("Laufamholzstraße 154 Nürnberg");
         EdgeIteratorState edge = createTestEdgeIterator("Laufamholzstraße, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
         // Single Typo
-        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholzstraße 154 Nürnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholzstraße");
         assertTrue(edgeFilter.accept(edge));
 
         // Two Typos
-        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholystraße 154 Nürnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholystraße");
         assertTrue(edgeFilter.accept(edge));
 
         // Three Typos
-        edgeFilter = createNameSimilarityEdgeFilter("Kaufmholystraße 154 Nürnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufmholystraße");
         assertFalse(edgeFilter.accept(edge));
 
         edgeFilter = createNameSimilarityEdgeFilter("Hauptstraße");
@@ -215,27 +171,13 @@ public void testAcceptWithTypos() {
 
         // Two Typos
         edgeFilter = createNameSimilarityEdgeFilter("Lauptstrase");
-        assertTrue(edgeFilter.accept(edge));
-
-        // We ignore too short Strings for now
-        /*
-        // Distance - PerfectDistance = 1
-        edgeFilter = createNameSimilarityEdgeFilter("z");
-        assertFalse(edgeFilter.accept(edge));
-        // Distance - PerfectDistance = 1
-        edgeFilter = createNameSimilarityEdgeFilter("az");
-        assertFalse(edgeFilter.accept(edge));
-
-        // Distance - PerfectDistance = 2
-        edgeFilter = createNameSimilarityEdgeFilter("xy");
-        assertFalse(edgeFilter.accept(edge));
-        */
+//        assertTrue(edgeFilter.accept(edge));
     }
 
     private NameSimilarityEdgeFilter createNameSimilarityEdgeFilter(String s) {
         return new NameSimilarityEdgeFilter(DefaultEdgeFilter.allEdges(new CarFlagEncoder()), s);
     }
-    
+
     private EdgeIteratorState createTestEdgeIterator(final String name) {
         return new GHUtility.DisabledEdgeIterator() {
 
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 2352ddc1d7..bf3b188868 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -30,6 +30,12 @@ $ ./graphhopper.sh -a web -i north-america_us_new-york.pbf -o new-york-gh
 # the format follows the link structure at http://download.geofabrik.de
 ```
 
+For larger maps you might need to allow the JVM to access more memory. For example for 2GB you can do this using:
+```bash
+$ export JAVA_OPTS="-Xmx=2g -Xms=2g"
+```
+before running `graphhopper.sh`.
+
 ## Start Development
 
 Open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index 45acff304e..ac47f822b8 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -6,7 +6,10 @@ The following steps are simpler and only need the JRE, a jar file and an OSM fil
  1. Install the latest JRE and get the [GraphHopper Web Service](https://github.com/graphhopper/graphhopper/blob/master/README.md#get-started)
 as jar file
  2. Copy an OSM file to the same directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
- 3. Start GraphHopper Maps via: `java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-example.yml`
+ 3. Start GraphHopper Maps via: 
+    ```bash
+    java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-example.yml
+    ```
  4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
 
 See [here](./../core/elevation.md) how to easily enable elevation data. To see how GraphHopper is configured for production usage, see the [deployment guide](./../core/deploy.md).
@@ -17,4 +20,6 @@ See [here](./../core/elevation.md) how to easily enable elevation data. To see h
  * Regarding step 2:
     * The folder where you execute the java command should contain the following files: berlin-latest.osm.pbf, config-example.yml and `graphhopper-web-[version].jar`
     * The first time you execute this it'll take ~30 seconds (for Berlin), further starts will only load the graph and should be nearly instantaneous. You should see log statements but no exceptions and the last entry should be something like: Started server at HTTP 8989
+ * Regarding step 3:
+    * Depending on the size of the map you might run into `java.lang.OutOfMemoryError`. In this case you need to increase the memory settings of the JVM by starting the above command with `java -Xmx2g -Xms2g ...` (example for 2GB memory)
  * Or [contact us](../index.md#contact)
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index f4f1131016..7fd7ab57a2 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -45,19 +45,18 @@
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
-    private final PtTravelTimeWeighting weighting;
     private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
     private final Graph graph;
     private final boolean walkOnly;
+    private double walkSpeedKmH;
 
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
+    GraphExplorer(Graph graph, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
         this.graph = graph;
         this.edgeExplorer = graph.createEdgeExplorer(reverse ? DefaultEdgeFilter.inEdges(flagEncoder) : DefaultEdgeFilter.outEdges(flagEncoder));
         this.flagEncoder = flagEncoder;
-        this.weighting = weighting;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
@@ -70,6 +69,7 @@
             extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalTraversalKey(), extraEdge.getEdge(), extraEdge.getAdjNode(), extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3)));
         }
         this.walkOnly = walkOnly;
+        this.walkSpeedKmH = walkSpeedKmh;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
@@ -100,7 +100,7 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
         switch (edgeType) {
             case HIGHWAY:
-                return weighting.calcMillis(edge, false, -1);
+                return (long) (getWalkDistance(edge) * 3.6 / walkSpeedKmH) * 1000;
             case ENTER_TIME_EXPANDED_NETWORK:
                 if (reverse) {
                     return 0;
@@ -118,15 +118,15 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         }
     }
 
-    public boolean isBlocked(EdgeIteratorState edge) {
+    boolean isBlocked(EdgeIteratorState edge) {
         return realtimeFeed.isBlocked(edge.getEdge());
     }
 
-    public long getDelayFromBoardEdge(EdgeIteratorState edge, long currentTime) {
+    long getDelayFromBoardEdge(EdgeIteratorState edge, long currentTime) {
         return realtimeFeed.getDelayForBoardEdge(edge, Instant.ofEpochMilli(currentTime));
     }
 
-    public long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
+    long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
         return realtimeFeed.getDelayForAlightEdge(edge, Instant.ofEpochMilli(currentTime));
     }
 
@@ -156,6 +156,23 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         }
     }
 
+    int calcNTransfers(EdgeIteratorState edge) {
+        return flagEncoder.getTransfers(edge.getFlags());
+    }
+
+    double getWalkDistance(EdgeIteratorState edge) {
+        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+        switch (edgeType) {
+            case HIGHWAY:
+                return edge.getDistance();
+            case ENTER_PT:
+            case EXIT_PT:
+                return 10.0;
+            default:
+                return 0.0;
+        }
+    }
+
     EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
         if (edgeId == -1) {
             throw new RuntimeException();
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 05e063f30c..f1f41e7cbe 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -18,13 +18,19 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.Transfer;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.*;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
@@ -96,7 +102,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final double maxWalkDistancePerLeg;
         private final double maxTransferDistancePerLeg;
         private final int blockedRouteTypes;
-        private final PtTravelTimeWeighting weighting;
+        private final Weighting weighting;
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
@@ -124,7 +130,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 1000.0);
             maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
             blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
-            weighting = createPtTravelTimeWeighting(flagEncoder, arriveBy, walkSpeedKmH);
+            weighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
@@ -167,7 +173,7 @@ GHResponse route() {
         }
 
         private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, extraEdges, true);
+            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, reverse, extraEdges, true, walkSpeedKmH);
             int nextNodeId = graphWithExtraEdges.getNodes() + 2 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
             int nextEdgeId = graphWithExtraEdges.getAllEdges().length() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
 
@@ -180,9 +186,9 @@ private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint
                         nextEdgeId++, reverse ? stationNode.adjNode : nextNodeId, reverse ? nextNodeId : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
                         nextEdgeId++, reverse ? nextNodeId : stationNode.adjNode, reverse ? stationNode.adjNode : nextNodeId, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
-                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
+                newEdge.setFlags(flagEncoder.setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
                 final long time = pathWrapper.getTime() / 1000;
-                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setTime(newEdge.getFlags(), time));
+                newEdge.setFlags(flagEncoder.setTime(newEdge.getFlags(), time));
                 newEdge.setFlags(flagEncoder.setValidityId(newEdge.getFlags(), flagEncoder.getValidityId(graphExplorer.getEdgeIteratorState(stationNode.edge, Integer.MIN_VALUE).getFlags())));
                 reverseNewEdge.setFlags(newEdge.getFlags());
                 newEdge.setReverseEdge(reverseNewEdge);
@@ -200,7 +206,7 @@ private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint
 
         private List<Label> findStationNodes(GraphExplorer graphExplorer, int node, boolean reverse) {
             GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, reverse, maxWalkDistancePerLeg, maxTransferDistancePerLeg, false, false, maxVisitedNodesForRequest);
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, maxTransferDistancePerLeg, false, false, maxVisitedNodesForRequest);
             final Stream<Label> labels = router.calcLabels(node, -1, initialTime, blockedRouteTypes);
             return labels
                     .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
@@ -208,10 +214,14 @@ private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint
         }
 
         private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
-            QueryResult source = locationIndex.findClosest(point.lat, point.lon, new EverythingButPt(flagEncoder));
+            final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+            QueryResult source = locationIndex.findClosest(point.lat, point.lon, filter);
             if (!source.isValid()) {
                 throw new PointNotFoundException("Cannot find point: " + point, indexForErrorMessage);
             }
+            if (flagEncoder.getEdgeType(source.getClosestEdge().getFlags()) != GtfsStorage.EdgeType.HIGHWAY) {
+                throw new RuntimeException(flagEncoder.getEdgeType(source.getClosestEdge().getFlags()).name());
+            }
             return source;
         }
 
@@ -266,8 +276,8 @@ private int egressNode(Label solution) {
 
         private List<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false);
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, -1, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
+            graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, -1, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
             final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime, 0);
             List<Label> solutions = labels
                     .filter(current -> destNode == current.adjNode)
@@ -343,8 +353,18 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
             } else {
                 walkNetworkIndex = new EmptyLocationIndex();
             }
+            GraphHopperGtfs graphHopperGtfs = new GraphHopperGtfs(ptFlagEncoder, createTranslationMap(), graphHopperStorage, walkNetworkIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
             for (int i = 0; i < id; i++) {
-                new GtfsReader("gtfs_" + i, graphHopperStorage, gtfsStorage, ptFlagEncoder, walkNetworkIndex).readGraph();
+                GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get("gtfs_" + i);
+                GtfsReader gtfsReader = new GtfsReader("gtfs_" + i, graphHopperStorage, gtfsStorage, ptFlagEncoder, walkNetworkIndex);
+                gtfsReader.connectStopsToStreetNetwork();
+                graphHopperGtfs.getType0TransferWithTimes(gtfsFeed)
+                        .forEach(t -> {
+                            t.transfer.transfer_type = 2;
+                            t.transfer.min_transfer_time = (int) (t.time / 1000L);
+                            gtfsFeed.transfers.put(t.id, t.transfer);
+                        });
+                gtfsReader.readGraph();
             }
             graphHopperStorage.flush();
             return graphHopperStorage;
@@ -352,9 +372,9 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
     }
 
 
-    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage, PtFlagEncoder flagEncoder) {
-        final EverythingButPt everythingButPt = new EverythingButPt(flagEncoder);
-        Graph walkNetwork = GraphSupport.filteredView(graphHopperStorage, everythingButPt);
+    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage) {
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+        Graph walkNetwork = GraphSupport.filteredView(graphHopperStorage, filter);
         LocationIndex locationIndex = new LocationIndexTree(walkNetwork, directory);
         if (!locationIndex.loadExisting()) {
             locationIndex.prepareIndex();
@@ -371,12 +391,43 @@ public GHResponse route(GHRequest request) {
         return new RequestHandler(request).route();
     }
 
-    private static PtTravelTimeWeighting createPtTravelTimeWeighting(PtFlagEncoder encoder, boolean arriveBy, double walkSpeedKmH) {
-        PtTravelTimeWeighting weighting = new PtTravelTimeWeighting(encoder, walkSpeedKmH);
-        if (arriveBy) {
-            weighting = weighting.reverse();
-        }
-        return weighting;
+    private class TransferWithTime {
+        public String id;
+        Transfer transfer;
+        long time;
+    }
+
+    private Stream<TransferWithTime> getType0TransferWithTimes(GTFSFeed gtfsFeed) {
+        return gtfsFeed.transfers.entrySet()
+                .parallelStream()
+                .filter(e -> e.getValue().transfer_type == 0)
+                .map(e -> {
+                    PointList points = new PointList(2, false);
+                    final int fromnode = gtfsStorage.getStationNodes().get(e.getValue().from_stop_id);
+                    final QueryResult fromstation = new QueryResult(graphHopperStorage.getNodeAccess().getLat(fromnode), graphHopperStorage.getNodeAccess().getLon(fromnode));
+                    fromstation.setClosestNode(fromnode);
+                    points.add(graphHopperStorage.getNodeAccess().getLat(fromnode), graphHopperStorage.getNodeAccess().getLon(fromnode));
+
+                    final int tonode = gtfsStorage.getStationNodes().get(e.getValue().to_stop_id);
+                    final QueryResult tostation = new QueryResult(graphHopperStorage.getNodeAccess().getLat(tonode), graphHopperStorage.getNodeAccess().getLon(tonode));
+                    tostation.setClosestNode(tonode);
+                    points.add(graphHopperStorage.getNodeAccess().getLat(tonode), graphHopperStorage.getNodeAccess().getLon(tonode));
+
+                    QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+                    queryGraph.lookup(Collections.emptyList());
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+
+                    MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, Double.MAX_VALUE, false, false, Integer.MAX_VALUE);
+                    final Stream<Label> labels = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0);
+                    List<Label> solutions = labels
+                            .filter(current -> tonode == current.adjNode)
+                            .collect(Collectors.toList());
+                    TransferWithTime transferWithTime = new TransferWithTime();
+                    transferWithTime.id = e.getKey();
+                    transferWithTime.transfer = e.getValue();
+                    transferWithTime.time = solutions.get(0).currentTime;
+                    return transferWithTime;
+                });
     }
 
     private PointList pointListFrom(List<QueryResult> queryResults) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 16b8797381..3a7aefb3c5 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -32,7 +32,9 @@
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -138,19 +140,21 @@ void readGraph() {
         gtfsStorage.getFares().putAll(feed.fares);
         transfers = new Transfers(feed);
         gtfsStorage.getTransfers().put(id, transfers);
-        connectStopsToStreetNetwork();
         buildPtNetwork();
     }
 
-    private void connectStopsToStreetNetwork() {
-        EdgeFilter filter = new EverythingButPt(encoder);
+    void connectStopsToStreetNetwork() {
+        FlagEncoder footEncoder = ((GraphHopperStorage) graph).getEncodingManager().getEncoder("foot");
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(footEncoder);
         for (Stop stop : feed.stops.values()) {
             QueryResult locationQueryResult = walkNetworkIndex.findClosest(stop.stop_lat, stop.stop_lon, filter);
             int streetNode;
             if (!locationQueryResult.isValid()) {
                 streetNode = i++;
                 nodeAccess.setNode(streetNode, stop.stop_lat, stop.stop_lon);
-                graph.edge(streetNode, streetNode, 0.0, false);
+                EdgeIteratorState edge = graph.edge(streetNode, streetNode);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                edge.setFlags(footEncoder.setAccess(edge.getFlags(), true, false));
             } else {
                 streetNode = locationQueryResult.getClosestNode();
             }
@@ -216,7 +220,8 @@ void wireUpStops() {
                         int stopExitNode = i-1;
                         nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
 
-                        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode, 0.0, false);
+                        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode);
+                        exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
                         setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                         exitEdge.setFlags(encoder.setValidityId(exitEdge.getFlags(), route.route_type));
                         exitEdge.setName(stop.stop_name);
@@ -237,7 +242,8 @@ void wireUpStops() {
                         int stopEnterNode = i-1;
                         nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
 
-                        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode, 0.0, false);
+                        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode);
+                        entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
                         setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
                         entryEdge.setFlags(encoder.setValidityId(entryEdge.getFlags(), route.route_type));
                         entryEdge.setName(stop.stop_name);
@@ -266,14 +272,16 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                         SortedSet<Fun.Tuple2<Integer, Integer>> headSet = staticTimelineNodesForRoute.headSet(timelineNode);
                         if(!headSet.isEmpty()) {
                             Fun.Tuple2<Integer, Integer> before = headSet.last();
-                            EdgeIteratorState edge = graph.edge(before.b, timelineNode.b,0.0, false);
+                            EdgeIteratorState edge = graph.edge(before.b, timelineNode.b);
+                            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                             setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
                             edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a-before.a));
                         }
                         SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = staticTimelineNodesForRoute.tailSet(timelineNode);
                         if (!tailSet.isEmpty()) {
                             Fun.Tuple2<Integer, Integer> after = tailSet.first();
-                            EdgeIteratorState edge = graph.edge(timelineNode.b, after.b, 0.0, false);
+                            EdgeIteratorState edge = graph.edge(timelineNode.b, after.b);
+                            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                             setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
                             edge.setFlags(encoder.setTime(edge.getFlags(), after.a-timelineNode.a));
 
@@ -287,7 +295,8 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
 
                         }
 
-                        EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b, 0.0, false);
+                        EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b);
+                        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                         setEdgeType(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
                         edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
                         setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
@@ -296,7 +305,8 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                     nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
                     int stopEnterNode = i-1;
                     nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-                    EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode, 0.0, false);
+                    EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode);
+                    entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
                     setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
                     entryEdge.setName(stop.stop_name);
                     NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
@@ -311,7 +321,8 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                 if (platformNode != -1) {
                     Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
                     realtimeTimelineIterator.forEachRemaining(timelineNode -> {
-                        EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode, 0.0, false);
+                        EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode);
+                        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                         setEdgeType(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
                         edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
                         setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
@@ -320,7 +331,8 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                     nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
                     int stopExitNode = i-1;
                     nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-                    EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode, 0.0, false);
+                    EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode);
+                    exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
                     setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                     exitEdge.setName(stop.stop_name);
                     wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
@@ -443,11 +455,9 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                         fromStop.stop_lon,
                         stop.stop_lat,
                         stop.stop_lon);
-                EdgeIteratorState edge = graph.edge(
-                        departureNode,
-                        arrivalNode,
-                        distance,
-                        false);
+                EdgeIteratorState edge = graph.edge(departureNode, arrivalNode);
+                edge.setDistance(distance);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 edge.setName(stop.stop_name);
                 setEdgeType(edge, GtfsStorage.EdgeType.HOP);
                 edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
@@ -477,11 +487,8 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                 gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
             }
 
-            EdgeIteratorState boardEdge = graph.edge(
-                    departureTimelineNode,
-                    departureNode,
-                    0.0,
-                    false);
+            EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
+            boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
             boardEdge.setName(getRouteName(feed, trip.trip));
             setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
             while (boardEdges.size() < stopTime.stop_sequence) {
@@ -493,11 +500,8 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
             boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
 
-            EdgeIteratorState alightEdge = graph.edge(
-                    arrivalNode,
-                    arrivalTimelineNode,
-                    0.0,
-                    false);
+            EdgeIteratorState alightEdge = graph.edge(arrivalNode, arrivalTimelineNode);
+            alightEdge.setFlags(encoder.setAccess(alightEdge.getFlags(), true, false));
             alightEdge.setName(getRouteName(feed, trip.trip));
             setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
             while (alightEdges.size() < stopTime.stop_sequence) {
@@ -510,11 +514,8 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
 //                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
 
 
-            EdgeIteratorState dwellEdge = graph.edge(
-                    arrivalNode,
-                    departureNode,
-                    0.0,
-                    false);
+            EdgeIteratorState dwellEdge = graph.edge(arrivalNode, departureNode);
+            dwellEdge.setFlags(encoder.setAccess(dwellEdge.getFlags(), true, false));
             dwellEdge.setName(getRouteName(feed, trip.trip));
             setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
             dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
@@ -551,11 +552,8 @@ int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescripto
             gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
         }
 
-        EdgeIteratorState boardEdge = graph.edge(
-                departureTimelineNode,
-                departureNode,
-                0.0,
-                false);
+        EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
+        boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
         boardEdge.setName(getRouteName(feed, trip));
         setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
         gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopSequence);
@@ -570,13 +568,15 @@ private void wireUpAndAndConnectArrivalTimeline(Stop toStop, String routeId, int
         int time = 0;
         int prev = -1;
         for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode, 0.0, false);
+            EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode);
+            leaveTimeExpandedNetworkEdge.setFlags(encoder.setAccess(leaveTimeExpandedNetworkEdge.getFlags(), true, false));
             setEdgeType(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
             int arrivalTime = e.a;
             leaveTimeExpandedNetworkEdge.setFlags(encoder.setTime(leaveTimeExpandedNetworkEdge.getFlags(), arrivalTime));
             setFeedIdWithTimezone(leaveTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev, 0.0, false);
+                EdgeIteratorState edge = graph.edge(e.b, prev);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 setEdgeType(edge, GtfsStorage.EdgeType.WAIT_ARRIVAL);
                 edge.setName(toStop.stop_name);
                 edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
@@ -602,13 +602,15 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
         int time = 0;
         int prev = -1;
         for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState enterTimeExpandedNetworkEdge = graph.edge(stopEnterNode, e.b, 0.0, false);
+            EdgeIteratorState enterTimeExpandedNetworkEdge = graph.edge(stopEnterNode, e.b);
+            enterTimeExpandedNetworkEdge.setFlags(encoder.setAccess(enterTimeExpandedNetworkEdge.getFlags(), true, false));
             enterTimeExpandedNetworkEdge.setName(toStop.stop_name);
             setEdgeType(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
             enterTimeExpandedNetworkEdge.setFlags(encoder.setTime(enterTimeExpandedNetworkEdge.getFlags(), e.a));
             setFeedIdWithTimezone(enterTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev, 0.0, false);
+                EdgeIteratorState edge = graph.edge(e.b, prev);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
                 edge.setName(toStop.stop_name);
                 edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
@@ -617,7 +619,8 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
             prev = e.b;
         }
         if (!timeNodes.isEmpty()) {
-            EdgeIteratorState edge = graph.edge(timeNodes.last().b, timeNodes.first().b, 0.0, false);
+            EdgeIteratorState edge = graph.edge(timeNodes.last().b, timeNodes.first().b);
+            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
             int rolloverTime = 24 * 60 * 60 - timeNodes.last().a + timeNodes.first().a;
             setEdgeType(edge, GtfsStorage.EdgeType.OVERNIGHT);
             edge.setName(toStop.stop_name);
@@ -628,7 +631,6 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
     private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
         BitSet accumulatorValidity = new BitSet(validOn.validity.size());
         accumulatorValidity.or(validOn.validity);
-        EdgeIteratorState boardEdge;
         ListIterator<TripWithStopTimeAndArrivalNode> li = arrivalNodes.listIterator(arrivalNodes.size());
         while(li.hasPrevious() && accumulatorValidity.cardinality() > 0) {
             TripWithStopTimeAndArrivalNode lastTrip = li.previous();
@@ -647,18 +649,12 @@ private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> ar
                 }
                 nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
                 nodeAccess.setAdditionalNodeField(i-1, NodeType.INTERNAL_PT.ordinal());
-                boardEdge = graph.edge(
-                        lastTrip.arrivalNode,
-                        i-1,
-                        0.0,
-                        false);
-                setEdgeType(boardEdge, GtfsStorage.EdgeType.TRANSFER);
-                boardEdge.setFlags(encoder.setTime(boardEdge.getFlags(), dwellTime));
-                boardEdge = graph.edge(
-                        i-1,
-                        departureNode,
-                        0.0,
-                        false);
+                EdgeIteratorState transferEdge = graph.edge(lastTrip.arrivalNode,i-1);
+                transferEdge.setFlags(encoder.setAccess(transferEdge.getFlags(), true, false));
+                setEdgeType(transferEdge, GtfsStorage.EdgeType.TRANSFER);
+                transferEdge.setFlags(encoder.setTime(transferEdge.getFlags(), dwellTime));
+                EdgeIteratorState boardEdge = graph.edge(i-1, departureNode);
+                boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
                 setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
                 boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), blockTransferValidityId));
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
@@ -692,7 +688,8 @@ private void insertInboundTransfers(String fromStopId, String from_route_id, int
                             SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = toStopTimelineNode.tailSet(new Fun.Tuple2<>(arrivalTime + minimumTransferTime, -1));
                             if (!tailSet.isEmpty()) {
                                 Fun.Tuple2<Integer, Integer> e = tailSet.first();
-                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), e.b, 0.0, false);
+                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), e.b);
+                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                                 setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
                                 edge.setFlags(encoder.setTime(edge.getFlags(), e.a - arrivalTime));
                             }
@@ -720,7 +717,8 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
                                 if (departureTime < e.a + minimumTransferTime) {
                                     continue;
                                 }
-                                EdgeIteratorState edge = graph.edge(e.b, j.getAdjNode(), 0.0, false);
+                                EdgeIteratorState edge = graph.edge(e.b, j.getAdjNode());
+                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                                 setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
                                 edge.setFlags(encoder.setTime(edge.getFlags(), departureTime - e.a));
                                 break;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 1400502b93..fd5d8e6dec 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -19,7 +19,6 @@
 
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.Multimap;
-import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -44,7 +43,6 @@
     private long startTime;
     private int blockedRouteTypes;
     private final PtFlagEncoder flagEncoder;
-    private final PtTravelTimeWeighting weighting;
     private final Multimap<Integer, Label> fromMap;
     private final PriorityQueue<Label> fromHeap;
     private final int maxVisitedNodes;
@@ -56,9 +54,8 @@
     private int visitedNodes;
     private final GraphExplorer explorer;
 
-    MultiCriteriaLabelSetting(GraphExplorer explorer, Weighting weighting, boolean reverse, double maxWalkDistancePerLeg, double maxTransferDistancePerLeg, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes) {
-        this.weighting = (PtTravelTimeWeighting) weighting;
-        this.flagEncoder = (PtFlagEncoder) weighting.getFlagEncoder();
+    MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, double maxTransferDistancePerLeg, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes) {
+        this.flagEncoder = flagEncoder;
         this.maxVisitedNodes = maxVisitedNodes;
         this.explorer = explorer;
         this.reverse = reverse;
@@ -122,7 +119,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     } else {
                         nextTime = label.currentTime + explorer.calcTravelTimeMillis(edge, label.currentTime);
                     }
-                    int nTransfers = label.nTransfers + weighting.calcNTransfers(edge);
+                    int nTransfers = label.nTransfers + explorer.calcNTransfers(edge);
                     Long firstPtDepartureTime = label.departureTime;
                     if (!reverse && (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK || edgeType == GtfsStorage.EdgeType.WAIT)) {
                         if (label.nTransfers == 0) {
@@ -133,7 +130,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                             firstPtDepartureTime = nextTime - label.walkTime;
                         }
                     }
-                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + weighting.getWalkDistance(edge));
+                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + explorer.getWalkDistance(edge));
                     boolean isTryingToReEnterPtAfterTransferWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
                     long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? nextTime - label.currentTime : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index 34daa5f3e6..dd1cb35e1e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -54,14 +54,14 @@ public int defineWayBits(int index, int shift) {
 		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, 0, 0);
 		shift += speedEncoder.getBits();
 
-		time = new EncodedValue("time", shift, 32, 1.0, 0, Integer.MAX_VALUE);
+		time = new EncodedValue("time", shift, 17, 1.0, 0, 24*60*60);
 		shift += time.getBits();
 		transfers = new EncodedValue("transfers", shift, 1, 1.0, 0, 1);
 		shift += transfers.getBits();
 		validityId = new EncodedValue("validityId", shift, 20, 1.0, 0, 1048575);
 		shift += validityId.getBits();
 		GtfsStorage.EdgeType[] edgeTypes = GtfsStorage.EdgeType.values();
-		type = new EncodedValue("type", shift, 6, 1.0, GtfsStorage.EdgeType.HIGHWAY.ordinal(), edgeTypes[edgeTypes.length-1].ordinal());
+		type = new EncodedValue("type", shift, 4, 1.0, GtfsStorage.EdgeType.HIGHWAY.ordinal(), edgeTypes[edgeTypes.length-1].ordinal());
 		shift += type.getBits();
 		return shift;
 	}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
deleted file mode 100644
index b119fc953a..0000000000
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.graphhopper.reader.gtfs;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.util.EdgeIteratorState;
-
-import java.time.Instant;
-
-class PtTravelTimeWeighting extends AbstractWeighting {
-
-    private final boolean reverse;
-    private final double walkSpeedKmH;
-    private final int transferFactor;
-
-    PtTravelTimeWeighting(FlagEncoder encoder, double walkSpeedKmH) {
-		this(encoder, false, walkSpeedKmH, 1);
-    }
-
-    private PtTravelTimeWeighting(FlagEncoder encoder, boolean reverse, double walkSpeedKmH, int transferFactor) {
-        super(encoder);
-        this.reverse = reverse;
-        this.walkSpeedKmH = walkSpeedKmH;
-        this.transferFactor = transferFactor;
-    }
-
-    PtTravelTimeWeighting reverse() {
-        return new PtTravelTimeWeighting(flagEncoder, !reverse, walkSpeedKmH, transferFactor);
-    }
-
-    @Override
-	public double getMinWeight(double distance) {
-		return 0.0;
-	}
-
-	@Override
-	public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-		throw new RuntimeException("Not supported.");
-	}
-
-    @Override
-    public long calcMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-        GtfsStorage.EdgeType edgeType = ((PtFlagEncoder) getFlagEncoder()).getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return (long) (getWalkDistance(edge) * 3.6 / walkSpeedKmH) * 1000;
-            case ENTER_TIME_EXPANDED_NETWORK:
-            case LEAVE_TIME_EXPANDED_NETWORK:
-                return 0;
-            default:
-                return ((PtFlagEncoder) getFlagEncoder()).getTime(edge.getFlags());
-        }
-    }
-
-	int calcNTransfers(EdgeIteratorState edge) {
-        return transferFactor * ((PtFlagEncoder) getFlagEncoder()).getTransfers(edge.getFlags());
-	}
-
-    double getWalkDistance(EdgeIteratorState edge) {
-        GtfsStorage.EdgeType edgeType = ((PtFlagEncoder) getFlagEncoder()).getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return edge.getDistance();
-            case ENTER_PT:
-            case EXIT_PT:
-                return 10.0;
-            default:
-                return 0.0;
-        }
-    }
-
-    @Override
-	public String getName() {
-		return "pttraveltime";
-	}
-
-}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 76dba608b7..2a45fa86c1 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -32,6 +32,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
@@ -105,14 +106,14 @@ public static RealtimeFeed empty(GtfsStorage staticGtfs) {
         return new RealtimeFeed(staticGtfs, Collections.emptyMap(), new IntHashSet(), new IntLongHashMap(), new IntLongHashMap(), Collections.emptyList(), Collections.emptyMap(), Collections.emptyMap(), staticGtfs.getOperatingDayPatterns(), staticGtfs.getWritableTimeZones());
     }
 
-    public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, Map<String, GtfsRealtime.FeedMessage> feedMessages) {
+    public static RealtimeFeed fromProtobuf(GraphHopperStorage graphHopperStorage, GtfsStorage staticGtfs, PtFlagEncoder encoder, Map<String, GtfsRealtime.FeedMessage> feedMessages) {
         final IntHashSet blockedEdges = new IntHashSet();
         final IntLongHashMap delaysForBoardEdges = new IntLongHashMap();
         final IntLongHashMap delaysForAlightEdges = new IntLongHashMap();
         final LinkedList<VirtualEdgeIteratorState> additionalEdges = new LinkedList<>();
         final Graph overlayGraph = new Graph() {
             int nNodes = 0;
-            int firstEdge = graph.getAllEdges().length();
+            int firstEdge = graphHopperStorage.getAllEdges().length();
             final NodeAccess nodeAccess = new NodeAccess() {
                 IntIntHashMap additionalNodeFields = new IntIntHashMap();
 
@@ -183,12 +184,12 @@ public double getEle(int nodeId) {
             };
             @Override
             public Graph getBaseGraph() {
-                return graph;
+                return graphHopperStorage;
             }
 
             @Override
             public int getNodes() {
-                return graph.getNodes() + nNodes;
+                return graphHopperStorage.getNodes() + nNodes;
             }
 
             @Override
@@ -203,23 +204,22 @@ public BBox getBounds() {
 
             @Override
             public EdgeIteratorState edge(int a, int b) {
-                return null;
-            }
-
-            @Override
-            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
                 int edge = firstEdge++;
                 final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(-1,
-                        edge, a, b, distance,0, "", new PointList());
+                        edge, a, b, 0.0, 0, "", new PointList());
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(-1,
-                        edge, b, a, distance,0, "", new PointList());
-
+                        edge, b, a, 0.0, 0, "", new PointList());
                 newEdge.setReverseEdge(reverseNewEdge);
                 reverseNewEdge.setReverseEdge(newEdge);
                 additionalEdges.push(newEdge);
                 return newEdge;
             }
 
+            @Override
+            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+                return null;
+            }
+
             @Override
             public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
                 return null;
@@ -237,7 +237,7 @@ public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
 
             @Override
             public EdgeExplorer createEdgeExplorer() {
-                return graph.createEdgeExplorer();
+                return graphHopperStorage.createEdgeExplorer();
             }
 
             @Override
@@ -359,7 +359,7 @@ public GraphExtension getExtension() {
                             int departureDelay = stopTime.departure_time - originalStopTime.departure_time;
                             if (departureDelay > 0) {
                                 int boardEdge = boardEdges[stopTime.stop_sequence];
-                                int departureNode = graph.getEdgeIteratorState(boardEdge, Integer.MIN_VALUE).getAdjNode();
+                                int departureNode = graphHopperStorage.getEdgeIteratorState(boardEdge, Integer.MIN_VALUE).getAdjNode();
                                 int delayedBoardEdge = gtfsReader.addDelayedBoardEdge(timezone, tripUpdate.getTrip(), stopTime.stop_sequence, stopTime.departure_time + timeOffset, departureNode, validOnDay);
                                 delaysForBoardEdges.put(delayedBoardEdge, departureDelay * 1000);
                             }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 2ad0689678..d668033935 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -59,7 +59,7 @@
         this.realtimeFeed = realtimeFeed;
     }
 
-    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution, PointList waypoints) {
         final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         return createPathWrapper(tr, waypoints, legs);
     }
@@ -119,7 +119,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return path;
     }
 
-    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution) {
+    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -154,7 +154,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -375,6 +375,9 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
                     weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i = 1; i < path.size(); i++) {
+                if (path.get(i).edge.edgeType != GtfsStorage.EdgeType.HIGHWAY) {
+                    throw new IllegalStateException("Got a transit edge where I think I must be on a road.");
+                }
                 EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
                 instructionsFromEdges.next(edge, i, prevEdgeId);
                 prevEdgeId = edge.getEdge();
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index 379a762b44..ece1abf017 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -22,27 +22,21 @@
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
-import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
-import java.math.BigDecimal;
 import java.time.LocalDateTime;
-import java.time.LocalTime;
 import java.time.ZoneId;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -61,11 +55,11 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 18f311f34f..2952deddbf 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -21,7 +21,9 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -29,7 +31,6 @@
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
-import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -62,11 +63,14 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(carFlagEncoder, footFlagEncoder, ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index f0200d359e..c305f9bacd 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -22,6 +22,7 @@
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -51,11 +52,11 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index b90a872374..283e3d9ddb 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -22,7 +22,9 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -30,7 +32,6 @@
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -64,17 +65,17 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new FootFlagEncoder(), ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperStorage.close();
         locationIndex.close();
         // Re-load read only
         directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
 
@@ -116,12 +117,12 @@ public void testSkipDepartureStop() {
 
         PathWrapper possibleAlternative = response.getAll().get(0);
         assertFalse(possibleAlternative.isImpossible());
-        assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
+        assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
         assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), possibleAlternative.getTime(), 0.1);
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
     }
 
     @Test
@@ -155,13 +156,13 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
         assertEquals(2, response.getAll().size());
 
         PathWrapper best = response.getBest();
-        Trip.PtLeg bestPtLeg = (Trip.PtLeg) best.getLegs().get(1);
+        Trip.PtLeg bestPtLeg = (Trip.PtLeg) best.getLegs().get(0);
         assertEquals("It's better to wait half an hour for the next one (and ride 5 minutes).", LocalDateTime.parse("2007-01-01T07:19:00").atZone(zoneId).toInstant(), bestPtLeg.stops.get(bestPtLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("There is no predicted arrival time.", null, bestPtLeg.stops.get(bestPtLeg.stops.size()-1).predictedArrivalTime);
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.PtLeg impossiblePtLeg = (Trip.PtLeg) impossibleAlternative.getLegs().get(1);
+        Trip.PtLeg impossiblePtLeg = (Trip.PtLeg) impossibleAlternative.getLegs().get(0);
         assertEquals("The impossible alternative is my planned 5-minute-trip", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), impossiblePtLeg.stops.get(impossiblePtLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("..which is very late today", LocalDateTime.parse("2007-01-01T07:49:00").atZone(zoneId).toInstant(), impossiblePtLeg.stops.get(impossiblePtLeg.stops.size()-1).predictedArrivalTime.toInstant());
     }
@@ -231,7 +232,7 @@ public void testSkipArrivalStop() {
 
         PathWrapper impossibleAlternative = response.getAll().get(2);
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(1).arrivalCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(1).arrivalCancelled);
     }
 
     @Test
@@ -267,7 +268,7 @@ public void testSkipTransferStop() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2).departureCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2).departureCancelled);
     }
 
     @Test
@@ -405,8 +406,8 @@ public void testZeroDelay() {
         GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
-        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(responseWithRealtimeUpdate.getBest().getLegs().size()-2);
-        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(responseWithoutRealtimeUpdate.getBest().getLegs().size()-2);
+        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(0);
+        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(0);
         assertEquals("My planned arrival time is correct.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("My expected arrival time is the same.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).predictedArrivalTime.toInstant());
         assertEquals("The trip without realtime update does not have an expected arrival time.", null, responseWithoutRealtimeUpdateBest.stops.get(responseWithoutRealtimeUpdateBest.stops.size()-1).predictedArrivalTime);
@@ -480,7 +481,7 @@ public void testDelayFromBeginningWithoutTransfer() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size() - 2));
+        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(0));
         assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), ptLeg.getArrivalTime().toInstant());
         assertEquals("It is still reporting its original, scheduled time.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
     }
@@ -543,7 +544,7 @@ public void testBlockTripSkipsStop() {
         // Note that my stop (BULLFROG), which is skipped, is a switch of "block legs", so even though it looks like I (impossibly) transfer there,
         // this is not a real transfer. The bus drives through BULLFROG without stopping.
         // Very untypical example, but seems correct.
-        Trip.PtLeg ptLeg = (Trip.PtLeg) route.getBest().getLegs().get(4);
+        Trip.PtLeg ptLeg = (Trip.PtLeg) route.getBest().getLegs().get(3);
         assertEquals("I have to continue on AB1 which skips my stop, go all the way to the end, and ride back.", LocalDateTime.parse("2007-01-01T12:00:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("Using expected route", "BFC2", ptLeg.trip_id);
     }
@@ -580,7 +581,7 @@ public void testMissedTransferBecauseOfDelay() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2);
+        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2);
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
     }
 
@@ -716,7 +717,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2);
+        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2);
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
 
         // But when I ask about tomorrow, it works as planned
@@ -724,7 +725,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
         response = graphHopper.route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        Trip.Stop notDelayedStop = ((Trip.PtLeg) response.getBest().getLegs().get(1)).stops.get(2);
+        Trip.Stop notDelayedStop = ((Trip.PtLeg) response.getBest().getLegs().get(0)).stops.get(2);
         assertNull("Not late", notDelayedStop.predictedArrivalTime);
 
     }
@@ -756,9 +757,9 @@ public void testDelayAtEndForNonFrequencyBasedTrip() {
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Travel time == predicted travel time", time(8, 15), route.getBest().getTime(), 0.1);
-        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
-        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(2)).trip_id));
-        assertEquals("Delay at destination", LocalTime.parse("08:15"), LocalTime.from(((Trip.PtLeg) route.getBest().getLegs().get(2)).stops.get(1).predictedArrivalTime.toInstant().atZone(zoneId)));
+        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).trip_id));
+        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
+        assertEquals("Delay at destination", LocalTime.parse("08:15"), LocalTime.from(((Trip.PtLeg) route.getBest().getLegs().get(1)).stops.get(1).predictedArrivalTime.toInstant().atZone(zoneId)));
         assertEquals("Paid expected fare", 250, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue()); // Two legs, no transfers allowed. Need two 'p' tickets costing 125 cents each.
     }
 
diff --git a/web-api/src/main/java/com/graphhopper/MultiException.java b/web-api/src/main/java/com/graphhopper/MultiException.java
new file mode 100644
index 0000000000..6b59ce982e
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/MultiException.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper;
+
+import java.util.Collections;
+import java.util.List;
+
+public class MultiException extends RuntimeException {
+
+    private final List<Throwable> errors;
+
+    public MultiException(List<Throwable> errors) {
+        this.errors = errors;
+    }
+
+    public MultiException(Throwable e) {
+        this(Collections.singletonList(e));
+    }
+
+    public List<Throwable> getErrors() {
+        return errors;
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
index ac45eeb1ec..c26a46e270 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
@@ -1,6 +1,7 @@
 package com.graphhopper.jackson;
 
 import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.graphhopper.MultiException;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
@@ -18,6 +19,7 @@ public GraphHopperModule() {
         addSerializer(PathDetail.class, new PathDetailSerializer());
         addSerializer(InstructionList.class, new InstructionListSerializer());
         addDeserializer(CmdArgs.class, new CmdArgsDeserializer());
+        addSerializer(MultiException.class, new MultiExceptionSerializer());
     }
 
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java
new file mode 100644
index 0000000000..b7798eb9a8
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.MultiException;
+import com.graphhopper.util.exceptions.GHException;
+
+import java.io.IOException;
+import java.util.List;
+
+public class MultiExceptionSerializer extends JsonSerializer<MultiException> {
+
+    @Override
+    public void serialize(MultiException e, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
+        List<Throwable> errors = e.getErrors();
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.put("message", getMessage(errors.get(0)));
+        ArrayNode errorHintList = json.putArray("hints");
+        for (Throwable t : errors) {
+            ObjectNode error = errorHintList.addObject();
+            error.put("message", getMessage(t));
+            error.put("details", t.getClass().getName());
+            if (t instanceof GHException) {
+                ((GHException) t).getDetails().forEach(error::putPOJO);
+            }
+        }
+        jsonGenerator.writeObject(json);
+    }
+
+    private static String getMessage(Throwable t) {
+        if (t.getMessage() == null)
+            return t.getClass().getSimpleName();
+        else
+            return t.getMessage();
+    }
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index e59e6ed75e..8756484716 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -39,7 +39,9 @@
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.reader.gtfs.RealtimeFeed;
 import com.graphhopper.resources.*;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -53,6 +55,10 @@
 import org.glassfish.hk2.utilities.binding.AbstractBinder;
 
 import javax.inject.Inject;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.ext.WriterInterceptor;
+import javax.ws.rs.ext.WriterInterceptorContext;
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -183,6 +189,14 @@ public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider
     public void run(GraphHopperBundleConfiguration configuration, Environment environment) {
         configuration.getGraphHopperConfiguration().merge(CmdArgs.readFromSystemProperties());
 
+        // If the "?type=gpx" parameter is present, sets a corresponding media type header
+        environment.jersey().register(new TypeGPXFilter());
+
+        // Together, these two take care that MultiExceptions thrown from RouteResource
+        // come out as JSON or GPX, depending on the media type
+        environment.jersey().register(new MultiExceptionMapper());
+        environment.jersey().register(new MultiExceptionGPXMessageBodyWriter());
+
         if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
             // switch to different API implementation when using Pt
             runPtGraphHopper(configuration.getGraphHopperConfiguration(), environment);
@@ -195,13 +209,13 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.get("graph.location", "target/tmp"));
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 8);
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
                 configuration.getBool("gtfs.createwalknetwork", false),
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
-        final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage, ptFlagEncoder);
+        final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage);
         final GraphHopperAPI graphHopper = new GraphHopperGtfs(ptFlagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
         environment.jersey().register(new AbstractBinder() {
             @Override
@@ -221,6 +235,17 @@ protected void configure() {
         environment.jersey().register(IsochroneResource.class);
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
+        // Say we only support pt, even though we now have several flag encoders. Yes, I know, we're almost there.
+        environment.jersey().register((WriterInterceptor) context -> {
+            if (context.getEntity() instanceof InfoResource.Info) {
+                InfoResource.Info info = (InfoResource.Info) context.getEntity();
+                info.supported_vehicles = new String[]{"pt"};
+                info.features.remove("car");
+                info.features.remove("foot");
+                context.setEntity(info);
+            }
+            context.proceed();
+        });
         environment.lifecycle().manage(new Managed() {
             @Override
             public void start() throws Exception {
@@ -263,7 +288,6 @@ protected void configure() {
         environment.jersey().register(IsochroneResource.class);
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
-
         environment.healthChecks().register("graphhopper", new GraphHopperHealthCheck(graphHopperManaged.getGraphHopper()));
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java
new file mode 100644
index 0000000000..2f53c12107
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java
@@ -0,0 +1,99 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+import javax.ws.rs.Produces;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Provider;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+@Provider
+@Produces("application/gpx+xml")
+public class MultiExceptionGPXMessageBodyWriter implements MessageBodyWriter<MultiException> {
+
+    @Override
+    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
+        return true;
+    }
+
+    @Override
+    public long getSize(MultiException e, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
+        return -1;
+    }
+
+    @Override
+    public void writeTo(MultiException e, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
+        if (e.getErrors().isEmpty())
+            throw new RuntimeException("errorsToXML should not be called with an empty list");
+
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
+
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
+
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
+
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(e.getErrors().iterator().next().getMessage());
+
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
+
+            for (Throwable t : e.getErrors()) {
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                error.setAttribute("details", t.getClass().getName());
+            }
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            transformer.transform(new DOMSource(doc), new StreamResult(entityStream));
+        } catch (ParserConfigurationException | TransformerException e2) {
+            throw new RuntimeException(e2);
+        }
+
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
similarity index 65%
rename from reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java
rename to web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
index a90263c55b..237daee611 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
@@ -16,21 +16,18 @@
  *  limitations under the License.
  */
 
-package com.graphhopper.reader.gtfs;
+package com.graphhopper.http;
 
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.MultiException;
 
-class EverythingButPt implements EdgeFilter {
-
-    PtFlagEncoder encoder;
-
-    EverythingButPt(PtFlagEncoder encoder) {
-        this.encoder = encoder;
-    }
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
 
+@Provider
+public class MultiExceptionMapper implements ExceptionMapper<MultiException> {
     @Override
-    public boolean accept(EdgeIteratorState edgeState) {
-        return encoder.getEdgeType(edgeState.getFlags()) == GtfsStorage.EdgeType.HIGHWAY;
+    public Response toResponse(MultiException exception) {
+        return Response.status(400).entity(exception).build();
     }
 }
diff --git a/web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java b/web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java
new file mode 100644
index 0000000000..7c38043c3d
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import javax.annotation.Priority;
+import javax.ws.rs.Priorities;
+import javax.ws.rs.container.ContainerRequestContext;
+import javax.ws.rs.container.ContainerRequestFilter;
+import javax.ws.rs.container.PreMatching;
+import javax.ws.rs.core.HttpHeaders;
+
+@PreMatching
+@Priority(Priorities.HEADER_DECORATOR)
+public class TypeGPXFilter implements ContainerRequestFilter {
+
+    @Override
+    public void filter(ContainerRequestContext rc) {
+        String maybeType = rc.getUriInfo().getQueryParameters().getFirst("type");
+        if (maybeType != null && maybeType.equals("gpx")) {
+            rc.getHeaders().putSingle(HttpHeaders.ACCEPT, "application/gpx+xml");
+        }
+    }
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java b/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
index b8e3520522..095f0660ff 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -44,11 +44,14 @@ public I18NResource(TranslationMap map) {
     public static class Response {
         public String locale;
         public Map<String, String> en;
-        @JsonProperty("default") public Map<String, String> defaultTr;
+        @JsonProperty("default")
+        public Map<String, String> defaultTr;
     }
 
     @GET
     public Response getFromHeader(@HeaderParam("Accept-Language") String acceptLang) {
+        if (acceptLang == null)
+            return get("");
         return get(acceptLang.split(",")[0]);
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 3314fa81fd..aca3bdbfcb 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -17,33 +17,26 @@
  */
 package com.graphhopper.resources;
 
-import com.fasterxml.jackson.databind.node.ArrayNode;
-import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.MultiException;
 import com.graphhopper.http.WebHelper;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.exceptions.GHException;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
 
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.servlet.http.HttpServletRequest;
 import javax.ws.rs.*;
+import javax.ws.rs.container.ContainerRequestContext;
 import javax.ws.rs.core.*;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
 import java.util.*;
 
 import static com.graphhopper.util.Parameters.Routing.*;
@@ -76,7 +69,8 @@ public RouteResource(GraphHopperAPI graphHopper, EncodingManager encodingManager
     public Response doGet(
             @Context HttpServletRequest httpReq,
             @Context UriInfo uriInfo,
-            @QueryParam(WAY_POINT_MAX_DISTANCE) @DefaultValue("1") double minPathPrecision,
+            @Context ContainerRequestContext rc,
+            @QueryParam(WAY_POINT_MAX_DISTANCE)@DefaultValue("1") double minPathPrecision,
             @QueryParam("point") List<GHPoint> requestPoints,
             @QueryParam("type") @DefaultValue("json") String type,
             @QueryParam(INSTRUCTIONS) @DefaultValue("true") boolean instructions,
@@ -101,20 +95,20 @@ public Response doGet(
         StopWatch sw = new StopWatch().start();
 
         if(requestPoints.isEmpty()) {
-            throw new WebApplicationException(errorResponse(new IllegalArgumentException("You have to pass at least one point"), writeGPX));
+            throw new MultiException(new IllegalArgumentException("You have to pass at least one point"));
         }
 
         if (!encodingManager.supports(vehicleStr)) {
-            throw new WebApplicationException(errorResponse(new IllegalArgumentException("Vehicle not supported: " + vehicleStr), writeGPX));
+            throw new MultiException(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
         } else if (enableElevation && !hasElevation) {
-            throw new WebApplicationException(errorResponse(new IllegalArgumentException("Elevation not supported!"), writeGPX));
+            throw new MultiException(new IllegalArgumentException("Elevation not supported!"));
         } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size()) {
-            throw new WebApplicationException(errorResponse(new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
-                    + "or equal to the number of points (" + requestPoints.size() + ")"), writeGPX));
+            throw new MultiException(new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
+                    + "or equal to the number of points (" + requestPoints.size() + ")"));
         }
 
         if (pointHints.size() > 0 && pointHints.size() != requestPoints.size()) {
-            throw new WebApplicationException(errorResponse(new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored"), writeGPX));
+            throw new MultiException(new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored"));
         }
 
         GHRequest request;
@@ -153,7 +147,7 @@ public Response doGet(
 
         if (ghResponse.hasErrors()) {
             logger.error(logStr + ", errors:" + ghResponse.getErrors());
-            throw new WebApplicationException(errorResponse(ghResponse.getErrors(), writeGPX));
+            throw new MultiException(ghResponse.getErrors());
         } else {
             logger.info(logStr + ", alternatives: " + ghResponse.getAll().size()
                     + ", distance0: " + ghResponse.getBest().getDistance()
@@ -173,7 +167,7 @@ public Response doGet(
 
     private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
         if (ghRsp.getAll().size() > 1) {
-            throw new WebApplicationException("Alternatives are currently not yet supported for GPX");
+            throw new MultiException(new IllegalArgumentException("Alternatives are currently not yet supported for GPX"));
         }
 
         long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
@@ -181,72 +175,7 @@ public Response doGet(
                 header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
     }
 
-    private static Response xmlErrorResponse(Collection<Throwable> list) {
-        if (list.isEmpty())
-            throw new RuntimeException("errorsToXML should not be called with an empty list");
-
-        try {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            DocumentBuilder builder = factory.newDocumentBuilder();
-            Document doc = builder.newDocument();
-            Element gpxElement = doc.createElement("gpx");
-            gpxElement.setAttribute("creator", "GraphHopper");
-            gpxElement.setAttribute("version", "1.1");
-            doc.appendChild(gpxElement);
-
-            Element mdElement = doc.createElement("metadata");
-            gpxElement.appendChild(mdElement);
-
-            Element extensionsElement = doc.createElement("extensions");
-            mdElement.appendChild(extensionsElement);
-
-            Element messageElement = doc.createElement("message");
-            extensionsElement.appendChild(messageElement);
-            messageElement.setTextContent(list.iterator().next().getMessage());
-
-            Element hintsElement = doc.createElement("hints");
-            extensionsElement.appendChild(hintsElement);
-
-            for (Throwable t : list) {
-                Element error = doc.createElement("error");
-                hintsElement.appendChild(error);
-                error.setAttribute("message", t.getMessage());
-                error.setAttribute("details", t.getClass().getName());
-            }
-            return Response.status(400).entity(doc).build();
-        } catch (ParserConfigurationException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static Response errorResponse(List<Throwable> t, boolean writeGPX) {
-        if (writeGPX) {
-            return xmlErrorResponse(t);
-        } else {
-            return jsonErrorResponse(t);
-        }
-    }
-
-    private static Response errorResponse(Throwable t, boolean writeGPX) {
-        return errorResponse(Collections.singletonList(t), writeGPX);
-    }
-
-    private static Response jsonErrorResponse(List<Throwable> errors) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.put("message", getMessage(errors.get(0)));
-        ArrayNode errorHintList = json.putArray("hints");
-        for (Throwable t : errors) {
-            ObjectNode error = errorHintList.addObject();
-            error.put("message", getMessage(t));
-            error.put("details", t.getClass().getName());
-            if (t instanceof GHException) {
-                ((GHException) t).getDetails().forEach(error::putPOJO);
-            }
-        }
-        return Response.status(400).entity(json).build();
-    }
-
-    public static void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
+    static void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
         for (Map.Entry<String, List<String>> e : parameterMap.entrySet()) {
             if (e.getValue().size() == 1) {
                 m.put(e.getKey(), e.getValue().get(0));
@@ -267,11 +196,4 @@ public static void initHints(HintsMap m, MultivaluedMap<String, String> paramete
         }
     }
 
-    private static String getMessage(Throwable t) {
-        if (t.getMessage() == null)
-            return t.getClass().getSimpleName();
-        else
-            return t.getMessage();
-    }
-
 }
diff --git a/web/pom.xml b/web/pom.xml
index e5685e9905..c9e48ef4b7 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -20,6 +20,11 @@
     </properties>
 
     <dependencies>
+        <dependency>
+            <groupId>javax.activation</groupId>
+            <artifactId>activation</artifactId>
+            <version>1.1.1</version>
+        </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-core</artifactId>
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index 7035bb772c..825343644d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -17,19 +17,8 @@
  */
 package com.graphhopper.http;
 
-import com.bedatadriven.jackson.datatype.jts.JtsModule;
-import com.fasterxml.jackson.annotation.JsonInclude;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.databind.BeanDescription;
-import com.fasterxml.jackson.databind.SerializationConfig;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
-import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
-import com.fasterxml.jackson.databind.util.ISO8601DateFormat;
 import com.graphhopper.http.cli.ImportCommand;
 import com.graphhopper.http.resources.RootResource;
-import com.graphhopper.jackson.GraphHopperModule;
 import io.dropwizard.Application;
 import io.dropwizard.bundles.assets.ConfiguredAssetsBundle;
 import io.dropwizard.setup.Bootstrap;
@@ -37,8 +26,6 @@
 
 import javax.servlet.DispatcherType;
 import java.util.EnumSet;
-import java.util.List;
-import java.util.stream.Collectors;
 
 public final class GraphHopperApplication extends Application<GraphHopperServerConfiguration> {
 
@@ -55,7 +42,6 @@ public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
 
     @Override
     public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
-
         environment.jersey().register(new RootResource());
         environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
         environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
diff --git a/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
new file mode 100644
index 0000000000..c1182e26bb
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
@@ -0,0 +1,52 @@
+package com.graphhopper.http.resources;
+
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class I18nResourceIT {
+    private static final String DIR = "./target/andorra-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    static {
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("prepare.ch.weightings", "no").
+                put("graph.flag_encoders", "car").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
+            GraphHopperApplication.class, config);
+
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void requestI18n() {
+        Response response = app.client().target("http://localhost:8080/i18n").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        String str = response.readEntity(String.class);
+        assertTrue(str, str.contains("\"en\":") && str.contains("\"locale\":\"\""));
+
+        response = app.client().target("http://localhost:8080/i18n/de").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        str = response.readEntity(String.class);
+        assertTrue(str, str.contains("\"default\":") && str.contains("\"locale\":\"de\""));
+    }
+}
