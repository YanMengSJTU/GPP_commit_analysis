diff --git a/.codeclimate.yml b/.codeclimate.yml
index d9d364d924..63f072aaeb 100644
--- a/.codeclimate.yml
+++ b/.codeclimate.yml
@@ -16,6 +16,10 @@ engines:
         enabled: false
       com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck:
         enabled: false
+      com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.naming.LocalVariableNameCheck:
+        enabled: false
   duplication:
     enabled: true
     config:
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 62f766591c..9dcf0d482a 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -1,4 +1,4 @@
-Submit a new issue only if you are sure it is a missing feature or a bug. Otherwise, [discuss the topic](http://graphhopper.com/#developers) first. 
+Submit a new issue only if you are sure it is a missing feature or a bug. Otherwise, [discuss the topic](https://discuss.graphhopper.com/c/graphhopper) first. 
 For new translations or fixes to existing translations,
 please refer to [this documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/core/translations.md).
 
diff --git a/.travis.yml b/.travis.yml
index 790cc30845..359bf681a8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -46,7 +46,7 @@ before_install:
 install: true
 
 script:
-  - mvn clean test verify checkstyle:check findbugs:check -B
+  - mvn clean test verify checkstyle:check findbugs:check forbiddenapis:check -B
 
 after_success:
   # deploy snapshot artifacts to maven central
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index aa23cb20cb..3f26531b71 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -38,6 +38,7 @@ Here is an overview:
  * JohannesPelzer, improved GPX information and various other things
  * karussell, one of the core developers
  * khuebner, initial turn costs support
+ * legraina, improved docker for dockerhub
  * lmar, improved instructions
  * michaz, one of the core developers
  * mprins, improvements for travis CI and regarding JDK9 #806
diff --git a/Dockerfile b/Dockerfile
index 07d264dfd3..19d70fc819 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,10 +1,21 @@
 FROM openjdk:8-jdk
 
-RUN mkdir -p /data
-RUN mkdir -p /graphhopper
+ENV JETTY_PORT 11111
+ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+
+RUN mkdir -p /data && \
+    mkdir -p /graphhopper
 
 COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
 RUN ./graphhopper.sh buildweb
+
+VOLUME [ "/data" ]
+
+EXPOSE 11111
+
+ENTRYPOINT [ "./graphhopper.sh", "web" ]
+
+CMD [ "/data/europe_germany_berlin.pbf" ]
diff --git a/NOTICE.md b/NOTICE.md
index b290fbeffe..aa7adc7dcd 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -1,3 +1,5 @@
+## Licenses
+
 GraphHopper licensed under the Apache license, Version 2.0
 
 Copyright 2012 - 2017 GraphHopper GmbH
@@ -51,3 +53,14 @@ android:
  * android (Apache license)
  * org.mapsforge, LGPL
  * VTM, LGPL
+
+## Data
+
+|source | license | used as default | included in repo |
+|---------|-----------|---------|------|
+|OpenStreetMap data for the road network | [ODBL](https://www.openstreetmap.org/copyright) | yes | yes
+| SRTM elevation | [public domain](https://www2.jpl.nasa.gov/srtm/), [acknowledgement](https://lpdaac.usgs.gov/citing_our_data) | no | yes
+| CGIAR elevation | [allowed usage for GraphHopper](https://graphhopper.com/public/license/CGIAR.txt) | no | no
+| SRTMGL1 elevation | [acknowledgement](https://lpdaac.usgs.gov/citing_our_data) | no | no
+|OpenTopography mirror for SRTMGL1 | [acknowledgement OpenTopoGraphy](http://www.opentopography.org/citations) and [data source](http://opentopo.sdsc.edu/datasetMetadata?otCollectionID=OT.042013.4326.1) + SRTMGL1 | no | no
+| GMTED | [public domain, acknowledgment](https://lta.cr.usgs.gov/citation) | no | no
diff --git a/README.md b/README.md
index 7b6716f47b..ea7a6ac63c 100644
--- a/README.md
+++ b/README.md
@@ -158,6 +158,7 @@ Here is a list of the more detailed features including a link to the documentati
  * Memory efficient data structures, algorithms and [the low and high level API](./docs/core/low-level-api.md) is tuned towards ease of use and efficiency
  * Provides a simple [web API](./docs/web/api-doc.md) including JavaScript and Java clients
  * Multiple weightings (fastest/shortest/...) and pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
+ * Support for public transit routing and [GTFS support](./reader-gtfs/README.md).
  * Offers turn instructions in more than 35 languages, contribute or improve [here](./docs/core/translations.md)
  * Displays and takes into account [elevation data](./docs/core/elevation.md) (per default disabled)
  * Can apply [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexible and hybrid mode only)
diff --git a/android/app/build.gradle b/android/app/build.gradle
index ba2fb0c0d6..9fa9d7ced6 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion 27
-    buildToolsVersion "27.0.0"
+    buildToolsVersion "27.0.3"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
@@ -11,9 +11,10 @@ android {
     }
 
     buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        all {
+            minifyEnabled true
+            useProguard false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 
@@ -41,15 +42,15 @@ dependencies {
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.8.0'
-    implementation 'org.mapsforge:vtm-android:0.8.0'
-    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi'
-    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.8.0:natives-x86'
-    implementation('org.mapsforge:vtm-jts:0.8.0') {
-        exclude group: 'com.vividsolutions', module: 'jts-core'
-    }
-    implementation 'org.mapsforge:vtm-themes:0.8.0'
+    implementation 'org.mapsforge:vtm:0.9.2'
+    implementation 'org.mapsforge:vtm-android:0.9.2'
+    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi'
+    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.9.2:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.9.2'
+    implementation 'org.mapsforge:vtm-themes:0.9.2'
     implementation 'com.caverock:androidsvg:1.2.2-beta-1'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 1ca4a99567..bc1c1679b3 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -19,7 +19,7 @@
         <version>0.10-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.8.0</vtm.version>
+        <vtm.version>0.9.2</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -67,23 +67,29 @@
             <version>${vtm.version}</version>
             <classifier>natives-armeabi-v7a</classifier>
         </dependency>  
+         <dependency>
+            <groupId>org.mapsforge</groupId>
+            <artifactId>vtm-android</artifactId>
+            <version>${vtm.version}</version>
+            <classifier>natives-arm64-v8a</classifier>
+        </dependency>
          <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-android</artifactId>
             <version>${vtm.version}</version>
             <classifier>natives-x86</classifier>
         </dependency>        
-        
+         <dependency>
+            <groupId>org.mapsforge</groupId>
+            <artifactId>vtm-android</artifactId>
+            <version>${vtm.version}</version>
+            <classifier>natives-x86_64</classifier>
+        </dependency>
+
         <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-jts</artifactId>
             <version>${vtm.version}</version>
-            <exclusions>
-            	<exclusion>
-            	  <groupId>com.vividsolutions</groupId>            
-  		  <artifactId>jts-core</artifactId>
-            	</exclusion>
-            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.mapsforge</groupId>            
diff --git a/android/app/proguard-rules.pro b/android/app/proguard-rules.pro
new file mode 100644
index 0000000000..63b4a48a1c
--- /dev/null
+++ b/android/app/proguard-rules.pro
@@ -0,0 +1,8 @@
+-keep class com.** { *; }
+-dontwarn com.**
+-keep class okhttp3.** { *; }
+-dontwarn okhttp3.**
+-keep class okio.** { *; }
+-dontwarn okio.**
+-keep class org.** { *; }
+-dontwarn org.**
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 5434d6fb9f..8dc3e82782 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -39,7 +39,6 @@
 import org.oscim.android.canvas.AndroidGraphics;
 import org.oscim.backend.canvas.Bitmap;
 import org.oscim.core.GeoPoint;
-import org.oscim.core.Tile;
 import org.oscim.event.Gesture;
 import org.oscim.event.GestureListener;
 import org.oscim.event.MotionEvent;
@@ -119,7 +118,6 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
 
-        Tile.SIZE = Tile.calculateTileSize(getResources().getDisplayMetrics().scaledDensity);
         mapView = new MapView(this);
 
         final EditText input = new EditText(this);
diff --git a/android/build.gradle b/android/build.gradle
index 42a1c7f0e4..7105f5a2dd 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0'
+        classpath 'com.android.tools.build:gradle:3.0.1'
     }
 }
 
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index 4335aa22d6..d15882dc6d 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -25,7 +25,7 @@
     <artifactId>directions-api-client-hc</artifactId>
     <version>0.10-SNAPSHOT</version>
     <packaging>jar</packaging>
-    <name>GraphHopper Directions API hand-crafted Java Client. For the Matrix and Routing API only</name>
+    <name>GraphHopper Directions API hand-crafted Java Client.</name>
      
     <parent>
         <groupId>com.graphhopper</groupId>
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index a8f1e524e3..9a39b7cc31 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -75,14 +75,13 @@ public MatrixResponse route(GHMRequest ghRequest) {
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
 
-        ObjectNode hintsObject = requestJson.putObject("hints");
         Map<String, String> hintsMap = ghRequest.getHints().toMap();
         for (String hintKey : hintsMap.keySet()) {
             if (ignoreSet.contains(hintKey))
                 continue;
 
             String hint = hintsMap.get(hintKey);
-            hintsObject.put(hintKey, hint);
+            requestJson.put(hintKey, hint);
         }
 
         boolean withTimes = outArraysList.contains("times");
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
new file mode 100644
index 0000000000..c351156485
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
@@ -0,0 +1,138 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.api.model.GHGeocodingRequest;
+import com.graphhopper.api.model.GHGeocodingResponse;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Client implementation for the GraphHopper Directions API Geocoding. For details on how to use it, please consult
+ * the documentation at: https://graphhopper.com/api/1/docs/geocoding/.
+ * <p>
+ * Signup for a free API key at: https://graphhopper.com
+ *
+ * @author Robin Boldt
+ */
+public class GraphHopperGeocoding {
+
+    private final ObjectMapper objectMapper;
+    private OkHttpClient downloader;
+    private String routeServiceUrl;
+    private String key = "";
+
+    private final long DEFAULT_TIMEOUT = 5000;
+
+    public GraphHopperGeocoding() {
+        this("https://graphhopper.com/api/1/geocode");
+    }
+
+    /**
+     * This method allows you to point the client to a different URL than the default one.
+     *
+     * @param serviceUrl Geocoding endpoint that is compatible with the GraphHopper geocoding API
+     */
+    public GraphHopperGeocoding(String serviceUrl) {
+        this.routeServiceUrl = serviceUrl;
+        downloader = new OkHttpClient.Builder().
+                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                build();
+
+        objectMapper = new ObjectMapper();
+    }
+
+    /**
+     * Perform a geocoding request. Both forward and revers are possible, just configure the <code>request</code>
+     * accordingly.
+     *
+     * @param request the request to send to the API
+     * @return found results for your request
+     */
+    public GHGeocodingResponse geocode(GHGeocodingRequest request) {
+        String url = buildUrl(request);
+
+        try {
+            Request okRequest = new Request.Builder().url(url).build();
+            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            return objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem performing geocoding for " + url + ": " + ex.getMessage(), ex);
+        }
+    }
+
+    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {
+        this.downloader = downloader;
+        return this;
+    }
+
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    public OkHttpClient getDownloader() {
+        return downloader;
+    }
+
+    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {
+        OkHttpClient client = this.downloader;
+        if (request.hasTimeout()) {
+            long timeout = request.getTimeout();
+            client = client.newBuilder()
+                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .readTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .build();
+        }
+
+        return client;
+    }
+
+    private String buildUrl(GHGeocodingRequest request) {
+        String url = routeServiceUrl + "?";
+
+        if (request.isReverse()) {
+            if (!request.getPoint().isValid())
+                throw new IllegalArgumentException("For reverse geocoding you have to pass valid lat and long values");
+            url += "reverse=true";
+        } else {
+            if (request.getQuery() == null)
+                throw new IllegalArgumentException("For forward geocoding you have to a string for the query");
+            url += "reverse=false";
+            url += "&q=" + request.getQuery();
+        }
+
+        if (request.getPoint().isValid())
+            url += "&point=" + request.getPoint().getLat() + "," + request.getPoint().getLon();
+
+        url += "&limit=" + request.getLimit();
+        url += "&locale=" + request.getLocale();
+        url += "&provider=" + request.getProvider();
+
+        if (!key.isEmpty()) {
+            url += "&key=" + WebHelper.encodeURL(key);
+        }
+
+        return url;
+    }
+
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 48daf5a87d..b8ca744ade 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -37,6 +37,8 @@
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient
  * usage.
@@ -174,6 +176,11 @@ PathWrapper createPathWrapper(JsonNode path,
                         instr = new FinishInstruction(text, instPL, 0);
                     } else {
                         instr = new Instruction(sign, text, ia, instPL);
+                        if(sign == Instruction.CONTINUE_ON_STREET){
+                            if(jsonObj.has("heading")){
+                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
+                            }
+                        }
                     }
 
                     // Usually, the translation is done from the routing service so just use the provided string
@@ -407,7 +414,7 @@ private Request createRequest(GHRequest request) {
 
         String places = "";
         for (GHPoint p : request.getPoints()) {
-            places += "point=" + Helper.round6(p.lat) + "," + Helper.round6(p.lon) + "&";
+            places += "point=" + round6(p.lat) + "," + round6(p.lon) + "&";
         }
 
         String type = request.getHints().get("type", "json");
@@ -441,7 +448,7 @@ private Request createRequest(GHRequest request) {
             String urlValue = entry.getValue();
 
             // use lower case conversion for check only!
-            if (ignoreSet.contains(urlKey.toLowerCase())) {
+            if (ignoreSet.contains(toLowerCase(urlKey))) {
                 continue;
             }
 
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java
new file mode 100644
index 0000000000..c4242cfdef
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingEntry.java
@@ -0,0 +1,210 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * Contains the results of a geocoding request.
+ * This is a copy of: https://github.com/graphhopper/geocoder-converter/blob/master/src/main/java/com/graphhopper/converter/api/GHResponse.java
+ *
+ * @author Robin Boldt
+ * @author Peter Karich
+ */
+@JsonInclude(JsonInclude.Include.NON_NULL)
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class GHGeocodingEntry {
+
+    private Long osmId;
+    private String osmType;
+
+    private Point point;
+
+    private String name;
+    private String country;
+    private String city;
+    private String state;
+    private String street;
+    private String houseNumber;
+    private String postcode;
+    private String osmValue;
+
+    public GHGeocodingEntry(Long osmId, String type, double lat, double lng, String name, String osmValue, String country, String city, String state, String street, String houseNumber, String postcode) {
+        this.osmId = osmId;
+        this.osmType = type;
+        this.point = new Point(lat, lng);
+        this.name = name;
+        this.country = country;
+        this.city = city;
+        this.state = state;
+        this.street = street;
+        this.houseNumber = houseNumber;
+        this.postcode = postcode;
+        this.osmValue = osmValue;
+    }
+
+    public GHGeocodingEntry() {
+    }
+
+    @JsonProperty
+    public String getName() {
+        return name;
+    }
+
+    @JsonProperty
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @JsonProperty
+    public String getCountry() {
+        return country;
+    }
+
+    @JsonProperty
+    public void setCountry(String country) {
+        this.country = country;
+    }
+
+    @JsonProperty
+    public void setState(String state) {
+        this.state = state;
+    }
+
+    @JsonProperty
+    public String getState() {
+        return state;
+    }
+
+    @JsonProperty
+    public String getCity() {
+        return city;
+    }
+
+    @JsonProperty
+    public void setCity(String city) {
+        this.city = city;
+    }
+
+    @JsonProperty
+    public Point getPoint() {
+        return point;
+    }
+
+    @JsonProperty
+    public void setPoint(Point point) {
+        this.point = point;
+    }
+
+    @JsonProperty("osm_id")
+    public Long getOsmId() {
+        return osmId;
+    }
+
+    @JsonProperty("osm_id")
+    public void setOsmId(Long osmId) {
+        this.osmId = osmId;
+    }
+
+    @JsonProperty("osm_type")
+    public String getOsmType() {
+        return osmType;
+    }
+
+    @JsonProperty("osm_type")
+    public void setOsmType(String type) {
+        this.osmType = type;
+    }
+
+    @JsonProperty
+    public String getStreet() {
+        return street;
+    }
+
+    @JsonProperty
+    public void setStreet(String street) {
+        this.street = street;
+    }
+
+    @JsonProperty("house_number")
+    public String getHouseNumber() {
+        return houseNumber;
+    }
+
+    @JsonProperty("house_number")
+    public void setHouseNumber(String houseNumber) {
+        this.houseNumber = houseNumber;
+    }
+
+    @JsonProperty
+    public String getPostcode() {
+        return postcode;
+    }
+
+    @JsonProperty
+    public void setPostcode(String postcode) {
+        this.postcode = postcode;
+    }
+
+    @JsonProperty("osm_value")
+    public String getOsmValue() {
+        return osmValue;
+    }
+
+    @JsonProperty("osm_value")
+    public void setOsmValue(String osmValue) {
+        this.osmValue = osmValue;
+    }
+
+    public class Point {
+
+        private double lat;
+        private double lng;
+
+        public Point(double lat, double lng) {
+            this.lat = lat;
+            this.lng = lng;
+        }
+
+        public Point() {
+        }
+
+        @JsonProperty
+        public double getLat() {
+            return lat;
+        }
+
+        @JsonProperty
+        public void setLat(double lat) {
+            this.lat = lat;
+        }
+
+        @JsonProperty
+        public double getLng() {
+            return lng;
+        }
+
+        @JsonProperty
+        public void setLng(double lng) {
+            this.lng = lng;
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java
new file mode 100644
index 0000000000..f966f15bf7
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingRequest.java
@@ -0,0 +1,106 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+/**
+ * A geocoding request following https://graphhopper.com/api/1/docs/geocoding/
+ *
+ * @author Robin Boldt
+ */
+public class GHGeocodingRequest {
+
+    private final boolean reverse;
+
+    private final GHPoint point;
+
+    private final String query;
+
+    private final String locale;
+    private final int limit;
+    private final String provider;
+    private final long timeout;
+
+    /**
+     * This is a wrapper to build a reverse geocoding request
+     */
+    public GHGeocodingRequest(double lat, double lon, String locale, int limit) {
+        this(true, new GHPoint(lat, lon), null, locale, limit, "default", -1);
+    }
+
+    /**
+     * This is a wrapper to build a reverse geocoding request
+     */
+    public GHGeocodingRequest(GHPoint point, String locale, int limit) {
+        this(true, point, null, locale, limit, "default", -1);
+    }
+
+    /**
+     * This is a wrapper to build a forward geocoding request
+     */
+    public GHGeocodingRequest(String query, String locale, int limit) {
+        this(false, null, query, locale, limit, "default", -1);
+    }
+
+    public GHGeocodingRequest(boolean reverse, GHPoint point, String query, String locale, int limit, String provider, long timeout) {
+        this.reverse = reverse;
+        if (point == null) {
+            this.point = new GHPoint();
+        } else {
+            this.point = point;
+        }
+        this.query = query;
+        this.locale = locale;
+        this.limit = limit;
+        this.provider = provider;
+        this.timeout = timeout;
+    }
+
+    public boolean isReverse() {
+        return reverse;
+    }
+
+    public GHPoint getPoint() {
+        return point;
+    }
+
+    public String getQuery() {
+        return query;
+    }
+
+    public String getLocale() {
+        return locale;
+    }
+
+    public int getLimit() {
+        return limit;
+    }
+
+    public String getProvider() {
+        return provider;
+    }
+
+    public boolean hasTimeout() {
+        return this.timeout > 0;
+    }
+
+    public long getTimeout() {
+        return timeout;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java
new file mode 100644
index 0000000000..c69f04b82e
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/model/GHGeocodingResponse.java
@@ -0,0 +1,80 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api.model;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains the results of a geocoding request.
+ * This is a copy of: https://github.com/graphhopper/geocoder-converter/blob/master/src/main/java/com/graphhopper/converter/api/GHResponse.java
+ *
+ * @author Robin Boldt
+ * @author Peter Karich
+ */
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class GHGeocodingResponse {
+
+    private List<String> copyrights = new ArrayList<String>(5);
+    private List<GHGeocodingEntry> hits;
+    private String locale = "en";
+
+    public GHGeocodingResponse() {
+        this(5);
+    }
+
+    public GHGeocodingResponse(int no) {
+        hits = new ArrayList<>(no);
+    }
+
+    public void setCopyrights(List<String> copyrights) {
+        this.copyrights = copyrights;
+    }
+
+    public List<String> getCopyrights() {
+        return copyrights;
+    }
+
+    public GHGeocodingResponse addCopyright(String cr) {
+        copyrights.add(cr);
+        return this;
+    }
+
+    public void setHits(List<GHGeocodingEntry> hits) {
+        this.hits = hits;
+    }
+
+    public void add(GHGeocodingEntry entry) {
+        hits.add(entry);
+    }
+
+    public List<GHGeocodingEntry> getHits() {
+        return hits;
+    }
+
+    public String getLocale() {
+        return locale;
+    }
+
+    public void setLocale(String locale) {
+        this.locale = locale;
+    }
+
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index c92f3980cb..de7e2cc629 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -56,7 +56,7 @@ public void testBikeMatrix() {
         req.addOutArray("times");
 
         MatrixResponse res = ghMatrix.route(req);
-        assertEquals(2350, res.getTime(1, 2) / 1000, 50);
+        assertEquals(2450, res.getTime(1, 2) / 1000, 110);
     }
 
     @Test
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
new file mode 100644
index 0000000000..828f7d54c1
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
@@ -0,0 +1,71 @@
+package com.graphhopper.api;
+
+import com.graphhopper.api.model.GHGeocodingRequest;
+import com.graphhopper.api.model.GHGeocodingResponse;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.net.SocketTimeoutException;
+
+import static com.graphhopper.api.GraphHopperWebIT.KEY;
+import static org.junit.Assert.*;
+
+/**
+ * @author Robin Boldt
+ */
+public class GraphHopperGeocodingIT {
+
+    GraphHopperGeocoding geocoding = new GraphHopperGeocoding();
+
+    @Before
+    public void setUp() {
+        String key = System.getProperty("graphhopper.key", KEY);
+        geocoding.setKey(key);
+    }
+
+    @Test
+    public void testForwardGeocoding() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("Berlin", "en", 7));
+        assertEquals(7, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testForwardGeocodingNominatim() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "nominatim", 5000));
+        assertEquals(5, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testReverseGeocoding() {
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(52.5170365, 13.3888599, "en", 5));
+        assertEquals(5, response.getHits().size());
+        assertTrue(response.getHits().get(0).getName().contains("Berlin"));
+    }
+
+    @Test
+    public void testTimeout() {
+        try {
+            // We set the timeout to 1ms, it shouldn't be possible for the API to answer that quickly => we will receive a SocketTimeout
+            geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "default", 1));
+        } catch (RuntimeException e) {
+            if (e.getCause() instanceof SocketTimeoutException) {
+                return;
+            }
+        }
+        fail();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testForwardException() {
+        geocoding.geocode(new GHGeocodingRequest(false, new GHPoint(1, 1), null, "en", 5, "default", 1));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testBackwadException() {
+        geocoding.geocode(new GHGeocodingRequest(true, null, "Berlin", "en", 5, "default", 1));
+    }
+
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 0b2814cd5b..dc3eef9fba 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -120,11 +120,11 @@ public void testRetrieveOnlyStreetname() {
                 addPoint(new GHPoint(52.399067, 13.469238));
 
         GHResponse res = gh.route(req);
-        assertEquals("Turn right onto B 246", res.getBest().getInstructions().get(4).getName());
+        assertEquals("Continue onto B 96", res.getBest().getInstructions().get(4).getName());
 
         req.getHints().put("turn_description", false);
         res = gh.route(req);
-        assertEquals("B 246", res.getBest().getInstructions().get(4).getName());
+        assertEquals("B 96", res.getBest().getInstructions().get(4).getName());
     }
 
     @Test
@@ -252,6 +252,29 @@ public void testMatrix() {
         assertEquals(1695, res.getWeight(1, 2), 10);
     }
 
+    @Test
+    public void testMatrix_DoNotWrapHints() {
+        final GraphHopperMatrixWeb ghMatrix = new GraphHopperMatrixWeb(new GHMatrixBatchRequester() {
+            @Override
+            protected String postJson(String url, JsonNode data) throws IOException {
+                assertFalse(data.has("hints"));
+                assertTrue(data.has("something"));
+                return super.postJson(url, data);
+            }
+        });
+        ghMatrix.setKey(System.getProperty("graphhopper.key", KEY));
+
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(49.6724, 11.3494));
+        req.addPoint(new GHPoint(49.6550, 11.4180));
+        req.getHints().put("something", "xy");
+        ghMatrix.route(req);
+
+        // clashing parameter will overwrite!
+        req.getHints().put("vehicle", "xy");
+        assertEquals("xy", req.getVehicle());
+    }
+
     @Test
     public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
diff --git a/config-example.properties b/config-example.properties
index f0aa981bef..bf3f7d9cec 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -14,7 +14,8 @@ graph.flag_encoders=car
 ##### Elevation #####
 
 
-# To populate your graph with elevation data use SRTM, default is noop (no elevation)
+# Per default GraphHopper doesn't use elevation data, you can enable elevation by setting graph.elevation.provider
+# to srtm, cgiar, gmted, srtmgl1, or multi. See the corresponding classes at com.graphhopper.reader.dem for more information.
 # graph.elevation.provider=srtm
 
 
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
index 55c7c34c5b..ff9d1f7c7c 100644
--- a/core/files/docker-compose.yml
+++ b/core/files/docker-compose.yml
@@ -10,7 +10,4 @@ services:
             JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
         ports:
             - "11111:11111"
-        entrypoint:
-            - ./graphhopper.sh
-            - web
-            - ../data/europe_germany_berlin.pbf
+        command: /data/europe_germany_berlin.pbf
diff --git a/core/files/krautsand.osm.gz b/core/files/krautsand.osm.gz
new file mode 100644
index 0000000000..d8e1578532
Binary files /dev/null and b/core/files/krautsand.osm.gz differ
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 2b74df151d..4141dfeaa1 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -57,6 +57,7 @@
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
+import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.*;
 
 /**
@@ -85,6 +86,7 @@
     private boolean allowWrites = true;
     private String preferredLanguage = "";
     private boolean fullyLoaded = false;
+    private boolean smoothElevation = false;
     // for routing
     private int maxRoundTripRetries = 3;
     private boolean simplifyResponse = true;
@@ -436,7 +438,7 @@ public String getDataReaderFile() {
      */
     public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
-        if (Helper.isEmpty(dataReaderFileStr))
+        if (isEmpty(dataReaderFileStr))
             throw new IllegalArgumentException("Data reader file cannot be empty.");
 
         dataReaderFile = dataReaderFileStr;
@@ -522,15 +524,15 @@ public GraphHopper init(CmdArgs args) {
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
 
         String tmpOsmFile = args.get("datareader.file", "");
-        if (!Helper.isEmpty(tmpOsmFile))
+        if (!isEmpty(tmpOsmFile))
             dataReaderFile = tmpOsmFile;
 
         String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
-            if (Helper.isEmpty(dataReaderFile))
-                throw new IllegalArgumentException("You need to specify an OSM file.");
+        if (isEmpty(graphHopperFolder) && isEmpty(ghLocation)) {
+            if (isEmpty(dataReaderFile))
+                throw new IllegalArgumentException("If no graph.location is provided you need to specify an OSM file.");
 
-            graphHopperFolder = Helper.pruneFileEnd(dataReaderFile) + "-gh";
+            graphHopperFolder = pruneFileEnd(dataReaderFile) + "-gh";
         }
 
         // graph
@@ -553,7 +555,8 @@ public GraphHopper init(CmdArgs args) {
             lockFactory = new NativeFSLockFactory();
 
         // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+        String eleProviderStr = toLowerCase(args.get("graph.elevation.provider", "noop"));
+        this.smoothElevation = args.getBool("graph.elevation.smoothing", false);
 
         // keep fallback until 0.8
         boolean eleCalcMean = args.has("graph.elevation.calcmean")
@@ -568,18 +571,25 @@ public GraphHopper init(CmdArgs args) {
         if (baseURL.isEmpty())
             args.get("graph.elevation.baseurl", "");
 
+        boolean removeTempElevationFiles = args.getBool("graph.elevation.cgiar.clear", true);
+        removeTempElevationFiles = args.getBool("graph.elevation.clear", removeTempElevationFiles);
+
         DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
         if (eleProviderStr.equalsIgnoreCase("srtm")) {
-            tmpProvider = new SRTMProvider();
+            tmpProvider = new SRTMProvider(cacheDirStr);
         } else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
-            CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
-            tmpProvider = cgiarProvider;
+            tmpProvider = new CGIARProvider(cacheDirStr);
+        } else if (eleProviderStr.equalsIgnoreCase("gmted")) {
+            tmpProvider = new GMTEDProvider(cacheDirStr);
+        } else if (eleProviderStr.equalsIgnoreCase("srtmgl1")) {
+            tmpProvider = new SRTMGL1Provider(cacheDirStr);
+        } else if (eleProviderStr.equalsIgnoreCase("multi")) {
+            tmpProvider = new MultiSourceElevationProvider(cacheDirStr);
         }
 
+        tmpProvider.setAutoRemoveTemporaryFiles(removeTempElevationFiles);
         tmpProvider.setCalcMean(eleCalcMean);
-        tmpProvider.setCacheDir(new File(cacheDirStr));
         if (!baseURL.isEmpty())
             tmpProvider.setBaseURL(baseURL);
         tmpProvider.setDAType(elevationDAType);
@@ -650,7 +660,7 @@ private GraphHopper process(String graphHopperLocation) {
 
             try {
                 DataReader reader = importData();
-                DateFormat f = Helper.createFormatter();
+                DateFormat f = createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
                 if (reader.getDataDate() != null)
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
@@ -679,7 +689,7 @@ protected DataReader importData() throws IOException {
         encodingManager.setEnableInstructions(enableInstructions);
         encodingManager.setPreferredLanguage(preferredLanguage);
         DataReader reader = createReader(ghStorage);
-        logger.info("using " + ghStorage.toString() + ", memory:" + Helper.getMemInfo());
+        logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
         reader.readGraph();
         return reader;
     }
@@ -697,7 +707,8 @@ protected DataReader initDataReader(DataReader reader) {
         return reader.setFile(new File(dataReaderFile)).
                 setElevationProvider(eleProvider).
                 setWorkerThreads(dataReaderWorkerThreads).
-                setWayPointMaxDistance(dataReaderWayPointMaxDistance);
+                setWayPointMaxDistance(dataReaderWayPointMaxDistance).
+                setSmoothElevation(this.smoothElevation);
     }
 
     /**
@@ -708,7 +719,7 @@ protected DataReader initDataReader(DataReader reader) {
      */
     @Override
     public boolean load(String graphHopperFolder) {
-        if (Helper.isEmpty(graphHopperFolder))
+        if (isEmpty(graphHopperFolder))
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
 
         if (fullyLoaded)
@@ -842,7 +853,7 @@ public void postProcessing() {
 
             GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
             GHUtility.sortDFS(ghStorage, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+            logger.info("graph sorted (" + getMemInfo() + ")");
             ghStorage = newGraph;
         }
 
@@ -895,7 +906,7 @@ private void interpolateBridgesAndOrTunnels() {
      * @see HintsMap
      */
     public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
-        String weightingStr = hintsMap.getWeighting().toLowerCase();
+        String weightingStr = toLowerCase(hintsMap.getWeighting());
         Weighting weighting = null;
 
         if (encoder.supports(GenericWeighting.class)) {
@@ -916,7 +927,7 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         }
 
         if (weighting == null)
-            throw new IllegalArgumentException("weighting " + weighting + " not supported");
+            throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
 
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
@@ -1069,6 +1080,9 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                         setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
                         setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
 
+                if (request.hasFavoredHeading(0))
+                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
+
                 if (routingTemplate.isReady(pathMerger, tr))
                     break;
             }
@@ -1125,7 +1139,7 @@ private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
         GHPoint lastPoint = points.get(0);
         GHPoint point;
         double dist;
-        DistanceCalc calc = Helper.DIST_3D;
+        DistanceCalc calc = DIST_3D;
         for (int i = 1; i < points.size(); i++) {
             point = points.get(i);
             dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
@@ -1213,9 +1227,9 @@ protected void cleanUp() {
 
     protected void flush() {
         logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
-                + Helper.getMemInfo() + ")");
+                + getMemInfo() + ")");
         ghStorage.flush();
-        logger.info("flushed graph " + Helper.getMemInfo() + ")");
+        logger.info("flushed graph " + getMemInfo() + ")");
         fullyLoaded = true;
     }
 
@@ -1246,7 +1260,7 @@ public void clean() {
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
         File folder = new File(getGraphHopperLocation());
-        Helper.removeDir(folder);
+        removeDir(folder);
     }
 
     protected void ensureNotLoaded() {
@@ -1262,4 +1276,5 @@ protected void ensureWriteAccess() {
     public void setNonChMaxWaypointDistance(int nonChMaxWaypointDistance) {
         this.nonChMaxWaypointDistance = nonChMaxWaypointDistance;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 1664eef86a..2b82d6cd7c 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -254,9 +254,6 @@ public void addPathDetails(Map<String, List<PathDetail>> details) {
             throw new IllegalStateException("Details have to be the same size");
         }
         for (Map.Entry<String, List<PathDetail>> detailEntry : details.entrySet()) {
-            if (detailEntry.getValue().isEmpty())
-                throw new IllegalStateException("PathDetails " + detailEntry.getKey() + " must not be empty");
-
             if (this.pathDetails.containsKey(detailEntry.getKey())) {
                 List<PathDetail> pd = this.pathDetails.get(detailEntry.getKey());
                 PathMerger.merge(pd, detailEntry.getValue());
diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index 4ed6b675e7..25611620ac 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -12,25 +12,24 @@
     public static abstract class Leg {
         public final String type;
         public final String departureLocation;
-        public final Date departureTime;
         public final List<EdgeIteratorState> edges;
         public final Geometry geometry;
         public final double distance;
-        public final Date arrivalTime;
 
-        public Leg(String type, String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, Date arrivalTime) {
+        public Leg(String type, String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance) {
             this.type = type;
             this.departureLocation = departureLocation;
             this.edges = edges;
             this.geometry = geometry;
             this.distance = distance;
-            this.departureTime = departureTime;
-            this.arrivalTime = arrivalTime;
         }
 
         public double getDistance() {
             return distance;
         }
+
+        public abstract Date getDepartureTime();
+        public abstract Date getArrivalTime();
     }
 
     public static class Stop {
@@ -39,23 +38,56 @@ public double getDistance() {
         public final Point geometry;
 
         public final Date arrivalTime;
+        public final Date plannedArrivalTime;
+        public final Date predictedArrivalTime;
+
         public final Date departureTime;
+        public final Date plannedDepartureTime;
+        public final Date predictedDepartureTime;
 
-        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date departureTime) {
+        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date plannedArrivalTime, Date predictedArrivalTime, Date departureTime, Date plannedDepartureTime, Date predictedDepartureTime) {
             this.stop_id = stop_id;
             this.stop_name = name;
             this.geometry = geometry;
             this.arrivalTime = arrivalTime;
+            this.plannedArrivalTime = plannedArrivalTime;
+            this.predictedArrivalTime = predictedArrivalTime;
             this.departureTime = departureTime;
+            this.plannedDepartureTime = plannedDepartureTime;
+            this.predictedDepartureTime = predictedDepartureTime;
+        }
+
+        @Override
+        public String toString() {
+            return "Stop{" +
+                    "stop_id='" + stop_id + '\'' +
+                    ", arrivalTime=" + arrivalTime +
+                    ", departureTime=" + departureTime +
+                    '}';
         }
     }
     public static class WalkLeg extends Leg {
         public final InstructionList instructions;
+        private final Date departureTime;
+        private final Date arrivalTime;
 
         public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
-            super("walk", departureLocation, departureTime, edges, geometry, distance, arrivalTime);
+            super("walk", departureLocation, edges, geometry, distance);
             this.instructions = instructions;
+            this.departureTime = departureTime;
+            this.arrivalTime = arrivalTime;
+        }
+
+        @Override
+        public Date getDepartureTime() {
+            return departureTime;
+        }
+
+        @Override
+        public Date getArrivalTime() {
+            return arrivalTime;
         }
+
     }
     public static class PtLeg extends Leg {
         public final String feed_id;
@@ -66,8 +98,8 @@ public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorSt
         public final String trip_id;
         public final String route_id;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
-            super("pt", stops.get(0).stop_name, departureTime, edges, geometry, distance, arrivalTime);
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
+            super("pt", stops.get(0).stop_name, edges, geometry, distance);
             this.feed_id = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
             this.trip_id = tripId;
@@ -77,6 +109,15 @@ public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, St
             this.stops = stops;
         }
 
+        @Override
+        public Date getDepartureTime() {
+            return stops.get(0).departureTime;
+        }
+
+        @Override
+        public Date getArrivalTime() {
+            return stops.get(stops.size()-1).arrivalTime;
+        }
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/DataReader.java b/core/src/main/java/com/graphhopper/reader/DataReader.java
index 362ac348a7..0a37be8c83 100644
--- a/core/src/main/java/com/graphhopper/reader/DataReader.java
+++ b/core/src/main/java/com/graphhopper/reader/DataReader.java
@@ -36,6 +36,8 @@
 
     DataReader setWayPointMaxDistance(double wayPointMaxDistance);
 
+    DataReader setSmoothElevation(boolean smoothElevation);
+
     /**
      * This method triggers reading the underlying data to create a graph
      */
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/AbstractElevationProvider.java
new file mode 100644
index 0000000000..eda3e48b97
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/AbstractElevationProvider.java
@@ -0,0 +1,114 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.util.Downloader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Provides basic methods that are usually used in an ElevationProvider.
+ *
+ * @author Robin Boldt
+ */
+public abstract class AbstractElevationProvider implements ElevationProvider {
+    final Logger logger = LoggerFactory.getLogger(getClass());
+    Downloader downloader;
+    final File cacheDir;
+    String baseUrl;
+    Directory dir;
+    DAType daType = DAType.MMAP;
+    boolean calcMean = false;
+    boolean autoRemoveTemporary = true;
+    long sleep = 2000;
+
+    protected AbstractElevationProvider(String cacheDirString) {
+        File cacheDir = new File(cacheDirString);
+        if (cacheDir.exists() && !cacheDir.isDirectory())
+            throw new IllegalArgumentException("Cache path has to be a directory");
+        try {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public void setCalcMean(boolean eleCalcMean) {
+        calcMean = eleCalcMean;
+    }
+
+    void setSleep(long sleep) {
+        this.sleep = sleep;
+    }
+
+    @Override
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+    public void setDownloader(Downloader downloader) {
+        this.downloader = downloader;
+    }
+
+    protected File getCacheDir() {
+        return cacheDir;
+    }
+
+    @Override
+    public ElevationProvider setBaseURL(String baseUrl) {
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
+
+        this.baseUrl = baseUrl;
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType(DAType daType) {
+        this.daType = daType;
+        return this;
+    }
+
+
+    protected Directory getDirectory() {
+        if (dir != null)
+            return dir;
+
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType +
+                " using calcmean: " + calcMean);
+        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    }
+
+    /**
+     * Return the local file name without file ending, has to be lower case, because DataAccess only supports lower case names.
+     */
+    abstract String getFileName(double lat, double lon);
+
+    /**
+     * Returns the complete URL to download the file
+     */
+    abstract String getDownloadURL(double lat, double lon);
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractSRTMElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/AbstractSRTMElevationProvider.java
new file mode 100644
index 0000000000..65419b8cb1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/AbstractSRTMElevationProvider.java
@@ -0,0 +1,188 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.coll.GHIntObjectHashMap;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Downloader;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
+
+/**
+ * Common functionality used when working with SRTM hgt data.
+ *
+ * @author Robin Boldt
+ */
+public abstract class AbstractSRTMElevationProvider extends AbstractElevationProvider {
+
+    private static final BitUtil BIT_UTIL = BitUtil.BIG;
+    private final int DEFAULT_WIDTH;
+    private final int WIDTH_BYTE_INDEX = 0;
+    private final int DEGREE = 1;
+    // use a map as an array is not quite useful if we want to hold only parts of the world
+    private final GHIntObjectHashMap<HeightTile> cacheData = new GHIntObjectHashMap<HeightTile>();
+    private final double precision = 1e7;
+    private final double invPrecision = 1 / precision;
+
+    public AbstractSRTMElevationProvider(String baseUrl, String cacheDir, String downloaderName, int defaultWidt) {
+        super(cacheDir);
+        this.baseUrl = baseUrl;
+        downloader = new Downloader(downloaderName).setTimeout(10000);
+        this.DEFAULT_WIDTH = defaultWidt;
+    }
+
+    // use int key instead of string for lower memory usage
+    int calcIntKey(double lat, double lon) {
+        // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
+        return (down(lat) + 90) * 1000 + down(lon) + 180;
+    }
+
+    @Override
+    public void release() {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (autoRemoveTemporary && dir != null)
+            dir.clear();
+    }
+
+    /**
+     * Creating temporary files can take a long time to fill our DataAccess object, so this option
+     * can be used to disable the default clear mechanism via specifying 'false'.
+     */
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+    int down(double val) {
+        int intVal = (int) val;
+        if (val >= 0 || intVal - val < invPrecision)
+            return intVal;
+        return intVal - 1;
+    }
+
+    @Override
+    public double getEle(double lat, double lon) {
+        // Return fast, if there is no data available
+        // See https://www2.jpl.nasa.gov/srtm/faq.html
+        if (lat >= 60 || lat <= -56)
+            return 0;
+
+        lat = (int) (lat * precision) / precision;
+        lon = (int) (lon * precision) / precision;
+        int intKey = calcIntKey(lat, lon);
+        HeightTile demProvider = cacheData.get(intKey);
+        if (demProvider == null) {
+            if (!cacheDir.exists())
+                cacheDir.mkdirs();
+
+            int minLat = down(lat);
+            int minLon = down(lon);
+
+            String fileName = getFileName(lat, lon);
+            if (fileName == null)
+                return 0;
+
+            DataAccess heights = getDirectory().find("dem" + intKey);
+            boolean loadExisting = false;
+            try {
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex) {
+                logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
+            }
+
+            if (!loadExisting) {
+                try {
+                    updateHeightsFromFile(lat, lon, heights);
+                } catch (FileNotFoundException ex) {
+                    demProvider = new HeightTile(minLat, minLon, DEFAULT_WIDTH, DEFAULT_WIDTH, precision, DEGREE, DEGREE);
+                    cacheData.put(intKey, demProvider);
+                    demProvider.setHeights(heights);
+                    demProvider.setSeaLevel(true);
+                    // use small size on disc and in-memory
+                    heights.setSegmentSize(100).create(10).
+                            flush();
+                    return 0;
+                }
+            }
+
+            int width = (int) (Math.sqrt(heights.getHeader(WIDTH_BYTE_INDEX)) + 0.5);
+            if (width == 0)
+                width = DEFAULT_WIDTH;
+
+            demProvider = new HeightTile(minLat, minLon, width, width, precision, DEGREE, DEGREE);
+            cacheData.put(intKey, demProvider);
+            demProvider.setCalcMean(calcMean);
+            demProvider.setHeights(heights);
+        }
+
+        if (demProvider.isSeaLevel())
+            return 0;
+
+        return demProvider.getHeight(lat, lon);
+    }
+
+    private void updateHeightsFromFile(double lat, double lon, DataAccess heights) throws FileNotFoundException {
+        try {
+            byte[] bytes = getByteArrayFromFile(lat, lon);
+            heights.create(bytes.length);
+            for (int bytePos = 0; bytePos < bytes.length; bytePos += 2) {
+                short val = BIT_UTIL.toShort(bytes, bytePos);
+                if (val < -1000 || val > 12000)
+                    val = Short.MIN_VALUE;
+
+                heights.setShort(bytePos, val);
+            }
+            heights.setHeader(WIDTH_BYTE_INDEX, bytes.length / 2);
+            heights.flush();
+
+        } catch (FileNotFoundException ex) {
+            logger.warn("File not found for the coordinates for " + lat + "," + lon);
+            throw ex;
+        } catch (Exception ex) {
+            throw new RuntimeException("There was an issue looking up the coordinates for " + lat + "," + lon, ex);
+        }
+    }
+
+    private byte[] getByteArrayFromFile(double lat, double lon) throws InterruptedException, IOException {
+        String zippedURL = baseUrl + getDownloadURL(lat, lon);
+        File file = new File(cacheDir, new File(zippedURL).getName());
+        InputStream is;
+        // get zip file if not already in cacheDir
+        if (!file.exists())
+            for (int i = 0; i < 3; i++) {
+                try {
+                    downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                    break;
+                } catch (SocketTimeoutException ex) {
+                    // just try again after a little nap
+                    Thread.sleep(2000);
+                }
+            }
+
+        return readFile(file);
+    }
+
+    abstract byte[] readFile(File file) throws IOException;
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java
new file mode 100644
index 0000000000..1b63d9c457
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/AbstractTiffElevationProvider.java
@@ -0,0 +1,199 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.util.Downloader;
+
+import java.awt.image.Raster;
+import java.io.File;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Provides basic methods that are usually used in an ElevationProvider that reads tiff files.
+ *
+ * @author Robin Boldt
+ */
+public abstract class AbstractTiffElevationProvider extends AbstractElevationProvider {
+    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
+    final double precision = 1e7;
+
+    private final int WIDTH;
+    private final int HEIGHT;
+
+    // Degrees of latitude covered by this tile
+    final int LAT_DEGREE;
+    // Degrees of longitude covered by this tile
+    final int LON_DEGREE;
+
+    public AbstractTiffElevationProvider(String baseUrl, String cacheDir, String downloaderName, int width, int height, int latDegree, int lonDegree) {
+        super(cacheDir);
+        this.baseUrl = baseUrl;
+        this.downloader = new Downloader(downloaderName).setTimeout(10000);
+        this.WIDTH = width;
+        this.HEIGHT = height;
+        this.LAT_DEGREE = latDegree;
+        this.LON_DEGREE = lonDegree;
+    }
+
+    @Override
+    public void release() {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (autoRemoveTemporary && dir != null)
+            dir.clear();
+    }
+
+    /**
+     * Return true if the coordinates are outside of the supported area
+     */
+    abstract boolean isOutsideSupportedArea(double lat, double lon);
+
+    /**
+     * The smallest lat that is still in the HeightTile
+     */
+    abstract int getMinLatForTile(double lat);
+
+    /**
+     * The smallest lon that is still in the HeightTile
+     */
+    abstract int getMinLonForTile(double lon);
+
+    /**
+     * Specify the name of the file after downloading
+     */
+    abstract String getFileNameOfLocalFile(double lat, double lon);
+
+    @Override
+    public double getEle(double lat, double lon) {
+        // Return fast, if there is no data available
+        if (isOutsideSupportedArea(lat, lon))
+            return 0;
+
+        lat = (int) (lat * precision) / precision;
+        lon = (int) (lon * precision) / precision;
+        String name = getFileName(lat, lon);
+        HeightTile demProvider = cacheData.get(name);
+        if (demProvider == null) {
+            if (!cacheDir.exists())
+                cacheDir.mkdirs();
+
+            int minLat = getMinLatForTile(lat);
+            int minLon = getMinLonForTile(lon);
+            // less restrictive against boundary checking
+            demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, LON_DEGREE * precision, LON_DEGREE, LAT_DEGREE);
+            demProvider.setCalcMean(calcMean);
+
+            cacheData.put(name, demProvider);
+            DataAccess heights = getDirectory().find(name + ".gh");
+            demProvider.setHeights(heights);
+            boolean loadExisting = false;
+            try {
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex) {
+                logger.warn("cannot load " + name + ", error: " + ex.getMessage());
+            }
+
+            if (!loadExisting) {
+                String zippedURL = getDownloadURL(lat, lon);
+                File file = new File(cacheDir, new File(getFileNameOfLocalFile(lat, lon)).getName());
+
+                try {
+                    downloadFile(file, zippedURL);
+                } catch (IOException e) {
+                    demProvider.setSeaLevel(true);
+                    // use small size on disc and in-memory
+                    heights.setSegmentSize(100).create(10).
+                            flush();
+                    return 0;
+                }
+
+                // short == 2 bytes
+                heights.create(2 * WIDTH * HEIGHT);
+
+                Raster raster = generateRasterFromFile(file, name + ".tif");
+                fillDataAccessWithElevationData(raster, heights, WIDTH);
+
+            } // loadExisting
+        }
+
+        if (demProvider.isSeaLevel())
+            return 0;
+
+        return demProvider.getHeight(lat, lon);
+    }
+
+    abstract Raster generateRasterFromFile(File file, String tifName);
+
+    /**
+     * Download a file at the provided url and save it as the given downloadFile if the downloadFile does not exist.
+     */
+    private void downloadFile(File downloadFile, String url) throws IOException {
+        if (!downloadFile.exists()) {
+            int max = 3;
+            for (int trial = 0; trial < max; trial++) {
+                try {
+                    downloader.downloadFile(url, downloadFile.getAbsolutePath());
+                    return;
+                } catch (SocketTimeoutException ex) {
+                    if (trial >= max - 1)
+                        throw new RuntimeException(ex);
+                    try {
+                        Thread.sleep(sleep);
+                    } catch (InterruptedException ignored) {
+                    }
+                }
+            }
+        }
+    }
+
+    private void fillDataAccessWithElevationData(Raster raster, DataAccess heights, int dataAccessWidth) {
+        final int height = raster.getHeight();
+        final int width = raster.getWidth();
+        int x = 0;
+        int y = 0;
+        try {
+            for (y = 0; y < height; y++) {
+                for (x = 0; x < width; x++) {
+                    short val = (short) raster.getPixel(x, y, (int[]) null)[0];
+                    if (val < -1000 || val > 12000)
+                        val = Short.MIN_VALUE;
+
+                    heights.setShort(2 * (y * dataAccessWidth + x), val);
+                }
+            }
+            heights.flush();
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
+        }
+    }
+
+    /**
+     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
+     * our DataAccess object, so this option can be used to disable the default clear mechanism via
+     * specifying 'false'.
+     */
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 973a54bf03..e9d9a9a58f 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -17,26 +17,15 @@
  */
 package com.graphhopper.reader.dem;
 
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
 import org.apache.xmlgraphics.image.codec.util.SeekableStream;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.awt.image.Raster;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.io.InputStream;
-import java.net.SocketTimeoutException;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
@@ -56,22 +45,21 @@
  * @author NopMap
  * @author Peter Karich
  */
-public class CGIARProvider implements ElevationProvider {
-    private static final int WIDTH = 6000;
-    final double precision = 1e7;
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
+public class CGIARProvider extends AbstractTiffElevationProvider {
     private final double invPrecision = 1 / precision;
-    private final int degree = 5;
-    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
-    private File cacheDir = new File("/tmp/cgiar");
-    // for alternatives see #346
-    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
-    private Directory dir;
-    private DAType daType = DAType.MMAP;
-    private boolean calcMean = false;
-    private boolean autoRemoveTemporary = true;
-    private long sleep = 2000;
+
+    public CGIARProvider() {
+        this("");
+    }
+
+    public CGIARProvider(String cacheDir) {
+        // Alternative URLs for the CGIAR data can be found in #346
+        super("http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff",
+                cacheDir.isEmpty() ? "/tmp/cgiar" : cacheDir,
+                "GraphHopper CGIARReader",
+                6000, 6000,
+                5, 5);
+    }
 
     public static void main(String[] args) {
         CGIARProvider provider = new CGIARProvider();
@@ -80,214 +68,75 @@ public static void main(String[] args) {
 
         // 337.0
         System.out.println(provider.getEle(49.949784, 11.57517));
-        // 453.0
+        // 466.0
         System.out.println(provider.getEle(49.968668, 11.575127));
-        // 447.0
+        // 455.0
         System.out.println(provider.getEle(49.968682, 11.574842));
 
-        // 3131
+        // 3134
         System.out.println(provider.getEle(-22.532854, -65.110474));
 
-        // 123
+        // 120
         System.out.println(provider.getEle(38.065392, -87.099609));
 
         // 1615
         System.out.println(provider.getEle(40, -105.2277023));
         System.out.println(provider.getEle(39.99999999, -105.2277023));
         System.out.println(provider.getEle(39.9999999, -105.2277023));
-        // 1617
+        // 1616
         System.out.println(provider.getEle(39.999999, -105.2277023));
 
         // 0
         System.out.println(provider.getEle(29.840644, -42.890625));
-    }
-
-    @Override
-    public void setCalcMean(boolean eleCalcMean) {
-        calcMean = eleCalcMean;
-    }
-
-    void setSleep(long sleep) {
-        this.sleep = sleep;
-    }
-
-    /**
-     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
-     * our DataAccess object, so this option can be used to disable the default clear mechanism via
-     * specifying 'false'.
-     */
-    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
-        this.autoRemoveTemporary = autoRemoveTemporary;
-    }
 
-    public void setDownloader(Downloader downloader) {
-        this.downloader = downloader;
+        // 841
+        System.out.println(provider.getEle(48.469123, 9.576393));
     }
 
     @Override
-    public ElevationProvider setCacheDir(File cacheDir) {
-        if (cacheDir.exists() && !cacheDir.isDirectory())
-            throw new IllegalArgumentException("Cache path has to be a directory");
+    Raster generateRasterFromFile(File file, String tifName) {
+        SeekableStream ss = null;
         try {
-            this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex) {
-            throw new RuntimeException(ex);
-        }
-        return this;
-    }
-
-    protected File getCacheDir() {
-        return cacheDir;
-    }
-
-    @Override
-    public ElevationProvider setBaseURL(String baseUrl) {
-        if (baseUrl == null || baseUrl.isEmpty())
-            throw new IllegalArgumentException("baseUrl cannot be empty");
-
-        this.baseUrl = baseUrl;
-        return this;
-    }
-
-    @Override
-    public ElevationProvider setDAType(DAType daType) {
-        this.daType = daType;
-        return this;
-    }
-
-    @Override
-    public double getEle(double lat, double lon) {
-        // no data we can avoid the trouble
-        if (lat > 60 || lat < -60)
-            return 0;
-
-        lat = (int) (lat * precision) / precision;
-        lon = (int) (lon * precision) / precision;
-        String name = getFileName(lat, lon);
-        HeightTile demProvider = cacheData.get(name);
-        if (demProvider == null) {
-            if (!cacheDir.exists())
-                cacheDir.mkdirs();
-
-            int minLat = down(lat);
-            int minLon = down(lon);
-            // less restrictive against boundary checking
-            demProvider = new HeightTile(minLat, minLon, WIDTH, degree * precision, degree);
-            demProvider.setCalcMean(calcMean);
-
-            cacheData.put(name, demProvider);
-            DataAccess heights = getDirectory().find(name + ".gh");
-            demProvider.setHeights(heights);
-            boolean loadExisting = false;
-            try {
-                loadExisting = heights.loadExisting();
-            } catch (Exception ex) {
-                logger.warn("cannot load " + name + ", error: " + ex.getMessage());
+            InputStream is = new FileInputStream(file);
+            ZipInputStream zis = new ZipInputStream(is);
+            // find tif file in zip
+            ZipEntry entry = zis.getNextEntry();
+            while (entry != null && !entry.getName().equals(tifName)) {
+                entry = zis.getNextEntry();
             }
 
-            if (!loadExisting) {
-                String tifName = name + ".tif";
-                String zippedURL = baseUrl + "/" + name + ".zip";
-                File file = new File(cacheDir, new File(zippedURL).getName());
-
-                // get zip file if not already in cacheDir - unzip later and in-memory only!
-                if (!file.exists()) {
-                    try {
-                        int max = 3;
-                        for (int trial = 0; trial < max; trial++) {
-                            try {
-                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                                break;
-                            } catch (SocketTimeoutException ex) {
-                                // just try again after a little nap
-                                Thread.sleep(sleep);
-                                if (trial >= max - 1)
-                                    throw ex;
-                                continue;
-                            } catch (IOException ex) {
-                                demProvider.setSeaLevel(true);
-                                // use small size on disc and in-memory
-                                heights.setSegmentSize(100).create(10).
-                                        flush();
-                                return 0;
-                            }
-                        }
-                    } catch (Exception ex) {
-                        throw new RuntimeException(ex);
-                    }
-                }
-
-                // short == 2 bytes
-                heights.create(2 * WIDTH * WIDTH);
-
-                // logger.info("start decoding");
-                // decode tiff data
-                Raster raster;
-                SeekableStream ss = null;
-                try {
-                    InputStream is = new FileInputStream(file);
-                    ZipInputStream zis = new ZipInputStream(is);
-                    // find tif file in zip
-                    ZipEntry entry = zis.getNextEntry();
-                    while (entry != null && !entry.getName().equals(tifName)) {
-                        entry = zis.getNextEntry();
-                    }
-
-                    ss = SeekableStream.wrapInputStream(zis, true);
-                    TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
-                    raster = imageDecoder.decodeAsRaster();
-                } catch (Exception e) {
-                    throw new RuntimeException("Can't decode " + tifName, e);
-                } finally {
-                    if (ss != null)
-                        Helper.close(ss);
-                }
-
-                // logger.info("start converting to our format");
-                final int height = raster.getHeight();
-                final int width = raster.getWidth();
-                int x = 0, y = 0;
-                try {
-                    for (y = 0; y < height; y++) {
-                        for (x = 0; x < width; x++) {
-                            short val = (short) raster.getPixel(x, y, (int[]) null)[0];
-                            if (val < -1000 || val > 12000)
-                                val = Short.MIN_VALUE;
-
-                            heights.setShort(2 * (y * WIDTH + x), val);
-                        }
-                    }
-                    heights.flush();
-
-                    // TODO remove tifName and zip?
-                } catch (Exception ex) {
-                    throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
-                }
-            } // loadExisting
+            ss = SeekableStream.wrapInputStream(zis, true);
+            TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
+            return imageDecoder.decodeAsRaster();
+        } catch (Exception e) {
+            throw new RuntimeException("Can't decode " + tifName, e);
+        } finally {
+            if (ss != null)
+                Helper.close(ss);
         }
-
-        if (demProvider.isSeaLevel())
-            return 0;
-
-        return demProvider.getHeight(lat, lon);
     }
 
     int down(double val) {
         // 'rounding' to closest 5
-        int intVal = (int) (val / degree) * degree;
+        int intVal = (int) (val / LAT_DEGREE) * LAT_DEGREE;
         if (!(val >= 0 || intVal - val < invPrecision))
-            intVal = intVal - degree;
+            intVal = intVal - LAT_DEGREE;
 
         return intVal;
     }
 
+    @Override
+    boolean isOutsideSupportedArea(double lat, double lon) {
+        return lat >= 60 || lat <= -56;
+    }
+
     protected String getFileName(double lat, double lon) {
-        lon = 1 + (180 + lon) / degree;
+        lon = 1 + (180 + lon) / LAT_DEGREE;
         int lonInt = (int) lon;
-        lat = 1 + (60 - lat) / degree;
+        lat = 1 + (60 - lat) / LAT_DEGREE;
         int latInt = (int) lat;
 
-        if (Math.abs(latInt - lat) < invPrecision / degree)
+        if (Math.abs(latInt - lat) < invPrecision / LAT_DEGREE)
             latInt--;
 
         // replace String.format as it seems to be slow
@@ -302,24 +151,27 @@ protected String getFileName(double lat, double lon) {
     }
 
     @Override
-    public void release() {
-        cacheData.clear();
+    int getMinLatForTile(double lat) {
+        return down(lat);
+    }
 
-        // for memory mapped type we create temporary unpacked files which should be removed
-        if (autoRemoveTemporary && dir != null)
-            dir.clear();
+    @Override
+    int getMinLonForTile(double lon) {
+        return down(lon);
     }
 
     @Override
-    public String toString() {
-        return "CGIAR";
+    String getDownloadURL(double lat, double lon) {
+        return baseUrl + "/" + getFileName(lat, lon) + ".zip";
     }
 
-    private Directory getDirectory() {
-        if (dir != null)
-            return dir;
+    @Override
+    String getFileNameOfLocalFile(double lat, double lon) {
+        return getDownloadURL(lat, lon);
+    }
 
-        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
-        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    @Override
+    public String toString() {
+        return "cgiar";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index 5c8726cf28..d38142d069 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -19,8 +19,6 @@
 
 import com.graphhopper.storage.DAType;
 
-import java.io.File;
-
 /**
  * @author Peter Karich
  */
@@ -31,11 +29,6 @@ public double getEle(double lat, double lon) {
             return Double.NaN;
         }
 
-        @Override
-        public ElevationProvider setCacheDir(File cacheDir) {
-            return this;
-        }
-
         @Override
         public ElevationProvider setBaseURL(String baseURL) {
             return this;
@@ -50,6 +43,10 @@ public ElevationProvider setDAType(DAType daType) {
         public void release() {
         }
 
+        @Override
+        public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        }
+
         @Override
         public void setCalcMean(boolean eleCalcMean) {
         }
@@ -66,12 +63,6 @@ public void setCalcMean(boolean eleCalcMean) {
      */
     ElevationProvider setBaseURL(String baseURL);
 
-    /**
-     * Specifies the directory where to temporarily store the elevation data after fetched from base
-     * URL. Default is a custom provider-dependent subdirectory in '/tmp'
-     */
-    ElevationProvider setCacheDir(File cacheDir);
-
     /**
      * Set to true if you have a small area and need high speed access. Default is DAType.MMAP
      */
@@ -87,4 +78,11 @@ public void setCalcMean(boolean eleCalcMean) {
      * Release resources.
      */
     void release();
+
+    /**
+     * Creating temporary files can take a long time as we need to unpack them as well as to fill
+     * our DataAccess object, so this option can be used to disable the default clear mechanism via
+     * specifying 'false'.
+     */
+    void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary);
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java b/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java
new file mode 100644
index 0000000000..a9f5031d4f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/GMTEDProvider.java
@@ -0,0 +1,225 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Helper;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
+import org.apache.xmlgraphics.image.codec.util.SeekableStream;
+
+import java.awt.image.Raster;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+
+import static com.graphhopper.util.Helper.*;
+
+/**
+ * Elevation data from Global Multi-resolution Terrain Elevation Data 2010 (GMTED2010).
+ * The data provides 7.5 arc seconds resolution (~250 m) global elevation data. The data is available between latitudes
+ * of 84°N and 70°S. The data is available as .tiff and the we are using the mean elevation per cell (other options are
+ * median, min, max, etc.).
+ * <p>
+ * More information can be found here: https://topotools.cr.usgs.gov/gmted_viewer/
+ * <p>
+ * When using the data we have to acknowledge the source: "Data available from the U.S. Geological Survey.",
+ * more information can be found here: https://lta.cr.usgs.gov/citation
+ * <p>
+ * The gdalinfo of one GeoTiff is:
+ * Driver: GTiff/GeoTIFF
+ * Files: 50N000E_20101117_gmted_mea075.tif
+ * Size is 14400, 9600
+ * Coordinate System is:
+ * GEOGCS["WGS 84",
+ * DATUM["WGS_1984",
+ * SPHEROID["WGS 84",6378137,298.257223563,
+ * AUTHORITY["EPSG","7030"]],
+ * AUTHORITY["EPSG","6326"]],
+ * PRIMEM["Greenwich",0],
+ * UNIT["degree",0.0174532925199433],
+ * AUTHORITY["EPSG","4326"]]
+ * Origin = (-0.000138888888889,69.999861111111116)
+ * Pixel Size = (0.002083333333333,-0.002083333333333)
+ * Metadata:
+ * AREA_OR_POINT=Area
+ * Image Structure Metadata:
+ * INTERLEAVE=BAND
+ * Corner Coordinates:
+ * Upper Left  (  -0.0001389,  69.9998611) (  0d 0' 0.50"W, 69d59'59.50"N)
+ * Lower Left  (  -0.0001389,  49.9998611) (  0d 0' 0.50"W, 49d59'59.50"N)
+ * Upper Right (  29.9998611,  69.9998611) ( 29d59'59.50"E, 69d59'59.50"N)
+ * Lower Right (  29.9998611,  49.9998611) ( 29d59'59.50"E, 49d59'59.50"N)
+ * Center      (  14.9998611,  59.9998611) ( 14d59'59.50"E, 59d59'59.50"N)
+ * Band 1 Block=14400x1 Type=Int16, ColorInterp=Gray
+ * Min=-209.000 Max=2437.000
+ * Minimum=-209.000, Maximum=2437.000, Mean=149.447, StdDev=239.767
+ * NoData Value=-32768
+ * Metadata:
+ * STATISTICS_EXCLUDEDVALUES=-32768
+ * STATISTICS_MAXIMUM=2437
+ * STATISTICS_MEAN=149.44718774595
+ * STATISTICS_MINIMUM=-209
+ * STATISTICS_STDDEV=239.767158482
+ *
+ * @author Robin Boldt
+ */
+public class GMTEDProvider extends AbstractTiffElevationProvider {
+    // for alternatives see #346
+    private final String FILE_NAME_END = "_20101117_gmted_mea075";
+
+    public GMTEDProvider() {
+        this("");
+    }
+
+    public GMTEDProvider(String cacheDir) {
+        super("https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/topo/downloads/GMTED/Global_tiles_GMTED/075darcsec/mea/",
+                cacheDir.isEmpty() ? "/tmp/gmted" : cacheDir,
+                "GraphHopper GMTEDReader",
+                14400, 9600,
+                20, 30);
+    }
+
+    public static void main(String[] args) {
+        GMTEDProvider provider = new GMTEDProvider();
+
+        System.out.println(provider.getEle(46, -20));
+
+        // 337.0 (339)
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 453.0 (438)
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 447.0 (432)
+        System.out.println(provider.getEle(49.968682, 11.574842));
+
+        // 3131 (3169)
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+
+        // 123 (124)
+        System.out.println(provider.getEle(38.065392, -87.099609));
+
+        // 1615 (1615)
+        System.out.println(provider.getEle(40, -105.2277023));
+        // (1618)
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        // 1617 (1618)
+        System.out.println(provider.getEle(39.999999, -105.2277023));
+
+        // 1046 (1070)
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113 (1115)
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946 (1990)
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845 (841)
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new: (1115)
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 0
+        System.out.println(provider.getEle(29.840644, -42.890625));
+    }
+
+    @Override
+    Raster generateRasterFromFile(File file, String tifName) {
+        SeekableStream ss = null;
+        try {
+            InputStream is = new FileInputStream(file);
+            ss = SeekableStream.wrapInputStream(is, true);
+            TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
+            return imageDecoder.decodeAsRaster();
+        } catch (Exception e) {
+            throw new RuntimeException("Can't decode " + file.getName(), e);
+        } finally {
+            if (ss != null)
+                close(ss);
+        }
+    }
+
+    int getMinLatForTile(double lat) {
+        return (int) (Math.floor((90 + lat) / LAT_DEGREE) * LAT_DEGREE) - 90;
+    }
+
+    int getMinLonForTile(double lon) {
+        return (int) (Math.floor((180 + lon) / LON_DEGREE) * LON_DEGREE) - 180;
+    }
+
+    private String getLonString(int lonInt) {
+        lonInt = Math.abs(lonInt);
+        String lonString = lonInt < 100 ? "0" : "";
+        if (lonInt < 10)
+            lonString += "0";
+        lonString += lonInt;
+        return lonString;
+    }
+
+    private String getLatString(int latInt) {
+        latInt = Math.abs(latInt);
+        String latString = latInt < 10 ? "0" : "";
+        latString += latInt;
+        return latString;
+    }
+
+    @Override
+    boolean isOutsideSupportedArea(double lat, double lon) {
+        return lat > 84 || lat < -70;
+    }
+
+    String getFileName(double lat, double lon) {
+        int lonInt = getMinLonForTile(lon);
+        int latInt = getMinLatForTile(lat);
+        return toLowerCase(getLatString(latInt) + getNorthString(latInt) + getLonString(lonInt) + getEastString(lonInt) + FILE_NAME_END);
+    }
+
+    String getDownloadURL(double lat, double lon) {
+        int lonInt = getMinLonForTile(lon);
+        int latInt = getMinLatForTile(lat);
+        String east = getEastString(lonInt);
+        String lonString = getLonString(lonInt);
+        return baseUrl + "/" + east + lonString + "/" + getLatString(latInt) + getNorthString(latInt) + lonString + east + FILE_NAME_END + ".tif";
+    }
+
+    @Override
+    String getFileNameOfLocalFile(double lat, double lon) {
+        return getFileName(lat, lon) + ".tif";
+    }
+
+    private String getNorthString(int lat) {
+        if (lat < 0) {
+            return "S";
+        }
+        return "N";
+    }
+
+    private String getEastString(int lon) {
+        if (lon < 0) {
+            return "W";
+        }
+        return "E";
+    }
+
+    @Override
+    public String toString() {
+        return "gmted";
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/GraphElevationSmoothing.java b/core/src/main/java/com/graphhopper/reader/dem/GraphElevationSmoothing.java
new file mode 100644
index 0000000000..3deb4b3022
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/GraphElevationSmoothing.java
@@ -0,0 +1,62 @@
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+
+/**
+ * This class smooths the elevation data of a PointList by calculating the average elevation over
+ * multiple points of that PointList.
+ * <p>
+ * The ElevationData is read from rectangular tiles. Especially when going along a cliff,
+ * valley, or pass, it can happen that a small part of the road contains incorrect elevation data.
+ * This is because the elevation data is coarse and sometimes contains errors.
+ * <p>
+ * This can lead to incorrect ascend, descend, and distance calculation of a route.
+ *
+ * @author Robin Boldt
+ */
+public class GraphElevationSmoothing {
+
+    // If the point is farther then this, we stop averaging
+    private final static int MAX_SEARCH_DISTANCE = 150;
+
+    public static PointList smoothElevation(PointList geometry) {
+        for (int i = 1; i < geometry.size() - 1; i++) {
+
+            int start = i;
+            for (int j = i-1; j >= 0 ; j--) {
+                if (MAX_SEARCH_DISTANCE > Helper.DIST_PLANE.calcDist(geometry.getLat(i), geometry.getLon(i), geometry.getLat(j), geometry.getLon(j))) {
+                    start = j;
+                }else{
+                    break;
+                }
+            }
+
+            int end = i;
+            for (int j = i+1; j < geometry.size(); j++) {
+                if (MAX_SEARCH_DISTANCE > Helper.DIST_PLANE.calcDist(geometry.getLat(i), geometry.getLon(i), geometry.getLat(j), geometry.getLon(j))) {
+                    // +1 because the end is exclusive
+                    end = j+1;
+                }else{
+                    break;
+                }
+            }
+
+            // In this case we cannot find any points withing the max search distance, so we simply skip this point
+            if(start == end)
+                continue;
+
+            double sum = 0;
+            for (int j = start; j < end; j++) {
+                // We skip points that are too far away, important for motorways
+                if (MAX_SEARCH_DISTANCE > Helper.DIST_PLANE.calcDist(geometry.getLat(i), geometry.getLon(i), geometry.getLat(j), geometry.getLon(j))) {
+                    sum += geometry.getEle(j);
+                }
+            }
+            double smoothed = sum / (end-start);
+            geometry.setElevation(i, smoothed);
+        }
+        return geometry;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index 7fb681172e..c7b5b866c1 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -36,21 +36,27 @@
     private final int minLat;
     private final int minLon;
     private final int width;
-    private final int degree;
+    private final int height;
+    private final int horizontalDegree;
+    private final int verticalDegree;
     private final double lowerBound;
-    private final double higherBound;
+    private final double lonHigherBound;
+    private final double latHigherBound;
     private DataAccess heights;
     private boolean calcMean;
 
-    public HeightTile(int minLat, int minLon, int width, double precision, int degree) {
+    public HeightTile(int minLat, int minLon, int width, int height, double precision, int horizontalDegree, int verticalDegree) {
         this.minLat = minLat;
         this.minLon = minLon;
         this.width = width;
+        this.height = height;
 
         this.lowerBound = -1 / precision;
-        this.higherBound = degree + 1 / precision;
+        this.lonHigherBound = horizontalDegree + 1 / precision;
+        this.latHigherBound = verticalDegree + 1 / precision;
 
-        this.degree = degree;
+        this.horizontalDegree = horizontalDegree;
+        this.verticalDegree = verticalDegree;
     }
 
     public HeightTile setCalcMean(boolean b) {
@@ -74,18 +80,18 @@ void setHeights(DataAccess da) {
     public double getHeight(double lat, double lon) {
         double deltaLat = Math.abs(lat - minLat);
         double deltaLon = Math.abs(lon - minLon);
-        if (deltaLat > higherBound || deltaLat < lowerBound)
+        if (deltaLat > latHigherBound || deltaLat < lowerBound)
             throw new IllegalStateException("latitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
-        if (deltaLon > higherBound || deltaLon < lowerBound)
+        if (deltaLon > lonHigherBound || deltaLon < lowerBound)
             throw new IllegalStateException("longitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
 
         // first row in the file is the northernmost one
         // http://gis.stackexchange.com/a/43756/9006
-        int lonSimilar = (int) (width / degree * deltaLon);
+        int lonSimilar = (int) (width / horizontalDegree * deltaLon);
         // different fallback methods for lat and lon as we have different rounding (lon -> positive, lat -> negative)
         if (lonSimilar >= width)
             lonSimilar = width - 1;
-        int latSimilar = width - 1 - (int) (width / degree * deltaLat);
+        int latSimilar = height - 1 - (int) (height / verticalDegree * deltaLat);
         if (latSimilar < 0)
             latSimilar = 0;
 
@@ -106,7 +112,7 @@ public double getHeight(double lat, double lon) {
             if (latSimilar > 0)
                 value += includePoint(daPointer - 2 * width, counter);
 
-            if (latSimilar < width - 1)
+            if (latSimilar < height - 1)
                 value += includePoint(daPointer + 2 * width, counter);
         }
 
@@ -127,14 +133,13 @@ public void toImage(String imageFile) throws IOException {
     }
 
     protected BufferedImage makeARGB() {
-        int height = width;
         BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
         Graphics g = argbImage.getGraphics();
-        long len = width * width;
+        long len = width * height;
         for (int i = 0; i < len; i++) {
             int lonSimilar = i % width;
             // no need for width - y as coordinate system for Graphics is already this way
-            int latSimilar = i / width;
+            int latSimilar = i / height;
             int green = Math.abs(heights.getShort(i * 2));
             if (green == 0) {
                 g.setColor(new Color(255, 0, 0, 255));
@@ -154,8 +159,7 @@ protected BufferedImage makeARGB() {
         return argbImage;
     }
 
-    public BufferedImage getImageFromArray(int[] pixels, int width) {
-        int height = width;
+    public BufferedImage getImageFromArray(int[] pixels, int width, int height) {
         BufferedImage tmpImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
         tmpImage.setRGB(0, 0, width, height, pixels, 0, width);
         return tmpImage;
@@ -165,4 +169,4 @@ public BufferedImage getImageFromArray(int[] pixels, int width) {
     public String toString() {
         return minLat + "," + minLon;
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java
new file mode 100644
index 0000000000..080cc0f383
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/MultiSourceElevationProvider.java
@@ -0,0 +1,102 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+
+/**
+ * The MultiSourceElevationProvider mixes different elevation providers to provide the best available elevation data
+ * for a certain area.
+ *
+ * @author Robin Boldt
+ */
+public class MultiSourceElevationProvider implements ElevationProvider {
+
+    // Usually a high resolution provider in the SRTM area
+    private ElevationProvider srtmProvider;
+    // The fallback provider that provides elevation data globally
+    private ElevationProvider globalProvider;
+
+    public MultiSourceElevationProvider(ElevationProvider srtmProvider, ElevationProvider globalProvider) {
+        this.srtmProvider = srtmProvider;
+        this.globalProvider = globalProvider;
+    }
+
+    public MultiSourceElevationProvider() {
+        this(new CGIARProvider(), new GMTEDProvider());
+    }
+
+    public MultiSourceElevationProvider(String cacheDir) {
+        this(new CGIARProvider(cacheDir), new GMTEDProvider(cacheDir));
+    }
+
+    @Override
+    public double getEle(double lat, double lon) {
+        // Sometimes the cgiar data north of 59.999 equals 0
+        if (lat < 59.999 && lat > -56) {
+            return srtmProvider.getEle(lat, lon);
+        }
+        return globalProvider.getEle(lat, lon);
+    }
+
+    /**
+     * For the MultiSourceElevationProvider you have to specify the base URL separated by a ';'.
+     * The first for cgiar, the second for gmted.
+     */
+    @Override
+    public ElevationProvider setBaseURL(String baseURL) {
+        String[] urls = baseURL.split(";");
+        if (urls.length != 2) {
+            throw new IllegalArgumentException("The base url must consist of two urls separated by a ';'. The first for cgiar, the second for gmted");
+        }
+        srtmProvider.setBaseURL(urls[0]);
+        globalProvider.setBaseURL(urls[1]);
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType(DAType daType) {
+        srtmProvider.setDAType(daType);
+        globalProvider.setDAType(daType);
+        return this;
+    }
+
+    @Override
+    public void setCalcMean(boolean calcMean) {
+        srtmProvider.setCalcMean(calcMean);
+        globalProvider.setCalcMean(calcMean);
+    }
+
+    @Override
+    public void release() {
+        srtmProvider.release();
+        globalProvider.release();
+    }
+
+    @Override
+    public void setAutoRemoveTemporaryFiles(boolean autoRemoveTemporary) {
+        srtmProvider.setAutoRemoveTemporaryFiles(autoRemoveTemporary);
+        globalProvider.setAutoRemoveTemporaryFiles(autoRemoveTemporary);
+    }
+
+    @Override
+    public String toString() {
+        return "multi";
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMGL1Provider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMGL1Provider.java
new file mode 100644
index 0000000000..f351e92438
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMGL1Provider.java
@@ -0,0 +1,172 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Helper;
+
+import java.io.*;
+
+import static com.graphhopper.util.Helper.*;
+
+/**
+ * SRTMGL1 contains elevation data for most of the world with 1 arc second (~30m) accuracy.
+ * We use the mirror of OpenTopography, as the official SRTMGL1 download requires authentication.
+ * http://opentopo.sdsc.edu/raster?opentopoID=OTSRTM.082015.4326.1
+ * <p>
+ * TODO: In addition, NSF requires oral acknowledgment during all news media interviews.
+ * TODO: This is weird, we have to check if really want to use OpenTopography then, see: http://www.opentopography.org/citations
+ * <p>
+ * When using this data we have to acknowledge:
+ * This material is based on data services provided by the OpenTopography Facility with support from the
+ * National Science Foundation under NSF Award Numbers 1226353 & 1225810
+ * National Geospatial-Intelligence Agency (NGA) and the National Aeronautics and Space Administration (NASA), 2013,
+ * SRTMGL1: NASA Shuttle Radar Topography Mission Global 1 arc second V003. [Version]. NASA EOSDIS Land Processes DAAC,
+ * USGS Earth Resources Observation and Science (EROS) Center, Sioux Falls, South Dakota (https://lpdaac.usgs.gov),
+ * accessed 11 29, 2017, at https://doi.org/10.5067/measures/srtm/srtmgl1.003
+ * <p>
+ * Detailed information can be found here: https://lpdaac.usgs.gov/sites/default/files/public/measures/docs/NASA_SRTM_V3.pdf
+ *
+ * @author Robin Boldt
+ */
+public class SRTMGL1Provider extends AbstractSRTMElevationProvider {
+
+    private final int latDegree = 1;
+    private final int lonDegree = 1;
+
+    public SRTMGL1Provider() {
+        this("");
+    }
+
+    public SRTMGL1Provider(String cacheDir) {
+        super("https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/",
+                cacheDir.isEmpty() ? "/tmp/srtmgl1" : cacheDir,
+                "GraphHopper SRTMReader",
+                3601
+        );
+    }
+
+    public static void main(String[] args) throws IOException {
+        SRTMGL1Provider provider = new SRTMGL1Provider();
+        // 338
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 468
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 467
+        System.out.println(provider.getEle(49.968682, 11.574842));
+        // 3110
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+        // 120
+        System.out.println(provider.getEle(38.065392, -87.099609));
+        // 1617
+        System.out.println(provider.getEle(40, -105.2277023));
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        System.out.println(provider.getEle(39.999999, -105.2277023));
+        // 1015
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1107
+        System.out.println(provider.getEle(47.467753, 14.573911));
+        // 1930
+        System.out.println(provider.getEle(46.468835, 12.578777));
+        // 844
+        System.out.println(provider.getEle(48.469123, 9.576393));
+    }
+
+    @Override
+    byte[] readFile(File file) throws IOException {
+        InputStream is = new FileInputStream(file);
+        BufferedInputStream buff = new BufferedInputStream(is);
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        byte[] buffer = new byte[0xFFFF];
+        int len;
+        while ((len = buff.read(buffer)) > 0) {
+            os.write(buffer, 0, len);
+        }
+        os.flush();
+        close(buff);
+        return os.toByteArray();
+    }
+
+    int getMinLatForTile(double lat) {
+        return (int) (Math.floor((90 + lat) / latDegree) * latDegree) - 90;
+    }
+
+    int getMinLonForTile(double lon) {
+        return (int) (Math.floor((180 + lon) / lonDegree) * lonDegree) - 180;
+    }
+
+    private String getLonString(int lonInt) {
+        lonInt = Math.abs(lonInt);
+        String lonString = lonInt < 100 ? "0" : "";
+        if (lonInt < 10)
+            lonString += "0";
+        lonString += lonInt;
+        return lonString;
+    }
+
+    private String getLatString(int latInt) {
+        latInt = Math.abs(latInt);
+        String latString = latInt < 10 ? "0" : "";
+        latString += latInt;
+        return latString;
+    }
+
+    String getFileName(double lat, double lon) {
+        int lonInt = getMinLonForTile(lon);
+        int latInt = getMinLatForTile(lat);
+        return toLowerCase(getNorthString(latInt) + getLatString(latInt) + getEastString(lonInt) + getLonString(lonInt));
+    }
+
+    String getDownloadURL(double lat, double lon) {
+        int lonInt = getMinLonForTile(lon);
+        int latInt = getMinLatForTile(lat);
+        String north = getNorthString(latInt);
+        String dir;
+        if (north.equals("N")) {
+            dir = "North/";
+            if (lat >= 30)
+                dir += "North_30_60/";
+            else
+                dir += "North_0_29/";
+        } else {
+            dir = "South/";
+        }
+
+        return dir + north + getLatString(latInt) + getEastString(lonInt) + getLonString(lonInt) + ".hgt";
+    }
+
+    private String getNorthString(int lat) {
+        if (lat < 0) {
+            return "S";
+        }
+        return "N";
+    }
+
+    private String getEastString(int lon) {
+        if (lon < 0) {
+            return "W";
+        }
+        return "E";
+    }
+
+    @Override
+    public String toString() {
+        return "srtmgl1";
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 7c1fc29c16..50a9fdb9d4 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -18,18 +18,9 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.coll.GHIntObjectHashMap;
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.*;
-import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
 
 /**
@@ -43,52 +34,49 @@
  *
  * @author Peter Karich
  */
-public class SRTMProvider implements ElevationProvider {
-    private static final BitUtil BIT_UTIL = BitUtil.BIG;
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final int DEFAULT_WIDTH = 1201;
-    private final int WIDTH_BYTE_INDEX = 0;
-    // use a map as an array is not quite useful if we want to hold only parts of the world
-    private final GHIntObjectHashMap<HeightTile> cacheData = new GHIntObjectHashMap<HeightTile>();
+public class SRTMProvider extends AbstractSRTMElevationProvider {
     private final GHIntObjectHashMap<String> areas = new GHIntObjectHashMap<String>();
-    private final double precision = 1e7;
-    private final double invPrecision = 1 / precision;
-    private Directory dir;
-    private DAType daType = DAType.MMAP;
-    private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
-    private File cacheDir = new File("/tmp/srtm");
-    // possible alternatives see #451
-    // http://mirror.ufs.ac.za/datasets/SRTM3/
-    //"http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/"
-    private String baseUrl = "https://srtm.kurviger.de/SRTM3/";
-    private boolean calcMean = false;
 
     public SRTMProvider() {
+        this("");
+    }
+
+    public SRTMProvider(String cacheDir) {
+        super(
+                "https://srtm.kurviger.de/SRTM3/",
+                cacheDir.isEmpty()? "/tmp/srtm": cacheDir,
+                "GraphHopper SRTMReader",
+                1201
+        );
         // move to explicit calls?
         init();
     }
 
     public static void main(String[] args) throws IOException {
         SRTMProvider provider = new SRTMProvider();
+        // 337
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 466
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 466
+        System.out.println(provider.getEle(49.968682, 11.574842));
+        // 3100
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+        // 122
+        System.out.println(provider.getEle(38.065392, -87.099609));
+        // 1617
+        System.out.println(provider.getEle(40, -105.2277023));
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        System.out.println(provider.getEle(39.999999, -105.2277023));
         // 1046
         System.out.println(provider.getEle(47.468668, 14.575127));
         // 1113
         System.out.println(provider.getEle(47.467753, 14.573911));
-
         // 1946
         System.out.println(provider.getEle(46.468835, 12.578777));
-
         // 845
         System.out.println(provider.getEle(48.469123, 9.576393));
-
-        // 1113 vs new:
-        provider.setCalcMean(true);
-        System.out.println(provider.getEle(47.467753, 14.573911));
-    }
-
-    @Override
-    public void setCalcMean(boolean calcMean) {
-        this.calcMean = calcMean;
     }
 
     /**
@@ -121,52 +109,30 @@ private SRTMProvider init() {
         }
     }
 
-    // use int key instead of string for lower memory usage
-    private int calcIntKey(double lat, double lon) {
-        // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
-        return (down(lat) + 90) * 1000 + down(lon) + 180;
-    }
-
-    public void setDownloader(Downloader downloader) {
-        this.downloader = downloader;
-    }
-
     @Override
-    public ElevationProvider setCacheDir(File cacheDir) {
-        if (cacheDir.exists() && !cacheDir.isDirectory())
-            throw new IllegalArgumentException("Cache path has to be a directory");
-
-        try {
-            this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex) {
-            throw new RuntimeException(ex);
-        }
-        return this;
+    public String toString() {
+        return "srtm";
     }
 
     @Override
-    public ElevationProvider setBaseURL(String baseUrl) {
-        if (baseUrl == null || baseUrl.isEmpty())
-            throw new IllegalArgumentException("baseUrl cannot be empty");
-
-        this.baseUrl = baseUrl;
-        return this;
+    byte[] readFile(File file) throws IOException {
+        InputStream is = new FileInputStream(file);
+        ZipInputStream zis = new ZipInputStream(is);
+        zis.getNextEntry();
+        BufferedInputStream buff = new BufferedInputStream(zis);
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        byte[] buffer = new byte[0xFFFF];
+        int len;
+        while ((len = buff.read(buffer)) > 0) {
+            os.write(buffer, 0, len);
+        }
+        os.flush();
+        Helper.close(buff);
+        return os.toByteArray();
     }
 
     @Override
-    public ElevationProvider setDAType(DAType daType) {
-        this.daType = daType;
-        return this;
-    }
-
-    int down(double val) {
-        int intVal = (int) val;
-        if (val >= 0 || intVal - val < invPrecision)
-            return intVal;
-        return intVal - 1;
-    }
-
-    String getFileString(double lat, double lon) {
+    String getFileName(double lat, double lon) {
         int intKey = calcIntKey(lat, lon);
         String str = areas.get(intKey);
         if (str == null)
@@ -198,113 +164,7 @@ String getFileString(double lat, double lon) {
     }
 
     @Override
-    public double getEle(double lat, double lon) {
-        lat = (int) (lat * precision) / precision;
-        lon = (int) (lon * precision) / precision;
-        int intKey = calcIntKey(lat, lon);
-        HeightTile demProvider = cacheData.get(intKey);
-        if (demProvider != null)
-            return demProvider.getHeight(lat, lon);
-
-        if (!cacheDir.exists())
-            cacheDir.mkdirs();
-
-        String fileDetails = getFileString(lat, lon);
-        if (fileDetails == null)
-            return 0;
-
-        DataAccess heights = getDirectory().find("dem" + intKey);
-        boolean loadExisting = false;
-        try {
-            loadExisting = heights.loadExisting();
-        } catch (Exception ex) {
-            logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
-        }
-
-        if (!loadExisting)
-            updateHeightsFromZipFile(fileDetails, heights);
-
-        int width = (int) (Math.sqrt(heights.getHeader(WIDTH_BYTE_INDEX)) + 0.5);
-        if (width == 0)
-            width = DEFAULT_WIDTH;
-
-        demProvider = new HeightTile(down(lat), down(lon), width, precision, 1);
-        cacheData.put(intKey, demProvider);
-        demProvider.setCalcMean(calcMean);
-        demProvider.setHeights(heights);
-        return demProvider.getHeight(lat, lon);
-    }
-
-    private void updateHeightsFromZipFile(String fileDetails, DataAccess heights) throws RuntimeException {
-        try {
-            byte[] bytes = getByteArrayFromZipFile(fileDetails);
-            heights.create(bytes.length);
-            for (int bytePos = 0; bytePos < bytes.length; bytePos += 2) {
-                short val = BIT_UTIL.toShort(bytes, bytePos);
-                if (val < -1000 || val > 12000)
-                    val = Short.MIN_VALUE;
-
-                heights.setShort(bytePos, val);
-            }
-            heights.setHeader(WIDTH_BYTE_INDEX, bytes.length / 2);
-            heights.flush();
-
-        } catch (Exception ex) {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    private byte[] getByteArrayFromZipFile(String fileDetails) throws InterruptedException, FileNotFoundException, IOException {
-        String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
-        File file = new File(cacheDir, new File(zippedURL).getName());
-        InputStream is;
-        // get zip file if not already in cacheDir
-        if (!file.exists())
-            for (int i = 0; i < 3; i++) {
-                try {
-                    downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                    break;
-                } catch (SocketTimeoutException ex) {
-                    // just try again after a little nap
-                    Thread.sleep(2000);
-                    continue;
-                }
-            }
-
-        is = new FileInputStream(file);
-        ZipInputStream zis = new ZipInputStream(is);
-        zis.getNextEntry();
-        BufferedInputStream buff = new BufferedInputStream(zis);
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        byte[] buffer = new byte[0xFFFF];
-        int len;
-        while ((len = buff.read(buffer)) > 0) {
-            os.write(buffer, 0, len);
-        }
-        os.flush();
-        Helper.close(buff);
-        return os.toByteArray();
-    }
-
-    @Override
-    public void release() {
-        cacheData.clear();
-
-        // for memory mapped type we create temporary unpacked files which should be removed
-        if (dir != null)
-            dir.clear();
-    }
-
-    @Override
-    public String toString() {
-        return "SRTM";
-    }
-
-    private Directory getDirectory() {
-        if (dir != null)
-            return dir;
-
-        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
-        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    String getDownloadURL(double lat, double lon) {
+        return getFileName(lat, lon) + ".hgt.zip";
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 4278e995b7..6307564897 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -66,13 +66,17 @@
     private double doublePrevLat, doublePrevLon; // Lat and Lon of node t-2
     private int prevNode;
     private double prevOrientation;
+    private double prevInstructionPrevOrientation = Double.NaN;
     private Instruction prevInstruction;
     private boolean prevInRoundabout;
     private String prevName;
+    private String prevInstructionName;
     private InstructionAnnotation prevAnnotation;
     private EdgeExplorer outEdgeExplorer;
     private EdgeExplorer crossingExplorer;
 
+    private final int MAX_U_TURN_DISTANCE = 35;
+
     public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder, NodeAccess nodeAccess, Translation tr, InstructionList ways) {
         this.weighting = weighting;
         this.encoder = encoder;
@@ -119,6 +123,10 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
         {
             int sign = Instruction.CONTINUE_ON_STREET;
             prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+            double startLat = nodeAccess.getLat(baseNode);
+            double startLon = nodeAccess.getLon(baseNode);
+            double heading = Helper.ANGLE_CALC.calcAzimuth(startLat, startLon, latitude, longitude);
+            prevInstruction.setExtraInfo("heading", Helper.round(heading, 2));
             ways.add(prevInstruction);
             prevName = name;
             prevAnnotation = annotation;
@@ -130,6 +138,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                 int sign = Instruction.USE_ROUNDABOUT;
                 RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
                         annotation, new PointList(10, nodeAccess.is3D()));
+                prevInstructionPrevOrientation = prevOrientation;
                 if (prevName != null) {
                     // check if there is an exit at the same node the roundabout was entered
                     EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
@@ -192,6 +201,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                     .setDirOfRotation(deltaOut)
                     .setExited();
 
+            prevInstructionName = prevName;
             prevName = name;
             prevAnnotation = annotation;
 
@@ -199,9 +209,56 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
             int sign = getTurn(edge, baseNode, prevNode, adjNode, annotation, name);
 
             if (sign != Instruction.IGNORE) {
-                prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
-                ways.add(prevInstruction);
-                prevAnnotation = annotation;
+                /*
+                    Check if the next instruction is likely to only be a short connector to execute a u-turn
+                    --A->--
+                           |    <-- This is the short connector
+                    --B-<--
+                    Road A and Road B have to have the same name and roughly the same, but opposite orientation, otherwise we are assuming this is no u-turn.
+
+                    Note: This approach only works if there a turn instruction fro A->Connector and Connector->B.
+                    Currently we don't create a turn instruction if there is no other possible turn
+                    We only create a u-turn if edge B is a one-way, see #1073 for more details.
+                  */
+
+                boolean isUTurn = false;
+                int uTurnType = Instruction.U_TURN_UNKNOWN;
+                if (!Double.isNaN(prevInstructionPrevOrientation)
+                        && prevInstruction.getDistance() < MAX_U_TURN_DISTANCE
+                        && (sign < 0) == (prevInstruction.getSign() < 0)
+                        && (Math.abs(sign) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(sign) == Instruction.TURN_RIGHT || Math.abs(sign) == Instruction.TURN_SHARP_RIGHT)
+                        && (Math.abs(prevInstruction.getSign()) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_SHARP_RIGHT)
+                        && edge.isForward(encoder) != edge.isBackward(encoder)
+                        && InstructionsHelper.isNameSimilar(prevInstructionName, name)) {
+                    // Chances are good that this is a u-turn, we only need to check if the orientation matches
+                    GHPoint point = InstructionsHelper.getPointForOrientationCalculation(edge, nodeAccess);
+                    double lat = point.getLat();
+                    double lon = point.getLon();
+                    double currentOrientation = Helper.ANGLE_CALC.calcOrientation(prevLat, prevLon, lat, lon, false);
+
+                    double diff = Math.abs(prevInstructionPrevOrientation - currentOrientation);
+                    if (diff > (Math.PI * .9) && diff < (Math.PI * 1.1)) {
+                        isUTurn = true;
+                        if (sign < 0) {
+                            uTurnType = Instruction.U_TURN_LEFT;
+                        } else {
+                            uTurnType = Instruction.U_TURN_RIGHT;
+                        }
+                    }
+
+                }
+
+                if (isUTurn) {
+                    prevInstruction.setSign(uTurnType);
+                    prevInstruction.setName(name);
+                } else {
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                    // Remember the Orientation and name of the road, before doing this maneuver
+                    prevInstructionPrevOrientation = prevOrientation;
+                    prevInstructionName = prevName;
+                    ways.add(prevInstruction);
+                    prevAnnotation = annotation;
+                }
             }
             // Updated the prevName, since we don't always create an instruction on name changes the previous
             // name can be an old name. This leads to incorrect turn instructions due to name changes
@@ -236,7 +293,11 @@ public void finish() {
             ((RoundaboutInstruction) prevInstruction).setRadian(delta);
 
         }
-        ways.add(new FinishInstruction(nodeAccess, prevEdge.getAdjNode()));
+
+        Instruction finishInstruction = new FinishInstruction(nodeAccess, prevEdge.getAdjNode());
+        // This is the heading how the edge ended
+        finishInstruction.setExtraInfo("last_heading", Helper.ANGLE_CALC.calcAzimuth(doublePrevLat, doublePrevLon, prevLat, prevLon));
+        ways.add(finishInstruction);
     }
 
     private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjNode, InstructionAnnotation annotation, String name) {
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
index daebfb9543..b395f6025f 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
@@ -39,9 +39,6 @@ static int calculateSign(double prevLatitude, double prevLongitude, double latit
         double delta = calculateOrientationDelta(prevLatitude, prevLongitude, latitude, longitude, prevOrientation);
         double absDelta = Math.abs(delta);
 
-        // TODO not only calculate the mathematical orientation, but also compare to other streets
-        // TODO If there is one street turning slight right and one right, but no straight street
-        // TODO We can assume the slight right street would be a continue
         if (absDelta < 0.2) {
             // 0.2 ~= 11°
             return Instruction.CONTINUE_ON_STREET;
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index 996b464a39..f4898ea1ae 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -35,6 +35,7 @@
 import java.util.*;
 import java.util.concurrent.*;
 
+import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.CH.DISABLE;
 
 /**
@@ -227,7 +228,7 @@ public CHAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList)
 
         weightingsAsStrings.clear();
         for (String strWeighting : weightingList) {
-            strWeighting = strWeighting.toLowerCase();
+            strWeighting = toLowerCase(strWeighting);
             strWeighting = strWeighting.trim();
             addWeighting(strWeighting);
         }
@@ -282,7 +283,7 @@ public void prepare(final StorableProperties properties) {
         ExecutorCompletionService completionService = new ExecutorCompletionService<>(threadPool);
         int counter = 0;
         for (final PrepareContractionHierarchies prepare : getPreparations()) {
-            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling CH prepare.doWork for " + prepare.getWeighting() + " ... (" + Helper.getMemInfo() + ")");
+            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling CH prepare.doWork for " + prepare.getWeighting() + " ... (" + getMemInfo() + ")");
             final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting());
             completionService.submit(new Runnable() {
                 @Override
@@ -290,7 +291,7 @@ public void run() {
                     // toString is not taken into account so we need to cheat, see http://stackoverflow.com/q/6113746/194609 for other options
                     Thread.currentThread().setName(name);
                     prepare.doWork();
-                    properties.put(CH.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
+                    properties.put(CH.PREPARE + "date." + name, createFormatter().format(new Date()));
                 }
             }, name);
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
new file mode 100644
index 0000000000..d10cefbf83
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
@@ -0,0 +1,442 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+class NodeContractor {
+    private final GraphHopperStorage ghStorage;
+    private final CHGraph prepareGraph;
+    private final PreparationWeighting prepareWeighting;
+    // todo: so far node contraction can only be done for node-based graph traversal
+    private final TraversalMode traversalMode;
+    private final DataAccess originalEdges;
+    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
+    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
+    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
+    private CHEdgeExplorer vehicleInExplorer;
+    private CHEdgeExplorer vehicleOutExplorer;
+    private IgnoreNodeFilter ignoreNodeFilter;
+    private DijkstraOneToMany prepareAlgo;
+    private int addedShortcutsCount;
+    private long dijkstraCount;
+    private int maxVisitedNodes = Integer.MAX_VALUE;
+    private StopWatch dijkstraSW = new StopWatch();
+    private int maxEdgesCount;
+    private int maxLevel;
+
+    NodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting,
+                   TraversalMode traversalMode) {
+        if (traversalMode.isEdgeBased()) {
+            throw new IllegalArgumentException("Contraction Hierarchies only support node based traversal so far, given: " + traversalMode);
+        }
+        // todo: it would be nice to check if ghStorage is frozen here
+        this.ghStorage = ghStorage;
+        this.prepareGraph = prepareGraph;
+        this.prepareWeighting = new PreparationWeighting(weighting);
+        this.traversalMode = traversalMode;
+        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
+        originalEdges.create(1000);
+    }
+
+    void initFromGraph() {
+        // todo: do we really need this method ? the problem is that ghStorage/prepareGraph can potentially be modified
+        // between the constructor call and contractNode,calcShortcutCount etc. ...
+        maxLevel = prepareGraph.getNodes() + 1;
+        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
+    }
+
+    void close() {
+        prepareAlgo.close();
+        originalEdges.close();
+    }
+
+    void setMaxVisitedNodes(int maxVisitedNodes) {
+        this.maxVisitedNodes = maxVisitedNodes;
+    }
+
+    long contractNode(int node) {
+        shortcuts.clear();
+        long degree = findShortcuts(addScHandler.setNode(node));
+        addedShortcutsCount += addShortcuts(shortcuts.keySet());
+        return degree;
+    }
+
+    CalcShortcutsResult calcShortcutCount(int node) {
+        findShortcuts(calcScHandler.setNode(node));
+        return calcScHandler.calcShortcutsResult;
+    }
+
+    /**
+     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
+     * changed by this method.
+     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that 
+     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     */
+    private long findShortcuts(ShortcutHandler sch) {
+        long degree = 0;
+        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
+        // collect outgoing nodes (goal-nodes) only once
+        while (incomingEdges.next()) {
+            int fromNode = incomingEdges.getAdjNode();
+            // accept only uncontracted nodes
+            if (prepareGraph.getLevel(fromNode) != maxLevel)
+                continue;
+
+            final double incomingEdgeDistance = incomingEdges.getDistance();
+            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            int incomingEdge = incomingEdges.getEdge();
+            int incomingEdgeOrigCount = getOrigEdgeCount(incomingEdge);
+            // collect outgoing nodes (goal-nodes) only once
+            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
+            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
+            prepareAlgo.clear();
+            degree++;
+            while (outgoingEdges.next()) {
+                int toNode = outgoingEdges.getAdjNode();
+                // add only uncontracted nodes
+                if (prepareGraph.getLevel(toNode) != maxLevel || fromNode == toNode)
+                    continue;
+
+                // Limit weight as ferries or forbidden edges can increase local search too much.
+                // If we decrease the correct weight we only explore less and introduce more shortcuts.
+                // I.e. no change to accuracy is made.
+                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
+                if (Double.isNaN(existingDirectWeight))
+                    throw new IllegalStateException("Weighting should never return NaN values"
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
+                            + ", dist:" + outgoingEdges.getDistance());
+
+                if (Double.isInfinite(existingDirectWeight))
+                    continue;
+
+                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
+                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
+
+                dijkstraSW.start();
+                dijkstraCount++;
+                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
+                dijkstraSW.stop();
+
+                // compare end node as the limit could force dijkstra to finish earlier
+                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
+                    // FOUND witness path, so do not add shortcut
+                    continue;
+
+                sch.foundShortcut(fromNode, toNode,
+                        existingDirectWeight, existingDistSum,
+                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
+                        incomingEdge, incomingEdgeOrigCount);
+            }
+        }
+        return degree;
+    }
+
+    /**
+     * Adds the given shortcuts to the graph.
+     *
+     * @return the actual number of shortcuts that were added to the graph
+     */
+    private int addShortcuts(Collection<Shortcut> shortcuts) {
+        int tmpNewShortcuts = 0;
+        NEXT_SC:
+        for (Shortcut sc : shortcuts) {
+            boolean updatedInGraph = false;
+            // check if we need to update some existing shortcut in the graph
+            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
+            while (iter.next()) {
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
+                    int status = iter.getMergeStatus(sc.flags);
+                    if (status == 0)
+                        continue;
+
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
+                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
+                        // see testShortcutMergeBug
+                        if (status == 2)
+                            break;
+
+                        continue NEXT_SC;
+                    }
+
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
+                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
+                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
+                                + ", sc:" + sc
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", neighbors:" + GHUtility.getNeighbors(iter));
+                    }
+
+                    // note: flags overwrite weight => call first
+                    iter.setFlags(sc.flags);
+                    iter.setWeight(sc.weight);
+                    iter.setDistance(sc.dist);
+                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
+                    updatedInGraph = true;
+                    break;
+                }
+            }
+
+            if (!updatedInGraph) {
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                // note: flags overwrite weight => call first
+                edgeState.setFlags(sc.flags);
+                edgeState.setWeight(sc.weight);
+                edgeState.setDistance(sc.dist);
+                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
+                tmpNewShortcuts++;
+            }
+        }
+        return tmpNewShortcuts;
+    }
+
+    private String getCoords(EdgeIteratorState edge, Graph graph) {
+        NodeAccess na = graph.getNodeAccess();
+        int base = edge.getBaseNode();
+        int adj = edge.getAdjNode();
+        return base + "->" + adj + " (" + edge.getEdge() + "); "
+                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
+    }
+
+    int getAddedShortcutsCount() {
+        return addedShortcutsCount;
+    }
+
+    private void setOrigEdgeCount(int edgeId, int value) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0) {
+            // ignore setting as every normal edge has original edge count of 1
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
+                        prepareGraph.getAllEdges().getMaxId());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        originalEdges.setInt(tmp, value);
+    }
+
+    private int getOrigEdgeCount(int edgeId) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        return originalEdges.getInt(tmp);
+    }
+
+    String getPrepareAlgoMemoryUsage() {
+        return prepareAlgo.getMemoryUsageAsString();
+    }
+
+    long getDijkstraCount() {
+        return dijkstraCount;
+    }
+
+    void resetDijkstraTime() {
+        dijkstraSW = new StopWatch();
+    }
+
+    float getDijkstraSeconds() {
+        return dijkstraSW.getSeconds();
+    }
+
+    static class IgnoreNodeFilter implements EdgeFilter {
+        int avoidNode;
+        int maxLevel;
+        CHGraph graph;
+
+        IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
+            this.graph = chGraph;
+            this.maxLevel = maxLevel;
+        }
+
+        IgnoreNodeFilter setAvoidNode(int node) {
+            this.avoidNode = node;
+            return this;
+        }
+
+        @Override
+        public final boolean accept(EdgeIteratorState iter) {
+            // ignore if it is skipNode or adjNode is already contracted
+            int node = iter.getAdjNode();
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
+        }
+    }
+
+    static class Shortcut {
+        int from;
+        int to;
+        int skippedEdge1;
+        int skippedEdge2;
+        double dist;
+        double weight;
+        int originalEdges;
+        long flags = PrepareEncoder.getScFwdDir();
+
+        public Shortcut(int from, int to, double weight, double dist) {
+            this.from = from;
+            this.to = to;
+            this.weight = weight;
+            this.dist = dist;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 5;
+            hash = 23 * hash + from;
+            hash = 23 * hash + to;
+            return 23 * hash
+                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == null || getClass() != obj.getClass())
+                return false;
+
+            final Shortcut other = (Shortcut) obj;
+            return this.from == other.from && this.to == other.to &&
+                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
+
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            if (flags == PrepareEncoder.getScDirMask())
+                str = from + "<->";
+            else
+                str = from + "->";
+
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+        }
+    }
+
+    interface ShortcutHandler {
+        void foundShortcut(int fromNode, int toNode,
+                           double existingDirectWeight, double distance,
+                           int outgoingEdge, int outgoingEdgeOrigCount,
+                           int incomingEdge, int incomingEdgeOrigCount);
+
+        int getNode();
+    }
+
+    class CalcShortcutHandler implements ShortcutHandler {
+        int node;
+        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public CalcShortcutHandler setNode(int node) {
+            this.node = node;
+            calcShortcutsResult.originalEdgesCount = 0;
+            calcShortcutsResult.shortcutsCount = 0;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double distance,
+                                  int outgoingEdge, int outgoingEdgeOrigCount,
+                                  int incomingEdge, int incomingEdgeOrigCount) {
+            calcShortcutsResult.shortcutsCount++;
+            calcShortcutsResult.originalEdgesCount += incomingEdgeOrigCount + outgoingEdgeOrigCount;
+        }
+    }
+
+    class AddShortcutHandler implements ShortcutHandler {
+        int node;
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public AddShortcutHandler setNode(int node) {
+            shortcuts.clear();
+            this.node = node;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double existingDistSum,
+                                  int outgoingEdge, int outgoingEdgeOrigCount,
+                                  int incomingEdge, int incomingEdgeOrigCount) {
+            // FOUND shortcut
+            // but be sure that it is the only shortcut in the collection
+            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
+            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
+            // know yet the levels so we need to determine the correct direction or if both directions
+            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
+            if (shortcuts.containsKey(sc))
+                return;
+
+            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            // overwrite flags only if skipped edges are identical
+            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
+                tmpRetSc.flags = PrepareEncoder.getScDirMask();
+                return;
+            }
+
+            Shortcut old = shortcuts.put(sc, sc);
+            if (old != null)
+                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+
+            sc.skippedEdge1 = incomingEdge;
+            sc.skippedEdge2 = outgoingEdge;
+            sc.originalEdges = incomingEdgeOrigCount + outgoingEdgeOrigCount;
+        }
+    }
+
+    static class CalcShortcutsResult {
+        int originalEdgesCount;
+        int shortcutsCount;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 2701f7c3bd..1afc3a550f 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -20,7 +20,6 @@
 import com.graphhopper.coll.GHTreeMapComposed;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.AbstractWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
@@ -36,7 +35,7 @@
  * This class prepares the graph for a bidirectional algorithm supporting contraction hierarchies
  * ie. an algorithm returned by createAlgo.
  * <p>
- * There are several description of contraction hierarchies available. The following is one of the
+ * There are several descriptions of contraction hierarchies available. The following is one of the
  * more detailed: http://web.cs.du.edu/~sturtevant/papers/highlevelpathfinding.pdf
  * <p>
  * The only difference is that we use two skipped edges instead of one skipped node for faster
@@ -47,19 +46,15 @@
  */
 public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory {
     private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Directory dir;
     private final PreparationWeighting prepareWeighting;
+    private final Weighting weighting;
     private final TraversalMode traversalMode;
-    private final LevelEdgeFilter levelFilter;
     private final GraphHopperStorage ghStorage;
     private final CHGraphImpl prepareGraph;
-    private final DataAccess originalEdges;
-    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private final Random rand = new Random(123);
     private final StopWatch allSW = new StopWatch();
-    AddShortcutHandler addScHandler = new AddShortcutHandler();
-    CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
-    private CHEdgeExplorer vehicleInExplorer;
-    private CHEdgeExplorer vehicleOutExplorer;
+    private NodeContractor nodeContractor;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
     private CHEdgeExplorer calcPrioAllExplorer;
@@ -67,13 +62,7 @@
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
-    private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany prepareAlgo;
-    private long counter;
-    private int newShortcuts;
-    private long dijkstraCount;
     private double meanDegree;
-    private StopWatch dijkstraSW = new StopWatch();
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
     private int neighborUpdatePercentage = 20;
@@ -83,18 +72,15 @@
     private double periodTime;
     private double lazyTime;
     private double neighborTime;
-    private int maxEdgesCount;
 
     public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
                                          Weighting weighting, TraversalMode traversalMode) {
+        this.dir = dir;
         this.ghStorage = ghStorage;
         this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
-        levelFilter = new LevelEdgeFilter(prepareGraph);
-
+        this.weighting = weighting;
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
-        originalEdges.create(1000);
     }
 
     /**
@@ -171,9 +157,6 @@ public PrepareContractionHierarchies setContractedNodes(double nodesContracted)
 
     @Override
     public void doWork() {
-        if (prepareWeighting == null)
-            throw new IllegalStateException("No weight calculation set.");
-
         allSW.start();
         super.doWork();
 
@@ -184,7 +167,57 @@ public void doWork() {
         contractNodes();
     }
 
-    boolean prepareNodes() {
+    @Override
+    public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
+        AbstractBidirAlgo algo;
+        if (ASTAR_BI.equals(opts.getAlgorithm())) {
+            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
+            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
+            algo = tmpAlgo;
+        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
+            if (opts.getHints().getBool("stall_on_demand", true)) {
+                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+            } else {
+                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+            }
+        } else {
+            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
+        }
+
+        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
+        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
+        return algo;
+    }
+
+    private void initFromGraph() {
+        ghStorage.freeze();
+        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
+            @Override
+            public final boolean accept(EdgeIteratorState edgeState) {
+                return super.accept(edgeState) && allFilter.accept(edgeState);
+            }
+        };
+
+        maxLevel = prepareGraph.getNodes() + 1;
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
+        // Use an alternative to PriorityQueue as it has some advantages:
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used.
+        //      Important because Graph is increasing until the end.
+        //   2. is slightly faster
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
+        sortedNodes = new GHTreeMapComposed();
+        oldPriorities = new int[prepareGraph.getNodes()];
+        nodeContractor = new NodeContractor(dir, ghStorage, prepareGraph, weighting, traversalMode);
+        nodeContractor.initFromGraph();
+    }
+
+    private boolean prepareNodes() {
         int nodes = prepareGraph.getNodes();
         for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
@@ -195,16 +228,19 @@ boolean prepareNodes() {
             sortedNodes.insert(node, priority);
         }
 
-        if (sortedNodes.isEmpty())
-            return false;
-
-        return true;
+        return !sortedNodes.isEmpty();
     }
 
-    void contractNodes() {
+    private void contractNodes() {
+        // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
+        // each edge can exist in both directions
+        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
+        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
+        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
+        // graph contraction parameters, because it affects the node contraction order.
         meanDegree = prepareGraph.getAllEdges().getMaxId() / prepareGraph.getNodes();
         int level = 1;
-        counter = 0;
+        long counter = 0;
         int initSize = sortedNodes.getSize();
         long logSize = Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
         if (logMessagesPercentage == 0)
@@ -256,21 +292,21 @@ void contractNodes() {
             }
 
             if (counter % logSize == 0) {
-                dijkstraTime += dijkstraSW.getSeconds();
+                dijkstraTime += nodeContractor.getDijkstraSeconds();
                 periodTime += periodSW.getSeconds();
                 lazyTime += lazySW.getSeconds();
                 neighborTime += neighborSW.getSeconds();
 
                 logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
-                        + ", shortcuts:" + Helper.nf(newShortcuts)
-                        + ", dijkstras:" + Helper.nf(dijkstraCount)
+                        + ", shortcuts:" + Helper.nf(nodeContractor.getAddedShortcutsCount())
+                        + ", dijkstras:" + Helper.nf(nodeContractor.getDijkstraCount())
                         + ", " + getTimesAsString()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
+                        + ", algo:" + nodeContractor.getPrepareAlgoMemoryUsage()
                         + ", " + Helper.getMemInfo());
 
-                dijkstraSW = new StopWatch();
+                nodeContractor.resetDijkstraTime();
                 periodSW = new StopWatch();
                 lazySW = new StopWatch();
                 neighborSW = new StopWatch();
@@ -292,9 +328,10 @@ void contractNodes() {
             }
 
             // contract node v!
-            shortcuts.clear();
-            findShortcuts(addScHandler.setNode(polledNode));
-            newShortcuts += addShortcuts(shortcuts.keySet());
+            nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
+            long degree = nodeContractor.contractNode(polledNode);
+            // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
+            meanDegree = (meanDegree * 2 + degree) / 3;
             prepareGraph.setLevel(polledNode, level);
             level++;
 
@@ -305,7 +342,7 @@ void contractNodes() {
             CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next()) {
 
-                if(Thread.currentThread().isInterrupted()){
+                if (Thread.currentThread().isInterrupted()) {
                     throw new RuntimeException("Thread was interrupted");
                 }
 
@@ -331,14 +368,14 @@ void contractNodes() {
         // The preparation object itself has to be intact to create the algorithm.
         close();
 
-        dijkstraTime += dijkstraSW.getSeconds();
+        dijkstraTime += nodeContractor.getDijkstraSeconds();
         periodTime += periodSW.getSeconds();
         lazyTime += lazySW.getSeconds();
         neighborTime += neighborSW.getSeconds();
         logger.info("took:" + (int) allSW.stop().getSeconds()
-                + ", new shortcuts: " + Helper.nf(newShortcuts)
+                + ", new shortcuts: " + Helper.nf(nodeContractor.getAddedShortcutsCount())
                 + ", " + prepareWeighting
-                + ", dijkstras:" + dijkstraCount
+                + ", dijkstras:" + nodeContractor.getDijkstraCount()
                 + ", " + getTimesAsString()
                 + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + initSize
@@ -348,8 +385,18 @@ void contractNodes() {
                 + ", " + Helper.getMemInfo());
     }
 
+    public void close() {
+        nodeContractor.close();
+        sortedNodes = null;
+        oldPriorities = null;
+    }
+
     public long getDijkstraCount() {
-        return dijkstraCount;
+        return nodeContractor.getDijkstraCount();
+    }
+
+    public int getShortcuts() {
+        return nodeContractor.getAddedShortcutsCount();
     }
 
     public double getLazyTime() {
@@ -372,13 +419,6 @@ public Weighting getWeighting() {
         return prepareGraph.getWeighting();
     }
 
-    public void close() {
-        prepareAlgo.close();
-        originalEdges.close();
-        sortedNodes = null;
-        oldPriorities = null;
-    }
-
     private String getTimesAsString() {
         return "t(dijk):" + Helper.round2(dijkstraTime)
                 + ", t(period):" + Helper.round2(periodTime)
@@ -386,32 +426,23 @@ private String getTimesAsString() {
                 + ", t(neighbor):" + Helper.round2(neighborTime);
     }
 
-    Set<Shortcut> testFindShortcuts(int node) {
-        findShortcuts(addScHandler.setNode(node));
-        return shortcuts.keySet();
-    }
-
     /**
-     * Calculates the priority of adjNode v without changing the graph. Warning: the calculated
-     * priority must NOT depend on priority(v) and therefor findShortcuts should also not depend on
+     * Calculates the priority of a node v without changing the graph. Warning: the calculated
+     * priority must NOT depend on priority(v) and therefore findShortcuts should also not depend on
      * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
      * lead to a slowish or even endless loop.
      */
-    int calculatePriority(int v) {
-        // set of shortcuts that would be added if adjNode v would be contracted next.
-        findShortcuts(calcScHandler.setNode(v));
+    private int calculatePriority(int node) {
+        nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
+        NodeContractor.CalcShortcutsResult calcShortcutsResult = nodeContractor.calcShortcutCount(node);
 
-//        System.out.println(v + "\t " + tmpShortcuts);
         // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
         //
         // every adjNode has an 'original edge' number associated. initially it is r=1
         // when a new shortcut is introduced then r of the associated edges is summed up:
         // r(u,w)=r(u,v)+r(v,w) now we can define
         // originalEdgesCount = σ(v) := sum_{ (u,w) ∈ shortcuts(v) } of r(u, w)
-        int originalEdgesCount = calcScHandler.originalEdgesCount;
-//        for (Shortcut sc : tmpShortcuts) {
-//            originalEdgesCount += sc.originalEdges;
-//        }
+        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
 
         // # lowest influence on preparation speed or shortcut creation count
         // (but according to paper should speed up queries)
@@ -419,7 +450,7 @@ int calculatePriority(int v) {
         // number of already contracted neighbors of v
         int contractedNeighbors = 0;
         int degree = 0;
-        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(v);
+        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(node);
         while (iter.next()) {
             degree++;
             if (iter.isShortcut())
@@ -432,234 +463,17 @@ int calculatePriority(int v) {
         // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|
         // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
         // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
-        int edgeDifference = calcScHandler.shortcuts - degree;
+        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
 
         // according to the paper do a simple linear combination of the properties to get the priority.
         // this is the current optimum for unterfranken:
         return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
     }
 
-    /**
-     * Finds shortcuts, does not change the underlying graph.
-     */
-    void findShortcuts(ShortcutHandler sch) {
-        long tmpDegreeCounter = 0;
-        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
-        // collect outgoing nodes (goal-nodes) only once
-        while (incomingEdges.next()) {
-            int u_fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
-                continue;
-
-            double v_u_dist = incomingEdges.getDistance();
-            double v_u_weight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
-            int skippedEdge1 = incomingEdges.getEdge();
-            int incomingEdgeOrigCount = getOrigEdgeCount(skippedEdge1);
-            // collect outgoing nodes (goal-nodes) only once
-            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
-            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            prepareAlgo.clear();
-            tmpDegreeCounter++;
-            while (outgoingEdges.next()) {
-                int w_toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
-                    continue;
-
-                // Limit weight as ferries or forbidden edges can increase local search too much.
-                // If we decrease the correct weight we only explore less and introduce more shortcuts.
-                // I.e. no change to accuracy is made.
-                double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
-                if (Double.isNaN(existingDirectWeight))
-                    throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
-                            + ", dist:" + outgoingEdges.getDistance());
-
-                if (Double.isInfinite(existingDirectWeight))
-                    continue;
-
-                double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                prepareAlgo.setWeightLimit(existingDirectWeight);
-                prepareAlgo.setMaxVisitedNodes((int) meanDegree * 100);
-                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
-
-                dijkstraSW.start();
-                dijkstraCount++;
-                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
-                dijkstraSW.stop();
-
-                // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
-                    // FOUND witness path, so do not add shortcut
-                    continue;
-
-                sch.foundShortcut(u_fromNode, w_toNode,
-                        existingDirectWeight, existingDistSum,
-                        outgoingEdges,
-                        skippedEdge1, incomingEdgeOrigCount);
-            }
-        }
-        if (sch instanceof AddShortcutHandler) {
-            // sliding mean value when using "*2" => slower changes
-            meanDegree = (meanDegree * 2 + tmpDegreeCounter) / 3;
-            // meanDegree = (meanDegree + tmpDegreeCounter) / 2;
-        }
-    }
-
-    /**
-     * Introduces the necessary shortcuts for adjNode v in the graph.
-     */
-    int addShortcuts(Collection<Shortcut> tmpShortcuts) {
-        int tmpNewShortcuts = 0;
-        NEXT_SC:
-        for (Shortcut sc : tmpShortcuts) {
-            boolean updatedInGraph = false;
-            // check if we need to update some existing shortcut in the graph
-            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
-            while (iter.next()) {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
-                    int status = iter.getMergeStatus(sc.flags);
-                    if (status == 0)
-                        continue;
-
-                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
-                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
-                        // see testShortcutMergeBug
-                        if (status == 2)
-                            break;
-
-                        continue NEXT_SC;
-                    }
-
-                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
-                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
-                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
-                                + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
-                                + ", neighbors:" + GHUtility.getNeighbors(iter));
-                    }
-
-                    // note: flags overwrite weight => call first
-                    iter.setFlags(sc.flags);
-                    iter.setWeight(sc.weight);
-                    iter.setDistance(sc.dist);
-                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
-                    updatedInGraph = true;
-                    break;
-                }
-            }
-
-            if (!updatedInGraph) {
-                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
-                // note: flags overwrite weight => call first
-                edgeState.setFlags(sc.flags);
-                edgeState.setWeight(sc.weight);
-                edgeState.setDistance(sc.dist);
-                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
-                tmpNewShortcuts++;
-            }
-        }
-        return tmpNewShortcuts;
-    }
-
-    String getCoords(EdgeIteratorState e, Graph g) {
-        NodeAccess na = g.getNodeAccess();
-        int base = e.getBaseNode();
-        int adj = e.getAdjNode();
-        return base + "->" + adj + " (" + e.getEdge() + "); "
-                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
-    }
-
-    PrepareContractionHierarchies initFromGraph() {
-        ghStorage.freeze();
-        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
-        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
-        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
-
-        // filter by vehicle and level number
-        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
-            @Override
-            public final boolean accept(EdgeIteratorState edgeState) {
-                if (!super.accept(edgeState))
-                    return false;
-
-                return allFilter.accept(edgeState);
-            }
-        };
-
-        maxLevel = prepareGraph.getNodes() + 1;
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
-        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
-
-        // Use an alternative to PriorityQueue as it has some advantages:
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used.
-        //      Important because Graph is increasing until the end.
-        //   2. is slightly faster
-        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
-        sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[prepareGraph.getNodes()];
-        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
-        return this;
-    }
-
-    public int getShortcuts() {
-        return newShortcuts;
-    }
-
-    private void setOrigEdgeCount(int edgeId, int value) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0) {
-            // ignore setting as every normal edge has original edge count of 1
-            if (value != 1)
-                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
-                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" + ghStorage.getAllEdges().getMaxId());
-            return;
-        }
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        originalEdges.setInt(tmp, value);
-    }
-
-    private int getOrigEdgeCount(int edgeId) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0)
-            return 1;
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        return originalEdges.getInt(tmp);
-    }
-
-    @Override
-    public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
-        AbstractBidirAlgo algo;
-        if (ASTAR_BI.equals(opts.getAlgorithm())) {
-            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
-            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
-            algo = tmpAlgo;
-        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
-            if (opts.getHints().getBool("stall_on_demand", true)) {
-                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
-            } else {
-                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
-            }
-        } else {
-            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
-        }
-
-        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
-        algo.setEdgeFilter(levelFilter);
-        return algo;
+    private int getMaxVisitedNodesEstimate() {
+        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
+        // the node contraction order and requires re-optimizing the parameters of the graph contraction
+        return (int) meanDegree * 100;
     }
 
     @Override
@@ -667,163 +481,4 @@ public String toString() {
         return "prepare|dijkstrabi|ch";
     }
 
-    interface ShortcutHandler {
-        void foundShortcut(int u_fromNode, int w_toNode,
-                           double existingDirectWeight, double distance,
-                           EdgeIterator outgoingEdges,
-                           int skippedEdge1, int incomingEdgeOrigCount);
-
-        int getNode();
-    }
-
-    static class IgnoreNodeFilter implements EdgeFilter {
-        int avoidNode;
-        int maxLevel;
-        CHGraph graph;
-
-        public IgnoreNodeFilter(CHGraph g, int maxLevel) {
-            this.graph = g;
-            this.maxLevel = maxLevel;
-        }
-
-        public IgnoreNodeFilter setAvoidNode(int node) {
-            this.avoidNode = node;
-            return this;
-        }
-
-        @Override
-        public final boolean accept(EdgeIteratorState iter) {
-            // ignore if it is skipNode or adjNode is already contracted
-            int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == maxLevel;
-        }
-    }
-
-    static class Shortcut {
-        int from;
-        int to;
-        int skippedEdge1;
-        int skippedEdge2;
-        double dist;
-        double weight;
-        int originalEdges;
-        long flags = PrepareEncoder.getScFwdDir();
-
-        public Shortcut(int from, int to, double weight, double dist) {
-            this.from = from;
-            this.to = to;
-            this.weight = weight;
-            this.dist = dist;
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 5;
-            hash = 23 * hash + from;
-            hash = 23 * hash + to;
-            return 23 * hash
-                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || getClass() != obj.getClass())
-                return false;
-
-            final Shortcut other = (Shortcut) obj;
-            if (this.from != other.from || this.to != other.to)
-                return false;
-
-            return Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
-        }
-
-        @Override
-        public String toString() {
-            String str;
-            if (flags == PrepareEncoder.getScDirMask())
-                str = from + "<->";
-            else
-                str = from + "->";
-
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
-        }
-    }
-
-    class CalcShortcutHandler implements ShortcutHandler {
-        int node;
-        int originalEdgesCount;
-        int shortcuts;
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public CalcShortcutHandler setNode(int n) {
-            node = n;
-            originalEdgesCount = 0;
-            shortcuts = 0;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int u_fromNode, int w_toNode,
-                                  double existingDirectWeight, double distance,
-                                  EdgeIterator outgoingEdges,
-                                  int skippedEdge1, int incomingEdgeOrigCount) {
-            shortcuts++;
-            originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
-
-    class AddShortcutHandler implements ShortcutHandler {
-        int node;
-
-        public AddShortcutHandler() {
-        }
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public AddShortcutHandler setNode(int n) {
-            shortcuts.clear();
-            node = n;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int u_fromNode, int w_toNode,
-                                  double existingDirectWeight, double existingDistSum,
-                                  EdgeIterator outgoingEdges,
-                                  int skippedEdge1, int incomingEdgeOrigCount) {
-            // FOUND shortcut
-            // but be sure that it is the only shortcut in the collection
-            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
-            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
-            // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
-            if (shortcuts.containsKey(sc))
-                return;
-
-            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
-            Shortcut tmpRetSc = shortcuts.get(tmpSc);
-            if (tmpRetSc != null) {
-                // overwrite flags only if skipped edges are identical
-                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge()) {
-                    tmpRetSc.flags = PrepareEncoder.getScDirMask();
-                    return;
-                }
-            }
-
-            Shortcut old = shortcuts.put(sc, sc);
-            if (old != null)
-                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
-
-            sc.skippedEdge1 = skippedEdge1;
-            sc.skippedEdge2 = outgoingEdges.getEdge();
-            sc.originalEdges = incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
index 6ac4991120..785b95ff76 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
@@ -44,6 +44,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * This class implements the A*, landmark and triangulation (ALT) decorator.
  *
@@ -148,7 +150,7 @@ public LMAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList)
 
         weightingsAsStrings.clear();
         for (String strWeighting : weightingList) {
-            strWeighting = strWeighting.toLowerCase();
+            strWeighting = toLowerCase(strWeighting);
             strWeighting = strWeighting.trim();
             addWeighting(strWeighting);
         }
@@ -282,11 +284,11 @@ public void run() {
                     if (plm.loadExisting())
                         return;
 
-                    LOGGER.info(tmpCounter + "/" + getPreparations().size() + " calling LM prepare.doWork for " + plm.getWeighting() + " ... (" + Helper.getMemInfo() + ")");
+                    LOGGER.info(tmpCounter + "/" + getPreparations().size() + " calling LM prepare.doWork for " + plm.getWeighting() + " ... (" + getMemInfo() + ")");
                     prepared.set(true);
                     Thread.currentThread().setName(name);
                     plm.doWork();
-                    properties.put(Landmark.PREPARE + "date." + name, Helper.createFormatter().format(new Date()));
+                    properties.put(Landmark.PREPARE + "date." + name, createFormatter().format(new Date()));
                 }
             }, name);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 458527582d..42ee449894 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -453,10 +453,10 @@ protected double getFerrySpeed(ReaderWay way) {
         }
         // seconds to hours
         double durationInHours = duration / 60d / 60d;
+        // Check if our graphhopper specific artificially created estimated_distance way tag is present
+        Number estimatedLength = way.getTag("estimated_distance", null);
         if (durationInHours > 0)
             try {
-                // Check if our graphhopper specific artificially created estimated_distance way tag is present
-                Number estimatedLength = way.getTag("estimated_distance", null);
                 if (estimatedLength != null) {
                     double estimatedLengthInKm = estimatedLength.doubleValue() / 1000;
                     // If duration AND distance is available we can calculate the speed more precisely
@@ -487,6 +487,8 @@ protected double getFerrySpeed(ReaderWay way) {
             }
 
         if (durationInHours == 0) {
+            if(estimatedLength != null && estimatedLength.doubleValue() <= 300)
+                return speedEncoder.factor / 2;
             // unknown speed -> put penalty on ferry transport
             return UNKNOWN_DURATION_FERRY_SPEED;
         } else if (durationInHours > 1) {
@@ -674,8 +676,8 @@ public double getDouble(long flags, int key) {
     }
 
     /**
-     * @param way:   needed to retrieve tags
-     * @param speed: speed guessed e.g. from the road type or other tags
+     * @param way   needed to retrieve tags
+     * @param speed speed guessed e.g. from the road type or other tags
      * @return The assumed speed.
      */
     protected double applyMaxSpeed(ReaderWay way, double speed) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 54c4cf5a5e..54a6dcd1cf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -325,8 +325,8 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
      * just only 90%.
      * <p>
      *
-     * @param way:   needed to retrieve tags
-     * @param speed: speed guessed e.g. from the road type or other tags
+     * @param way   needed to retrieve tags
+     * @param speed speed guessed e.g. from the road type or other tags
      * @return The assumed average speed.
      */
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 21e905b3bf..1a9d691d5b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -335,8 +335,8 @@ public String getWayInfo(ReaderWay way) {
     }
 
     /**
-     * @param way:   needed to retrieve tags
-     * @param speed: speed guessed e.g. from the road type or other tags
+     * @param way   needed to retrieve tags
+     * @param speed speed guessed e.g. from the road type or other tags
      * @return The assumed speed
      */
     protected double applyBadSurfaceSpeed(ReaderWay way, double speed) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index a3b24989dd..b8ac216e8a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -29,6 +29,8 @@
 import java.util.*;
 import java.util.Map.Entry;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * This encoder tries to store all way information into a 32 or 64bit value. Later extendable to
  * multiple ints or bytes. The assumption is that edge.getFlags is cheap and can be later replaced
@@ -426,7 +428,7 @@ private SpatialRule getSpatialRule(ReaderWay way) {
 
     private long extractMeter(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
         String value = way.getFirstPriorityTag(keys);
-        if (Helper.isEmpty(value)) return flags;
+        if (isEmpty(value)) return flags;
 
         double val;
         try {
@@ -447,7 +449,7 @@ private long extractMeter(ReaderWay way, long flags, EncodedDoubleValue valueEnc
 
     private long extractTons(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
         String value = way.getFirstPriorityTag(keys);
-        if (Helper.isEmpty(value)) return flags;
+        if (isEmpty(value)) return flags;
 
         double val;
         try {
@@ -467,7 +469,7 @@ private long extractTons(ReaderWay way, long flags, EncodedDoubleValue valueEnco
     }
 
     public static double stringToTons(String value) {
-        value = value.toLowerCase().replaceAll(" ", "").replaceAll("(tons|ton)", "t");
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
         value = value.replace("mgw", "").trim();
         double factor = 1;
         if (value.endsWith("t")) {
@@ -481,7 +483,7 @@ public static double stringToTons(String value) {
     }
 
     public static double stringToMeter(String value) {
-        value = value.toLowerCase().replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
         double factor = 1;
         double offset = 0;
         value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 682eb585c4..5dc6fbdccb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -30,6 +30,9 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
+
+import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
@@ -108,14 +111,14 @@ public EncodingManager(List<? extends FlagEncoder> flagEncoders, int bytesForEdg
         if (encoderList.contains(":"))
             throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
 
-        if (!encoderList.equals(encoderList.toLowerCase()))
+        if (!encoderList.equals(toLowerCase(encoderList)))
             throw new IllegalArgumentException("Since 0.7 EncodingManager does no longer accept upper case profiles: " + encoderList);
 
         String[] entries = encoderList.split(",");
         List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
         for (String entry : entries) {
-            entry = entry.trim().toLowerCase();
+            entry = toLowerCase(entry.trim());
             if (entry.isEmpty())
                 continue;
 
@@ -186,26 +189,26 @@ private void registerEncoder(AbstractFlagEncoder encoder) {
         int encoderCount = edgeEncoders.size();
         int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "node"));
+            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
+            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
         if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForEdgeFlags, "relation"));
+            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
         // turn flag bits are independent from edge encoder bits
         usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
         if (usedBits > bitsForTurnFlags)
-            throw new IllegalArgumentException(String.format(ERR, usedBits, bitsForTurnFlags, "turn"));
+            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForTurnFlags, "turn"));
         nextTurnBit = usedBits;
 
         edgeEncoders.add(encoder);
diff --git a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
index 314af30c60..10950e8f20 100644
--- a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/HintsMap.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.util.PMap;
 
+import static com.graphhopper.util.Helper.toLowerCase;
+
 /**
  * @author Peter Karich
  */
@@ -53,7 +55,7 @@ public HintsMap put(String key, Object str) {
     }
 
     public String getWeighting() {
-        return super.get("weighting", "").toLowerCase();
+        return toLowerCase(super.get("weighting", ""));
     }
 
     public HintsMap setWeighting(String w) {
@@ -63,7 +65,7 @@ public HintsMap setWeighting(String w) {
     }
 
     public String getVehicle() {
-        return super.get("vehicle", "").toLowerCase();
+        return toLowerCase(super.get("vehicle", ""));
     }
 
     public HintsMap setVehicle(String v) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
index 94a5132a06..530cdbffba 100644
--- a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
@@ -17,13 +17,16 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.apache.commons.lang3.StringUtils;
 import com.graphhopper.debatty.java.stringsimilarity.JaroWinkler;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.apache.commons.lang3.StringUtils;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.regex.Pattern;
 
+import static com.graphhopper.util.Helper.toLowerCase;
+
 /**
  * This class defines the basis for NameSimilarity matching using an EdgeFilter.
  * The typical use-case is to match not the nearest edge in
@@ -67,7 +70,7 @@ private String prepareName(String name) {
         String tmp;
         List<String> list = new ArrayList<>(arr.length);
         for (int i = 0; i < arr.length; i++) {
-            tmp = NON_WORD_CHAR.matcher(arr[i].toLowerCase()).replaceAll("");
+            tmp = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
             // Ignore matching short frases like, de, rue, st, etc.
             if (!tmp.isEmpty() && tmp.length() > 3) {
                 list.add(tmp);
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index e54ad8532b..693ca6a71d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -22,6 +22,8 @@
 
 import java.util.Arrays;
 
+import static com.graphhopper.util.Helper.toUpperCase;
+
 /**
  * Defines how the graph can be traversed while Dijkstra or similar RoutingAlgorithm is in progress.
  * Different options define how precise turn restrictions and costs are taken into account, but
@@ -70,7 +72,7 @@
 
     public static TraversalMode fromString(String name) {
         try {
-            return valueOf(name.toUpperCase());
+            return valueOf(toUpperCase(name));
         } catch (Exception ex) {
             throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
                     + "Supported are: " + Arrays.asList(TraversalMode.values()));
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
index 70564e59d3..43f227689a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
@@ -7,7 +7,11 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static com.graphhopper.util.Helper.toLowerCase;
 
 public class SpatialRuleLookupBuilder {
 
@@ -39,7 +43,7 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
 
         for (int jsonFeatureIdx = 0; jsonFeatureIdx < jsonFeatureCollection.getFeatures().size(); jsonFeatureIdx++) {
             JsonFeature jsonFeature = jsonFeatureCollection.getFeatures().get(jsonFeatureIdx);
-            String id = jsonIdField.isEmpty() || jsonIdField.toLowerCase().equals("id") ? jsonFeature.getId() : (String) jsonFeature.getProperty(jsonIdField);
+            String id = jsonIdField.isEmpty() || toLowerCase(jsonIdField).equals("id") ? jsonFeature.getId() : (String) jsonFeature.getProperty(jsonIdField);
             if (id == null || id.isEmpty())
                 throw new IllegalArgumentException("ID cannot be empty but was for JsonFeature " + jsonFeatureIdx);
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index e5572cf992..3f043952a3 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -21,6 +21,8 @@
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.EdgeIteratorState;
 
+import static com.graphhopper.util.Helper.toLowerCase;
+
 /**
  * @author Peter Karich
  */
@@ -91,7 +93,7 @@ static final boolean isValidName(String name) {
      * Replaces all characters which are not numbers, characters or underscores with underscores
      */
     public static String weightingToFileName(Weighting w) {
-        return w.toString().toLowerCase().replaceAll("\\|", "_");
+        return toLowerCase(w.toString()).replaceAll("\\|", "_");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index 7da8bd52bb..c78735f943 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -599,18 +599,25 @@ public int getMaxId() {
 
         @Override
         public final void setSkippedEdges(int edge1, int edge2) {
-            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE1, edge1);
-            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+            checkShortcut(true, "setSkippedEdges");
+            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
+                throw new IllegalStateException("Skipped edges of a shortcut needs "
+                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
+            }
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
         }
 
         @Override
         public final int getSkippedEdge1() {
-            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE1);
+            checkShortcut(true, "getSkippedEdge1");
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE1);
         }
 
         @Override
         public final int getSkippedEdge2() {
-            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE2);
+            checkShortcut(true, "getSkippedEdge2");
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
         @Override
@@ -634,5 +641,13 @@ public final double getWeight() {
         public int getMergeStatus(long flags) {
             return PrepareEncoder.getScMergeStatus(getDirectFlags(), flags);
         }
+
+        void checkShortcut(boolean shouldBeShortcut, String methodName) {
+            if (isShortcut()) {
+                if (!shouldBeShortcut)
+                    throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
+            } else if (shouldBeShortcut)
+                throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index ec672e7996..30266d601a 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.storage;
 
+import static com.graphhopper.util.Helper.toUpperCase;
+
 /**
  * Defines how a DataAccess object is created.
  * <p>
@@ -72,7 +74,7 @@ public DAType(MemRef memRef, boolean storing, boolean integ, boolean allowWrites
     }
 
     public static DAType fromString(String dataAccess) {
-        dataAccess = dataAccess.toUpperCase();
+        dataAccess = toUpperCase(dataAccess);
         DAType type;
         if (dataAccess.contains("SYNC"))
             throw new IllegalArgumentException("SYNC option is no longer supported, see #982");
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 953985ad91..8d39ace8d2 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -25,6 +25,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * Implements some common methods for the subclasses.
  * <p>
@@ -40,7 +42,7 @@
 
     public GHDirectory(String _location, DAType defaultType) {
         this.defaultType = defaultType;
-        if (Helper.isEmpty(_location))
+        if (isEmpty(_location))
             _location = new File("").getAbsolutePath();
 
         if (!_location.endsWith("/"))
@@ -72,7 +74,7 @@ public ByteOrder getByteOrder() {
     }
 
     public Directory put(String name, DAType type) {
-        if (!name.equals(name.toLowerCase()))
+        if (!name.equals(toLowerCase(name)))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
         types.put(name, type);
@@ -90,7 +92,7 @@ public DataAccess find(String name) {
 
     @Override
     public DataAccess find(String name, DAType type) {
-        if (!name.equals(name.toLowerCase()))
+        if (!name.equals(toLowerCase(name)))
             throw new IllegalArgumentException("Since 0.7 DataAccess objects does no longer accept upper case names");
 
         DataAccess da = map.get(name);
@@ -135,7 +137,7 @@ public void clear() {
             removeDA(da, da.getName(), false);
         }
         if (mmapDA != null)
-            Helper.cleanHack();
+            cleanHack();
         map.clear();
     }
 
@@ -152,7 +154,7 @@ void removeDA(DataAccess da, String name, boolean forceClean) {
             da.close();
 
         if (da.getType().isStoring())
-            Helper.removeDir(new File(location + name));
+            removeDir(new File(location + name));
     }
 
     void removeFromMap(String name) {
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 71597910a1..1b088e17bb 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -26,6 +26,8 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * Writes an in-memory HashMap into a file on flush. Thread safe, see #743.
  *
@@ -50,7 +52,7 @@ public synchronized boolean loadExisting() {
         byte[] bytes = new byte[len];
         da.getBytes(0, bytes, len);
         try {
-            Helper.loadProperties(map, new StringReader(new String(bytes, Helper.UTF_CS)));
+            loadProperties(map, new StringReader(new String(bytes, UTF_CS)));
             return true;
         } catch (IOException ex) {
             throw new IllegalStateException(ex);
@@ -61,9 +63,9 @@ public synchronized boolean loadExisting() {
     public synchronized void flush() {
         try {
             StringWriter sw = new StringWriter();
-            Helper.saveProperties(map, sw);
+            saveProperties(map, sw);
             // TODO at the moment the size is limited to da.segmentSize() !
-            byte[] bytes = sw.toString().getBytes(Helper.UTF_CS);
+            byte[] bytes = sw.toString().getBytes(UTF_CS);
             da.setBytes(0, bytes, bytes.length);
             da.flush();
         } catch (IOException ex) {
@@ -90,7 +92,7 @@ public synchronized StorableProperties put(String key, String val) {
      * Before it saves this value it creates a string out of it.
      */
     public synchronized StorableProperties put(String key, Object val) {
-        if (!key.equals(key.toLowerCase()))
+        if (!key.equals(toLowerCase(key)))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
         map.put(key, val.toString());
@@ -98,7 +100,7 @@ public synchronized StorableProperties put(String key, Object val) {
     }
 
     public synchronized String get(String key) {
-        if (!key.equals(key.toLowerCase()))
+        if (!key.equals(toLowerCase(key)))
             throw new IllegalArgumentException("Do not use upper case keys (" + key + ") for StorableProperties since 0.7");
 
         String ret = map.get(key);
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index b780f0ee74..b2c42fee57 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -115,7 +115,7 @@ public double calcAzimuth(double lat1, double lon1, double lat2, double lon2) {
         if (orientation < 0)
             orientation += 2 * Math.PI;
 
-        return Math.toDegrees(Helper.round4(orientation))%360;
+        return Math.toDegrees(Helper.round4(orientation)) % 360;
     }
 
     String azimuth2compassPoint(double azimuth) {
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index ebf9ee70d7..b25ef1acc9 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -26,6 +26,8 @@
 import java.util.Map.Entry;
 import java.util.Properties;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
  * <p>
@@ -54,8 +56,8 @@ public static CmdArgs readFromConfig(String fileStr, String systemProperty) thro
             configLocation = fileStr;
 
         Map<String, String> map = new LinkedHashMap<String, String>();
-        Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
-                new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
+        loadProperties(map, new InputStreamReader(new FileInputStream(
+                new File(configLocation).getAbsoluteFile()), UTF_CS));
         CmdArgs args = new CmdArgs();
         args.merge(map);
 
@@ -93,9 +95,9 @@ public static CmdArgs read(String[] args) {
             }
 
             String value = arg.substring(index + 1);
-            String old = map.put(key.toLowerCase(), value);
+            String old = map.put(toLowerCase(key), value);
             if (old != null)
-                throw new IllegalArgumentException("Pair '" + key.toLowerCase() + "'='" + value + "' not possible to " +
+                throw new IllegalArgumentException("Pair '" + toLowerCase(key) + "'='" + value + "' not possible to " +
                         "add to the CmdArgs-object as the key already exists with '" + old + "'");
         }
 
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index b300b1c3e8..942b90db61 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.StringTokenizer;
 
-import static com.graphhopper.util.Helper.readFile;
+import static com.graphhopper.util.Helper.*;
 
 /**
  * Defining several important constants for GraphHopper. Partially taken from Lucene.
@@ -94,7 +94,7 @@
         try {
             // see com/graphhopper/version file in resources which is modified in the maven packaging process
             // to contain the current version
-            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), Helper.UTF_CS));
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("version"), UTF_CS));
             version = v.get(0);
         } catch (Exception ex) {
             System.err.println("GraphHopper Initialization ERROR: cannot read version!? " + ex.getMessage());
@@ -114,12 +114,12 @@
             if (indexM >= 0)
                 tmp = version.substring(0, indexM);
 
-            SNAPSHOT = version.toLowerCase().contains("-snapshot");
+            SNAPSHOT = toLowerCase(version).contains("-snapshot");
             VERSION = tmp;
         }
         String buildDate = "";
         try {
-            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), Helper.UTF_CS));
+            List<String> v = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("builddate"), UTF_CS));
             buildDate = v.get(0);
         } catch (Exception ex) {
         }
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index 5f1f3777f2..888524bbc7 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -47,6 +47,11 @@ public FinishInstruction(PointAccess pointAccess, int node) {
                 pointAccess.is3D() ? pointAccess.getElevation(node) : Double.NaN);
     }
 
+    @Override
+    public int getLength() {
+        return 0;
+    }
+
     @Override
     public String getTurnDescription(Translation tr) {
         if (rawName)
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 901576ec1e..58f6637b4e 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -88,6 +88,14 @@ public static Locale getLocale(String param) {
         return new Locale(param.substring(0, index), param.substring(index + 1));
     }
 
+    public static String toLowerCase(String string){
+        return string.toLowerCase(Locale.ROOT);
+    }
+
+    public static String toUpperCase(String string){
+        return string.toUpperCase(Locale.ROOT);
+    }
+
     static String packageToPath(Package pkg) {
         return pkg.getName().replaceAll("\\.", File.separator);
     }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 992d74ca3b..085cb88ba9 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,12 +17,14 @@
  */
 package com.graphhopper.util;
 
-import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class Instruction {
     public static final int UNKNOWN = -99;
+    public static final int U_TURN_UNKNOWN = -98;
+    public static final int U_TURN_LEFT = -8;
     public static final int KEEP_LEFT = -7;
     public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
@@ -37,6 +39,7 @@
     public static final int USE_ROUNDABOUT = 6;
     public static final int IGNORE = Integer.MIN_VALUE;
     public static final int KEEP_RIGHT = 7;
+    public static final int U_TURN_RIGHT = 8;
     public static final int PT_START_TRIP = 101;
     public static final int PT_TRANSFER = 102;
     public static final int PT_END_TRIP = 103;
@@ -48,6 +51,7 @@
     protected String name;
     protected double distance;
     protected long time;
+    protected Map<String, Object> extraInfo = new HashMap<>(3);
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
@@ -79,6 +83,10 @@ public int getSign() {
         return sign;
     }
 
+    public void setSign(int sign) {
+        this.sign = sign;
+    }
+
     public String getName() {
         return name;
     }
@@ -88,11 +96,11 @@ public void setName(String name) {
     }
 
     public Map<String, Object> getExtraInfoJSON() {
-        return Collections.<String, Object>emptyMap();
+        return extraInfo;
     }
 
     public void setExtraInfo(String key, Object value) {
-        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+        extraInfo.put(key, value);
     }
 
     /**
@@ -238,6 +246,20 @@ void checkOne() {
             throw new IllegalStateException("Instruction must contain at least one point " + toString());
     }
 
+    /**
+     * This method returns the length of an Instruction. The length of an instruction is defined by [the
+     * index of the first point of the next instruction] - [the index of the first point of this instruction].
+     * <p>
+     * In general this will just resolve to the size of the PointList, except for {@link ViaInstruction} and
+     * {@link FinishInstruction}, which are only virtual instructions, in a sense that they don't provide
+     * a turn instruction, but only an info ("reached via point or destination").
+     * <p>
+     * See #1216 and #1138
+     */
+    public int getLength() {
+        return points.getSize();
+    }
+
     public String getTurnDescription(Translation tr) {
         if (rawName)
             return getName();
@@ -256,6 +278,15 @@ public String getTurnDescription(Translation tr) {
         } else {
             String dir = null;
             switch (indi) {
+                case Instruction.U_TURN_UNKNOWN:
+                    dir = tr.tr("u_turn");
+                    break;
+                case Instruction.U_TURN_LEFT:
+                    dir = tr.tr("u_turn");
+                    break;
+                case Instruction.U_TURN_RIGHT:
+                    dir = tr.tr("u_turn");
+                    break;
                 case Instruction.KEEP_LEFT:
                     dir = tr.tr("keep_left");
                     break;
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index cd7ab45dc7..91dd0febaf 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -80,7 +80,8 @@ public void replaceLast(Instruction instr) {
         instructions.set(instructions.size() - 1, instr);
     }
 
-    @JsonValue public List<Map<String, Object>> createJson() {
+    @JsonValue
+    public List<Map<String, Object>> createJson() {
         List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
         int pointsIndex = 0;
         int counter = 0;
@@ -104,11 +105,7 @@ public void replaceLast(Instruction instr) {
             instrJson.put("sign", instruction.getSign());
             instrJson.putAll(instruction.getExtraInfoJSON());
 
-            int tmpIndex = pointsIndex + instruction.getPoints().size();
-            // the last instruction should not point to the next instruction
-            if (counter + 1 == instructions.size())
-                tmpIndex--;
-
+            int tmpIndex = pointsIndex + instruction.getLength();
             instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
             pointsIndex = tmpIndex;
 
@@ -120,7 +117,6 @@ public void replaceLast(Instruction instr) {
     /**
      * @return This method returns a list of gpx entries where the time (in millis) is relative to
      * the first which is 0.
-     * <p>
      */
     public List<GPXEntry> createGPXList() {
         if (isEmpty())
@@ -178,11 +174,10 @@ private void createWayPointBlock(StringBuilder output, Instruction instruction,
     public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
         DateFormat formatter = Helper.createFormatter();
 
-        DecimalFormat decimalFormat = new DecimalFormat("#");
+        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
         decimalFormat.setMinimumFractionDigits(1);
         decimalFormat.setMaximumFractionDigits(6);
         decimalFormat.setMinimumIntegerDigits(1);
-        decimalFormat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.US));
 
         String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
                 + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 6712382627..34a04c3810 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -21,6 +21,8 @@
 import org.slf4j.LoggerFactory;
 
 import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.Locale;
 
 /**
  * @author Peter Karich
@@ -92,7 +94,7 @@ public String getReport() {
     }
 
     public String nf(Number num) {
-        return new DecimalFormat("#.###").format(num);
+        return new DecimalFormat("#.###", DecimalFormatSymbols.getInstance(Locale.ROOT)).format(num);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 0f90371240..4395e0d395 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -48,6 +48,7 @@
     private boolean calcPoints = true;
     private PathDetailsBuilderFactory pathBuilderFactory;
     private List<String> requestedPathDetails = Collections.EMPTY_LIST;
+    private double favoredHeading = Double.NaN;
 
     public PathMerger setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
@@ -87,6 +88,10 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         List<String> description = new ArrayList<>();
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
             Path path = paths.get(pathIndex);
+            if (!path.isFound()) {
+                allFound = false;
+                continue;
+            }
             description.addAll(path.getDescription());
             fullTimeInMillis += path.getTime();
             fullDistance += path.getDistance();
@@ -111,9 +116,14 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 if (fullPoints.isEmpty())
                     fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
+                // Remove duplicated points, see #1138
+                if (pathIndex + 1 < paths.size()) {
+                    tmpPoints.removeLastPoint();
+                }
+
                 fullPoints.add(tmpPoints);
                 altRsp.addPathDetails(path.calcDetails(requestedPathDetails, pathBuilderFactory, origPoints));
-                origPoints += tmpPoints.size();
+                origPoints = fullPoints.size();
             }
 
             allFound = allFound && path.isFound();
@@ -126,8 +136,10 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 calcAscendDescend(altRsp, fullPoints);
         }
 
-        if (enableInstructions)
+        if (enableInstructions) {
+            fullInstructions = updateInstructionsWithContext(fullInstructions);
             altRsp.setInstructions(fullInstructions);
+        }
 
         if (!allFound) {
             altRsp.addError(new ConnectionNotFoundException("Connection between locations not found", Collections.<String, Object>emptyMap()));
@@ -164,6 +176,51 @@ public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDet
         pathDetails.addAll(otherDetails);
     }
 
+    /**
+     * This method iterates over all instructions and uses the available context to improve the instructions.
+     * If the requests contains a heading, this method can transform the first continue to a u-turn if the heading
+     * points into the opposite direction of the route.
+     * At a waypoint it can transform the continue to a u-turn if the route involves turning.
+     */
+    private InstructionList updateInstructionsWithContext(InstructionList instructions) {
+        Instruction instruction;
+        Instruction nextInstruction;
+
+        for (int i = 0; i < instructions.size() - 1; i++) {
+            instruction = instructions.get(i);
+
+            if (i == 0 && !Double.isNaN(favoredHeading) && instruction.extraInfo.containsKey("heading")) {
+                double heading = (double) instruction.extraInfo.get("heading");
+                double diff = Math.abs(heading - favoredHeading) % 360;
+                if (diff > 170 && diff < 190) {
+                    // The requested heading points into the opposite direction of the calculated heading
+                    // therefore we change the continue instruction to a u-turn
+                    instruction.setSign(Instruction.U_TURN_UNKNOWN);
+                }
+            }
+
+            if (instruction.getSign() == Instruction.REACHED_VIA) {
+                nextInstruction = instructions.get(i + 1);
+                if (nextInstruction.getSign() != Instruction.CONTINUE_ON_STREET
+                        || !instruction.extraInfo.containsKey("last_heading")
+                        || !nextInstruction.extraInfo.containsKey("heading")) {
+                    // TODO throw exception?
+                    continue;
+                }
+                double lastHeading = (double) instruction.extraInfo.get("last_heading");
+                double heading = (double) nextInstruction.extraInfo.get("heading");
+
+                // Since it's supposed to go back the same edge, we can be very strict with the diff
+                double diff = Math.abs(lastHeading - heading) % 360;
+                if (diff > 179 && diff < 181) {
+                    nextInstruction.setSign(Instruction.U_TURN_UNKNOWN);
+                }
+            }
+        }
+
+        return instructions;
+    }
+
     private void calcAscendDescend(final PathWrapper rsp, final PointList pointList) {
         double ascendMeters = 0;
         double descendMeters = 0;
@@ -183,4 +240,8 @@ private void calcAscendDescend(final PathWrapper rsp, final PointList pointList)
         rsp.setAscend(ascendMeters);
         rsp.setDescend(descendMeters);
     }
+
+    public void setFavoredHeading(double favoredHeading) {
+        this.favoredHeading = favoredHeading;
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/util/PathSimplification.java b/core/src/main/java/com/graphhopper/util/PathSimplification.java
index 40aebf84b6..dc1ea86eee 100644
--- a/core/src/main/java/com/graphhopper/util/PathSimplification.java
+++ b/core/src/main/java/com/graphhopper/util/PathSimplification.java
@@ -49,7 +49,8 @@ public PathSimplification(PathWrapper pathWrapper, DouglasPeucker douglasPeucker
         this.pathDetails = pathWrapper.getPathDetails();
         for (String name : pathDetails.keySet()) {
             List<PathDetail> pathDetailList = pathDetails.get(name);
-            if (pathDetailList.isEmpty())
+            // If the pointList only contains one point, PathDetails have to be empty because 1 point => 0 edges
+            if (pathDetailList.isEmpty() && pointList.size() > 1)
                 throw new IllegalStateException("PathDetails " + name + " must not be empty");
 
             listsToSimplify.add(pathDetailList);
@@ -58,7 +59,7 @@ public PathSimplification(PathWrapper pathWrapper, DouglasPeucker douglasPeucker
     }
 
     public PointList simplify() {
-        if (listsToSimplify.isEmpty() || pointList.isEmpty())
+        if (listsToSimplify.isEmpty() || pointList.size() <= 2)
             return pointList;
 
         // The offset of already included points
@@ -146,12 +147,7 @@ public PointList simplify() {
 
     private int getLength(Object o, int index) {
         if (o instanceof InstructionList) {
-            // we do not store the last point of an instruction
-            int size = ((InstructionList) o).get(index).getPoints().size();
-            if (size == 0)
-                throw new IllegalStateException("PointList of instruction should not be empty " + o);
-            // the last point of instruction (i.e. first point of next instruction) is not included
-            return size;
+            return ((InstructionList) o).get(index).getLength();
         }
         if (o instanceof List) {
             return ((List<PathDetail>) o).get(index).getLength();
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index e00b77fb94..cece58286e 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -44,6 +44,11 @@ public void add(double lat, double lon, double ele) {
             throw new RuntimeException("cannot change EMPTY PointList");
         }
 
+        @Override
+        public void removeLastPoint() {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
         @Override
         public double getLatitude(int index) {
             throw new RuntimeException("cannot access EMPTY PointList");
@@ -64,6 +69,11 @@ public void clear() {
             throw new RuntimeException("cannot change EMPTY PointList");
         }
 
+        @Override
+        public void setElevation(int index, double ele) {
+            throw new RuntimeException("cannot change EMPTY PointList");
+        }
+
         @Override
         public void trimToSize(int newSize) {
             throw new RuntimeException("cannot change EMPTY PointList");
@@ -260,6 +270,12 @@ public void add(PointList points) {
         size = newSize;
     }
 
+    public void removeLastPoint() {
+        if (size == 0)
+            throw new IllegalStateException("Cannot remove last point from empty PointList");
+        size--;
+    }
+
     public int size() {
         return size;
     }
@@ -308,6 +324,14 @@ public double getElevation(int index) {
         return elevations[index];
     }
 
+    public void setElevation(int index, double ele) {
+        if (index >= size)
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
+        if (!is3D)
+            throw new IllegalStateException("This is a 2D PointList, you cannot set it's elevation");
+        this.elevations[index] = ele;
+    }
+
     @Override
     public double getEle(int index) {
         return getElevation(index);
diff --git a/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java b/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
index 4f5b2f02cd..7523843d50 100644
--- a/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
+++ b/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
@@ -80,6 +80,11 @@ public double getElevation(int index) {
         return wrappedPointList.getElevation(fromOffset + index);
     }
 
+    @Override
+    public void setElevation(int index, double ele) {
+        wrappedPointList.setElevation(fromOffset + index, ele);
+    }
+
     public void makeImmutable() {
         this.wrappedPointList.makeImmutable();
     }
@@ -138,6 +143,11 @@ public void add(PointList points) {
         throw new UnsupportedOperationException(IMMUTABLE_ERR);
     }
 
+    @Override
+    public void removeLastPoint() {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
     @Override
     public void reverse() {
         throw new UnsupportedOperationException(IMMUTABLE_ERR);
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 7695d3fb9c..3a890f7bb4 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -21,6 +21,8 @@
 import java.util.*;
 import java.util.Map.Entry;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * A class which manages the translations in-memory. See here for more information:
  * ./docs/core/translations.md
@@ -38,7 +40,7 @@
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     public static int countOccurence(String phrase, String splitter) {
-        if (Helper.isEmpty(phrase))
+        if (isEmpty(phrase))
             return 0;
         return phrase.trim().split(splitter).length;
     }
@@ -49,7 +51,7 @@ public static int countOccurence(String phrase, String splitter) {
     public TranslationMap doImport(File folder) {
         try {
             for (String locale : LOCALES) {
-                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
+                TranslationHashMap trMap = new TranslationHashMap(getLocale(locale));
                 trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
                 add(trMap);
             }
@@ -66,7 +68,7 @@ public TranslationMap doImport(File folder) {
     public TranslationMap doImport() {
         try {
             for (String locale : LOCALES) {
-                TranslationHashMap trMap = new TranslationHashMap(Helper.getLocale(locale));
+                TranslationHashMap trMap = new TranslationHashMap(getLocale(locale));
                 trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
                 add(trMap);
             }
@@ -129,7 +131,7 @@ private void postImportHook() {
             Map<String, String> trMap = tr.asMap();
             for (Entry<String, String> enEntry : enMap.entrySet()) {
                 String value = trMap.get(enEntry.getKey());
-                if (Helper.isEmpty(value)) {
+                if (isEmpty(value)) {
                     trMap.put(enEntry.getKey(), enEntry.getValue());
                     continue;
                 }
@@ -144,7 +146,7 @@ private void postImportHook() {
                     Object[] strs = new String[expectedCount];
                     Arrays.fill(strs, "tmp");
                     try {
-                        String.format(value, strs);
+                        String.format(Locale.ROOT, value, strs);
                     } catch (Exception ex) {
                         sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
                                 append(enEntry.getKey()).append("->").
@@ -189,15 +191,15 @@ public String getLanguage() {
 
         @Override
         public String tr(String key, Object... params) {
-            String val = map.get(key.toLowerCase());
-            if (Helper.isEmpty(val))
+            String val = map.get(toLowerCase(key));
+            if (isEmpty(val))
                 return key;
 
-            return String.format(val, params);
+            return String.format(Locale.ROOT, val, params);
         }
 
         public TranslationHashMap put(String key, String val) {
-            String existing = map.put(key.toLowerCase(), val);
+            String existing = map.put(toLowerCase(key), val);
             if (existing != null)
                 throw new IllegalStateException("Cannot overwrite key " + key + " with " + val + ", was: " + existing);
             return this;
@@ -217,7 +219,7 @@ public TranslationHashMap doImport(InputStream is) {
             if (is == null)
                 throw new IllegalStateException("No input stream found in class path!?");
             try {
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS))) {
+                for (String line : readFile(new InputStreamReader(is, UTF_CS))) {
                     if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
                         continue;
 
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index c2c45104dc..cf35a22237 100644
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -31,6 +31,12 @@ public ViaInstruction(Instruction instr) {
         this(instr.getName(), instr.getAnnotation(), instr.getPoints());
         setDistance(instr.getDistance());
         setTime(instr.getTime());
+        this.extraInfo = instr.extraInfo;
+    }
+
+    @Override
+    public int getLength() {
+        return 0;
     }
 
     public int getViaCount() {
diff --git a/core/src/main/resources/com/graphhopper/util/ast.txt b/core/src/main/resources/com/graphhopper/util/ast.txt
index bd8bb0ee77..22526b0c8f 100644
--- a/core/src/main/resources/com/graphhopper/util/ast.txt
+++ b/core/src/main/resources/com/graphhopper/util/ast.txt
@@ -8,11 +8,11 @@ turn_slight_left=xira llixeramente a la izquierda
 turn_slight_right=xira llixeramente a la drecha
 turn_sharp_left=xira fuerte a la izquierda
 turn_sharp_right=xira fuerte a la drecha
-keep_left=
-keep_right=
+keep_left=sigui pela izquierda
+keep_right=sigui pela derecha
 turn_onto=%1$s per %2$s
-u_turn=
-unknown=
+u_turn=da vuelta atrás
+unknown=signu indicador desconocíu '%1$s'
 web.search_button=Buscar
 web.from_hint=Dende
 web.via_hint=Pasando per
@@ -20,8 +20,8 @@ web.to_hint=Fasta
 web.more_button=más
 web.gpx_export_button=Esportar GPX
 web.route_info=%1$s tardaràs %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=llegada a les %1$s con %2$s tresbordos (%3$s)
+web.pt_route_info_walking=llegada a les %1$s sólo caminando (%2$s)
 web.locations_not_found=Nun se puede trazar una ruta. Dalgún llugar nun s'alcuentra nel área
 web.bike=Bicicleta
 web.racingbike=Bici de carreres
@@ -56,10 +56,10 @@ roundabout_exit=Na rotonda, toma la salida %1$s
 roundabout_exit_onto=Na rotonda, toma la salida %1$s haza %2$s
 total_ascend=%1$s d'ascensu total
 total_descend=%1$s de descensu total
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=hai un vau nel camín
+pt_start_trip=xubi a  %1$s
+pt_end_trip=baxa de  %1$s
+pt_transfer_to=cambia a  %1$s
 web.start_label=Principiu
 web.intermediate_label=Intermediu
 web.end_label=Final
@@ -76,4 +76,4 @@ web.refresh_button=Refrescar la páxina
 web.server_status=Estáu
 web.zoom_in=Averar
 web.zoom_out=Alloñar
-web.drag_to_reorder=
+web.drag_to_reorder=Abasnar pa cambiar l'orde
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
index d39bc7647d..bfa55fc271 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -18,7 +18,9 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.util.Downloader;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -33,6 +35,7 @@
  * @author Peter Karich
  */
 public class CGIARProviderTest {
+    private double precision = .1;
     CGIARProvider instance;
 
     @Before
@@ -40,6 +43,11 @@ public void setUp() {
         instance = new CGIARProvider();
     }
 
+    @After
+    public void tearDown() {
+        instance.release();
+    }
+
     @Test
     public void testDown() {
         assertEquals(50, instance.down(52.5));
@@ -103,4 +111,45 @@ public void downloadFile(String url, String toFile) throws IOException {
         file.delete();
         zipFile.delete();
     }
+
+    @Ignore
+    public void testGetEle() {
+        assertEquals(337, instance.getEle(49.949784, 11.57517), precision);
+        assertEquals(466, instance.getEle(49.968668, 11.575127), precision);
+        assertEquals(455, instance.getEle(49.968682, 11.574842), precision);
+        assertEquals(3134, instance.getEle(-22.532854, -65.110474), precision);
+        assertEquals(120, instance.getEle(38.065392, -87.099609), precision);
+        assertEquals(1615, instance.getEle(40, -105.2277023), precision);
+        assertEquals(1615, instance.getEle(39.99999999, -105.2277023), precision);
+        assertEquals(1615, instance.getEle(39.9999999, -105.2277023), precision);
+        assertEquals(1616, instance.getEle(39.999999, -105.2277023), precision);
+        assertEquals(986, instance.getEle(47.468668, 14.575127), precision);
+        assertEquals(1091, instance.getEle(47.467753, 14.573911), precision);
+        assertEquals(1951, instance.getEle(46.468835, 12.578777), precision);
+        assertEquals(841, instance.getEle(48.469123, 9.576393), precision);
+        assertEquals(Double.NaN, instance.getEle(56.4787319, 17.6118363), precision);
+        // Outside of SRTM covered area
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 19), precision);
+        assertEquals(0, instance.getEle(60.251, 18.805), precision);
+    }
+
+    @Ignore
+    public void testGetEleVerticalBorder() {
+        // Border between the tiles srtm_39_04 and srtm_39_03
+        assertEquals("srtm_39_04", instance.getFileName(44.999999, 11.5));
+        assertEquals(5, instance.getEle(44.999999, 11.5), precision);
+        assertEquals("srtm_39_03", instance.getFileName(45.000001, 11.5));
+        assertEquals(6, instance.getEle(45.000001, 11.5), precision);
+    }
+
+    @Ignore
+    public void testGetEleHorizontalBorder() {
+        // Border between the tiles N42E011 and N42E012
+        assertEquals("srtm_38_04", instance.getFileName(44.94, 9.999999));
+        assertEquals(48, instance.getEle(44.94, 9.999999), precision);
+        assertEquals("srtm_39_04", instance.getFileName(44.94, 10.000001));
+        assertEquals(48, instance.getEle(44.94, 10.000001), precision);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java
new file mode 100644
index 0000000000..99ca59d90c
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/GMTEDProviderTest.java
@@ -0,0 +1,174 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Downloader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Robin Boldt
+ */
+public class GMTEDProviderTest {
+    private double precision = .1;
+    GMTEDProvider instance;
+
+    @Before
+    public void setUp() {
+        instance = new GMTEDProvider();
+    }
+
+    @After
+    public void tearDown() {
+        instance.release();
+    }
+
+    @Test
+    public void testMinLat() {
+        assertEquals(50, instance.getMinLatForTile(52.5));
+        assertEquals(10, instance.getMinLatForTile(29.9));
+        assertEquals(-70, instance.getMinLatForTile(-59.9));
+    }
+
+    @Test
+    public void testMinLon() {
+        assertEquals(-60, instance.getMinLonForTile(-59.9));
+        assertEquals(0, instance.getMinLonForTile(0.9));
+    }
+
+    @Test
+    public void testGetDownloadUrl() {
+        // Created a couple of random tests and compared to https://topotools.cr.usgs.gov/gmted_viewer/viewer.htm
+        assertTrue(instance.getDownloadURL(42.940339, 11.953125).contains("E000/30N000E_20101117_gmted_mea075.tif"));
+        assertTrue(instance.getDownloadURL(38.548165, -77.167969).contains("W090/30N090W_20101117_gmted_mea075.tif"));
+        assertTrue(instance.getDownloadURL(74.116047, -169.277344).contains("W180/70N180W_20101117_gmted_mea075.tif"));
+        assertTrue(instance.getDownloadURL(-61.015725, -156.621094).contains("W180/70S180W_20101117_gmted_mea075.tif"));
+        assertTrue(instance.getDownloadURL(74.590108, 166.640625).contains("E150/70N150E_20101117_gmted_mea075.tif"));
+        assertTrue(instance.getDownloadURL(-61.015725, 162.949219).contains("E150/70S150E_20101117_gmted_mea075.tif"));
+    }
+
+    @Test
+    public void testGetFileName() {
+        assertEquals("30n000e_20101117_gmted_mea075", instance.getFileName(42.940339, 11.953125));
+        assertEquals("30n090w_20101117_gmted_mea075", instance.getFileName(38.548165, -77.167969));
+        assertEquals("70n180w_20101117_gmted_mea075", instance.getFileName(74.116047, -169.277344));
+        assertEquals("70s180w_20101117_gmted_mea075", instance.getFileName(-61.015725, -156.621094));
+        assertEquals("70n150e_20101117_gmted_mea075", instance.getFileName(74.590108, 166.640625));
+        assertEquals("70s150e_20101117_gmted_mea075", instance.getFileName(-61.015725, 162.949219));
+    }
+
+    @Test
+    public void testFileNotFound() {
+        File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
+        File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".tif");
+        file.delete();
+        zipFile.delete();
+
+        instance.setDownloader(new Downloader("test GH") {
+            @Override
+            public void downloadFile(String url, String toFile) throws IOException {
+                throw new FileNotFoundException("xyz");
+            }
+        });
+        assertEquals(0, instance.getEle(46, -20), 1);
+
+        // file not found => small!
+        assertTrue(file.exists());
+        assertEquals(228, file.length());
+
+        instance.setDownloader(new Downloader("test GH") {
+            @Override
+            public void downloadFile(String url, String toFile) throws IOException {
+                throw new SocketTimeoutException("xyz");
+            }
+        });
+
+        try {
+            instance.setSleep(30);
+            instance.getEle(16, -20);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+
+        file.delete();
+        zipFile.delete();
+    }
+
+    /*
+    Enabling this test requires you to change the pom.xml and increase the memory limit for running tests.
+    Change to: <argLine>-Xmx500m -Xms500m</argLine>
+    This test will download about 2gb of data.
+     */
+    @Ignore
+    public void testGetEle() {
+        assertEquals(339, instance.getEle(49.949784, 11.57517), precision);
+        assertEquals(438, instance.getEle(49.968668, 11.575127), precision);
+        assertEquals(432, instance.getEle(49.968682, 11.574842), precision);
+        assertEquals(3169, instance.getEle(-22.532854, -65.110474), precision);
+        assertEquals(124, instance.getEle(38.065392, -87.099609), precision);
+        assertEquals(1615, instance.getEle(40, -105.2277023), precision);
+        assertEquals(1618, instance.getEle(39.99999999, -105.2277023), precision);
+        assertEquals(1618, instance.getEle(39.9999999, -105.2277023), precision);
+        assertEquals(1618, instance.getEle(39.999999, -105.2277023), precision);
+        assertEquals(1070, instance.getEle(47.468668, 14.575127), precision);
+        assertEquals(1115, instance.getEle(47.467753, 14.573911), precision);
+        assertEquals(1990, instance.getEle(46.468835, 12.578777), precision);
+        assertEquals(841, instance.getEle(48.469123, 9.576393), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        // Outside of SRTM covered area
+        assertEquals(108, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 19), precision);
+        // Stor Roten
+        assertEquals(14, instance.getEle(60.251, 18.805), precision);
+
+    }
+
+    @Ignore
+    public void testGetEleVerticalBorder() {
+        // Border between the tiles 50n000e and 70n000e
+        assertEquals("50n000e_20101117_gmted_mea075", instance.getFileName(69.999999, 19.493));
+        assertEquals(268, instance.getEle(69.999999, 19.5249), precision);
+        assertEquals("70n000e_20101117_gmted_mea075", instance.getFileName(70, 19.493));
+        assertEquals(298, instance.getEle(70, 19.5249), precision);
+        // Second location at the border
+        assertEquals("50n000e_20101117_gmted_mea075", instance.getFileName(69.999999, 19.236));
+        assertEquals(245, instance.getEle(69.999999, 19.236), precision);
+        assertEquals("70n000e_20101117_gmted_mea075", instance.getFileName(70, 19.236));
+        assertEquals(241, instance.getEle(70, 19.236), precision);
+    }
+
+    @Ignore
+    public void testGetEleHorizontalBorder() {
+        // Border between the tiles 50n000e and 50n030e
+        assertEquals("50n000e_20101117_gmted_mea075", instance.getFileName(53, 29.999999));
+        assertEquals(143, instance.getEle(53, 29.999999), precision);
+        assertEquals("50n030e_20101117_gmted_mea075", instance.getFileName(53, 30.000001));
+        assertEquals(142, instance.getEle(53, 30.000001), precision);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/GraphElevationSmoothingTest.java b/core/src/test/java/com/graphhopper/reader/dem/GraphElevationSmoothingTest.java
new file mode 100644
index 0000000000..89c718533e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/GraphElevationSmoothingTest.java
@@ -0,0 +1,56 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.PointList;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Robin Boldt
+ */
+public class GraphElevationSmoothingTest {
+
+    @Test
+    public void interpolatesElevationOfPillarNodes() {
+
+        PointList pl1 = new PointList(3, true);
+        pl1.add(0, 0, 0);
+        pl1.add(0.0005, 0.0005, 100);
+        pl1.add(0.001, 0.001, 50);
+        GraphElevationSmoothing.smoothElevation(pl1);
+        assertEquals(3, pl1.size());
+        assertEquals(50, pl1.getElevation(1), .1);
+
+        PointList pl2 = new PointList(3, true);
+        pl2.add(0.001, 0.001, 50);
+        pl2.add(0.0015, 0.0015, 160);
+        pl2.add(0.0016, 0.0015, 150);
+        pl2.add(0.0017, 0.0015, 220);
+        pl2.add(0.002, 0.002, 20);
+        GraphElevationSmoothing.smoothElevation(pl2);
+        assertEquals(5, pl2.size());
+        assertEquals(120, pl2.getElevation(1), .1);
+        // This is not 120 anymore, as the point at index 1 was smoothed from 160=>120
+        assertEquals(112, pl2.getElevation(2), .1);
+
+        assertEquals(50, pl2.getEle(0), .1);
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index 046ff8d5e8..8bc1d90b5b 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -32,17 +32,18 @@ public void testGetHeight() {
         // data access has same coordinate system as graphical or UI systems have (or the original DEM data has).
         // But HeightTile has lat,lon system ('mathematically')
         int width = 10;
-        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10);
+        int height = 20;
+        HeightTile instance = new HeightTile(0, 0, width, height, 1e-6, 10, 20);
         DataAccess heights = new RAMDirectory().find("tmp");
-        heights.create(2 * 10 * 10);
+        heights.create(2 * width * height);
         instance.setHeights(heights);
-        init(heights, width, 1);
+        init(heights, width, height, 1);
 
         // x,y=1,7
-        heights.setShort(2 * (7 * width + 1), (short) 70);
+        heights.setShort(2 * (17 * width + 1), (short) 70);
 
         // x,y=2,9
-        heights.setShort(2 * (9 * width + 2), (short) 90);
+        heights.setShort(2 * (19 * width + 2), (short) 90);
 
         assertEquals(1, instance.getHeight(5, 5), 1e-3);
         assertEquals(70, instance.getHeight(2.5, 1.5), 1e-3);
@@ -50,7 +51,7 @@ public void testGetHeight() {
         assertEquals(1, instance.getHeight(3, 2), 1e-3);
         assertEquals(70, instance.getHeight(2, 1), 1e-3);
 
-        // edge cases for the whole object        
+        // edge cases for the whole object
         assertEquals(1, instance.getHeight(+1.0, 2), 1e-3);
         assertEquals(90, instance.getHeight(0.5, 2.5), 1e-3);
         assertEquals(90, instance.getHeight(0.0, 2.5), 1e-3);
@@ -75,11 +76,11 @@ public void testGetHeight() {
     @Test
     public void testGetHeightForNegativeTile() {
         int width = 10;
-        HeightTile instance = new HeightTile(-20, -20, width, 1e-6, 10);
+        HeightTile instance = new HeightTile(-20, -20, width, width, 1e-6, 10, 10);
         DataAccess heights = new RAMDirectory().find("tmp");
         heights.create(2 * 10 * 10);
         instance.setHeights(heights);
-        init(heights, width, 1);
+        init(heights, width, width, 1);
 
         // x,y=1,7
         heights.setShort(2 * (7 * width + 1), (short) 70);
@@ -97,11 +98,11 @@ public void testGetHeightForNegativeTile() {
     @Test
     public void testCalcMean() {
         int width = 10;
-        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10).setCalcMean(true);
+        HeightTile instance = new HeightTile(0, 0, width, width, 1e-6, 10, 10).setCalcMean(true);
         DataAccess heights = new RAMDirectory().find("tmp");
         heights.create(2 * 10 * 10);
         instance.setHeights(heights);
-        init(heights, width, 1);
+        init(heights, width, width, 1);
 
         // x,y=0,9
         heights.setShort(2 * (9 * width + 0), (short) 10);
@@ -121,11 +122,11 @@ public void testCalcMean() {
         assertEquals((10 + 2) / 3d, instance.getHeight(-0.5, -0.5), 1e-3);
     }
 
-    private void init(DataAccess da, int width, int i) {
+    private void init(DataAccess da, int width, int height, int i) {
         for (int x = 0; x < width; x++) {
-            for (int y = 0; y < width; y++) {
+            for (int y = 0; y < height; y++) {
                 da.setShort(2 * (y * width + x), (short) 1);
             }
         }
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java
new file mode 100644
index 0000000000..3e67de36e2
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/MultiSourceElevationProviderTest.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Robin Boldt
+ */
+public class MultiSourceElevationProviderTest {
+    MultiSourceElevationProvider instance;
+
+    @After
+    public void tearDown() {
+        instance.release();
+    }
+
+    @Test
+    public void testGetEleMocked() {
+        instance = new MultiSourceElevationProvider(
+                new CGIARProvider() {
+                    @Override
+                    public double getEle(double lat, double lon) {
+                        return 1;
+                    }
+                },
+                new GMTEDProvider() {
+                    @Override
+                    public double getEle(double lat, double lon) {
+                        return 2;
+                    }
+                }
+        );
+
+        assertEquals(1, instance.getEle(0, 0), .1);
+        assertEquals(2, instance.getEle(60.0001, 0), .1);
+        assertEquals(2, instance.getEle(-56.0001, 0), .1);
+    }
+
+    /*
+    Enabling this test requires you to change the pom.xml and increase the memory limit for running tests.
+    Change to: <argLine>-Xmx500m -Xms500m</argLine>
+    */
+    @Ignore
+    public void testGetEle() {
+        instance = new MultiSourceElevationProvider();
+        double precision = .1;
+        // The first part is copied from the SRTMGL1ProviderTest
+        assertEquals(338, instance.getEle(49.949784, 11.57517), precision);
+        assertEquals(468, instance.getEle(49.968668, 11.575127), precision);
+        assertEquals(467, instance.getEle(49.968682, 11.574842), precision);
+        assertEquals(3110, instance.getEle(-22.532854, -65.110474), precision);
+        assertEquals(120, instance.getEle(38.065392, -87.099609), precision);
+        assertEquals(1617, instance.getEle(40, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.99999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.9999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.999999, -105.2277023), precision);
+        assertEquals(1015, instance.getEle(47.468668, 14.575127), precision);
+        assertEquals(1107, instance.getEle(47.467753, 14.573911), precision);
+        assertEquals(1930, instance.getEle(46.468835, 12.578777), precision);
+        assertEquals(844, instance.getEle(48.469123, 9.576393), precision);
+        // The file for this coordinate does not exist, but there is a ferry tagged in OSM
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        // The second part is copied from the GMTEDProviderTest
+        // Outside of SRTM covered area
+        assertEquals(108, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 19), precision);
+        // Stor Roten
+        assertEquals(14, instance.getEle(60.251, 18.805), precision);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMGL1ProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMGL1ProviderTest.java
new file mode 100644
index 0000000000..8510fb59d0
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMGL1ProviderTest.java
@@ -0,0 +1,121 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Robin Boldt
+ */
+public class SRTMGL1ProviderTest {
+    private double precision = .1;
+    SRTMGL1Provider instance;
+
+    @Before
+    public void setUp() {
+        instance = new SRTMGL1Provider();
+    }
+
+    @After
+    public void tearDown() {
+        instance.release();
+    }
+
+    @Test
+    public void testMinLat() {
+        assertEquals(52, instance.getMinLatForTile(52.5));
+        assertEquals(29, instance.getMinLatForTile(29.9));
+        assertEquals(-60, instance.getMinLatForTile(-59.9));
+    }
+
+    @Test
+    public void testMinLon() {
+        assertEquals(-60, instance.getMinLonForTile(-59.9));
+        assertEquals(0, instance.getMinLonForTile(0.9));
+    }
+
+    @Test
+    public void testGetDownloadUrl() {
+        // Created a couple of random tests and compared to https://topotools.cr.usgs.gov/gmted_viewer/viewer.htm
+        assertEquals("North/North_30_60/N42E011.hgt", instance.getDownloadURL(42.940339, 11.953125));
+        assertEquals("North/North_30_60/N38W078.hgt", instance.getDownloadURL(38.548165, -77.167969));
+        assertEquals("North/North_0_29/N14W005.hgt", instance.getDownloadURL(14.116047, -4.277344));
+        assertEquals("South/S52W058.hgt", instance.getDownloadURL(-51.015725, -57.621094));
+        assertEquals("North/North_0_29/N24E120.hgt", instance.getDownloadURL(24.590108, 120.640625));
+        assertEquals("South/S42W063.hgt", instance.getDownloadURL(-41.015725, -62.949219));
+    }
+
+    @Test
+    public void testGetFileName() {
+        assertEquals("n42e011", instance.getFileName(42.940339, 11.953125));
+        assertEquals("n38w078", instance.getFileName(38.548165, -77.167969));
+        assertEquals("n14w005", instance.getFileName(14.116047, -4.277344));
+        assertEquals("s52w058", instance.getFileName(-51.015725, -57.621094));
+        assertEquals("n24e120", instance.getFileName(24.590108, 120.640625));
+        assertEquals("s42w063", instance.getFileName(-41.015725, -62.949219));
+    }
+
+    @Ignore
+    public void testGetEle() {
+        assertEquals(338, instance.getEle(49.949784, 11.57517), precision);
+        assertEquals(468, instance.getEle(49.968668, 11.575127), precision);
+        assertEquals(467, instance.getEle(49.968682, 11.574842), precision);
+        assertEquals(3110, instance.getEle(-22.532854, -65.110474), precision);
+        assertEquals(120, instance.getEle(38.065392, -87.099609), precision);
+        assertEquals(1617, instance.getEle(40, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.99999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.9999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.999999, -105.2277023), precision);
+        assertEquals(1015, instance.getEle(47.468668, 14.575127), precision);
+        assertEquals(1107, instance.getEle(47.467753, 14.573911), precision);
+        assertEquals(1930, instance.getEle(46.468835, 12.578777), precision);
+        assertEquals(844, instance.getEle(48.469123, 9.576393), precision);
+        // The file for this coordinate does not exist, but there is a ferry tagged in OSM
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        // Outside of SRTM covered area
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 19), precision);
+        assertEquals(0, instance.getEle(60.251, 18.805), precision);
+    }
+
+    @Ignore
+    public void testGetEleVerticalBorder() {
+        // Border between the tiles n42e011 and n43e011
+        assertEquals("n42e011", instance.getFileName(42.999999, 11.48));
+        assertEquals(420, instance.getEle(42.999999, 11.48), precision);
+        assertEquals("n43e011", instance.getFileName(43.000001, 11.48));
+        assertEquals(420, instance.getEle(43.000001, 11.48), precision);
+    }
+
+    @Ignore
+    public void testGetEleHorizontalBorder() {
+        // Border between the tiles n42e011 and n42e012
+        assertEquals("n42e011", instance.getFileName(42.1, 11.999999));
+        assertEquals(324, instance.getEle(42.1, 11.999999), precision);
+        assertEquals("n42e012", instance.getFileName(42.1, 12.000001));
+        assertEquals(324, instance.getEle(42.1, 12.000001), precision);
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 83fd21588d..0352f7f1df 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -17,13 +17,11 @@
  */
 package com.graphhopper.reader.dem;
 
-import com.graphhopper.storage.DAType;
-import com.graphhopper.util.Constants;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
-import java.io.File;
 import java.io.IOException;
 
 import static org.junit.Assert.assertEquals;
@@ -32,6 +30,7 @@
  * @author Peter Karich
  */
 public class SRTMProviderTest {
+    private double precision = .1;
     SRTMProvider instance;
 
     @Before
@@ -46,20 +45,20 @@ public void tearDown() {
 
     @Test
     public void testGetFileString() {
-        assertEquals("Eurasia/N49E011", instance.getFileString(49, 11));
-        assertEquals("Eurasia/N52W002", instance.getFileString(52.268157, -1.230469));
-        assertEquals("Africa/S06E034", instance.getFileString(-5.965754, 34.804687));
-        assertEquals("Australia/S29E131", instance.getFileString(-28.304381, 131.484375));
-        assertEquals("South_America/S09W045", instance.getFileString(-9, -45));
-        assertEquals("South_America/S10W046", instance.getFileString(-9.1, -45.1));
-        assertEquals("South_America/S10W045", instance.getFileString(-9.6, -45));
-        assertEquals("South_America/S28W071", instance.getFileString(-28, -71));
-        assertEquals("South_America/S29W072", instance.getFileString(-28.88316, -71.070557));
+        assertEquals("Eurasia/N49E011", instance.getFileName(49, 11));
+        assertEquals("Eurasia/N52W002", instance.getFileName(52.268157, -1.230469));
+        assertEquals("Africa/S06E034", instance.getFileName(-5.965754, 34.804687));
+        assertEquals("Australia/S29E131", instance.getFileName(-28.304381, 131.484375));
+        assertEquals("South_America/S09W045", instance.getFileName(-9, -45));
+        assertEquals("South_America/S10W046", instance.getFileName(-9.1, -45.1));
+        assertEquals("South_America/S10W045", instance.getFileName(-9.6, -45));
+        assertEquals("South_America/S28W071", instance.getFileName(-28, -71));
+        assertEquals("South_America/S29W072", instance.getFileName(-28.88316, -71.070557));
     }
 
     @Test
     public void testGetHeight() throws IOException {
-        instance.setCacheDir(new File("./files/"));
+        instance = new SRTMProvider("./files/");
         // easy to verify orientation of tile:
 //        instance.getEle(43, 13);
 
@@ -88,7 +87,7 @@ public void testGetHeight() throws IOException {
 
     @Test
     public void testGetHeight_issue545() throws IOException {
-        instance.setCacheDir(new File("./files/"));
+        instance = new SRTMProvider("./files/");
 
         // test different precision of the elevation file (3600)
         assertEquals(84, instance.getEle(48.003878, -124.660492), 1e-1);
@@ -96,7 +95,53 @@ public void testGetHeight_issue545() throws IOException {
 
     @Test
     public void testGetHeightMMap() throws IOException {
-        instance.setCacheDir(new File("./files/"));
+        instance = new SRTMProvider("./files/");
         assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
     }
+
+    @Ignore
+    public void testGetEle() {
+        instance = new SRTMProvider();
+        assertEquals(337, instance.getEle(49.949784, 11.57517), precision);
+        assertEquals(466, instance.getEle(49.968668, 11.575127), precision);
+        assertEquals(466, instance.getEle(49.968682, 11.574842), precision);
+        assertEquals(3100, instance.getEle(-22.532854, -65.110474), precision);
+        assertEquals(122, instance.getEle(38.065392, -87.099609), precision);
+        assertEquals(1617, instance.getEle(40, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.99999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.9999999, -105.2277023), precision);
+        assertEquals(1617, instance.getEle(39.999999, -105.2277023), precision);
+        assertEquals(1046, instance.getEle(47.468668, 14.575127), precision);
+        assertEquals(1113, instance.getEle(47.467753, 14.573911), precision);
+        assertEquals(1946, instance.getEle(46.468835, 12.578777), precision);
+        assertEquals(845, instance.getEle(48.469123, 9.576393), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        assertEquals(0, instance.getEle(56.4787319, 17.6118363), precision);
+        // Outside of SRTM covered area
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 16), precision);
+        assertEquals(0, instance.getEle(60.0000001, 19), precision);
+        assertEquals(0, instance.getEle(60.251, 18.805), precision);
+    }
+
+    @Ignore
+    public void testGetEleVerticalBorder() {
+        instance = new SRTMProvider();
+        // Border between the tiles N42E011 and N43E011
+        assertEquals("Eurasia/N42E011", instance.getFileName(42.999999, 11.48));
+        assertEquals(419, instance.getEle(42.999999, 11.48), precision);
+        assertEquals("Eurasia/N43E011", instance.getFileName(43.000001, 11.48));
+        assertEquals(419, instance.getEle(43.000001, 11.48), precision);
+    }
+
+    @Ignore
+    public void testGetEleHorizontalBorder() {
+        instance = new SRTMProvider();
+        // Border between the tiles N42E011 and N42E012
+        assertEquals("Eurasia/N42E011", instance.getFileName(42.1, 11.999999));
+        assertEquals(324, instance.getEle(42.1, 11.999999), precision);
+        assertEquals("Eurasia/N42E012", instance.getFileName(42.1, 12.000001));
+        assertEquals(324, instance.getEle(42.1, 12.000001), precision);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index c2df7a627d..fbbb480a43 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -597,6 +597,76 @@ public void testCalcInstructionSlightTurn() {
         assertEquals(-1, wayList.get(1).getSign());
     }
 
+    @Test
+    public void testUTurnLeft() {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+        // Real Situation: point=48.402116%2C9.994367&point=48.402198%2C9.99507
+        //       7
+        //       |
+        //  4----5----6
+        //       |
+        //  1----2----3
+        na.setNode(1, 48.402116, 9.994367);
+        na.setNode(2, 48.402198, 9.99507);
+        na.setNode(3, 48.402344, 9.996266);
+        na.setNode(4, 48.402191, 9.994351);
+        na.setNode(5, 48.402298, 9.995053);
+        na.setNode(6, 48.402422, 9.996067);
+        na.setNode(7, 48.402604, 9.994962);
+
+        g.edge(1, 2, 5, false).setName("Olgastraße");
+        g.edge(2, 3, 5, false).setName("Olgastraße");
+        g.edge(6, 5, 5, false).setName("Olgastraße");
+        g.edge(5, 4, 5, false).setName("Olgastraße");
+        g.edge(2, 5, 5, true).setName("Neithardtstraße");
+        g.edge(5, 7, 5, true).setName("Neithardtstraße");
+
+        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(1, 4);
+        assertTrue(p.isFound());
+        InstructionList wayList = p.calcInstructions(tr);
+
+        assertEquals(3, wayList.size());
+        assertEquals(Instruction.U_TURN_LEFT, wayList.get(1).getSign());
+    }
+
+    @Test
+    public void testUTurnRight() {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+        // Real Situation: point=-33.885758,151.181472&point=-33.885692,151.181445
+        //       7
+        //       |
+        //  4----5----6
+        //       |
+        //  3----2----1
+        na.setNode(1, -33.885758,151.181472);
+        na.setNode(2, -33.885852,151.180968);
+        na.setNode(3, -33.885968,151.180501);
+        na.setNode(4, -33.885883,151.180442);
+        na.setNode(5, -33.885772,151.180941);
+        na.setNode(6, -33.885692,151.181445);
+        na.setNode(7, -33.885692,151.181445);
+
+        g.edge(1, 2, 5, false).setName("Parramatta Road");
+        g.edge(2, 3, 5, false).setName("Parramatta Road");
+        g.edge(4, 5, 5, false).setName("Parramatta Road");
+        g.edge(5, 6, 5, false).setName("Parramatta Road");
+        g.edge(2, 5, 5, true).setName("Larkin Street");
+        g.edge(5, 7, 5, true).setName("Larkin Street");
+
+        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(1, 6);
+        assertTrue(p.isFound());
+        InstructionList wayList = p.calcInstructions(tr);
+
+        assertEquals(3, wayList.size());
+        assertEquals(Instruction.U_TURN_RIGHT, wayList.get(1).getSign());
+    }
+
     @Test
     public void testCalcInstructionsForTurn() {
         // The street turns left, but there is not turn
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
new file mode 100644
index 0000000000..c73b25eebe
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
@@ -0,0 +1,395 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+
+public class NodeContractorTest {
+    private final CarFlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager encodingManager = new EncodingManager(encoder);
+    private final Weighting weighting = new ShortestWeighting(encoder);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+    private final CHGraph lg = graph.getGraph(CHGraph.class);
+    private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private Directory dir;
+
+    @Before
+    public void setUp() {
+        dir = new GHDirectory("", DAType.RAM_INT);
+    }
+
+    private NodeContractor createNodeContractor() {
+        NodeContractor nodeContractor = new NodeContractor(dir, graph, lg, weighting, traversalMode);
+        nodeContractor.initFromGraph();
+        return nodeContractor;
+    }
+
+    private void createExampleGraph() {
+        //5-1-----2
+        //   \ __/|
+        //    0   |
+        //   /    |
+        //  4-----3
+        //
+        graph.edge(0, 1, 1, true);
+        graph.edge(0, 2, 1, true);
+        graph.edge(0, 4, 3, true);
+        graph.edge(1, 2, 3, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(4, 3, 2, true);
+        graph.edge(5, 1, 2, true);
+        graph.freeze();
+    }
+
+    @Test
+    public void testShortestPathSkipNode() {
+        createExampleGraph();
+        final double normalDist = new Dijkstra(graph, weighting, traversalMode).calcPath(4, 2).getDistance();
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+        CHGraph lg = graph.getGraph(CHGraph.class);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
+        assertTrue(algo.getWeight(nodeEntry) > normalDist);
+
+        algo.clear();
+        algo.setMaxVisitedNodes(1);
+        nodeEntry = algo.findEndNode(4, 2);
+        assertEquals(-1, nodeEntry);
+    }
+
+    @Test
+    public void testShortestPathSkipNode2() {
+        createExampleGraph();
+        final double normalDist = new Dijkstra(graph, weighting, traversalMode).calcPath(4, 2).getDistance();
+        assertEquals(3, normalDist, 1e-5);
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
+        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
+
+        nodeEntry = algo.findEndNode(4, 1);
+        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
+    }
+
+    @Test
+    public void testShortestPathLimit() {
+        createExampleGraph();
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
+        // did not reach endNode
+        assertNotEquals(1, endNode);
+    }
+
+    @Test
+    public void testDirectedGraph() {
+        //5 6 7
+        // \|/
+        //4-3_1<-\ 10
+        //     \_|/
+        //   0___2_11
+
+        graph.edge(0, 2, 2, true);
+        graph.edge(10, 2, 2, true);
+        graph.edge(11, 2, 2, true);
+        // create a longer one directional edge => no longish one-dir shortcut should be created
+        final EdgeIteratorState edge2to1bidirected = graph.edge(2, 1, 2, true);
+        final EdgeIteratorState edge2to1directed = graph.edge(2, 1, 10, false);
+        final EdgeIteratorState edge1to3 = graph.edge(1, 3, 2, true);
+        graph.edge(3, 4, 2, true);
+        graph.edge(3, 5, 2, true);
+        graph.edge(3, 6, 2, true);
+        graph.edge(3, 7, 2, true);
+        graph.freeze();
+
+        setMaxLevelOnAllNodes();
+
+        // find all shortcuts if we contract node 1
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(1);
+        checkShortcuts(
+                expectedShortcut(2, 3, edge1to3, edge2to1bidirected, true, true),
+                expectedShortcut(2, 3, edge2to1directed, edge1to3, true, false)
+        );
+    }
+
+    @Test
+    public void testFindShortcuts_Roundabout() {
+        // 1 -- 3 -- 4 ---> 5 ---> 6 -- 7
+        //            \           /
+        //             <--- 8 <--- 
+        final EdgeIteratorState iter1to3 = graph.edge(1, 3, 1, true);
+        final EdgeIteratorState iter3to4 = graph.edge(3, 4, 1, true);
+        final EdgeIteratorState iter4to5 = graph.edge(4, 5, 1, false);
+        final EdgeIteratorState iter5to6 = graph.edge(5, 6, 1, false);
+        final EdgeIteratorState iter6to8 = graph.edge(6, 8, 2, false);
+        final EdgeIteratorState iter8to4 = graph.edge(8, 4, 1, false);
+        graph.edge(6, 7, 1, true);
+        graph.freeze();
+
+        CHEdgeIteratorState sc1to4 = lg.shortcut(1, 4);
+        sc1to4.setFlags(PrepareEncoder.getScDirMask());
+        sc1to4.setWeight(2);
+        sc1to4.setDistance(2);
+        sc1to4.setSkippedEdges(iter1to3.getEdge(), iter3to4.getEdge());
+
+        long f = PrepareEncoder.getScFwdDir();
+        CHEdgeIteratorState sc4to6 = lg.shortcut(4, 6);
+        sc4to6.setFlags(f);
+        sc4to6.setWeight(2);
+        sc4to6.setDistance(2);
+        sc4to6.setSkippedEdges(iter4to5.getEdge(), iter5to6.getEdge());
+
+        CHEdgeIteratorState sc6to4 = lg.shortcut(6, 4);
+        sc6to4.setFlags(f);
+        sc6to4.setWeight(3);
+        sc6to4.setDistance(3);
+        sc6to4.setSkippedEdges(iter6to8.getEdge(), iter8to4.getEdge());
+
+        setMaxLevelOnAllNodes();
+
+        lg.setLevel(3, 3);
+        lg.setLevel(5, 5);
+        lg.setLevel(7, 7);
+        lg.setLevel(8, 8);
+
+        Shortcut manualSc1 = expectedShortcut(1, 4, iter1to3, iter3to4, true, true);
+        Shortcut manualSc2 = expectedShortcut(4, 6, iter4to5, iter5to6, true, false);
+        Shortcut manualSc3 = expectedShortcut(4, 6, iter6to8, iter8to4, false, true);
+        checkShortcuts(manualSc1, manualSc2, manualSc3);
+
+        // after 'manual contraction' of nodes 3, 5, 8 the graph looks like:
+        // 1 -- 4 -->-- 6 -- 7
+        //       \      |
+        //        --<----
+
+        // contract node 4!
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(4);
+        checkShortcuts(manualSc1, manualSc2, manualSc3,
+                // there should be two different shortcuts for both directions!
+                expectedShortcut(1, 6, sc1to4, sc4to6, true, false),
+                expectedShortcut(1, 6, sc6to4, sc1to4, false, true)
+        );
+    }
+
+
+    @Test
+    public void testShortcutMergeBug() {
+        // We refer to this real world situation http://www.openstreetmap.org/#map=19/52.71205/-1.77326
+        // assume the following graph:
+        //
+        // ---1---->----2-----3
+        //    \--------/
+        //
+        // where there are two roads from 1 to 2 and the directed road has a smaller weight
+        // leading to two shortcuts sc1 (unidir) and sc2 (bidir) where the second should NOT be rejected due to the larger weight
+        final EdgeIteratorState edge1to2bidirected = graph.edge(1, 2, 1, true);
+        final EdgeIteratorState edge1to2directed = graph.edge(1, 2, 1, false);
+        final EdgeIteratorState edge2to3 = graph.edge(2, 3, 1, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(2);
+        checkShortcuts(
+                expectedShortcut(1, 3, edge2to3, edge1to2bidirected, false, true),
+                expectedShortcut(1, 3, edge1to2directed, edge2to3, true, false)
+        );
+    }
+
+    @Test
+    public void testContractNode_directed_shortcutRequired() {
+        // 0 --> 1 --> 2
+        final EdgeIteratorState edge1 = graph.edge(0, 1, 1, false);
+        final EdgeIteratorState edge2 = graph.edge(1, 2, 2, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge1, edge2, true, false));
+    }
+
+    @Test
+    public void testContractNode_directed_shortcutRequired_reverse() {
+        // 0 <-- 1 <-- 2
+        final EdgeIteratorState edge1 = graph.edge(2, 1, 1, false);
+        final EdgeIteratorState edge2 = graph.edge(1, 0, 2, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge1, edge2, false, true));
+    }
+
+    @Test
+    public void testContractNode_bidirected_shortcutsRequired() {
+        // 0 -- 1 -- 2
+        final EdgeIteratorState edge1 = graph.edge(0, 1, 1, true);
+        final EdgeIteratorState edge2 = graph.edge(1, 2, 2, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge2, edge1, true, true));
+    }
+
+    @Test
+    public void testContractNode_directed_withWitness() {
+        // 0 --> 1 --> 2
+        //  \_________/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(0, 2, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkNoShortcuts();
+    }
+
+    /**
+     * Queries the ch graph and checks if the graph's shortcuts match the given expected shortcuts.
+     */
+    private void checkShortcuts(Shortcut... expectedShortcuts) {
+        Set<Shortcut> expected = setOf(expectedShortcuts);
+        if (expected.size() != expectedShortcuts.length) {
+            fail("was given duplicate shortcuts");
+        }
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        Set<Shortcut> given = new HashSet<>();
+        while (iter.next()) {
+            if (iter.isShortcut()) {
+                given.add(new Shortcut(
+                        iter.getBaseNode(), iter.getAdjNode(), iter.getWeight(), iter.getDistance(),
+                        iter.isForward(encoder), iter.isBackward(encoder),
+                        iter.getSkippedEdge1(), iter.getSkippedEdge2()));
+            }
+        }
+        assertEquals(expected, given);
+    }
+
+    private void checkNoShortcuts() {
+        checkShortcuts();
+    }
+
+    private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState edge1, EdgeIteratorState edge2,
+                                      boolean fwd, boolean bwd) {
+        //todo: weight calculation might have to be adjusted for different encoders/weightings/reverse speed
+        double weight = weighting.calcWeight(edge1, false, EdgeIterator.NO_EDGE) +
+                weighting.calcWeight(edge2, false, EdgeIterator.NO_EDGE);
+        double distance = edge1.getDistance() + edge2.getDistance();
+        return new Shortcut(baseNode, adjNode, weight, distance, fwd, bwd, edge1.getEdge(), edge2.getEdge());
+    }
+
+    private Set<Shortcut> setOf(Shortcut... shortcuts) {
+        Set<Shortcut> result = new HashSet<>();
+        result.addAll(Arrays.asList(shortcuts));
+        return result;
+    }
+
+    private void setMaxLevelOnAllNodes() {
+        int nodes = lg.getNodes();
+        for (int node = 0; node < nodes; node++) {
+            lg.setLevel(node, nodes + 1);
+        }
+    }
+
+    private static class Shortcut {
+        int baseNode;
+        int adjNode;
+        double weight;
+        double distance;
+        boolean fwd;
+        boolean bwd;
+        int skipEdge1;
+        int skipEdge2;
+
+        Shortcut(int baseNode, int adjNode, double weight, double distance, boolean fwd, boolean bwd, int skipEdge1, int skipEdge2) {
+            this.baseNode = baseNode;
+            this.adjNode = adjNode;
+            this.weight = weight;
+            this.distance = distance;
+            this.fwd = fwd;
+            this.bwd = bwd;
+            this.skipEdge1 = skipEdge1;
+            this.skipEdge2 = skipEdge2;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) return true;
+            if (obj == null || getClass() != obj.getClass()) return false;
+            Shortcut shortcut = (Shortcut) obj;
+            return baseNode == shortcut.baseNode &&
+                    adjNode == shortcut.adjNode &&
+                    Double.compare(shortcut.weight, weight) == 0 &&
+                    Double.compare(shortcut.distance, distance) == 0 &&
+                    fwd == shortcut.fwd &&
+                    bwd == shortcut.bwd &&
+                    skipEdge1 == shortcut.skipEdge1 &&
+                    skipEdge2 == shortcut.skipEdge2;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(baseNode, adjNode, weight, distance, fwd, bwd, skipEdge1, skipEdge2);
+        }
+
+        @Override
+        public String toString() {
+            return "Shortcut{" +
+                    "baseNode=" + baseNode +
+                    ", adjNode=" + adjNode +
+                    ", weight=" + weight +
+                    ", distance=" + distance +
+                    ", fwd=" + fwd +
+                    ", bwd=" + bwd +
+                    ", skipEdge1=" + skipEdge1 +
+                    ", skipEdge2=" + skipEdge2 +
+                    '}';
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index f88c684057..d588a05dd3 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -19,7 +19,6 @@
 
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.BikeFlagEncoder;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -33,8 +32,6 @@
 import org.junit.Test;
 
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
 import java.util.List;
 
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
@@ -140,7 +137,7 @@ GraphHopperStorage createExampleGraph() {
         g.edge(0, 1, 1, true);
         g.edge(0, 2, 1, true);
         g.edge(0, 4, 3, true);
-        g.edge(1, 2, 2, true);
+        g.edge(1, 2, 3, true);
         g.edge(2, 3, 1, true);
         g.edge(4, 3, 2, true);
         g.edge(5, 1, 2, true);
@@ -152,59 +149,6 @@ public void setUp() {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
-    @Test
-    public void testShortestPathSkipNode() {
-        GraphHopperStorage g = createExampleGraph();
-        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        CHGraph lg = g.getGraph(CHGraph.class);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg,
-                weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
-        algo.setWeightLimit(100);
-        int nodeEntry = algo.findEndNode(4, 2);
-        assertTrue(algo.getWeight(nodeEntry) > normalDist);
-
-        algo.clear();
-        algo.setMaxVisitedNodes(1);
-        nodeEntry = algo.findEndNode(4, 2);
-        assertEquals(-1, nodeEntry);
-    }
-
-    @Test
-    public void testShortestPathSkipNode2() {
-        GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
-        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
-        assertEquals(3, normalDist, 1e-5);
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
-        algo.setWeightLimit(10);
-        int nodeEntry = algo.findEndNode(4, 2);
-        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
-
-        nodeEntry = algo.findEndNode(4, 1);
-        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
-    }
-
-    @Test
-    public void testShortestPathLimit() {
-        GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
-
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(0));
-        algo.setWeightLimit(2);
-        int endNode = algo.findEndNode(4, 1);
-        // did not reach endNode
-        assertNotEquals(1, endNode);
-    }
-
     @Test
     public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
@@ -212,7 +156,7 @@ public void testAddShortcuts() {
         int old = lg.getAllEdges().getMaxId();
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, lg.getAllEdges().getMaxId());
+        assertEquals(old + 2, lg.getAllEdges().getMaxId());
     }
 
     @Test
@@ -263,66 +207,16 @@ public void testDirectedGraph2() {
         assertEquals(oldCount, g.getAllEdges().getMaxId());
         assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
 
-        assertEquals(9, prepare.getShortcuts());
-        assertEquals(oldCount + 9, lg.getAllEdges().getMaxId());
-        assertEquals(oldCount + 9, GHUtility.count(lg.getAllEdges()));
+        int numShortcuts = 9;
+        assertEquals(numShortcuts, prepare.getShortcuts());
+        assertEquals(oldCount + numShortcuts, lg.getAllEdges().getMaxId());
+        assertEquals(oldCount + numShortcuts, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
     }
 
-    @Test
-    public void testDirectedGraph3() {
-        GraphHopperStorage g = createGHStorage();
-        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
-        //5 6 7
-        // \|/
-        //4-3_1<-\ 10
-        //     \_|/
-        //   0___2_11
-
-        g.edge(0, 2, 2, true);
-        g.edge(10, 2, 2, true);
-        g.edge(11, 2, 2, true);
-        // create a longer one directional edge => no longish one-dir shortcut should be created
-        g.edge(2, 1, 2, true);
-        g.edge(2, 1, 10, false);
-
-        g.edge(1, 3, 2, true);
-        g.edge(3, 4, 2, true);
-        g.edge(3, 5, 2, true);
-        g.edge(3, 6, 2, true);
-        g.edge(3, 7, 2, true);
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph();
-        prepare.prepareNodes();
-
-        // find all shortcuts if we contract node 1
-        Collection<Shortcut> scs = prepare.testFindShortcuts(1);
-        assertEquals(2, scs.size());
-        Iterator<Shortcut> iter = scs.iterator();
-        Shortcut sc1 = iter.next();
-        Shortcut sc2 = iter.next();
-        if (sc1.weight > sc2.weight) {
-            Shortcut tmp = sc1;
-            sc1 = sc2;
-            sc2 = tmp;
-        }
-
-        // both dirs
-        assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
-
-        // directed
-        assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
-        assertTrue(sc2.toString(), carEncoder.isForward(sc2.flags));
-
-        assertEquals(sc1.toString(), 4, sc1.weight, 1e-4);
-        assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
-    }
-
     void initRoundaboutGraph(Graph g) {
         //              roundabout:
         //16-0-9-10--11   12<-13
@@ -389,58 +283,6 @@ public void testRoundaboutUnpacking() {
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
 
-    @Test
-    public void testFindShortcuts_Roundabout() {
-        GraphHopperStorage ghStorage = createGHStorage();
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
-        EdgeIteratorState iter1_3 = ghStorage.edge(1, 3, 1, true);
-        EdgeIteratorState iter3_4 = ghStorage.edge(3, 4, 1, true);
-        EdgeIteratorState iter4_5 = ghStorage.edge(4, 5, 1, false);
-        EdgeIteratorState iter5_6 = ghStorage.edge(5, 6, 1, false);
-        EdgeIteratorState iter6_8 = ghStorage.edge(6, 8, 2, false);
-        EdgeIteratorState iter8_4 = ghStorage.edge(8, 4, 1, false);
-        ghStorage.edge(6, 7, 1, true);
-        ghStorage.freeze();
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg,
-                weighting, tMode);
-        CHEdgeIteratorState tmp = lg.shortcut(1, 4);
-        tmp.setFlags(PrepareEncoder.getScDirMask());
-        tmp.setWeight(2);
-        tmp.setSkippedEdges(iter1_3.getEdge(), iter3_4.getEdge());
-        long f = PrepareEncoder.getScFwdDir();
-        tmp = lg.shortcut(4, 6);
-        tmp.setFlags(f);
-        tmp.setWeight(2);
-        tmp.setSkippedEdges(iter4_5.getEdge(), iter5_6.getEdge());
-        tmp = lg.shortcut(6, 4);
-        tmp.setFlags(f);
-        tmp.setWeight(3);
-        tmp.setSkippedEdges(iter6_8.getEdge(), iter8_4.getEdge());
-
-        prepare.initFromGraph();
-        prepare.prepareNodes();
-        lg.setLevel(3, 3);
-        lg.setLevel(5, 5);
-        lg.setLevel(7, 7);
-        lg.setLevel(8, 8);
-
-        // there should be two different shortcuts for both directions!
-        Collection<Shortcut> sc = prepare.testFindShortcuts(4);
-        assertEquals(2, sc.size());
-        Iterator<Shortcut> iter = sc.iterator();
-        Shortcut sc1 = iter.next();
-        Shortcut sc2 = iter.next();
-        if (sc1.from > sc2.from) {
-            Shortcut tmpSc = sc1;
-            sc1 = sc2;
-            sc2 = tmpSc;
-        }
-
-        assertEquals("1->6, weight:4.0 (7,8)", sc1.toString());
-        assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
-    }
-
     void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
         final long flags = carEncoder.setProperties(30, true, false);
         double dist = 1;
@@ -646,30 +488,4 @@ void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, doub
         assertEquals(w.toString(), expNodes, p.calcNodes());
     }
 
-    @Test
-    public void testShortcutMergeBug() {
-        // We refer to this real world situation http://www.openstreetmap.org/#map=19/52.71205/-1.77326
-        // assume the following graph:
-        //
-        // ---1---->----2-----3
-        //    \--------/
-        //
-        // where there are two roads from 1 to 2 and the directed road has a smaller weight
-        // leading to two shortcuts sc1 (unidir) and sc2 (bidir) where the second should NOT be rejected due to the larger weight
-        GraphHopperStorage g = createGHStorage();
-        g.edge(1, 2, 1, true);
-        g.edge(1, 2, 1, false);
-        g.edge(2, 3, 1, true);
-
-        CHGraph lg = g.getGraph(CHGraph.class);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph();
-
-        // order is important here
-        Shortcut sc1 = new Shortcut(1, 3, 6.81620625, 121.18);
-        Shortcut sc2 = new Shortcut(1, 3, 6.82048125, 121.25);
-        sc2.flags = PrepareEncoder.getScDirMask();
-        List<Shortcut> list = Arrays.asList(sc1, sc2);
-        assertEquals(2, prepare.addShortcuts(list));
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 43f2b7aeef..ae01cd3d9f 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -447,7 +447,7 @@ public void testRailway() {
         // accept
         assertTrue(encoder.acceptWay(way) > 0);
         // We have ignored the unrealisitc long duration and take the unknown speed
-        assertEquals(5, encoder.getFerrySpeed(way), 1e-1);
+        assertEquals(2.5, encoder.getFerrySpeed(way), 1e-1);
     }
 
     @Test
@@ -619,4 +619,16 @@ public void testApplyBadSurfaceSpeed() {
         assertEquals(30, encoder.applyBadSurfaceSpeed(way, 90), 1e-1);
 
     }
+
+    @Test
+    public void testIssue_1256() {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("route", "ferry");
+        way.setTag("estimated_distance", 257);
+
+        CarFlagEncoder lowFactorCar = new CarFlagEncoder(10, 1, 0);
+        lowFactorCar.defineWayBits(0,0);
+        assertEquals(2.5, encoder.getFerrySpeed(way), .1);
+        assertEquals(.5, lowFactorCar.getFerrySpeed(way), .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 200806f488..acde4d6e42 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -344,6 +344,46 @@ public void testSimpleShortcutCreationAndTraversal() {
         assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
     }
 
+    @Test
+    public void testAddShortcutSkippedEdgesWriteRead() {
+        graph = createGHStorage();
+        final EdgeIteratorState edge1 = graph.edge(1, 3, 10, true);
+        final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
+        graph.freeze();
+
+        CHGraph lg = graph.getGraph(CHGraph.class);
+        lg.shortcut(1, 4);
+
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        iter.next();
+        iter.next();
+        iter.next();
+        assertTrue(iter.isShortcut());
+        iter.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
+        assertEquals(edge1.getEdge(), iter.getSkippedEdge1());
+        assertEquals(edge2.getEdge(), iter.getSkippedEdge2());
+    }
+
+    @Test
+    public void testAddShortcutSkippedEdgesWriteRead_writeWithCHEdgeIterator() {
+        graph = createGHStorage();
+        final EdgeIteratorState edge1 = graph.edge(1, 3, 10, true);
+        final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
+        graph.freeze();
+
+        CHGraph lg = graph.getGraph(CHGraph.class);
+        CHEdgeIteratorState shortcut = lg.shortcut(1, 4);
+        shortcut.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
+
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        iter.next();
+        iter.next();
+        iter.next();
+        assertTrue(iter.isShortcut());
+        assertEquals(edge1.getEdge(), iter.getSkippedEdge1());
+        assertEquals(edge2.getEdge(), iter.getSkippedEdge2());
+    }
+
     @Test
     public void testShortcutCreationAndAccessForManyVehicles() {
         FlagEncoder tmpCar = new CarFlagEncoder();
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index beaa879c1e..9319b0ff9a 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,11 +20,7 @@
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
-import java.util.Arrays;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
@@ -100,6 +96,29 @@ public void testIterable() {
         }
     }
 
+    @Test
+    public void testRemoveLast() {
+        PointList list = new PointList(20, false);
+        for (int i = 0; i < 10; i++) {
+            list.add(1, i);
+        }
+        assertEquals(10, list.getSize());
+        assertEquals(9, list.getLon(list.getSize() - 1), .1);
+        list.removeLastPoint();
+        assertEquals(9, list.getSize());
+        assertEquals(8, list.getLon(list.getSize() - 1), .1);
+
+        list = new PointList(20, false);
+        list.add(1, 1);
+        list.removeLastPoint();
+        try {
+            list.removeLastPoint();
+            fail();
+        } catch (Exception ex) {
+        }
+        assertEquals(0, list.getSize());
+    }
+
     @Test
     public void testCopy_issue1166() {
         PointList list = new PointList(20, false);
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
index 04532aefd5..349e816816 100644
--- a/docs/core/elevation.md
+++ b/docs/core/elevation.md
@@ -1,29 +1,28 @@
 # Elevation
 
-Per default elevation is disabled. But you can easily enable it:
-`graph.elevation.provider=cgiar`
-or
-`graph.elevation.provider=srtm`
+Per default elevation is disabled. But you can easily enable it e.g. via
+`graph.elevation.provider=cgiar`. Or use other possibilities `srtm`, `gmted`
+or `multi` (combined cgiar and gmted).
 
-then GraphHopper will automatically download the necessary data for the area and include elevation 
+Then GraphHopper will automatically download the necessary data for the area and include elevation 
 for all vehicles - making also the distances a bit more precise. 
 
-The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+The default cache directory `/tmp/<provider name>` will be used. For large areas it is highly recommended to 
 use a SSD disc, thus you need to specify the cache directory:
 `graph.elevation.cache_dir=/myssd/ele_cache/`
 
 ## What to download and where to store it? 
 
-All should work automatically. Another setting is to specify the location where the files are 
-downloaded - e.g. if the servers are not reachable, then you set:
+All should work automatically but you can tune certain settings like the location where the files are 
+downloaded and e.g. if the servers are not reachable, then you set:
 `graph.elevation.base_url`
 
-E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+For CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
 `http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
 where the last one is only accessibly if you specify the 
 [full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
 
-If the area is small and you need a faster import you can change the default MMAP setting to:
+If the geographical area is small and you need a faster import you can change the default MMAP setting to:
 `graph.elevation.dataaccess=RAM_STORE`
 
 ## CGIAR vs. SRTM
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 711c759474..252f936a51 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -53,14 +53,13 @@ List<Map<String, Object>> iList = il.createJson();
 List<GPXEntry> list = il.createGPXList();
 ```
 
-## Speed mode vs. Flexibility mode
+## Speed mode vs. Hybrid mode vs. Flexibile mode
 
-The default is to use the speed-up mode. If you need multiple profiles you specify a list of profiles (e.g. car,bike). 
+The default option of GraphHopper is the speed mode. If you don't want to use the speed-up mode you can disable it before the import (see config.properties `prepare.ch.weightings=no`) or on a per request base by adding `ch.disable=true` to the request. If you want to use the hybrid mode you have to enable it before the import (see config.properties `prepare.lm.weightings=fastest`).
 
-You can also completely disable the speed-up mode before import (see config.properties `prepare.ch.weightings=no`)
-or for a per request setting (`ch.disable=true`). 
+If you need multiple vehicle profiles you can specify a list of vehicle profiles (see config.properties e.g. `graph.flag_encoders=car,bike` or use `new EncodingManager("car,bike")`). 
 
-Then pick one vehicle and optionally an algorithm like 'bidirectional astar':
+To calculate a route you have to pick one vehicle and optionally an algorithm like `bidirectional_astar`:
 
 ```java
 GraphHopper hopper = new GraphHopperOSM().forServer();
@@ -78,8 +77,8 @@ GHResponse res = hopper.route(req);
 
 ## Heading
 
-In the flexibility mode it is also possible to add a desired heading (north based azimuth between 0 and 360 degree)
-to any point:
+The flexibile and hybrid mode allows to add a desired heading (north based azimuth between 0 and 360 degree)
+to any point. Adding a heading makes it more likely that a route starts towards the provided direction:
 ```java
 GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
 ```
@@ -94,7 +93,7 @@ I.e. if you want to force "coming from south" to a destination you need to speci
 
 ## Alternative Routes
 
-In the flexibility mode you can get alternative routes via:
+The flexibile and hybrid mode allows you to calculate alternative routes via:
 ```java
 req.setAlgorithm(Parameters.Algorithms.ALT_ROUTE)
 ```
@@ -108,10 +107,9 @@ req.getHints().put(Parameters.AltRoute.MAX_PATHS, "3");
 
 See the Parameters class for further hints.
 
-## Java client
+## Java client (client-hc)
  
-In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
- see the 'web' sub module or [the Java client for the GraphHopper Directions API](https://github.com/graphhopper/directions-api-java-client).
+If you want to calculate routes using the [GraphHopper Directions API](https://www.graphhopper.com/products/) or a self hosted instance of GraphHopper, you can use the [Java and Android client-hc](https://github.com/graphhopper/graphhopper/tree/master/client-hc) (there are also clients for [Java Script](https://github.com/graphhopper/directions-api-js-client) and [many other languages](https://github.com/graphhopper/directions-api-clients)). 
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 8d50f43698..d5ce068dd3 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -95,7 +95,7 @@ paths[0].instructions[0].annotation_text      | [optional] A text describing the
 paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
 paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
 paths[0].instructions[0].exited               | [optional] Only available for USE_ROUNDABOUT instructions. True if the roundabout should be exited. False if a via point or end is placed in the roundabout, thus, the roundabout should not be exited due to this instruction.
-paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Null if the direction of rotation is undefined.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: `0 < r < 2*PI` for clockwise and `-2PI < r < 0` for counterclockwise transit. `NaN` if the direction of rotation is undefined.
 
 ```json
 {
diff --git a/pom.xml b/pom.xml
index 3e82c5cf15..13e4e21a9b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -19,6 +19,7 @@
         <log4j.version>1.2.17</log4j.version>
         <commons-compress.version>1.12</commons-compress.version>
         <jackson.version>2.8.4</jackson.version>
+        <maven.compiler.target>1.8</maven.compiler.target>
 
         <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
         <org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>4</org-netbeans-modules-editor-indent.CodeStyle.project.spaces-per-tab>
@@ -94,7 +95,7 @@
                     <compilerArgument>-Xlint:deprecation</compilerArgument>
                     -->
 
-                    <!-- suppress warning about Unsafe functionality -->                    
+                    <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                     <source>1.7</source>
@@ -169,6 +170,41 @@
                 </configuration>
                 -->
             </plugin>
+            <plugin>
+                <groupId>de.thetaphi</groupId>
+                <artifactId>forbiddenapis</artifactId>
+                <version>2.4.1</version>
+                <configuration>
+                    <!--
+                      if the used Java version is too new,
+                      don't fail, just do nothing:
+                    -->
+                    <failOnUnsupportedJava>false</failOnUnsupportedJava>
+                    <bundledSignatures>
+                        <!--
+                          This will automatically choose the right
+                          signatures based on 'maven.compiler.target':
+                        -->
+                        <bundledSignature>jdk-unsafe</bundledSignature>
+                        <bundledSignature>jdk-deprecated</bundledSignature>
+                        <!-- disallow undocumented classes like sun.misc.Unsafe: -->
+                        <bundledSignature>jdk-non-portable</bundledSignature>
+                    </bundledSignatures>
+                    <excludes>
+                        <!-- Excluded because of "Helper7#getBeanMemInfo" -->
+                        <exclude>
+                            com/graphhopper/util/Helper7.class
+                        </exclude>
+                        <exclude>
+                            com/graphhopper/storage/UnsafeDataAccess.class
+                        </exclude>
+                        <!-- Has a couple of issues with the FileWriter -->
+                        <exclude>
+                            com/graphhopper/tools/Measurement.class
+                        </exclude>
+                    </excludes>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 
@@ -196,7 +232,7 @@
                 <activeByDefault>false</activeByDefault>
             </activation>
             <!-- this exception is valid for jdk8 profile below too -->
-            <modules>                
+            <modules>
                 <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
                 Currently works for jdk8 only -->
                 <module>reader-shp</module>
@@ -268,14 +304,14 @@
                 <module>android/app</module>
             </modules>
         </profile>
-        
+
         <profile>
             <id>jdk8</id>
             <activation>
                 <activeByDefault>true</activeByDefault>
             </activation>
             <properties />
-            <modules>                
+            <modules>
                 <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
                 Currently works for jdk8 only -->
                 <module>reader-shp</module>
@@ -291,7 +327,7 @@
                 </plugins>
             </build>
         </profile>
-        
+
         <profile>
             <id>jdk9</id>
             <activation>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index ec80420efc..d19a18aa74 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -115,7 +115,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             try {
                 initialTime = Instant.parse(departureTimeString);
             } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format("Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+                throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
             }
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
@@ -280,7 +280,7 @@ public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap,
         this.locationIndex = locationIndex;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
-        this.tripFromLabel = new TripFromLabel(this.gtfsStorage);
+        this.tripFromLabel = new TripFromLabel(this.gtfsStorage, this.realtimeFeed);
     }
 
     public static GtfsStorage createGtfsStorage() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
index 45ca525f4c..bee02ff8eb 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
@@ -20,6 +20,7 @@
 import java.text.SimpleDateFormat;
 import java.time.LocalDateTime;
 import java.util.Date;
+import java.util.Locale;
 
 /**
  * Generic helper for GTFS routines.
@@ -50,6 +51,6 @@ public static int time(LocalDateTime localDateTime) {
     }
 
     public static LocalDateTime localDateTimeFromDate(Date date) {
-        return LocalDateTime.parse(new SimpleDateFormat("YYYY-MM-dd'T'HH:mm").format(date));
+        return LocalDateTime.parse(new SimpleDateFormat("YYYY-MM-dd'T'HH:mm", Locale.ROOT).format(date));
     }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 6eef12943f..6514c8befa 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -20,7 +20,13 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.*;
+import com.conveyal.gtfs.model.Frequency;
+import com.conveyal.gtfs.model.Route;
+import com.conveyal.gtfs.model.Service;
+import com.conveyal.gtfs.model.Stop;
+import com.conveyal.gtfs.model.StopTime;
+import com.conveyal.gtfs.model.Transfer;
+import com.conveyal.gtfs.model.Trip;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
@@ -39,9 +45,20 @@
 
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.NavigableSet;
+import java.util.Optional;
+import java.util.SortedSet;
+import java.util.TreeSet;
 import java.util.stream.Collectors;
 
+import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 class GtfsReader {
@@ -50,14 +67,14 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, Iterable<StopTime> stopTimes, BitSet validOnDay) {
+        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
         }
 
         Trip trip;
-        Iterable<StopTime> stopTimes;
+        List<StopTime> stopTimes;
         BitSet validOnDay;
     }
 
@@ -122,10 +139,10 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
         this.i = graph.getNodes();
         this.startDate = feed.calculateStats().getStartDate();
         this.endDate = feed.calculateStats().getEndDate();
-        this.gtfsStorage.getFares().putAll(feed.fares);
     }
 
     void readGraph() {
+        gtfsStorage.getFares().putAll(feed.fares);
         buildPtNetwork();
         connectStopsToStreetNetwork();
         connectStopsToStationNodes();
@@ -184,7 +201,9 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
-                        return new TripWithStopTimes(trip, getInterpolatedStopTimesForTrip(trip.trip_id), validOnDay);
+                        ArrayList<StopTime> stopTimes = new ArrayList<>();
+                        getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
+                        return new TripWithStopTimes(trip, stopTimes, validOnDay);
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
                     .collect(Collectors.toList());
@@ -249,6 +268,10 @@ void wireUpStops() {
     void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
         List<Integer> arrivalNodes = new ArrayList<>();
         for (TripWithStopTimes trip : trips) {
+            GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder()
+                    .setTripId(trip.trip.trip_id)
+                    .setStartTime(convertToGtfsTime(time)).build();
+
             IntArrayList boardEdges = new IntArrayList();
             IntArrayList alightEdges = new IntArrayList();
             StopTime prev = null;
@@ -310,7 +333,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
                 boardEdges.add(boardEdge.getEdge());
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
                 boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
                 boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
 
@@ -323,7 +346,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
                 alightEdges.add(alightEdge.getEdge());
                 gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(alightEdge.getEdge(), tripDescriptor.toByteArray());
                 alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
 //                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
 
@@ -337,11 +360,10 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
                 dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
                 if (prev == null) {
-                    insertInboundBlockTransfers(arrivalNodes, trip.trip, departureNode, stopTime, stop, validityId);
+                    insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validityId);
                 }
                 prev = stopTime;
             }
-            final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
             gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
             gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
             arrivalNodes.add(arrivalNode);
@@ -415,7 +437,7 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
         });
     }
 
-    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip, int departureNode, StopTime stopTime, Stop stop, int validityId) {
+    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, int validityId) {
         EdgeIteratorState edge;
         for (int lastTripArrivalNode : arrivalNodes) {
             int dwellTime = times.get(departureNode) - times.get(lastTripArrivalNode);
@@ -439,7 +461,7 @@ private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip,
                 setEdgeType(edge, GtfsStorage.EdgeType.BOARD);
                 edge.setFlags(encoder.setValidityId(edge.getFlags(), validityId));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(edge.getEdge(), trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(edge.getEdge(), tripDescriptor.toByteArray());
             }
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 916af7c6cb..7b4ab0ee1c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -93,7 +93,7 @@ public int hashCode() {
 	private Map<Integer, Validity> validities;
 	private Bind.MapWithModificationListener<FeedIdWithTimezone, Integer> timeZones;
 	private Map<Integer, FeedIdWithTimezone> readableTimeZones;
-	private Map<Integer, String> extra;
+	private Map<Integer, byte[]> tripDescriptors;
 	private Map<Integer, Integer> stopSequences;
 	private Map<String, Fare> fares;
 	private Map<GtfsRealtime.TripDescriptor, int[]> boardEdgesForTrip;
@@ -186,7 +186,7 @@ private void init() {
 		Bind.mapInverse(this.timeZones, readableTimeZones);
 		this.readableTimeZones = Collections.unmodifiableMap(readableTimeZones);
 		this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
-		this.extra = data.getTreeMap("extra");
+		this.tripDescriptors = data.getTreeMap("tripDescriptors");
 		this.stopSequences = data.getTreeMap("stopSequences");
 		this.fares = data.getTreeMap("fares");
 		this.boardEdgesForTrip = data.getHashMap("boardEdgesForTrip");
@@ -259,8 +259,8 @@ public long getCapacity() {
 		return timeZones;
 	}
 
-	Map<Integer, String> getExtraStrings() {
-		return extra;
+	Map<Integer, byte[]> getTripDescriptors() {
+		return tripDescriptors;
 	}
 
 	Map<Integer, Integer> getStopSequences() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 9119b9e35a..85b331fca5 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -21,6 +21,7 @@
 import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.IntIntHashMap;
 import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.Agency;
 import com.conveyal.gtfs.model.StopTime;
 import com.conveyal.gtfs.model.Trip;
 import com.google.transit.realtime.GtfsRealtime;
@@ -34,35 +35,53 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-
-import java.time.*;
+import org.mapdb.Fun;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
 import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 
+import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 public class RealtimeFeed {
+    private static final Logger logger = LoggerFactory.getLogger(RealtimeFeed.class);
     private final IntHashSet blockedEdges;
-
     private final List<VirtualEdgeIteratorState> additionalEdges;
-
-    private RealtimeFeed(IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
+    private final GtfsRealtime.FeedMessage feedMessage;
+    private final GTFSFeed staticFeed;
+    private final Agency agency;
+
+    private RealtimeFeed(GTFSFeed feed, Agency agency, GtfsRealtime.FeedMessage feedMessage, IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
+        this.staticFeed = feed;
+        this.agency = agency;
+        this.feedMessage = feedMessage;
         this.blockedEdges = blockedEdges;
         this.additionalEdges = additionalEdges;
     }
 
     public static RealtimeFeed empty() {
-        return new RealtimeFeed(new IntHashSet(), Collections.emptyList());
+        return new RealtimeFeed(null, null, null, new IntHashSet(), Collections.emptyList());
     }
 
     public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
-        String feedKey = "gtfs_0"; //FIXME
+        String feedKey = "gtfs_0";
         GTFSFeed feed = staticGtfs.getGtfsFeeds().get(feedKey);
+        // TODO: Require configuration of feed and agency this realtime feed is for.
+        Agency agency = feed.agency.values().iterator().next(); // Realtime feeds are always specific to an agency.
         final IntHashSet blockedEdges = new IntHashSet();
         feedMessage.getEntityList().stream()
             .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -70,6 +89,10 @@ public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtF
             .forEach(tripUpdate -> {
                 final int[] boardEdges = staticGtfs.getBoardEdgesForTrip().get(tripUpdate.getTrip());
                 final int[] leaveEdges = staticGtfs.getAlightEdgesForTrip().get(tripUpdate.getTrip());
+                if (boardEdges == null || leaveEdges == null) {
+                    logger.warn("Trip not found: {}", tripUpdate.getTrip());
+                    return;
+                }
                 tripUpdate.getStopTimeUpdateList().stream()
                         .filter(stopTimeUpdate -> stopTimeUpdate.getScheduleRelationship() == SKIPPED)
                         .mapToInt(stu -> stu.getStopSequence()-1) // stop sequence number is 1-based, not 0-based
@@ -222,7 +245,7 @@ public GraphExtension getExtension() {
         };
         final GtfsReader gtfsReader = new GtfsReader(feedKey, overlayGraph, encoder, null);
         Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
-        LocalDate dateToChange = timestamp.atZone(ZoneId.of(feed.agency.values().iterator().next().agency_timezone)).toLocalDate(); //FIXME
+        LocalDate dateToChange = timestamp.atZone(ZoneId.of(agency.agency_timezone)).toLocalDate(); //FIXME
 
         feedMessage.getEntityList().stream()
                 .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -238,9 +261,9 @@ public GraphExtension getExtension() {
                                 stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
                                 stopTime.stop_id = stopTimeUpdate.getStopId();
                                 stopTime.trip_id = trip.trip_id;
-                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
                                 stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
-                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
                                 stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
                                 return stopTime;
                             })
@@ -250,10 +273,10 @@ public GraphExtension getExtension() {
                     validOnDay.set((int) DAYS.between(startDate, dateToChange));
                     return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
                 })
-                .forEach(trip -> gtfsReader.addTrips(ZoneId.systemDefault(), Collections.singletonList(trip), 0));
+                .forEach(trip -> gtfsReader.addTrips(ZoneId.of(agency.agency_timezone), Collections.singletonList(trip), 0));
         gtfsReader.wireUpStops();
         gtfsReader.connectStopsToStationNodes();
-        return new RealtimeFeed(blockedEdges, additionalEdges);
+        return new RealtimeFeed(feed, agency, feedMessage, blockedEdges, additionalEdges);
     }
 
     boolean isBlocked(int edgeId) {
@@ -264,4 +287,102 @@ boolean isBlocked(int edgeId) {
         return additionalEdges;
     }
 
+    public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GtfsRealtime.TripDescriptor tripDescriptor) {
+        if (feedMessage == null) {
+            return Optional.empty();
+        } else {
+            return feedMessage.getEntityList().stream()
+                    .filter(e -> e.hasTripUpdate())
+                    .map(e -> e.getTripUpdate())
+                    .filter(tu -> tu.getTrip().equals(tripDescriptor))
+                    .map(tu -> toTripWithStopTimes(staticFeed, agency, tu))
+                    .findFirst();
+        }
+    }
+
+    public static GtfsReader.TripWithStopTimes toTripWithStopTimes(GTFSFeed feed, Agency agency, GtfsRealtime.TripUpdate tripUpdate) {
+        logger.trace("{}", tripUpdate.getTrip());
+        final List<StopTime> stopTimes = new ArrayList<>();
+        Trip originalTrip = feed.trips.get(tripUpdate.getTrip().getTripId());
+        Trip trip = new Trip();
+        if (originalTrip != null) {
+            trip.trip_id = originalTrip.trip_id;
+            trip.route_id = originalTrip.route_id;
+        } else {
+            trip.trip_id = tripUpdate.getTrip().getTripId();
+            trip.route_id = tripUpdate.getTrip().getRouteId();
+        }
+        int delay = 0;
+        int time = -1;
+        List<GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdateListWithSentinel = new ArrayList<>(tripUpdate.getStopTimeUpdateList());
+        Iterable<StopTime> interpolatedStopTimesForTrip;
+        try {
+            interpolatedStopTimesForTrip = feed.getInterpolatedStopTimesForTrip(tripUpdate.getTrip().getTripId());
+        } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) {
+            throw new RuntimeException(firstAndLastStopsDoNotHaveTimes);
+        }
+        int stopSequenceCeiling = Math.max(stopTimeUpdateListWithSentinel.isEmpty() ? 0 : stopTimeUpdateListWithSentinel.get(stopTimeUpdateListWithSentinel.size() - 1).getStopSequence(),
+                StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).mapToInt(stopTime -> stopTime.stop_sequence).max().orElse(0)
+        ) + 1;
+        stopTimeUpdateListWithSentinel.add(GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder().setStopSequence(stopSequenceCeiling).setScheduleRelationship(NO_DATA).build());
+        for (GtfsRealtime.TripUpdate.StopTimeUpdate stopTimeUpdate : stopTimeUpdateListWithSentinel) {
+            int nextStopSequence = stopTimes.isEmpty() ? 1 : stopTimes.get(stopTimes.size()-1).stop_sequence+1;
+            for (int i=nextStopSequence; i<stopTimeUpdate.getStopSequence(); i++) {
+                StopTime previousOriginalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), i));
+                if (previousOriginalStopTime == null) {
+                    continue; // This can and does happen. Stop sequence numbers can be left out.
+                }
+                StopTime updatedPreviousStopTime = previousOriginalStopTime.clone();
+                updatedPreviousStopTime.arrival_time = Math.max(previousOriginalStopTime.arrival_time + delay, time);
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", i, previousOriginalStopTime.arrival_time, updatedPreviousStopTime.arrival_time);
+                time = updatedPreviousStopTime.arrival_time;
+                updatedPreviousStopTime.departure_time = Math.max(previousOriginalStopTime.departure_time + delay, time);
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", i, previousOriginalStopTime.departure_time, updatedPreviousStopTime.departure_time);
+                time = updatedPreviousStopTime.departure_time;
+                stopTimes.add(updatedPreviousStopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
+            }
+
+            final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTimeUpdate.getStopSequence()));
+            if (originalStopTime != null) {
+                StopTime updatedStopTime = originalStopTime.clone();
+                if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
+                    delay = 0;
+                }
+                if (stopTimeUpdate.hasArrival()) {
+                    delay = stopTimeUpdate.getArrival().getDelay();
+                }
+                updatedStopTime.arrival_time = Math.max(originalStopTime.arrival_time + delay, time);
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopTimeUpdate.getStopSequence(), originalStopTime.arrival_time, updatedStopTime.arrival_time);
+                time = updatedStopTime.arrival_time;
+                if (stopTimeUpdate.hasDeparture()) {
+                    delay = stopTimeUpdate.getDeparture().getDelay();
+                }
+                updatedStopTime.departure_time = Math.max(originalStopTime.departure_time + delay, time);
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopTimeUpdate.getStopSequence(), originalStopTime.departure_time, updatedStopTime.departure_time);
+                time = updatedStopTime.departure_time;
+                stopTimes.add(updatedStopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
+            } else if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
+            } else if (tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED) {
+                final StopTime stopTime = new StopTime();
+                stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
+                stopTime.stop_id = stopTimeUpdate.getStopId();
+                stopTime.trip_id = trip.trip_id;
+                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
+                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
+                stopTimes.add(stopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
+            } else {
+                throw new RuntimeException();
+            }
+        }
+        logger.trace("Number of stop times: {}", stopTimes.size());
+        BitSet validOnDay = new BitSet(); // Not valid on any day. Just a template.
+        return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
+    }
+
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 0afaaa4666..baa450d90c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -21,6 +21,8 @@
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Stop;
 import com.conveyal.gtfs.model.StopTime;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.Trip;
 import com.graphhopper.gtfs.fare.Fares;
@@ -31,6 +33,8 @@
 import com.vividsolutions.jts.geom.Geometry;
 import com.vividsolutions.jts.geom.GeometryFactory;
 import org.mapdb.Fun;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.time.Duration;
 import java.time.Instant;
@@ -38,11 +42,24 @@
 import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 import static com.graphhopper.reader.gtfs.Label.reverseEdges;
+import static java.time.temporal.ChronoUnit.SECONDS;
 
 class TripFromLabel {
 
+    private static final Logger logger = LoggerFactory.getLogger(TripFromLabel.class);
+
+    private final GtfsStorage gtfsStorage;
+    private final RealtimeFeed realtimeFeed;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
+
+    TripFromLabel(GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
+        this.gtfsStorage = gtfsStorage;
+        this.realtimeFeed = realtimeFeed;
+    }
+
     PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
         final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         return createPathWrapper(tr, waypoints, legs);
@@ -51,11 +68,11 @@ PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Trans
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
-            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).departureTime.getTime() - (accessLeg.arrivalTime.getTime() - accessLeg.departureTime.getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).departureTime));
+            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).getDepartureTime().getTime() - (accessLeg.getArrivalTime().getTime() - accessLeg.getDepartureTime().getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).getDepartureTime()));
         }
         if (legs.size() > 1 && legs.get(legs.size()-1) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg egressLeg = (Trip.WalkLeg) legs.get(legs.size()-1);
-            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size()-2).arrivalTime, egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size()-2).arrivalTime.getTime() + (egressLeg.arrivalTime.getTime() - egressLeg.departureTime.getTime()))));
+            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size() - 2).getArrivalTime(), egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size() - 2).getArrivalTime().getTime() + (egressLeg.getArrivalTime().getTime() - egressLeg.getDepartureTime().getTime()))));
         }
 
         PathWrapper path = new PathWrapper();
@@ -71,7 +88,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         }
         path.setPoints(pointsList);
         path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((legs.get(legs.size()-1).arrivalTime.toInstant().toEpochMilli() - legs.get(0).departureTime.toInstant().toEpochMilli()));
+        path.setTime((legs.get(legs.size() - 1).getArrivalTime().toInstant().toEpochMilli() - legs.get(0).getDepartureTime().toInstant().toEpochMilli()));
         path.setNumChanges((int) path.getLegs().stream()
                 .filter(l -> l instanceof Trip.PtLeg)
                 .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
@@ -82,13 +99,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
                 .map(leg -> (Trip.PtLeg) leg)
                 .findFirst()
                 .ifPresent(firstPtLeg -> {
-                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
+                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.getDepartureTime());
                     path.getLegs().stream()
                             .filter(leg -> leg instanceof Trip.PtLeg)
                             .map(leg -> (Trip.PtLeg) leg)
                             .map(ptLeg -> {
                                 final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feed_id);
-                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
+                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.getDepartureTime())).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
                             })
                             .forEach(faresTrip.segments::add);
                     Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
@@ -175,57 +192,96 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
 
     private class StopsFromBoardHopDwellEdges {
 
-        private final String tripId;
+        private final GtfsRealtime.TripDescriptor tripDescriptor;
         private final List<Trip.Stop> stops = new ArrayList<>();
         private final GTFSFeed gtfsFeed;
-        private long arrivalTimeFromHopEdge;
-        private Stop stop = null;
+        private Instant arrivalTimeFromHopEdge;
+        private Optional<Instant> updatedArrival;
+        private StopTime stopTime = null;
+        private final GtfsReader.TripWithStopTimes tripUpdate;
 
-        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
-            this.tripId = tripId;
+        StopsFromBoardHopDwellEdges(String feedId, GtfsRealtime.TripDescriptor tripDescriptor) {
+            this.tripDescriptor = tripDescriptor;
             this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
+            this.tripUpdate = realtimeFeed.getTripUpdate(tripDescriptor).orElse(null);
+            if (this.tripUpdate != null) {
+                validateTripUpdate(this.tripUpdate);
+            }
         }
 
         void next(Label.Transition t) {
-            long departureTime;
             switch (t.edge.edgeType) {
-                case BOARD:
-                    stop = findStop(t);
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
+                case BOARD: {
+                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
+                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
+                    Optional<Instant> updatedDeparture = getDepartureDelay(stopSequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
+                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, null, null, updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
                     break;
-                case HOP:
-                    stop = findStop(t);
-                    arrivalTimeFromHopEdge = t.label.currentTime;
+                }
+                case HOP: {
+                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
+                    arrivalTimeFromHopEdge = Instant.ofEpochMilli(t.label.currentTime);
+                    updatedArrival = getArrivalDelay(stopSequence).map(delay -> arrivalTimeFromHopEdge.plus(delay, SECONDS));
                     break;
-                case DWELL:
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
+                }
+                case DWELL: {
+                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
+                    Optional<Instant> updatedDeparture = getDepartureDelay(stopTime.stop_sequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
+                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
                     break;
-                default:
+                }
+                default: {
                     throw new RuntimeException();
+                }
             }
         }
 
-        private Stop findStop(Label.Transition t) {
-            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
-            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
-            return gtfsFeed.stops.get(stopTime.stop_id);
+        private Optional<Integer> getArrivalDelay(int stopSequence) {
+            if (tripUpdate != null) {
+                int arrival_time = tripUpdate.stopTimes.stream().filter(st -> st.stop_sequence == stopSequence).findFirst().orElseThrow(() -> new RuntimeException("Stop time not found.")).arrival_time;
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopSequence, stopTime.arrival_time, arrival_time);
+                return Optional.of(arrival_time - stopTime.arrival_time);
+            } else {
+                return Optional.empty();
+            }
         }
 
-        void finish() {
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
+        private Optional<Integer> getDepartureDelay(int stopSequence) {
+            if (tripUpdate != null) {
+                int departure_time = tripUpdate.stopTimes.stream().filter(st -> st.stop_sequence == stopSequence).findFirst().orElseThrow(() -> new RuntimeException("Stop time not found.")).departure_time;
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopSequence, stopTime.departure_time, departure_time);
+                return Optional.of(departure_time - stopTime.departure_time);
+            } else {
+                return Optional.empty();
+            }
         }
 
-    }
-
-
-    private final GtfsStorage gtfsStorage;
-    private final GeometryFactory geometryFactory = new GeometryFactory();
+        void finish() {
+            Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), null, null, null));
+            for (Trip.Stop tripStop : stops) {
+                logger.trace("{}", tripStop);
+            }
+        }
 
-    TripFromLabel(GtfsStorage gtfsStorage) {
+        private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
+            com.conveyal.gtfs.model.Trip originalTrip = gtfsFeed.trips.get(tripUpdate.trip.trip_id);
+            try {
+                Iterable<StopTime> interpolatedStopTimesForTrip = gtfsFeed.getInterpolatedStopTimesForTrip(tripUpdate.trip.trip_id);
+                long nStopTimes = StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).count();
+                logger.trace("Original stop times: {} Updated stop times: {}", nStopTimes, tripUpdate.stopTimes.size());
+                if (nStopTimes != tripUpdate.stopTimes.size()) {
+                    logger.error("Original stop times: {} Updated stop times: {}", nStopTimes, tripUpdate.stopTimes.size());
+                }
+            } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) {
+                throw new RuntimeException(firstAndLastStopsDoNotHaveTimes);
+            }
+        }
 
-        this.gtfsStorage = gtfsStorage;
     }
 
     // We are parsing a string of edges into a hierarchical trip.
@@ -254,25 +310,28 @@ void finish() {
                 }
                 if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
                     Geometry lineString = lineStringFromEdges(partition);
-                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
-                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
+                    GtfsRealtime.TripDescriptor tripDescriptor;
+                    try {
+                        tripDescriptor = GtfsRealtime.TripDescriptor.parseFrom(gtfsStorage.getTripDescriptors().get(partition.get(0).edge.edgeIteratorState.getEdge()));
+                    } catch (InvalidProtocolBufferException e) {
+                        throw new RuntimeException(e);
+                    }
+                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripDescriptor);
                     partition.stream()
                             .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
                             .forEach(stopsFromBoardHopDwellEdges::next);
                     stopsFromBoardHopDwellEdges.finish();
                     List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
 
-                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
+                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripDescriptor.getTripId());
                     result.add(new Trip.PtLeg(
                             feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
-                            tripId,
+                            tripDescriptor.getTripId(),
                             trip.route_id,
                             edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
-                            new Date(boardTime),
                             stops,
                             partition.stream().mapToDouble(t -> t.edge.distance).sum(),
                             path.get(i-1).label.currentTime - boardTime,
-                            new Date(path.get(i-1).label.currentTime),
                             lineString));
                     partition = null;
                 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index d94d1419e5..5d5ffbfc73 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -182,7 +182,7 @@ public void testRoute1ProfileEarliestArrival() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
@@ -209,7 +209,7 @@ public void testRoute1ProfileLatestDeparture() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "12:44", "12:14", "11:44", "11:14")
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 676500e16b..f0200d359e 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -77,10 +77,10 @@ public void testDepartureTimeOfAccessLeg() {
 
         GHResponse response = graphHopper.route(ghRequest);
 
-        assertThat(response.getAll().get(0).getLegs().get(0).departureTime.toInstant().atZone(zoneId).toLocalTime())
+        assertThat(response.getAll().get(0).getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
                 .isEqualTo("06:41:06");
-        assertThat(response.getAll().get(0).getLegs().get(0).arrivalTime.toInstant())
-                .isEqualTo(response.getAll().get(0).getLegs().get(1).departureTime.toInstant());
+        assertThat(response.getAll().get(0).getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(response.getAll().get(0).getLegs().get(1).getDepartureTime().toInstant());
     }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 47bc982462..be8b1476a6 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -30,14 +30,21 @@
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
-import java.time.*;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
 import java.util.Arrays;
 import java.util.Collections;
 
 import static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED;
+import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -51,7 +58,7 @@
     private static LocationIndex locationIndex;
 
     @BeforeClass
-    public static void init() {
+    public static void init() throws InterruptedException {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
@@ -59,6 +66,12 @@ public static void init() {
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage.close();
+        locationIndex.close();
+        // Re-load read only
+        directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
 
@@ -68,6 +81,7 @@ public static void close() {
         locationIndex.close();
     }
 
+
     @Test
     public void testSkipDepartureStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -161,7 +175,7 @@ public void testSkipTransferStop() {
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
     }
 
-    @Test
+    @Test @Ignore //Pending feature
     public void testExtraTrip() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
@@ -213,6 +227,126 @@ public void testExtraTrip() {
         assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
     }
 
+    @Test
+    public void testZeroDelay() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        GHResponse responseWithoutRealtimeUpdate = graphHopperFactory.createWithoutRealtimeFeed().route(ghRequest);
+
+        // The 6:00 departure of my line is going to be "late" by 0 minutes
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(5)
+                .setScheduleRelationship(SCHEDULED)
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(0).build());
+
+        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, responseWithRealtimeUpdate.getAll().size());
+
+        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(responseWithRealtimeUpdate.getBest().getLegs().size()-2);
+        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(responseWithoutRealtimeUpdate.getBest().getLegs().size()-2);
+        assertEquals("My planned arrival time is correct.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).plannedArrivalTime.toInstant());
+        assertEquals("My expected arrival time is the same.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).predictedArrivalTime.toInstant());
+        assertEquals("The trip without realtime update does not have an expected arrival time.", null, responseWithoutRealtimeUpdateBest.stops.get(responseWithoutRealtimeUpdateBest.stops.size()-1).predictedArrivalTime);
+
+//        assertEquals(responseWithoutRealtimeUpdateBest.toString(), responseWithRealtimeUpdateBest.toString());
+    }
+
+    @Test
+    public void testDelayWithoutTransfer() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // The 6:00 departure of my line is going to be late by 3 minutes
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(4)
+                .setScheduleRelationship(SCHEDULED)
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, response.getAll().size());
+
+        assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
+    }
+
+
+    @Test
+    public void testDelayFromBeginningWithoutTransfer() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // The 6:00 departure of my line is going to be "late" by 0 minutes
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(1)
+                .setScheduleRelationship(SCHEDULED)
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, response.getAll().size());
+
+        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size() - 2));
+        assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), ptLeg.getArrivalTime().toInstant());
+        assertEquals("It is still reporting its original, scheduled time.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
+    }
 
     @Test
     public void testBlockTrips() {
@@ -244,4 +378,4 @@ public void testBlockTrips() {
     }
 
 
-}
+}
\ No newline at end of file
diff --git a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java b/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
index 004ee0af4a..b61a125ec0 100644
--- a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
+++ b/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
@@ -21,11 +21,9 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.change.ChangeGraphHelper;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.FilenameFilter;
-import java.io.Reader;
+import java.io.*;
+
+import static com.graphhopper.util.Helper.UTF_CS;
 
 /**
  * Creates JsonFeature out of files and applies them to the graph.
@@ -51,7 +49,7 @@ public long applyChanges(String fileOrFolderStr) {
         File fileOrFolder = new File(fileOrFolderStr);
         try {
             if (fileOrFolder.isFile()) {
-                return applyChanges(new FileReader(fileOrFolder));
+                return applyChanges(new InputStreamReader(new FileInputStream(fileOrFolder), UTF_CS));
             }
 
             long sum = 0;
@@ -62,7 +60,7 @@ public boolean accept(File dir, String name) {
                 }
             });
             for (File f : fList) {
-                sum += applyChanges(new FileReader(f));
+                sum += applyChanges(new InputStreamReader(new FileInputStream(f), UTF_CS));
             }
             return sum;
 
diff --git a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
index 33cc90ea75..37c472f385 100644
--- a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
+++ b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
@@ -12,16 +12,17 @@
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.PMap;
-import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.FileReader;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
 
+import static com.graphhopper.util.Helper.UTF_CS;
+
 /**
  * Helper class to build the spatial rule index
  *
@@ -36,7 +37,7 @@ public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdA
         if (!spatialRuleLocation.isEmpty()) {
             try {
                 final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
-                final FileReader reader = new FileReader(spatialRuleLocation);
+                final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS);
                 final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
                 logger.info("Set spatial rule lookup with " + index.size() + " rules");
                 final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
@@ -58,7 +59,7 @@ public FlagEncoder createFlagEncoder(String name, PMap configuration) {
 
     public static JsonFeatureCollection createLandmarkSplittingFeatureCollection(String location) {
         try {
-            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
+            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(location), UTF_CS);
             return new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
         } catch (IOException e) {
             logger.error("Problem while reading border map GeoJSON. Skipping this.", e);
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 9621b33e92..1ab9b83aae 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -29,6 +29,7 @@
 import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.*;
 import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.dem.GraphElevationSmoothing;
 import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -85,6 +86,7 @@
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private boolean smoothElevation = false;
     private final boolean exitOnlyPillarNodeException = true;
     private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
     private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
@@ -681,6 +683,10 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long
         if (pointList.getDimension() != nodeAccess.getDimension())
             throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
 
+        // Smooth the elevation before calculating the distance because the distance will be incorrect if calculated afterwards
+        if (this.smoothElevation)
+            pointList = GraphElevationSmoothing.smoothElevation(pointList);
+
         double towerNodeDistance = 0;
         double prevLat = pointList.getLatitude(0);
         double prevLon = pointList.getLongitude(0);
@@ -882,6 +888,12 @@ public OSMReader setWayPointMaxDistance(double maxDist) {
         return this;
     }
 
+    @Override
+    public DataReader setSmoothElevation(boolean smoothElevation) {
+        this.smoothElevation = smoothElevation;
+        return this;
+    }
+
     @Override
     public OSMReader setWorkerThreads(int numOfWorkers) {
         this.workerThreads = numOfWorkers;
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 938ca0d7a3..ae39ec15ca 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -129,6 +129,35 @@ public void testMonacoWithInstructions() throws Exception {
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
+    @Test
+    public void testUTurn() throws Exception {
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/monaco.osm.gz").
+                setCHEnabled(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager("car"));
+        tmpHopper.importOrLoad();
+
+        GHRequest request = new GHRequest();
+        //Force initial U-Turn
+        request.addPoint(new GHPoint(43.743887, 7.431151), 200);
+        request.addPoint(new GHPoint(43.744007, 7.431076));
+
+        request.setAlgorithm(ASTAR).setVehicle("car").setWeighting(weightCalcStr);
+        GHResponse rsp = tmpHopper.route(request);
+
+        assertFalse(rsp.hasErrors());
+        PathWrapper arsp = rsp.getBest();
+        InstructionList il = arsp.getInstructions();
+        assertEquals(3, il.size());
+
+        List<Map<String, Object>> resultJson = il.createJson();
+        // Initial U-turn
+        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
+        // Second U-turn to get to destination
+        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
+    }
+
     @Test
     public void testAlternativeRoutes() {
         GHRequest req = new GHRequest(43.729057, 7.41251, 43.740298, 7.423561).
@@ -327,7 +356,7 @@ public void testMonacoVia() {
 
         PathWrapper arsp = rsp.getBest();
         assertEquals(6875.2, arsp.getDistance(), .1);
-        assertEquals(174, arsp.getPoints().getSize());
+        assertEquals(173, arsp.getPoints().getSize());
 
         InstructionList il = arsp.getInstructions();
         assertEquals(38, il.size());
@@ -339,6 +368,7 @@ public void testMonacoVia() {
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
 
         assertEquals("Waypoint 1", resultJson.get(20).get("text"));
+        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
 
         assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
         assertEquals("Turn left", resultJson.get(32).get("text"));
@@ -384,7 +414,7 @@ public void testMonacoVia() {
         arsp = rsp.getBest();
         assertEquals(0, arsp.getDistance(), .1);
         assertEquals(0, arsp.getRouteWeight(), .1);
-        assertEquals(2, arsp.getPoints().getSize());
+        assertEquals(1, arsp.getPoints().getSize());
         assertEquals(2, arsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().createJson().get(0).get("sign"));
         assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(1).get("sign"));
@@ -509,7 +539,7 @@ public void testMonacoStraightVia() {
 
         PathWrapper arsp = rsp.getBest();
         assertEquals(297, arsp.getDistance(), 5.);
-        assertEquals(24, arsp.getPoints().getSize());
+        assertEquals(23, arsp.getPoints().getSize());
 
         // test if start and first point are identical leading to an empty path, #788
         rq = new GHRequest().
@@ -531,7 +561,7 @@ public void testSRTMWithInstructions() throws Exception {
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+        tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
@@ -581,7 +611,7 @@ public void testSRTMWithoutTunnelInterpolation() throws Exception {
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
                 .setEncodingManager(new EncodingManager(importVehicles, 8));
 
-        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+        tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.74056471749763, 7.4299266210693755,
@@ -607,7 +637,7 @@ public void testSRTMWithTunnelInterpolation() throws Exception {
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
                 .setEncodingManager(new EncodingManager(genericImportVehicles, 8));
 
-        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+        tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.74056471749763, 7.4299266210693755,
@@ -656,6 +686,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
         assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
+        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
         assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
         assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
 
@@ -730,7 +761,7 @@ public void testCircularJunctionInstructionsWithCH() {
 
         assertEquals(2, tmpHopper.getCHFactoryDecorator().getPreparations().size());
 
-        GHResponse rsp = tmpHopper.route(new GHRequest(52.513505,13.350443, 52.513505,13.350245)
+        GHResponse rsp = tmpHopper.route(new GHRequest(52.513505, 13.350443, 52.513505, 13.350245)
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
         Instruction instr = rsp.getBest().getInstructions().get(1);
@@ -845,7 +876,49 @@ public void testRoundTour() {
         PathWrapper pw = rsp.getBest();
         assertEquals(1.45, rsp.getBest().getDistance() / 1000f, .01);
         assertEquals(17, rsp.getBest().getTime() / 1000f / 60, 1);
-        assertEquals(64, pw.getPoints().size());
+        assertEquals(63, pw.getPoints().size());
+    }
+
+    @Test
+    public void testPathDetails1216() {
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/north-bayreuth.osm.gz").
+                setCHEnabled(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager("car"));
+        tmpHopper.importOrLoad();
+
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.984352, 11.498802)).
+                // This is exactly between two edges with different speed values
+                        addPoint(new GHPoint(49.984565, 11.499188)).
+                        addPoint(new GHPoint(49.9847, 11.499612)).
+                        setVehicle("car").setWeighting("fastest").
+                        setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+
+        GHResponse rsp = tmpHopper.route(req);
+
+        assertFalse(rsp.hasErrors());
+    }
+
+    @Test
+    public void testPathDetailsSamePoint() {
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/north-bayreuth.osm.gz").
+                setCHEnabled(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager("car"));
+        tmpHopper.importOrLoad();
+
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.984352, 11.498802)).
+                addPoint(new GHPoint(49.984352, 11.498802)).
+                setVehicle("car").setWeighting("fastest").
+                setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+
+        GHResponse rsp = tmpHopper.route(req);
+
+        assertFalse(rsp.hasErrors());
     }
 
     @Test
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index bb588202cf..6fd91cc3b3 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -26,7 +26,6 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.lm.PrepareLandmarks;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.AbstractWeighting;
@@ -558,7 +557,7 @@ public void testVia() {
         assertFalse("should find 1->2->3", grsp.hasErrors());
         PathWrapper rsp = grsp.getBest();
         assertEquals(rsp12.getBest().getDistance() + rsp23.getBest().getDistance(), rsp.getDistance(), 1e-6);
-        assertEquals(5, rsp.getPoints().getSize());
+        assertEquals(4, rsp.getPoints().getSize());
         assertEquals(5, rsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
     }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 61efc52173..be7a6d0012 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -647,8 +647,7 @@ protected double getElevation(ReaderNode node) {
     public void testReadEleFromDataProvider() {
         GraphHopper hopper = new GraphHopperFacade("test-osm5.xml");
         // get N10E046.hgt.zip
-        ElevationProvider provider = new SRTMProvider();
-        provider.setCacheDir(new File(GraphHopperIT.DIR));
+        ElevationProvider provider = new SRTMProvider(GraphHopperIT.DIR);
         hopper.setElevationProvider(provider);
         hopper.importOrLoad();
 
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 2faaad9b6c..1f53faf8cb 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -309,7 +309,7 @@ public void testBug1014() {
         OneRun run = new OneRun();
         run.add(50.016923, 11.514187, 0, 0);
         run.add(50.019129, 11.500325, 0, 0);
-        run.add(50.023623, 11.56929, 7069, 180);
+        run.add(50.023623, 11.56929, 7069, 178);
         list.add(run);
 
         runAlgo(testCollector, DIR + "/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
@@ -486,6 +486,19 @@ public void testNeudrossenfeld() {
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testDisconnectedAreaAndMultiplePoints() {
+        List<OneRun> list = new ArrayList<OneRun>();
+        OneRun oneRun = new OneRun();
+        oneRun.add(53.753177, 9.435968, 10, 10);
+        oneRun.add(53.751299, 9.386959, 10, 10);
+        oneRun.add(53.751299, 9.3869, 10, 10);
+        list.add(oneRun);
+
+        runAlgo(testCollector, DIR + "/krautsand.osm.gz", "target/krautsand-gh",
+                list, "car", true, "car", "fastest", true);
+    }
+
     /**
      * @param withCH if true also the CH and LM algorithms will be tested which need
      *               preparation and takes a bit longer
@@ -509,6 +522,8 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
                     setGraphHopperLocation(graphFile).
                     setEncodingManager(new EncodingManager(importVehicles));
 
+            if (osmFile.contains("krautsand"))
+                hopper.setMinNetworkSize(0, 0);
             // avoid that path.getDistance is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
@@ -521,7 +536,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
                         setEnabled(true).setDisablingAllowed(true);
 
             if (is3D)
-                hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File(DIR)));
+                hopper.setElevationProvider(new SRTMProvider(DIR));
 
             hopper.importOrLoad();
 
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
index 00afc556b3..4ecb63dd91 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -42,6 +42,8 @@
 import java.util.HashSet;
 import java.util.List;
 
+import static com.graphhopper.util.Helper.*;
+
 /**
  * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
  * extracts the data as per the structure of shape files
@@ -56,11 +58,11 @@
     private static final String[] DIRECT_COPY_TAGS = new String[]{"name"};
     private File roadsFile;
     private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
-    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc distCalc = DIST_EARTH;
     private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
     private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
     private int nextNodeId = FIRST_NODE_ID;
-    private final String encoding= "utf8";
+    private final String encoding = "utf8";
 
     public OSMShapeFileReader(GraphHopperStorage ghStorage) {
         super(ghStorage);
@@ -246,6 +248,12 @@ public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
         return this;
     }
 
+    @Override
+    public DataReader setSmoothElevation(boolean smoothElevation) {
+        // TODO implement elevation smoothing for shape files
+        return this;
+    }
+
     @Override
     public Date getDataDate() {
         return null;
@@ -299,7 +307,7 @@ private void addEdge(int fromTower, int toTower, SimpleFeature road, double dist
             // shapefile.
             // We map back to the standard convention so that tag can be dealt
             // with correctly by the flag encoder.
-            String val = oneway.toString().trim().toLowerCase();
+            String val = toLowerCase(oneway.toString().trim());
             if (val.equals("b")) {
                 // both ways
                 val = "no";
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 7ec739bcea..7a8de1ac21 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -48,6 +48,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 
 /**
@@ -68,7 +69,7 @@ public static void main(String[] strs) {
     void start(CmdArgs args) {
         String graphLocation = args.get("graph.location", "");
         String propLocation = args.get("measurement.location", "");
-        if (Helper.isEmpty(propLocation))
+        if (isEmpty(propLocation))
             propLocation = "measurement" + new SimpleDateFormat("yyyy-MM-dd_HH_mm_ss").format(new Date()) + ".properties";
 
         seed = args.getLong("measurement.seed", 123);
@@ -161,8 +162,8 @@ protected DataReader importData() throws IOException {
             put("measurement.seed", seed);
             put("measurement.time", sw.stop().getTime());
             System.gc();
-            put("measurement.totalMB", Helper.getTotalMB());
-            put("measurement.usedMB", Helper.getUsedMB());
+            put("measurement.totalMB", getTotalMB());
+            put("measurement.usedMB", getUsedMB());
             try {
                 store(new FileWriter(propLocation), "measurement finish, "
                         + new Date().toString() + ", " + Constants.BUILD_DATE);
@@ -183,7 +184,7 @@ private GHBitSet printGraphDetails(GraphHopperStorage g, String vehicleStr) {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getMaxId());
-        put("graph.size_in_MB", g.getCapacity() / Helper.MB);
+        put("graph.size_in_MB", g.getCapacity() / MB);
         put("graph.encoder", vehicleStr);
 
         AllEdgesIterator iter = g.getAllEdges();
@@ -317,7 +318,7 @@ private void compareRouting(final GraphHopper hopper, String vehicle, int count)
 
             String infoStr = " weight:" + lmRsp.getBest().getRouteWeight() + ", original: " + originalRsp.getBest().getRouteWeight()
                     + " distance:" + lmRsp.getBest().getDistance() + ", original: " + originalRsp.getBest().getDistance()
-                    + " time:" + Helper.round2(lmRsp.getBest().getTime() / 1000) + ", original: " + Helper.round2(originalRsp.getBest().getTime() / 1000)
+                    + " time:" + round2(lmRsp.getBest().getTime() / 1000) + ", original: " + round2(originalRsp.getBest().getTime() / 1000)
                     + " points:" + lmRsp.getBest().getPoints().size() + ", original: " + originalRsp.getBest().getPoints().size();
 
             if (Math.abs(1 - lmRsp.getBest().getRouteWeight() / originalRsp.getBest().getRouteWeight()) > 0.000001)
@@ -367,7 +368,7 @@ private void compareCHWithAndWithoutSOD(final GraphHopper hopper, String vehicle
             String infoStr =
                     " weight:" + noSodRsp.getBest().getRouteWeight() + ", original: " + sodRsp.getBest().getRouteWeight()
                             + " distance:" + noSodRsp.getBest().getDistance() + ", original: " + sodRsp.getBest().getDistance()
-                            + " time:" + Helper.round2(noSodRsp.getBest().getTime() / 1000) + ", original: " + Helper.round2(sodRsp.getBest().getTime() / 1000)
+                            + " time:" + round2(noSodRsp.getBest().getTime() / 1000) + ", original: " + round2(sodRsp.getBest().getTime() / 1000)
                             + " points:" + noSodRsp.getBest().getPoints().size() + ", original: " + sodRsp.getBest().getPoints().size();
 
             if (Math.abs(1 - noSodRsp.getBest().getRouteWeight() / sodRsp.getBest().getRouteWeight()) > 0.000001)
@@ -434,7 +435,7 @@ public int doCalc(boolean warmup, int run) {
 
                     if (rsp.getErrors().get(0).getMessage() == null)
                         rsp.getErrors().get(0).printStackTrace();
-                    else if (!rsp.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                    else if (!toLowerCase(rsp.getErrors().get(0).getMessage()).contains("not found"))
                         logger.error("errors should NOT happen in Measurement! " + req + " => " + rsp.getErrors());
 
                     return 0;
diff --git a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
index 742923b5fc..e1c4bced19 100644
--- a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
+++ b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
@@ -41,16 +41,15 @@ public void handle(String str, Request req, HttpServletRequest httpReq, HttpServ
             url += "?" + httpReq.getQueryString();
 
         if (throwable != null) {
-            String message = throwable.getMessage();
-            logger.error(message + "! Via:" + url, throwable);
+            logger.error("Internal error for request " + url, throwable);
         } else {
             String message = (String) httpReq.getAttribute("javax.servlet.error.message");
             if (httpRes.getStatus() / 100 == 4) {
-                logger.warn(message + ", via:" + url);
+                logger.warn("Bad request '" + message + "' " + url);
             } else if (message != null) {
-                logger.error("Internal error " + message + "! Via:" + url);
+                logger.error("Internal error with message " + message + " for " + url);
             } else {
-                logger.error("Internal error " + str + ", throwable unknown! Via:" + url);
+                logger.error("Internal error with unknown throwable (" + str + ") for " + url);
             }
         }
 
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 3c0828a712..2386053a00 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -70,21 +70,20 @@ public void start(Injector injector) throws Exception {
         this.injector = injector;
         ResourceHandler resHandler = new ResourceHandler();
         resHandler.setDirectoriesListed(false);
-        resHandler.setWelcomeFiles(new String[]{
-                "index.html"
-        });
+        resHandler.setWelcomeFiles(new String[]{"index.html"});
         resHandler.setRedirectWelcome(false);
 
+        String contextPath = args.get("jetty.contextpath", "/");
         ContextHandler contextHandler = new ContextHandler();
-        contextHandler.setContextPath("/");
+        contextHandler.setErrorHandler(new GHErrorHandler());
+        contextHandler.setContextPath(contextPath);
         contextHandler.setBaseResource(Resource.newResource(args.get("jetty.resourcebase", "./web/src/main/webapp")));
         contextHandler.setHandler(resHandler);
 
         server = new Server();
         // getSessionHandler and getSecurityHandler should always return null
         ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
-        servHandler.setErrorHandler(new GHErrorHandler());
-        servHandler.setContextPath("/");
+        servHandler.setContextPath(contextPath);
 
         // Putting this here (and not in the guice servlet module) because it should take precedence
         // over more specific routes. And guice, strangely, is order-dependent (even though, except in the servlet
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
index bb85d59410..3454deb432 100644
--- a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -108,7 +108,7 @@ private String getMessage(Throwable t) {
 
                 jsonPath.put("snapped_waypoints", createPoints(ar.getWaypoints(), pointsEncoded, includeElevation));
                 if (ar.getFare() != null) {
-                    jsonPath.put("fare", NumberFormat.getCurrencyInstance().format(ar.getFare()));
+                    jsonPath.put("fare", NumberFormat.getCurrencyInstance(Locale.ROOT).format(ar.getFare()));
                 }
                 jsonPathList.add(jsonPath);
             }
diff --git a/web/src/main/webapp/img/direction-icons.svg b/web/src/main/webapp/img/direction-icons.svg
index a4a51d0f8f..d97df165ca 100644
--- a/web/src/main/webapp/img/direction-icons.svg
+++ b/web/src/main/webapp/img/direction-icons.svg
@@ -17,7 +17,7 @@
    inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
    inkscape:export-xdpi="134.39999"
    inkscape:export-ydpi="134.39999"
-   sodipodi:docname="left.svg">
+   sodipodi:docname="direction-icons.svg">
   <defs
      id="defs4">
     <marker
@@ -151,17 +151,22 @@
      borderopacity="1.0"
      inkscape:pageopacity="0.0"
      inkscape:pageshadow="2"
-     inkscape:zoom="2.8"
-     inkscape:cx="107.42943"
-     inkscape:cy="956.50972"
+     inkscape:zoom="3.959798"
+     inkscape:cx="93.18453"
+     inkscape:cy="865.72483"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      showgrid="false"
      inkscape:window-width="1920"
-     inkscape:window-height="1025"
+     inkscape:window-height="1026"
      inkscape:window-x="0"
      inkscape:window-y="0"
-     inkscape:window-maximized="1" />
+     inkscape:window-maximized="1"
+     showguides="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4267" />
+  </sodipodi:namedview>
   <metadata
      id="metadata7">
     <rdf:RDF>
@@ -170,7 +175,7 @@
         <dc:format>image/svg+xml</dc:format>
         <dc:type
            rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title></dc:title>
+        <dc:title />
       </cc:Work>
     </rdf:RDF>
   </metadata>
@@ -417,5 +422,78 @@
        d="m 143.94012,187.53763 c 0.29079,-21.60561 -2.82368,-24.68941 11.81123,-45.19825 l 5.53521,4.22349 c -13.38965,18.0529 -10.73771,18.20147 -11.07454,40.96696 z"
        style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:none;fill-opacity:1;stroke:#454545;stroke-width:1.50225437;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker:none;enable-background:accumulate"
        sodipodi:nodetypes="ccccc" />
+    <rect
+       style="fill:none;fill-opacity:1;stroke:none;stroke-width:0.101;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="rect4276-8"
+       width="57.85714"
+       height="61.42857"
+       x="-41.42857"
+       y="147.00507"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70"
+       transform="scale(-1,1)" />
+    <g
+       transform="matrix(0.78731598,-0.92691482,0.67619035,1.0792447,-42.098387,193.41103)"
+       id="g3928-3-3-9"
+       style="fill:#454545;fill-opacity:1"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70">
+      <path
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;enable-background:accumulate"
+         d="m 28.203018,20.77195 7.293457,6.468549 c 7.457643,-8.437252 12.94311,-16.87947 23.754619,-7.772992 10.778001,9.421424 -2.818211,21.92169 -10.062438,29.93397 4.051938,3.490253 3.635639,3.118539 7.573918,6.485115 C 65.717897,45.690879 82.708133,31.075913 63.552159,14.451975 47.244178,0.29958263 37.572444,9.8599329 28.203018,20.77195 Z"
+         id="path2985-5-8-6-7"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccccsc" />
+      <path
+         d="M 46.825302,26.816113 24.813116,31.774239 26.984505,9.577043 c 7.112389,10.242898 8.641167,11.555897 19.840797,17.23907 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3934-8-7-7"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccc" />
+    </g>
+    <rect
+       style="fill:none;fill-opacity:1;stroke:none;stroke-width:0.101;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="rect4276-8-5"
+       width="57.85714"
+       height="61.42857"
+       x="57.94455"
+       y="171.8571"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70" />
+    <g
+       transform="matrix(-0.78731598,-0.92691482,-0.67619035,1.0792447,141.47151,218.26305)"
+       id="g3928-3-3-9-2"
+       style="fill:#454545;fill-opacity:1"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70">
+      <path
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;enable-background:accumulate"
+         d="m 28.203018,20.77195 7.293457,6.468549 c 7.457643,-8.437252 12.94311,-16.87947 23.754619,-7.772992 10.778001,9.421424 -2.818211,21.92169 -10.062438,29.93397 4.051938,3.490253 3.635639,3.118539 7.573918,6.485115 C 65.717897,45.690879 82.708133,31.075913 63.552159,14.451975 47.244178,0.29958263 37.572444,9.8599329 28.203018,20.77195 Z"
+         id="path2985-5-8-6-7-6"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccccsc" />
+      <path
+         d="M 46.825302,26.816113 24.813116,31.774239 26.984505,9.577043 c 7.112389,10.242898 8.641167,11.555897 19.840797,17.23907 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3934-8-7-7-5"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccc" />
+    </g>
   </g>
 </svg>
diff --git a/web/src/main/webapp/img/u_turn.png b/web/src/main/webapp/img/u_turn.png
new file mode 100644
index 0000000000..453d682af0
Binary files /dev/null and b/web/src/main/webapp/img/u_turn.png differ
diff --git a/web/src/main/webapp/img/u_turn_left.png b/web/src/main/webapp/img/u_turn_left.png
new file mode 100644
index 0000000000..453d682af0
Binary files /dev/null and b/web/src/main/webapp/img/u_turn_left.png differ
diff --git a/web/src/main/webapp/img/u_turn_right.png b/web/src/main/webapp/img/u_turn_right.png
new file mode 100644
index 0000000000..91b847ce7b
Binary files /dev/null and b/web/src/main/webapp/img/u_turn_right.png differ
diff --git a/web/src/main/webapp/js/config/options.js b/web/src/main/webapp/js/config/options.js
index a3c26593f7..97b4c687fd 100644
--- a/web/src/main/webapp/js/config/options.js
+++ b/web/src/main/webapp/js/config/options.js
@@ -12,5 +12,6 @@ exports.options = {
     environment: "development",
     routing: {host: '', api_key: ''},
     geocoding: {host: '', api_key: ''},
-    thunderforest: {api_key: ''}
+    thunderforest: {api_key: ''},
+    omniscale: {api_key: ''}
 };
\ No newline at end of file
diff --git a/web/src/main/webapp/js/config/tileLayers.js b/web/src/main/webapp/js/config/tileLayers.js
index f6d081d0c9..c19def0622 100644
--- a/web/src/main/webapp/js/config/tileLayers.js
+++ b/web/src/main/webapp/js/config/tileLayers.js
@@ -3,6 +3,10 @@ var tfAddition = '';
 if (ghenv.thunderforest.api_key)
     tfAddition = '?apikey=' + ghenv.thunderforest.api_key;
 
+var osAPIKey = 'mapsgraph-bf48cc0b';
+if (ghenv.omniscale.api_key)
+    osAPIKey = ghenv.omniscale.api_key;
+
 var osmAttr = '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors';
 
 // Automatically enable high-DPI tiles if provider and browser support it.
@@ -12,9 +16,9 @@ var lyrk = L.tileLayer('https://tiles.lyrk.org/' + (retinaTiles ? 'lr' : 'ls') +
     attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>'
 });
 
-var omniscale = L.tileLayer.wms('https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile', {
+var omniscale = L.tileLayer('https://maps.omniscale.net/v2/' +osAPIKey + '/style.default' + (retinaTiles ? '/hq.true' : '') + '/{z}/{x}/{y}.png', {
     layers: 'osm',
-    attribution: osmAttr + ', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'
+    attribution: osmAttr + ', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'
 });
 
 var openMapSurfer = L.tileLayer('http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}', {
diff --git a/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js b/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js
index 0fc12c21b7..76fe697f02 100644
--- a/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js
+++ b/web/src/main/webapp/js/lib/leaflet.elevation-0.0.4.min.js
@@ -1,2 +1,2 @@
 /*! leaflet.elevation 02-03-2016 */
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(a){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter;var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){var b=d(a.dist);return a.xDiagCoord=b,b}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(f,b.theme),this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(a){return d3.mouse(h.select("g"))[0]}).y(function(a){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_findItemForLatLng:function(a){var b=null,c=1/0;return this._data.forEach(function(d){var e=a.distanceTo(d.latlng);c>e&&(c=e,b=d)}),b},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,a);b.href="#",b.title=this.options.controlButton.title,L.Browser.touch?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){var b=this.options;b.imperial?a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){var b=this.options;b.imperial?a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(a,b,c){if(this._data&&0!==this._data.length){var d=d3.mouse(this._background.node()),e=this.options,f=this._data[this._findItemForX(d[0])],g=f.altitude,h=f.dist,i=f.latlng,j=e.hoverNumber.formatter(g,e.hoverNumber.decimalsY);e.hoverNumber.formatter(h,e.hoverNumber.decimalsX);this._showDiagramIndicator(f,d[0]);var k=this._map.latLngToLayerPoint(i);if(e.useHeightIndicator){if(!this._mouseHeightFocus){var l=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=l.append("svg:line").attr("class",e.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var m=this._pointG=l.append("g");m.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",e.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=l.append("svg:text").attr("class",e.theme+" height-focus-label").style("pointer-events","none")}var n=this._height()/this._maxElevation*g,o=k.y-n;this._mouseHeightFocus.attr("x1",k.x).attr("x2",k.x).attr("y1",k.y).attr("y2",o).style("visibility","visible"),this._pointG.attr("transform","translate("+k.x+","+k.y+")").style("visibility","visible"),e.imperial?this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(i):this._marker=new L.Marker(i).addTo(this._map)}},_addGeoJSONData:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=new L.LatLng(a[f][1],a[f][0]),h=new L.LatLng(a[f?f-1:0][1],a[f?f-1:0][0]),i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<a[f][2]?a[f][2]:e,c.push({dist:d,altitude:b.imperial?a[f][2]*this.__footFactor:a[f][2],x:a[f][0],y:a[f][1],latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addGPXdata:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=a[f],h=a[f?f-1:0],i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<g.meta.ele?g.meta.ele:e,c.push({dist:d,altitude:b.imperial?g.meta.ele*this.__footFactor:g.meta.ele,x:g.lng,y:g.lat,latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a,b){this._addData(a),this._container&&this._applyData(),null===b&&a.on&&(b=a),b&&b.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(a){if(this._data&&0!==this._data.length){var b=a.latlng,c=this._findItemForLatLng(b);if(c){var d=c.xDiagCoord;this._showDiagramIndicator(c,d)}}},_showDiagramIndicator:function(a,b){var c=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",b).attr("y1",0).attr("x2",b).attr("y2",this._height()).classed("hidden",!1);var d=a.altitude,e=a.dist,f=(a.latlng,c.hoverNumber.formatter(d,c.hoverNumber.decimalsY)),g=c.hoverNumber.formatter(e,c.hoverNumber.decimalsX);c.imperial?(this._focuslabelX.attr("x",b).text(f+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" mi")):(this._focuslabelX.attr("x",b).text(f+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" km"))},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
+L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(a){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter;var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){var b=d(a.dist);return a.xDiagCoord=b,b}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(f,b.theme),this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(a){return d3.mouse(h.select("g"))[0]}).y(function(a){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.mobile?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_findItemForLatLng:function(a){var b=null,c=1/0;return this._data.forEach(function(d){var e=a.distanceTo(d.latlng);c>e&&(c=e,b=d)}),b},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.mobile?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,a);b.href="#",b.title=this.options.controlButton.title,L.Browser.mobile?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){var b=this.options;b.imperial?a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){var b=this.options;b.imperial?a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(a,b,c){if(this._data&&0!==this._data.length){var d=d3.mouse(this._background.node()),e=this.options,f=this._data[this._findItemForX(d[0])],g=f.altitude,h=f.dist,i=f.latlng,j=e.hoverNumber.formatter(g,e.hoverNumber.decimalsY);e.hoverNumber.formatter(h,e.hoverNumber.decimalsX);this._showDiagramIndicator(f,d[0]);var k=this._map.latLngToLayerPoint(i);if(e.useHeightIndicator){if(!this._mouseHeightFocus){var l=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=l.append("svg:line").attr("class",e.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var m=this._pointG=l.append("g");m.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",e.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=l.append("svg:text").attr("class",e.theme+" height-focus-label").style("pointer-events","none")}var n=this._height()/this._maxElevation*g,o=k.y-n;this._mouseHeightFocus.attr("x1",k.x).attr("x2",k.x).attr("y1",k.y).attr("y2",o).style("visibility","visible"),this._pointG.attr("transform","translate("+k.x+","+k.y+")").style("visibility","visible"),e.imperial?this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(i):this._marker=new L.Marker(i).addTo(this._map)}},_addGeoJSONData:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=new L.LatLng(a[f][1],a[f][0]),h=new L.LatLng(a[f?f-1:0][1],a[f?f-1:0][0]),i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<a[f][2]?a[f][2]:e,c.push({dist:d,altitude:b.imperial?a[f][2]*this.__footFactor:a[f][2],x:a[f][0],y:a[f][1],latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addGPXdata:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=a[f],h=a[f?f-1:0],i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<g.meta.ele?g.meta.ele:e,c.push({dist:d,altitude:b.imperial?g.meta.ele*this.__footFactor:g.meta.ele,x:g.lng,y:g.lat,latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a,b){this._addData(a),this._container&&this._applyData(),null===b&&a.on&&(b=a),b&&b.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(a){if(this._data&&0!==this._data.length){var b=a.latlng,c=this._findItemForLatLng(b);if(c){var d=c.xDiagCoord;this._showDiagramIndicator(c,d)}}},_showDiagramIndicator:function(a,b){var c=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",b).attr("y1",0).attr("x2",b).attr("y2",this._height()).classed("hidden",!1);var d=a.altitude,e=a.dist,f=(a.latlng,c.hoverNumber.formatter(d,c.hoverNumber.decimalsY)),g=c.hoverNumber.formatter(e,c.hoverNumber.decimalsX);c.imperial?(this._focuslabelX.attr("x",b).text(f+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" mi")):(this._focuslabelX.attr("x",b).text(f+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" km"))},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index f46845ee7f..b13eb2c1d9 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -34,10 +34,10 @@ return this._update(),this._container},setPrefix:function(t){return this.options
 var formatTools=require("./tools/format.js"),GHInput=require("./graphhopper/GHInput.js"),GHRoute=require("./graphhopper/GHRoute.js"),mapLayer=require("./map.js"),dataToHtml=function(e,t){var o="";if(e.name)o+="<div class='nameseg'>"+formatTools.formatValue(e.name,t)+"</div>";else if(e.street){var a=e.street;e.housenumber&&(a=formatTools.insComma(a,e.housenumber)),o+="<div class='nameseg'>"+formatTools.formatValue(a,t)+"</div>"}var n="";return e.postcode&&(n=e.postcode),e.city&&(n=formatTools.insComma(n,e.city)),e.country&&(n=formatTools.insComma(n,e.country)),n&&(o+="<div class='cityseg'>"+formatTools.formatValue(n,t)+"</div>"),"highway"===e.osm_key,o+="place"===e.osm_key?"<span class='moreseg'>"+e.osm_value+"</span>":"<span class='moreseg'>"+e.osm_key+"</span>"},dataToText=function(e){var t="";return e.name?t=e.name:e.street&&(t=e.street,e.housenumber&&(t=formatTools.insComma(t,e.housenumber))),e.postcode&&(t=formatTools.insComma(t,e.postcode)),e.city&&t.indexOf(e.city)<0&&(t=formatTools.insComma(t,e.city)),e.country&&t.indexOf(e.country)<0&&(t=formatTools.insComma(t,e.country)),t},AutoComplete=function(e,t){this.host=e,this.key=t,this.dataType="json",this.api_params={locale:"en"}};AutoComplete.prototype.createPath=function(e){for(var t in this.api_params){var o=this.api_params[t];if(GHRoute.isArray(o))for(var a in o)e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o[a]);else e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o)}return e},AutoComplete.prototype.createGeocodeURL=function(e,t){var o=this.createPath(this.host+"/geocode?limit=6&type="+this.dataType+"&key="+this.key);if(t>=0&&t<e.route.size()){var a=e.route.getIndex(t);a.isResolved()&&(o+="&point="+a.lat+","+a.lng)}return o},AutoComplete.prototype.getAutoCompleteDiv=function(e){return $("#locationpoints > div.pointDiv").eq(e).find(".pointInput")},AutoComplete.prototype.hide=function(){$(':input[id$="_Input"]').autocomplete().hide()},AutoComplete.prototype.showListForIndex=function(e,t,o){var a=this.getAutoCompleteDiv(o),n=this.createGeocodeURL(e,o-1),r={containerClass:"autocomplete",timeout:1e3,deferRequestBy:5,minChars:2,maxHeight:510,noCache:!0,triggerSelectOnValidInput:!1,autoSelectFirst:!1,paramName:"q",dataType:e.dataType,onSearchStart:function(e){var t=new GHInput(e.q).lat;return void 0===t},serviceUrl:function(){return n},transformResult:function(e,t){if(e.suggestions=[],e.hits)for(var o=0;o<e.hits.length;o++){var a=e.hits[o];e.suggestions.push({value:dataToText(a),data:a})}return e},onSearchError:function(e,t,o,a,n){},formatResult:function(e,t){return dataToHtml(e.data,t)},onSelect:function(e){r.onPreSelect(e)},onPreSelect:function(n){var r=e.route.getIndex(o);a.autocomplete().disable();var s=n.data.point;r.setCoord(s.lat,s.lng),r.input=n.value,t(!0)||mapLayer.focus(r,15,o),a.autocomplete().enable()}};a.autocomplete(r)},AutoComplete.prototype.createStub=function(){return complete=new AutoComplete,complete.showListForIndex=function(){},complete.hide=function(){},complete},AutoComplete.prototype.setLocale=function(e){e&&(this.api_params.locale=e)},module.exports=AutoComplete;
 
 },{"./graphhopper/GHInput.js":12,"./graphhopper/GHRoute.js":14,"./map.js":23,"./tools/format.js":27}],9:[function(require,module,exports){
-exports.options={environment:"development",routing:{host:"",api_key:""},geocoding:{host:"",api_key:""},thunderforest:{api_key:""}};
+exports.options={environment:"development",routing:{host:"",api_key:""},geocoding:{host:"",api_key:""},thunderforest:{api_key:""},omniscale:{api_key:""}};
 
 },{}],10:[function(require,module,exports){
-var ghenv=require("./options.js").options,tfAddition="";ghenv.thunderforest.api_key&&(tfAddition="?apikey="+ghenv.thunderforest.api_key);var osmAttr='&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors',retinaTiles=L.Browser.retina,lyrk=L.tileLayer("https://tiles.lyrk.org/"+(retinaTiles?"lr":"ls")+"/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077",{attribution:osmAttr+', <a href="https://geodienste.lyrk.de/">Lyrk</a>'}),omniscale=L.tileLayer.wms("https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile",{layers:"osm",attribution:osmAttr+', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'}),openMapSurfer=L.tileLayer("http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}",{attribution:osmAttr+', <a href="http://korona.geog.uni-heidelberg.de/contact.html">GIScience Heidelberg</a>'}),sorbianLang=L.tileLayer("http://a.tile.openstreetmap.de/tiles/osmhrb/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'}),thunderTransport=L.tileLayer("https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/transport/" target="_blank">Thunderforest Transport</a>'}),thunderCycle=L.tileLayer("https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/opencyclemap/" target="_blank">Thunderforest Cycle</a>'}),thunderOutdoors=L.tileLayer("https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/outdoors/" target="_blank">Thunderforest Outdoors</a>'}),thunderNeighbourhood=L.tileLayer("https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://thunderforest.com/maps/neighbourhood/" target="_blank">Thunderforest Neighbourhood</a>'}),wrk=L.tileLayer("http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',subdomains:["topo4","topo","topo2","topo3"]}),osm=L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:osmAttr}),osmde=L.tileLayer("http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png",{attribution:osmAttr}),mapLink='<a href="http://www.esri.com/">Esri</a>',wholink="i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",esriAerial=L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",{attribution:"&copy; "+mapLink+", "+wholink,maxZoom:18}),availableTileLayers={Omniscale:omniscale,OpenStreetMap:osm,"Esri Aerial":esriAerial,"TF Transport":thunderTransport,"TF Cycle":thunderCycle,"TF Outdoors":thunderOutdoors,"TF Neighbourhood":thunderNeighbourhood,Lyrk:lyrk,WanderReitKarte:wrk,OpenMapSurfer:openMapSurfer,"Sorbian Language":sorbianLang,"OpenStreetMap.de":osmde};module.exports.activeLayerName="Omniscale",module.exports.defaultLayer=omniscale,module.exports.getAvailableTileLayers=function(){return availableTileLayers},module.exports.selectLayer=function(t){var e=availableTileLayers[t];return e||(e=module.exports.defaultLayer),e};
+var ghenv=require("./options.js").options,tfAddition="";ghenv.thunderforest.api_key&&(tfAddition="?apikey="+ghenv.thunderforest.api_key);var osAPIKey="mapsgraph-bf48cc0b";ghenv.omniscale.api_key&&(osAPIKey=ghenv.omniscale.api_key);var osmAttr='&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors',retinaTiles=L.Browser.retina,lyrk=L.tileLayer("https://tiles.lyrk.org/"+(retinaTiles?"lr":"ls")+"/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077",{attribution:osmAttr+', <a href="https://geodienste.lyrk.de/">Lyrk</a>'}),omniscale=L.tileLayer("https://maps.omniscale.net/v2/"+osAPIKey+"/style.default"+(retinaTiles?"/hq.true":"")+"/{z}/{x}/{y}.png",{layers:"osm",attribution:osmAttr+', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'}),openMapSurfer=L.tileLayer("http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}",{attribution:osmAttr+', <a href="http://korona.geog.uni-heidelberg.de/contact.html">GIScience Heidelberg</a>'}),sorbianLang=L.tileLayer("http://a.tile.openstreetmap.de/tiles/osmhrb/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'}),thunderTransport=L.tileLayer("https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/transport/" target="_blank">Thunderforest Transport</a>'}),thunderCycle=L.tileLayer("https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/opencyclemap/" target="_blank">Thunderforest Cycle</a>'}),thunderOutdoors=L.tileLayer("https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/outdoors/" target="_blank">Thunderforest Outdoors</a>'}),thunderNeighbourhood=L.tileLayer("https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://thunderforest.com/maps/neighbourhood/" target="_blank">Thunderforest Neighbourhood</a>'}),wrk=L.tileLayer("http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',subdomains:["topo4","topo","topo2","topo3"]}),osm=L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:osmAttr}),osmde=L.tileLayer("http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png",{attribution:osmAttr}),mapLink='<a href="http://www.esri.com/">Esri</a>',wholink="i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",esriAerial=L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",{attribution:"&copy; "+mapLink+", "+wholink,maxZoom:18}),availableTileLayers={Omniscale:omniscale,OpenStreetMap:osm,"Esri Aerial":esriAerial,"TF Transport":thunderTransport,"TF Cycle":thunderCycle,"TF Outdoors":thunderOutdoors,"TF Neighbourhood":thunderNeighbourhood,Lyrk:lyrk,WanderReitKarte:wrk,OpenMapSurfer:openMapSurfer,"Sorbian Language":sorbianLang,"OpenStreetMap.de":osmde};module.exports.activeLayerName="Omniscale",module.exports.defaultLayer=omniscale,module.exports.getAvailableTileLayers=function(){return availableTileLayers},module.exports.selectLayer=function(e){var t=availableTileLayers[e];return t||(t=module.exports.defaultLayer),t};
 
 },{"./options.js":9}],11:[function(require,module,exports){
 var ensureOneCheckboxSelected=function(){$("#gpx_route").change(function(){$(this).is(":checked")?($("#gpx_track").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_track").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_track").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_track").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_waypoints").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_track").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_track").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_track").prop("disabled",!0)})};module.exports.addGpxExport=function(e){function p(p,o,i){return e.route.isResolved()&&window.open(e.createGPXURL(p,o,i)),!1}function o(){return p($("#gpx_route").is(":checked"),$("#gpx_track").is(":checked"),$("#gpx_waypoints").is(":checked")),i.dialog("close"),!1}var i;$(function(){i=$("#gpx_dialog").dialog({width:420,height:260,autoOpen:!1,resizable:!1,draggable:!1,buttons:{"Export GPX":o,Cancel:function(){$(this).dialog("close")}}}),ensureOneCheckboxSelected()}),$("#gpxExportButton a").click(function(e){e.preventDefault(),$("#gpx_dialog").dialog("open")})};
@@ -67,7 +67,7 @@ at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).off
 !function(e,t){"use strict";var r=e.History=e.History||{},a=e.jQuery;if("undefined"!=typeof r.Adapter)throw new Error("History.js Adapter has already been loaded...");r.Adapter={bind:function(e,t,r){a(e).bind(t,r)},trigger:function(e,t,r){a(e).trigger(t,r)},extractEventData:function(e,r,a){var n=r&&r.originalEvent&&r.originalEvent[e]||a&&a[e]||t;return n},onDomLoad:function(e){a(e)}},"undefined"!=typeof r.init&&r.init()}(window),function(e,t){"use strict";var r=e.console||t,a=e.document,n=e.navigator,o=e.sessionStorage||!1,i=e.setTimeout,s=e.clearTimeout,u=e.setInterval,l=e.clearInterval,d=e.JSON,c=e.alert,p=e.History=e.History||{},f=e.history;try{o.setItem("TEST","1"),o.removeItem("TEST")}catch(e){o=!1}if(d.stringify=d.stringify||d.encode,d.parse=d.parse||d.decode,"undefined"!=typeof p.init)throw new Error("History.js Core has already been loaded...");p.init=function(e){return"undefined"!=typeof p.Adapter&&("undefined"!=typeof p.initCore&&p.initCore(),"undefined"!=typeof p.initHtml4&&p.initHtml4(),!0)},p.initCore=function(g){if("undefined"!=typeof p.initCore.initialized)return!1;if(p.initCore.initialized=!0,p.options=p.options||{},p.options.hashChangeInterval=p.options.hashChangeInterval||100,p.options.safariPollInterval=p.options.safariPollInterval||500,p.options.doubleCheckInterval=p.options.doubleCheckInterval||500,p.options.disableSuid=p.options.disableSuid||!1,p.options.storeInterval=p.options.storeInterval||1e3,p.options.busyDelay=p.options.busyDelay||250,p.options.debug=p.options.debug||!1,p.options.initialTitle=p.options.initialTitle||a.title,p.options.html4Mode=p.options.html4Mode||!1,p.options.delayInit=p.options.delayInit||!1,p.intervalList=[],p.clearAllIntervals=function(){var e,t=p.intervalList;if("undefined"!=typeof t&&null!==t){for(e=0;e<t.length;e++)l(t[e]);p.intervalList=null}},p.debug=function(){(p.options.debug||!1)&&p.log.apply(p,arguments)},p.log=function(){var e,t,n,o,i,s="undefined"!=typeof r&&"undefined"!=typeof r.log&&"undefined"!=typeof r.log.apply,u=a.getElementById("log");for(s?(o=Array.prototype.slice.call(arguments),e=o.shift(),"undefined"!=typeof r.debug?r.debug.apply(r,[e,o]):r.log.apply(r,[e,o])):e="\n"+arguments[0]+"\n",t=1,n=arguments.length;t<n;++t){if(i=arguments[t],"object"==typeof i&&"undefined"!=typeof d)try{i=d.stringify(i)}catch(e){}e+="\n"+i+"\n"}return u?(u.value+=e+"\n-----\n",u.scrollTop=u.scrollHeight-u.clientHeight):s||c(e),!0},p.getInternetExplorerMajorVersion=function(){var e=p.getInternetExplorerMajorVersion.cached="undefined"!=typeof p.getInternetExplorerMajorVersion.cached?p.getInternetExplorerMajorVersion.cached:function(){for(var e=3,t=a.createElement("div"),r=t.getElementsByTagName("i");(t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&r[0];);return e>4&&e}();return e},p.isInternetExplorer=function(){var e=p.isInternetExplorer.cached="undefined"!=typeof p.isInternetExplorer.cached?p.isInternetExplorer.cached:Boolean(p.getInternetExplorerMajorVersion());return e},p.options.html4Mode?p.emulated={pushState:!0,hashChange:!0}:p.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(n.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(n.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in a)||p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8)},p.enabled=!p.emulated.pushState,p.bugs={setHash:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),safariPoll:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===n.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(n.userAgent)),ieDoubleCheck:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<7)},p.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},p.cloneObject=function(e){var t,r;return e?(t=d.stringify(e),r=d.parse(t)):r={},r},p.getRootUrl=function(){var e=a.location.protocol+"//"+(a.location.hostname||a.location.host);return a.location.port&&(e+=":"+a.location.port),e+="/"},p.getBaseHref=function(){var e=a.getElementsByTagName("base"),t=null,r="";return 1===e.length&&(t=e[0],r=t.href.replace(/[^\/]+$/,"")),r=r.replace(/\/+$/,""),r&&(r+="/"),r},p.getBaseUrl=function(){var e=p.getBaseHref()||p.getBasePageUrl()||p.getRootUrl();return e},p.getPageUrl=function(){var e,t=p.getState(!1,!1),r=(t||{}).url||p.getLocationHref();return e=r.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,r){return/\./.test(e)?e:e+"/"})},p.getBasePageUrl=function(){var e=p.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,r){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},p.getFullUrl=function(e,t){var r=e,a=e.substring(0,1);return t="undefined"==typeof t||t,/[a-z]+\:\/\//.test(e)||(r="/"===a?p.getRootUrl()+e.replace(/^\/+/,""):"#"===a?p.getPageUrl().replace(/#.*/,"")+e:"?"===a?p.getPageUrl().replace(/[\?#].*/,"")+e:t?p.getBaseUrl()+e.replace(/^(\.\/)+/,""):p.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),r.replace(/\#$/,"")},p.getShortUrl=function(e){var t=e,r=p.getBaseUrl(),a=p.getRootUrl();return p.emulated.pushState&&(t=t.replace(r,"")),t=t.replace(a,"/"),p.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,"")},p.getLocationHref=function(e){return e=e||a,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},p.store={},p.idToState=p.idToState||{},p.stateToId=p.stateToId||{},p.urlToId=p.urlToId||{},p.storedStates=p.storedStates||[],p.savedStates=p.savedStates||[],p.normalizeStore=function(){p.store.idToState=p.store.idToState||{},p.store.urlToId=p.store.urlToId||{},p.store.stateToId=p.store.stateToId||{}},p.getState=function(e,t){"undefined"==typeof e&&(e=!0),"undefined"==typeof t&&(t=!0);var r=p.getLastSavedState();return!r&&t&&(r=p.createStateObject()),e&&(r=p.cloneObject(r),r.url=r.cleanUrl||r.url),r},p.getIdByState=function(e){var t,r=p.extractId(e.url);if(!r)if(t=p.getStateString(e),"undefined"!=typeof p.stateToId[t])r=p.stateToId[t];else if("undefined"!=typeof p.store.stateToId[t])r=p.store.stateToId[t];else{for(;r=(new Date).getTime()+String(Math.random()).replace(/\D/g,""),"undefined"!=typeof p.idToState[r]||"undefined"!=typeof p.store.idToState[r];);p.stateToId[t]=r,p.idToState[r]=e}return r},p.normalizeState=function(e){var t,r;return e&&"object"==typeof e||(e={}),"undefined"!=typeof e.normalized?e:(e.data&&"object"==typeof e.data||(e.data={}),t={},t.normalized=!0,t.title=e.title||"",t.url=p.getFullUrl(e.url?e.url:p.getLocationHref()),t.hash=p.getShortUrl(t.url),t.data=p.cloneObject(e.data),t.id=p.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,r=!p.isEmptyObject(t.data),(t.title||r)&&p.options.disableSuid!==!0&&(t.hash=p.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=p.getFullUrl(t.hash),(p.emulated.pushState||p.bugs.safariPoll)&&p.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t)},p.createStateObject=function(e,t,r){var a={data:e,title:t,url:r};return a=p.normalizeState(a)},p.getStateById=function(e){e=String(e);var r=p.idToState[e]||p.store.idToState[e]||t;return r},p.getStateString=function(e){var t,r,a;return t=p.normalizeState(e),r={data:t.data,title:e.title,url:e.url},a=d.stringify(r)},p.getStateId=function(e){var t,r;return t=p.normalizeState(e),r=t.id},p.getHashByState=function(e){var t,r;return t=p.normalizeState(e),r=t.hash},p.extractId=function(e){var t,r,a,n;return n=e.indexOf("#")!=-1?e.split("#")[0]:e,r=/(.*)\&_suid=([0-9]+)$/.exec(n),a=r?r[1]||e:e,t=r?String(r[2]||""):"",t||!1},p.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},p.extractState=function(e,t){var r,a,n=null;return t=t||!1,r=p.extractId(e),r&&(n=p.getStateById(r)),n||(a=p.getFullUrl(e),r=p.getIdByUrl(a)||!1,r&&(n=p.getStateById(r)),!n&&t&&!p.isTraditionalAnchor(e)&&(n=p.createStateObject(null,null,a))),n},p.getIdByUrl=function(e){var r=p.urlToId[e]||p.store.urlToId[e]||t;return r},p.getLastSavedState=function(){return p.savedStates[p.savedStates.length-1]||t},p.getLastStoredState=function(){return p.storedStates[p.storedStates.length-1]||t},p.hasUrlDuplicate=function(e){var t,r=!1;return t=p.extractState(e.url),r=t&&t.id!==e.id},p.storeState=function(e){return p.urlToId[e.url]=e.id,p.storedStates.push(p.cloneObject(e)),e},p.isLastSavedState=function(e){var t,r,a,n=!1;return p.savedStates.length&&(t=e.id,r=p.getLastSavedState(),a=r.id,n=t===a),n},p.saveState=function(e){return!p.isLastSavedState(e)&&(p.savedStates.push(p.cloneObject(e)),!0)},p.getStateByIndex=function(e){var t=null;return t="undefined"==typeof e?p.savedStates[p.savedStates.length-1]:e<0?p.savedStates[p.savedStates.length+e]:p.savedStates[e]},p.getCurrentIndex=function(){var e=null;return e=p.savedStates.length<1?0:p.savedStates.length-1},p.getHash=function(e){var t,r=p.getLocationHref(e);return t=p.getHashByUrl(r)},p.unescapeHash=function(e){var t=p.normalizeHash(e);return t=decodeURIComponent(t)},p.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},p.setHash=function(e,t){var r,n;return t!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.setHash,args:arguments,queue:t}),!1):(p.busy(!0),r=p.extractState(e,!0),r&&!p.emulated.pushState?p.pushState(r.data,r.title,r.url,!1):p.getHash()!==e&&(p.bugs.setHash?(n=p.getPageUrl(),p.pushState(null,null,n+"#"+e,!1)):a.location.hash=e),p)},p.escapeHash=function(t){var r=p.normalizeHash(t);return r=e.encodeURIComponent(r),p.bugs.hashEscape||(r=r.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),r},p.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=p.unescapeHash(t)},p.setTitle=function(e){var t,r=e.title;r||(t=p.getStateByIndex(0),t&&t.url===e.url&&(r=t.title||p.options.initialTitle));try{a.getElementsByTagName("title")[0].innerHTML=r.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(e){}return a.title=r,p},p.queues=[],p.busy=function(e){if("undefined"!=typeof e?p.busy.flag=e:"undefined"==typeof p.busy.flag&&(p.busy.flag=!1),!p.busy.flag){s(p.busy.timeout);var t=function(){var e,r,a;if(!p.busy.flag)for(e=p.queues.length-1;e>=0;--e)r=p.queues[e],0!==r.length&&(a=r.shift(),p.fireQueueItem(a),p.busy.timeout=i(t,p.options.busyDelay))};p.busy.timeout=i(t,p.options.busyDelay)}return p.busy.flag},p.busy.flag=!1,p.fireQueueItem=function(e){return e.callback.apply(e.scope||p,e.args||[])},p.pushQueue=function(e){return p.queues[e.queue||0]=p.queues[e.queue||0]||[],p.queues[e.queue||0].push(e),p},p.queue=function(e,t){return"function"==typeof e&&(e={callback:e}),"undefined"!=typeof t&&(e.queue=t),p.busy()?p.pushQueue(e):p.fireQueueItem(e),p},p.clearQueue=function(){return p.busy.flag=!1,p.queues=[],p},p.stateChanged=!1,p.doubleChecker=!1,p.doubleCheckComplete=function(){return p.stateChanged=!0,p.doubleCheckClear(),p},p.doubleCheckClear=function(){return p.doubleChecker&&(s(p.doubleChecker),p.doubleChecker=!1),p},p.doubleCheck=function(e){return p.stateChanged=!1,p.doubleCheckClear(),p.bugs.ieDoubleCheck&&(p.doubleChecker=i(function(){return p.doubleCheckClear(),p.stateChanged||e(),!0},p.options.doubleCheckInterval)),p},p.safariStatePoll=function(){var t,r=p.extractState(p.getLocationHref());if(!p.isLastSavedState(r))return t=r,t||(t=p.createStateObject()),p.Adapter.trigger(e,"popstate"),p},p.back=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.back,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.back(!1)}),f.go(-1),!0)},p.forward=function(e){return e!==!1&&p.busy()?(p.pushQueue({scope:p,callback:p.forward,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.forward(!1)}),f.go(1),!0)},p.go=function(e,t){var r;if(e>0)for(r=1;r<=e;++r)p.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(r=-1;r>=e;--r)p.back(t)}return p},p.emulated.pushState){var h=function(){};p.pushState=p.pushState||h,p.replaceState=p.replaceState||h}else p.onPopState=function(t,r){var a,n,o=!1,i=!1;return p.doubleCheckComplete(),a=p.getHash(),a?(n=p.extractState(a||p.getLocationHref(),!0),n?p.replaceState(n.data,n.title,n.url,!1):(p.Adapter.trigger(e,"anchorchange"),p.busy(!1)),p.expectedStateId=!1,!1):(o=p.Adapter.extractEventData("state",t,r)||!1,i=o?p.getStateById(o):p.expectedStateId?p.getStateById(p.expectedStateId):p.extractState(p.getLocationHref()),i||(i=p.createStateObject(null,null,p.getLocationHref())),p.expectedStateId=!1,p.isLastSavedState(i)?(p.busy(!1),!1):(p.storeState(i),p.saveState(i),p.setTitle(i),p.Adapter.trigger(e,"statechange"),p.busy(!1),!0))},p.Adapter.bind(e,"popstate",p.onPopState),p.pushState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.pushState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.pushState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0},p.replaceState=function(t,r,a,n){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(n!==!1&&p.busy())return p.pushQueue({scope:p,callback:p.replaceState,args:arguments,queue:n}),!1;p.busy(!0);var o=p.createStateObject(t,r,a);return p.isLastSavedState(o)?p.busy(!1):(p.storeState(o),p.expectedStateId=o.id,f.replaceState(o.id,o.title,o.url),p.Adapter.trigger(e,"popstate")),!0};if(o){try{p.store=d.parse(o.getItem("History.store"))||{}}catch(e){p.store={}}p.normalizeStore()}else p.store={},p.normalizeStore();p.Adapter.bind(e,"unload",p.clearAllIntervals),p.saveState(p.storeState(p.extractState(p.getLocationHref(),!0))),o&&(p.onUnload=function(){var e,t,r;try{e=d.parse(o.getItem("History.store"))||{}}catch(t){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in p.idToState)p.idToState.hasOwnProperty(t)&&(e.idToState[t]=p.idToState[t]);for(t in p.urlToId)p.urlToId.hasOwnProperty(t)&&(e.urlToId[t]=p.urlToId[t]);for(t in p.stateToId)p.stateToId.hasOwnProperty(t)&&(e.stateToId[t]=p.stateToId[t]);p.store=e,p.normalizeStore(),r=d.stringify(e);try{o.setItem("History.store",r)}catch(e){if(e.code!==DOMException.QUOTA_EXCEEDED_ERR)throw e;o.length&&(o.removeItem("History.store"),o.setItem("History.store",r))}},p.intervalList.push(u(p.onUnload,p.options.storeInterval)),p.Adapter.bind(e,"beforeunload",p.onUnload),p.Adapter.bind(e,"unload",p.onUnload)),p.emulated.pushState||(p.bugs.safariPoll&&p.intervalList.push(u(p.safariStatePoll,p.options.safariPollInterval)),"Apple Computer, Inc."!==n.vendor&&"Mozilla"!==(n.appCodeName||"")||(p.Adapter.bind(e,"hashchange",function(){p.Adapter.trigger(e,"popstate")}),p.getHash()&&p.Adapter.onDomLoad(function(){p.Adapter.trigger(e,"hashchange")})))},(!p.options||!p.options.delayInit)&&p.init()}(window);
 
 },{}],20:[function(require,module,exports){
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(t){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter;var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),o=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){var i=a(t.dist);return t.xDiagCoord=i,i}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(o,i.theme),this._initToggle();var r=d3.select(o);r.attr("width",i.width);var n=r.append("svg");n.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(t){return d3.mouse(n.select("g"))[0]}).y(function(t){return this._height()});var l=d3.select(this._container).select("svg").select("g");this._areapath=l.append("path").attr("class","area");var d=this._background=l.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(d.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(d.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=l.append("g"),this._yaxisgraphicnode=l.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=l.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),o},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_findItemForLatLng:function(t){var i=null,e=1/0;return this._data.forEach(function(a){var s=t.distanceTo(a.latlng);e>s&&(e=s,i=a)}),i},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,t);i.href="#",i.title=this.options.controlButton.title,L.Browser.touch?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a;a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"";var s=a.split(".");if(s[1]){for(var o=i-s[1].length;o>0;o--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){var i=this.options;i.imperial?t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){var i=this.options;i.imperial?t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(t,i,e){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),s=this.options,o=this._data[this._findItemForX(a[0])],r=o.altitude,n=o.dist,h=o.latlng,l=s.hoverNumber.formatter(r,s.hoverNumber.decimalsY);s.hoverNumber.formatter(n,s.hoverNumber.decimalsX),this._showDiagramIndicator(o,a[0]);var d=this._map.latLngToLayerPoint(h);if(s.useHeightIndicator){if(!this._mouseHeightFocus){var c=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=c.append("svg:line").attr("class",s.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var _=this._pointG=c.append("g");_.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",s.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=c.append("svg:text").attr("class",s.theme+" height-focus-label").style("pointer-events","none")}var u=this._height()/this._maxElevation*r,g=d.y-u;this._mouseHeightFocus.attr("x1",d.x).attr("x2",d.x).attr("y1",d.y).attr("y2",g).style("visibility","visible"),this._pointG.attr("transform","translate("+d.x+","+d.y+")").style("visibility","visible"),s.imperial?this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(h):this._marker=new L.Marker(h).addTo(this._map)}},_addGeoJSONData:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=new L.LatLng(t[o][1],t[o][0]),n=new L.LatLng(t[o?o-1:0][1],t[o?o-1:0][0]),h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<t[o][2]?t[o][2]:s,e.push({dist:a,altitude:i.imperial?t[o][2]*this.__footFactor:t[o][2],x:t[o][0],y:t[o][1],latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addGPXdata:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=t[o],n=t[o?o-1:0],h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<r.meta.ele?r.meta.ele:s,e.push({dist:a,altitude:i.imperial?r.meta.ele*this.__footFactor:r.meta.ele,x:r.lng,y:r.lat,latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}var a=t&&"FeatureCollection"===t.type;if(a)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t,i){this._addData(t),this._container&&this._applyData(),null===i&&t.on&&(i=t),i&&i.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(t){if(this._data&&0!==this._data.length){var i=t.latlng,e=this._findItemForLatLng(i);if(e){var a=e.xDiagCoord;this._showDiagramIndicator(e,a)}}},_showDiagramIndicator:function(t,i){var e=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",i).attr("y1",0).attr("x2",i).attr("y2",this._height()).classed("hidden",!1);var a=t.altitude,s=t.dist,o=(t.latlng,e.hoverNumber.formatter(a,e.hoverNumber.decimalsY)),r=e.hoverNumber.formatter(s,e.hoverNumber.decimalsX);e.imperial?(this._focuslabelX.attr("x",i).text(o+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" mi")):(this._focuslabelX.attr("x",i).text(o+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" km"))},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
+L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(t){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter;var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),o=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){var i=a(t.dist);return t.xDiagCoord=i,i}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(o,i.theme),this._initToggle();var r=d3.select(o);r.attr("width",i.width);var n=r.append("svg");n.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(t){return d3.mouse(n.select("g"))[0]}).y(function(t){return this._height()});var l=d3.select(this._container).select("svg").select("g");this._areapath=l.append("path").attr("class","area");var d=this._background=l.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.mobile?(d.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(d.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=l.append("g"),this._yaxisgraphicnode=l.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=l.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),o},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_findItemForLatLng:function(t){var i=null,e=1/0;return this._data.forEach(function(a){var s=t.distanceTo(a.latlng);e>s&&(e=s,i=a)}),i},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.mobile?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,t);i.href="#",i.title=this.options.controlButton.title,L.Browser.mobile?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a;a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"";var s=a.split(".");if(s[1]){for(var o=i-s[1].length;o>0;o--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){var i=this.options;i.imperial?t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){var i=this.options;i.imperial?t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(t,i,e){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),s=this.options,o=this._data[this._findItemForX(a[0])],r=o.altitude,n=o.dist,h=o.latlng,l=s.hoverNumber.formatter(r,s.hoverNumber.decimalsY);s.hoverNumber.formatter(n,s.hoverNumber.decimalsX),this._showDiagramIndicator(o,a[0]);var d=this._map.latLngToLayerPoint(h);if(s.useHeightIndicator){if(!this._mouseHeightFocus){var c=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=c.append("svg:line").attr("class",s.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var _=this._pointG=c.append("g");_.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",s.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=c.append("svg:text").attr("class",s.theme+" height-focus-label").style("pointer-events","none")}var u=this._height()/this._maxElevation*r,g=d.y-u;this._mouseHeightFocus.attr("x1",d.x).attr("x2",d.x).attr("y1",d.y).attr("y2",g).style("visibility","visible"),this._pointG.attr("transform","translate("+d.x+","+d.y+")").style("visibility","visible"),s.imperial?this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",d.x).attr("y",g).text(l+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(h):this._marker=new L.Marker(h).addTo(this._map)}},_addGeoJSONData:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=new L.LatLng(t[o][1],t[o][0]),n=new L.LatLng(t[o?o-1:0][1],t[o?o-1:0][0]),h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<t[o][2]?t[o][2]:s,e.push({dist:a,altitude:i.imperial?t[o][2]*this.__footFactor:t[o][2],x:t[o][0],y:t[o][1],latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addGPXdata:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var r=t[o],n=t[o?o-1:0],h=i.imperial?r.distanceTo(n)*this.__mileFactor:r.distanceTo(n);a+=Math.round(h/1e3*1e5)/1e5,s=s<r.meta.ele?r.meta.ele:s,e.push({dist:a,altitude:i.imperial?r.meta.ele*this.__footFactor:r.meta.ele,x:r.lng,y:r.lat,latlng:r})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}var a=t&&"FeatureCollection"===t.type;if(a)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t,i){this._addData(t),this._container&&this._applyData(),null===i&&t.on&&(i=t),i&&i.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(t){if(this._data&&0!==this._data.length){var i=t.latlng,e=this._findItemForLatLng(i);if(e){var a=e.xDiagCoord;this._showDiagramIndicator(e,a)}}},_showDiagramIndicator:function(t,i){var e=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",i).attr("y1",0).attr("x2",i).attr("y2",this._height()).classed("hidden",!1);var a=t.altitude,s=t.dist,o=(t.latlng,e.hoverNumber.formatter(a,e.hoverNumber.decimalsY)),r=e.hoverNumber.formatter(s,e.hoverNumber.decimalsX);e.imperial?(this._focuslabelX.attr("x",i).text(o+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" mi")):(this._focuslabelX.attr("x",i).text(o+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(r+" km"))},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
 
 },{}],21:[function(require,module,exports){
 L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number:"",shadowUrl:null,iconSize:new L.Point(25,41),iconAnchor:new L.Point(12,40),popupAnchor:new L.Point(0,-33),shadowSize:new L.Point(50,-64),shadowAnchor:new L.Point(4,-62),className:"leaflet-div-icon"},createIcon:function(){var n=document.createElement("div"),e=this._createImg(this.options.iconUrl),o=document.createElement("div");return o.setAttribute("class","number"),o.innerHTML=this.options.number||"",n.appendChild(e),n.appendChild(o),this._setIconStyles(n,"icon"),n},createShadow:function(){return null}});
@@ -80,7 +80,7 @@ function initFromParams(e,t){ghRequest.init(e);var o=new Flatpickr(document.getE
 function adjustMapSize(){var e=$("#map"),t=$(window).width()-280;t<400?(t=400,e.attr("style","position: relative; float: right;")):e.attr("style","position: absolute; right: 0;");var a=$(window).height();a<500&&(a=500),e.width(t).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(e,t,a,n,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:t,index:0},m={text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),icon:"./img/marker-small-red.png",callback:n,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(m,m.index),menuEnd=map.contextmenu.insertItem(s,s.index);var u=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:u}).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={color:"black",weight:2,opacity:.3},c={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(c,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,a){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,a))}function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null,defaultContextmenuItems;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){var t=routingLayer.getLayers();return t.filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,a,n,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),icon:i!==TO?"./img/marker-small-red.png":"./img/marker-small-green.png",callback:i!==TO?a:n,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:i!==-1&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
 
 },{"./config/tileLayers.js":10,"./main-template.js":22,"./translate.js":31}],24:[function(require,module,exports){
-module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
+module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-98?"u_turn":e===-8?"u_turn_left":e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":8===e?"u_turn_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
 
 },{}],25:[function(require,module,exports){
 function createAmbiguityList(o){o.error="",o.resolvedList=[];var n=3e3;if(o.isResolved()){var r=$.Deferred();return r.resolve([o]),r}if(o.lat&&o.lng){var t=nominatimReverseURL+"?lat="+o.lat+"&lon="+o.lng+"&format=json&zoom=16";return $.ajax({url:t,type:"GET",dataType:"json",timeout:n}).then(function(n){if(!n)return o.error="No description found for coordinate",[o];var r=n.address,t={};return t.lat=o.lat,t.lng=o.lng,t.bbox=n.boundingbox,t.positionType=n.type,t.locationDetails=format.formatLocationEntry(r),o.resolvedList.push(t),[o]},function(n){return console.log("[nominatim_reverse] Error while looking up coordinate lat="+o.lat+"&lon="+o.lng),o.error="Problem while looking up location.",[o]})}return doGeoCoding(o.input,10,n).then(function(n){if(!n||0===n.length)return o.error="No area description found",[o];var r,t=n[0].importance;for(var e in n){var i=n[e];if(t-i.importance>.4)break;if(!r||JSON.stringify(r)!==JSON.stringify(i.address)){r=i.address,t=i.importance;var a={};a.lat=mathTools.round(i.lat),a.lng=mathTools.round(i.lon),a.locationDetails=format.formatLocationEntry(r),a.bbox=i.boundingbox,a.positionType=i.type,o.resolvedList.push(a)}}if(0===o.resolvedList.length)return o.error="No area description found",[o];var s=o.resolvedList;return o.lat=s[0].lat,o.lng=s[0].lng,[o]},function(){return o.error="Problem while looking up address",[o]})}function doGeoCoding(o,n,r){n||(n=10);var t=nominatimURL+"?format=json&addressdetails=1&q="+encodeURIComponent(o)+"&limit="+n;return bounds.initialized&&(t+="&bounded=1&viewbox="+bounds.minLon+","+bounds.maxLat+","+bounds.maxLon+","+bounds.minLat),$.ajax({url:t,type:"GET",dataType:"json",timeout:r}).fail(createCallback("[nominatim] Problem while looking up location "+o))}function createCallback(o){return function(n){console.log(o+" "+JSON.stringify(n))}}function resolve(o,n){var r=$("#locationpoints > div.pointDiv").eq(o);return $(r).find(".pointFlag").hide(),$(r).find(".pointIndicator").show(),$(r).find(".pointInput").val(n.input),createAmbiguityList(n).always(function(){var o=$(r).find(".pointResolveError");return o.empty(),n.error&&(o.show(),o.text(n.error).fadeOut(5e3),n.error=""),$(r).find(".pointIndicator").hide(),$(r).find(".pointFlag").show(),n})}var nominatimURL="https://nominatim.openstreetmap.org/search",nominatimReverseURL="https://nominatim.openstreetmap.org/reverse",bounds,mathTools=require("./tools/math.js"),format=require("./tools/format.js");module.exports.resolve=resolve,module.exports.setBounds=function(o){bounds=o};
diff --git a/web/src/main/webapp/js/messages.js b/web/src/main/webapp/js/messages.js
index 9fa39c9384..4005890cf3 100644
--- a/web/src/main/webapp/js/messages.js
+++ b/web/src/main/webapp/js/messages.js
@@ -15,9 +15,13 @@ module.exports.extractMetaVersionInfo = function (json) {
 };
 
 module.exports.getSignName = function (sign) {
-    if (sign === -7)
+    if (sign === -98)
+        return "u_turn";
+    else if (sign === -8)
+        return "u_turn_left";
+    else if (sign === -7)
         return "keep_left";
-    if (sign === -3)
+    else if (sign === -3)
         return "sharp_left";
     else if (sign === -2)
         return "left";
@@ -39,6 +43,8 @@ module.exports.getSignName = function (sign) {
         return "roundabout";
     else if (sign === 7)
         return "keep_right";
+    else if (sign === 8)
+        return "u_turn_right";
     else if (sign === 101)
         return "pt_start_trip";
     else if (sign === 102)
@@ -46,7 +52,7 @@ module.exports.getSignName = function (sign) {
     else if (sign === 103)
         return "pt_end_trip";
     else
-        // throw "did not find sign " + sign;
+    // throw "did not find sign " + sign;
         return "unknown";
 };
 
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 0891185abc..0aa9303b83 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -179,6 +179,17 @@ public void testPathDetails() throws Exception {
         assertEquals(expectedTime, actualTime);
     }
 
+    @Test
+    public void testPathDetailsSamePoint() throws Exception {
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
+        GHRequest request = new GHRequest(42.554851, 1.536198, 42.554851, 1.536198);
+        request.setPathDetails(Arrays.asList("average_speed", "edge_id", "time"));
+        GHResponse rsp = hopper.route(request);
+        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
+        assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
+    }
+
     @Test
     public void testPathDetailsNoConnection() throws Exception {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
