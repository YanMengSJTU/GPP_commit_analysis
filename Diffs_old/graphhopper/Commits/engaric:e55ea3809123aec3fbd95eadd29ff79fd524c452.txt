diff --git a/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java b/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
new file mode 100644
index 0000000000..0d24ed5d02
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
@@ -0,0 +1,67 @@
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+public class EscapePrivateWeighting implements Weighting
+{
+
+	private static final double ESCAPE_WEIGHT = 1.1;
+	public static final int KEY = 100;
+	private Weighting innerWeighting;
+	private FlagEncoder encoder;
+	private Graph graph;
+	private int start;
+	private int end;
+
+	public EscapePrivateWeighting( Graph graph, FlagEncoder encoder, Weighting weighting, int start, int end )
+    {
+	    super();
+	    this.graph = graph;
+	    this.encoder = encoder;
+	    this.innerWeighting = weighting;
+	    this.start = start;
+	    this.end = end;
+    }
+
+	@Override
+	public double getMinWeight( double distance )
+	{
+		return innerWeighting.getMinWeight(distance);
+	}
+
+	@Override
+	public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+	{
+		System.err.println(edgeState.getClass() + ":" + edgeState.toString());
+		double calcWeight = innerWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+		if(encoder.getLong(edgeState.getFlags(), KEY)>0) {
+			EdgeIteratorState edgeProps=null;
+			System.err.println("EDGE"+ edgeState.getEdge()+":PREVNEXT"  + prevOrNextEdgeId);
+			if(!isStartOrEnd(edgeState) && prevOrNextEdgeId>EdgeIterator.NO_EDGE) {
+				edgeProps = graph.getEdgeProps(prevOrNextEdgeId, Integer.MIN_VALUE);
+			}
+			if(null==edgeProps || encoder.getLong(edgeProps.getFlags(), KEY)>0) {
+				calcWeight *= ESCAPE_WEIGHT;
+			}
+			else {
+				calcWeight = Double.POSITIVE_INFINITY;
+			}
+		}
+		System.err.println("WEIGHT:" +calcWeight);
+		return calcWeight;
+	}
+
+	private boolean isStartOrEnd( EdgeIteratorState edgeState )
+    {
+	    int baseNode = edgeState.getBaseNode();
+		int adjNode = edgeState.getAdjNode();
+		boolean startEnd = baseNode == start  || baseNode == end  || adjNode == start || adjNode == end;
+		System.err.println("STARTEND:" + startEnd + ":" + edgeState.toString());
+		return startEnd;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
index 56da0dca36..cea014217a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
@@ -1,6 +1,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.Way;
+import com.graphhopper.routing.EscapePrivateWeighting;
 
 public class EmergencyVehicleFlagEncoder extends CarFlagEncoder
 {
@@ -29,7 +30,7 @@ public long acceptWay( Way way )
 	@Override
 	public long getLong( long flags, int key )
 	{
-	    if(key==100) 
+	    if(key==EscapePrivateWeighting.KEY) 
 	    	return startStopEncoder.getValue(flags);
 		return super.getLong(flags, key);
 	}
@@ -59,5 +60,14 @@ public int defineWayBits( int index, int shift )
         
         return shift;
     }
+    
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return EscapePrivateWeighting.class.isAssignableFrom(feature);
+    }
 	
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 54edf7b16f..91f4002e5b 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -17,18 +17,42 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import gnu.trove.list.TIntList;
+
 import java.util.Random;
-import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.reader.Way;
+import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EmergencyVehicleFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FastestWeighting;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.routing.util.ShortestWeighting;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+
 /**
  *
  * @author Peter Karich
@@ -37,9 +61,10 @@
 {
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
-    protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
+    protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT,EMV");
     protected FlagEncoder carEncoder;
     protected FlagEncoder footEncoder;
+    protected EmergencyVehicleFlagEncoder emvEncoder;
     protected AlgorithmOptions defaultOpts;
 
     @Before
@@ -47,6 +72,7 @@ public void setUp()
     {
         carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
         footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        emvEncoder = (EmergencyVehicleFlagEncoder) encodingManager.getEncoder("EMV");
         defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
                 weighting(new ShortestWeighting()).build();
     }
@@ -187,6 +213,51 @@ public void testCalcFootPath()
         assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
+    
+    @Test
+    /**
+     * 0-7 can take route 4-5-2-3 despite first and last edge being private as must be able to leave a private start point or reach a private destination
+     */
+    public void testCalcStartEndOnlyPrivatePath()
+    {
+    	Way way = new OSMWay(1L);
+    	way.setTag("access", "no");
+    	way.setTag("highway","track");
+    	way.setTag("tracktype","grade3");
+        Graph graphShortest = createGraph(false);
+        initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
+        
+        GHUtility.printEdgeInfo(graphShortest, emvEncoder);
+        GHUtility.printInfo(graphShortest, 0,20, EdgeFilter.ALL_EDGES);
+        RoutingAlgorithm algo = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(emvEncoder).
+                weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting(), 4, 3)).build());
+		
+        Path p1 = algo.calcPath(4, 3);
+        assertEquals(Helper.createTList(4, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6); 
+    }
+    
+    @Test
+    /**
+     * 0-7 cannot take shortest route 0-4-6-7 so must instead take 0-1-5-7
+     */
+    public void testCalcWontTraversePrivatePath()
+    {
+    	Way way = new OSMWay(1L);
+    	way.setTag("access", "no");
+    	way.setTag("highway","track");
+    	way.setTag("tracktype","grade3");
+        Graph graphShortest = createGraph(false);
+        initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
+        
+        GHUtility.printEdgeInfo(graphShortest, emvEncoder);
+        GHUtility.printInfo(graphShortest, 0,20, EdgeFilter.ALL_EDGES);
+        RoutingAlgorithm algo = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(emvEncoder).
+                weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting(), 0, 7)).build());
+		Path p1 = algo.calcPath(0, 7);
+		assertEquals(Helper.createTList(0, 1, 5, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 19000, p1.getDistance(), 1e-6); 
+    }
 
     protected void initFootVsCar( Graph graph )
     {
@@ -211,6 +282,30 @@ protected void initFootVsCar( Graph graph )
 
         graph.edge(6, 7).setDistance(5000).setFlags(carEncoder.setProperties(20, true, true));
     }
+    
+    protected void initPrivateSections( Graph graph, long privateSectionFlagValue  )
+    {
+        graph.edge(0, 1).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+        graph.edge(0, 4).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true) );
+
+        graph.edge(1, 4).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+        graph.edge(1, 5).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+        graph.edge(1, 2).setDistance(20000).setFlags(emvEncoder.setProperties(10, true, true));
+
+        graph.edge(5, 2).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
+        graph.edge(2, 3).setDistance(5000).setFlags(privateSectionFlagValue);
+
+        graph.edge(5, 3).setDistance(11000).setFlags(privateSectionFlagValue);
+        graph.edge(3, 7).setDistance(7000).setFlags(privateSectionFlagValue);
+
+        graph.edge(4, 6).setDistance(5000).setFlags(privateSectionFlagValue);
+        graph.edge(5, 4).setDistance(7000).setFlags(privateSectionFlagValue);
+
+        graph.edge(5, 6).setDistance(7000).setFlags(privateSectionFlagValue);
+        graph.edge(7, 5).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
+
+        graph.edge(6, 7).setDistance(6000).setFlags(emvEncoder.setProperties(10, true, true));
+    }
 
     // see test-graph.svg !
     protected Graph createTestGraph()
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 4092c96b44..19d224a0c5 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -109,6 +109,12 @@ public void testTwoWeightsPerEdge2()
     {
         // calcPath with QueryResult not supported
     }
+    
+    @Override
+    public void testCalcWontTraversePrivatePath()
+    {
+        // calcPath with QueryResult not supported
+    }
 
     @Test
     public void testIssue182()
