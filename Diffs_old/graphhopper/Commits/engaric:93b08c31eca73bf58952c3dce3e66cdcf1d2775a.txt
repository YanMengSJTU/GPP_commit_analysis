diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 3e1eabd247..ee25c691ce 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -1,63 +1,49 @@
 /*
- * Licensed to GraphHopper and Peter Karich under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 package com.graphhopper.routing;
 
-import gnu.trove.list.TIntList;
-import gnu.trove.list.array.TIntArrayList;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.util.AngleCalc;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.FinishInstruction;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.InstructionAnnotation;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.RoundaboutInstruction;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.Translation;
+import com.graphhopper.util.*;
+import gnu.trove.list.TIntList;
+import gnu.trove.list.array.TIntArrayList;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- * Stores the nodes for the found path of an algorithm. It additionally needs
- * the edgeIds to make edge determination faster and less complex as there could
- * be several edges (u,v) especially for graphs with shortcuts.
+ * Stores the nodes for the found path of an algorithm. It additionally needs the edgeIds to make
+ * edge determination faster and less complex as there could be several edges (u,v) especially for
+ * graphs with shortcuts.
  * <p/>
- *
  * @author Peter Karich
  * @author Ottavio Campana
  * @author jan soe
  */
-public class Path {
+public class Path
+{
     private static final AngleCalc ac = new AngleCalc();
     protected Graph graph;
     private FlagEncoder encoder;
     protected double distance;
-    // we go upwards (via EdgeEntry.parent) from the goal node to the origin
-    // node
+    // we go upwards (via EdgeEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
     protected long millis;
     private boolean found;
@@ -69,7 +55,8 @@
     private double weight;
     private NodeAccess nodeAccess;
 
-    public Path(Graph graph, FlagEncoder encoder) {
+    public Path( Graph graph, FlagEncoder encoder )
+    {
         this.weight = Double.MAX_VALUE;
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
@@ -80,32 +67,36 @@ public Path(Graph graph, FlagEncoder encoder) {
     /**
      * Populates an unextracted path instances from the specified path p.
      */
-    Path(Path p) {
+    Path( Path p )
+    {
         this(p.graph, p.encoder);
         weight = p.weight;
         edgeIds = new TIntArrayList(p.edgeIds);
         edgeEntry = p.edgeEntry;
     }
 
-    public Path setEdgeEntry(EdgeEntry edgeEntry) {
+    public Path setEdgeEntry( EdgeEntry edgeEntry )
+    {
         this.edgeEntry = edgeEntry;
         return this;
     }
 
-    protected void addEdge(int edge) {
+    protected void addEdge( int edge )
+    {
         edgeIds.add(edge);
     }
 
-    protected Path setEndNode(int end) {
+    protected Path setEndNode( int end )
+    {
         endNode = end;
         return this;
     }
 
     /**
-     * We need to remember fromNode explicitely as its not saved in one edgeId
-     * of edgeIds.
+     * We need to remember fromNode explicitely as its not saved in one edgeId of edgeIds.
      */
-    protected Path setFromNode(int from) {
+    protected Path setFromNode( int from )
+    {
         fromNode = from;
         return this;
     }
@@ -113,24 +104,30 @@ protected Path setFromNode(int from) {
     /**
      * @return the first node of this Path.
      */
-    private int getFromNode() {
+    private int getFromNode()
+    {
         if (fromNode < 0)
             throw new IllegalStateException("Call extract() before retrieving fromNode");
+
         return fromNode;
     }
 
-    public boolean isFound() {
+    public boolean isFound()
+    {
         return found;
     }
 
-    public Path setFound(boolean found) {
+    public Path setFound( boolean found )
+    {
         this.found = found;
         return this;
     }
 
-    void reverseOrder() {
+    void reverseOrder()
+    {
         if (!reverseOrder)
             throw new IllegalStateException("Switching order multiple times is not supported");
+
         reverseOrder = false;
         edgeIds.reverse();
     }
@@ -138,26 +135,29 @@ void reverseOrder() {
     /**
      * @return distance in meter
      */
-    public double getDistance() {
+    public double getDistance()
+    {
         return distance;
     }
 
     /**
      * @return time in millis
      */
-    public long getMillis() {
+    public long getMillis()
+    {
         return millis;
     }
 
     /**
-     * This weight will be updated during the algorithm. The initial value is
-     * maximum double.
+     * This weight will be updated during the algorithm. The initial value is maximum double.
      */
-    public double getWeight() {
+    public double getWeight()
+    {
         return weight;
     }
 
-    public Path setWeight(double w) {
+    public Path setWeight( double w )
+    {
         this.weight = w;
         return this;
     }
@@ -165,16 +165,20 @@ public Path setWeight(double w) {
     /**
      * Extracts the Path from the shortest-path-tree determined by edgeEntry.
      */
-    public Path extract() {
+    public Path extract()
+    {
         if (isFound())
             throw new IllegalStateException("Extract can only be called once");
+
         extractSW.start();
         EdgeEntry goalEdge = edgeEntry;
         setEndNode(goalEdge.adjNode);
-        while (EdgeIterator.Edge.isValid(goalEdge.edge)) {
+        while (EdgeIterator.Edge.isValid(goalEdge.edge))
+        {
             processEdge(goalEdge.edge, goalEdge.adjNode);
             goalEdge = goalEdge.parent;
         }
+
         setFromNode(goalEdge.adjNode);
         reverseOrder();
         extractSW.stop();
@@ -184,18 +188,21 @@ public Path extract() {
     /**
      * @return the time it took to extract the path in nano (!) seconds
      */
-    public long getExtractTime() {
+    public long getExtractTime()
+    {
         return extractSW.getNanos();
     }
 
-    public String getDebugInfo() {
+    public String getDebugInfo()
+    {
         return extractSW.toString();
     }
 
     /**
      * Calls getDistance and adds the edgeId.
      */
-    protected void processEdge(int edgeId, int adjNode) {
+    protected void processEdge( int edgeId, int adjNode )
+    {
         EdgeIteratorState iter = graph.getEdgeProps(edgeId, adjNode);
         double dist = iter.getDistance();
         distance += dist;
@@ -204,46 +211,54 @@ protected void processEdge(int edgeId, int adjNode) {
     }
 
     /**
-     * Calculates the time in millis for the specified distance in meter and
-     * speed (in km/h) via flags.
+     * Calculates the time in millis for the specified distance in meter and speed (in km/h) via
+     * flags.
      */
-    protected long calcMillis(double distance, long flags, boolean revert) {
-        if (revert && !encoder.isBool(flags, FlagEncoder.K_BACKWARD) || !revert && !encoder.isBool(flags, FlagEncoder.K_FORWARD))
-            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. " + "Reverse:" + revert + ", fwd:" + encoder.isBool(flags, FlagEncoder.K_FORWARD) + ", bwd:" + encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+    protected long calcMillis( double distance, long flags, boolean revert )
+    {
+        if (revert && !encoder.isBackward(flags)
+                || !revert && !encoder.isForward(flags))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
+
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
             throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+
         if (speed == 0)
             throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
         return (long) (distance * 3600 / speed);
     }
 
     /**
      * The callback used in forEveryEdge.
      */
-    private static interface EdgeVisitor {
-        void next(EdgeIteratorState edgeBase, int index);
+    private static interface EdgeVisitor
+    {
+        void next( EdgeIteratorState edgeBase, int index );
     }
 
     /**
-     * Iterates over all edges in this path sorted from start to end and calls
-     * the visitor callback for every edge.
+     * Iterates over all edges in this path sorted from start to end and calls the visitor callback
+     * for every edge.
      * <p>
-     *
-     * @param visitor
-     *            callback to handle every edge. The edge is decoupled from the
-     *            iterator and can be stored.
+     * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
+     * be stored.
      */
-    private void forEveryEdge(EdgeVisitor visitor) {
+    private void forEveryEdge( EdgeVisitor visitor )
+    {
         int tmpNode = getFromNode();
         int len = edgeIds.size();
-        for (int i = 0; i < len; i++) {
+        for (int i = 0; i < len; i++)
+        {
             EdgeIteratorState edgeBase = graph.getEdgeProps(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
-                throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode + ", array index:" + i + ", edges:" + edgeIds.size());
+                throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode
+                        + ", array index:" + i + ", edges:" + edgeIds.size());
+
             tmpNode = edgeBase.getBaseNode();
-            // more efficient swap, currently not implemented for virtual edges:
-            // visitor.next(edgeBase.detach(true), i);
+            // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
             edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
@@ -252,13 +267,17 @@ private void forEveryEdge(EdgeVisitor visitor) {
     /**
      * Returns the list of all edges.
      */
-    public List<EdgeIteratorState> calcEdges() {
+    public List<EdgeIteratorState> calcEdges()
+    {
         final List<EdgeIteratorState> edges = new ArrayList<EdgeIteratorState>(edgeIds.size());
         if (edgeIds.isEmpty())
             return edges;
-        forEveryEdge(new EdgeVisitor() {
+
+        forEveryEdge(new EdgeVisitor()
+        {
             @Override
-            public void next(EdgeIteratorState eb, int i) {
+            public void next( EdgeIteratorState eb, int i )
+            {
                 edges.add(eb);
             }
         });
@@ -268,19 +287,25 @@ public void next(EdgeIteratorState eb, int i) {
     /**
      * @return the uncached node indices of the tower nodes in this path.
      */
-    public TIntList calcNodes() {
+    public TIntList calcNodes()
+    {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
-        if (edgeIds.isEmpty()) {
-            if (isFound()) {
+        if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
                 nodes.add(endNode);
             }
             return nodes;
         }
+
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
-        forEveryEdge(new EdgeVisitor() {
+        forEveryEdge(new EdgeVisitor()
+        {
             @Override
-            public void next(EdgeIteratorState eb, int i) {
+            public void next( EdgeIteratorState eb, int i )
+            {
                 nodes.add(eb.getAdjNode());
             }
         });
@@ -290,24 +315,30 @@ public void next(EdgeIteratorState eb, int i) {
     /**
      * This method calculated a list of points for this path
      * <p>
-     *
      * @return this path its geometry
      */
-    public PointList calcPoints() {
+    public PointList calcPoints()
+    {
         final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
-        if (edgeIds.isEmpty()) {
-            if (isFound()) {
+        if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
                 points.add(graph.getNodeAccess(), endNode);
             }
             return points;
         }
+
         int tmpNode = getFromNode();
         points.add(nodeAccess, tmpNode);
-        forEveryEdge(new EdgeVisitor() {
+        forEveryEdge(new EdgeVisitor()
+        {
             @Override
-            public void next(EdgeIteratorState eb, int index) {
+            public void next( EdgeIteratorState eb, int index )
+            {
                 PointList pl = eb.fetchWayGeometry(2);
-                for (int j = 0; j < pl.getSize(); j++) {
+                for (int j = 0; j < pl.getSize(); j++)
+                {
                     points.add(pl, j);
                 }
             }
@@ -318,38 +349,45 @@ public void next(EdgeIteratorState eb, int index) {
     /**
      * @return the list of instructions for this path.
      */
-    public InstructionList calcInstructions(final Translation tr) {
+    public InstructionList calcInstructions( final Translation tr )
+    {
         final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
-        if (edgeIds.isEmpty()) {
-            if (isFound()) {
+        if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
                 ways.add(new FinishInstruction(nodeAccess, endNode));
             }
             return ways;
         }
+
         final int tmpNode = getFromNode();
-        forEveryEdge(new EdgeVisitor() {
+        forEveryEdge(new EdgeVisitor()
+        {
             /*
              * We need three points to make directions
              *
-             *          (1)----(2)
-             *          /
-             *         /
-             *       (0)
+             *        (1)----(2)
+             *        /
+             *       /
+             *    (0)
              *
-             * 0 is the node visited at t-2, 1 is the node visited at t-1 and 2
-             * is the node being visited at instant t. orientation is the angle
-             * of the vector(1->2) expressed as atan2, while previousOrientation
-             * is the angle of the vector(0->1) Intuitively, if orientation is
-             * smaller than previousOrientation, then we have to turn right,
-             * while if it is greater we have to turn left. To make this
-             * algorithm work, we need to make the comparison by considering
-             * orientation belonging to the interval [ - pi +
-             * previousOrientation , + pi + previousOrientation ]
+             * 0 is the node visited at t-2, 1 is the node visited
+             * at t-1 and 2 is the node being visited at instant t.
+             * orientation is the angle of the vector(1->2) expressed
+             * as atan2, while previousOrientation is the angle of the
+             * vector(0->1)
+             * Intuitively, if orientation is smaller than
+             * previousOrientation, then we have to turn right, while
+             * if it is greater we have to turn left. To make this
+             * algorithm work, we need to make the comparison by
+             * considering orientation belonging to the interval
+             * [ - pi + previousOrientation , + pi + previousOrientation ]
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
-            private double doublePrevLat, doublePrevLong; // Lat and Lon of node
-            // t-2
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
             private boolean prevInRoundabout = false;
@@ -358,7 +396,8 @@ public InstructionList calcInstructions(final Translation tr) {
             private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
-            public void next(EdgeIteratorState edge, int index) {
+            public void next( EdgeIteratorState edge, int index )
+            {
                 // If the add.additional.tower.nodes property is set to true
                 // additional zero length edges are created. This means that
                 // direction calculations are not accurate because they are
@@ -375,8 +414,10 @@ public void next(EdgeIteratorState edge, int index) {
                     double adjLat = nodeAccess.getLatitude(adjNode);
                     double adjLon = nodeAccess.getLongitude(adjNode);
                     double latitude, longitude;
+
                     PointList wayGeo = edge.fetchWayGeometry(3);
-                    boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
+                    boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                     if (wayGeo.getSize() <= 2) {
                         latitude = adjLat;
                         longitude = adjLon;
@@ -386,39 +427,49 @@ public void next(EdgeIteratorState edge, int index) {
                         assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
                         assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                     }
+
                     name = edge.getName();
                     annotation = encoder.getAnnotation(flags, tr);
-                    if ((prevName == null) && (!isRoundabout)) // very first
-                        // instruction (if
-                        // not in Roundabout)
+
+                    if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                     {
                         int sign = Instruction.CONTINUE_ON_STREET;
                         prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                         ways.add(prevInstruction);
                         prevName = name;
                         prevAnnotation = annotation;
+
                     } else {
                         if (isRoundabout)
-                            // remark: names and annotations within roundabout are
-                            // ignored
+                        // remark: names and annotations within roundabout are ignored
                         {
-                            if (!prevInRoundabout) // just entered roundabout
+                            if (!prevInRoundabout) //just entered roundabout
                             {
                                 int sign = Instruction.USE_ROUNDABOUT;
-                                RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                                RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                        annotation, new PointList(10, nodeAccess.is3D()));
                                 if (prevName != null) {
-                                    // previous orientation is last orientation
-                                    // before entering roundabout
+                                    // check if there is an exit at the same node the roundabout was entered
+                                    EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                    while (edgeIter.next()) {
+                                        if ((edgeIter.getAdjNode() != prevNode)
+                                                && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
+                                            roundaboutInstruction.increaseExitNumber();
+                                            break;
+                                        }
+                                    }
+
+                                    // previous orientation is last orientation before entering roundabout
                                     prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
-                                    // calculate direction of entrance turn to
-                                    // determine direction of rotation
+
+                                    // calculate direction of entrance turn to determine direction of rotation
                                     // right turn == counterclockwise and vice versa
                                     double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                                     orientation = ac.alignOrientation(prevOrientation, orientation);
                                     double delta = (orientation - prevOrientation);
                                     roundaboutInstruction.setDirOfRotation(delta);
-                                } else // first instructions is roundabout
-                                    // instruction
+
+                                } else // first instructions is roundabout instruction
                                 {
                                     prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                                     prevName = name;
@@ -427,34 +478,41 @@ public void next(EdgeIteratorState edge, int index) {
                                 prevInstruction = roundaboutInstruction;
                                 ways.add(prevInstruction);
                             }
-                            // Add passed exits to instruction. There is an exit if
-                            // there are
-                            // at least 2 out-going edges (one continuing in the
-                            // roundabout)
-                            // This could lead to problems if there are non-complete
-                            // roundabouts!
+
+                            // Add passed exits to instruction. A node is countet if there is at least one outgoing edge
+                            // out of the roundabout
                             EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
-                            edgeIter.next();
-                            if (edgeIter.next()) {
-                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                            while (edgeIter.next()) {
+                                if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT)) {
+                                    ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                                    break;
+                                }
                             }
-                        } else if (prevInRoundabout) // previously in roundabout but
-                            // not anymore
+
+                        } else if (prevInRoundabout) //previously in roundabout but not anymore
                         {
+
                             prevInstruction.setName(name);
+
                             // calc angle between roundabout entrance and exit
                             double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                             orientation = ac.alignOrientation(prevOrientation, orientation);
                             double deltaInOut = (orientation - prevOrientation);
-                            // calculate direction of exit turn to determine
-                            // direction of rotation
+
+                            // calculate direction of exit turn to determine direction of rotation
                             // right turn == counterclockwise and vice versa
                             double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                             orientation = ac.alignOrientation(recentOrientation, orientation);
                             double deltaOut = (orientation - recentOrientation);
-                            prevInstruction = ((RoundaboutInstruction) prevInstruction).setRadian(deltaInOut).setDirOfRotation(deltaOut).setExited();
+
+                            prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                                    .setRadian(deltaInOut)
+                                    .setDirOfRotation(deltaOut)
+                                    .setExited();
+
                             prevName = name;
                             prevAnnotation = annotation;
+
                         } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation))) {
                             prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                             double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
@@ -462,26 +520,31 @@ public void next(EdgeIteratorState edge, int index) {
                             double delta = orientation - prevOrientation;
                             double absDelta = Math.abs(delta);
                             int sign;
+
                             if (absDelta < 0.2) {
                                 // 0.2 ~= 11°
                                 sign = Instruction.CONTINUE_ON_STREET;
+
                             } else if (absDelta < 0.8) {
                                 // 0.8 ~= 40°
                                 if (delta > 0)
                                     sign = Instruction.TURN_SLIGHT_LEFT;
                                 else
                                     sign = Instruction.TURN_SLIGHT_RIGHT;
+
                             } else if (absDelta < 1.8) {
                                 // 1.8 ~= 103°
                                 if (delta > 0)
                                     sign = Instruction.TURN_LEFT;
                                 else
                                     sign = Instruction.TURN_RIGHT;
+
                             } else {
                                 if (delta > 0)
                                     sign = Instruction.TURN_SHARP_LEFT;
                                 else
                                     sign = Instruction.TURN_SHARP_RIGHT;
+
                             }
                             prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                             ways.add(prevInstruction);
@@ -489,7 +552,9 @@ public void next(EdgeIteratorState edge, int index) {
                             prevAnnotation = annotation;
                         }
                     }
+
                     updatePointsAndInstruction(edge, wayGeo);
+
                     if (wayGeo.getSize() <= 2) {
                         doublePrevLat = prevLat;
                         doublePrevLong = prevLon;
@@ -498,9 +563,12 @@ public void next(EdgeIteratorState edge, int index) {
                         doublePrevLat = wayGeo.getLatitude(beforeLast);
                         doublePrevLong = wayGeo.getLongitude(beforeLast);
                     }
+
                     prevInRoundabout = isRoundabout;
+                    prevNode = baseNode;
                     prevLat = adjLat;
                     prevLon = adjLon;
+
                     boolean lastEdge = index == edgeIds.size() - 1;
                     if (lastEdge) {
                         if (isRoundabout) {
@@ -509,16 +577,19 @@ public void next(EdgeIteratorState edge, int index) {
                             orientation = ac.alignOrientation(prevOrientation, orientation);
                             double delta = (orientation - prevOrientation);
                             ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
                         }
                         ways.add(new FinishInstruction(nodeAccess, adjNode));
                     }
                 }
             }
 
-            private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
+            private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
+            {
                 // skip adjNode
                 int len = pl.size() - 1;
-                for (int i = 0; i < len; i++) {
+                for (int i = 0; i < len; i++)
+                {
                     prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
@@ -527,21 +598,26 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
                 prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
             }
         });
+
         return ways;
     }
 
     @Override
-    public String toString() {
+    public String toString()
+    {
         return "distance:" + getDistance() + ", edges:" + edgeIds.size();
     }
 
-    public String toDetailsString() {
+    public String toDetailsString()
+    {
         String str = "";
-        for (int i = 0; i < edgeIds.size(); i++) {
+        for (int i = 0; i < edgeIds.size(); i++)
+        {
             if (i > 0)
                 str += "->";
+
             str += edgeIds.get(i);
         }
         return toString() + ", found:" + isFound() + ", " + str;
     }
-}
\ No newline at end of file
+}
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index a74897fb02..6b684c5120 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -39,9 +39,12 @@
 {
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
+    private final EncodingManager mixedEncoders = new EncodingManager(
+            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final AngleCalc ac = new AngleCalc();
+    private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
 
     @Test
     public void testFound()
@@ -213,14 +216,15 @@ public void testFindInstruction()
 
     private class RoundaboutGraph
     {
-        public EdgeIteratorState edge2change;
-        boolean clockwise;
-        final public Graph g = new GraphBuilder(carManager).create();
+        private EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
         final public NodeAccess na = g.getNodeAccess();
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
 
-        private RoundaboutGraph(boolean clockwise)
+        private RoundaboutGraph()
         {
-            //
+            //                          
             //      8
             //       \
             //         5
@@ -228,34 +232,78 @@ private RoundaboutGraph(boolean clockwise)
             //  1 - 2    4 - 7
             //       \  /
             //        3
-            //        |
-            //        6
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
 
             na.setNode(1, 52.514, 13.348);
             na.setNode(2, 52.514, 13.349);
             na.setNode(3, 52.5135,13.35);
             na.setNode(4, 52.514, 13.351);
             na.setNode(5, 52.5145,13.351);
-            na.setNode(6, 52.513, 13.351);
+            na.setNode(6, 52.513, 13.35);
             na.setNode(7, 52.514, 13.352);
             na.setNode(8, 52.515, 13.351);
-
+            na.setNode(9, 52.513, 13.351);
+          
+           
             EdgeIteratorState tmpEdge;
             tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            
+            // roundabout
+            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+            roundaboutEdges.add(tmpEdge.detach(false));
+
             tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
             tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+
             tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
-            edge2change = tmpEdge.detach(false);
+            edge3to6 = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
+            edge3to9 = tmpEdge.detach(false);
+            
+            setRoundabout(clockwise);
+            inverse3to9();
+            
+        }
+        
+        public void setRoundabout(boolean clockwise)
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                for (EdgeIteratorState edge : roundaboutEdges)
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                }
+            }    
             this.clockwise = clockwise;
         }
+        
+        public void inverse3to9()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+            }
+        }
+
+        public void inverse3to6()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+            }
+        }
+        
 
         private double getAngle(int n1, int n2, int n3, int n4)
         {
@@ -268,63 +316,85 @@ private double getAngle(int n1, int n2, int n3, int n4)
         }
     }
 
+    /**
+     * Test roundabout instructions for different profiles
+     */
     @Test
     public void testCalcInstructionsRoundabout()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        {
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                    .calcPath(1, 8);
+            InstructionList wayList = p.calcInstructions(tr);
+            // Test instructions
+            List<String> tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 3 onto 5-8",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+            RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+
+            // case of continuing a street through a roundabout
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            wayList = p.calcInstructions(tr);
+            tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 2 onto MainStreet",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            delta = roundaboutGraph.getAngle(1, 2, 4, 7);
+            instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+        }
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
-        // Test instructions
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 3 onto 5-8",
-                        "Finish!"),
-                tmpList);
-        // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
-        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
-
-        // case of continuing a street through a roundabout
-        p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
-        wayList = p.calcInstructions(tr);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 2 onto MainStreet",
-                        "Finish!"),
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
                 tmpList);
-        // Test Radian
-        delta = rg.getAngle(1, 2, 4, 7);
-        instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
     }
 
     /**
-     * case with one edge being not an exit
+     * case with one node being containig already exit 
      */
     @Test
-    public void testCalcInstructionsRoundabout2()
+    public void testCalcInstructionsRoundaboutDirectExit()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        roundaboutGraph.inverse3to9();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
-                                    "Finish!"),
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
                 tmpList);
+        roundaboutGraph.inverse3to9();
     }
 
     /**
-     * case starting in Roundabout
+     * case with one edge being not an exit
      */
     @Test
-    public void testCalcInstructionsRoundaboutBegin()
+    public void testCalcInstructionsRoundabout2()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        roundaboutGraph.inverse3to6();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto MainStreet",
@@ -332,12 +402,89 @@ public void testCalcInstructionsRoundaboutBegin()
                         "Finish!"),
                 tmpList);
         // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
         assertEquals(delta, instr.getRadian(), 0.01);
+        roundaboutGraph.inverse3to6();
+
     }
 
 
+    /**
+     * see https://github.com/graphhopper/graphhopper/issues/353
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutIssue353()
+    {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+
+        //
+        //          8
+        //           \
+        //            5
+        //           /  \
+        //  11- 1 - 2    4 - 7
+        //      |     \  /
+        //      10 -9 -3
+        //       \    |
+        //        --- 6
+
+        na.setNode(1, 52.514, 13.348);
+        na.setNode(2, 52.514, 13.349);
+        na.setNode(3, 52.5135,13.35);
+        na.setNode(4, 52.514, 13.351);
+        na.setNode(5, 52.5145,13.351);
+        na.setNode(6, 52.513, 13.35);
+        na.setNode(7, 52.514, 13.352);
+        na.setNode(8, 52.515, 13.351);
+
+        // Sidelane
+        na.setNode(9, 52.5135, 13.349);
+        na.setNode(10, 52.5135, 13.348);
+        na.setNode(11, 52.514, 13.347);
+
+
+        EdgeIteratorState tmpEdge;
+        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
+        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
+
+
+         // roundabout
+        tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+
+        
+        
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 11);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
+                                    "Finish!"),
+                tmpList);
+    }
+
     /**
      * clockwise roundabout
      */
@@ -345,10 +492,9 @@ public void testCalcInstructionsRoundaboutBegin()
     public void testCalcInstructionsRoundaboutClockwise()
     {
 
-        RoundaboutGraph rg = new RoundaboutGraph(true);
-        System.out.println(rg.clockwise);
-
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        roundaboutGraph.setRoundabout(true);
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList( "Continue onto MainStreet",
@@ -356,7 +502,7 @@ public void testCalcInstructionsRoundaboutClockwise()
                         "Finish!"),
                 tmpList);
         // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
         assertEquals(delta, instr.getRadian(), 0.01);
     }
