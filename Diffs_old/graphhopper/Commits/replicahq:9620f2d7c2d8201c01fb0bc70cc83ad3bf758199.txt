diff --git a/pom.xml b/pom.xml
index 3806b682ff..bd2b00d20a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -95,8 +95,8 @@
                     <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
-                    <source>1.7</source>
-                    <target>1.7</target>
+                    <source>1.8</source>
+                    <target>1.8</target>
                 </configuration>
             </plugin>
 
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index f7d2e4c0fe..54cfe65851 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -21,7 +21,11 @@
             <artifactId>graphhopper-core</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-              
+        <dependency>
+            <groupId>net.sourceforge.javacsv</groupId>
+            <artifactId>javacsv</artifactId>
+            <version>2.0</version>
+        </dependency>
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java
index 1ebf14853e..0495050ebe 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java
@@ -20,25 +20,22 @@
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.osm.GraphHopperOSM;
-import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultFlagEncoderFactory;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FlagEncoderFactory;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.spatialrules.SpatialRuleLookupHelper;
+import com.graphhopper.swl.R5EdgeIdPathDetailsBuilder;
 import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
-import com.graphhopper.util.details.AbstractPathDetailsBuilder;
 import com.graphhopper.util.details.AverageSpeedDetails;
 import com.graphhopper.util.details.EdgeIdDetails;
 import com.graphhopper.util.details.PathDetailsBuilder;
 import com.graphhopper.util.details.PathDetailsBuilderFactory;
 import com.graphhopper.util.details.StreetNameDetails;
 import com.graphhopper.util.details.TimeDetails;
-import com.michaz.OriginalDirectionFlagEncoder;
+import com.graphhopper.swl.OriginalDirectionFlagEncoder;
 import io.dropwizard.lifecycle.Managed;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -92,30 +89,7 @@ public FlagEncoder createFlagEncoder(String name, PMap configuration) {
                     builders.add(new TimeDetails(weighting));
 
                 if (requestedPathDetails.contains("r5_edge_id")) {
-                    builders.add(new AbstractPathDetailsBuilder("r5_edge_id") {
-                        private int edgeId = -1;
-
-                        @Override
-                        public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
-                            final int ghEdgeKey;
-                            if (edge instanceof VirtualEdgeIteratorState) {
-                                ghEdgeKey = GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalTraversalKey());
-                            } else {
-                                ghEdgeKey = edge.getEdge();
-                            }
-                            int newEdgeId = ghEdgeKey * 2 + (originalDirectionFlagEncoder.isOriginalDirection(edge.getFlags()) ? 0 : 1);
-                            if (newEdgeId != edgeId) {
-                                edgeId = newEdgeId;
-                                return true;
-                            }
-                            return false;
-                        }
-
-                        @Override
-                        public Object getCurrentValue() {
-                            return this.edgeId;
-                        }
-                    });
+                    builders.add(new R5EdgeIdPathDetailsBuilder(originalDirectionFlagEncoder));
                 }
 
                 if (requestedPathDetails.size() != builders.size()) {
diff --git a/web/src/main/java/com/graphhopper/swl/FileTravelTimeCalculator.java b/web/src/main/java/com/graphhopper/swl/FileTravelTimeCalculator.java
new file mode 100644
index 0000000000..c946054c9a
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/swl/FileTravelTimeCalculator.java
@@ -0,0 +1,111 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.csvreader.CsvReader;
+import com.graphhopper.GHRequest;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+public class FileTravelTimeCalculator implements TravelTimeCalculator {
+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(FileTravelTimeCalculator.class);
+    private final TravelTimeCalculator delegateTravelTimeCalculator =
+            new TravelTimeCalculator() {
+                @Override
+                public float getTravelTimeMilliseconds(int edge, int durationSeconds, String streetMode, GHRequest req) {
+                    return 0;
+                }
+            };
+
+    private Map<Integer, short[]> linkTravelTimes;
+
+    /**
+     *  The class behaves differently, depending on the value of the parameter.
+     *
+     *  If the parameter is a local path, then the file at that path is read into `linkTravelTimes`.
+     *
+     *  If the parameter is a GCS path, than the contents of the file (let's call it a "meta" file) is treated as a
+     *  path to a congestion file on GCS. The contents of the "meta" file is monitored, and whenever it is updated,
+     *  `linkTravelTimes` is updated with the contents of the new congestion file.
+     *
+     * @param path Either:
+     *             - path to the local file with congestion data.
+     *             - path on GCS to a text file, containing the path on GCS to a file with congestion data.
+     */
+    public FileTravelTimeCalculator(String path) {
+        linkTravelTimes = readTravelTimes(new File(path));
+    }
+
+    @Override
+    public float getTravelTimeMilliseconds(int edge, int durationSeconds, String streetMode, GHRequest req) {
+//        if (linkTravelTimes != null && streetMode.equals("car")) {
+//            short[] speeds = linkTravelTimes.get(edge.getEdgeIndex());
+//            if (speeds != null) {
+//                int currentTimeSeconds = req.fromTime + durationSeconds;
+//                int timebinIndex = (currentTimeSeconds / (60 * 15)) % (24 * 4);
+//                double speedms = speeds[timebinIndex] / 3.6;
+//                return (float) (edge.getLengthM() / speedms);
+//            }
+//        }
+//        return delegateTravelTimeCalculator.getTravelTimeMilliseconds(edge, durationSeconds, streetMode, req);
+        return 99.0f;
+    }
+
+    private static Map<Integer, short[]> readTravelTimes(File file) {
+        Map<Integer, short[]> res = new HashMap<>();
+        LOG.warn("Processing {}", file.toString());
+        try (InputStream is = new FileInputStream(file)) {
+            CsvReader reader = new CsvReader(is, ',', Charset.forName("UTF-8"));
+            reader.readHeaders();
+            while (reader.readRecord()) {
+                int edgeId = Integer.parseInt(reader.get("edgeId"));
+                int[] speeds = IntStream.range(0, 24).mapToObj(Integer::toString).flatMap(hour -> {
+                    try {
+                        return Stream.of(Short.parseShort(reader.get(hour + "h_1")),
+                                Short.parseShort(reader.get(hour + "h_2")), Short.parseShort(reader.get(hour + "h_3")),
+                                Short.parseShort(reader.get(hour + "h_4")));
+                    } catch (IOException e) {
+                        throw new RuntimeException(e);
+                    }
+                }).mapToInt(v -> v).toArray();
+                // TODO(sindelar): temporary hack to decrease the memory footprint for congestion
+                short shortSpeeds[] = new short[speeds.length];
+                for (int i = 0; i < speeds.length; i++) {
+                    shortSpeeds[i] = (short) speeds[i];
+                }
+                res.put(edgeId, shortSpeeds);
+            }
+        } catch (IOException ex) {
+            throw new RuntimeException("Exception while loading travel times.");
+        }
+        LOG.warn("Done.");
+
+        return res;
+    }
+
+}
diff --git a/core/src/main/java/com/michaz/OriginalDirectionFlagEncoder.java b/web/src/main/java/com/graphhopper/swl/OriginalDirectionFlagEncoder.java
similarity index 98%
rename from core/src/main/java/com/michaz/OriginalDirectionFlagEncoder.java
rename to web/src/main/java/com/graphhopper/swl/OriginalDirectionFlagEncoder.java
index 35c389c0d0..3761b55435 100644
--- a/core/src/main/java/com/michaz/OriginalDirectionFlagEncoder.java
+++ b/web/src/main/java/com/graphhopper/swl/OriginalDirectionFlagEncoder.java
@@ -16,7 +16,7 @@
  *  limitations under the License.
  */
 
-package com.michaz;
+package com.graphhopper.swl;
 
 import com.graphhopper.routing.util.CarFlagEncoder;
 
diff --git a/web/src/main/java/com/graphhopper/swl/R5EdgeIdPathDetailsBuilder.java b/web/src/main/java/com/graphhopper/swl/R5EdgeIdPathDetailsBuilder.java
new file mode 100644
index 0000000000..051d7e3b47
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/swl/R5EdgeIdPathDetailsBuilder.java
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.details.AbstractPathDetailsBuilder;
+
+public class R5EdgeIdPathDetailsBuilder extends AbstractPathDetailsBuilder {
+    private final OriginalDirectionFlagEncoder originalDirectionFlagEncoder;
+    private int edgeId;
+
+    public R5EdgeIdPathDetailsBuilder(OriginalDirectionFlagEncoder originalDirectionFlagEncoder) {
+        super("r5_edge_id");
+        this.originalDirectionFlagEncoder = originalDirectionFlagEncoder;
+        edgeId = -1;
+    }
+
+    @Override
+    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
+        int newEdgeId = R5EdgeIds.getR5EdgeId(originalDirectionFlagEncoder, edge);
+        if (newEdgeId != edgeId) {
+            edgeId = newEdgeId;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public Object getCurrentValue() {
+        return this.edgeId;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/swl/R5EdgeIds.java b/web/src/main/java/com/graphhopper/swl/R5EdgeIds.java
new file mode 100644
index 0000000000..aaec111c74
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/swl/R5EdgeIds.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+
+public class R5EdgeIds {
+
+    static int getR5EdgeId(OriginalDirectionFlagEncoder originalDirectionFlagEncoder, EdgeIteratorState edge) {
+        final int ghEdgeKey;
+        if (edge instanceof VirtualEdgeIteratorState) {
+            ghEdgeKey = GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalTraversalKey());
+        } else {
+            ghEdgeKey = edge.getEdge();
+        }
+        return ghEdgeKey * 2 + (originalDirectionFlagEncoder.isOriginalDirection(edge.getFlags()) ? 0 : 1);
+    }
+
+}
diff --git a/web/src/main/java/com/graphhopper/swl/TDWeighting.java b/web/src/main/java/com/graphhopper/swl/TDWeighting.java
new file mode 100644
index 0000000000..a226e1c304
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/swl/TDWeighting.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
+
+public class TDWeighting implements Weighting {
+
+    protected static final double SPEED_CONV = 3.6D;
+
+    private final double maxSpeed;
+    private final FlagEncoder encoder;
+    private final TravelTimeCalculator travelTimeCalculator;
+    private final long headingPenaltyMillis;
+    private final double headingPenalty;
+
+    public TDWeighting(FlagEncoder encoder, TravelTimeCalculator travelTimeCalculator, PMap map) {
+        this.encoder = encoder;
+        this.maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
+        this.travelTimeCalculator = travelTimeCalculator;
+
+        headingPenalty = map.getDouble(Parameters.Routing.HEADING_PENALTY, Parameters.Routing.DEFAULT_HEADING_PENALTY);
+        headingPenaltyMillis = Math.round(headingPenalty * 1000);
+    }
+
+    @Override
+    public double getMinWeight(double distance) {
+        return distance / this.maxSpeed;
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
+        if (speed == 0)
+            return Double.POSITIVE_INFINITY;
+
+        double time = edge.getDistance() / speed * SPEED_CONV;
+
+        // add direction penalties at start/stop/via points
+        boolean unfavoredEdge = edge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge)
+            time += headingPenalty;
+
+        return time;
+    }
+
+    @Override
+    public long calcMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        long flags = edge.getFlags();
+        if (reverse && !encoder.isBackward(flags) || !reverse && !encoder.isForward(flags))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + reverse + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
+
+        double speed = reverse ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! " +
+                    "Should only occur for shortest path calculation. See #242.");
+        long time = (long) (edge.getDistance() * 3600 / speed);
+        boolean unfavoredEdge = edge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        if (unfavoredEdge)
+            time += headingPenaltyMillis;
+        return time;
+    }
+
+    @Override
+    public FlagEncoder getFlagEncoder() {
+        return encoder;
+    }
+
+    @Override
+    public String getName() {
+        return "td";
+    }
+
+    @Override
+    public boolean matches(HintsMap reqMap) {
+        return getName().equals(reqMap.getWeighting())
+                && encoder.toString().equals(reqMap.getVehicle());
+    }
+
+    @Override
+    public String toString() {
+        return getName();
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/swl/TravelTimeCalculator.java b/web/src/main/java/com/graphhopper/swl/TravelTimeCalculator.java
new file mode 100644
index 0000000000..ce6e940dc2
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/swl/TravelTimeCalculator.java
@@ -0,0 +1,28 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.swl;
+
+import com.graphhopper.GHRequest;
+
+import java.util.concurrent.locks.Lock;
+
+public interface TravelTimeCalculator {
+    float getTravelTimeMilliseconds(int edge, int durationSeconds, String streetMode, GHRequest req);
+
+}
diff --git a/reader-osm/src/test/java/com/graphhopper/swl/TDNetworkIT.java b/web/src/test/java/com/graphhopper/swl/TDNetworkIT.java
similarity index 75%
rename from reader-osm/src/test/java/com/graphhopper/swl/TDNetworkIT.java
rename to web/src/test/java/com/graphhopper/swl/TDNetworkIT.java
index d58305c1e8..d0331dc7e9 100644
--- a/reader-osm/src/test/java/com/graphhopper/swl/TDNetworkIT.java
+++ b/web/src/test/java/com/graphhopper/swl/TDNetworkIT.java
@@ -20,38 +20,17 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osm.GraphHopperOSM;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.RoutingAlgorithmIT;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
-import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.routing.weighting.ShortestWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.details.PathDetail;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
 
-import static com.graphhopper.GraphHopperIT.DIR;
-import static com.graphhopper.util.Parameters.Algorithms.ASTAR;
-import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 
 public class TDNetworkIT {
     private GraphHopper graphHopper;
@@ -65,10 +44,10 @@ public void setUp() {
                 setStoreOnFlush(true).
                 setEncodingManager(encodingManager).setCHEnabled(false).
                 setWayPointMaxDistance(0).
-                setDataReaderFile(DIR + "/monaco.osm.gz").
+                setDataReaderFile("../core/files/monaco.osm.gz").
                 setGraphHopperLocation(graphFile).
                 importOrLoad();
-        }
+    }
 
     @Test
     public void testMonacoFastest() {
@@ -111,4 +90,15 @@ private long sumTimes(List<PathDetail> time) {
         return sum;
     }
 
+    private static TravelTimeCalculator getTravelTimeCalculator(File dir) {
+        if (dir.exists()) {
+            // TODO(sindelar): Fix logging and don't use println.
+            System.out.println("Using local congestion file");
+            return new FileTravelTimeCalculator(dir.getPath());
+        } else {
+            return null;
+        }
+    }
+
+
 }
