diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index 8750594f76..944ab7b1df 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -28,11 +28,16 @@
 import com.graphhopper.util.shapes.Circle;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Shape;
+// import com.graphhopper.util.shapes.Shape;
 import com.vividsolutions.jts.geom.*;
 
+import java.awt.geom.Point2D;
 import java.util.ArrayList;
 import java.util.List;
 
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.Geometry;
+
 /**
  * This class allows to find edges (or construct shapes) from shape filter.
  *
@@ -63,7 +68,8 @@ public void findClosestEdge(GHIntHashSet edgeIds, double lat, double lon, EdgeFi
         if (qr.isValid())
             edgeIds.add(qr.getClosestEdge().getEdge());
     }
-
+    
+    
     /**
      * This method fills the edgeIds hash with edgeIds found inside the specified shape
      */
@@ -97,6 +103,47 @@ protected boolean checkAdjacent(EdgeIteratorState edge) {
         };
         bfs.start(graph.createEdgeExplorer(filter), qr.getClosestNode());
     }
+    
+    /**
+     * This method fills the edgeIds hash with edgeIds found inside the specified shape
+     */
+    public void findEdgesInShape(final GHIntHashSet edgeIds, final Geometry shape, EdgeFilter filter) {
+    	//GHPoint center = shape.getCentroid();
+        Coordinate p = shape.getCentroid().getCoordinate();
+        //Point2D vp = viewport.toView(new Point2D.Double(p.x, p.y));
+        QueryResult qr = locationIndex.findClosest(p.x, p.y, filter);
+        // TODO: if there is no street close to the center it'll fail although there are roads covered. Maybe we should check edge points or some random points in the Shape instead?
+        if (!qr.isValid())
+            throw new IllegalArgumentException("Shape " + shape + " does not cover graph");
+        final GeometryFactory geomFact = new GeometryFactory();
+        Geometry snappedPoint = geomFact.createPoint(new Coordinate(qr.getSnappedPoint().lat, qr.getSnappedPoint().lon));
+        
+        if (shape.contains(snappedPoint))
+            edgeIds.add(qr.getClosestEdge().getEdge());
+
+        BreadthFirstSearch bfs = new BreadthFirstSearch() {
+            final NodeAccess na = graph.getNodeAccess();
+            final Geometry localShape = shape;
+
+            @Override
+            protected boolean goFurther(int nodeId) {
+            	Geometry naPoint = geomFact.createPoint(new Coordinate(na.getLatitude(nodeId), na.getLongitude(nodeId)));
+            	
+                return localShape.contains(naPoint);
+            }
+
+            @Override
+            protected boolean checkAdjacent(EdgeIteratorState edge) {
+            	Geometry adjPoint = geomFact.createPoint(new Coordinate(na.getLatitude(edge.getAdjNode()), na.getLongitude(edge.getAdjNode())));
+                if (localShape.contains(adjPoint)) {
+                    edgeIds.add(edge.getEdge());
+                    return true;
+                }
+                return false;
+            }
+        };
+        bfs.start(graph.createEdgeExplorer(filter), qr.getClosestNode());
+    }
 
     /**
      * This method fills the edgeIds hash with edgeIds found inside the specified geometry
@@ -128,6 +175,7 @@ public void fillEdgeIDs(GHIntHashSet edgeIds, Geometry geometry, EdgeFilter filt
     public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter, double useEdgeIdsUntilAreaSize) {
         final String objectSeparator = ";";
         final String innerObjSep = ",";
+        final String coordObjSep = " ";
         BlockArea blockArea = new BlockArea(graph);
 
         // Add blocked circular areas or points
@@ -136,29 +184,62 @@ public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter, doubl
             for (int i = 0; i < blockedCircularAreasArr.length; i++) {
                 String objectAsString = blockedCircularAreasArr[i];
                 String[] splittedObject = objectAsString.split(innerObjSep);
-                if (splittedObject.length == 4) {
-                    final BBox bbox = BBox.parseTwoPoints(objectAsString);
-                    if (bbox.calculateArea() > useEdgeIdsUntilAreaSize)
-                        blockArea.add(bbox);
-                    else
-                        findEdgesInShape(blockArea.blockedEdges, bbox, filter);
-                } else if (splittedObject.length == 3) {
-                    double lat = Double.parseDouble(splittedObject[0]);
-                    double lon = Double.parseDouble(splittedObject[1]);
-                    int radius = Integer.parseInt(splittedObject[2]);
-                    Circle circle = new Circle(lat, lon, radius);
-                    if (circle.calculateArea() > useEdgeIdsUntilAreaSize) {
-                        blockArea.add(circle);
+                boolean isXYFormat = (splittedObject.length >0 && splittedObject[0].split(coordObjSep).length ==2);
+                if(isXYFormat){
+                	if (splittedObject.length >= 3 ) {
+                		GeometryFactory gf = new GeometryFactory();
+                	    Coordinate[] coords = new Coordinate[splittedObject.length];
+                	    for  (int j = 0; j < splittedObject.length; j++){
+                	    	String[] coordXY = splittedObject[j].split(coordObjSep);
+                	    	coords[j] =  new Coordinate(Double.parseDouble(coordXY[0]), Double.parseDouble(coordXY[1]));
+                	    }
+                	    Polygon geom = gf.createPolygon(gf.createLinearRing(coords), null);
+                	    
+                        if (geom.getArea() > useEdgeIdsUntilAreaSize)
+                            blockArea.add(geom);
+                        else
+                            findEdgesInShape(blockArea.blockedEdges, geom, filter);
+                    }else{
+                    	throw new IllegalArgumentException(objectAsString + " at index " + i + " need to be defined as lat,lon "
+                                + "or as a circle lat,lon,radius or rectangular lat1,lon1,lat2,lon2");
+                    }
+                }else{
+                	if (splittedObject.length == 4 ) {
+                		
+                		GeometryFactory gf = new GeometryFactory();
+                	    Coordinate[] coords = new Coordinate[]{
+                	        new Coordinate(Double.parseDouble(splittedObject[0]), Double.parseDouble(splittedObject[1])),
+                	        new Coordinate(Double.parseDouble(splittedObject[2]), Double.parseDouble(splittedObject[1])),
+                	        new Coordinate(Double.parseDouble(splittedObject[2]), Double.parseDouble(splittedObject[3])),
+                	        new Coordinate(Double.parseDouble(splittedObject[0]), Double.parseDouble(splittedObject[3])),
+                	        new Coordinate(Double.parseDouble(splittedObject[0]), Double.parseDouble(splittedObject[1])),
+                	    };
+                	    Polygon geom = gf.createPolygon(gf.createLinearRing(coords), null);
+                	    
+                	    if (geom.getArea() > useEdgeIdsUntilAreaSize)
+                            blockArea.add(geom);
+                        else
+                            findEdgesInShape(blockArea.blockedEdges, geom, filter);
+                    } else if (splittedObject.length == 3) {
+                    	double lat = Double.parseDouble(splittedObject[0]);
+                        double lon = Double.parseDouble(splittedObject[1]);
+                        int radius = Integer.parseInt(splittedObject[2]);
+                        GeometryFactory geomFact = new GeometryFactory();
+                    	Geometry circle = geomFact.createPoint(new Coordinate(lat, lon)).buffer(radius);
+                      	
+                        if (circle.getArea() > useEdgeIdsUntilAreaSize) {
+                            blockArea.add(circle);
+                        } else {
+                            findEdgesInShape(blockArea.blockedEdges, circle, filter);
+                        }
+                    } else if (splittedObject.length == 2) {
+                        double lat = Double.parseDouble(splittedObject[0]);
+                        double lon = Double.parseDouble(splittedObject[1]);
+                        findClosestEdge(blockArea.blockedEdges, lat, lon, filter);
                     } else {
-                        findEdgesInShape(blockArea.blockedEdges, circle, filter);
+                        throw new IllegalArgumentException(objectAsString + " at index " + i + " need to be defined as lat,lon "
+                                + "or as a circle lat,lon,radius or rectangular lat1,lon1,lat2,lon2");
                     }
-                } else if (splittedObject.length == 2) {
-                    double lat = Double.parseDouble(splittedObject[0]);
-                    double lon = Double.parseDouble(splittedObject[1]);
-                    findClosestEdge(blockArea.blockedEdges, lat, lon, filter);
-                } else {
-                    throw new IllegalArgumentException(objectAsString + " at index " + i + " need to be defined as lat,lon "
-                            + "or as a circle lat,lon,radius or rectangular lat1,lon1,lat2,lon2");
                 }
             }
         }
@@ -170,7 +251,7 @@ public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter, doubl
      */
     public static class BlockArea {
         final GHIntHashSet blockedEdges = new GHIntHashSet();
-        final List<Shape> blockedShapes = new ArrayList<>();
+        final List<Geometry> blockedShapes = new ArrayList<>();
         private final NodeAccess na;
 
         public BlockArea(Graph g) {
@@ -181,7 +262,7 @@ public void add(int edgeId) {
             blockedEdges.addAll(edgeId);
         }
 
-        public void add(Shape shape) {
+        public void add(Geometry shape) {
             blockedShapes.add(shape);
         }
 
@@ -194,8 +275,11 @@ public final boolean contains(EdgeIteratorState edgeState) {
             }
 
             if (!blockedShapes.isEmpty() && na != null) {
-                for (Shape shape : blockedShapes) {
-                    if (shape.contains(na.getLatitude(edgeState.getAdjNode()), na.getLongitude(edgeState.getAdjNode())))
+            	GeometryFactory geomFact = new GeometryFactory();
+            	Geometry adjPoint = geomFact.createPoint(new Coordinate(na.getLatitude(edgeState.getAdjNode()), na.getLongitude(edgeState.getAdjNode())));
+            	
+                for (Geometry shape : blockedShapes) {
+                    if (shape.contains(adjPoint))
                         return true;
                 }
             }
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
index 856a8a4b05..367b0e0b0c 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
@@ -10,6 +10,10 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.shapes.Circle;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.Geometry;
+import com.vividsolutions.jts.geom.GeometryFactory;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -53,13 +57,22 @@ public void testBlockedByShape() {
         BlockAreaWeighting instance = new BlockAreaWeighting(new FastestWeighting(encoder), bArea);
         assertEquals(94.35, instance.calcWeight(edge, false, EdgeIterator.NO_EDGE), 0.01);
 
-        bArea.add(new Circle(0.01, 0.01, 100));
+        
+        GeometryFactory geomFact = new GeometryFactory();
+    	Geometry circle1 = geomFact.createPoint(new Coordinate(0.01, 0.01)).buffer(100);
+      	
+        bArea.add(circle1);
+        
+        
         assertEquals(Double.POSITIVE_INFINITY, instance.calcWeight(edge, false, EdgeIterator.NO_EDGE), .01);
 
         bArea = new GraphEdgeIdFinder.BlockArea(graph);
         instance = new BlockAreaWeighting(new FastestWeighting(encoder), bArea);
         // Do not match 1,1 of edge
-        bArea.add(new Circle(0.1, 0.1, 100));
+        
+        Geometry circle2 = geomFact.createPoint(new Coordinate(0.1, 0.1)).buffer(0.09);
+      	
+        bArea.add(circle2);
         assertEquals(94.35, instance.calcWeight(edge, false, EdgeIterator.NO_EDGE), .01);
     }
 
