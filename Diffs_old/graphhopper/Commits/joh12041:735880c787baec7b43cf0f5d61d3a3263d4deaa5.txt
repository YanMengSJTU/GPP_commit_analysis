diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 6d5e5a757b..0e0a9be8d3 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -38,10 +38,12 @@
     private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private List<String> description;
     private double distance;
+    private double distanceNonHighway;
     private double ascend;
     private double descend;
     private double routeWeight;
     private long time;
+    private long timeNonHighway;
     private String debugInfo = "";
     private InstructionList instructions;
     private PointList waypointList = PointList.EMPTY;
@@ -152,6 +154,16 @@ public PathWrapper setDistance(double distance) {
         return this;
     }
 
+    public double getNonHighwayDistance() {
+        check("getDistance");
+        return distanceNonHighway;
+    }
+
+    public PathWrapper setNonHighwayDistance(double distance) {
+        this.distanceNonHighway = distance;
+        return this;
+    }
+
     /**
      * This method returns the total elevation change (going upwards) in meter.
      * <p>
@@ -201,6 +213,16 @@ public PathWrapper setTime(long timeInMillis) {
         return this;
     }
 
+    public long getNonHighwayTime() {
+        check("getTimes");
+        return timeNonHighway;
+    }
+
+    public PathWrapper setNonHighwayTime(long timeInMillis) {
+        this.timeNonHighway = timeInMillis;
+        return this;
+    }
+
     /**
      * This method returns a double value which is better than the time for comparison of routes but
      * only if you know what you are doing, e.g. only to compare routes gained with the same query
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index de2ebfe722..9e34d96208 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -428,6 +428,8 @@ public boolean execute(final int traversalId, final SPTEntry fromSPTEntry) {
                                     setWeight(weight);
                             path.extract();
 
+                            //TODO: check if MVT exceeded per Quercia et al. and stop searching
+
                             // for now do not add alternatives to set, if we do we need to remove then on alternatives.clear too (see below)
                             // AtomicInteger tid = addToMap(traversalIDMap, path);
                             // int tid = traversalMode.createTraversalId(path.calcEdges().get(0), false);
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 707c99c190..11363f4ff5 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -49,6 +49,8 @@
     // we go upwards (via SPTEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
     protected long time;
+    protected double distanceNonHighway;
+    protected long timeNonHighway;
     /**
      * Shortest path tree entry
      */
@@ -167,6 +169,10 @@ public double getDistance() {
         return distance;
     }
 
+    public double getNonHighwayDistance() {
+        return distanceNonHighway;
+    }
+
     /**
      * @return time in millis
      */
@@ -174,6 +180,10 @@ public long getTime() {
         return time;
     }
 
+    public long getNonHighwayime() {
+        return timeNonHighway;
+    }
+
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
@@ -232,8 +242,14 @@ public String getDebugInfo() {
      */
     protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
-        distance += iter.getDistance();
-        time += weighting.calcMillis(iter, false, prevEdgeId);
+        double d = iter.getDistance();
+        long t = weighting.calcMillis(iter, false, prevEdgeId);
+        distance += d;
+        time += t;
+        if (d / (t / 1000.0) > 20)  {  // 20 m per sec just under 45 mph
+            distanceNonHighway += d;
+            timeNonHighway += t;
+        }
         addEdge(edgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 0f2ca2d7d6..98272fcf39 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -62,8 +62,10 @@ public PathMerger setEnableInstructions(boolean enableInstructions) {
     public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         int origPoints = 0;
         long fullTimeInMillis = 0;
+        long fullNHTimeInMillis = 0;
         double fullWeight = 0;
         double fullDistance = 0;
+        double fullNHDistance = 0;
         boolean allFound = true;
         int simplicity = 0;
 
@@ -74,7 +76,9 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
             Path path = paths.get(pathIndex);
             description.addAll(path.getDescription());
             fullTimeInMillis += path.getTime();
+            fullNHTimeInMillis += path.getNonHighwayime();
             fullDistance += path.getDistance();
+            fullNHDistance += path.getNonHighwayDistance();
             fullWeight += path.getWeight();
             if (enableInstructions) {
                 InstructionList il = path.calcInstructions(tr);
@@ -138,6 +142,8 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 setRouteWeight(fullWeight).
                 setDistance(fullDistance).
                 setTime(fullTimeInMillis).
+                setNonHighwayDistance(fullNHDistance).
+                setNonHighwayTime(fullNHTimeInMillis).
                 setSimplicity(simplicity);
     }
 
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
index 2bd77450df..9c0d626243 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
@@ -41,7 +41,7 @@
     private HashMap<String, Integer> gridCT;
     private GraphHopper hopper;
     private MapMatching mapMatching;
-    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,numCTs" +
+    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,numCTs,pctHighwayTime,pctHighwayDist" +
             System.getProperty("line.separator");
     private ArrayList<float[]> inputPoints = new ArrayList<>();
     private ArrayList<String> id_to_points = new ArrayList<>();
@@ -250,6 +250,27 @@ public void setDataSources() throws Exception {
             outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
             gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
+        } else if (city.equals("sin")) {
+            osmFile = osmFile + "singapore.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sin_noch";
+            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("lon")) {
+            osmFile = osmFile + "london_england.osm.pbf";
+            graphFolder = graphFolder + "ghosm_lon_noch";
+            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("man")) {
+            osmFile = osmFile + "manila_philippines.osm.pbf";
+            graphFolder = graphFolder + "ghosm_man_noch";
+            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
         } else {
             throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
         }
@@ -260,57 +281,64 @@ public void getGridValues() throws Exception {
         gridBeauty = new HashMap<>();
 
         for (String fn : gridValuesFNs) {
-            Scanner sc_in = new Scanner(new File(fn));
-            String[] gvHeader = sc_in.nextLine().split(",");
-            int i = 0;
-            for (String col : gvHeader) {
-                gvHeaderMap.put(col, i);
-                i++;
-            }
-            String line;
-            String[] vals;
-            String rc;
-            float beauty;
-            while (sc_in.hasNext()) {
-                line = sc_in.nextLine();
-                vals = line.split(",");
-                try {
-                    rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                    beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                    gridBeauty.put(rc, beauty);
-                } catch (NullPointerException ex) {
-                    System.out.println(ex.getMessage());
-                    System.out.println(line);
-                    continue;
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                String[] gvHeader = sc_in.nextLine().split(",");
+                int i = 0;
+                for (String col : gvHeader) {
+                    gvHeaderMap.put(col, i);
+                    i++;
+                }
+                String line;
+                String[] vals;
+                String rc;
+                float beauty;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
+                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
+                        gridBeauty.put(rc, beauty);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
                 }
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
             }
-
         }
     }
 
     public void getGridCTs() throws Exception {
         gridCT = new HashMap<>();
         for (String fn : gridCTsFNs) {
-            Scanner sc_in = new Scanner(new File(fn));
-            sc_in.nextLine();
-            String line;
-            String[] vals;
-            String rc;
-            int ct;
-            while (sc_in.hasNext()) {
-                line = sc_in.nextLine();
-                vals = line.split(",");
-                try {
-                    rc = vals[1] + "," + vals[0];
-                    ct = Integer.valueOf(vals[2]);
-                    gridCT.put(rc, ct);
-                } catch (NullPointerException ex) {
-                    System.out.println(ex.getMessage());
-                    System.out.println(line);
-                    continue;
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                sc_in.nextLine();
+                String line;
+                String[] vals;
+                String rc;
+                int ct;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[1] + "," + vals[0];
+                        ct = Integer.valueOf(vals[2]);
+                        gridCT.put(rc, ct);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
                 }
-            }
 
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
         }
     }
 
@@ -348,7 +376,11 @@ public String writeOutput(int i, String optimized, String name, String od_id, Pa
         PointList pointList = bestPath.getPoints();
         int simplicity = bestPath.getSimplicity();
         double distance = Math.round(bestPath.getDistance() * 100) / 100;
+        double nonHighwayDistance = bestPath.getNonHighwayDistance();
+        float pctNHD = Math.round(1000 * nonHighwayDistance / distance) / 1000;
         long timeInSec = bestPath.getTime() / 1000;
+        long nonHighwayTimeInSec = bestPath.getNonHighwayTime() / 1000;
+        float pctNHT = Math.round(1000 * (float) nonHighwayTimeInSec / timeInSec) / 1000;
         InstructionList il = bestPath.getInstructions();
         int numDirections = il.getSize();
         // iterate over every turn instruction
@@ -357,14 +389,17 @@ public String writeOutput(int i, String optimized, String name, String od_id, Pa
             maneuvers.add(instruction.getSimpleTurnDescription());
         }
 
-        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score + ";\tNumCts: " + numCTs);
+        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score + ";\tNumCts: " + numCTs + ";\tPctNHT: " + pctNHT + ";\tPctNHD: " + pctNHD);
         return od_id + "," + name + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                ",\"" + maneuvers.toString() + "\"" + "," + score + "," + simplicity + "," + numCTs + System.getProperty("line.separator");
+                ",\"" + maneuvers.toString() + "\"" + "," + score + "," + simplicity + "," + numCTs + "," + pctNHT + "," + pctNHD + System.getProperty("line.separator");
 
 
     }
 
     public int getNumCTs(PathWrapper path) {
+        if (gridCT.size() == 0) {
+            return -1;
+        }
         HashSet<String> roundedPoints = path.roundPoints();
         HashSet<Integer> cts = new HashSet<>();
         for (String pt : roundedPoints) {
@@ -500,17 +535,22 @@ public void process_routes() throws Exception {
         // Score each route on beauty to determine most beautiful
         int j = 0;
         float bestscore = -1000;
+        //float originalscore = getBeauty(paths.get(0));
         int routeidx = -1;
-        int capPathsPerMVT = paths.size() - 1;
+        //int capPathsPerMVT = paths.size() - 1;
         for (PathWrapper path : paths) {
             float score = getBeauty(path);
             if (score > bestscore) {
                 bestscore = score;
                 routeidx = j;
             }
-            System.out.println(j + "\t" + score);
+            //if ((bestscore - originalscore) < (bestscore / (j + 1))) {
+            //    j = j + 0;
+            //}
+            //System.out.println(j + "\t" + score);
             j++;
         }
+        //System.out.println("Most beautiful route: " + routeidx);
         responses.put("beauty", writeOutput(route, "Best", "beauty", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
         float maxBeauty = bestscore;
 
@@ -521,19 +561,19 @@ public void process_routes() throws Exception {
         routeidx = -1;
         double uglydistance;
         for (PathWrapper path : paths) {
-            if (j < capPathsPerMVT) {
-                uglydistance = path.getDistance();
-                if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
-                    float score = getBeauty(path);
-                    if (score < bestscore) {
-                        bestscore = score;
-                        routeidx = j;
-                    }
+            //if (j < capPathsPerMVT) {
+            uglydistance = path.getDistance();
+            if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
+                float score = getBeauty(path);
+                if (score < bestscore) {
+                    bestscore = score;
+                    routeidx = j;
                 }
-                j++;
-            } else {
-                break;
             }
+            j++;
+            //} else {
+            //    break;
+            //}
         }
         responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
 
@@ -551,6 +591,7 @@ public void process_routes() throws Exception {
             }
             j++;
         }
+        //System.out.println("Simplest route: " + routeidx);
         responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), beauty, getNumCTs(paths.get(routeidx))));
         float minSimplicity = bestscore;
 
@@ -572,6 +613,7 @@ public void process_routes() throws Exception {
             }
             j++;
         }
+        //System.out.println("Most beautiful-simple route: " + routeidx);
         responses.put("besi", writeOutput(route, "BeSi", "beauty-simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
 
         // Fewest # directions
@@ -589,6 +631,7 @@ public void process_routes() throws Exception {
             }
             j++;
         }
+        //System.out.println("Min directions route: " + routeidx);
         responses.put("mindirections", writeOutput(route, "MnDi", "mindirections", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
 
 
@@ -650,35 +693,11 @@ public static void main(String[] args) throws Exception {
         // PBFs from: https://mapzen.com/data/metro-extracts/
 
         //String city = args[0];
-        String city = "sf";  // nyc
-        String odtype = "grid";  // rand
+        String city = "lon";  // sf, nyc, chi, lon, man, sin
+        String odtype = "grid";  // grid, rand
         parallelKSP ksp = new parallelKSP(city, odtype);
         boolean matchexternal = false;
-        boolean getghroutes = false;
-        boolean testing = true;
-
-        if (testing) {
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.getGridCTs();
-            ksp.prepMapMatcher();  // score external API routes
-            String inputfolder = "../data/SCRATCH/";
-            String outputfolder = "../data/SCRATCH/";
-            ArrayList<String> platforms = new ArrayList<>();
-            platforms.add("mapquest");
-            ArrayList<String> conditions = new ArrayList<>();
-            conditions.add("traffic");
-            ArrayList<String> routetypes = new ArrayList<>();
-            routetypes.add("main");
-            for (String platform : platforms) {
-                for (String condition : conditions) {
-                    for (String routetype : routetypes) {
-                        ksp.PointsToPath(inputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
-                    }
-                }
-            }
-        }
+        boolean getghroutes = true;
 
         if (matchexternal) {
             ksp.setDataSources();
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java
new file mode 100644
index 0000000000..e4384fa3c7
--- /dev/null
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java
@@ -0,0 +1,624 @@
+package com.graphhopper.reader.osm;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.matching.MapMatching;
+import com.graphhopper.matching.MatchResult;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.*;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Created by isaac on 09/14/16.
+ */
+public class parallelKSP_debug {
+
+    String city;
+    String route_type;
+    HashMap<String, FileWriter> outputFiles;
+    private String osmFile = "./reader-osm/files/";
+    private String graphFolder = "./reader-osm/target/tmp/";
+    private String inputPointsFN = "../data/intermediate/";
+    private String outputPointsFN = "../data/testing/";
+    private String gvfnStem = "../data/intermediate/";
+    private String gctfnStem = "../geometries/";
+    private ArrayList<String> gridValuesFNs = new ArrayList<>();
+    private ArrayList<String> gridCTsFNs = new ArrayList<>();
+    private HashMap<String, Integer> gvHeaderMap;
+    private HashMap<String, Float> gridBeauty;
+    private HashMap<String, Integer> gridCT;
+    private GraphHopper hopper;
+    private MapMatching mapMatching;
+    private String outputheader = "ID";
+    private ArrayList<float[]> inputPoints = new ArrayList<>();
+    private ArrayList<String> id_to_points = new ArrayList<>();
+    private ArrayList<String> optimizations = new ArrayList<>();
+    private int stepsize = 10;
+    private int maxstep = 500;
+
+
+    public parallelKSP_debug(String city, String route_type) {
+
+        this.city = city;
+        this.route_type = route_type;
+        this.outputFiles = new HashMap<>();
+        optimizations.add("beauty");
+        optimizations.add("simple");
+        for (int i = stepsize; i < maxstep + 1; i += stepsize) {
+            outputheader = outputheader + "," + i + "pct";
+        }
+        outputheader = outputheader + System.getProperty("line.separator");
+
+    }
+
+    public void setCity(String city) {
+        this.city = city;
+    }
+
+    public void setRouteType(String route_type) {
+        this.route_type = route_type;
+    }
+
+    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
+        PathWrapper matchGHRsp = new PathWrapper();
+        try {
+            MatchResult mr = mapMatching.doWork(gpxEntries);
+            Path path = mapMatching.calcPath(mr);
+            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
+        }
+        catch (RuntimeException e) {
+            System.out.println("Broken GPX trace.");
+            System.out.println(e.getMessage());
+        }
+        return matchGHRsp;
+    }
+
+    public void PointsToPath(String fin, String fout) throws IOException {
+        Scanner sc_in = new Scanner(new File(fin));
+        String[] pointsHeader = sc_in.nextLine().split(",");
+        int idIdx = -1;
+        int nameIdx = -1;
+        int latIdx = -1;
+        int lonIdx = -1;
+        int timeIdx = -1;
+        for (int i=0; i<pointsHeader.length; i++) {
+            if (pointsHeader[i].equalsIgnoreCase("ID")) {
+                idIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("name")) {
+                nameIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
+                latIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
+                lonIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
+                timeIdx = i;
+            }
+            else {
+                System.out.println("Unexpected header value: " + pointsHeader[i]);
+            }
+        }
+        String optimized = "";
+        if (fin.indexOf("google") > -1) {
+            optimized = optimized + "Goog";
+        } else if (fin.indexOf("mapquest") > -1) {
+            optimized = optimized + "MapQ";
+        } else {
+            System.out.println("Don't recognize platform: " + fin);
+        }
+        if (fin.indexOf("alt") > -1) {
+            optimized = optimized + " altn";
+        } else if (fin.indexOf("main") > -1) {
+            optimized = optimized + " main";
+        } else {
+            System.out.println("Don't recognize route type: " + fin);
+        }
+        String line;
+        String[] vals;
+        String routeID = "";
+        String prevRouteID = "";
+        String name = "";
+        String prevName = "";
+        String label = "";
+        String prevLabel = "";
+        double lat;
+        double lon;
+        long time;
+        HashMap<String, ArrayList<GPXEntry>> pointsLists = new HashMap<>();
+        HashMap<String, String> routeNames = new HashMap<>();
+        ArrayList<GPXEntry> pointsList = new ArrayList<>();
+        while (sc_in.hasNext()) {
+            line = sc_in.nextLine();
+            vals = line.split(",");
+            routeID = vals[idIdx];
+            name = vals[nameIdx];
+            if (name.equalsIgnoreCase("alternative 2") || name.equalsIgnoreCase("alternative 3")) {
+                continue;
+            }
+            lat = Double.valueOf(vals[latIdx]);
+            lon = Double.valueOf(vals[lonIdx]);
+            time = Long.valueOf(vals[timeIdx]);
+            label = routeID + "|" + name;
+            GPXEntry pt = new GPXEntry(lat, lon, time);
+            if (label.equalsIgnoreCase(prevLabel)) {
+                pointsList.add(pt);
+            }
+            else if (pointsList.size() > 0) {
+                pointsLists.put(prevRouteID, pointsList);
+                routeNames.put(prevRouteID, prevName);
+                pointsList = new ArrayList<>();
+                pointsList.add(pt);
+            } else {
+                System.out.println("First point.");
+                pointsList.add(pt);
+            }
+            prevRouteID = routeID;
+            prevName = name;
+            prevLabel = label;
+        }
+        if (pointsList.size() > 0) {
+            pointsLists.put(prevRouteID, pointsList);
+            routeNames.put(prevRouteID, prevName);
+        }
+        sc_in.close();
+
+        ConcurrentHashMap<String, String> results = getPaths(pointsLists, routeNames, optimized);
+        FileWriter sc_out = new FileWriter(fout, true);
+        sc_out.write(outputheader);
+        for (String result : results.values()) {
+            sc_out.write(result);
+        }
+        sc_out.close();
+    }
+
+    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists, HashMap<String, String> routeNames, String optimized) {
+
+        AtomicInteger num_processed = new AtomicInteger();
+        int num_routes = pointLists.size();
+        Set<String> routeIDs = pointLists.keySet();
+
+        ConcurrentHashMap<String, String> results = new ConcurrentHashMap<>();
+        routeIDs.parallelStream().forEach(routeID -> {
+            System.out.println("Processing: " + routeID);
+            int i = num_processed.incrementAndGet();
+            PathWrapper path = GPXToPath(pointLists.get(routeID));
+            if (path.getDistance() > 0) {
+                float score = getBeauty(path);
+                results.put(routeID, writeOutput(routeID, new float[1]));
+            }
+            if (i % 50 == 0) {
+                System.out.println(i + " of " + num_routes + " routes matched.");
+            }
+        }
+        );
+
+        return results;
+    }
+
+    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
+    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
+        return new PathWrapper();
+    }
+
+
+    public void setDataSources() throws Exception {
+        if (city.equals("sf")) {
+            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sf_noch";
+            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
+        } else if (city.equals("nyc")) {
+            osmFile = osmFile + "new-york_new-york.osm.pbf";
+            graphFolder = graphFolder + "ghosm_nyc_noch";
+            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
+        } else if (city.equals("bos")) {
+            osmFile = osmFile + "boston_massachusetts.osm.pbf";
+            graphFolder = graphFolder + "ghosm_bos_noch";
+            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
+            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
+        } else if (city.equals("chi")) {
+            osmFile = osmFile + "chicago_illinois.osm.pbf";
+            graphFolder = graphFolder + "ghosm_chi_noch";
+            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
+        } else if (city.equals("sin")) {
+            osmFile = osmFile + "singapore.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sin_noch";
+            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("lon")) {
+            osmFile = osmFile + "london_england.osm.pbf";
+            graphFolder = graphFolder + "ghosm_lon_noch";
+            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("man")) {
+            osmFile = osmFile + "manila_philippines.osm.pbf";
+            graphFolder = graphFolder + "ghosm_man_noch";
+            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else {
+            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
+        }
+    }
+
+    public void getGridValues() throws Exception {
+        gvHeaderMap = new HashMap<>();
+        gridBeauty = new HashMap<>();
+
+        for (String fn : gridValuesFNs) {
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                String[] gvHeader = sc_in.nextLine().split(",");
+                int i = 0;
+                for (String col : gvHeader) {
+                    gvHeaderMap.put(col, i);
+                    i++;
+                }
+                String line;
+                String[] vals;
+                String rc;
+                float beauty;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
+                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
+                        gridBeauty.put(rc, beauty);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
+                }
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
+        }
+    }
+
+    public void getGridCTs() throws Exception {
+        gridCT = new HashMap<>();
+        for (String fn : gridCTsFNs) {
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                sc_in.nextLine();
+                String line;
+                String[] vals;
+                String rc;
+                int ct;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[1] + "," + vals[0];
+                        ct = Integer.valueOf(vals[2]);
+                        gridCT.put(rc, ct);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
+                }
+
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
+        }
+    }
+
+    public void prepareGraphHopper() {
+        // create one GraphHopper instance
+        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
+        hopper.setDataReaderFile(osmFile);
+        // where to store graphhopper files?
+        hopper.setGraphHopperLocation(graphFolder);
+        hopper.setEncodingManager(new EncodingManager("car"));
+
+        // now this can take minutes if it imports or a few seconds for loading
+        // of course this is dependent on the area you import
+        hopper.importOrLoad();
+    }
+
+    public void prepMapMatcher() {
+
+        // create MapMatching object, can and should be shared accross threads
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(Parameters.Algorithms.DIJKSTRA).
+                traversalMode(hopper.getTraversalMode()).
+                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
+                build();
+        mapMatching = new MapMatching(hopper, algoOpts);
+        mapMatching.setTransitionProbabilityBeta(0.00959442);
+//        mapMatching.setTransitionProbabilityBeta(0.000959442);
+        mapMatching.setMeasurementErrorSigma(100);
+    }
+
+
+    public String writeOutput(String od_id, float[] tradeoffs) {
+        // preps output for CSV
+        String result = od_id;
+        int num_bins = tradeoffs.length;
+        for (int i = 0; i < num_bins; i++) {
+            if (tradeoffs[i] > 0) {
+                result = result + "," + tradeoffs[i];
+            } else {
+                result = result + ",";
+            }
+        }
+        return result + System.getProperty("line.separator");
+    }
+
+    public int getNumCTs(PathWrapper path) {
+        if (gridCT.size() == 0) {
+            return -1;
+        }
+        HashSet<String> roundedPoints = path.roundPoints();
+        HashSet<Integer> cts = new HashSet<>();
+        for (String pt : roundedPoints) {
+            if (gridCT.containsKey(pt)) {
+                cts.add(gridCT.get(pt));
+            }
+        }
+        return cts.size();
+    }
+
+    public float getBeauty(PathWrapper path) {
+        HashSet<String> roundedPoints = path.roundPoints();
+        float score = 0;
+        for (String pt : roundedPoints) {
+            if (gridBeauty.containsKey(pt)) {
+                score = score + gridBeauty.get(pt);
+            }
+        }
+        score = score / roundedPoints.size();
+        return score;
+    }
+
+    public void setODPairs() throws Exception {
+        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
+        for (String optimization : optimizations) {
+            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_tradeoffs" + optimization + ".csv"), true));
+        }
+
+        for (FileWriter fw : outputFiles.values()) {
+            fw.write(outputheader);
+        }
+
+        // Bring in origin-destination pairs for processing
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
+        String header = sc_in.nextLine();
+        String od_id;
+        float laF;
+        float loF;
+        float laT;
+        float loT;
+        float idx = 0;
+        System.out.println("Input data points header: " + header);
+        while (sc_in.hasNext()) {
+            idx = idx + 1;
+            String line = sc_in.nextLine();
+            String[] vals = line.split(",");
+            od_id = vals[0];
+            loF = Float.valueOf(vals[1]);
+            laF = Float.valueOf(vals[2]);
+            loT = Float.valueOf(vals[3]);
+            laT = Float.valueOf(vals[4]);
+            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
+            id_to_points.add(od_id);
+        }
+        int numPairs = inputPoints.size();
+        System.out.println(numPairs + " origin-destination pairs.");
+
+    }
+
+    public void process_routes() throws Exception {
+
+        AtomicInteger num_processed = new AtomicInteger();
+        int num_odpairs = id_to_points.size();
+
+        ConcurrentHashMap<String, ConcurrentHashMap<String, String>> results = new ConcurrentHashMap<>();
+        for (String optimization : optimizations) {
+            results.put(optimization, new ConcurrentHashMap<>());
+        }
+        id_to_points.parallelStream().forEach(od_id -> {
+            System.out.println("Processing: " + od_id);
+            int route = id_to_points.indexOf(od_id);
+            HashMap<String, String> routes = process_route(route);
+            for (String optimization : optimizations) {
+                results.get(optimization).put(od_id, routes.getOrDefault(optimization, "FAILURE"));
+            }
+            int i = num_processed.incrementAndGet();
+            if (i % 50 == 0) {
+                System.out.println(i + " of " + num_odpairs + " o-d pairs processed.");
+            }
+        }
+        );
+
+        for (String optimization : optimizations) {
+            for (String result : results.get(optimization).values()) {
+                outputFiles.get(optimization).write(result);
+            }
+            outputFiles.get(optimization).close();
+        }
+    }
+
+
+    public HashMap<String, String> process_route(int route) {
+        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
+        float[] points;
+        String od_id;
+        HashMap<String, String> responses = new HashMap<>();
+
+        // Get Routes
+        points = inputPoints.get(route);
+        od_id = id_to_points.get(route);
+        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("ksp");
+        GHResponse rsp = hopper.route(req);
+
+        String defaultRow = od_id;
+        for (int i = stepsize; i < maxstep + 1; i = i + stepsize) {
+            defaultRow = defaultRow + ",";
+        }
+        defaultRow = defaultRow + System.getProperty("line.separator");
+
+        // first check for errors
+        if (rsp.hasErrors()) {
+            // handle them!
+            System.out.println(rsp.getErrors().toString());
+            System.out.println(route + ": Error - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        // Get All Routes (up to 10K right now)
+        List<PathWrapper> paths = rsp.getAll();
+
+        if (paths.size() == 0) {
+            System.out.println(route + ": No paths - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        float[] tradeoffs = new float[Math.floorDiv(maxstep, stepsize)];
+        long mintime = paths.get(0).getTime();
+        float defaultbeauty = getBeauty(paths.get(0));
+        int defaultsimplicity = paths.get(0).getSimplicity();
+
+        // Score each route on beauty to determine most beautiful
+        int j = 0;
+        float bestscore = defaultbeauty;
+        int prevbinstep = 0;
+        for (PathWrapper path : paths) {
+            float score = getBeauty(path);
+            if (score > bestscore) {
+                bestscore = score;
+                int curbinstep = (int) (((bestscore / defaultbeauty * 100) - 100) / stepsize);
+                float time_tradeoff = (float) path.getTime() / mintime;
+                for (int i = prevbinstep; i < curbinstep; i++) {
+                    tradeoffs[i] = time_tradeoff;
+                }
+            }
+            j++;
+        }
+        responses.put("beauty", writeOutput(od_id, tradeoffs));
+
+        // Simplest Route
+        j = 0;
+        bestscore = defaultsimplicity;
+        prevbinstep = 0;
+        tradeoffs = new float[Math.floorDiv(maxstep, stepsize)];
+        for (PathWrapper path : paths) {
+            int score = path.getSimplicity();
+            if (score < bestscore) {
+                bestscore = score;
+                int curbinstep = (int) ((100 - (bestscore * 100.0 / defaultsimplicity)) / stepsize);
+                float time_tradeoff = (float) path.getTime() / mintime;
+                for (int i = prevbinstep; i < curbinstep; i++) {
+                    tradeoffs[i] = time_tradeoff;
+                }
+            }
+            j++;
+        }
+        responses.put("simple", writeOutput(od_id, tradeoffs));
+
+        return responses;
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        // PBFs from: https://mapzen.com/data/metro-extracts/
+        if (false) {
+            System.out.println((int) (((0.0035 / 0.0018 * 100) - 100) / 25));  // 3
+            System.out.println((int) (((0.0035 / 0.0017 * 100) - 100) / 25));  // 4
+            System.out.println((int) (((0.0035 / 0.0033 * 100) - 100) / 25));  // 0
+            System.out.println((int) ((100 - (79 * 100.0 / 100)) / 10));  // 2
+            System.out.println((int) ((100 - (81 * 100.0 / 100)) / 10));  // 1
+            System.out.println((int) ((100 - (80 * 100.0 / 87)) / 10));  // 0
+            System.out.println((int) ((100 - (90 * 100.0 / 100)) / 10));  // 1
+            return;
+        }
+        //String city = args[0];
+        String city = "sf";  // sf, nyc, chi, lon, man, sin
+        String odtype = "grid";  // grid, rand
+        parallelKSP_debug ksp = new parallelKSP_debug(city, odtype);
+        boolean matchexternal = false;
+        boolean getghroutes = true;
+
+        if (matchexternal) {
+            ksp.setDataSources();
+            ksp.getGridValues();
+            ksp.prepareGraphHopper();
+            ksp.getGridCTs();
+            ksp.prepMapMatcher();  // score external API routes
+            String inputfolder = "../data/intermediate/";
+            String outputfolder = "../data/SCRATCH/";
+            ArrayList<String> platforms = new ArrayList<>();
+            platforms.add("google");
+            platforms.add("mapquest");
+            ArrayList<String> conditions = new ArrayList<>();
+            conditions.add("traffic");
+            conditions.add("notraffic");
+            ArrayList<String> routetypes = new ArrayList<>();
+            routetypes.add("main");
+            routetypes.add("alt");
+            for (String platform : platforms) {
+                for (String condition : conditions) {
+                    for (String routetype : routetypes) {
+                        ksp.PointsToPath(inputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
+                    }
+                }
+            }
+        }
+
+        if (getghroutes) {
+            ksp.setDataSources();
+            ksp.getGridValues();
+            ksp.prepareGraphHopper();
+            ksp.setODPairs();
+            ksp.process_routes();  // get Graphhopper routes
+        }
+    }
+}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
index 1e8901a40e..79007bdef3 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -569,52 +569,44 @@ public static void main(String[] args) throws Exception {
 
         // PBFs from: https://mapzen.com/data/metro-extracts/
 
-        String city = args[0];
-        runKSP ksp = new runKSP(city, "grid");
-
-        // SF Grid
-        //runKSP ksp = new runKSP("SF", "grid");
-
-        // SF Random
-        //runKSP ksp = new runKSP("SF", "rand");
-
-        // NYC Grid
-        //runKSP ksp = new runKSP("NYC", "grid");
-
-        // NYC Random
-        //runKSP ksp = new runKSP("NYC", "rand");
-
-        // BOS Check
-        //runKSP ksp = new runKSP("BOS", "check");
-
-        ksp.setDataSources();
-        ksp.getGridValues();
-        ksp.prepareGraphHopper();
-        ksp.getGridCTs();
-        ksp.prepMapMatcher();  // score external API routes
-        String inputfolder = "../data/intermediate/";
-        String outputfolder = "../data/output/";
-        ArrayList<String> platforms = new ArrayList<>();
-        platforms.add("google");
-        platforms.add("mapquest");
-        ArrayList<String> conditions = new ArrayList<>();
-        conditions.add("traffic");
-        conditions.add("notraffic");
-        ArrayList<String> routetypes = new ArrayList<>();
-        routetypes.add("main");
-        routetypes.add("alt");
-        for (String platform : platforms) {
-            for (String condition : conditions) {
-                for (String routetype : routetypes) {
-                    ksp.PointsToPath(inputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
+        //String city = args[0];
+        String city = "nyc";
+        runKSP ksp = new runKSP(city.toUpperCase(), "grid");
+        boolean matchexternal = false;
+        boolean getghroutes = true;
+
+        if (matchexternal) {
+            ksp.setDataSources();
+            ksp.getGridValues();
+            ksp.prepareGraphHopper();
+            ksp.getGridCTs();
+            ksp.prepMapMatcher();  // score external API routes
+            String inputfolder = "../data/intermediate/";
+            String outputfolder = "../data/output/";
+            ArrayList<String> platforms = new ArrayList<>();
+            platforms.add("google");
+            platforms.add("mapquest");
+            ArrayList<String> conditions = new ArrayList<>();
+            conditions.add("traffic");
+            conditions.add("notraffic");
+            ArrayList<String> routetypes = new ArrayList<>();
+            routetypes.add("main");
+            routetypes.add("alt");
+            for (String platform : platforms) {
+                for (String condition : conditions) {
+                    for (String routetype : routetypes) {
+                        ksp.PointsToPath(inputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_grid_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
+                    }
                 }
             }
         }
 
-        //ksp.setDataSources();
-        //ksp.getGridValues();
-        //ksp.prepareGraphHopper();
-        //ksp.getGridCTs();
-        //ksp.process_routes();  // get Graphhopper routes
+        if (getghroutes) {
+            ksp.setDataSources();
+            ksp.getGridValues();
+            ksp.prepareGraphHopper();
+            ksp.getGridCTs();
+            ksp.process_routes();  // get Graphhopper routes
+        }
     }
 }
