diff --git a/.gitignore b/.gitignore
index ab07f17340..3731f11fbf 100644
--- a/.gitignore
+++ b/.gitignore
@@ -36,3 +36,4 @@ android/.gradle
 .classpath
 .project
 local.properties
+tracks/
diff --git a/core/pom.xml b/core/pom.xml
index 949b694ccf..beae148e52 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -91,6 +91,20 @@
             <version>20140107</version>
             <scope>test</scope>
         </dependency>
+
+        <!-- for using profiles -->
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>map-matching</artifactId>
+            <!-- or 0.6-SNAPSHOT for the unstable -->
+            <version>0.5.0.0</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-math3</artifactId>
+            <version>3.5</version>
+        </dependency>
         
     </dependencies>
         
diff --git a/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java b/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java
new file mode 100644
index 0000000000..043d2e7d78
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/GPXDataExtractor.java
@@ -0,0 +1,199 @@
+package com.graphhopper.util.profiles;
+
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.matching.*;
+
+import com.graphhopper.reader.dem.HighPrecisionSRTMProvider;
+import com.graphhopper.routing.util.BikeGenericFlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class GPXDataExtractor {
+
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+
+    public static final int FILTER_KALMAN_FORWARD = 1;
+    public static final int FILTER_KALMAN_BACKWARD = 2;
+    public static final int FILTER_KALMAN_COMBINED = 3;
+    public static final int FILTER_MEAN = 4;
+
+    private List<GPXEntry> inputGPXEntries;
+    private List<TrackPart> trackParts;
+    private MapMatching mapMatching;
+    private BikeGenericFlagEncoder encoder;
+    private int filterType = FILTER_KALMAN_FORWARD;
+    private int filterDistance = 100;
+
+    private double[] distances;
+    private double[] elevations;
+
+    public GPXDataExtractor() {}
+
+    public void setFile(GPXFile gpxFile){
+        this.inputGPXEntries = gpxFile.getEntries();
+        this.distances = new double[inputGPXEntries.size() - 1];
+        this.elevations = new double[inputGPXEntries.size()];
+    }
+
+    public void configFilter(int filterType, int filterDistance) {
+        this.filterType = filterType;
+        this.filterDistance = filterDistance;
+    }
+
+    public void setupMapMatching(GraphHopper hopper){
+
+        // import OpenStreetMap data
+        /*CmdArgs args = CmdArgs.readFromConfig("config", "graphhopper.config");
+        GraphHopper hopper = new GraphHopper();
+        hopper.setOSMFile(pbfFileName);
+        String graphHopperLocation = Helper.pruneFileEnd(pbfFileName) + "-gh";
+        hopper.setGraphHopperLocation(graphHopperLocation);
+        encoder = new BikeGenericFlagEncoder();
+
+        hopper.setEncodingManager(new EncodingManager(encoder));
+        hopper.setElevation(true);
+        hopper.setElevationProvider(new HighPrecisionSRTMProvider());
+        hopper.setCHEnable(false);
+        hopper.setPreciseIndexResolution(300);
+        hopper.importOrLoad();
+        */
+
+        // create MapMatching object, can and should be shared accross threads
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
+        LocationIndexMatch locationIndex = new LocationIndexMatch(graph, (LocationIndexTree) hopper.getLocationIndex());
+        encoder = (BikeGenericFlagEncoder) hopper.getEncodingManager().getEncoder("generic_bike");
+
+        mapMatching = new MapMatching(graph, locationIndex, encoder);
+        mapMatching.setForceRepair(true);
+        mapMatching.setMaxSearchMultiplier(100);
+
+    }
+
+    public boolean isMapMatchingEnabled(){
+        return (mapMatching != null && encoder != null);
+    }
+
+    public List<TrackPart> extract(){
+
+        if(this.inputGPXEntries == null)
+            return Collections.emptyList();
+
+        processGPXData();
+
+        if(isMapMatchingEnabled())
+            processOSMData();
+
+        return trackParts;
+    }
+
+
+    private double[] filterMeasurements(final double[] measurements){
+
+        SmoothingFilter smoothingFilter;
+
+        switch(filterType){
+            case FILTER_KALMAN_FORWARD:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.FORWARD, 6, distances, filterDistance);
+                break;
+            case FILTER_KALMAN_BACKWARD:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.BACKWARD, 6, distances, filterDistance);
+                break;
+            case FILTER_KALMAN_COMBINED:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.COMBINED, 6, distances, filterDistance);
+                break;
+            case FILTER_MEAN:
+                smoothingFilter = new MeanFilter(distances, filterDistance);
+                break;
+            default:
+                smoothingFilter = new SimpleKalmanFilter(SimpleKalmanFilter.FORWARD, 6, distances, filterDistance);
+                break;
+        }
+
+        return smoothingFilter.smooth(measurements);
+
+    }
+
+
+    private void processGPXData(){
+
+        // 1. Step: Extract elevation and distance from GPX file
+
+        elevations[0] = inputGPXEntries.get(0).getEle();
+
+        for (int i = 1; i < inputGPXEntries.size(); i++) {
+
+            double firstLat = inputGPXEntries.get(i-1).getLat();
+            double firstLon = inputGPXEntries.get(i-1).getLon();
+            double secondLat = inputGPXEntries.get(i).getLat();
+            double secondLon = inputGPXEntries.get(i).getLon();
+
+            distances[i-1] = distCalc.calcDist(firstLat, firstLon, secondLat, secondLon);
+            System.out.print(", " + distances[i-1]);
+            elevations[i] = inputGPXEntries.get(i).getEle();
+
+        }
+
+        // 2. Step: Filter elevations
+        elevations = filterMeasurements(elevations);
+
+        // 3. Step: Split GPX into > 200 m track parts
+        List<GPXEntry> gpxEntryList;
+        trackParts = new ArrayList<TrackPart>();
+
+        for (int i = 0; i < inputGPXEntries.size(); i++){
+
+            int next = 1;
+            gpxEntryList = new ArrayList<GPXEntry>();
+            gpxEntryList.add(inputGPXEntries.get(i));
+            gpxEntryList.add(inputGPXEntries.get(i + next));
+
+            double distance = distances[i];
+            double elevation = elevations[i+next] - elevations[i];
+
+            while(distance < 200 && i+next+1 < inputGPXEntries.size()) {
+                next++;
+                gpxEntryList.add(inputGPXEntries.get(i+next));
+                distance += distances[i+next-1];
+                elevation += elevations[i+next] - elevations[i+next-1];
+            }
+
+            double slope = elevation / distance * 100;
+            distance = Math.sqrt((elevation * elevation) + (distance * distance)); // Update distance to 3D distance
+            double speed = distance / ((gpxEntryList.get(gpxEntryList.size() -1).getTime() - gpxEntryList.get(0).getTime()) / 1000) * 3.6;
+
+            trackParts.add(new TrackPart(gpxEntryList, distance, slope, speed));
+
+            if(i+next+1 == inputGPXEntries.size())
+                break;
+
+            i = i+next-1;
+
+        }
+
+    }
+
+    private void processOSMData() {
+
+        for (TrackPart tp : trackParts) {
+
+            try {
+                MatchResult mr = mapMatching.doWork(tp.getGpxEntryList());
+                List<EdgeMatch> matches = mr.getEdgeMatches();
+
+                for (EdgeMatch match : matches) {
+                    long flags = match.getEdgeState().getFlags();
+                    tp.setWayType((int) encoder.getWayType(flags));
+                }
+            } catch (Exception e) { // Skip track parts, which could not be matched to an edge in OSM}
+            }
+
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/Main.java b/core/src/main/java/com/graphhopper/util/profiles/Main.java
new file mode 100644
index 0000000000..6db3f07291
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/Main.java
@@ -0,0 +1,129 @@
+package com.graphhopper.util.profiles;
+
+import com.graphhopper.util.profiles.operations.AddToProfileOperation;
+import com.graphhopper.util.profiles.operations.CreateProfileOperation;
+import com.graphhopper.util.profiles.operations.Operation;
+import com.graphhopper.util.profiles.operations.PrintProfileOperation;
+
+public class Main {
+
+    public static void main(String[] args) {
+
+        String operationType = args[0];
+        Operation op = null;
+
+        System.out.println("Operation: " + args[0]);
+
+        if(operationType.equalsIgnoreCase("create")){
+            op = new CreateProfileOperation(args);
+        } else if (operationType.equalsIgnoreCase("add")){
+            op = new AddToProfileOperation(args);
+        } else if (operationType.equalsIgnoreCase("print")){
+            op = new PrintProfileOperation(args);
+        }
+
+        if(op != null)
+            op.run();
+
+        /*
+        // import OpenStreetMap data
+        GraphHopper hopper = new GraphHopper();
+        hopper.setOSMFile("./" + pbfFileName);
+        hopper.setGraphHopperLocation("./cache");
+        BikeGenericFlagEncoder encoder = new BikeGenericFlagEncoder();
+
+        hopper.setEncodingManager(new EncodingManager(encoder));
+        hopper.setElevation(true);
+        hopper.setElevationProvider(new HighPrecisionSRTMProvider());
+        hopper.setCHEnable(false);
+        hopper.setPreciseIndexResolution(300);
+        hopper.importOrLoad();
+
+        // create MapMatching object, can and should be shared accross threads
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
+        LocationIndexMatch locationIndex = new LocationIndexMatch(graph, (LocationIndexTree) hopper.getLocationIndex());
+
+
+        MapMatching mapMatching = new MapMatching(graph, locationIndex, encoder);
+        mapMatching.setForceRepair(true);
+        mapMatching.setMaxSearchMultiplier(100);
+
+        // do the actual matching, get the GPX entries from a file or via stream
+
+        GPXDataExtractor gpxDataExtractor = new GPXDataExtractor();
+        gpxDataExtractor.setupMapMatching(mapMatching, encoder);
+        gpxDataExtractor.configFilter(GPXDataExtractor.FILTER_KALMAN_COMBINED, 100);
+
+        String[] files = null;
+
+        files = new String[]{ "Garmin_150629_Seis_Seiser_Alm.gpx",
+                "Garmin_150629_Seiser_Alm_Seis.gpx",
+                "Garmin_150704_Konstantin_Seis.gpx",
+                "Garmin_150704_Seis_Konstantin.gpx",
+                "Garmin_150706_Ritsch_Kompatsch.gpx",
+                "Garmin_150706_Seis_Pufls_Seiser_Alm.gpx",
+                "Garmin_150706_Seiser_Alm_Seis.gpx",
+                "Garmin_160915_Seis_Fursch.gpx",
+                "Garmin_200915_Kastelruth_Seis.gpx",
+                "Garmin_200915_Seis_Kastelruth.gpx"};
+
+        //files = new String[]{"Sella_Ronda_-_Ed._2014.gpx", "Sellaronda_hero_2014.gpx" };
+
+        GPXFile gpxFile;
+        RidersProfile ridersProfile = new RidersProfile();
+        int skippedTrackParts = 0;
+
+        for(int i = 0; i < files.length; i++){
+            gpxFile = new GPXFile().doImport("./track-data/" + files[i]);
+            gpxDataExtractor.setFile(gpxFile);
+            skippedTrackParts += ridersProfile.update(gpxDataExtractor.extract());
+        }
+
+
+        /*int waytype = 0;
+
+        for(int i = -30; i < 30; i++) {
+
+            if(ridersProfile.getEntry(waytype,i) == null)
+                continue;
+
+            System.out.println(i + " " + ridersProfile.getEntry(waytype,i).getSpeed());
+
+        }
+
+        //System.out.println(ridersProfile);
+        System.out.println(ridersProfile.getTotalDistance());
+        System.out.println(ridersProfile.getDistance(0));
+
+        double[] tmp = ridersProfile.getWayTypePriority();
+        double totalDist = ridersProfile.getTotalDistance();
+
+        double distancePerWay = tmp[14] * totalDist / 100;
+
+        System.out.println("Skipped: " + skippedTrackParts);
+
+
+
+        Map<Integer, double[]> speedsMap = ridersProfile.getFilterSpeeds();
+
+        int waytype = 0;
+
+
+        for(double[] speeds : speedsMap.values()) {
+
+            System.out.println("-----------------------------");
+            int i = -30;
+
+            for (double speed : speeds) {
+                System.out.println(i + ", " + speed);
+                i++;
+            }
+        }
+        */
+    }
+
+
+    private void setup(){
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java b/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java
new file mode 100644
index 0000000000..37d713881b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/ProfileManager.java
@@ -0,0 +1,120 @@
+package com.graphhopper.util.profiles;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.lang.ClassNotFoundException;
+import java.lang.Object;
+import java.lang.String;
+
+
+public class ProfileManager {
+
+
+    private RidersProfile ridersProfile;
+    private final String base = "profiles/";
+
+    public ProfileManager(){}
+
+    public void createProfile(String name) {
+        ridersProfile = new RidersProfile();
+
+        saveProfile(name);
+    }
+
+    public void readProfile(String name){
+
+        FileInputStream fileInputStream = null;
+        ObjectInputStream inputStream = null;
+        Object obj = null;
+
+        try {
+
+            fileInputStream = new FileInputStream(base + name);
+            inputStream = new ObjectInputStream (fileInputStream);
+            obj = inputStream.readObject();
+
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+
+            if(inputStream != null){
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if(fileInputStream != null){
+                try {
+                    fileInputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+        }
+
+
+        if (obj instanceof RidersProfile)
+        {
+            ridersProfile = (RidersProfile) obj;
+        }
+    }
+
+
+    public void saveProfile(String name){
+        if (ridersProfile == null)
+            return;
+
+        FileOutputStream fileOutputStream = null;
+        ObjectOutputStream outputStream = null;
+
+        try {
+            fileOutputStream = new FileOutputStream(base + name);
+            outputStream = new ObjectOutputStream(fileOutputStream);
+            outputStream.writeObject(ridersProfile);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if(outputStream != null) {
+                try {
+                    outputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+
+            if(fileOutputStream != null) {
+                try {
+                    fileOutputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+
+    public RidersProfile getProfile(String name){
+        if (ridersProfile == null) {
+            readProfile(name);
+        }
+
+        return ridersProfile;
+    }
+
+
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java b/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java
new file mode 100644
index 0000000000..204f8183e0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/RidersEntry.java
@@ -0,0 +1,44 @@
+package com.graphhopper.util.profiles;
+
+import java.io.Serializable;
+import java.lang.IllegalArgumentException;
+import java.lang.String;
+
+public class RidersEntry implements Serializable{
+
+    private float speed = 0;
+    private float distance = 0;
+
+    public RidersEntry(){};
+
+    public void updateEntry(double speed, double distance) {
+
+        this.distance += distance;
+
+        if(this.distance == 0)
+            throw new IllegalArgumentException("Cannot update RidersEntry with distance equal to ZERO.");
+
+        this.speed = (float) ((this.speed * (this.distance - distance) + speed * distance) / this.distance);
+    }
+
+    @Override
+    public String toString() {
+        return "[s=" + speed + ", d=" + distance + "]";
+    }
+
+    public float getSpeed() {
+        return speed;
+    }
+
+    public void setSpeed(float speed) {
+        this.speed = speed;
+    }
+
+    public float getDistance() {
+        return distance;
+    }
+
+    public void setDistance(float distance) {
+        this.distance = distance;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java b/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java
new file mode 100644
index 0000000000..a7296fbdee
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/RidersProfile.java
@@ -0,0 +1,197 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.fitting.WeightedObservedPoint;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class RidersProfile implements Serializable{
+
+    public transient final static int WAY_TYPES = 16;
+    public transient final static int SLOPES = 60;
+
+    private RidersEntry[][] speedMatrix = new RidersEntry[WAY_TYPES][SLOPES+1]; // 16 Way types, Steigung von -30 % bis + 30 %
+    private double totalDistance;
+
+
+    public RidersProfile(){};
+
+    public RidersEntry getEntry(int wayType, int slope){
+        return speedMatrix[wayType][slope+(SLOPES/2)];
+    }
+
+    public RidersEntry[] getEntries(int wayType) {
+        return speedMatrix[wayType];
+    }
+
+    public Map<Integer, double[]> getFilterSpeeds(){
+
+        Map<Integer, double[]> speedMap = new HashMap<Integer, double[]>();
+
+        for( int i = 0; i < WAY_TYPES; i++ ){
+
+            if(getDistance(i) > 10000) {
+                speedMap.put(i, filterSpeeds(getEntries(i), i));
+            }
+
+        }
+
+        return speedMap;
+    }
+
+    private double[] filterSpeeds(RidersEntry[] ridersEntries, int wayType) {
+
+        ArrayList<WeightedObservedPoint> points = new ArrayList<WeightedObservedPoint>();
+
+        double maxSpeed = maxSpeed(wayType);
+
+        for ( int i = 0; i < ridersEntries.length; i++){
+            if(ridersEntries[i] != null) {
+                points.add(new WeightedObservedPoint(ridersEntries[i].getDistance(), i - SLOPES / 2, ridersEntries[i].getSpeed() / maxSpeed));
+            }
+        }
+
+        final double[] coef = new SigmoidalFitter(new double[]{1, 0.5, -1}).fit(points);
+        SigmoidFunction sigF = new SigmoidFunction();
+
+        double[] result = new double[SLOPES + 1];
+
+        int offset = SLOPES / 2;
+
+        for( int i = - offset; i < offset + 1; i++){
+            result[i + offset] = sigF.value(i, coef) * maxSpeed;
+        }
+
+        return result;
+    }
+
+    public double maxSpeed(int wayType){
+
+        double max = 0.0;
+
+        for (RidersEntry r : speedMatrix[wayType]){
+            if(r != null && r.getSpeed() > max)
+                max = r.getSpeed();
+        }
+
+        return max;
+    }
+
+
+    public double getSpeed(int wayType, int slope){
+
+        RidersEntry entry = getEntry(wayType, slope);
+
+        if(entry == null)
+            return Double.NaN;
+
+        return getEntry(wayType, slope).getSpeed();
+    }
+
+    public double getDistance(int wayType, int slope){
+
+        RidersEntry entry = getEntry(wayType, slope);
+
+        if(entry == null)
+            return 0.0;
+
+        return getEntry(wayType, slope).getDistance();
+    }
+
+    public double getDistance(int wayType){
+        double totalDist = 0;
+
+        for(int i = 0; i < speedMatrix[wayType].length; i++) {
+            if(speedMatrix[wayType][i] != null)
+                totalDist += speedMatrix[wayType][i].getDistance();
+        }
+
+        return totalDist;
+    }
+
+    public double getTotalDistance(){
+        return totalDistance;
+    }
+
+    public double[] getWayTypePriority(){
+
+        double[] distancesPerWayType = new double[WAY_TYPES];
+
+        for (int i = 0; i < speedMatrix.length; i++) {
+            for (int j = 0; j < speedMatrix[i].length; j++) {
+                distancesPerWayType[i] += getDistance(i, j - (SLOPES / 2));
+            }
+
+            distancesPerWayType[i] = distancesPerWayType[i] / totalDistance * 100;
+        }
+
+        return distancesPerWayType;
+
+    }
+
+    public void update(TrackPart trackPart) {
+
+        if(trackPart == null)
+            return;
+
+        int wayType = (int) trackPart.getWayType();
+        int slope = (int) trackPart.getSlope();
+
+        if (wayType < 0 || wayType > 15)
+            throw new IllegalArgumentException("Waytype must be between 0 and 15, but was: " + wayType);
+
+        if (slope < - (SLOPES/2))
+            slope = - (SLOPES/2);
+
+        if (slope > SLOPES/2)
+            slope = SLOPES/2;
+
+        RidersEntry ridersEntry = speedMatrix[wayType][slope+(SLOPES/2)];
+
+        if(ridersEntry == null) {
+            ridersEntry = new RidersEntry();
+            speedMatrix[wayType][slope+(SLOPES/2)] = ridersEntry;
+        }
+
+        ridersEntry.updateEntry(trackPart.getSpeed(), trackPart.getDistance());
+        totalDistance += trackPart.getDistance();
+
+    }
+
+    public int update(List<TrackPart> trackPartList) {
+
+        int skipped = 0;
+
+        for(TrackPart tp : trackPartList) {
+            try{
+                update(tp);
+            } catch(IllegalArgumentException i){
+                skipped++;
+            }
+        }
+
+        return skipped;
+
+    }
+
+    @Override
+    public java.lang.String toString() {
+
+        String riderString = "";
+
+        for (int i = 0; i < speedMatrix.length; i++) {
+            riderString += "-----[ " + i + " ]------ \n";
+            for (int j = 0; j < speedMatrix[i].length; j++) {
+                if(speedMatrix[i][j] != null)
+                    riderString += (j - SLOPES / 2) + ", " + speedMatrix[i][j].getSpeed() + ", " + speedMatrix[i][j].getDistance() + "\n";
+            }
+            riderString += "----------------------\n";
+        }
+
+        return riderString;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java b/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java
new file mode 100644
index 0000000000..a3bbc1c748
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/SigmoidFunction.java
@@ -0,0 +1,36 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.analysis.ParametricUnivariateFunction;
+import java.lang.Math;
+
+public class SigmoidFunction implements ParametricUnivariateFunction {
+
+    @Override
+    public double value(double x, double... params) {
+
+        double a = params[0];
+        double b = params[1];
+        double c = params[2];
+
+        double value = 1 - ( a / (1 + Math.exp(-b * (x - c))));
+
+        return value;
+    }
+
+    @Override
+    public double[] gradient(double x, double... params) {
+
+        double a = params[0];
+        double b = params[1];
+        double c = params[2];
+
+        double[] gradient = new double[3];
+
+        gradient[0] = - ( 1 / (Math.exp(b * ( c - x )) + 1));
+        gradient[1] = (a * ( c - x ) * Math.exp( -(b * ( x - c )))) / Math.pow(Math.exp( -(b * ( x - c ))) + 1, 2);
+        gradient[2] = (a * b * Math.exp( -(b * ( x - c )))) / Math.pow(Math.exp( -(b * ( x - c ))) + 1, 2);
+
+        return gradient;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java b/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java
new file mode 100644
index 0000000000..00f7ea0fef
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/SigmoidalFitter.java
@@ -0,0 +1,116 @@
+package com.graphhopper.util.profiles;
+
+import org.apache.commons.math3.fitting.AbstractCurveFitter;
+import org.apache.commons.math3.fitting.WeightedObservedPoint;
+import org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder;
+import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
+import org.apache.commons.math3.linear.DiagonalMatrix;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+
+public class SigmoidalFitter extends AbstractCurveFitter{
+
+    private double[] initialGuess;
+
+
+    public SigmoidalFitter(double[] initialGuess){
+        this.initialGuess = initialGuess;
+    }
+
+
+    @Override
+    protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> points) {
+
+
+        final int len = points.size();
+        final double[] target  = new double[len];
+        final double[] weights = new double[len];
+
+        int i = 0;
+
+        for(WeightedObservedPoint point : points) {
+            target[i]  = point.getY();
+            weights[i] = point.getWeight();
+            i += 1;
+        }
+
+        final AbstractCurveFitter.TheoreticalValuesFunction model = new
+                AbstractCurveFitter.TheoreticalValuesFunction(new SigmoidFunction(), points);
+
+        final DiagonalMatrix weightMatrix = new DiagonalMatrix(weights);
+
+        return new LeastSquaresBuilder().
+                maxEvaluations(Integer.MAX_VALUE).
+                maxIterations(Integer.MAX_VALUE).
+                start(initialGuess).
+                target(target).
+                weight(weightMatrix).
+                model(model.getModelFunction(), model.getModelFunctionJacobian()).
+                build();
+    }
+
+    public static void main(String[] args) {
+        SigmoidalFitter fitter = new SigmoidalFitter(new double[] {1, 0.5, -1});
+        ArrayList<WeightedObservedPoint> points = new ArrayList<WeightedObservedPoint>();
+
+        // Add points here; for instance,
+        WeightedObservedPoint point1 = new WeightedObservedPoint(222.0084, -11, 33.30126 / 37.36653);
+        WeightedObservedPoint point2 = new WeightedObservedPoint(409.9835, -10, 35.188465 / 37.36653);
+        WeightedObservedPoint point3 = new WeightedObservedPoint(1675.1172, -9, 35.625652 / 37.36653);
+        WeightedObservedPoint point4 = new WeightedObservedPoint(1075.3177, -8, 37.36653 / 37.36653);
+        WeightedObservedPoint point5 = new WeightedObservedPoint(60.274113, -7, 6.7808375 / 37.36653);
+        WeightedObservedPoint point6 = new WeightedObservedPoint(651.5845, -6, 28.758934 / 37.36653);
+        WeightedObservedPoint point7 = new WeightedObservedPoint(205.16458, -5, 30.774687 / 37.36653);
+        WeightedObservedPoint point8 = new WeightedObservedPoint(171.65067, -4, 30.89712 / 37.36653);
+        WeightedObservedPoint point9 = new WeightedObservedPoint(389.28305, -3, 24.898178 / 37.36653);
+        WeightedObservedPoint point10 = new WeightedObservedPoint(204.34619, -2, 13.880118 / 37.36653);
+        WeightedObservedPoint point11 = new WeightedObservedPoint(209.81961, -1, 11.989692 / 37.36653);
+        WeightedObservedPoint point12 = new WeightedObservedPoint(203.6042, 0, 15.595216 / 37.36653);
+        WeightedObservedPoint point13 = new WeightedObservedPoint(619.88995, 1, 14.0128 / 37.36653);
+        WeightedObservedPoint point14 = new WeightedObservedPoint(455.45798, 2, 10.182568 / 37.36653);
+        WeightedObservedPoint point15 = new WeightedObservedPoint(205.16792, 3, 12.9579735 / 37.36653);
+        WeightedObservedPoint point16 = new WeightedObservedPoint(451.05057, 4, 12.913956 / 37.36653);
+        WeightedObservedPoint point17 = new WeightedObservedPoint(471.85242, 5, 7.089638 / 37.36653);
+        WeightedObservedPoint point18 = new WeightedObservedPoint(646.1104, 6, 9.526044 / 37.36653);
+        WeightedObservedPoint point19 = new WeightedObservedPoint(689.3907, 7, 8.498449 / 37.36653);
+        WeightedObservedPoint point20 = new WeightedObservedPoint(208.12926, 8, 9.250189 / 37.36653);
+        WeightedObservedPoint point21 = new WeightedObservedPoint(1262.8378, 9, 7.8886223 / 37.36653);
+        WeightedObservedPoint point22 = new WeightedObservedPoint(214.3265, 10, 7.9543853 / 37.36653);
+        WeightedObservedPoint point23 = new WeightedObservedPoint(617.08203, 11, 7.3262196 / 37.36653);
+        WeightedObservedPoint point24 = new WeightedObservedPoint(219.78712, 12, 5.733577 / 37.36653);
+        WeightedObservedPoint point25 = new WeightedObservedPoint(202.69017, 13, 6.0807056 / 37.36653);
+        WeightedObservedPoint point26 = new WeightedObservedPoint(216.81699, 30, 6.7873144 / 37.36653);
+
+        points.add(point1);
+        points.add(point2);
+        points.add(point3);
+        points.add(point4);
+        points.add(point5);
+        points.add(point6);
+        points.add(point7);
+        points.add(point8);
+        points.add(point9);
+        points.add(point10);
+        points.add(point11);
+        points.add(point12);
+        points.add(point13);
+        points.add(point14);
+        points.add(point15);
+        points.add(point16);
+        points.add(point17);
+        points.add(point18);
+        points.add(point19);
+        points.add(point20);
+        points.add(point21);
+        points.add(point22);
+        points.add(point23);
+        points.add(point24);
+        points.add(point25);
+        points.add(point26);
+
+        final double coeffs[] = fitter.fit(points);
+        System.out.println(Arrays.toString(coeffs));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java b/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java
new file mode 100644
index 0000000000..75d9fe57d4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/TrackPart.java
@@ -0,0 +1,61 @@
+package com.graphhopper.util.profiles;
+
+import com.graphhopper.util.GPXEntry;
+
+import java.util.List;
+
+public class TrackPart {
+
+    private double distance;
+    private List<GPXEntry> gpxEntryList;
+    private double slope;
+    private double speed;
+    private int wayType = -1;
+
+    public TrackPart(List<GPXEntry> gpxEntryList, double distance, double slope, double speed) {
+        this.gpxEntryList = gpxEntryList;
+        this.distance = distance;
+        this.slope = slope;
+        this.speed = speed;
+    }
+
+    public List<GPXEntry> getGpxEntryList() {
+        return gpxEntryList;
+    }
+
+    public void setGpxEntryList(List<GPXEntry> gpxEntryList) {
+        this.gpxEntryList = gpxEntryList;
+    }
+
+    public double getDistance() {
+        return distance;
+    }
+
+    public void setDistance(double distance) {
+        this.distance = distance;
+    }
+
+    public double getSlope() {
+        return slope;
+    }
+
+    public void setSlope(double slope) {
+        this.slope = slope;
+    }
+
+    public double getSpeed() {
+        return speed;
+    }
+
+    public void setSpeed(double speed) {
+        this.speed = speed;
+    }
+
+    public int getWayType() {
+        return wayType;
+    }
+
+    public void setWayType(int wayType) {
+        this.wayType = wayType;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java
new file mode 100644
index 0000000000..2473976de5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/AddToProfileOperation.java
@@ -0,0 +1,53 @@
+package com.graphhopper.util.profiles.operations;
+
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.matching.LocationIndexMatch;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.profiles.GPXDataExtractor;
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
+import com.graphhopper.matching.GPXFile;
+
+public class AddToProfileOperation implements Operation {
+
+    String name;
+    String gpxFileName;
+
+    GraphHopper hopper;
+
+    public AddToProfileOperation(String[] args) {
+        name = args[1];
+        gpxFileName = args[2];
+
+        CmdArgs cmdArgs = CmdArgs.read(args);
+        cmdArgs = CmdArgs.readFromConfigAndMerge(cmdArgs, "config", "graphhopper.config");
+        hopper = new GraphHopper().init(cmdArgs);
+        hopper.importOrLoad();
+
+    }
+
+    @Override
+    public void run() {
+
+        ProfileManager profileManager = new ProfileManager();
+
+        RidersProfile ridersProfile = profileManager.getProfile(name);
+
+        if(ridersProfile == null) {
+            System.err.println("Could not load profile " + name + ". Please check your profile name.");
+            return;
+        }
+
+        GPXDataExtractor gpxDataExtractor = new GPXDataExtractor();
+        gpxDataExtractor.setupMapMatching(hopper);
+        gpxDataExtractor.configFilter(GPXDataExtractor.FILTER_KALMAN_COMBINED, 100);
+
+        GPXFile gpxFile = new GPXFile().doImport("./" + gpxFileName);
+        gpxDataExtractor.setFile(gpxFile);
+        ridersProfile.update(gpxDataExtractor.extract());
+
+        profileManager.saveProfile(name);
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java
new file mode 100644
index 0000000000..e95e1fefff
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/CreateProfileOperation.java
@@ -0,0 +1,18 @@
+package com.graphhopper.util.profiles.operations;
+
+import com.graphhopper.util.profiles.ProfileManager;
+
+public class CreateProfileOperation implements Operation {
+
+    String name;
+
+    public CreateProfileOperation(String[] args){
+        this.name = args[1];
+    }
+
+    @Override
+    public void run() {
+        ProfileManager aProfileManager = new ProfileManager();
+        aProfileManager.createProfile(name);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java
new file mode 100644
index 0000000000..77d73c94f9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/Operation.java
@@ -0,0 +1,8 @@
+package com.graphhopper.util.profiles.operations;
+
+
+public interface Operation {
+
+    void run();
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java b/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java
new file mode 100644
index 0000000000..4e60346f80
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/profiles/operations/PrintProfileOperation.java
@@ -0,0 +1,27 @@
+package com.graphhopper.util.profiles.operations;
+
+import com.graphhopper.util.profiles.ProfileManager;
+import com.graphhopper.util.profiles.RidersProfile;
+
+public class PrintProfileOperation implements Operation {
+
+    String name;
+
+    public PrintProfileOperation(String[] args) {
+        this.name = args[1];
+    }
+
+    @Override
+    public void run() {
+
+        ProfileManager profileManager = new ProfileManager();
+        RidersProfile ridersProfile = profileManager.getProfile(name);
+
+        System.out.println("Profile of: " + name);
+
+        if(ridersProfile != null){
+            System.out.println(ridersProfile.getFilterSpeeds());
+        }
+
+    }
+}
diff --git a/profiles/.gitignore b/profiles/.gitignore
new file mode 100644
index 0000000000..86d0cb2726
--- /dev/null
+++ b/profiles/.gitignore
@@ -0,0 +1,4 @@
+# Ignore everything in this directory
+*
+# Except this file
+!.gitignore
\ No newline at end of file
