diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 6b078d1257..029b265fdb 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -49,10 +49,13 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FastestWeighting;
+import com.graphhopper.routing.util.FastestWithAvoidancesWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.PrepareRoutingSubnetworks;
 import com.graphhopper.routing.util.PriorityWeighting;
+import com.graphhopper.routing.util.PriorityWithAvoidancesWeighting;
 import com.graphhopper.routing.util.ShortestWeighting;
+import com.graphhopper.routing.util.ShortestWithAvoidancesWeighting;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.TurnWeighting;
 import com.graphhopper.routing.util.Weighting;
@@ -87,1136 +90,1152 @@
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
+ * 
  * @see GraphHopperAPI
  * @author Peter Karich
  */
-public class GraphHopper implements GraphHopperAPI
-{
-    private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    // for graph:
-    private GraphStorage graph;
-    private EncodingManager encodingManager;
-    private int defaultSegmentSize = -1;
-    private String ghLocation = "";
-    private DAType dataAccessType = DAType.RAM_STORE;
-    private boolean sortGraph = false;
-    boolean removeZipped = true;
-    private boolean elevation = false;
-    private LockFactory lockFactory = new NativeFSLockFactory();
-    private final String fileLockName = "gh.lock";
-    private boolean allowWrites = true;
-    boolean enableInstructions = true;
-    private boolean fullyLoaded = false;
-    // for routing
-    private double defaultWeightLimit = Double.MAX_VALUE;
-    private boolean simplifyResponse = true;
-    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private String defaultVehicleStr;
-    private RoutingAlgorithmFactory algoFactory;
-    // for index
-    private LocationIndex locationIndex;
-    private int preciseIndexResolution = 300;
-    private int maxRegionSearch = 4;
-    // for prepare
-    private int minNetworkSize = 200;
-    private int minOneWayNetworkSize = 0;
-    // for CH prepare
-    private boolean doPrepare = true;
-    private boolean chEnabled = true;
-    private String chWeightingStr = "fastest";
-    private int periodicUpdates = -1;
-    private int lazyUpdates = -1;
-    private int neighborUpdates = -1;
-    private double logMessages = -1;
-    // for OSM import
-    private String dataReader = "OSM";
-    private String osmFile;
-    private double osmReaderWayPointMaxDistance = 1;
-    private int workerThreads = -1;
-    private boolean calcPoints = true;
-    // utils
-    private final TranslationMap trMap = new TranslationMap().doImport();
-    private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final AtomicLong visitedSum = new AtomicLong(0);
-
-    /**
-     * Certain readers require additional arguments so this can be passed to them as a constructor parameter
-     */
-    private CmdArgs args;
-
-    public GraphHopper()
-    {
-    }
-
-    /**
-     * For testing only
-     */
-    protected GraphHopper loadGraph( GraphStorage g )
-    {
-        this.graph = g;
-        fullyLoaded = true;
-        initLocationIndex();
-        return this;
-    }
-
-    /**
-     * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
-     * how data from every vehicle is written (und read) into edges of the graph.
-     */
-    public GraphHopper setEncodingManager( EncodingManager em )
-    {
-        ensureNotLoaded();
-        this.encodingManager = em;
-        if (em.needsTurnCostsSupport())
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-
-        return this;
-    }
-
-    FlagEncoder getDefaultVehicle()
-    {
-        if (encodingManager == null)
-        {
-            throw new IllegalStateException("No encoding manager specified or loaded");
-        }
-
-        return encodingManager.fetchEdgeEncoders().get(0);
-    }
-
-    public EncodingManager getEncodingManager()
-    {
-        return encodingManager;
-    }
-
-    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
-    {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
-            setElevation(false);
-        else
-            setElevation(true);
-        this.eleProvider = eleProvider;
-        return this;
-    }
-
-    /**
-     * Threads for data reading.
-     */
-    protected int getWorkerThreads()
-    {
-        return workerThreads;
-    }
-
-    /**
-     * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
-     */
-    protected double getWayPointMaxDistance()
-    {
-        return osmReaderWayPointMaxDistance;
-    }
-
-    /**
-     * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
-     * value means more details, unit is meter. Default is 1. Disable via 0.
-     */
-    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
-    {
-        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
-        return this;
-    }
-
-    /**
-     * Sets the default traversal mode used for the algorithms and preparation.
-     */
-    public GraphHopper setTraversalMode( TraversalMode traversalMode )
-    {
-        this.traversalMode = traversalMode;
-        return this;
-    }
-
-    public TraversalMode getTraversalMode()
-    {
-        return traversalMode;
-    }
-
-    /**
-     * Configures the underlying storage and response to be used on a well equipped server. Result
-     * also optimized for usage in the web module i.e. try reduce network IO.
-     */
-    public GraphHopper forServer()
-    {
-        setSimplifyResponse(true);
-        return setInMemory();
-    }
-
-    /**
-     * Configures the underlying storage to be used on a Desktop computer or within another Java
-     * application with enough RAM but no network latency.
-     */
-    public GraphHopper forDesktop()
-    {
-        setSimplifyResponse(false);
-        return setInMemory();
-    }
-
-    /**
-     * Configures the underlying storage to be used on a less powerful machine like Android or
-     * Raspberry Pi with only few MB of RAM.
-     */
-    public GraphHopper forMobile()
-    {
-        setSimplifyResponse(false);
-        return setMemoryMapped();
-    }
-
-    /**
-     * Precise location resolution index means also more space (disc/RAM) could be consumed and
-     * probably slower query times, which would be e.g. not suitable for Android. The resolution
-     * specifies the tile width (in meter).
-     */
-    public GraphHopper setPreciseIndexResolution( int precision )
-    {
-        ensureNotLoaded();
-        preciseIndexResolution = precision;
-        return this;
-    }
-
-    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
-    {
-        this.minNetworkSize = minNetworkSize;
-        this.minOneWayNetworkSize = minOneWayNetworkSize;
-    }
-
-    /**
-     * This method call results in an in-memory graph.
-     */
-    public GraphHopper setInMemory()
-    {
-        ensureNotLoaded();
-        dataAccessType = DAType.RAM_STORE;
-        return this;
-    }
-
-    /**
-     * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
-     * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
-     * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
-     * <p>
-     * @param storeOnFlush true by default
-     */
-    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
-    {
-        ensureNotLoaded();
-        if (storeOnFlush)
-            dataAccessType = DAType.RAM_STORE;
-        else
-            dataAccessType = DAType.RAM;
-        return this;
-    }
-
-    /**
-     * Enable memory mapped configuration if not enough memory is available on the target platform.
-     */
-    public GraphHopper setMemoryMapped()
-    {
-        ensureNotLoaded();
-        dataAccessType = DAType.MMAP;
-        return this;
-    }
-
-    /**
-     * Not yet stable enough to offer it for everyone
-     */
-    private GraphHopper setUnsafeMemory()
-    {
-        ensureNotLoaded();
-        dataAccessType = DAType.UNSAFE_STORE;
-        return this;
-    }
-
-    /**
-     * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
-     * <p/>
-     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
-     * @see #setCHEnable(boolean)
-     */
-    public GraphHopper setCHWeighting( String weighting )
-    {
-        ensureNotLoaded();
-        chWeightingStr = weighting;
-        return this;
-    }
-
-    public String getCHWeighting()
-    {
-        return chWeightingStr;
-    }
-
-    /**
-     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
-     * the full usage of CH use setCHEnable(false) instead.
-     */
-    public GraphHopper setDoPrepare( boolean doPrepare )
-    {
-        this.doPrepare = doPrepare;
-        return this;
-    }
-
-    /**
-     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
-     * Disabling CH is only recommended for short routes or in combination with
-     * setDefaultWeightLimit and called flexibility mode
-     * <p>
-     * @see #setDefaultWeightLimit(double)
-     */
-    public GraphHopper setCHEnable( boolean enable )
-    {
-        ensureNotLoaded();
-        algoFactory = null;
-        chEnabled = enable;
-        return this;
-    }
-
-    /**
-     * This methods stops the algorithm from searching further if the resulting path would go over
-     * specified weight, important if CH is disabled. The unit is defined by the used weighting
-     * created from createWeighting, e.g. distance for shortest or seconds for the standard
-     * FastestWeighting implementation.
-     */
-    public void setDefaultWeightLimit( double defaultWeightLimit )
-    {
-        this.defaultWeightLimit = defaultWeightLimit;
-    }
-
-    public boolean isCHEnabled()
-    {
-        return chEnabled;
-    }
-
-    /**
-     * @return true if storing and fetching elevation data is enabled. Default is false
-     */
-    public boolean hasElevation()
-    {
-        return elevation;
-    }
-
-    /**
-     * Enable storing and fetching elevation data. Default is false
-     */
-    public GraphHopper setElevation( boolean includeElevation )
-    {
-        this.elevation = includeElevation;
-        return this;
-    }
-
-    /**
-     * This method specifies if the import should include way names to be able to return
-     * instructions for a route.
-     */
-    public GraphHopper setEnableInstructions( boolean b )
-    {
-        ensureNotLoaded();
-        enableInstructions = b;
-        return this;
-    }
-
-    /**
-     * This methods enables gps point calculation. If disabled only distance will be calculated.
-     */
-    public GraphHopper setEnableCalcPoints( boolean b )
-    {
-        calcPoints = b;
-        return this;
-    }
-
-    /**
-     * This method specifies if the returned path should be simplified or not, via douglas-peucker
-     * or similar algorithm.
-     */
-    private GraphHopper setSimplifyResponse( boolean doSimplify )
-    {
-        this.simplifyResponse = doSimplify;
-        return this;
-    }
-
-    /**
-     * Sets the graphhopper folder.
-     */
-    public GraphHopper setGraphHopperLocation( String ghLocation )
-    {
-        ensureNotLoaded();
-        if (ghLocation == null)
-            throw new IllegalArgumentException("graphhopper location cannot be null");
-
-        this.ghLocation = ghLocation;
-        return this;
-    }
-
-    public String getGraphHopperLocation()
-    {
-        return ghLocation;
-    }
-
-    /**
-     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
-     * (.pbf).
-     */
-    public GraphHopper setOSMFile( String osmFileStr )
-    {
-        ensureNotLoaded();
-        if (Helper.isEmpty(osmFileStr))
-            throw new IllegalArgumentException("OSM file cannot be empty.");
-
-        osmFile = osmFileStr;
-        return this;
-    }
-
-    public String getOSMFile()
-    {
-        return osmFile;
-    }
-
-    /**
-     * The underlying graph used in algorithms.
-     * <p>
-     * @throws IllegalStateException if graph is not instantiated.
-     */
-    public GraphStorage getGraph()
-    {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
-
-        return graph;
-    }
-
-    public void setGraph( GraphStorage graph )
-    {
-        this.graph = graph;
-    }
-
-    protected void setLocationIndex( LocationIndex locationIndex )
-    {
-        this.locationIndex = locationIndex;
-    }
-
-    /**
-     * The location index created from the graph.
-     * <p>
-     * @throws IllegalStateException if index is not initialized
-     */
-    public LocationIndex getLocationIndex()
-    {
-        if (locationIndex == null)
-            throw new IllegalStateException("Location index not initialized");
-
-        return locationIndex;
-    }
-
-    /**
-     * Sorts the graph which requires more RAM while import. See #12
-     */
-    public GraphHopper setSortGraph( boolean sortGraph )
-    {
-        ensureNotLoaded();
-        this.sortGraph = sortGraph;
-        return this;
-    }
-
-    /**
-     * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
-     * possible to create a lock file and so we can avoid write locks.
-     */
-    public GraphHopper setAllowWrites( boolean allowWrites )
-    {
-        this.allowWrites = allowWrites;
-        return this;
-    }
-
-    public boolean isAllowWrites()
-    {
-        return allowWrites;
-    }
-
-    public TranslationMap getTranslationMap()
-    {
-        return trMap;
-    }
-
-    /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
-     * args) ala CmdArgs.read(args) or via configuration file ala
-     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
-     */
-    public GraphHopper init( CmdArgs args )
-    {
-        this.args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        String tmpOsmFile = args.get("osmreader.osm", "");
-        if (!Helper.isEmpty(tmpOsmFile))
-            osmFile = tmpOsmFile;
-
-        dataReader = args.get("reader.implementation", dataReader);
-
-        String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
-        {
-            if (Helper.isEmpty(osmFile))
-                throw new IllegalArgumentException("You need to specify an OSM file.");
-
-            graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
-        }
-
-        // graph
-        setGraphHopperLocation(graphHopperFolder);
-        defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
-
-        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
-        dataAccessType = DAType.fromString(graphDATypeStr);
-
-        sortGraph = args.getBool("graph.doSort", sortGraph);
-        removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
-        if (args.get("graph.locktype", "native").equals("simple"))
-            lockFactory = new SimpleFSLockFactory();
-        else
-            lockFactory = new NativeFSLockFactory();
-
-        // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
-        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
-        String baseURL = args.get("graph.elevation.baseurl", "");
-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm"))
-        {
-            tmpProvider = new SRTMProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
-        {
-            CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
-            tmpProvider = cgiarProvider;
-        }
-
-        tmpProvider.setCalcMean(eleCalcMean);
-        tmpProvider.setCacheDir(new File(cacheDirStr));
-        if (!baseURL.isEmpty())
-            tmpProvider.setBaseURL(baseURL);
-        tmpProvider.setDAType(elevationDAType);
-        setElevationProvider(tmpProvider);
-
-        // optimizable prepare
-        minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
-
-        // prepare CH
-        doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
-        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
-        if (chEnabled)
-            setCHWeighting(tmpCHWeighting);
-
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
-
-        // osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "");
-        if (!flagEncoders.isEmpty())
-            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
-
-        workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
-        enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
-
-        // index
-        preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
-        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
-
-        // routing
-        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
-        return this;
-    }
-
-    private void printInfo()
-    {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
-    }
-
-    /**
-     * Imports provided data from disc and creates graph. Depending on the settings the resulting
-     * graph will be stored to disc so on a second call this method will only load the graph from
-     * disc which is usually a lot faster.
-     */
-    public GraphHopper importOrLoad()
-    {
-        if (!load(ghLocation))
-        {
-            printInfo();
-            process(ghLocation);
-        } else
-        {
-            printInfo();
-        }
-        return this;
-    }
-
-    /**
-     * Creates the graph from OSM data.
-     */
-    private GraphHopper process( String graphHopperLocation )
-    {
-        setGraphHopperLocation(graphHopperLocation);
-        Lock lock = null;
-        try
-        {
-            if (graph.getDirectory().getDefaultType().isStoring())
-            {
-                lockFactory.setLockDir(new File(graphHopperLocation));
-                lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
-            }
-
-            try
-            {
-                importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex)
-            {
-                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
-            }
-            cleanUp();
-            optimize();
-            postProcessing();
-            flush();
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
-        return this;
-    }
-
-    protected DataReader importData() throws IOException
-    {
-        ensureWriteAccess();
-        if (graph == null)
-            throw new IllegalStateException("Load graph before importing OSM data");
-
-        if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot import from OSM file as it wasn't specified!");
-
-        encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
-        reader.readGraph();
-        return reader;
-    }
-
-    protected DataReader createReader(GraphStorage tmpGraph) {
-        DataReader reader;
-        if ("OSM".equals(dataReader))
-            reader = new OSMReader(tmpGraph);
-        else if ("OSITN".equals(dataReader))
-            reader = new OsItnReader(tmpGraph, args);
-        else if ("OSDPN".equals(dataReader))
-            reader = new OsDpnReader(tmpGraph);
-        else if ("OSHN".equals(dataReader))
-            reader = new OsHnReader(tmpGraph);
-        else {
-            String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
-            throw new IllegalArgumentException(exceptionMessage);
-        }
-        return initReader(reader);
-    }
-
-    protected DataReader initReader(DataReader reader) {
-        if (osmFile == null)
-            throw new IllegalArgumentException("No OSM file specified");
-
-        logger.info("start creating graph from " + osmFile);
-        File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).
-                setElevationProvider(eleProvider).
-                setWorkerThreads(workerThreads).
-                setEncodingManager(encodingManager).
-                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
-    }
-
-    /**
-     * Opens existing graph.
-     * <p/>
-     * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
-     * too)
-     */
-    @Override
-    public boolean load( String graphHopperFolder )
-    {
-        if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
-
-        if (fullyLoaded)
-            throw new IllegalStateException("graph is already successfully loaded");
-
-        if (graphHopperFolder.endsWith("-gh"))
-        {
-            // do nothing
-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
-        {
-            throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (!graphHopperFolder.contains("."))
-        {
-            if (new File(graphHopperFolder + "-gh").exists())
-                graphHopperFolder += "-gh";
-        } else
-        {
-            File compressed = new File(graphHopperFolder + ".ghz");
-            if (compressed.exists() && !compressed.isDirectory())
-            {
-                try
-                {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex)
-                {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
-                            + " to " + graphHopperFolder, ex);
-                }
-            }
-        }
-
-        setGraphHopperLocation(graphHopperFolder);
-
-        if (encodingManager == null)
-            setEncodingManager(EncodingManager.create(ghLocation));
-
-        if (!allowWrites && dataAccessType.isMMap())
-            dataAccessType = DAType.MMAP_RO;
-
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
-        if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
-        else
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
-
-        graph.setSegmentSize(defaultSegmentSize);
-
-        Lock lock = null;
-        try
-        {
-            // create locks only if writes are allowed, if they are not allowed a lock cannot be created
-            // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
-            {
-                lockFactory.setLockDir(new File(ghLocation));
-                lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
-            }
-
-            if (!graph.loadExisting())
-                return false;
-
-            postProcessing();
-            fullyLoaded = true;
-            return true;
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
-    }
-
-    public RoutingAlgorithmFactory getAlgorithmFactory()
-    {
-        if (algoFactory == null)
-            this.algoFactory = new RoutingAlgorithmFactorySimple();
-
-        return algoFactory;
-    }
-
-    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
-    {
-        this.algoFactory = algoFactory;
-    }
-
-    /**
-     * Sets EncodingManager, does the preparation and creates the locationIndex
-     */
-    protected void postProcessing()
-    {
-        initLocationIndex();
-        if (chEnabled)
-            algoFactory = createPrepare();
-        else
-            algoFactory = new RoutingAlgorithmFactorySimple();
-
-        if (!isPrepared())
-            prepare();
-    }
-
-    private boolean isPrepared()
-    {
-        return "true".equals(graph.getProperties().get("prepare.done"));
-    }
-
-    protected RoutingAlgorithmFactory createPrepare()
-    {
-        FlagEncoder defaultVehicle = getDefaultVehicle();
-        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
-        setLazyUpdates(lazyUpdates).
-        setNeighborUpdates(neighborUpdates).
-        setLogMessages(logMessages);
-
-        return tmpPrepareCH;
-    }
-
-    /**
-     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
-     * created. Note that all URL parameters are available in the weightingParameters as String if
-     * you use the GraphHopper Web module.
-     * <p>
-     * @see WeightingMap
-     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
-     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
-     * @param encoder the required vehicle
-     * @return the weighting to be used for route calculation
-     */
-    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
-    {
-        String weighting = weightingMap.getWeighting();
-        Weighting result;
-
-        if ("shortest".equalsIgnoreCase(weighting))
-        {
-            result = new ShortestWeighting();
-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-        {
-            if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
-            else
-                result = new FastestWeighting(encoder);
-        } else
-        {
-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-        }
-        return result;
-    }
-
-    /**
-     * Potentially wraps the specified weighting into a TurnWeighting instance.
-     */
-    public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
-    {
-        if (encoder.supports(TurnWeighting.class))
-            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
-        return weighting;
-    }
-
-    @Override
-    public GHResponse route( GHRequest request )
-    {
-        GHResponse response = new GHResponse();
-        List<Path> paths = getPaths(request, response);
-        if (response.hasErrors())
-            return response;
-
-        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
-        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
-        Locale locale = request.getLocale();
-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-
-        new PathMerger().
-        setCalcPoints(tmpCalcPoints).
-        setDouglasPeucker(peucker).
-        setEnableInstructions(tmpEnableInstructions).
-        setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
-        doWork(response, paths, trMap.getWithFallBack(locale));
-        return response;
-    }
-
-    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
-    {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
-
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty())
-            vehicle = getDefaultVehicle().toString();
-
-        if (!encodingManager.supports(vehicle))
-        {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                    + "Supported are: " + getEncodingManager()));
-            return Collections.emptyList();
-        }
-
-        TraversalMode tMode;
-        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try
-        {
-            tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex)
-        {
-            rsp.addError(ex);
-            return Collections.emptyList();
-        }
-
-        List<GHPoint> points = request.getPoints();
-        if (points.size() < 2)
-        {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
-            return Collections.emptyList();
-        }
-
-        visitedSum.set(0);
-
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-
-        StopWatch sw = new StopWatch().start();
-        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
-        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
-        {
-            GHPoint point = points.get(placeIndex);
-            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            if (!res.isValid())
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
-
-            qResults.add(res);
-        }
-
-        if (rsp.hasErrors())
-            return Collections.emptyList();
-
-        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
-
-        QueryGraph queryGraph;
-        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
-        {
-            // fall back to normal traversing
-            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
-            queryGraph = new QueryGraph(graph.getBaseGraph());
-        } else
-        {
-            queryGraph = new QueryGraph(graph);
-        }
-
-        queryGraph.lookup(qResults);
-
-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
-        QueryResult fromQResult = qResults.get(0);
-        Weighting weighting = createWeighting(request.getHints(), encoder);
-        weighting = createTurnWeighting(weighting, queryGraph, encoder);
-
-        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
-        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
-                build();
-
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
-        {
-            QueryResult toQResult = qResults.get(placeIndex);
-            sw = new StopWatch().start();
-            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
-            algo.setWeightLimit(weightLimit);
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
-
-            sw = new StopWatch().start();
-            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
-            if (path.getMillis() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
-
-            paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
-
-            visitedSum.addAndGet(algo.getVisitedNodes());
-            fromQResult = toQResult;
-        }
-
-        if (rsp.hasErrors())
-            return Collections.emptyList();
-
-        if (points.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
-
-        rsp.setDebugInfo(debug);
-        return paths;
-    }
-
-    protected LocationIndex createLocationIndex( Directory dir )
-    {
-        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
-        tmpIndex.setResolution(preciseIndexResolution);
-        tmpIndex.setMaxRegionSearch(maxRegionSearch);
-        if (!tmpIndex.loadExisting())
-        {
-            ensureWriteAccess();
-            tmpIndex.prepareIndex();
-        }
-
-        return tmpIndex;
-    }
-
-    /**
-     * Initializes the location index after the import is done.
-     */
-    protected void initLocationIndex()
-    {
-        if (locationIndex != null)
-            throw new IllegalStateException("Cannot initialize locationIndex twice!");
-
-        locationIndex = createLocationIndex(graph.getDirectory());
-    }
-
-    protected void optimize()
-    {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
-
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
-            if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
-
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
-    }
-
-    protected void prepare()
-    {
-        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
-        if (tmpPrepare)
-        {
-            ensureWriteAccess();
-            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
-            ((PrepareContractionHierarchies) algoFactory).doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
-        }
-        graph.getProperties().put("prepare.done", tmpPrepare);
-    }
-
-    protected void cleanUp()
-    {
-        int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
-        preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
-        logger.info("start finding subnetworks, " + Helper.getMemInfo());
-        preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
-        int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
-    }
-
-    protected void flush()
-    {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
-        graph.flush();
-        fullyLoaded = true;
-    }
-
-    /**
-     * Releases all associated resources like memory or files. But it does not remove them. To
-     * remove the files created in graphhopperLocation you have to call clean().
-     */
-    public void close()
-    {
-        if (graph != null)
-            graph.close();
-
-        if (locationIndex != null)
-            locationIndex.close();
-
-        try
-        {
-            lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex)
-        {
-            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
-        }
-    }
-
-    /**
-     * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
-     * load
-     */
-    public void clean()
-    {
-        if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
-
-        File folder = new File(getGraphHopperLocation());
-        Helper.removeDir(folder);
-    }
-
-    // make sure this is identical to buildDate used in pom.xml
-    // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime( Date date )
-    {
-        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
-    }
-
-    protected void ensureNotLoaded()
-    {
-        if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
-    }
-
-    protected void ensureWriteAccess()
-    {
-        if (!allowWrites)
-            throw new IllegalStateException("Writes are not allowed!");
-    }
-
-    /**
-     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
-     * debugging purposes.
-     */
-    public long getVisitedSum()
-    {
-        return visitedSum.get();
-    }
-
-    public GraphHopper setAsOSMReader() {
-        dataReader = "OSM";
-        return this;
-    }
-
-    public GraphHopper setAsItnReader() {
-        dataReader = "OSITN";
-        return this;
-    }
-    public GraphHopper setAsHnReader() {
-        dataReader = "OSHN";
-        return this;
-    }
-
-    public GraphHopper setAsDpnReader() {
-        dataReader = "OSDPN";
-        return this;
-    }
+public class GraphHopper implements GraphHopperAPI {
+	private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+	// for graph:
+	private GraphStorage graph;
+	private EncodingManager encodingManager;
+	private int defaultSegmentSize = -1;
+	private String ghLocation = "";
+	private DAType dataAccessType = DAType.RAM_STORE;
+	private boolean sortGraph = false;
+	boolean removeZipped = true;
+	private boolean elevation = false;
+	private LockFactory lockFactory = new NativeFSLockFactory();
+	private final String fileLockName = "gh.lock";
+	private boolean allowWrites = true;
+	boolean enableInstructions = true;
+	private boolean fullyLoaded = false;
+	// for routing
+	private double defaultWeightLimit = Double.MAX_VALUE;
+	private boolean simplifyResponse = true;
+	private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+	private String defaultVehicleStr;
+	private RoutingAlgorithmFactory algoFactory;
+	// for index
+	private LocationIndex locationIndex;
+	private int preciseIndexResolution = 300;
+	private int maxRegionSearch = 4;
+	// for prepare
+	private int minNetworkSize = 200;
+	private int minOneWayNetworkSize = 0;
+	// for CH prepare
+	private boolean doPrepare = true;
+	private boolean chEnabled = true;
+	private String chWeightingStr = "fastest";
+	private int periodicUpdates = -1;
+	private int lazyUpdates = -1;
+	private int neighborUpdates = -1;
+	private double logMessages = -1;
+	// for OSM import
+	private String dataReader = "OSM";
+	private String osmFile;
+	private double osmReaderWayPointMaxDistance = 1;
+	private int workerThreads = -1;
+	private boolean calcPoints = true;
+	// utils
+	private final TranslationMap trMap = new TranslationMap().doImport();
+	private ElevationProvider eleProvider = ElevationProvider.NOOP;
+	private final AtomicLong visitedSum = new AtomicLong(0);
+
+	/**
+	 * Certain readers require additional arguments so this can be passed to
+	 * them as a constructor parameter
+	 */
+	private CmdArgs args;
+
+	public GraphHopper() {
+	}
+
+	/**
+	 * For testing only
+	 */
+	protected GraphHopper loadGraph(GraphStorage g) {
+		this.graph = g;
+		fullyLoaded = true;
+		initLocationIndex();
+		return this;
+	}
+
+	/**
+	 * Specify which vehicles can be read by this GraphHopper instance. An
+	 * encoding manager defines how data from every vehicle is written (und
+	 * read) into edges of the graph.
+	 */
+	public GraphHopper setEncodingManager(EncodingManager em) {
+		ensureNotLoaded();
+		this.encodingManager = em;
+		if (em.needsTurnCostsSupport())
+			traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
+		return this;
+	}
+
+	FlagEncoder getDefaultVehicle() {
+		if (encodingManager == null) {
+			throw new IllegalStateException(
+					"No encoding manager specified or loaded");
+		}
+
+		return encodingManager.fetchEdgeEncoders().get(0);
+	}
+
+	public EncodingManager getEncodingManager() {
+		return encodingManager;
+	}
+
+	public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
+		if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+			setElevation(false);
+		else
+			setElevation(true);
+		this.eleProvider = eleProvider;
+		return this;
+	}
+
+	/**
+	 * Threads for data reading.
+	 */
+	protected int getWorkerThreads() {
+		return workerThreads;
+	}
+
+	/**
+	 * Return maximum distance (in meter) to reduce points via douglas peucker
+	 * while OSM import.
+	 */
+	protected double getWayPointMaxDistance() {
+		return osmReaderWayPointMaxDistance;
+	}
+
+	/**
+	 * This parameter specifies how to reduce points via douglas peucker while
+	 * OSM import. Higher value means more details, unit is meter. Default is 1.
+	 * Disable via 0.
+	 */
+	public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
+		this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+		return this;
+	}
+
+	/**
+	 * Sets the default traversal mode used for the algorithms and preparation.
+	 */
+	public GraphHopper setTraversalMode(TraversalMode traversalMode) {
+		this.traversalMode = traversalMode;
+		return this;
+	}
+
+	public TraversalMode getTraversalMode() {
+		return traversalMode;
+	}
+
+	/**
+	 * Configures the underlying storage and response to be used on a well
+	 * equipped server. Result also optimized for usage in the web module i.e.
+	 * try reduce network IO.
+	 */
+	public GraphHopper forServer() {
+		setSimplifyResponse(true);
+		return setInMemory();
+	}
+
+	/**
+	 * Configures the underlying storage to be used on a Desktop computer or
+	 * within another Java application with enough RAM but no network latency.
+	 */
+	public GraphHopper forDesktop() {
+		setSimplifyResponse(false);
+		return setInMemory();
+	}
+
+	/**
+	 * Configures the underlying storage to be used on a less powerful machine
+	 * like Android or Raspberry Pi with only few MB of RAM.
+	 */
+	public GraphHopper forMobile() {
+		setSimplifyResponse(false);
+		return setMemoryMapped();
+	}
+
+	/**
+	 * Precise location resolution index means also more space (disc/RAM) could
+	 * be consumed and probably slower query times, which would be e.g. not
+	 * suitable for Android. The resolution specifies the tile width (in meter).
+	 */
+	public GraphHopper setPreciseIndexResolution(int precision) {
+		ensureNotLoaded();
+		preciseIndexResolution = precision;
+		return this;
+	}
+
+	public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+		this.minNetworkSize = minNetworkSize;
+		this.minOneWayNetworkSize = minOneWayNetworkSize;
+	}
+
+	/**
+	 * This method call results in an in-memory graph.
+	 */
+	public GraphHopper setInMemory() {
+		ensureNotLoaded();
+		dataAccessType = DAType.RAM_STORE;
+		return this;
+	}
+
+	/**
+	 * Only valid option for in-memory graph and if you e.g. want to disable
+	 * store on flush for unit tests. Specify storeOnFlush to true if you want
+	 * that existing data will be loaded FROM disc and all in-memory data will
+	 * be flushed TO disc after flush is called e.g. while OSM import.
+	 * <p>
+	 * 
+	 * @param storeOnFlush
+	 *            true by default
+	 */
+	public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
+		ensureNotLoaded();
+		if (storeOnFlush)
+			dataAccessType = DAType.RAM_STORE;
+		else
+			dataAccessType = DAType.RAM;
+		return this;
+	}
+
+	/**
+	 * Enable memory mapped configuration if not enough memory is available on
+	 * the target platform.
+	 */
+	public GraphHopper setMemoryMapped() {
+		ensureNotLoaded();
+		dataAccessType = DAType.MMAP;
+		return this;
+	}
+
+	/**
+	 * Not yet stable enough to offer it for everyone
+	 */
+	private GraphHopper setUnsafeMemory() {
+		ensureNotLoaded();
+		dataAccessType = DAType.UNSAFE_STORE;
+		return this;
+	}
+
+	/**
+	 * Enables the use of contraction hierarchies to reduce query times. Enabled
+	 * by default.
+	 * <p/>
+	 * 
+	 * @param weighting
+	 *            can be "fastest", "shortest" or your own weight-calculation
+	 *            type.
+	 * @see #setCHEnable(boolean)
+	 */
+	public GraphHopper setCHWeighting(String weighting) {
+		ensureNotLoaded();
+		chWeightingStr = weighting;
+		return this;
+	}
+
+	public String getCHWeighting() {
+		return chWeightingStr;
+	}
+
+	/**
+	 * Disables the "CH-preparation" preparation only. Use only if you know what
+	 * you do. To disable the full usage of CH use setCHEnable(false) instead.
+	 */
+	public GraphHopper setDoPrepare(boolean doPrepare) {
+		this.doPrepare = doPrepare;
+		return this;
+	}
+
+	/**
+	 * Enables or disables contraction hierarchies (CH). This speed-up mode is
+	 * enabled by default. Disabling CH is only recommended for short routes or
+	 * in combination with setDefaultWeightLimit and called flexibility mode
+	 * <p>
+	 * 
+	 * @see #setDefaultWeightLimit(double)
+	 */
+	public GraphHopper setCHEnable(boolean enable) {
+		ensureNotLoaded();
+		algoFactory = null;
+		chEnabled = enable;
+		return this;
+	}
+
+	/**
+	 * This methods stops the algorithm from searching further if the resulting
+	 * path would go over specified weight, important if CH is disabled. The
+	 * unit is defined by the used weighting created from createWeighting, e.g.
+	 * distance for shortest or seconds for the standard FastestWeighting
+	 * implementation.
+	 */
+	public void setDefaultWeightLimit(double defaultWeightLimit) {
+		this.defaultWeightLimit = defaultWeightLimit;
+	}
+
+	public boolean isCHEnabled() {
+		return chEnabled;
+	}
+
+	/**
+	 * @return true if storing and fetching elevation data is enabled. Default
+	 *         is false
+	 */
+	public boolean hasElevation() {
+		return elevation;
+	}
+
+	/**
+	 * Enable storing and fetching elevation data. Default is false
+	 */
+	public GraphHopper setElevation(boolean includeElevation) {
+		this.elevation = includeElevation;
+		return this;
+	}
+
+	/**
+	 * This method specifies if the import should include way names to be able
+	 * to return instructions for a route.
+	 */
+	public GraphHopper setEnableInstructions(boolean b) {
+		ensureNotLoaded();
+		enableInstructions = b;
+		return this;
+	}
+
+	/**
+	 * This methods enables gps point calculation. If disabled only distance
+	 * will be calculated.
+	 */
+	public GraphHopper setEnableCalcPoints(boolean b) {
+		calcPoints = b;
+		return this;
+	}
+
+	/**
+	 * This method specifies if the returned path should be simplified or not,
+	 * via douglas-peucker or similar algorithm.
+	 */
+	private GraphHopper setSimplifyResponse(boolean doSimplify) {
+		this.simplifyResponse = doSimplify;
+		return this;
+	}
+
+	/**
+	 * Sets the graphhopper folder.
+	 */
+	public GraphHopper setGraphHopperLocation(String ghLocation) {
+		ensureNotLoaded();
+		if (ghLocation == null)
+			throw new IllegalArgumentException(
+					"graphhopper location cannot be null");
+
+		this.ghLocation = ghLocation;
+		return this;
+	}
+
+	public String getGraphHopperLocation() {
+		return ghLocation;
+	}
+
+	/**
+	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
+	 * .osm.gz) or a protobuf file (.pbf).
+	 */
+	public GraphHopper setOSMFile(String osmFileStr) {
+		ensureNotLoaded();
+		if (Helper.isEmpty(osmFileStr))
+			throw new IllegalArgumentException("OSM file cannot be empty.");
+
+		osmFile = osmFileStr;
+		return this;
+	}
+
+	public String getOSMFile() {
+		return osmFile;
+	}
+
+	/**
+	 * The underlying graph used in algorithms.
+	 * <p>
+	 * 
+	 * @throws IllegalStateException
+	 *             if graph is not instantiated.
+	 */
+	public GraphStorage getGraph() {
+		if (graph == null)
+			throw new IllegalStateException("Graph not initialized");
+
+		return graph;
+	}
+
+	public void setGraph(GraphStorage graph) {
+		this.graph = graph;
+	}
+
+	protected void setLocationIndex(LocationIndex locationIndex) {
+		this.locationIndex = locationIndex;
+	}
+
+	/**
+	 * The location index created from the graph.
+	 * <p>
+	 * 
+	 * @throws IllegalStateException
+	 *             if index is not initialized
+	 */
+	public LocationIndex getLocationIndex() {
+		if (locationIndex == null)
+			throw new IllegalStateException("Location index not initialized");
+
+		return locationIndex;
+	}
+
+	/**
+	 * Sorts the graph which requires more RAM while import. See #12
+	 */
+	public GraphHopper setSortGraph(boolean sortGraph) {
+		ensureNotLoaded();
+		this.sortGraph = sortGraph;
+		return this;
+	}
+
+	/**
+	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only
+	 * filesystems it is not possible to create a lock file and so we can avoid
+	 * write locks.
+	 */
+	public GraphHopper setAllowWrites(boolean allowWrites) {
+		this.allowWrites = allowWrites;
+		return this;
+	}
+
+	public boolean isAllowWrites() {
+		return allowWrites;
+	}
+
+	public TranslationMap getTranslationMap() {
+		return trMap;
+	}
+
+	/**
+	 * Reads configuration from a CmdArgs object. Which can be manually filled,
+	 * or via main(String[] args) ala CmdArgs.read(args) or via configuration
+	 * file ala CmdArgs.readFromConfig("config.properties",
+	 * "graphhopper.config")
+	 */
+	public GraphHopper init(CmdArgs args) {
+		this.args = CmdArgs.readFromConfigAndMerge(args, "config",
+				"graphhopper.config");
+		String tmpOsmFile = args.get("osmreader.osm", "");
+		if (!Helper.isEmpty(tmpOsmFile))
+			osmFile = tmpOsmFile;
+
+		dataReader = args.get("reader.implementation", dataReader);
+
+		String graphHopperFolder = args.get("graph.location", "");
+		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+			if (Helper.isEmpty(osmFile))
+				throw new IllegalArgumentException(
+						"You need to specify an OSM file.");
+
+			graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
+		}
+
+		// graph
+		setGraphHopperLocation(graphHopperFolder);
+		defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize",
+				defaultSegmentSize);
+
+		String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+		dataAccessType = DAType.fromString(graphDATypeStr);
+
+		sortGraph = args.getBool("graph.doSort", sortGraph);
+		removeZipped = args.getBool("graph.removeZipped", removeZipped);
+		int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
+		if (args.get("graph.locktype", "native").equals("simple"))
+			lockFactory = new SimpleFSLockFactory();
+		else
+			lockFactory = new NativeFSLockFactory();
+
+		// elevation
+		String eleProviderStr = args.get("graph.elevation.provider", "noop")
+				.toLowerCase();
+		boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+		String cacheDirStr = args.get("graph.elevation.cachedir", "");
+		String baseURL = args.get("graph.elevation.baseurl", "");
+		DAType elevationDAType = DAType.fromString(args.get(
+				"graph.elevation.dataaccess", "MMAP"));
+		ElevationProvider tmpProvider = ElevationProvider.NOOP;
+		if (eleProviderStr.equalsIgnoreCase("srtm")) {
+			tmpProvider = new SRTMProvider();
+		} else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
+			CGIARProvider cgiarProvider = new CGIARProvider();
+			cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool(
+					"graph.elevation.cgiar.clear", true));
+			tmpProvider = cgiarProvider;
+		}
+
+		tmpProvider.setCalcMean(eleCalcMean);
+		tmpProvider.setCacheDir(new File(cacheDirStr));
+		if (!baseURL.isEmpty())
+			tmpProvider.setBaseURL(baseURL);
+		tmpProvider.setDAType(elevationDAType);
+		setElevationProvider(tmpProvider);
+
+		// optimizable prepare
+		minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+		minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize",
+				minOneWayNetworkSize);
+
+		// prepare CH
+		doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+		String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+		chEnabled = "fastest".equals(tmpCHWeighting)
+				|| "shortest".equals(tmpCHWeighting);
+		if (chEnabled)
+			setCHWeighting(tmpCHWeighting);
+
+		periodicUpdates = args.getInt("prepare.updates.periodic",
+				periodicUpdates);
+		lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
+		neighborUpdates = args.getInt("prepare.updates.neighbor",
+				neighborUpdates);
+		logMessages = args.getDouble("prepare.logmessages", logMessages);
+
+		// osm import
+		osmReaderWayPointMaxDistance = args.getDouble(
+				"osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+		String flagEncoders = args.get("graph.flagEncoders", "");
+		if (!flagEncoders.isEmpty())
+			setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+
+		workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
+		enableInstructions = args.getBool("osmreader.instructions",
+				enableInstructions);
+
+		// index
+		preciseIndexResolution = args.getInt("index.highResolution",
+				preciseIndexResolution);
+		maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+		// routing
+		defaultWeightLimit = args.getDouble("routing.defaultWeightLimit",
+				defaultWeightLimit);
+		return this;
+	}
+
+	private void printInfo() {
+		logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE
+				+ " (" + Constants.getVersions() + ")");
+		if (graph != null)
+			logger.info("graph " + graph.toString() + ", details:"
+					+ graph.toDetailsString());
+	}
+
+	/**
+	 * Imports provided data from disc and creates graph. Depending on the
+	 * settings the resulting graph will be stored to disc so on a second call
+	 * this method will only load the graph from disc which is usually a lot
+	 * faster.
+	 */
+	public GraphHopper importOrLoad() {
+		if (!load(ghLocation)) {
+			printInfo();
+			process(ghLocation);
+		} else {
+			printInfo();
+		}
+		return this;
+	}
+
+	/**
+	 * Creates the graph from OSM data.
+	 */
+	private GraphHopper process(String graphHopperLocation) {
+		setGraphHopperLocation(graphHopperLocation);
+		Lock lock = null;
+		try {
+			if (graph.getDirectory().getDefaultType().isStoring()) {
+				lockFactory.setLockDir(new File(graphHopperLocation));
+				lock = lockFactory.create(fileLockName, true);
+				if (!lock.tryLock())
+					throw new RuntimeException(
+							"To avoid multiple writers we need to obtain a write lock but it failed. In "
+									+ graphHopperLocation,
+							lock.getObtainFailedReason());
+			}
+
+			try {
+				importData();
+				graph.getProperties().put("osmreader.import.date",
+						formatDateTime(new Date()));
+			} catch (IOException ex) {
+				throw new RuntimeException("Cannot parse OSM file "
+						+ getOSMFile(), ex);
+			}
+			cleanUp();
+			optimize();
+			postProcessing();
+			flush();
+		} finally {
+			if (lock != null)
+				lock.release();
+		}
+		return this;
+	}
+
+	protected DataReader importData() throws IOException {
+		ensureWriteAccess();
+		if (graph == null)
+			throw new IllegalStateException(
+					"Load graph before importing OSM data");
+
+		if (osmFile == null)
+			throw new IllegalStateException(
+					"Couldn't load from existing folder: "
+							+ ghLocation
+							+ " but also cannot import from OSM file as it wasn't specified!");
+
+		encodingManager.setEnableInstructions(enableInstructions);
+		DataReader reader = createReader(graph);
+		logger.info("using " + graph.toString() + ", memory:"
+				+ Helper.getMemInfo());
+		reader.readGraph();
+		return reader;
+	}
+
+	protected DataReader createReader(GraphStorage tmpGraph) {
+		DataReader reader;
+		if ("OSM".equals(dataReader))
+			reader = new OSMReader(tmpGraph);
+		else if ("OSITN".equals(dataReader))
+			reader = new OsItnReader(tmpGraph, args);
+		else if ("OSDPN".equals(dataReader))
+			reader = new OsDpnReader(tmpGraph);
+		else if ("OSHN".equals(dataReader))
+			reader = new OsHnReader(tmpGraph);
+		else {
+			String exceptionMessage = String.format(READER_UNAVAILABLE,
+					dataReader);
+			throw new IllegalArgumentException(exceptionMessage);
+		}
+		return initReader(reader);
+	}
+
+	protected DataReader initReader(DataReader reader) {
+		if (osmFile == null)
+			throw new IllegalArgumentException("No OSM file specified");
+
+		logger.info("start creating graph from " + osmFile);
+		File osmTmpFile = new File(osmFile);
+		return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
+				.setWorkerThreads(workerThreads)
+				.setEncodingManager(encodingManager)
+				.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+	}
+
+	/**
+	 * Opens existing graph.
+	 * <p/>
+	 * 
+	 * @param graphHopperFolder
+	 *            is the folder containing graphhopper files (which can be
+	 *            compressed too)
+	 */
+	@Override
+	public boolean load(String graphHopperFolder) {
+		if (Helper.isEmpty(graphHopperFolder))
+			throw new IllegalStateException(
+					"graphHopperLocation is not specified. call init before");
+
+		if (fullyLoaded)
+			throw new IllegalStateException(
+					"graph is already successfully loaded");
+
+		if (graphHopperFolder.endsWith("-gh")) {
+			// do nothing
+		} else if (graphHopperFolder.endsWith(".osm")
+				|| graphHopperFolder.endsWith(".xml")) {
+			throw new IllegalArgumentException(
+					"To import an osm file you need to use importOrLoad");
+		} else if (!graphHopperFolder.contains(".")) {
+			if (new File(graphHopperFolder + "-gh").exists())
+				graphHopperFolder += "-gh";
+		} else {
+			File compressed = new File(graphHopperFolder + ".ghz");
+			if (compressed.exists() && !compressed.isDirectory()) {
+				try {
+					new Unzipper().unzip(compressed.getAbsolutePath(),
+							graphHopperFolder, removeZipped);
+				} catch (IOException ex) {
+					throw new RuntimeException("Couldn't extract file "
+							+ compressed.getAbsolutePath() + " to "
+							+ graphHopperFolder, ex);
+				}
+			}
+		}
+
+		setGraphHopperLocation(graphHopperFolder);
+
+		if (encodingManager == null)
+			setEncodingManager(EncodingManager.create(ghLocation));
+
+		if (!allowWrites && dataAccessType.isMMap())
+			dataAccessType = DAType.MMAP_RO;
+
+		GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+		if (chEnabled)
+			graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+		else if (encodingManager.needsTurnCostsSupport())
+			graph = new GraphHopperStorage(dir, encodingManager,
+					hasElevation(), new TurnCostExtension());
+		else
+			graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+
+		graph.setSegmentSize(defaultSegmentSize);
+
+		Lock lock = null;
+		try {
+			// create locks only if writes are allowed, if they are not allowed
+			// a lock cannot be created
+			// (e.g. on a read only filesystem locks would fail)
+			if (graph.getDirectory().getDefaultType().isStoring()
+					&& isAllowWrites()) {
+				lockFactory.setLockDir(new File(ghLocation));
+				lock = lockFactory.create(fileLockName, false);
+				if (!lock.tryLock())
+					throw new RuntimeException(
+							"To avoid reading partial data we need to obtain the read lock but it failed. In "
+									+ ghLocation, lock.getObtainFailedReason());
+			}
+
+			if (!graph.loadExisting())
+				return false;
+
+			postProcessing();
+			fullyLoaded = true;
+			return true;
+		} finally {
+			if (lock != null)
+				lock.release();
+		}
+	}
+
+	public RoutingAlgorithmFactory getAlgorithmFactory() {
+		if (algoFactory == null)
+			this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+		return algoFactory;
+	}
+
+	public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+		this.algoFactory = algoFactory;
+	}
+
+	/**
+	 * Sets EncodingManager, does the preparation and creates the locationIndex
+	 */
+	protected void postProcessing() {
+		initLocationIndex();
+		if (chEnabled)
+			algoFactory = createPrepare();
+		else
+			algoFactory = new RoutingAlgorithmFactorySimple();
+
+		if (!isPrepared())
+			prepare();
+	}
+
+	private boolean isPrepared() {
+		return "true".equals(graph.getProperties().get("prepare.done"));
+	}
+
+	protected RoutingAlgorithmFactory createPrepare() {
+		FlagEncoder defaultVehicle = getDefaultVehicle();
+		Weighting weighting = createWeighting(new WeightingMap(chWeightingStr),
+				defaultVehicle);
+		PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
+				new GHDirectory("", DAType.RAM_INT), (LevelGraph) graph,
+				defaultVehicle, weighting, traversalMode);
+		tmpPrepareCH.setPeriodicUpdates(periodicUpdates)
+				.setLazyUpdates(lazyUpdates)
+				.setNeighborUpdates(neighborUpdates)
+				.setLogMessages(logMessages);
+
+		return tmpPrepareCH;
+	}
+
+	/**
+	 * Based on the weightingParameters and the specified vehicle a Weighting
+	 * instance can be created. Note that all URL parameters are available in
+	 * the weightingParameters as String if you use the GraphHopper Web module.
+	 * <p>
+	 * 
+	 * @see WeightingMap
+	 * @param weightingMap
+	 *            all parameters influencing the weighting. E.g. parameters
+	 *            coming via GHRequest.getHints or directly via "&api.xy=" from
+	 *            the URL of the web UI
+	 * @param encoder
+	 *            the required vehicle
+	 * @return the weighting to be used for route calculation
+	 */
+	public Weighting createWeighting(WeightingMap weightingMap,
+			FlagEncoder encoder) {
+		String weighting = weightingMap.getWeighting();
+		Weighting result;
+
+		if ("shortest".equalsIgnoreCase(weighting)) {
+			result = new ShortestWeighting();
+		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
+			if (encoder.supports(PriorityWeighting.class))
+				result = new PriorityWeighting(encoder);
+			else
+				result = new FastestWeighting(encoder);
+		} else if ("fastavoid".equalsIgnoreCase(weighting)) {
+			String avoidances = weightingMap.get("avoidances", "cliff");
+			if (encoder.supports(PriorityWeighting.class))
+				result = new PriorityWithAvoidancesWeighting(encoder, avoidances);
+			else
+				result = new FastestWithAvoidancesWeighting(encoder, avoidances);
+		} else if ("shortavoid".equalsIgnoreCase(weighting)) {
+			String avoidances = weightingMap.get("avoidances", "cliff");
+			result = new ShortestWithAvoidancesWeighting(encoder, avoidances);
+		} else {
+			throw new UnsupportedOperationException("weighting " + weighting
+					+ " not supported");
+		}
+		System.err.println("WEIGHTING:" + result.getClass());
+		return result;
+	}
+
+	/**
+	 * Potentially wraps the specified weighting into a TurnWeighting instance.
+	 */
+	public Weighting createTurnWeighting(Weighting weighting, Graph graph,
+			FlagEncoder encoder) {
+		if (encoder.supports(TurnWeighting.class))
+			return new TurnWeighting(weighting, encoder,
+					(TurnCostExtension) graph.getExtension());
+		return weighting;
+	}
+
+	@Override
+	public GHResponse route(GHRequest request) {
+		GHResponse response = new GHResponse();
+		List<Path> paths = getPaths(request, response);
+		if (response.hasErrors())
+			return response;
+
+		boolean tmpEnableInstructions = request.getHints().getBool(
+				"instructions", enableInstructions);
+		boolean tmpCalcPoints = request.getHints().getBool("calcPoints",
+				calcPoints);
+		double wayPointMaxDistance = request.getHints().getDouble(
+				"wayPointMaxDistance", 1d);
+		Locale locale = request.getLocale();
+		DouglasPeucker peucker = new DouglasPeucker()
+				.setMaxDistance(wayPointMaxDistance);
+
+		new PathMerger()
+				.setCalcPoints(tmpCalcPoints)
+				.setDouglasPeucker(peucker)
+				.setEnableInstructions(tmpEnableInstructions)
+				.setSimplifyResponse(
+						simplifyResponse && wayPointMaxDistance > 0)
+				.doWork(response, paths, trMap.getWithFallBack(locale));
+		return response;
+	}
+
+	protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+		if (graph == null || !fullyLoaded)
+			throw new IllegalStateException(
+					"Call load or importOrLoad before routing");
+
+		if (graph.isClosed())
+			throw new IllegalStateException(
+					"You need to create a new GraphHopper instance as it is already closed");
+
+		String vehicle = request.getVehicle();
+		if (vehicle.isEmpty())
+			vehicle = getDefaultVehicle().toString();
+
+		if (!encodingManager.supports(vehicle)) {
+			rsp.addError(new IllegalArgumentException("Vehicle " + vehicle
+					+ " unsupported. " + "Supported are: "
+					+ getEncodingManager()));
+			return Collections.emptyList();
+		}
+
+		TraversalMode tMode;
+		String tModeStr = request.getHints().get("traversal_mode",
+				traversalMode.toString());
+		try {
+			tMode = TraversalMode.fromString(tModeStr);
+		} catch (Exception ex) {
+			rsp.addError(ex);
+			return Collections.emptyList();
+		}
+
+		List<GHPoint> points = request.getPoints();
+		if (points.size() < 2) {
+			rsp.addError(new IllegalStateException(
+					"At least 2 points has to be specified, but was:"
+							+ points.size()));
+			return Collections.emptyList();
+		}
+
+		visitedSum.set(0);
+
+		FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+		EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+
+		StopWatch sw = new StopWatch().start();
+		List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+			GHPoint point = points.get(placeIndex);
+			QueryResult res = locationIndex.findClosest(point.lat, point.lon,
+					edgeFilter);
+			if (!res.isValid())
+				rsp.addError(new IllegalArgumentException("Cannot find point "
+						+ placeIndex + ": " + point));
+
+			qResults.add(res);
+		}
+
+		if (rsp.hasErrors())
+			return Collections.emptyList();
+
+		String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+
+		QueryGraph queryGraph;
+		RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+		if (chEnabled
+				&& !vehicle.equalsIgnoreCase(getDefaultVehicle().toString())) {
+			// fall back to normal traversing
+			tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+			queryGraph = new QueryGraph(graph.getBaseGraph());
+		} else {
+			queryGraph = new QueryGraph(graph);
+		}
+
+		queryGraph.lookup(qResults);
+
+		List<Path> paths = new ArrayList<Path>(points.size() - 1);
+		QueryResult fromQResult = qResults.get(0);
+		Weighting weighting = createWeighting(request.getHints(), encoder);
+		weighting = createTurnWeighting(weighting, queryGraph, encoder);
+
+		double weightLimit = request.getHints().getDouble("defaultWeightLimit",
+				defaultWeightLimit);
+		String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI
+				: request.getAlgorithm();
+		AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr)
+				.traversalMode(tMode).flagEncoder(encoder).weighting(weighting)
+				.build();
+
+		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+			QueryResult toQResult = qResults.get(placeIndex);
+			sw = new StopWatch().start();
+			RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph,
+					algoOpts);
+			algo.setWeightLimit(weightLimit);
+			debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+
+			sw = new StopWatch().start();
+			Path path = algo.calcPath(fromQResult.getClosestNode(),
+					toQResult.getClosestNode());
+			if (path.getMillis() < 0)
+				throw new RuntimeException(
+						"Time was negative. Please report as bug and include:"
+								+ request);
+
+			paths.add(path);
+			debug += ", " + algo.getName() + "-routing:"
+					+ sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+
+			visitedSum.addAndGet(algo.getVisitedNodes());
+			fromQResult = toQResult;
+		}
+
+		if (rsp.hasErrors())
+			return Collections.emptyList();
+
+		if (points.size() - 1 != paths.size())
+			throw new RuntimeException(
+					"There should be exactly one more places than paths. places:"
+							+ points.size() + ", paths:" + paths.size());
+
+		rsp.setDebugInfo(debug);
+		return paths;
+	}
+
+	protected LocationIndex createLocationIndex(Directory dir) {
+		LocationIndexTree tmpIndex = new LocationIndexTree(
+				graph.getBaseGraph(), dir);
+		tmpIndex.setResolution(preciseIndexResolution);
+		tmpIndex.setMaxRegionSearch(maxRegionSearch);
+		if (!tmpIndex.loadExisting()) {
+			ensureWriteAccess();
+			tmpIndex.prepareIndex();
+		}
+
+		return tmpIndex;
+	}
+
+	/**
+	 * Initializes the location index after the import is done.
+	 */
+	protected void initLocationIndex() {
+		if (locationIndex != null)
+			throw new IllegalStateException(
+					"Cannot initialize locationIndex twice!");
+
+		locationIndex = createLocationIndex(graph.getDirectory());
+	}
+
+	protected void optimize() {
+		logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
+		graph.optimize();
+		logger.info("finished optimize (" + Helper.getMemInfo() + ")");
+
+		// Later: move this into the GraphStorage.optimize method
+		// Or: Doing it after preparation to optimize shortcuts too. But not
+		// possible yet #12
+		if (sortGraph) {
+			if (graph instanceof LevelGraph && isPrepared())
+				throw new IllegalArgumentException(
+						"Sorting prepared LevelGraph is not possible yet. See #12");
+
+			GraphStorage newGraph = GHUtility.newStorage(graph);
+			GHUtility.sortDFS(graph, newGraph);
+			logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+			graph = newGraph;
+		}
+	}
+
+	protected void prepare() {
+		boolean tmpPrepare = doPrepare
+				&& algoFactory instanceof PrepareContractionHierarchies;
+		if (tmpPrepare) {
+			ensureWriteAccess();
+			logger.info("calling prepare.doWork for " + getDefaultVehicle()
+					+ " ... (" + Helper.getMemInfo() + ")");
+			((PrepareContractionHierarchies) algoFactory).doWork();
+			graph.getProperties().put("prepare.date",
+					formatDateTime(new Date()));
+		}
+		graph.getProperties().put("prepare.done", tmpPrepare);
+	}
+
+	protected void cleanUp() {
+		int prev = graph.getNodes();
+		PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(
+				graph, encodingManager);
+		preparation.setMinNetworkSize(minNetworkSize);
+		preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
+		logger.info("start finding subnetworks, " + Helper.getMemInfo());
+		preparation.doWork();
+		int n = graph.getNodes();
+		// calculate remaining subnetworks
+		int remainingSubnetworks = preparation.findSubnetworks().size();
+		logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n
+				+ ", there were " + preparation.getSubNetworks()
+				+ " subnetworks. removed them => " + (prev - n)
+				+ " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+	}
+
+	protected void flush() {
+		logger.info("flushing graph " + graph.toString() + ", details:"
+				+ graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
+		graph.flush();
+		fullyLoaded = true;
+	}
+
+	/**
+	 * Releases all associated resources like memory or files. But it does not
+	 * remove them. To remove the files created in graphhopperLocation you have
+	 * to call clean().
+	 */
+	public void close() {
+		if (graph != null)
+			graph.close();
+
+		if (locationIndex != null)
+			locationIndex.close();
+
+		try {
+			lockFactory.forceRemove(fileLockName, true);
+		} catch (Exception ex) {
+			// silently fail e.g. on Windows where we cannot remove an
+			// unreleased native lock
+		}
+	}
+
+	/**
+	 * Removes the on-disc routing files. Call only after calling close or
+	 * before importOrLoad or load
+	 */
+	public void clean() {
+		if (getGraphHopperLocation().isEmpty())
+			throw new IllegalStateException(
+					"Cannot clean GraphHopper without specified graphHopperLocation");
+
+		File folder = new File(getGraphHopperLocation());
+		Helper.removeDir(folder);
+	}
+
+	// make sure this is identical to buildDate used in pom.xml
+	// <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
+	private String formatDateTime(Date date) {
+		return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
+	}
+
+	protected void ensureNotLoaded() {
+		if (fullyLoaded)
+			throw new IllegalStateException(
+					"No configuration changes are possible after loading the graph");
+	}
+
+	protected void ensureWriteAccess() {
+		if (!allowWrites)
+			throw new IllegalStateException("Writes are not allowed!");
+	}
+
+	/**
+	 * Returns the current sum of the visited nodes while routing. Mainly for
+	 * statistic and debugging purposes.
+	 */
+	public long getVisitedSum() {
+		return visitedSum.get();
+	}
+
+	public GraphHopper setAsOSMReader() {
+		dataReader = "OSM";
+		return this;
+	}
+
+	public GraphHopper setAsItnReader() {
+		dataReader = "OSITN";
+		return this;
+	}
+
+	public GraphHopper setAsHnReader() {
+		dataReader = "OSHN";
+		return this;
+	}
+
+	public GraphHopper setAsDpnReader() {
+		dataReader = "OSDPN";
+		return this;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
new file mode 100644
index 0000000000..3810f54266
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
@@ -0,0 +1,77 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.Way;
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Translation;
+
+public abstract class AbstractAvoidanceDecorator implements EncoderDecorator {
+
+	protected EncodedValue wayTypeEncoder;
+	public static final int KEY = 303;
+
+	protected abstract void defineEncoder(int shift);
+	protected abstract EdgeAttribute[] getEdgeAttributesOfInterest();
+
+	public int defineWayBits(int shift) {
+		defineEncoder(shift);
+		shift += wayTypeEncoder.getBits();
+		return shift;
+	}
+
+	public InstructionAnnotation getAnnotation( long flags, Translation tr )
+    {
+        long wayType = wayTypeEncoder.getValue(flags);
+        String wayName = getWayName(wayType, tr);
+        return new InstructionAnnotation(0, wayName);
+    }
+
+	public boolean supports(int key) {
+		return key == KEY;
+	};
+	
+	@Override
+	public long getLong(long flags) {
+		return wayTypeEncoder.getValue(flags);
+	}
+	
+	@Override
+	public double getDouble(long flags) {
+		double avoidanceType = wayTypeEncoder.getValue(flags);
+		return avoidanceType;
+	}
+
+	public long handleWayTags(Way way, long encoded) {
+		long avoidanceValue = 0;
+	
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
+			if (aType.isValidForWay(way)) {
+				avoidanceValue += aType.getValue();
+			}
+		}
+		return wayTypeEncoder.setValue(encoded, avoidanceValue);
+	}
+
+	private String getWayName(long wayType, Translation tr) {
+		String wayName = "";
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
+			if ((wayType & aType.getValue()) == aType.getValue()) {
+				wayName += " ";
+				wayName += aType.name();
+			}
+		}
+	
+		return wayName;
+	}
+
+	@Override
+	public long getBitMask(String[] attributes) {
+		long avoidanceValue = 0;
+		for (EdgeAttribute aType : getEdgeAttributesOfInterest()) {
+			if (aType.representedIn(attributes)) {
+				avoidanceValue += aType.getValue();
+			}
+		}
+		return avoidanceValue;
+	}
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index f1492f543f..d609d7426d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -42,831 +42,825 @@
 import com.graphhopper.util.Translation;
 
 /**
- * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
- * EncodingManager to be usable. If you want the full long to be stored you need to enable this in
- * the GraphHopperStorage.
+ * Abstract class which handles flag decoding and encoding. Every encoder should
+ * be registered to a EncodingManager to be usable. If you want the full long to
+ * be stored you need to enable this in the GraphHopperStorage.
  * <p/>
+ * 
  * @author Peter Karich
  * @author Nop
  * @see EncodingManager
  */
-public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
-{
-    private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-    private final static int K_FORWARD = 0, K_BACKWARD = 1;
-    /* Edge Flag Encoder fields */
-    private long nodeBitMask;
-    private long wayBitMask;
-    private long relBitMask;
-    protected long forwardBit;
-    protected long backwardBit;
-    protected long directionBitMask;
-    protected long roundaboutBit;
-    protected EncodedDoubleValue speedEncoder;
-    // bit to signal that way is accepted
-    protected long acceptBit;
-    protected long ferryBit;
-
-    private EncodedValue turnCostEncoder;
-    private long turnRestrictionBit;
-    private final int maxTurnCosts;
-
-    /* processing properties (to be initialized lazy when needed) */
-    protected EdgeExplorer edgeOutExplorer;
-    protected EdgeExplorer edgeInExplorer;
-
-    /* restriction definitions where order is important */
-    protected List<String> restrictions = new ArrayList<String>(5);
-    protected final HashSet<String> intendedValues = new HashSet<String>(5);
-    protected final HashSet<String> excludedValues = new HashSet<String>(5);
-    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected final HashSet<String> ferries = new HashSet<String>(5);
-    protected final HashSet<String> oneways = new HashSet<String>(5);
-    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
-    // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
-    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
-    /**
-     * Used to hold type exclusions
-     */
-    protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(5);
-    protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(5);
-    private boolean blockByDefault = true;
-    private boolean blockFords = true;
-    protected final int speedBits;
-    protected final double speedFactor;
-	protected List<EncoderDecorator> encoderDecorators=null;
-
-    /**
-     * @param speedBits specify the number of bits used for speed
-     * @param speedFactor specify the factor to multiple the stored value (can be used to increase
-     * or decrease accuracy of speed value)
-     * @param maxTurnCosts specify the maximum value used for turn costs, if this value is reached a
-     * turn is forbidden and results in costs of positive infinity.
-     */
-    protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
-        this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
-        this.speedBits = speedBits;
-        this.speedFactor = speedFactor;
-        oneways.add("yes");
-        oneways.add("true");
-        oneways.add("1");
-        oneways.add("-1");
-
-        ferries.add("shuttle_train");
-        ferries.add("ferry");
-
-        acceptedRailways.add("tram");
-        acceptedRailways.add("abandoned");
-        acceptedRailways.add("disused");
-
-        // http://wiki.openstreetmap.org/wiki/Demolished_Railway
-        acceptedRailways.add("dismantled");
-        acceptedRailways.add("razed");
-        acceptedRailways.add("historic");
-        acceptedRailways.add("obliterated");
-
-        intendedValues.add("true");
-        intendedValues.add("yes");
-
-        excludedValues.add("false");
-        excludedValues.add("no");
-
-
-    }
-
-    /**
-     * Should potential barriers block when no access limits are given?
-     */
-    public void setBlockByDefault( boolean blockByDefault )
-    {
-        this.blockByDefault = blockByDefault;
-    }
-
-    public void setBlockFords( boolean blockFords )
-    {
-        this.blockFords = blockFords;
-    }
-
-    public boolean isBlockFords()
-    {
-        return blockFords;
-    }
-
-    /**
-     * Defines the bits for the node flags, which are currently used for barriers only.
-     * <p>
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineNodeBits( int index, int shift )
-    {
-        return shift;
-    }
-
-    /**
-     * Defines bits used for edge flags used for access, speed etc.
-     * <p/>
-     * @param index
-     * @param shift bit offset for the first bit used by this encoder
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineWayBits( int index, int shift )
-    {
-        if (forwardBit != 0)
-            throw new IllegalStateException("You must not register a FlagEncoder (" + toString() + ") twice!");
-
-        // define the first 2 speedBits in flags for routing
-        forwardBit = 1L << shift;
-        backwardBit = 2L << shift;
-        directionBitMask = 3L << shift;
-        shift += 2;
-        roundaboutBit = 1L << shift;
-        shift++;
-
-        // define internal flags for parsing
-        index *= 2;
-        acceptBit = 1L << index;
-        ferryBit = 2L << index;
-
-        if(null!=encoderDecorators) {
-        	for (EncoderDecorator decorator : encoderDecorators) {
-        		shift = decorator.defineWayBits(shift);
-        	}
-        }
-        return shift;
-    }
-
-    /**
-     * Defines the bits which are used for relation flags.
-     * <p>
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineRelationBits( int index, int shift )
-    {
-        return shift;
-    }
-
-    /**
-     * Analyze the properties of a relation and create the routing flags for the second read step.
-     * In the pre-parsing step this method will be called to determine the useful relation tags.
-     * <p/>
-     */
-    public abstract long handleRelationTags( Relation relation, long oldRelationFlags );
-
-    /**
-     * Decide whether a way is routable for a given mode of travel. This skips some ways before
-     * handleWayTags is called.
-     * <p/>
-     * @return the encoded value to indicate if this encoder allows travel or not.
-     */
-    public abstract long acceptWay( Way way );
-
-    /**
-     * Analyze properties of a way and create the routing flags. This method is called in the second
-     * parsing step.
-     */
-    public long handleWayTags( Way way, long allowed, long relationFlags ) {
-    	if(null!=encoderDecorators) {
-    		for (EncoderDecorator decorator : encoderDecorators) {
+public abstract class AbstractFlagEncoder implements FlagEncoder,
+		TurnCostEncoder {
+	private final static Logger logger = LoggerFactory
+			.getLogger(AbstractFlagEncoder.class);
+	private final static int K_FORWARD = 0, K_BACKWARD = 1;
+	/* Edge Flag Encoder fields */
+	private long nodeBitMask;
+	private long wayBitMask;
+	private long relBitMask;
+	protected long forwardBit;
+	protected long backwardBit;
+	protected long directionBitMask;
+	protected long roundaboutBit;
+	protected EncodedDoubleValue speedEncoder;
+	// bit to signal that way is accepted
+	protected long acceptBit;
+	protected long ferryBit;
+
+	private EncodedValue turnCostEncoder;
+	private long turnRestrictionBit;
+	private final int maxTurnCosts;
+
+	/* processing properties (to be initialized lazy when needed) */
+	protected EdgeExplorer edgeOutExplorer;
+	protected EdgeExplorer edgeInExplorer;
+
+	/* restriction definitions where order is important */
+	protected List<String> restrictions = new ArrayList<String>(5);
+	protected final HashSet<String> intendedValues = new HashSet<String>(5);
+	protected final HashSet<String> excludedValues = new HashSet<String>(5);
+	protected final HashSet<String> restrictedValues = new HashSet<String>(5);
+	protected final HashSet<String> ferries = new HashSet<String>(5);
+	protected final HashSet<String> oneways = new HashSet<String>(5);
+	protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+	// http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
+	protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
+	protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+	/**
+	 * Used to hold type exclusions
+	 */
+	protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(
+			5);
+	protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(
+			5);
+	private boolean blockByDefault = true;
+	private boolean blockFords = true;
+	protected final int speedBits;
+	protected final double speedFactor;
+	protected List<EncoderDecorator> encoderDecorators = null;
+
+	/**
+	 * @param speedBits
+	 *            specify the number of bits used for speed
+	 * @param speedFactor
+	 *            specify the factor to multiple the stored value (can be used
+	 *            to increase or decrease accuracy of speed value)
+	 * @param maxTurnCosts
+	 *            specify the maximum value used for turn costs, if this value
+	 *            is reached a turn is forbidden and results in costs of
+	 *            positive infinity.
+	 */
+	protected AbstractFlagEncoder(int speedBits, double speedFactor,
+			int maxTurnCosts) {
+		this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
+		this.speedBits = speedBits;
+		this.speedFactor = speedFactor;
+		oneways.add("yes");
+		oneways.add("true");
+		oneways.add("1");
+		oneways.add("-1");
+
+		ferries.add("shuttle_train");
+		ferries.add("ferry");
+
+		acceptedRailways.add("tram");
+		acceptedRailways.add("abandoned");
+		acceptedRailways.add("disused");
+
+		// http://wiki.openstreetmap.org/wiki/Demolished_Railway
+		acceptedRailways.add("dismantled");
+		acceptedRailways.add("razed");
+		acceptedRailways.add("historic");
+		acceptedRailways.add("obliterated");
+
+		intendedValues.add("true");
+		intendedValues.add("yes");
+
+		excludedValues.add("false");
+		excludedValues.add("no");
+
+	}
+
+	/**
+	 * Should potential barriers block when no access limits are given?
+	 */
+	public void setBlockByDefault(boolean blockByDefault) {
+		this.blockByDefault = blockByDefault;
+	}
+
+	public void setBlockFords(boolean blockFords) {
+		this.blockFords = blockFords;
+	}
+
+	public boolean isBlockFords() {
+		return blockFords;
+	}
+
+	/**
+	 * Defines the bits for the node flags, which are currently used for
+	 * barriers only.
+	 * <p>
+	 * 
+	 * @return incremented shift value pointing behind the last used bit
+	 */
+	public int defineNodeBits(int index, int shift) {
+		return shift;
+	}
+
+	/**
+	 * Defines bits used for edge flags used for access, speed etc.
+	 * <p/>
+	 * 
+	 * @param index
+	 * @param shift
+	 *            bit offset for the first bit used by this encoder
+	 * @return incremented shift value pointing behind the last used bit
+	 */
+	public int defineWayBits(int index, int shift) {
+		if (forwardBit != 0)
+			throw new IllegalStateException(
+					"You must not register a FlagEncoder (" + toString()
+							+ ") twice!");
+
+		// define the first 2 speedBits in flags for routing
+		forwardBit = 1L << shift;
+		backwardBit = 2L << shift;
+		directionBitMask = 3L << shift;
+		shift += 2;
+		roundaboutBit = 1L << shift;
+		shift++;
+
+		// define internal flags for parsing
+		index *= 2;
+		acceptBit = 1L << index;
+		ferryBit = 2L << index;
+
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
+				shift = decorator.defineWayBits(shift);
+			}
+		}
+		return shift;
+	}
+
+	/**
+	 * Defines the bits which are used for relation flags.
+	 * <p>
+	 * 
+	 * @return incremented shift value pointing behind the last used bit
+	 */
+	public int defineRelationBits(int index, int shift) {
+		return shift;
+	}
+
+	/**
+	 * Analyze the properties of a relation and create the routing flags for the
+	 * second read step. In the pre-parsing step this method will be called to
+	 * determine the useful relation tags.
+	 * <p/>
+	 */
+	public abstract long handleRelationTags(Relation relation,
+			long oldRelationFlags);
+
+	/**
+	 * Decide whether a way is routable for a given mode of travel. This skips
+	 * some ways before handleWayTags is called.
+	 * <p/>
+	 * 
+	 * @return the encoded value to indicate if this encoder allows travel or
+	 *         not.
+	 */
+	public abstract long acceptWay(Way way);
+
+	/**
+	 * Analyze properties of a way and create the routing flags. This method is
+	 * called in the second parsing step.
+	 */
+	public long handleWayTags(Way way, long allowed, long relationFlags) {
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
 				relationFlags = decorator.handleWayTags(way, relationFlags);
 			}
-    	}
-    	return relationFlags;
-    };
-
-    /**
-     * Parse tags on nodes. Node tags can add to speed (like traffic_signals) where the value is
-     * strict negative or blocks access (like a barrier), then the value is strict positive.This
-     * method is called in the second parsing step.
-     */
-    public long handleNodeTags( Node node )
-    {
-        // absolute barriers always block
-        if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
-
-        // movable barriers block if they are not marked as passable
-        if (node.hasTag("barrier", potentialBarriers))
-        {
-            boolean locked = false;
-            if (node.hasTag("locked", "yes"))
-                locked = true;
-
-            for (String res : restrictions)
-            {
-                if (!locked && node.hasTag(res, intendedValues))
-                    return 0;
-
-                if (node.hasTag(res, restrictedValues))
-                    return directionBitMask;
-            }
-
-            if (blockByDefault)
-                return directionBitMask;
-        }
-
-        if (blockFords
-                && (node.hasTag("highway", "ford") || node.hasTag("ford"))
-                && !node.hasTag(restrictions, intendedValues))
-            return directionBitMask;
-
-        return 0;
-    }
-
-    @Override
-    public InstructionAnnotation getAnnotation( long flags, Translation tr )
-    {
-    	if(null!=encoderDecorators) {
-    		for (EncoderDecorator decorator : encoderDecorators) {
+		}
+		return relationFlags;
+	};
+
+	/**
+	 * Parse tags on nodes. Node tags can add to speed (like traffic_signals)
+	 * where the value is strict negative or blocks access (like a barrier),
+	 * then the value is strict positive.This method is called in the second
+	 * parsing step.
+	 */
+	public long handleNodeTags(Node node) {
+		// absolute barriers always block
+		if (node.hasTag("barrier", absoluteBarriers))
+			return directionBitMask;
+
+		// movable barriers block if they are not marked as passable
+		if (node.hasTag("barrier", potentialBarriers)) {
+			boolean locked = false;
+			if (node.hasTag("locked", "yes"))
+				locked = true;
+
+			for (String res : restrictions) {
+				if (!locked && node.hasTag(res, intendedValues))
+					return 0;
+
+				if (node.hasTag(res, restrictedValues))
+					return directionBitMask;
+			}
+
+			if (blockByDefault)
+				return directionBitMask;
+		}
+
+		if (blockFords
+				&& (node.hasTag("highway", "ford") || node.hasTag("ford"))
+				&& !node.hasTag(restrictions, intendedValues))
+			return directionBitMask;
+
+		return 0;
+	}
+
+	@Override
+	public InstructionAnnotation getAnnotation(long flags, Translation tr) {
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
 				InstructionAnnotation anno = decorator.getAnnotation(flags, tr);
-				if(!anno.isEmpty()) {
+				if (!anno.isEmpty()) {
 					return anno;
 				}
 			}
-    	}
-        return InstructionAnnotation.EMPTY;
-    }
-
-    /**
-     * Swapping directions means swapping bits which are dependent on the direction of an edge like
-     * the access bits. But also direction dependent speed values should be swapped too. Keep in
-     * mind that this method is performance critical!
-     */
-    public long reverseFlags( long flags )
-    {
-        long dir = flags & directionBitMask;
-        if (dir == directionBitMask || dir == 0)
-            return flags;
-
-        return flags ^ directionBitMask;
-    }
-
-    /**
-     * Sets default flags with specified access.
-     */
-    public long flagsDefault( boolean forward, boolean backward )
-    {
-        long flags = speedEncoder.setDefaultValue(0);
-        return setAccess(flags, forward, backward);
-    }
-
-    @Override
-    public long setAccess( long flags, boolean forward, boolean backward )
-    {
-        return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
-    }
-
-    @Override
-    public long setSpeed( long flags, double speed )
-    {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed
-                    + ", flags:" + BitUtil.LITTLE.toBitString(flags));
-
-        if (speed > getMaxSpeed())
-            speed = getMaxSpeed();
-        return speedEncoder.setDoubleValue(flags, speed);
-    }
-
-    @Override
-    public double getSpeed( long flags )
-    {
-        double speedVal = speedEncoder.getDoubleValue(flags);
-        if (speedVal < 0)
-            throw new IllegalStateException("Speed was negative!? " + speedVal);
-
-        return speedVal;
-    }
-
-    @Override
-    public long setReverseSpeed( long flags, double speed )
-    {
-        return setSpeed(flags, speed);
-    }
-
-    @Override
-    public double getReverseSpeed( long flags )
-    {
-        return getSpeed(flags);
-    }
-
-    @Override
-    public long setProperties( double speed, boolean forward, boolean backward )
-    {
-        return setAccess(setSpeed(0, speed), forward, backward);
-    }
-
-    @Override
-    public double getMaxSpeed()
-    {
-        return speedEncoder.getMaxValue();
-    }
-
-    /**
-     * @return -1 if no maxspeed found
-     */
-    protected double getMaxSpeed( Way way )
-    {
-        double maxSpeed = parseSpeed(way.getTag("maxspeed"));
-        double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
-        if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed))
-            maxSpeed = fwdSpeed;
-
-        double backSpeed = parseSpeed(way.getTag("maxspeed:backward"));
-        if (backSpeed >= 0 && (maxSpeed < 0 || backSpeed < maxSpeed))
-            maxSpeed = backSpeed;
-
-        return maxSpeed;
-    }
-
-    @Override
-    public int hashCode()
-    {
-        int hash = 7;
-        hash = 61 * hash + (int) this.directionBitMask;
-        hash = 61 * hash + this.toString().hashCode();
-        return hash;
-    }
-
-    @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-            return false;
-
-        // only rely on the string
-        //        if (getClass() != obj.getClass())
-        //            return false;
-        final AbstractFlagEncoder other = (AbstractFlagEncoder) obj;
-        if (this.directionBitMask != other.directionBitMask)
-            return false;
-
-        return this.toString().equals(other.toString());
-    }
-
-    /**
-     * @return the speed in km/h
-     */
-    protected static double parseSpeed( String str )
-    {
-        if (Helper.isEmpty(str))
-            return -1;
-
-        try
-        {
-            int val;
-            // see https://en.wikipedia.org/wiki/Knot_%28unit%29#Definitions
-            int mpInteger = str.indexOf("mp");
-            if (mpInteger > 0)
-            {
-                str = str.substring(0, mpInteger).trim();
-                val = Integer.parseInt(str);
-                return val * DistanceCalcEarth.KM_MILE;
-            }
-
-            int knotInteger = str.indexOf("knots");
-            if (knotInteger > 0)
-            {
-                str = str.substring(0, knotInteger).trim();
-                val = Integer.parseInt(str);
-                return val * 1.852;
-            }
-
-            int kmInteger = str.indexOf("km");
-            if (kmInteger > 0)
-            {
-                str = str.substring(0, kmInteger).trim();
-            } else
-            {
-                kmInteger = str.indexOf("kph");
-                if (kmInteger > 0)
-                {
-                    str = str.substring(0, kmInteger).trim();
-                }
-            }
-
-            return Integer.parseInt(str);
-        } catch (Exception ex)
-        {
-            return -1;
-        }
-    }
-
-    /**
-     * This method parses a string ala "00:00" (hours and minutes) or "0:00:00" (days, hours and
-     * minutes).
-     * <p/>
-     * @return duration value in minutes
-     */
-    protected static int parseDuration( String str )
-    {
-        if (str == null)
-            return 0;
-
-        try
-        {
-            // for now ignore this special duration notation
-            // because P1M != PT1M but there are wrong edits in OSM! e.g. http://www.openstreetmap.org/way/24791405
-            // http://wiki.openstreetmap.org/wiki/Key:duration
-            if (str.startsWith("P"))
-                return 0;
-
-            int index = str.indexOf(":");
-            if (index > 0)
-            {
-                String hourStr = str.substring(0, index);
-                String minStr = str.substring(index + 1);
-                index = minStr.indexOf(":");
-                int minutes = 0;
-                if (index > 0)
-                {
-                    // string contains hours too
-                    String dayStr = hourStr;
-                    hourStr = minStr.substring(0, index);
-                    minStr = minStr.substring(index + 1);
-                    minutes = Integer.parseInt(dayStr) * 60 * 24;
-                }
-
-                minutes += Integer.parseInt(hourStr) * 60;
-                minutes += Integer.parseInt(minStr);
-                return minutes;
-            } else
-            {
-                return Integer.parseInt(str);
-            }
-        } catch (Exception ex)
-        {
-            logger.warn("Cannot parse " + str + " using 0 minutes");
-        }
-        return 0;
-    }
-
-    /**
-     * Second parsing step. Invoked after splitting the edges. Currently used to offer a hook to
-     * calculate precise speed values based on elevation data stored in the specified edge.
-     */
-    public void applyWayTags( Way way, EdgeIteratorState edge )
-    {
-    	if(null!=encoderDecorators) {
-    		for (EncoderDecorator decorator : encoderDecorators) {
-    			
+		}
+		return InstructionAnnotation.EMPTY;
+	}
+
+	/**
+	 * Swapping directions means swapping bits which are dependent on the
+	 * direction of an edge like the access bits. But also direction dependent
+	 * speed values should be swapped too. Keep in mind that this method is
+	 * performance critical!
+	 */
+	public long reverseFlags(long flags) {
+		long dir = flags & directionBitMask;
+		if (dir == directionBitMask || dir == 0)
+			return flags;
+
+		return flags ^ directionBitMask;
+	}
+
+	/**
+	 * Sets default flags with specified access.
+	 */
+	public long flagsDefault(boolean forward, boolean backward) {
+		long flags = speedEncoder.setDefaultValue(0);
+		return setAccess(flags, forward, backward);
+	}
+
+	@Override
+	public long setAccess(long flags, boolean forward, boolean backward) {
+		return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
+	}
+
+	@Override
+	public long setSpeed(long flags, double speed) {
+		if (speed < 0)
+			throw new IllegalArgumentException("Speed cannot be negative: "
+					+ speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+
+		if (speed > getMaxSpeed())
+			speed = getMaxSpeed();
+		return speedEncoder.setDoubleValue(flags, speed);
+	}
+
+	@Override
+	public double getSpeed(long flags) {
+		double speedVal = speedEncoder.getDoubleValue(flags);
+		if (speedVal < 0)
+			throw new IllegalStateException("Speed was negative!? " + speedVal);
+
+		return speedVal;
+	}
+
+	@Override
+	public long setReverseSpeed(long flags, double speed) {
+		return setSpeed(flags, speed);
+	}
+
+	@Override
+	public double getReverseSpeed(long flags) {
+		return getSpeed(flags);
+	}
+
+	@Override
+	public long setProperties(double speed, boolean forward, boolean backward) {
+		return setAccess(setSpeed(0, speed), forward, backward);
+	}
+
+	@Override
+	public double getMaxSpeed() {
+		return speedEncoder.getMaxValue();
+	}
+
+	/**
+	 * @return -1 if no maxspeed found
+	 */
+	protected double getMaxSpeed(Way way) {
+		double maxSpeed = parseSpeed(way.getTag("maxspeed"));
+		double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
+		if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed))
+			maxSpeed = fwdSpeed;
+
+		double backSpeed = parseSpeed(way.getTag("maxspeed:backward"));
+		if (backSpeed >= 0 && (maxSpeed < 0 || backSpeed < maxSpeed))
+			maxSpeed = backSpeed;
+
+		return maxSpeed;
+	}
+
+	@Override
+	public int hashCode() {
+		int hash = 7;
+		hash = 61 * hash + (int) this.directionBitMask;
+		hash = 61 * hash + this.toString().hashCode();
+		return hash;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj == null)
+			return false;
+
+		// only rely on the string
+		// if (getClass() != obj.getClass())
+		// return false;
+		final AbstractFlagEncoder other = (AbstractFlagEncoder) obj;
+		if (this.directionBitMask != other.directionBitMask)
+			return false;
+
+		return this.toString().equals(other.toString());
+	}
+
+	/**
+	 * @return the speed in km/h
+	 */
+	protected static double parseSpeed(String str) {
+		if (Helper.isEmpty(str))
+			return -1;
+
+		try {
+			int val;
+			// see https://en.wikipedia.org/wiki/Knot_%28unit%29#Definitions
+			int mpInteger = str.indexOf("mp");
+			if (mpInteger > 0) {
+				str = str.substring(0, mpInteger).trim();
+				val = Integer.parseInt(str);
+				return val * DistanceCalcEarth.KM_MILE;
+			}
+
+			int knotInteger = str.indexOf("knots");
+			if (knotInteger > 0) {
+				str = str.substring(0, knotInteger).trim();
+				val = Integer.parseInt(str);
+				return val * 1.852;
+			}
+
+			int kmInteger = str.indexOf("km");
+			if (kmInteger > 0) {
+				str = str.substring(0, kmInteger).trim();
+			} else {
+				kmInteger = str.indexOf("kph");
+				if (kmInteger > 0) {
+					str = str.substring(0, kmInteger).trim();
+				}
+			}
+
+			return Integer.parseInt(str);
+		} catch (Exception ex) {
+			return -1;
+		}
+	}
+
+	/**
+	 * This method parses a string ala "00:00" (hours and minutes) or "0:00:00"
+	 * (days, hours and minutes).
+	 * <p/>
+	 * 
+	 * @return duration value in minutes
+	 */
+	protected static int parseDuration(String str) {
+		if (str == null)
+			return 0;
+
+		try {
+			// for now ignore this special duration notation
+			// because P1M != PT1M but there are wrong edits in OSM! e.g.
+			// http://www.openstreetmap.org/way/24791405
+			// http://wiki.openstreetmap.org/wiki/Key:duration
+			if (str.startsWith("P"))
+				return 0;
+
+			int index = str.indexOf(":");
+			if (index > 0) {
+				String hourStr = str.substring(0, index);
+				String minStr = str.substring(index + 1);
+				index = minStr.indexOf(":");
+				int minutes = 0;
+				if (index > 0) {
+					// string contains hours too
+					String dayStr = hourStr;
+					hourStr = minStr.substring(0, index);
+					minStr = minStr.substring(index + 1);
+					minutes = Integer.parseInt(dayStr) * 60 * 24;
+				}
+
+				minutes += Integer.parseInt(hourStr) * 60;
+				minutes += Integer.parseInt(minStr);
+				return minutes;
+			} else {
+				return Integer.parseInt(str);
+			}
+		} catch (Exception ex) {
+			logger.warn("Cannot parse " + str + " using 0 minutes");
+		}
+		return 0;
+	}
+
+	/**
+	 * Second parsing step. Invoked after splitting the edges. Currently used to
+	 * offer a hook to calculate precise speed values based on elevation data
+	 * stored in the specified edge.
+	 */
+	public void applyWayTags(Way way, EdgeIteratorState edge) {
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
+
+			}
+		}
+	}
+
+	/**
+	 * Special handling for ferry ways.
+	 */
+	protected long handleFerryTags(Way way, double unknownSpeed,
+			double shortTripsSpeed, double longTripsSpeed) {
+		// to hours
+		double durationInHours = parseDuration(way.getTag("duration")) / 60d;
+		if (durationInHours > 0)
+			try {
+				Number estimatedLength = way.getTag("estimated_distance", null);
+				if (estimatedLength != null) {
+					// to km
+					double val = estimatedLength.doubleValue() / 1000;
+					// If duration AND distance is available we can calculate
+					// the speed more precisely
+					// and set both speed to the same value. Factor 1.4 slower
+					// because of waiting time!
+					shortTripsSpeed = Math.round(val / durationInHours / 1.4);
+					if (shortTripsSpeed > getMaxSpeed())
+						shortTripsSpeed = getMaxSpeed();
+					longTripsSpeed = shortTripsSpeed;
+				}
+			} catch (Exception ex) {
+			}
+
+		if (durationInHours == 0) {
+			// unknown speed -> put penalty on ferry transport
+			return setSpeed(0, unknownSpeed);
+		} else if (durationInHours > 1) {
+			// lengthy ferries should be faster than short trip ferry
+			return setSpeed(0, longTripsSpeed);
+		} else {
+			return setSpeed(0, shortTripsSpeed);
+		}
+	}
+
+	void setWayBitMask(int usedBits, int shift) {
+		wayBitMask = (1L << usedBits) - 1;
+		wayBitMask <<= shift;
+	}
+
+	long getWayBitMask() {
+		return wayBitMask;
+	}
+
+	void setRelBitMask(int usedBits, int shift) {
+		relBitMask = (1L << usedBits) - 1;
+		relBitMask <<= shift;
+	}
+
+	long getRelBitMask() {
+		return relBitMask;
+	}
+
+	void setNodeBitMask(int usedBits, int shift) {
+		nodeBitMask = (1L << usedBits) - 1;
+		nodeBitMask <<= shift;
+	}
+
+	long getNodeBitMask() {
+		return nodeBitMask;
+	}
+
+	/**
+	 * Defines the bits reserved for storing turn restriction and turn cost
+	 * <p>
+	 * 
+	 * @param shift
+	 *            bit offset for the first bit used by this encoder
+	 * @return incremented shift value pointing behind the last used bit
+	 */
+	public int defineTurnBits(int index, int shift) {
+		if (maxTurnCosts == 0)
+			return shift;
+
+		// optimization for turn restrictions only
+		else if (maxTurnCosts == 1) {
+			turnRestrictionBit = 1L << shift;
+			return shift + 1;
+		}
+
+		int turnBits = Helper.countBitValue(maxTurnCosts);
+		turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0,
+				maxTurnCosts) {
+			// override to avoid expensive Math.round
+			@Override
+			public final long getValue(long flags) {
+				// find value
+				flags &= mask;
+				flags >>= shift;
+				return flags;
+			}
+		};
+		return shift + turnBits;
+	}
+
+	@Override
+	public boolean isTurnRestricted(long flags) {
+		if (maxTurnCosts == 0)
+			return false;
+
+		else if (maxTurnCosts == 1)
+			return (flags & turnRestrictionBit) != 0;
+
+		return turnCostEncoder.getValue(flags) == maxTurnCosts;
+	}
+
+	@Override
+	public double getTurnCost(long flags) {
+		if (maxTurnCosts == 0)
+			return 0;
+
+		else if (maxTurnCosts == 1)
+			return ((flags & turnRestrictionBit) == 0) ? 0
+					: Double.POSITIVE_INFINITY;
+
+		long cost = turnCostEncoder.getValue(flags);
+		if (cost == maxTurnCosts)
+			return Double.POSITIVE_INFINITY;
+
+		return cost;
+	}
+
+	@Override
+	public long getTurnFlags(boolean restricted, double costs) {
+		if (maxTurnCosts == 0)
+			return 0;
+
+		else if (maxTurnCosts == 1) {
+			if (costs != 0)
+				throw new IllegalArgumentException(
+						"Only restrictions are supported");
+
+			return restricted ? turnRestrictionBit : 0;
+		}
+
+		if (restricted) {
+			if (costs != 0 || Double.isInfinite(costs))
+				throw new IllegalArgumentException(
+						"Restricted turn can only have infinite costs (or use 0)");
+		} else {
+			if (costs >= maxTurnCosts)
+				throw new IllegalArgumentException(
+						"Cost is too high. Or specifiy restricted == true");
+		}
+
+		if (costs < 0)
+			throw new IllegalArgumentException("Turn costs cannot be negative");
+
+		if (costs >= maxTurnCosts || restricted)
+			costs = maxTurnCosts;
+		return turnCostEncoder.setValue(0L, (int) costs);
+	}
+
+	public Collection<ITurnCostTableEntry> analyzeTurnRelation(
+			TurnRelation turnRelation, DataReader osmReader) {
+		if (!supports(TurnWeighting.class))
+			return Collections.emptyList();
+
+		if (edgeOutExplorer == null || edgeInExplorer == null) {
+			edgeOutExplorer = osmReader.getGraphStorage().createEdgeExplorer(
+					new DefaultEdgeFilter(this, false, true));
+			edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(
+					new DefaultEdgeFilter(this, true, false));
+		}
+		return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer,
+				edgeInExplorer, osmReader);
+	}
+
+	protected boolean isFerry(long internalFlags) {
+		return (internalFlags & ferryBit) != 0;
+	}
+
+	protected boolean isAccept(long internalFlags) {
+		return (internalFlags & acceptBit) != 0;
+	}
+
+	@Override
+	public boolean isBackward(long flags) {
+		return (flags & backwardBit) != 0;
+	}
+
+	@Override
+	public boolean isForward(long flags) {
+		return (flags & forwardBit) != 0;
+	}
+
+	@Override
+	public long setBool(long flags, int key, boolean value) {
+		switch (key) {
+		case K_FORWARD:
+			return value ? flags | forwardBit : flags & ~forwardBit;
+		case K_BACKWARD:
+			return value ? flags | backwardBit : flags & ~backwardBit;
+		case K_ROUNDABOUT:
+			return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+		default:
+			throw new IllegalArgumentException("Unknown key " + key
+					+ " for boolean value");
+		}
+	}
+
+	@Override
+	public boolean isBool(long flags, int key) {
+		switch (key) {
+
+		case K_FORWARD:
+			return isForward(flags);
+		case K_BACKWARD:
+			return isBackward(flags);
+		case K_ROUNDABOUT:
+			return (flags & roundaboutBit) != 0;
+		default:
+			throw new IllegalArgumentException("Unknown key " + key
+					+ " for boolean value");
+		}
+	}
+
+	@Override
+	public long setLong(long flags, int key, long value) {
+		throw new UnsupportedOperationException("Unknown key " + key
+				+ " for long value.");
+	}
+
+	@Override
+	public long getLong(long flags, int key) {
+		for (EncoderDecorator decorator : encoderDecorators) {
+			if (decorator.supports(key)) {
+				return decorator.getLong(flags);
+			}
+		}
+		throw new UnsupportedOperationException("Unknown key " + key
+				+ " for long value.");
+	}
+
+	@Override
+	public long setDouble(long flags, int key, double value) {
+		throw new UnsupportedOperationException("Unknown key " + key
+				+ " for double value.");
+	}
+
+	@Override
+	public double getDouble(long flags, int key) {
+		for (EncoderDecorator decorator : encoderDecorators) {
+			if (decorator.supports(key)) {
+				return decorator.getDouble(flags);
+			}
+		}
+		throw new UnsupportedOperationException("Unknown key " + key
+				+ " for double value.");
+	}
+
+	protected static double parseDouble(String str, String key, double defaultD) {
+		String val = getStr(str, key);
+		if (val.isEmpty())
+			return defaultD;
+		return Double.parseDouble(val);
+	}
+
+	protected static long parseLong(String str, String key, long defaultL) {
+		String val = getStr(str, key);
+		if (val.isEmpty())
+			return defaultL;
+		return Long.parseLong(val);
+	}
+
+	protected static boolean parseBoolean(String str, String key,
+			boolean defaultB) {
+		String val = getStr(str, key);
+		if (val.isEmpty())
+			return defaultB;
+		return Boolean.parseBoolean(val);
+	}
+
+	protected static String getStr(String str, String key) {
+		key = key.toLowerCase();
+		for (String s : str.split("\\|")) {
+			s = s.trim().toLowerCase();
+			int index = s.indexOf("=");
+			if (index < 0)
+				continue;
+
+			String field = s.substring(0, index);
+			String valueStr = s.substring(index + 1);
+			if (key.equals(field))
+				return valueStr;
+		}
+		return "";
+	}
+
+	/**
+	 * @param force
+	 *            should be false if speed should be changed only if it is
+	 *            bigger than maxspeed.
+	 */
+	protected double applyMaxSpeed(Way way, double speed, boolean force) {
+		double maxSpeed = getMaxSpeed(way);
+		// apply only if smaller maxSpeed
+		if (maxSpeed >= 0) {
+			if (force || maxSpeed < speed)
+				return maxSpeed * 0.9;
+		}
+		return speed;
+	}
+
+	protected String getPropertiesString() {
+		return "speedFactor=" + speedFactor + "|speedBits=" + speedBits
+				+ "|turnCosts=" + (maxTurnCosts > 0);
+	}
+
+	@Override
+	public boolean supports(Class<?> feature) {
+		if (TurnWeighting.class.isAssignableFrom(feature))
+			return maxTurnCosts > 0;
+
+		return false;
+	}
+
+	/**
+	 * The routingElement is specifically included in this exception. For
+	 * example Motor Vehicles=true or Buses=true
+	 * 
+	 * @param routingElement
+	 * @return
+	 */
+	public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
+		if (routingElement.hasTag(vehicleQualifierTypeInclusions,
+				intendedValues)) {
+			// It is specifically included
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * The routingElement is specifically excluded in this exception. For
+	 * example Motor Vehicles=false or Buses=false
+	 * 
+	 * @param routingElement
+	 * @return
+	 */
+	public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
+		if (routingElement.hasTag(vehicleQualifierTypeExclusions,
+				excludedValues)) {
+			// It is specifically excluded
+			return true;
+		}
+		return false;
+	}
+
+	@Override
+	public long getBitMask(String[] attributes, int key) {
+		long bitMask = 0;
+		if (null != encoderDecorators) {// BIT SHIFT FIRST
+			for (EncoderDecorator decorator : encoderDecorators) {
+				if(decorator.supports(key)) {
+					return decorator.getBitMask(attributes);
+				}
 			}
-    	}
-    }
-
-    /**
-     * Special handling for ferry ways.
-     */
-    protected long handleFerryTags( Way way, double unknownSpeed, double shortTripsSpeed, double longTripsSpeed )
-    {
-        // to hours
-        double durationInHours = parseDuration(way.getTag("duration")) / 60d;
-        if (durationInHours > 0)
-            try
-        {
-                Number estimatedLength = way.getTag("estimated_distance", null);
-                if (estimatedLength != null)
-                {
-                    // to km
-                    double val = estimatedLength.doubleValue() / 1000;
-                    // If duration AND distance is available we can calculate the speed more precisely
-                    // and set both speed to the same value. Factor 1.4 slower because of waiting time!
-                    shortTripsSpeed = Math.round(val / durationInHours / 1.4);
-                    if (shortTripsSpeed > getMaxSpeed())
-                        shortTripsSpeed = getMaxSpeed();
-                    longTripsSpeed = shortTripsSpeed;
-                }
-        } catch (Exception ex)
-        {
-        }
-
-        if (durationInHours == 0)
-        {
-            // unknown speed -> put penalty on ferry transport
-            return setSpeed(0, unknownSpeed);
-        } else if (durationInHours > 1)
-        {
-            // lengthy ferries should be faster than short trip ferry
-            return setSpeed(0, longTripsSpeed);
-        } else
-        {
-            return setSpeed(0, shortTripsSpeed);
-        }
-    }
-
-    void setWayBitMask( int usedBits, int shift )
-    {
-        wayBitMask = (1L << usedBits) - 1;
-        wayBitMask <<= shift;
-    }
-
-    long getWayBitMask()
-    {
-        return wayBitMask;
-    }
-
-    void setRelBitMask( int usedBits, int shift )
-    {
-        relBitMask = (1L << usedBits) - 1;
-        relBitMask <<= shift;
-    }
-
-    long getRelBitMask()
-    {
-        return relBitMask;
-    }
-
-    void setNodeBitMask( int usedBits, int shift )
-    {
-        nodeBitMask = (1L << usedBits) - 1;
-        nodeBitMask <<= shift;
-    }
-
-    long getNodeBitMask()
-    {
-        return nodeBitMask;
-    }
-
-    /**
-     * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
-     * @param shift bit offset for the first bit used by this encoder
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineTurnBits( int index, int shift )
-    {
-        if (maxTurnCosts == 0)
-            return shift;
-
-        // optimization for turn restrictions only
-        else if (maxTurnCosts == 1)
-        {
-            turnRestrictionBit = 1L << shift;
-            return shift + 1;
-        }
-
-        int turnBits = Helper.countBitValue(maxTurnCosts);
-        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts)
-        {
-            // override to avoid expensive Math.round
-            @Override
-            public final long getValue( long flags )
-            {
-                // find value
-                flags &= mask;
-                flags >>= shift;
-            return flags;
-            }
-        };
-        return shift + turnBits;
-    }
-
-    @Override
-    public boolean isTurnRestricted( long flags )
-    {
-        if (maxTurnCosts == 0)
-            return false;
-
-        else if (maxTurnCosts == 1)
-            return (flags & turnRestrictionBit) != 0;
-
-        return turnCostEncoder.getValue(flags) == maxTurnCosts;
-    }
-
-    @Override
-    public double getTurnCost( long flags )
-    {
-        if (maxTurnCosts == 0)
-            return 0;
-
-        else if (maxTurnCosts == 1)
-            return ((flags & turnRestrictionBit) == 0) ? 0 : Double.POSITIVE_INFINITY;
-
-        long cost = turnCostEncoder.getValue(flags);
-        if (cost == maxTurnCosts)
-            return Double.POSITIVE_INFINITY;
-
-        return cost;
-    }
-
-    @Override
-    public long getTurnFlags( boolean restricted, double costs )
-    {
-        if (maxTurnCosts == 0)
-            return 0;
-
-        else if (maxTurnCosts == 1)
-        {
-            if (costs != 0)
-                throw new IllegalArgumentException("Only restrictions are supported");
-
-            return restricted ? turnRestrictionBit : 0;
-        }
-
-        if (restricted)
-        {
-            if (costs != 0 || Double.isInfinite(costs))
-                throw new IllegalArgumentException("Restricted turn can only have infinite costs (or use 0)");
-        } else
-        {
-            if (costs >= maxTurnCosts)
-                throw new IllegalArgumentException("Cost is too high. Or specifiy restricted == true");
-        }
-
-        if (costs < 0)
-            throw new IllegalArgumentException("Turn costs cannot be negative");
-
-        if (costs >= maxTurnCosts || restricted)
-            costs = maxTurnCosts;
-        return turnCostEncoder.setValue(0L, (int) costs);
-    }
-
-    public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation, DataReader osmReader )
-    {
-        if (!supports(TurnWeighting.class))
-            return Collections.emptyList();
-
-        if (edgeOutExplorer == null || edgeInExplorer == null)
-        {
-            edgeOutExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, false, true));
-            edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, true, false));
-        }
-        return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer, osmReader);
-    }
-
-    protected boolean isFerry( long internalFlags )
-    {
-        return (internalFlags & ferryBit) != 0;
-    }
-
-    protected boolean isAccept( long internalFlags )
-    {
-        return (internalFlags & acceptBit) != 0;
-    }
-
-    @Override
-    public boolean isBackward( long flags )
-    {
-        return (flags & backwardBit) != 0;
-    }
-
-    @Override
-    public boolean isForward( long flags )
-    {
-        return (flags & forwardBit) != 0;
-    }
-
-    @Override
-    public long setBool( long flags, int key, boolean value )
-    {
-        switch (key)
-        {
-        case K_FORWARD:
-            return value ? flags | forwardBit : flags & ~forwardBit;
-        case K_BACKWARD:
-            return value ? flags | backwardBit : flags & ~backwardBit;
-        case K_ROUNDABOUT:
-            return value ? flags | roundaboutBit : flags & ~roundaboutBit;
-        default:
-            throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
-        }
-    }
-
-    @Override
-    public boolean isBool( long flags, int key )
-    {
-        switch (key)
-        {
-
-            case K_FORWARD:
-                return isForward(flags);
-            case K_BACKWARD:
-                return isBackward(flags);
-            case K_ROUNDABOUT:
-                return (flags & roundaboutBit) != 0;
-            default:
-                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
-        }
-    }
-
-    @Override
-    public long setLong( long flags, int key, long value )
-    {
-        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
-    }
-
-    @Override
-    public long getLong( long flags, int key )
-    {
-        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
-    }
-
-    @Override
-    public long setDouble( long flags, int key, double value )
-    {
-        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
-    }
-
-    @Override
-    public double getDouble( long flags, int key )
-    {
-        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
-    }
-
-    protected static double parseDouble( String str, String key, double defaultD )
-    {
-        String val = getStr(str, key);
-        if (val.isEmpty())
-            return defaultD;
-        return Double.parseDouble(val);
-    }
-
-    protected static long parseLong( String str, String key, long defaultL )
-    {
-        String val = getStr(str, key);
-        if (val.isEmpty())
-            return defaultL;
-        return Long.parseLong(val);
-    }
-
-    protected static boolean parseBoolean( String str, String key, boolean defaultB )
-    {
-        String val = getStr(str, key);
-        if (val.isEmpty())
-            return defaultB;
-        return Boolean.parseBoolean(val);
-    }
-
-    protected static String getStr( String str, String key )
-    {
-        key = key.toLowerCase();
-        for (String s : str.split("\\|"))
-        {
-            s = s.trim().toLowerCase();
-            int index = s.indexOf("=");
-            if (index < 0)
-                continue;
-
-            String field = s.substring(0, index);
-            String valueStr = s.substring(index + 1);
-            if (key.equals(field))
-                return valueStr;
-        }
-        return "";
-    }
-
-    /**
-     * @param force should be false if speed should be changed only if it is bigger than maxspeed.
-     */
-    protected double applyMaxSpeed(Way way, double speed, boolean force )
-    {
-        double maxSpeed = getMaxSpeed(way);
-        // apply only if smaller maxSpeed
-        if (maxSpeed >= 0)
-        {
-            if (force || maxSpeed < speed)
-                return maxSpeed * 0.9;
-        }
-        return speed;
-    }
-
-    protected String getPropertiesString()
-    {
-        return "speedFactor=" + speedFactor + "|speedBits=" + speedBits + "|turnCosts=" + (maxTurnCosts > 0);
-    }
-
-    @Override
-    public boolean supports( Class<?> feature )
-    {
-        if (TurnWeighting.class.isAssignableFrom(feature))
-            return maxTurnCosts > 0;
-
-            return false;
-    }
-
-    /**
-     * The routingElement is specifically included in this exception. For example Motor Vehicles=true or Buses=true
-     * @param routingElement
-     * @return
-     */
-    public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
-        if (routingElement.hasTag(vehicleQualifierTypeInclusions, intendedValues)) {
-            // It is specifically included
-            return true;
-        }
-        return false;
-    }
-    /**
-     * The routingElement is specifically excluded in this exception. For example Motor Vehicles=false or Buses=false
-     * @param routingElement
-     * @return
-     */
-    public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
-        if (routingElement.hasTag(vehicleQualifierTypeExclusions, excludedValues)) {
-            // It is specifically excluded
-            return true;
-        }
-        return false;
-    }
+		}
+		return bitMask;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeAttribute.java b/core/src/main/java/com/graphhopper/routing/util/EdgeAttribute.java
new file mode 100644
index 0000000000..6ac91014df
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeAttribute.java
@@ -0,0 +1,10 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.Way;
+
+public interface EdgeAttribute {
+	boolean isValidForWay(Way way);
+	long getValue();
+	String name();
+	boolean representedIn(String[] attributes);
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
index be4fddbcde..4a6e2e1602 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
@@ -8,4 +8,8 @@
 	int defineWayBits(int shift);
 	long handleWayTags(Way way, long encoded);
 	public InstructionAnnotation getAnnotation(long flags, Translation tr);
+	long getBitMask(String[] attributes);
+	double getDouble(long flags);
+	long getLong(long flags);
+	boolean supports(int key);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
new file mode 100644
index 0000000000..676b4938c3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
@@ -0,0 +1,29 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class FastestWithAvoidancesWeighting extends FastestWeighting {
+
+	private long bitMask;
+
+	public FastestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+		super(encoder);
+		configureAvoidances(avoidances);
+	}
+
+	private void configureAvoidances(String[] avoidances) {
+		bitMask = encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY);
+	}
+	
+	@Override
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {
+        long wayType = edge.getFlags();
+        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
+        
+        if((wayType & bitMask) == bitMask)
+            return Double.POSITIVE_INFINITY;
+        return super.calcWeight(edge, reverse, prevOrNextEdgeId);
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 96b6a599d3..7d4076b851 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -121,4 +121,6 @@
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
     InstructionAnnotation getAnnotation( long flags, Translation tr );
+
+	long getBitMask(String[] avoidances, int key);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/OsAvoidanceDecorator.java
index f4e8e691e8..abd6aea6f9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsAvoidanceDecorator.java
@@ -1,16 +1,13 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.Way;
-import com.graphhopper.util.InstructionAnnotation;
-import com.graphhopper.util.Translation;
 
 /**
  * Created by sadam on 4/15/15.
  */
-public class OsAvoidanceDecorator implements EncoderDecorator {
-	private EncodedValue wayTypeEncoder;
+public class OsAvoidanceDecorator extends AbstractAvoidanceDecorator {
 
-	protected enum AvoidanceType {
+	protected enum AvoidanceType implements EdgeAttribute {
 		Boulders(1) {
 			@Override
 			public boolean isValidForWay(Way way) {
@@ -37,10 +34,10 @@ public boolean isValidForWay(Way way) {
 			}
 		},
 		QuarryOrPit(16) {
-			 @Override
-			 public boolean isValidForWay(Way way) {
-				 return hasTag(way, "natural", "excavation");
-			 }
+			@Override
+			public boolean isValidForWay(Way way) {
+				return hasTag(way, "natural", "excavation");
+			}
 		},
 		Scree(32) {
 			@Override
@@ -53,8 +50,7 @@ public boolean isValidForWay(Way way) {
 			public boolean isValidForWay(Way way) {
 				return hasTag(way, "natural", "rock");
 			}
-		}
-		,
+		},
 		Mud(128) {
 			@Override
 			public boolean isValidForWay(Way way) {
@@ -67,29 +63,33 @@ public boolean isValidForWay(Way way) {
 				return hasTag(way, "natural", "sand");
 			}
 		},
-		
+
 		Shingle(512) {
 			@Override
 			public boolean isValidForWay(Way way) {
 				return hasTag(way, "natural", "shingle");
 			}
 		}
-//		,
-//		Spoil(1024) {
-//			@Override
-//			public boolean isValidForWay(Way way) {
-//				return hasTag(way, "natural", "spoil");
-//			}
-//		},
-//		
-//		TidalWater(2048) {
-//			@Override
-//			public boolean isValidForWay(Way way) {
-//				return hasTag(way, "natural", "water")
-//						&& way.hasTag("tidal", "yes");
-//			}
-//		}
-	;
+		// ,
+		// Spoil(1024) {
+		// @Override
+		// public boolean isValidForWay(Way way) {
+		// return hasTag(way, "natural", "spoil");
+		// }
+		// },
+		//
+		// TidalWater(2048) {
+		// @Override
+		// public boolean isValidForWay(Way way) {
+		// return hasTag(way, "natural", "water")
+		// && way.hasTag("tidal", "yes");
+		// }
+		// }
+		;
+
+		public String toString() {
+			return super.toString().toLowerCase();
+		}
 
 		private static boolean hasTag(Way way, String key, String value) {
 			String wayTag = way.getTag(key);
@@ -118,42 +118,27 @@ public boolean isValidForWay(Way way) {
 			return false;
 		}
 
-	}
+		public boolean representedIn(String[] attributes) {
+			System.err.println("REPRESENT:" + this.toString());
+			for (String attribute : attributes) {
+				System.err.println("SEEKING:" + attribute);
 
-	public int defineWayBits(int shift) {
-		wayTypeEncoder = new EncodedValue("WayType", shift, 11, 1, 0, 1024,
-				true);
-		shift += wayTypeEncoder.getBits();
-		return shift;
-	}
-
-	public long handleWayTags(Way way, long encoded) {
-		long avoidanceValue = 0;
-
-		for (AvoidanceType aType : AvoidanceType.values()) {
-			if (aType.isValidForWay(way)) {
-				avoidanceValue += aType.getValue();
+				if (attribute.equals(this.toString())) {
+					return true;
+				}
 			}
+			return false;
 		}
-		return wayTypeEncoder.setValue(encoded, avoidanceValue);
-	}
 
-	public InstructionAnnotation getAnnotation(long flags, Translation tr) {
-		long wayType = wayTypeEncoder.getValue(flags);
-		String wayName = getWayName(wayType, tr);
-		return new InstructionAnnotation(1, wayName);
 	}
 
-	private String getWayName(long wayType, Translation tr) {
-		String wayName = "";
-		for (AvoidanceType aType : AvoidanceType.values()) {
-			if ((wayType & aType.getValue()) == aType.getValue()) {
-				wayName += " ";
-				wayName += aType.name();
-			}
-		}
+	protected void defineEncoder(int shift) {
+		wayTypeEncoder = new EncodedValue("WayType", shift, 11, 1, 0, 1024,
+				true);
+	}
 
-		return wayName;
+	protected EdgeAttribute[] getEdgeAttributesOfInterest() {
+		return AvoidanceType.values();
 	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
index 6bfa8bd75a..8a002a77f3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsVehicleAvoidanceDecorator.java
@@ -1,17 +1,12 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.Way;
-import com.graphhopper.util.InstructionAnnotation;
-import com.graphhopper.util.Translation;
 
 /**
  * Created by sadam on 4/15/15.
  */
-public class OsVehicleAvoidanceDecorator implements EncoderDecorator {
-    private EncodedValue wayTypeEncoder;
-
-
-    protected enum AvoidanceType
+public class OsVehicleAvoidanceDecorator extends AbstractAvoidanceDecorator {
+    protected enum AvoidanceType implements EdgeAttribute
     {
         MOTORWAYS(1) {
             @Override
@@ -42,45 +37,24 @@ public long getValue()
         public boolean isValidForWay(Way way) {
             return false;
         }
-
-
-
+        
+        public boolean representedIn(String[] attributes) {
+			for (String attribute : attributes) {
+				if(attribute.equals(this.toString())) {
+					return true;
+				}
+			}
+			return false;
+		}
     }
 
-    public int defineWayBits(int shift) {
-        wayTypeEncoder = new EncodedValue("WayType", shift, 3, 1, 0, 4, true);
-        shift += wayTypeEncoder.getBits();
-        return shift;
-    }
-
-    public long handleWayTags(Way way, long encoded) {
-        long avoidanceValue=0;
-
-        for (AvoidanceType aType: AvoidanceType.values()) {
-            if(aType.isValidForWay(way)) {
-                avoidanceValue += aType.getValue();
-            }
-        }
-        return wayTypeEncoder.setValue(encoded, avoidanceValue);
-    }
-
-    public InstructionAnnotation getAnnotation( long flags, Translation tr )
-    {
-        long wayType = wayTypeEncoder.getValue(flags);
-        String wayName = getWayName(wayType, tr);
-        return new InstructionAnnotation(0, wayName);
-    }
-
-    private String getWayName(long wayType, Translation tr) {
-        String wayName="";
-        for (AvoidanceType aType: AvoidanceType.values()) {
-            if ((wayType & aType.getValue()) == aType.getValue()) {
-                wayName += " ";
-                wayName += aType.name();
-            }
-        }
-
-        return wayName;
-    }
+    @Override
+	protected void defineEncoder(int shift) {
+		wayTypeEncoder = new EncodedValue("WayType", shift, 3, 1, 0, 4, true);
+	}
+    
+    protected EdgeAttribute[] getEdgeAttributesOfInterest() {
+		return AvoidanceType.values();
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
new file mode 100644
index 0000000000..2a9d080773
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
@@ -0,0 +1,30 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class PriorityWithAvoidancesWeighting extends PriorityWeighting {
+
+	private long bitMask;
+
+	public PriorityWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+		super(encoder);
+		configureAvoidances(avoidances);
+	}
+
+	private void configureAvoidances(String[] avoidances) {
+		bitMask = encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY);
+	}
+	
+	@Override
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {
+        long wayType = edge.getFlags();
+        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
+        System.err.println("BITMASK:" + bitMask + " BITWEIGHT:" + wayType);
+        
+        if(bitMask!=0 && ((wayType & bitMask) == bitMask))
+            return Double.POSITIVE_INFINITY;
+        return super.calcWeight(edge, reverse, prevOrNextEdgeId);
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
new file mode 100644
index 0000000000..897d0b4348
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
@@ -0,0 +1,31 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class ShortestWithAvoidancesWeighting extends ShortestWeighting {
+
+	private long bitMask;
+	private FlagEncoder encoder;
+
+	public ShortestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+		super();
+		this.encoder = encoder;
+		configureAvoidances(avoidances);
+	}
+
+	private void configureAvoidances(String[] avoidances) {
+		bitMask = encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY);
+	}
+	
+	@Override
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {
+        long wayType = edge.getFlags();
+        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
+        
+        if((wayType & bitMask) == bitMask)
+            return Double.POSITIVE_INFINITY;
+        return super.calcWeight(edge, reverse, prevOrNextEdgeId);
+    }
+
+}
