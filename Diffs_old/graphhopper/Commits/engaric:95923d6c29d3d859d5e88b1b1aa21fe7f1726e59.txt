diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index e0e4425257..c316c92766 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -423,11 +423,10 @@ public void next( EdgeIteratorState edge, int index )
                 name = edge.getName();
                 annotation = encoder.getAnnotation(flags, tr);
 
-                if ((prevName == null) && (!isRoundabout))
-                // very first instruction (if not in Roundabout)
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
                     int sign = Instruction.CONTINUE_ON_STREET;
-                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()), 0);
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                     ways.add(prevInstruction);
                     prevName = name;
                     prevAnnotation = annotation;
@@ -440,10 +439,8 @@ public void next( EdgeIteratorState edge, int index )
                         if (!prevInRoundabout) //just entered roundabout
                         {
                             int sign = Instruction.USE_ROUNDABOUT;
-                            prevInstruction = new RoundaboutInstruction(sign, name, annotation,
-                                    new PointList(10, nodeAccess.is3D()), 0);
-                            ways.add(prevInstruction);
-
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                                                annotation, new PointList(10, nodeAccess.is3D()));
                             if (prevName != null)
                             {
                                 // previous orientation is last orientation before entering roundabout
@@ -454,13 +451,16 @@ public void next( EdgeIteratorState edge, int index )
                                 double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                                 orientation = ac.alignOrientation(prevOrientation, orientation);
                                 double delta = (orientation - prevOrientation);
-                                prevInstruction = ((RoundaboutInstruction) prevInstruction).setDirOfRotation(delta);
+                                roundaboutInstruction.setDirOfRotation(delta);
 
                             } else // first instructions is roundabout instruction
                             {
                                 prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                                 prevName = name;
+                                prevAnnotation = annotation;
                             }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
                         }
 
                         // Add passed exits to instruction. There is an exit if there are
@@ -470,25 +470,26 @@ public void next( EdgeIteratorState edge, int index )
                         edgeIter.next();
                         if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNr();}
 
-                    } else if (prevInRoundabout){ //previously in roundabout but not anymore
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
+                    {
 
                         prevInstruction.setName(name);
 
                         // calc angle between roundabout entrance and exit
                         double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
                         orientation = ac.alignOrientation(prevOrientation, orientation);
-                        double delta = (orientation - prevOrientation);
-                        prevInstruction.setRadian(delta);
+                        double deltaInOut = (orientation - prevOrientation);
 
                         // calculate direction of exit turn to determine direction of rotation
                         // right turn == counterclockwise and vice versa
                         double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                         orientation = ac.alignOrientation(recentOrientation, orientation);
-                        delta = (orientation - recentOrientation);
+                        double deltaOut = (orientation - recentOrientation);
 
                         prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                            .setRadian(deltaInOut)
                             .setContinuedStreet(!Helper.isEmpty(name) && (prevName.equals(name)))
-                            .setDirOfRotation(delta)
+                            .setDirOfRotation(deltaOut)
                             .setFinished();
 
                         prevName = name;
@@ -532,8 +533,7 @@ public void next( EdgeIteratorState edge, int index )
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-                        prevInstruction = new Instruction(sign, name, annotation,
-                                                          new PointList(10, nodeAccess.is3D()), delta);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()) );
                         ways.add(prevInstruction);
                         prevName = name;
                         prevAnnotation = annotation;
@@ -542,7 +542,8 @@ public void next( EdgeIteratorState edge, int index )
 
                 updatePointsAndInstruction(edge, wayGeo);
 
-                if (wayGeo.getSize() <= 2) {
+                if (wayGeo.getSize() <= 2)
+                {
                     doublePrevLat = prevLat;
                     doublePrevLong = prevLon;
                 }
@@ -565,7 +566,7 @@ public void next( EdgeIteratorState edge, int index )
                         double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
                         orientation = ac.alignOrientation(prevOrientation, orientation);
                         double delta = (orientation - prevOrientation);
-                        prevInstruction.setRadian(delta);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
 
                     }
                     ways.add(new FinishInstruction(nodeAccess, adjNode));
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index 78de314c35..b59f453b7b 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -33,8 +33,7 @@ public FinishInstruction( final double lat, final double lon, final double ele )
             {
                 add(lat, lon, ele);
             }
-        },
-        0);
+        });
     }
 
     public FinishInstruction( NodeAccess nodeAccess, int node )
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index d43ae6465d..c67046a81e 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,8 +17,10 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
@@ -48,13 +50,12 @@
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl, double radian)
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
         this.sign = sign;
         this.name = name;
         this.points = pl;
         this.annotation = ia;
-        this.radian = radian;
     }
 
     public InstructionAnnotation getAnnotation()
@@ -70,11 +71,6 @@ public int getSign()
         return sign;
     }
 
-    public void changeSing(int newSign)
-    {
-        this.sign = newSign;
-    }
-
     public String getName()
     {
         return name;
@@ -85,14 +81,14 @@ public void setName(String name)
         this.name = name;
     }
 
-    public double getRadian()
+    public Map<String,Object> getExtraInfo()
     {
-        return radian;
+        return Collections.<String, Object>emptyMap();
     }
 
-    public void setRadian(double radian)
+    public void setExtraInfo(String key, Object value)
     {
-        this.radian = radian;
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
     }
 
     public Instruction setDistance( double distance )
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 59b8beb890..76accba987 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -85,6 +85,7 @@ public int size()
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfo());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index e45ae7c1d1..ef1cb1e93d 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -1,28 +1,34 @@
 package com.graphhopper.util;
 
+import java.util.HashMap;
+import java.util.Map;
+
 /**
  * Created by jan on 02.02.15.
  *
  * @author jansoe
  */
-public class RoundaboutInstruction extends Instruction {
+public class RoundaboutInstruction extends Instruction
+{
 
     private int exitNr = 0;
     private boolean continuedStreet = false;
-    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, -2 inconsistent
-    private boolean unfinished = true;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean finished = false;
+    private double radian = Double.NaN; 
 
-    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl, double radian) {
-        super(sign, name, ia, pl, radian);
+    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl)
+    {
+        super(sign, name, ia, pl);
     }
 
-    public boolean getContinuedStreet()
+    public boolean istContinuedStreet()
     {
         return continuedStreet;
     }
 
     /**
-    * indicates whether on continues on the same street as before after roundabout
+    * indicates whether one continues on the same street as before after roundabout
     **/
     public RoundaboutInstruction setContinuedStreet(boolean continued)
     {
@@ -30,20 +36,29 @@ public RoundaboutInstruction setContinuedStreet(boolean continued)
         return this;
     }
 
-    public RoundaboutInstruction increaseExitNr() {
+    public RoundaboutInstruction increaseExitNr()
+    {
         this.exitNr += 1;
         return this;
     }
 
+    public RoundaboutInstruction setExitNr(int exitNr)
+    {
+        this.exitNr = exitNr;
+        return this;
+    }
+
     public RoundaboutInstruction setDirOfRotation(double deltaIn)
     {
-        if (clockwise == 0) {
+        if (clockwise == 0)
+        {
             clockwise = deltaIn > 0 ? 1 : -1;
         }
         else
         {
             int clockwise2 = deltaIn > 0 ? 1 : -1;
-            if (clockwise != clockwise2) {
+            if (clockwise != clockwise2)
+            {
                 clockwise = 2;
             }
         }
@@ -52,34 +67,69 @@ public RoundaboutInstruction setDirOfRotation(double deltaIn)
 
     public RoundaboutInstruction setFinished()
     {
-        unfinished = false;
+        finished = true;
         return this;
     }
 
-    public int getExitNr() {
-        if (exitNr == 0) {
+    private int getExitNr()
+    {
+        if (finished && exitNr == 0)
+        {
             throw new IllegalStateException("RoundaboutInstruction must contain exitNr>0");
         }
         return exitNr;
     }
 
-    @Override
-    public double getRadian() {
-        if (Math.abs(clockwise) != 1) {
-            throw new IllegalStateException("Roundabout direction of rotation is not determined");
+    /**
+     * @return radian of angle  -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        }
+        else
+        {
+            double tmpRadian = Math.PI - clockwise*radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
         }
-        double tmpRadian = Math.PI - clockwise*radian;
-        return tmpRadian;
     }
 
+    public RoundaboutInstruction setRadian(double radian)
+    {
+        this.radian = radian;
+        return this;
+    }
+
+
+    @Override
+    public Map<String, Object> getExtraInfo()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>();
+        tmpMap.put("exitNr", getExitNr());
+        double radian = getRadian();
+        if (Double.isNaN(radian))
+        {
+            tmpMap.put("turnAngle", radian);    
+        } else {
+            tmpMap.put("turnAngle", Helper.round(radian, 2));
+        }
+        return tmpMap;
+        
+    }
+    
     @Override
-    public String getTurnDescription(Translation tr) {
+    public String getTurnDescription(Translation tr)
+    {
         String str;
         String streetName = getName();
         int indi = getSign();
         if (indi == Instruction.USE_ROUNDABOUT)
         {
-            if (unfinished)
+            if (!finished)
             {
                 //str = tr.tr("roundaboutEntering");
                 str = tr.tr("roundaboutInstruction", 0);
@@ -91,7 +141,8 @@ public String getTurnDescription(Translation tr) {
                 str = Helper.isEmpty(streetName) ? tr.tr("roundaboutInstruction", getExitNr()) :
                         tr.tr("roundaboutInstructionWithDir", getExitNr(), streetName);
             }
-        } else {
+        } else
+        {
             throw new IllegalStateException(indi + "no Roundabout indication");
         }
         return str;
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index f9c93fac8e..212b08d828 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -37,10 +37,11 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = carManager.getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testFound()
@@ -210,148 +211,154 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
+    private class RoundaboutGraph
+    {
+        public EdgeIteratorState edge2change;
+        boolean clockwise;
+        final public Graph g = new GraphBuilder(carManager).create();
+        final public NodeAccess na = g.getNodeAccess();
+
+        private RoundaboutGraph(boolean clockwise)
+        {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        |
+            //        6
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.351);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge2change = tmpEdge.detach(false);
+            this.clockwise = clockwise;
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
     @Test
     public void testCalcInstructionsRoundabout()
     {
-        final AngleCalc ac = new AngleCalc();
-        EdgeIteratorState tmpEdge, edge2change;
-        EncodingManager carManager = new EncodingManager("CAR");
-
-        // counterclockwise roundabout
-        //
-        //         8
-        //         |
-        //         5
-        //       /  \
-        //  1 - 2    4 - 7
-        //       \  /
-        //        3
-        //        |
-        //        6
-
-        Graph g = new GraphBuilder(carManager).create();
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(1, 52.514321,13.34826);
-        na.setNode(2, 52.514432,13.349032);
-        na.setNode(3, 52.513857,13.350255);
-        na.setNode(4, 52.514536,13.351178);
-        na.setNode(5, 52.51502, 13.349333);
-        na.setNode(6, 52.513322,13.350363);
-        na.setNode(7, 52.514562,13.351886);
-        na.setNode(8, 52.51545, 13.348024);
-
-        tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-        tmpEdge = g.edge(2, 3, 5, false).setName("2-3");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(3, 4, 5, false).setName("3-4");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(4, 5, 5, false).setName("4-5");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(5, 2, 5, false).setName("5-2");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
-        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
-        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
-        edge2change = tmpEdge.detach(false);
-
-        double inOrientation = ac.calcOrientation(na.getLat(1), na.getLon(1), na.getLat(2), na.getLon(2));
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         // Test instructions
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "Continue onto MainStreet",
-                                    "Enter roundabout and use exit 3 in direction 5-8",
-                                    "Finish!"),
-                     tmpList);
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "Enter roundabout and use exit 3 in direction 5-8",
+                        "Finish!"),
+                tmpList);
         // Test Radian
-        double outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
-        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
-        double delta = (inOrientation - outOrientation);
-        delta = Math.PI - delta;
-        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
 
         // case of continuing a street through a roundabout
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
         wayList = p.calcInstructions(tr);
         tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "Continue onto MainStreet",
-                                    "Enter roundabout and use exit 2 in direction MainStreet",
-                                    "Finish!"),
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "Enter roundabout and use exit 2 in direction MainStreet",
+                        "Finish!"),
                 tmpList);
         // Test Radian
-        outOrientation = ac.calcOrientation(na.getLat(4), na.getLon(4), na.getLat(7), na.getLon(7));
-        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
-        delta = (inOrientation - outOrientation);
-        delta = Math.PI - delta;
-        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
-
-        // case with one edge being not an exit
-        edge2change.setFlags(encoder.setBool(edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
-        wayList = p.calcInstructions(tr);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "Continue onto MainStreet",
+        delta = rg.getAngle(1, 2, 4, 7);
+        instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Enter roundabout and use exit 3 in direction 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
                         "Enter roundabout and use exit 2 in direction 5-8",
                         "Finish!"),
                 tmpList);
         // Test Radian
-        outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
-        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
-        delta = (inOrientation - outOrientation);
-        delta = Math.PI - delta;
-        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
-
-
-
-        // clockwise roundabout
-        //
-        //         8
-        //         |
-        //         5
-        //       /  \
-        //  1 - 2    4 - 7
-        //       \  /
-        //        3
-        //        |
-        //        6
-
-        g = new GraphBuilder(carManager).create();
-        na = g.getNodeAccess();
-        na.setNode(1, 52.514321,13.34826);
-        na.setNode(2, 52.514432,13.349032);
-        na.setNode(3, 52.513857,13.350255);
-        na.setNode(4, 52.514536,13.351178);
-        na.setNode(5, 52.51502, 13.349333);
-        na.setNode(6, 52.513322,13.350363);
-        na.setNode(7, 52.514562,13.351886);
-        na.setNode(8, 52.51545, 13.348024);
-
-        tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-        tmpEdge = g.edge(2, 5, 5, false).setName("2-3");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(5, 4, 5, false).setName("3-4");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(4, 3, 5, false).setName("4-5");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(3, 2, 5, false).setName("5-2");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
-        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
-        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
-
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
-        wayList = p.calcInstructions(tr);
-        tmpList = pick("text", wayList.createJson());
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        RoundaboutGraph rg = new RoundaboutGraph(true);
+        System.out.println(rg.clockwise);
+
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList( "Continue onto MainStreet",
                         "Enter roundabout and use exit 1 in direction 5-8",
                         "Finish!"),
                 tmpList);
         // Test Radian
-        outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
-        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
-        delta = (inOrientation - outOrientation);
-        delta = Math.PI + delta;
-        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index fd8c6225d9..7bec24432f 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -337,6 +337,51 @@ public void testInstructionsWithTimeAndPlace()
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                                                                 new InstructionAnnotation(0, ""), pl)
+                                          .setDirOfRotation(-0.1)
+                                          .setRadian(-Math.PI+1)
+                                          .setExitNr(2)  
+                                          .setFinished();  
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);        
+        assertEquals("Enter roundabout and use exit 2 in direction streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turnAngle"), 0.01);
+        assertEquals("2", json.get("exitNr").toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNr(2)
+                .setFinished();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("Enter roundabout and use exit 2 in direction streetname", json.get("text").toString());
+        assertEquals("NaN", json.get("turnAngle").toString());
+    }
+    
     @Test
     public void testCreateGPXWithEle()
     {
@@ -373,15 +418,15 @@ public void testCreateGPX()
         PointList pl = new PointList();
         pl.add(49.942576, 11.580384);
         pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl, 0).setDistance(240).setTime(15000));
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
 
         pl = new PointList();
         pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl, 1.5).setDistance(25).setTime(4000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
 
         pl = new PointList();
         pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl, 1.5).setDistance(25).setTime(3000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
         instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
 
         List<GPXEntry> result = instructions.createGPXList();
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 3be86ce716..f65170813b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -35,8 +35,8 @@ public void testCalcAzimuthAndGetDirection()
         
         PointList nextPl = new PointList();
         nextPl.add(49.942, 11.582);
-        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl, 0);
-        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl, 0);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
 
         assertEquals(270, currI.calcAzimuth(nextI), .1);
         assertEquals("W", currI.calcDirection(nextI));
@@ -44,7 +44,7 @@ public void testCalcAzimuthAndGetDirection()
         PointList p2 = new PointList();
         p2.add(49.942, 11.580);
         p2.add(49.944, 11.582);
-        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2, 0);
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
 
         assertEquals(45, i2.calcAzimuth(null), .1);
         assertEquals("NE", i2.calcDirection(null));
@@ -52,7 +52,7 @@ public void testCalcAzimuthAndGetDirection()
         PointList p3 = new PointList();
         p3.add(49.942, 11.580);
         p3.add(49.944, 11.580);
-        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3, 0);
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
 
         assertEquals(0, i3.calcAzimuth(null), .1);
         assertEquals("N", i3.calcDirection(null));
@@ -60,13 +60,13 @@ public void testCalcAzimuthAndGetDirection()
         PointList p4 = new PointList();
         p4.add(49.940, 11.580);
         p4.add(49.920, 11.586);
-        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4, 0);
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
 
         assertEquals("S", i4.calcDirection(null));
 
         PointList p5 = new PointList();
         p5.add(49.940, 11.580);
-        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5, 0);
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
 
         assertTrue(Double.isNaN(i5.calcAzimuth(null)));
         assertEquals("", i5.calcDirection(null));
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..bf7898df6a 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -116,14 +116,16 @@ paths[0].instructions[0].text                 | A description what the user has
 paths[0].instructions[0].distance             | The distance for this instruction, in meter
 paths[0].instructions[0].time                 | The duration for this instruction, in ms
 paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
 paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exitNr               | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turnAngle            | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is NaN if direction of rotation is undefined.
 
 
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -171,6 +173,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 821aba3064..c1445d9616 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -212,7 +212,7 @@ public GHResponse route( GHRequest request )
                         }
 
                         // TODO way and payment type
-                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL, 0).
+                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
                                 setDistance(instDist).setTime(instTime);
                         il.add(instr);
                     }
