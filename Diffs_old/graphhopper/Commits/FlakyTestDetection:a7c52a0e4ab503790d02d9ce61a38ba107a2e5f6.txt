diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index a30f468cb3..e82b2f023b 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -226,7 +226,7 @@ public double getWeight() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
-    void setReverseEdge(EdgeIteratorState reverseEdge) {
+    public void setReverseEdge(EdgeIteratorState reverseEdge) {
         this.reverseEdge = reverseEdge;
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 45955d9b96..6904e8ec9e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -18,16 +18,26 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.FluentIterable;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
 
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.temporal.ChronoUnit;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Spliterators;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 final class GraphExplorer {
 
@@ -37,68 +47,90 @@
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
     private final PtTravelTimeWeighting weighting;
+    private final PointList extraNodes;
+    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
+    private final Graph graph;
+    private final boolean walkOnly;
+    private final boolean profileQuery;
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse) {
+
+    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, boolean profileQuery) {
+        this.graph = graph;
         this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
         this.flagEncoder = flagEncoder;
         this.weighting = weighting;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
+        this.extraNodes = extraNodes;
+        this.extraEdges = extraEdges;
+        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), (VirtualEdgeIteratorState) extraEdge.detach(true));
+        }
+        this.walkOnly = walkOnly;
+        this.profileQuery = profileQuery;
+    }
+
+    Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
+        final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
+        return Stream.concat(
+                label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
+                extraEdges.stream());
     }
 
-    Iterable<EdgeIteratorState> exploreEdgesAround(Label label) {
-        return new Iterable<EdgeIteratorState>() {
+    Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+        return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
+            boolean foundEnteredTimeExpandedNetworkEdge = false;
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
             @Override
-            public Iterator<EdgeIteratorState> iterator() {
-                return new Iterator<EdgeIteratorState>() {
-                    boolean foundEnteredTimeExpandedNetworkEdge = false;
-
-                    @Override
-                    public boolean hasNext() {
-                        while(edgeIterator.next()) {
-                            final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-                            if (!isValidOn(edgeIterator, label.currentTime)) {
-                                continue;
-                            }
-                            if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
-                                continue;
-                            }
-                            if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
-                                continue;
-                            }
-                            if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
+            public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
+                while (edgeIterator.next()) {
+                    final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
+                    if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
+                        continue;
+                    }
+                    if (profileQuery && (edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
+                        continue;
+                    }
+                    if (!isValidOn(edgeIterator, label.currentTime)) {
+                        continue;
+                    }
+                    if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
+                        continue;
+                    }
+                    if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
+                        continue;
+                    }
+                    if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
+                        continue;
+                    }
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
+                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
+                            continue;
+                        } else {
+                            if (foundEnteredTimeExpandedNetworkEdge) {
                                 continue;
+                            } else {
+                                foundEnteredTimeExpandedNetworkEdge = true;
                             }
-                            if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
-                                    continue;
-                                } else {
-                                    if (foundEnteredTimeExpandedNetworkEdge) {
-                                        continue;
-                                    } else {
-                                        foundEnteredTimeExpandedNetworkEdge = true;
-                                    }
-                                }
-                            } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
-                                    continue;
-                                }
-                            }
-                            return true;
                         }
-                        return false;
-                    }
-
-                    @Override
-                    public EdgeIteratorState next() {
-                        return edgeIterator;
+                    } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
+                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
+                            continue;
+                        }
                     }
-                };
+                    action.accept(edgeIterator);
+                    return true;
+                }
+                return false;
             }
-        };
+
+
+        }, false);
     }
 
     long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
@@ -149,4 +181,19 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         }
     }
 
+    public EdgeIteratorState getEdgeIteratorState(int edge, int adjNode) {
+        if (edge == -1) {
+            return extraEdges.iterator().next();
+        } else {
+            return graph.getEdgeIteratorState(edge, adjNode);
+        }
+    }
+
+    public NodeAccess getNodeAccess() {
+        return graph.getNodeAccess();
+    }
+
+    public Graph getGraph() {
+        return graph;
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 996923f85a..b297c4a215 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -22,6 +22,7 @@
 import com.graphhopper.*;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
@@ -37,6 +38,7 @@
 import java.time.format.DateTimeParseException;
 import java.util.*;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import java.util.zip.ZipFile;
 
 import static com.graphhopper.util.Parameters.PT.PROFILE_QUERY;
@@ -93,14 +95,18 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
+        private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        private final PointList extraNodes = new PointList();
+        private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
         private final QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+        private GraphExplorer graphExplorer;
 
         RequestHandler(GHRequest request) {
             maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, Integer.MAX_VALUE);
             profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
-            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, false);
+            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
             limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
             final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
             try {
@@ -110,8 +116,8 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             }
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Double.MAX_VALUE);
-            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
+            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 1000.0);
+            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, profileQuery ? -1 : Double.MAX_VALUE);
             weighting = createPtTravelTimeWeighting(flagEncoder, arriveBy, walkSpeedKmH);
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
@@ -124,27 +130,76 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         GHResponse route() {
             StopWatch stopWatch = new StopWatch().start();
 
+            ArrayList<QueryResult> allQueryResults = new ArrayList<>();
+
             QueryResult source = findClosest(enter, 0);
             QueryResult dest = findClosest(exit, 1);
+            allQueryResults.add(source);
+            allQueryResults.add(dest);
             queryGraph.lookup(Arrays.asList(source, dest)); // modifies queryGraph, source and dest!
 
             PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
+            if (profileQuery) {
+                substitutePointWithVirtualNode(0, false, enter, allQueryResults);
+                substitutePointWithVirtualNode(1, true, exit, allQueryResults);
+            }
+
             int startNode;
             int destNode;
             if (arriveBy) {
-                startNode = dest.getClosestNode();
-                destNode = source.getClosestNode();
+                startNode = allQueryResults.get(1).getClosestNode();
+                destNode = allQueryResults.get(0).getClosestNode();
             } else {
-                startNode = source.getClosestNode();
-                destNode = dest.getClosestNode();
+                startNode = allQueryResults.get(0).getClosestNode();
+                destNode = allQueryResults.get(1).getClosestNode();
             }
             List<Label> solutions = findPaths(startNode, destNode);
             parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
             return response;
         }
 
+        private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
+            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), Collections.emptyList(), true, false);
+
+            extraNodes.add(ghPoint);
+
+            int newNode = graphHopperStorage.getNodes() + 1000 + index;
+            final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
+            for (Label stationNode : stationNodes) {
+                final PathWrapper pathWrapper = stationNode.parent.parent != null ?
+                        tripFromLabel.parseSolutionIntoPath(reverse, flagEncoder, translation, graphExplorer, weighting, stationNode.parent, new PointList()) :
+                        new PathWrapper();
+                final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(stationNode.edge,
+                        -1, reverse ? stationNode.adjNode : newNode, reverse ? newNode : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
+                        -1, reverse ? newNode : stationNode.adjNode, reverse ? stationNode.adjNode : newNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
+                final long time = pathWrapper.getTime() / 1000;
+                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setTime(newEdge.getFlags(), time));
+                reverseNewEdge.setFlags(newEdge.getFlags());
+                newEdge.setReverseEdge(reverseNewEdge);
+                newEdge.setDistance(pathWrapper.getDistance());
+                extraEdges.add(newEdge);
+                walkPaths.put(stationNode.adjNode, pathWrapper);
+            }
+
+            final QueryResult virtualNode = new QueryResult(ghPoint.getLat(), ghPoint.getLon());
+            virtualNode.setClosestNode(newNode);
+            allQueryResults.set(index, virtualNode);
+        }
+
+        private List<Label> findStationNodes(GraphExplorer graphExplorer, int node, boolean reverse) {
+            GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, reverse, maxWalkDistancePerLeg, maxTransferDistancePerLeg, false, false, maxVisitedNodesForRequest);
+            final Stream<Label> labels = router.calcLabels(node, -1, initialTime);
+            return labels
+                    .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
+//                    .limit(limitSolutions)
+                    .collect(Collectors.toList());
+        }
+
         private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
             QueryResult source = locationIndex.findClosest(point.lat, point.lon, new EverythingButPt(flagEncoder));
             if (!source.isValid()) {
@@ -155,16 +210,37 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
 
         private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList waypoints) {
             for (Label solution : solutions) {
-                response.add(tripFromLabel.parseSolutionIntoPath(initialTime, arriveBy, flagEncoder, translation, queryGraph, weighting, solution, waypoints));
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(arriveBy, flagEncoder, translation, graphExplorer, weighting, solution);
+                if (profileQuery) {
+                    legs.addAll(0, walkPaths.get(accessNode(solution)).getLegs());
+                    legs.addAll(walkPaths.get(egressNode(solution)).getLegs());
+                }
+                final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
+                // TODO: remove
+                pathWrapper.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+                response.add(pathWrapper);
             }
             response.getAll().sort(Comparator.comparingDouble(PathWrapper::getTime));
         }
 
+        private int accessNode(Label solution) {
+            while(solution.parent.parent != null) {
+                solution = solution.parent;
+            }
+            return solution.adjNode;
+        }
+
+        private int egressNode(Label solution) {
+            return solution.parent.adjNode;
+        }
+
         private List<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy);
+            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false, profileQuery);
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
-            List<Label> solutions = router.calcPaths(startNode, destNode, initialTime)
+            final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime);
+            List<Label> solutions = labels
+                    .filter(current -> destNode == current.adjNode)
                     .limit(limitSolutions)
                     .collect(Collectors.toList());
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index ac134894b9..9268ed86f9 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -93,7 +93,7 @@ public String toString() {
         return adjNode + " " + Instant.ofEpochMilli(currentTime) + " " + nTransfers + " " + nWalkDistanceConstraintViolations + " " +  (departureTime != null ? Instant.ofEpochMilli(departureTime) : "");
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, GraphExplorer graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
@@ -111,7 +111,8 @@ public Transition next() {
                             ++i;
                             return new Transition(label, null);
                         } else {
-                            EdgeIteratorState edgeIteratorState = label.parent == null ? null : graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
+                            EdgeIteratorState edgeIteratorState = label.parent == null ? null :
+                                    graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
                             Transition transition;
                             if (reverseEdgeFlags) {
                                 transition = new Transition(label, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index de91b2446d..2945eabf13 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -21,7 +21,6 @@
 import com.google.common.collect.SetMultimap;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
 import java.util.*;
@@ -73,28 +72,11 @@
         fromMap = HashMultimap.create();
     }
 
-    Stream<Label> calcPaths(int from, int to, Instant startTime) {
+    Stream<Label> calcLabels(int from, int to, Instant startTime) {
         this.startTime = startTime.toEpochMilli();
-        final Stream<Label> labels = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false)
+        return StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false)
                 .limit(maxVisitedNodes)
                 .peek(label -> visitedNodes++);
-        final Spliterator<Label> spliterator = labels.spliterator();
-        return StreamSupport.stream(new Spliterators.AbstractSpliterator<Label>(0, 0) {
-            Label current = null;
-            List<Label> solutions = new ArrayList<>();
-            @Override
-            public boolean tryAdvance(Consumer<? super Label> action) {
-                while (spliterator.tryAdvance(label -> current = label)) {
-                    if (to == current.adjNode) {
-                        action.accept(current);
-                        solutions.add(current);
-                        return true;
-                    }
-                }
-                return false;
-            }
-        }, false)
-                .filter(me -> me.nWalkDistanceConstraintViolations <= 0);
     }
 
     private class MultiCriteriaLabelSettingSpliterator extends Spliterators.AbstractSpliterator<Label> {
@@ -121,7 +103,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
             } else {
                 Label label = fromHeap.poll();
                 action.accept(label);
-                for (EdgeIteratorState edge : explorer.exploreEdgesAround(label)) {
+                explorer.exploreEdgesAround(label).forEach(edge -> {
                     GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
                     long nextTime;
                     if (reverse) {
@@ -158,13 +140,16 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                         }
                         fromHeap.add(nEdge);
                     }
-                }
+                });
                 return true;
             }
         }
     }
 
     private boolean isNotDominatedByAnyOf(Label me, Set<Label> sptEntries) {
+        if (me.nWalkDistanceConstraintViolations > 0) {
+            return false;
+        }
         for (Label they : sptEntries) {
             if (dominates(they, me)) {
                 return false;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index c5f16609fc..708383f909 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -44,11 +44,24 @@
 
 class TripFromLabel {
 
-    PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagEncoder encoder, Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
+        return createPathWrapper(tr, waypoints, legs);
+    }
+
+    PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
+        if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
+            final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
+            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).departureTime.getTime() - (accessLeg.arrivalTime.getTime() - accessLeg.departureTime.getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).departureTime));
+        }
+        if (legs.size() > 1 && legs.get(legs.size()-1) instanceof Trip.WalkLeg) {
+            final Trip.WalkLeg egressLeg = (Trip.WalkLeg) legs.get(legs.size()-1);
+            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size()-2).arrivalTime, egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size()-2).arrivalTime.getTime() + (egressLeg.arrivalTime.getTime() - egressLeg.departureTime.getTime()))));
+        }
+
         PathWrapper path = new PathWrapper();
         path.setWaypoints(waypoints);
 
-        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         path.getLegs().addAll(legs);
 
         final InstructionList instructions = getInstructions(tr, path.getLegs());
@@ -57,10 +70,9 @@ PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagE
         for (Instruction instruction : instructions) {
             pointsList.add(instruction.getPoints());
         }
-        path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
         path.setPoints(pointsList);
         path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+        path.setTime((legs.get(legs.size()-1).arrivalTime.toInstant().toEpochMilli() - legs.get(0).departureTime.toInstant().toEpochMilli()));
         path.setNumChanges((int) path.getLegs().stream()
                 .filter(l -> l instanceof Trip.PtLeg)
                 .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
@@ -86,7 +98,7 @@ PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagE
         return path;
     }
 
-    private List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, Label solution) {
+    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -100,10 +112,6 @@ PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagE
 
         final List<List<Label.Transition>> partitions = getPartitions(transitions);
         final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
-        if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
-            final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
-            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).departureTime.getTime() - (accessLeg.arrivalTime.getTime() - accessLeg.departureTime.getTime())) , accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).departureTime));
-        }
         return legs;
     }
 
@@ -125,7 +133,7 @@ PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagE
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -225,7 +233,7 @@ void finish() {
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
-    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, Weighting weighting, Translation tr) {
+    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, GraphExplorer graph, Weighting weighting, Translation tr) {
         if (path.size() <= 1) {
             return Collections.emptyList();
         }
@@ -273,7 +281,7 @@ void finish() {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph.getGraph(), weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i=1; i<path.size(); i++) {
                 EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 674c060fca..676500e16b 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -76,12 +76,11 @@ public void testDepartureTimeOfAccessLeg() {
         ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
 
         GHResponse response = graphHopper.route(ghRequest);
-        final PathWrapper mixedPath = response.getAll().get(1);
 
-        assertThat(mixedPath.getLegs().get(0).departureTime.toInstant().atZone(zoneId).toLocalTime())
+        assertThat(response.getAll().get(0).getLegs().get(0).departureTime.toInstant().atZone(zoneId).toLocalTime())
                 .isEqualTo("06:41:06");
-        assertThat(mixedPath.getLegs().get(0).arrivalTime.toInstant())
-                .isEqualTo(mixedPath.getLegs().get(1).departureTime.toInstant());
+        assertThat(response.getAll().get(0).getLegs().get(0).arrivalTime.toInstant())
+                .isEqualTo(response.getAll().get(0).getLegs().get(1).departureTime.toInstant());
     }
 
 }
