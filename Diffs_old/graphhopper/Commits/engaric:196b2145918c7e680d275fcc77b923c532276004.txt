diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
index 676b4938c3..f2cca8dfe2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
@@ -20,9 +20,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        
-        if((wayType & bitMask) == bitMask)
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
index b5b796683f..b621e7474b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
@@ -20,8 +20,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) == bitMask))
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
index 897d0b4348..74bfed8399 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
@@ -22,9 +22,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        
-        if((wayType & bitMask) == bitMask)
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
new file mode 100644
index 0000000000..c6e303c645
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
@@ -0,0 +1,96 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class PriorityWithAvoidancesWeightingTest {
+	@Mock
+	FlagEncoder encoder;
+	
+	@Mock
+	EdgeIteratorState edge;
+	
+	@Before
+	public void configureMocks() {
+		MockitoAnnotations.initMocks(this);
+		configureSpeedsAndPriority();
+	}
+
+	@Test
+	public void testSingleAvoidWhenMatches() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testSingleAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteIsExactMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+
+	/**
+	 * Sets up :-
+	 *  max speed = 100
+	 *  edge speed = 50
+	 *  edge priority = 10
+	 */
+	private void configureSpeedsAndPriority() {
+		when(encoder.getMaxSpeed()).thenReturn(100D);
+		when(encoder.getSpeed(anyLong())).thenReturn(50D);
+		when(encoder.getDouble(anyLong(), eq(101))).thenReturn(10D);
+	}
+
+}
