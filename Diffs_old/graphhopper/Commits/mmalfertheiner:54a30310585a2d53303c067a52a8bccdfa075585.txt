diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 6460803985..0803faf299 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -419,19 +419,21 @@ private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean re
         if (!reverse)
         {
             // use weighted mean so that longer incline infuences speed more than shorter
-            double fwdFaster = 1 + 2 * keepIn(decElevation, 0, 0.2);
-            fwdFaster = fwdFaster * fwdFaster;
+            double fwdFaster = 1 + 30 * keepIn(decElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
             double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
             adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         } else {
-            double fwdFaster = 1 + 2 * keepIn(incElevation, 0, 0.2);
-            fwdFaster = fwdFaster * fwdFaster;
+            double fwdFaster = 1 + 30 * keepIn(incElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
             double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
             adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         }
-        System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation + ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage);
+        System.out.println("NEW SPEED: " + Helper.round2(adjustedSpeed) + ", SPEED: " + speed + ", INC ELE: " + incElevation +
+                ", DEC ELE: " + decElevation + ", PERCENTAGE: " + incDistPercentage +
+                ", INC DIST: " + incDist2DSum + ", DEC DIST: " + decDist2DSum);
 
         return adjustedSpeed;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
index 34c683a5e2..0105ac347a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeGenericFlagEncoder.java
@@ -694,29 +694,9 @@ public void applyWayTags(OSMWay way, EdgeIteratorState edge) {
             double decEleSum = 0, decDist2DSum = 0;
             double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
             double prevEle = pl.getElevation(0);
-            double fullDist2D = edge.getDistance();
+            double fullDist2D = 0;
 
-            if (Double.isInfinite(fullDist2D))
-            {
-                System.err.println("infinity distance? for way:" + way.getId());
-                return;
-            }
-            // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
-            if (fullDist2D < 1)
-                return;
-
-            /*double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
-            if (eleDelta >= 0)
-            {
-                incEleSum = eleDelta;
-                incDist2DSum = fullDist2D;
-            } else if (eleDelta < 0)
-            {
-                decEleSum = -eleDelta;
-                decDist2DSum = fullDist2D;
-            }*/
-
-//            // get a more detailed elevation information, but due to bad SRTM data this does not make sense now.
+            // get a more detailed elevation information, but due to bad SRTM data this does not make sense now.
             for (int i = 1; i < pl.size(); i++)
             {
                 double lat = pl.getLatitude(i);
@@ -742,6 +722,16 @@ public void applyWayTags(OSMWay way, EdgeIteratorState edge) {
             // Then calculate a factor which decreases or increases the speed.
             // Do this via a simple quadratic equation where y(0)=1 and y(0.3)=1/4 for incline and y(0.3)=2 for decline
 
+            if (Double.isInfinite(fullDist2D))
+            {
+                System.err.println("infinity distance? for way:" + way.getId());
+                return;
+            }
+
+            // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
+            if (fullDist2D < 1)
+                return;
+
             fwdIncline = incDist2DSum > 1 ? (incEleSum / incDist2DSum) * 100 : 0;
             fwdDecline = decDist2DSum > 1 ? (decEleSum / decDist2DSum) * 100 : 0;
             inclineDistancePercentage = keepIn(incDist2DSum / fullDist2D * 100, 0, 100);
diff --git a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
index 4bbeef3a4f..0706ca4cfd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DynamicWeighting.java
@@ -80,7 +80,7 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
         if (penalizeEdge)
             time += heading_penalty;
 
-        return time / (0.5 + getUserPreference(edgeState));
+        return time / (Math.pow(0.5 + getUserPreference(edgeState), 2));
     }
 
     private double getUserPreference(EdgeIteratorState edgeState) {
@@ -98,7 +98,7 @@ else if(wayType >= 10 && wayType <= 12) {
 
             priority = PriorityCode.AVOID_IF_POSSIBLE.getValue();
 
-            if(incDist2DSum > 50 && incElevation > 0.02) {
+            if(incDist2DSum > 10 && incElevation > 0.02) {
                 priority = PriorityCode.AVOID_AT_ALL_COSTS.getValue();
                 //System.out.println(wayType + ": elevation: " + incElevation + ": " + incDist2DSum);
 
@@ -106,8 +106,10 @@ else if(wayType >= 10 && wayType <= 12) {
                     priority = PriorityCode.WORST.getValue();
                 }
             }
-        } else if (wayType >= 1 && wayType <= 6){
+        } else if (wayType >= 2 && wayType <= 6){
             priority = PriorityCode.PREFER.getValue();
+        } else if (wayType == 15){
+            priority = PriorityCode.WORST.getValue();
         }
 
         return priority / PriorityCode.BEST.getValue();
@@ -128,15 +130,15 @@ private double adjustSpeed(double speed, EdgeIteratorState edgeState, boolean re
         if (!reverse)
         {
             // use weighted mean so that longer incline infuences speed more than shorter
-            double fwdFaster = 1 + 2 * keepIn(decElevation, 0, 0.2);
-            fwdFaster = fwdFaster * fwdFaster;
-            double fwdSlower = 1 - 3 * keepIn(incElevation, 0, 0.33);
+            double fwdFaster = 1 + 30 * keepIn(decElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
+            double fwdSlower = 1 - 5 * keepIn(incElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
             adjustedSpeed = keepIn(speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         } else {
-            double fwdFaster = 1 + 2 * keepIn(incElevation, 0, 0.2);
-            fwdFaster = fwdFaster * fwdFaster;
-            double fwdSlower = 1 - 3 * keepIn(decElevation, 0, 0.33);
+            double fwdFaster = 1 + 30 * keepIn(incElevation, 0, 0.1);
+            fwdFaster = Math.sqrt(fwdFaster);
+            double fwdSlower = 1 - 5 * keepIn(decElevation, 0, 0.2);
             fwdSlower = fwdSlower * fwdSlower;
             adjustedSpeed = keepIn(speed * (fwdSlower * decDist2DSum + fwdFaster * incDist2DSum) / edgeState.getDistance(), BikeGenericFlagEncoder.PUSHING_SECTION_SPEED / 2, 50);
         }
