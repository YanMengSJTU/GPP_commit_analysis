diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 49cc8da521..d3264e5372 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -7,6 +7,7 @@
  * dardin88, instructions improved
  * lmar, improved instructions information
  * fredao, translations
+ * jansoe, algorithm improvements
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
  * karussell, lead developer
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index d55c8f21c2..d360707593 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -32,8 +32,7 @@
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
  * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * See
- * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
+ * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
@@ -50,7 +49,8 @@
  * or could we even use this three phase approach?
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
- * @author Peter Karich, jansoe
+ * @author Peter Karich
+ * @author jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
@@ -71,7 +71,7 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
         BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
-        defaultApprox.setDistanceCalc(new  DistancePlaneProjection());
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
         setApproximation(defaultApprox);
     }
 
@@ -210,7 +210,7 @@ boolean fillEdgesTo()
     }
 
     private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
-                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -224,11 +224,11 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            float alreadyVisitedWeight =(float) (weighting.calcWeight(iter, reverse, currEdge.edge)
-                                                 + currEdge.weightOfVisitedPath);
+            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath);
             if (Double.isInfinite(alreadyVisitedWeight))
-                    continue;
-            
+                continue;
+
             AStarEdge ase = shortestWeightMap.get(traversalId);
             if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
@@ -240,7 +240,7 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
                     shortestWeightMap.put(traversalId, ase);
                 } else
                 {
-                    assert(ase.weight > estimationFullDist): "Inconsistent distance estimate";
+                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
                     prioQueueOpenSet.remove(ase);
                     ase.edge = iter.getEdge();
                     ase.weight = estimationFullDist;
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index 3bca270ac8..7057fe18c3 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -20,8 +20,8 @@
 import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.routing.util.WeightApproximator;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.Helper;
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
@@ -44,47 +44,16 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
         } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
         {
             AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
-                                                            opts.getTraversalMode());
-            String approximation = opts.getHints().get(AlgorithmOptions.ASTAR_BI + ".approximation",
-                                                       "BeelineSimplification");
-            if (approximation == "BeelineSimplification") {
-                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStarBi.nodeAccess, aStarBi.weighting);
-                approx.setDistanceCalc(new DistancePlaneProjection());
-                aStarBi.setApproximation(approx);
-            }
-            else if (approximation == "BeelineAccurate")
-            {
-                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStarBi.nodeAccess, aStarBi.weighting);
-                approx.setDistanceCalc(new DistanceCalcEarth());
-                aStarBi.setApproximation(approx);
-            } else
-            {
-                throw new IllegalArgumentException("Approximation " + approximation + " not found in " + getClass().getName());
-            }
-
+                    opts.getTraversalMode());
+            aStarBi.setApproximation(getApproximation(opts, g.getNodeAccess()));
             return aStarBi;
         } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
         {
             return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
         } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
         {
-            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(),opts.getTraversalMode());
-            String approximation = opts.getHints().get(AlgorithmOptions.ASTAR + ".approximation",
-                                                       "BeelineSimplification");
-            if (approximation == "BeelineSimplification") {
-                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStar.nodeAccess, aStar.weighting);
-                approx.setDistanceCalc(new DistancePlaneProjection());
-                aStar.setApproximation(approx);
-            }
-            else if (approximation == "BeelineAccurate")
-            {
-                BeelineWeightApproximator approx = new BeelineWeightApproximator(aStar.nodeAccess, aStar.weighting);
-                approx.setDistanceCalc(new DistanceCalcEarth());
-                aStar.setApproximation(approx);
-            } else
-            {
-                throw new IllegalArgumentException("Approximation " + approximation + " not found in " + getClass().getName());
-            }
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            aStar.setApproximation(getApproximation(opts, g.getNodeAccess()));
             return aStar;
         } else
         {
@@ -92,4 +61,24 @@ else if (approximation == "BeelineAccurate")
         }
 
     }
+
+    private WeightApproximator getApproximation( AlgorithmOptions opts, NodeAccess na )
+    {
+        String approxAsStr = opts.getHints().get(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        if ("BeelineSimplification".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_PLANE);
+            return approx;
+
+        } else if ("BeelineAccurate".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_EARTH);
+            return approx;
+        } else
+        {
+            throw new IllegalArgumentException("Approximation " + approxAsStr + " not found in " + getClass().getName());
+        }
+    }
 }
