diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index efbeabd2aa..6fe78eace6 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -57,6 +57,7 @@
     private TIntList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
+    private String profile;
 
     public Path( Graph graph, FlagEncoder encoder )
     {
@@ -174,6 +175,11 @@ public Path setWeight( double w )
         return this;
     }
 
+    public Path setProfile( String profile){
+        this.profile = profile;
+        return this;
+    }
+
     /**
      * Extracts the Path from the shortest-path-tree determined by edgeEntry.
      */
@@ -227,10 +233,6 @@ protected void processEdge( int edgeId, int adjNode )
         double dist = iter.getDistance();
         distance += dist;
         time += calcMillis(dist, iter.getFlags(), false);
-        int wayType = (int) this.encoder.getDouble(iter.getFlags(), DynamicWeighting.WAY_TYPE_KEY);
-
-        System.out.println(wayType + ": dist: " + dist);
-
         addEdge(edgeId);
     }
 
@@ -257,6 +259,24 @@ protected long calcMillis( double distance, long flags, boolean revert )
         return (long) (distance * 3600 / speed);
     }
 
+    protected long calcMillis( EdgeIteratorState edge, boolean revert, SpeedProvider speedProvider) {
+
+        if (revert && !encoder.isBackward(edge.getFlags())
+                || !revert && !encoder.isForward(edge.getFlags()))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(edge.getFlags()) + ", bwd:" + encoder.isBackward(edge.getFlags()));
+
+        double speed = speedProvider.calcSpeed(edge, revert);
+
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
+        return (long) (edge.getDistance() * 3600 / speed);
+    }
+
     /**
      * The callback used in forEveryEdge.
      */
@@ -372,38 +392,33 @@ public void next( EdgeIteratorState eb, int index )
         return points;
     }
 
-    public void updateTime(PMap params){
+    private SpeedProvider initSpeedProvider() {
 
-        time = 0;
-        String profileName = params.get("profile", "");
         ProfileManager profileManager = new ProfileManager(new ProfileRepository());
 
-        if(!profileName.equals(""))
-            profileManager.init(profileName, (BikeGenericFlagEncoder) encoder);
+        if(!profile.equals("")) {
+            profileManager.init(profile, (BikeGenericFlagEncoder) encoder);
+        }
 
-        final SpeedProvider speedProvider = new ProfileSpeedProvider(encoder, profileManager);
+        return new ProfileSpeedProvider(encoder, profileManager);
 
-        forEveryEdge(new EdgeVisitor() {
+    }
 
-            @Override
-            public void next(EdgeIteratorState edgeBase, int index) {
+    public void updateTime(PMap params){
 
-                double speed = speedProvider.calcSpeed(edgeBase, false);
+        time = 0;
+        String profileName = params.get("profile", "");
+        setProfile(profileName);
 
-                if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
-                    throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+        final SpeedProvider speedProvider = initSpeedProvider();
 
-                if (speed == 0)
-                    throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+        forEveryEdge(new EdgeVisitor() {
 
-                double edgeTime = edgeBase.getDistance() / speed * 3600;
+            @Override
+            public void next(EdgeIteratorState edgeBase, int index) {
 
-                // add direction penalties at start/stop/via points
-                boolean penalizeEdge = edgeBase.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, false);
-                if (penalizeEdge)
-                    edgeTime += 300; //pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
+                time += calcMillis(edgeBase, false, speedProvider);
 
-                time += edgeTime;
             }
         });
 
@@ -664,8 +679,13 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
-                long flags = edge.getFlags();
-                prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
+                final SpeedProvider speedProvider = initSpeedProvider();
+                if(speedProvider != null)
+                    prevInstruction.setTime(calcMillis(edge, false, speedProvider) + prevInstruction.getTime());
+                else {
+                    long flags = edge.getFlags();
+                    prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
+                }
             }
         });
 
