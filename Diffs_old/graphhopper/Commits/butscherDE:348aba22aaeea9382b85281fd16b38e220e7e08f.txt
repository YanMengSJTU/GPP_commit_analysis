diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 7ff93c4920..06f9f5a693 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -84,7 +84,6 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
     public boolean isReady(PathMerger pathMerger, Translation translation) {
         this.failOnNumPathsInvalid(this.ghRequest, this.pathList);
 
-        // TODO check if all waypoints have been queried. Respectively: The entry exit points: Are they queried? Do They have to be queried or mustnt they be queried?
         this.altResponse.setWaypoints(getWaypoints());
         this.ghResponse.add(this.altResponse);
         System.out.println(this.pathList.get(0).getNodesInPathOrder().toString());
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
index acf543ba70..f7279f7533 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
@@ -20,15 +20,15 @@ public void sortByGainAscending() {
         Collections.sort(this.candidates);
     }
 
-    private void sortRouteCandidatesToDistanceInROIDescending() {
+    private void sortRouteCandidatesToTimeInROIDescending() {
         Collections.sort(this.candidates, new Comparator<RouteCandidatePolygon>() {
             @Override
             public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
-                double distanceDifference = rc1.getTimeInROI() - rc2.getTimeInROI();
+                double timeDifference = rc1.getTimeInROI() - rc2.getTimeInROI();
                 int output;
-                if (distanceDifference < 0) {
+                if (timeDifference < 0) {
                     output = 1;
-                } else if (distanceDifference == 0) {
+                } else if (timeDifference == 0) {
                     output = 0;
                 } else {
                     output = -1;
@@ -44,7 +44,7 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
 
         final int endOfCandidates = this.candidates.size() - 1;
         paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, false));
-        paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, true));
+        paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements - paths.size(), queryGraph, algorithmOptions, endOfCandidates, true));
 
         return paths;
     }
@@ -68,7 +68,7 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
 
     // Do it in a skyline problem pruning fashion
     public void pruneDominatedCandidateRoutes() {
-        this.sortRouteCandidatesToDistanceInROIDescending();
+        this.sortRouteCandidatesToTimeInROIDescending();
 
         int currentPruningCandidateIndex = 1;
         while (indexInCandidateBounds(currentPruningCandidateIndex)) {
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
index a867c38a22..9c53f4f4df 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
@@ -11,6 +11,7 @@
 import com.graphhopper.util.shapes.Polygon;
 import org.junit.Test;
 
+import javax.management.Query;
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
@@ -27,43 +28,43 @@ private void addTestingCandidates() {
         Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(3, 6, 1, "a", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(2, 3, 1, "b", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(6, 6, 5, "c", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(4, 5, 3, "d", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(8, 4, 6, "e", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(6, 1, 3, "f", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
 
         startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
         this.candidateList.add(new RouteCandidateMocker(7, 1, 6, "g", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
     }
 
     @Test
@@ -124,6 +125,26 @@ private void illegalCandidateNotAdded(RouteCandidateMocker testingCandidate) {
         assertEquals(sizeBeforeAdding, this.candidateList.size());
     }
 
+    @Test
+    public void selfintersectingRouteNotAlsoAdded() {
+        addTestingCandidates();
+
+        RouteCandidateMocker selfintersectingCandidate = createSelfintersectingRouteCandidate();
+        this.candidateList.add(selfintersectingCandidate);
+
+        assertEquals(true, selfintersectingCandidate.isDetourSelfIntersecting(new QueryGraph(this.graphMocker.graph), this.graphMocker.algorithmOptions));
+        assertEquals(1, this.candidateList.getFirstAsPathList(1, new QueryGraph(this.graphMocker.graph), this.graphMocker.algorithmOptions).size());
+    }
+
+    private RouteCandidateMocker createSelfintersectingRouteCandidate() {
+        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit.addEdge(1);
+        detourEntryToDetourExit.addEdge(1);
+        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        return new RouteCandidateMocker(1, 1, 1, "selfintersecting", startToDetourEntry, detourEntryToDetourExit, detourExitToEnd, null);
+    }
+
     class RouteCandidateMocker extends RouteCandidatePolygon {
         final double polygonRouteTime;
         final double roiTime;
