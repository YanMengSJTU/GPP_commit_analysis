diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 081e1a7ab5..e21f549152 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -990,7 +990,7 @@ public GHResponse route(GHRequest request) {
             RoutingTemplate routingTemplate;
             if (ROUND_TRIP.equalsIgnoreCase(algoStr))
                 routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, maxRoundTripRetries);
-            else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
+            else if (ALT_ROUTE.equalsIgnoreCase(algoStr) || KSP.equalsIgnoreCase(algoStr))
                 routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex);
             else
                 routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex);
diff --git a/core/src/main/java/com/graphhopper/routing/Eppstein.java b/core/src/main/java/com/graphhopper/routing/Eppstein.java
deleted file mode 100644
index dac5cc2376..0000000000
--- a/core/src/main/java/com/graphhopper/routing/Eppstein.java
+++ /dev/null
@@ -1,699 +0,0 @@
-package com.graphhopper.routing;
-
-import com.graphhopper.routing.ksp.*;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.Parameters;
-
-import java.util.*;
-
-/**
- * Eppstein's algorithm for computing the K shortest paths between two nodes in a graph.
- *
- * Copyright (C) 2015  Brandon Smock (dr.brandon.smock@gmail.com, GitHub: bsmock)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Created by Brandon Smock on October 5, 2015.
- * Last updated by Brandon Smock on December 24, 2015.
- * Further moditifed by Isaac Johnson to work with GraphHopper on October 14, 2016.
- */
-public class Eppstein implements RoutingAlgorithm {
-
-    private final Graph graph;
-    private final FlagEncoder flagEncoder;
-    private final Weighting weighting;
-    private final TraversalMode traversalMode;
-    private int maxVisitedNodes = Integer.MAX_VALUE;
-    private int visitedNodes;
-    private int K = 1000000;
-
-    public boolean isLoopless() {
-        return false;
-    }
-
-    @Override
-    public String getName() {
-        return Parameters.Algorithms.KSP;
-    }
-
-    @Override
-    public void setMaxVisitedNodes(int numberOfNodes) {
-        this.maxVisitedNodes = numberOfNodes;
-    }
-
-    @Override
-    public int getVisitedNodes() {
-        return visitedNodes;
-    }
-
-    @Override
-    public Path calcPath(int from, int to) {
-        return calcPaths(from, to).get(0);
-    }
-
-    @Override
-    public List<Path> calcPaths(int from, int to) {
-        List<PathKSP> paths = ksp(new GraphKSP(), Integer.toString(from), Integer.toString(to), K);
-        return new ArrayList<Path>();
-    }
-
-    public Eppstein(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-        this.graph = graph;
-        this.flagEncoder = weighting.getFlagEncoder();
-        this.weighting = weighting;
-        this.traversalMode = traversalMode;
-    };
-
-    /**
-     * Computes the K shortest paths (allowing cycles) in a graph from node s to node t in graph G using Eppstein's
-     * algorithm. ("Finding the k Shortest Paths", Eppstein)
-     *
-     * Some explanatory notes about how Eppstein's algorithm works:
-     * - Start with the shortest path in the graph from s to t, which can be calculated using Dijkstra's algorithm.
-     * - The second shortest path must diverge away from this shortest path somewhere along the path at node u, with
-     * edge (u,v) known as a "sidetrack" edge. It then follows the shortest path from v to t.
-     * - In general, let T represent the shortest path tree rooted at target node t, containing for each node v, an edge
-     * (v,w) to the parent of node v (w) along its shortest path to node t.
-     * - All other edges (u,v) in the graph are "sidetrack" edges. In other words, this includes any edge (u,v) for
-     * which node v is not on the shortest path from u to t.
-     * - All paths from s to t can be uniquely represented by the sequence of sidetrack edges that appear in the path.
-     * - All non-sidetrack edges in the path are represented implicitly in the shortest path tree, T.
-     * - All paths from s to t can be represented in a tree, H, where the root node has no sidetrack edges, its children
-     * are all of the possible one sidetrack paths, the children of each of these sidetracks are the paths with a
-     * second sidetrack edge, and so on.
-     * - Each path from s to t corresponds to a path from the root of H to some descendant node in H.
-     * - The tree is a heap, as each additional sidetrack creates a new path whose cost is either the same as or greater
-     * than the cost of its parent path.
-     * - One possible way to find the k shortest paths, then, is to maintain a priority queue of candidate paths where
-     * once a path is pulled from the priority queue, its children in the heap are added to the priority queue.
-     * - Two observations about this heap:
-     *   - Each node in H has at most O(E) children, where E is the number of edges in the graph.
-     *   - If G has looped paths, then this heap is infinite.
-     * - Eppstein's algorithm is basically a scheme for re-organizing this heap so that each heap node has at most 4
-     * children, which is O(1) instead of O(E) - performing potentially much less work for each path found.
-     * - This re-organized heap R has the following form, in terms of the original heap H:
-     *   - For each heap node in H, select its best child, B.
-     *   - This child is known as a "cross edge" child.
-     *   - Child B has N siblings in H.
-     *   - These N siblings are removed from its parent in heap H and are made instead to be descendants of B in heap R.
-     *   - The best child, B, has up to three of its siblings placed as direct children (along with its own best "cross
-     *   edge" child in the original heap H, this yields a total of four possible children in R).
-     *   - Among its sibling-children, one of its children in R is the root of a new binary heap containing all of the
-     *   siblings of B in H that are sidetrack edges directed away from the same node in G.
-     *   - All of the remaining siblings of B in H are placed in a binary heap with B as the root in R.
-     *   - Because this is a binary heap, B has up to two children of this type.
-     *   - Thus, B has at most four children in R. Any node in R that is a "cross-edge" child has up to four children,
-     *   whereas other nodes fall inside binary heaps and are limited to having at most two children.
-     *
-     * @param graph         the graph on which to compute the K shortest paths from s to t
-     * @param from   the starting node for all of the paths
-     * @param to   the ending node for all of the paths
-     * @param K             the number of shortest paths to compute
-     * @return              a list of the K shortest paths from s to t, ordered from shortest to longest
-     */
-    public List<PathKSP> ksp(GraphKSP graph, String from, String to, int K) {
-        /* Compute the shortest path tree, T, for the target node (the shortest path from every node in the graph to the
-            target) */
-        ShortestPathTreeKSP tree;
-        try {
-            tree = DijkstraKSP.shortestPathTree(graph.transpose(), to);
-        } catch (Exception e) {
-            tree = new ShortestPathTreeKSP(to);
-        }
-
-        // Compute the set of sidetrack edge costs
-        HashMap<String,Double> sidetrackEdgeCostMap = computeSidetrackEdgeCosts(graph, tree);
-
-        /* Make indexes to give fast access to these heaps later */
-        // Heap H_out(v) for every node v
-        HashMap<String,EppsteinHeap> nodeHeaps = new HashMap<String, EppsteinHeap>(graph.numNodes());
-        HashMap<String,EppsteinHeap> edgeHeaps = new HashMap<String, EppsteinHeap>(graph.numEdges());
-        // Heap H_T(v) for every node v
-        HashMap<String,EppsteinHeap> outrootHeaps = new HashMap<String, EppsteinHeap>();
-
-        /* COMPUTE EPPSTEIN HEAP, Part 1: Compute sub-heap H_out(v) for each node v.
-            -- H_out(v) is a heap of all of the outgoing sidetrack edges of v. */
-        for (String nodeLabel : graph.getNodes().keySet()) {
-            computeOutHeap(nodeLabel, graph, sidetrackEdgeCostMap, nodeHeaps, edgeHeaps);
-        }
-
-        /* COMPUTE EPPSTEIN HEAP, Part 2: Compute sub-heap H_T(v) for each node v.
-            -- H_T(v) is a heap of all of the "best" sidetrack edges for each node on the shortest path from v to T.
-            -- H_T(v) is computed by adding the lowest cost sidetrack edge of v to heap H_T(nextT(v)),
-            where nextT(v) is the parent node of node v in the shortest path tree rooted at the target node T.
-            -- Therefore, can compute H_T(v) recursively. But instead of a top-down recursion, we will compute each
-            H_T(v) bottom-up, starting with the root node of the tree, T.
-            -- To facilitate bottom-up computation, reverse the edges of the shortest path tree so each node points to
-            its children instead of its parent. */
-        GraphKSP reversedSPT = new GraphKSP();
-        for (DijkstraNodeKSP node: tree.getNodes().values()) {
-            reversedSPT.addEdge(node.getParent(),node.getLabel(),graph.getNode(node.getLabel()).getNeighbors().get(node.getParent()));
-        }
-
-        /* Use a depth-first search from node T to perform the bottom-up computation, computing each H_T(v) given
-            H_T(nextT(v)). */
-        // Create the initial (empty) heap for the root node T to build from.
-        EppsteinArrayHeap rootArrayHeap = new EppsteinArrayHeap();
-        // Perform the DFS (recursively initiating additional depth-first searches for each child)
-        recursiveOutrootHeaps(to, rootArrayHeap, nodeHeaps, outrootHeaps, reversedSPT);
-
-        // Create a virtual/dummy heap that is the root of the overall Eppstein heap. It represents the best path from
-        // the source node to the target node, which does not involve any sidetrack edges.
-        EppsteinHeap hg = new EppsteinHeap(new EdgeKSP(from,from,0));
-
-        // Initialize the containers for the candidate k shortest paths and the actual found k shortest paths
-        ArrayList<PathKSP> ksp = new ArrayList<PathKSP>();
-        PriorityQueue<EppsteinPath> pathPQ = new PriorityQueue<EppsteinPath>();
-
-        // Place root heap in priority queue
-        pathPQ.add(new EppsteinPath(hg, -1, tree.getNodes().get(from).getDist()));
-
-        /* Pop k times from the priority queue to determine the k shortest paths */
-        for (int i = 0; i < K && pathPQ.size() > 0; i++) {
-            /* Get the next shortest path, which is implicitly represented as:
-                1) Some shorter path, p, from s (source) to t (target)
-                2) A sidetrack edge which branches off of path p at node u, and points to node v
-                3) The shortest path in the shortest path tree from node v to t */
-            EppsteinPath kpathImplicit = pathPQ.poll();
-
-            // Convert from the implicit path representation to the explicit path representation
-            PathKSP kpath = kpathImplicit.explicitPath(ksp, tree);
-
-            // Add explicit path to the list of K shortest paths
-            ksp.add(kpath);
-
-            // Push the (up to 3) children of this path within the Eppstein heap onto the priority queue
-            addExplicitChildrenToQueue(kpathImplicit, ksp, pathPQ);
-
-            /* Check for the existence of a potential fourth child, known as a "cross edge", to push onto the queue.
-                This heap edge/child does not need to be explicitly represented in the Eppstein heap because it is easy
-                to check for its existence. */
-            addCrossEdgeChildToQueue(outrootHeaps, kpathImplicit, i, ksp, pathPQ);
-        }
-
-        // Return the set of k shortest paths
-        return ksp;
-    }
-
-    /**
-     * Compute the set of sidetrack edge costs.
-     *
-     * Each sidetrack edge (u,v) is an edge in graph G that does not appear in the shortest path tree, T.
-     * For every sidetrack edge (u,v), compute S(u,v) = w(u,v) + d(v) - d(u), where w(u,v) is the cost of edge (u,v);
-     * and d(v) is the cost of the shortest path from node v to the target.
-     *
-     * @param graph     the graph on which to compute the K shortest paths from s to t
-     * @param tree      the shortest path tree, T, rooted at the target node, t
-     * @return
-     */
-    protected static HashMap<String,Double> computeSidetrackEdgeCosts(GraphKSP graph, ShortestPathTreeKSP tree) {
-        HashMap<String, Double> sidetrackEdgeCostMap = new HashMap<String, Double>();
-        List<EdgeKSP> edgeList = graph.getEdgeList();
-        for (EdgeKSP edge : edgeList) {
-            // Check to see if the target node is reachable from the outgoing vertex of the current edge,
-            // and check to see if the current edge is a sidetrack edge. If so, calculate its sidetrack cost.
-            String tp = tree.getParentOf(edge.getFromNode());
-            if (tp == null || !tp.equals(edge.getToNode())) {
-                double sidetrackEdgeCost = edge.getWeight() + tree.getNodes().get(edge.getToNode()).getDist() - tree.getNodes().get(edge.getFromNode()).getDist();
-                sidetrackEdgeCostMap.put(edge.getFromNode() + "," + edge.getToNode(), sidetrackEdgeCost);
-            }
-        }
-
-        return sidetrackEdgeCostMap;
-    }
-
-    /**
-     * Compute sub-heap H_out(v) for node v.
-     *
-     * @param nodeLabel             node v
-     * @param graph                 the graph, G, on which to compute the K shortest paths from s to t
-     * @param sidetrackEdgeCostMap  the cost of each sidetrack edge in G
-     * @param nodeHeaps             an index/hash table of heap H_out(v), for each node v in the graph
-     * @param edgeHeaps             an index/hash table of heaps H_out(v), but indexed by sidetrack edge
-     */
-    protected static void computeOutHeap(String nodeLabel, GraphKSP graph, HashMap<String,Double> sidetrackEdgeCostMap, HashMap<String,EppsteinHeap> nodeHeaps, HashMap<String,EppsteinHeap> edgeHeaps) {
-        NodeKSP node = graph.getNode(nodeLabel);
-        // This list holds the 2nd through last sidetrack edges, ordered by sidetrack cost
-        ArrayList<EdgeKSP> sidetrackEdges = new ArrayList<EdgeKSP>();
-        EdgeKSP bestSidetrack = null;
-        double minSidetrackCost = Double.MAX_VALUE;
-        // Iterate over the outgoing edges of v
-        for (String neighbor : node.getAdjacencyList()) {
-            String edgeLabel = nodeLabel+","+neighbor;
-            // Check to see if the current edge is a sidetrack edge
-            if (sidetrackEdgeCostMap.containsKey(edgeLabel)) {
-                double sidetrackEdgeCost = sidetrackEdgeCostMap.get(edgeLabel);
-                // Check to see if the current sidetrack edge has the lowest cost discovered so far for node v
-                if (sidetrackEdgeCost < minSidetrackCost) {
-                    // If there was a previously-known best sidetrack edge, add it to the list of non-best
-                    // sidetrack edges
-                    if (bestSidetrack != null) {
-                        sidetrackEdges.add(bestSidetrack);
-                    }
-                    // Set the new best (lowest cost) sidetrack edge to be the current one
-                    bestSidetrack = new EdgeKSP(nodeLabel, neighbor, node.getNeighbors().get(neighbor));
-                    minSidetrackCost = sidetrackEdgeCost;
-                }
-                // If current sidetrack edge is not the one with the lowest cost, add it to the list of non-best
-                // sidetrack edges
-                else {
-                    sidetrackEdges.add(new EdgeKSP(nodeLabel, neighbor, node.getNeighbors().get(neighbor)));
-                }
-            }
-        }
-        // If v was found to have at least one outgoing sidetrack edge...
-        if (bestSidetrack != null) {
-            // ...make a heap of the outgoing sidetrack edges of v, with the lowest-cost sidetrack edge put as the
-            // root
-            EppsteinHeap bestSidetrackHeap = new EppsteinHeap(bestSidetrack,sidetrackEdgeCostMap.get(bestSidetrack.getFromNode()+","+bestSidetrack.getToNode()));
-
-            // Make another heap (a binary heap) out of the rest of the sidetrack edges of v
-            EppsteinArrayHeap arrayHeap = new EppsteinArrayHeap();
-            if (sidetrackEdges.size() > 0) {
-                bestSidetrackHeap.setNumOtherSidetracks(bestSidetrackHeap.getNumOtherSidetracks()+1);
-                for (EdgeKSP edge : sidetrackEdges) {
-                    EppsteinHeap sidetrackHeap = new EppsteinHeap(edge,sidetrackEdgeCostMap.get(edge.getFromNode()+","+edge.getToNode()));
-                    edgeHeaps.put(edge.getFromNode()+","+edge.getToNode(), sidetrackHeap);
-                    arrayHeap.add(sidetrackHeap);
-                }
-
-                // Add the binary heap of 2nd-through-last lowest cost sidetrack edges as a child (the only child)
-                // of the lowest-cost sidetrack edge, forming the overall heap H_out(v)
-                bestSidetrackHeap.addChild(arrayHeap.toEppsteinHeap());
-            }
-
-            // Index H_out(v) by node v, for easy access later
-            nodeHeaps.put(nodeLabel, bestSidetrackHeap);
-            // Index H_out(v) by its lowest cost sidetrack edge, for easy access later
-            edgeHeaps.put(bestSidetrack.getFromNode()+","+bestSidetrack.getToNode(), bestSidetrackHeap);
-        }
-    }
-
-    /**
-     * Push the (up to 3) children (within the Eppstein heap) of the given (kth) path, onto the priority queue.
-     *
-     * @param kpathImplicit     implicit representation of the (kth) path
-     * @param ksp               list of shortest paths found so far
-     * @param pathPQ            priority queue of candidate paths
-     */
-    protected static void addExplicitChildrenToQueue(EppsteinPath kpathImplicit, ArrayList<PathKSP> ksp, PriorityQueue<EppsteinPath> pathPQ) {
-        double kpathCost = kpathImplicit.getCost();
-        for(EppsteinHeap childHeap : kpathImplicit.getHeap().getChildren()) {
-            // Get the index of the previous shorter path off of which this candidate sidetracks/branches
-            int prefPath = kpathImplicit.getPrefPath();
-
-            // Calculate the path cost of the new child/candidate
-            Double candidateCost = ksp.get(prefPath).getTotalCost() + childHeap.getSidetrackCost();
-
-            // Add the child/candidate to the priority queue
-            EppsteinPath candidate = new EppsteinPath(childHeap, prefPath, candidateCost);
-            pathPQ.add(candidate);
-        }
-    }
-
-    /**
-     *
-     * @param outrootHeaps      an index of heaps H_T(v) for each node v
-     * @param kpathImplicit     implicit representation of the (kth) path
-     * @param prefPath          the index k of the path off which this cross-edge child sidetracks
-     * @param ksp               list of shortest paths found so far
-     * @param pathPQ            priority queue of candidate paths
-     */
-    protected static void addCrossEdgeChildToQueue(HashMap<String,EppsteinHeap> outrootHeaps, EppsteinPath kpathImplicit, int prefPath, ArrayList<PathKSP> ksp, PriorityQueue<EppsteinPath> pathPQ) {
-        if (outrootHeaps.containsKey(kpathImplicit.getHeap().getSidetrack().getToNode())) {
-            EppsteinHeap childHeap = outrootHeaps.get(kpathImplicit.getHeap().getSidetrack().getToNode());
-
-            // Calculate the path cost of the new child/candidate
-            Double candidateCost = ksp.get(prefPath).getTotalCost() + childHeap.getSidetrackCost();
-
-            // Add the child/candidate to the priority queue
-            EppsteinPath candidate = new EppsteinPath(childHeap, prefPath, candidateCost);
-            pathPQ.add(candidate);
-        }
-    }
-
-    /**
-     * Generate sub-heap H_T(v) for node v and its children in the shortest path tree T, using a recursive depth-first
-     * search over the transpose graph, T', of the shortest path tree, T.
-     *
-     * The transpose graph is necessary because tree T is represented with pointers to parents instead of with pointers
-     * to children.
-     *
-     * @param nodeLabel         node v
-     * @param currentArrayHeap  the heap of v's parent in the shortest path tree; H_T(nextT(v))
-     * @param nodeHeaps         an index/hash table of heap H_out(v), for each node v in the graph
-     * @param outrootHeaps      an index/hash table of heap H_T(v), for each node v in the graph
-     * @param reversedSPT       the transpose graph, T', of the shortest path tree, T
-     */
-    protected static void recursiveOutrootHeaps(String nodeLabel, EppsteinArrayHeap currentArrayHeap, HashMap<String,EppsteinHeap> nodeHeaps, HashMap<String,EppsteinHeap> outrootHeaps, GraphKSP reversedSPT) {
-        // Get H_out(v)
-        EppsteinHeap sidetrackHeap = nodeHeaps.get(nodeLabel);
-
-        // Check to see if node v (nodeLabel) has a sidetrack edge
-        if (sidetrackHeap != null) {
-            // If so, need to add its best sidetrack edge to H_T(nextT(v))
-            // H_T(nextT(v)) is in variable currentArrayHeap, which was passed onto v when this function was called by
-            // nextT(v)
-
-            // The goal of Eppstein's algorithm is to re-use heap structures where possible
-            // When adding the best sidetrack edge of v to heap H_T(nextT(v)) to form H_T(v), this means that when
-            // the best sidetrack of v is added to H_T(nextT(v)), we need to make a new copy of all of the heap nodes
-            // on the path from the position where the sidetrack is added in the heap, to the root of the heap. All
-            // other heap nodes have the same structure in H_T(v) as in H_T(nextT(v)) and can simply be pointed to.
-
-            // Give H_T(v) a new set of pointers to the sub-heap nodes in H_T(nextT(v))
-            currentArrayHeap = currentArrayHeap.clone();
-
-            // Add the best sidetrack edge of v to heap H_T(v) (place the sidetrack edge in the next unoccupied space in
-            // the heap and bubble it up the tree to its rightful position) and make all new copies of the sub-heap
-            // nodes that fall on the path where the new edge is added in the heap, to the root of the heap
-            currentArrayHeap.addOutroot(sidetrackHeap);
-        }
-
-        // Convert from an array representation of the heap (EppsteinArrayHeap), which is convenient for accessing and
-        // manipulating a binary heap, to a pointer representation (EppsteinHeap), which is consistent with the overall
-        // heap, which is not strictly a binary heap since some nodes can have up to 4 children.
-        EppsteinHeap currentHeap = currentArrayHeap.toEppsteinHeap2();
-
-        // If v has any children (so H_T(v) exists), index heap H_T(v) in a list of heaps for fast access later
-        if (currentHeap != null) {
-            outrootHeaps.put(nodeLabel, currentHeap);
-        }
-
-        // Continue the depth-first search (recursively initiating additional depth-first searches for each child)
-        for (String neighbor : reversedSPT.getNode(nodeLabel).getNeighbors().keySet()) {
-            recursiveOutrootHeaps(neighbor, currentArrayHeap, nodeHeaps, outrootHeaps, reversedSPT);
-        }
-    }
-}
-
-/**
- * A pointer representation of an N-ary heap with data structures that aid in representing the heap constructed by
- * Eppstein's algorithm.
- * Does not contain functions for adding/removing elements while maintaining the heap property.
- * The children added to the root are sub-heaps whose elements are guaranteed to have a greater cost than the root
- * element of the heap.
- */
-class EppsteinHeap {
-    private EdgeKSP sidetrack; // the sidetrack edge (u,v) associated with the root of this heap or sub-heap
-    private double sidetrackCost = 0.0;
-    private ArrayList<EppsteinHeap> children; // supports N children but Eppstein is limited to 4
-    private int numOtherSidetracks = 0; // number of elements of H_out(u) - 1
-
-    public EppsteinHeap(EdgeKSP sidetrack) {
-        this.sidetrack = sidetrack;
-        this.children = new ArrayList<EppsteinHeap>();
-    }
-
-    public EppsteinHeap(EdgeKSP sidetrack, Double sidetrackCost) {
-        this.sidetrack = sidetrack;
-        this.sidetrackCost = sidetrackCost;
-        this.children = new ArrayList<EppsteinHeap>();
-    }
-
-    public EppsteinHeap(EdgeKSP sidetrack, double sidetrackCost, ArrayList<EppsteinHeap> children, int numOtherSidetracks) { //, boolean bestChild, int copy) {
-        this.sidetrack = sidetrack;
-        this.sidetrackCost = sidetrackCost;
-        this.children = children;
-        this.numOtherSidetracks = numOtherSidetracks;
-    }
-
-    public EdgeKSP getSidetrack() {
-        return sidetrack;
-    }
-
-    public void setSidetrack(EdgeKSP sidetrack) {
-        this.sidetrack = sidetrack;
-    }
-
-    public double getSidetrackCost() {
-        return sidetrackCost;
-    }
-
-    public void setSidetrackCost(double sidetrackCost) {
-        this.sidetrackCost = sidetrackCost;
-    }
-
-    public ArrayList<EppsteinHeap> getChildren() {
-        return children;
-    }
-
-    public void setChildren(ArrayList<EppsteinHeap> children) {
-        this.children = children;
-    }
-
-    public void addChild(EppsteinHeap child) {
-        this.children.add(child);
-    }
-
-    public int getNumOtherSidetracks() {
-        return numOtherSidetracks;
-    }
-
-    public void setNumOtherSidetracks(int numOtherSidetracks) {
-        this.numOtherSidetracks = numOtherSidetracks;
-    }
-
-    public EppsteinHeap clone() {
-        ArrayList<EppsteinHeap> children_clone = new ArrayList<EppsteinHeap>(children.size());
-        for (EppsteinHeap eh: children) {
-            children_clone.add(eh);
-        }
-
-        return new EppsteinHeap(sidetrack, sidetrackCost, children_clone, numOtherSidetracks);
-    }
-}
-
-/**
- * An array representation of a binary heap with additional functions specialized for implementing Eppstein's algorithm.
- */
-class EppsteinArrayHeap {
-    private ArrayList<EppsteinHeap> arrayHeap;
-
-    public EppsteinArrayHeap() {
-        arrayHeap = new ArrayList<EppsteinHeap>(0);
-    }
-
-    public ArrayList<EppsteinHeap> getArrayHeap() {
-        return arrayHeap;
-    }
-
-    public void setArrayHeap(ArrayList<EppsteinHeap> arrayHeap) {
-        this.arrayHeap = arrayHeap;
-    }
-
-    public int getParentIndex(int i) {
-        return (i-1)/2;
-    }
-
-    public void add(EppsteinHeap h) {
-        arrayHeap.add(h);
-        bubbleUp(arrayHeap.size()-1);
-    }
-
-    public void addOutroot(EppsteinHeap h) {
-        int current = arrayHeap.size();
-
-        while (current > 0) {
-            int parent = getParentIndex(current);
-            EppsteinHeap newHeap = arrayHeap.get(parent).clone();
-            arrayHeap.set(parent,newHeap);
-            current = parent;
-        }
-        arrayHeap.add(h);
-        bubbleUp(arrayHeap.size() - 1);
-    }
-
-    private void bubbleUp(int current) {
-        if (current == 0)
-            return;
-
-        int parent = getParentIndex(current);
-        if (arrayHeap.get(current).getSidetrackCost() >= arrayHeap.get(parent).getSidetrackCost())
-            return;
-
-        EppsteinHeap temp = arrayHeap.get(current);
-        arrayHeap.set(current, arrayHeap.get(parent));
-        arrayHeap.set(parent, temp);
-        bubbleUp(parent);
-    }
-
-    // Convert from an array representation of a binary heap to a pointer representation of a binary heap, which can fit
-    // consistently within an overall N-ary heap
-    public EppsteinHeap toEppsteinHeap() {
-        int heapsize = arrayHeap.size();
-        if (arrayHeap.size() == 0)
-            return null;
-
-        EppsteinHeap eh = arrayHeap.get(0);
-        for (int i = 1; i < arrayHeap.size(); i++) {
-            EppsteinHeap h = arrayHeap.get(i);
-            arrayHeap.get(getParentIndex(i)).addChild(h);
-        }
-
-        return eh;
-    }
-
-    // Convert from an array representation of a binary heap to a pointer representation of a binary heap, which can fit
-    // consistently within an overall non-binary heap.
-    public EppsteinHeap toEppsteinHeap2() {
-        int current = arrayHeap.size()-1;
-        if (current == -1)
-            return null;
-
-        while (current >= 0) {
-            EppsteinHeap childHeap = arrayHeap.get(current);
-            while (childHeap.getChildren().size() > childHeap.getNumOtherSidetracks()) {
-                childHeap.getChildren().remove(childHeap.getChildren().size()-1);
-            }
-
-            int child1 = current * 2 + 1;
-            int child2 = current * 2 + 2;
-
-            if (child1 < arrayHeap.size()) {
-                arrayHeap.get(current).addChild(arrayHeap.get(child1));
-            }
-            if (child2 < arrayHeap.size()) {
-                arrayHeap.get(current).addChild(arrayHeap.get(child2));
-            }
-            if (current > 0) {
-                current = getParentIndex(current);
-            }
-            else {
-                current = -1;
-            }
-        }
-
-        return arrayHeap.get(0);
-    }
-
-    public EppsteinArrayHeap clone() {
-        EppsteinArrayHeap clonedArrayHeap = new EppsteinArrayHeap();
-        for (EppsteinHeap heap: arrayHeap) {
-            clonedArrayHeap.add(heap);
-        }
-
-        return clonedArrayHeap;
-    }
-}
-
-/**
- * Data structure for representing a source-target path implicitly inside the priority queue of candidate k shortest
- * paths during the execution of Eppstein's algorithm.
- */
-class EppsteinPath implements Comparable<EppsteinPath> {
-    EppsteinHeap heap; // pointer to the heap node and last sidetrack edge in this candidate path
-    int prefPath; // index of the shorter path that this path sidetracks from
-    Double cost; // the total cost of the path
-
-    public EppsteinPath(EppsteinHeap heap, int prefPath, Double cost) {
-        this.heap = heap;
-        this.prefPath = prefPath;
-        this.cost = cost;
-    }
-
-    public int getPrefPath() {
-        return prefPath;
-    }
-
-    public void setPrefPath(int prefPath) {
-        this.prefPath = prefPath;
-    }
-
-    public EppsteinHeap getHeap() {
-        return heap;
-    }
-
-    public void setHeap(EppsteinHeap heap) {
-        this.heap = heap;
-    }
-
-    public Double getCost() {
-        return cost;
-    }
-
-    public void setCost(Double cost) {
-        this.cost = cost;
-    }
-
-    // Convert from the implicit representation of the path to an explicit listing of all of the edges in the path
-    // There are potentially three pieces to the path:
-    // 1) the path from node s (source) to node u in the parent path
-    // 2) the sidetrack edge (u,v)
-    // 3) the shortest path (in the shortest path tree) from node v to node t (target)
-    public PathKSP explicitPath(List<PathKSP> ksp, ShortestPathTreeKSP tree) {
-        PathKSP explicitPath = new PathKSP();
-
-        // If path is not the shortest path in the graph...
-        if (prefPath >= 0) {
-            // Get the explicit representation of the shorter parent path that this path sidetracks from
-            PathKSP explicitPrefPath = ksp.get(prefPath);
-
-            // 1a) Identify the s-u portion of the path
-            // Identify and add the segment of the parent path up until the point where the current path sidetracks off
-            // of it.
-            // In other words, if (u,v) is the sidetrack edge of the current path off of the parent path, look for the
-            // last instance of node u in the parent path.
-            LinkedList<EdgeKSP> edges = explicitPrefPath.getEdges();
-            int lastEdgeNum = -1;
-            EdgeKSP heapSidetrack = heap.getSidetrack();
-            for (int i = edges.size()-1; i >= 0; i--) {
-                EdgeKSP currentEdge = edges.get(i);
-                if (currentEdge.getToNode().equals(heapSidetrack.getFromNode())) {
-                    lastEdgeNum = i;
-                    break;
-                }
-            }
-
-            // 1b) Add the s-u portion of the path
-            // Copy the explicit parent path up to the identified point where the current/child path sidetracks
-            explicitPath = new PathKSP();
-            for (int i = 0; i <= lastEdgeNum; i++) {
-                explicitPath.add(edges.get(i));
-            }
-
-            // 2) Add the (u,v) portion of the path
-            // Add the last sidetrack edge to the explicit path representation
-            explicitPath.add(heap.getSidetrack());
-        }
-
-        // 3) Add the v-t portion of the path
-        // Add the shortest path from v (either the source node, or the incoming node of the sidetrack edge associated
-        // with the current path) to the explicit path representation
-        String current = heap.getSidetrack().getToNode();
-        while (!current.equals(tree.getRoot())) {
-            String next = tree.getParentOf(current);
-            Double edgeWeight = tree.getNodes().get(current).getDist() - tree.getNodes().get(next).getDist();
-            explicitPath.add(new EdgeKSP(current, next, edgeWeight));
-            current = next;
-        }
-
-        return explicitPath;
-    }
-
-    public int compareTo(EppsteinPath comparedNode) {
-        double cost1 = this.cost;
-        double cost2 = comparedNode.getCost();
-        if (cost1 == cost2)
-            return 0;
-        if (cost1 > cost2)
-            return 1;
-        return -1;
-    }
-
-}
diff --git a/core/src/main/java/com/graphhopper/routing/KSP.java b/core/src/main/java/com/graphhopper/routing/KSP.java
new file mode 100644
index 0000000000..87d5063dfe
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/KSP.java
@@ -0,0 +1,509 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.AStar.AStarEntry;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Parameters;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+import gnu.trove.procedure.TIntObjectProcedure;
+import gnu.trove.procedure.TObjectProcedure;
+import gnu.trove.set.TIntSet;
+import gnu.trove.set.hash.TIntHashSet;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Reimplementation of AlternativeRoute that is more like a k-shortest paths algorithm
+ * (i.e. lots of alternatives, high overlap with best route is fine)
+ *
+ * @author Peter Karich
+ */
+public class KSP implements RoutingAlgorithm {
+    private static final Comparator<AlternativeInfo> ALT_COMPARATOR = new Comparator<AlternativeInfo>() {
+        @Override
+        public int compare(AlternativeInfo o1, AlternativeInfo o2) {
+            return Double.compare(o1.sortBy, o2.sortBy);
+        }
+    };
+    private final Graph graph;
+    private final FlagEncoder flagEncoder;
+    private final Weighting weighting;
+    private final TraversalMode traversalMode;
+    private int visitedNodes;
+    private int maxVisitedNodes = Integer.MAX_VALUE;
+    private double maxWeightFactor = 2;  // time can be twice as long
+    // the higher the maxWeightFactor the higher the explorationFactor needs to be
+    // 1 is default for bidir Dijkstra, 0.8 seems to be a very similar value for bidir A* but roughly 1/2 of the nodes explored
+    private double maxExplorationFactor = 2;  //
+    private int maxPaths = 100;  // K
+
+    public KSP(Graph graph, Weighting weighting, TraversalMode traversalMode) {
+        this.graph = graph;
+        this.flagEncoder = weighting.getFlagEncoder();
+        this.weighting = weighting;
+        this.traversalMode = traversalMode;
+    }
+
+    static List<String> getAltNames(Graph graph, SPTEntry ee) {
+        if (ee == null || !EdgeIterator.Edge.isValid(ee.edge))
+            return Collections.emptyList();
+
+        EdgeIteratorState iter = graph.getEdgeIteratorState(ee.edge, Integer.MIN_VALUE);
+        if (iter == null)
+            return Collections.emptyList();
+
+        String str = iter.getName();
+        if (str.isEmpty())
+            return Collections.emptyList();
+
+        return Collections.singletonList(str);
+    }
+
+    @Override
+    public void setMaxVisitedNodes(int numberOfNodes) {
+        this.maxVisitedNodes = numberOfNodes;
+    }
+
+    /**
+     * Increasing this factor results in returning more alternatives. E.g. if the factor is 2 than
+     * all alternatives with a weight 2 times longer than the optimal weight are return. (default is
+     * 1)
+     */
+    public void setMaxWeightFactor(double maxWeightFactor) {
+        this.maxWeightFactor = maxWeightFactor;
+    }
+
+    /**
+     * This method sets the graph exploration percentage for alternative paths. Default is 1 (100%).
+     * Specify a higher value to get more alternatives (especially if maxWeightFactor is higher than
+     * 1.5) and a lower value to improve query time but reduces the possibility to find
+     * alternatives.
+     */
+    public void setMaxExplorationFactor(double explorationFactor) {
+        this.maxExplorationFactor = explorationFactor;
+    }
+
+    /**
+     * Specifies how many paths (including the optimal) are returned. (default is 2)
+     */
+    public void setMaxPaths(int maxPaths) {
+        this.maxPaths = maxPaths;
+        if (this.maxPaths < 2)
+            throw new IllegalStateException("Use normal algorithm with less overhead instead if no alternatives are required");
+    }
+
+    /**
+     * This method calculates best paths (alternatives) between 'from' and 'to', where maxPaths-1
+     * alternatives are searched and they are only accepted if they are not too similar but close to
+     * the best path.
+     */
+    public List<AlternativeInfo> calcAlternatives(int from, int to) {
+        AlternativeBidirSearch altBidirDijktra = new AlternativeBidirSearch(
+                graph, weighting, traversalMode, maxExplorationFactor * 2);
+        altBidirDijktra.setMaxVisitedNodes(maxVisitedNodes);
+        altBidirDijktra.searchBest(from, to);
+        visitedNodes = altBidirDijktra.getVisitedNodes();
+
+        List<AlternativeInfo> alternatives = altBidirDijktra.
+                calcAlternatives(maxPaths, maxWeightFactor);
+        return alternatives;
+    }
+
+    @Override
+    public Path calcPath(int from, int to) {
+        return calcPaths(from, to).get(0);
+    }
+
+    @Override
+    public List<Path> calcPaths(int from, int to) {
+        List<AlternativeInfo> alts = calcAlternatives(from, to);
+        List<Path> paths = new ArrayList<Path>(alts.size());
+        for (AlternativeInfo a : alts) {
+            paths.add(a.getPath());
+        }
+        return paths;
+    }
+
+    @Override
+    public String getName() {
+        return Parameters.Algorithms.ALT_ROUTE;
+    }
+
+    @Override
+    public int getVisitedNodes() {
+        return visitedNodes;
+    }
+
+    public static class AlternativeInfo {
+        private final double sortBy;
+        private final Path path;
+        private final SPTEntry shareStart;
+        private final SPTEntry shareEnd;
+        private final double shareWeight;
+        private final List<String> names;
+
+        public AlternativeInfo(double sortBy, Path path, SPTEntry shareStart, SPTEntry shareEnd,
+                               double shareWeight, List<String> altNames) {
+            this.names = altNames;
+            this.sortBy = sortBy;
+            this.path = path;
+            this.path.setDescription(names);
+            this.shareStart = shareStart;
+            this.shareEnd = shareEnd;
+            this.shareWeight = shareWeight;
+        }
+
+        public Path getPath() {
+            return path;
+        }
+
+        public SPTEntry getShareStart() {
+            return shareStart;
+        }
+
+        public SPTEntry getShareEnd() {
+            return shareEnd;
+        }
+
+        public double getShareWeight() {
+            return shareWeight;
+        }
+
+        public double getSortBy() {
+            return sortBy;
+        }
+
+        @Override
+        public String toString() {
+            return names + ", sortBy:" + sortBy + ", shareWeight:" + shareWeight + ", " + path;
+        }
+    }
+
+    /**
+     * Helper class to find alternatives and alternatives for round trip.
+     */
+    public static class AlternativeBidirSearch extends AStarBidirection {
+        private final double explorationFactor;
+
+        public AlternativeBidirSearch(Graph graph, Weighting weighting, TraversalMode tMode,
+                                      double explorationFactor) {
+            super(graph, weighting, tMode);
+            this.explorationFactor = explorationFactor;
+        }
+
+        public TIntObjectMap<AStarEntry> getBestWeightMapFrom() {
+            return bestWeightMapFrom;
+        }
+
+        public TIntObjectMap<AStarEntry> getBestWeightMapTo() {
+            return bestWeightMapTo;
+        }
+
+        @Override
+        public boolean finished() {
+            // we need to finish BOTH searches identical to CH
+            if (finishedFrom && finishedTo)
+                return true;
+
+            if (isMaxVisitedNodesExceeded())
+                return true;
+
+            // The following condition is necessary to avoid traversing the full graph if areas are disconnected
+            // but it is only valid for none-CH e.g. for CH it can happen that finishedTo is true but the from-SPT could still reach 'to'
+            if (!bestPath.isFound() && (finishedFrom || finishedTo))
+                return true;
+
+            // increase overlap of both searches:
+            return currFrom.weight + currTo.weight > explorationFactor * bestPath.getWeight();
+            // This is more precise but takes roughly 20% longer: return currFrom.weight > bestPath.getWeight() && currTo.weight > bestPath.getWeight();
+            // For bidir A* and AStarEdge.getWeightOfVisitedPath see comment in AStarBidirection.finished
+        }
+
+        public Path searchBest(int to, int from) {
+            createAndInitPath();
+            initFrom(to, 0);
+            initTo(from, 0);
+            // init collections and bestPath.getWeight properly
+            runAlgo();
+            return extractPath();
+        }
+
+        /**
+         * @return the information necessary to handle alternative paths. Note that the paths are
+         * not yet extracted.
+         */
+        public List<AlternativeInfo> calcAlternatives(final int maxPaths,
+                                                      double maxWeightFactor) {
+            final double maxWeight = maxWeightFactor * bestPath.getWeight();
+            final TIntObjectHashMap<TIntSet> traversalIDMap = new TIntObjectHashMap<TIntSet>();
+            final AtomicInteger startTID = addToMap(traversalIDMap, bestPath);
+
+            // find all 'good' alternatives from forward-SPT matching the backward-SPT and optimize by
+            // small total weight (1), small share and big plateau (3a+b) and do these expensive calculations
+            // only for plateau start candidates (2)
+            final List<AlternativeInfo> alternatives = new ArrayList<AlternativeInfo>(maxPaths);
+
+            double bestShare = 0;
+            double sortBy = bestPath.getWeight();
+
+            final AlternativeInfo bestAlt = new AlternativeInfo(sortBy, bestPath,
+                    bestPath.sptEntry, bestPath.edgeTo, bestShare, getAltNames(graph, bestPath.sptEntry));
+            alternatives.add(bestAlt);
+            final List<SPTEntry> bestPathEntries = new ArrayList<SPTEntry>(2);
+
+            bestWeightMapFrom.forEachEntry(new TIntObjectProcedure<SPTEntry>() {
+                @Override
+                public boolean execute(final int traversalId, final SPTEntry fromSPTEntry) {
+                    SPTEntry toSPTEntry = bestWeightMapTo.get(traversalId);
+                    if (toSPTEntry == null)
+                        return true;
+
+                    if (traversalMode.isEdgeBased()) {
+                        if (toSPTEntry.parent != null)
+                            // move to parent for two reasons:
+                            // 1. make only turn costs missing in 'weight' and not duplicating current edge.weight
+                            // 2. to avoid duplicate edge in Path
+                            toSPTEntry = toSPTEntry.parent;
+                        // TODO else if fromSPTEntry.parent != null fromSPTEntry = fromSPTEntry.parent;
+
+                    } else // The alternative path is suboptimal when both entries are parallel
+                        if (fromSPTEntry.edge == toSPTEntry.edge)
+                            return true;
+
+                    // (1) skip too long paths
+                    final double weight = fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath();
+                    if (weight > maxWeight)
+                        return true;
+
+                    // (2) Use the start traversal ID of a plateau as ID for the alternative path.
+                    // Accept from-EdgeEntries only if such a start of a plateau
+                    // i.e. discard if its parent has the same edgeId as the next to-SPTEntry.
+                    // Ignore already added best path
+                    if (isBestPath(fromSPTEntry, bestPath))
+                        return true;
+
+                    // For edge based traversal we need the next entry to find out the plateau start
+                    SPTEntry tmpFromEntry = traversalMode.isEdgeBased() ? fromSPTEntry.parent : fromSPTEntry;
+                    if (tmpFromEntry == null || tmpFromEntry.parent == null) {
+                        // we can be here only if edge based and only if entry is not part of the best path
+                        // e.g. when starting point has two edges and one is part of the best path the other edge is path of an alternative
+                        assert traversalMode.isEdgeBased();
+                    } else {
+                        int nextToTraversalId = traversalMode.createTraversalId(tmpFromEntry.adjNode,
+                                tmpFromEntry.parent.adjNode, tmpFromEntry.edge, true);
+                        SPTEntry tmpNextToSPTEntry = bestWeightMapTo.get(nextToTraversalId);
+                        if (tmpNextToSPTEntry == null)
+                            return true;
+
+                        if (traversalMode.isEdgeBased())
+                            tmpNextToSPTEntry = tmpNextToSPTEntry.parent;
+                        // skip if on plateau
+                        if (fromSPTEntry.edge == tmpNextToSPTEntry.edge)
+                            return true;
+                    }
+
+                    // (3a) calculate plateau, we know we are at the beginning of the 'from'-side of
+                    // the plateau A-B-C and go further to B
+                    // where B is the next-'from' of A and B is also the previous-'to' of A.
+                    //
+                    //      *<-A-B-C->*
+                    //        /    \
+                    //    start    end
+                    //
+                    // extend plateau in only one direction necessary (A to B to ...) as we know
+                    // that the from-SPTEntry is the start of the plateau or there is no plateau at all
+                    //
+                    SPTEntry prevToSPTEntry = toSPTEntry;
+                    // List<Integer> plateauEdges = new ArrayList<Integer>();
+                    while (prevToSPTEntry.parent != null) {
+                        int nextFromTraversalId = traversalMode.createTraversalId(prevToSPTEntry.adjNode, prevToSPTEntry.parent.adjNode,
+                                prevToSPTEntry.edge, false);
+
+                        SPTEntry nextFromSPTEntry = bestWeightMapFrom.get(nextFromTraversalId);
+                        // end of a plateau
+                        if (nextFromSPTEntry == null)
+                            break;
+
+                        // is the next from-SPTEntry on the plateau?
+                        if (prevToSPTEntry.edge != nextFromSPTEntry.edge)
+                            break;
+
+                        // plateauEdges.add(prevToSPTEntry.edge);
+                        prevToSPTEntry = prevToSPTEntry.parent;
+                    }
+
+                    if (fromSPTEntry.parent == null)
+                        throw new IllegalStateException("not implemented yet. in case of an edge based traversal the parent of fromSPTEntry could be null");
+
+                    // (3b) calculate share
+                    SPTEntry fromEE = getFirstShareEE(fromSPTEntry.parent, true);
+                    SPTEntry toEE = getFirstShareEE(toSPTEntry.parent, false);
+                    double shareWeight = fromEE.getWeightOfVisitedPath() + toEE.getWeightOfVisitedPath();
+                    List<String> altNames = getAltNames(graph, fromSPTEntry);
+
+                    double worstSortBy = getWorstSortBy();
+
+                    // plateaus.add(new PlateauInfo(altName, plateauEdges));
+                    if (weight < worstSortBy || alternatives.size() < maxPaths) {
+                        Path path = new PathBidirRef(graph, weighting).
+                                setSPTEntryTo(toSPTEntry).setSPTEntry(fromSPTEntry).
+                                setWeight(weight);
+                        path.extract();
+
+                        // for now do not add alternatives to set, if we do we need to remove then on alternatives.clear too (see below)
+                        // AtomicInteger tid = addToMap(traversalIDMap, path);
+                        // int tid = traversalMode.createTraversalId(path.calcEdges().get(0), false);
+                        alternatives.add(new AlternativeInfo(weight, path, fromEE, toEE, shareWeight, altNames));
+
+                        Collections.sort(alternatives, ALT_COMPARATOR);
+                        if (alternatives.get(0) != bestAlt)
+                            throw new IllegalStateException("best path should be always first entry");
+
+                        if (alternatives.size() > maxPaths)
+                            alternatives.subList(maxPaths, alternatives.size()).clear();
+                    }
+                    return true;
+                }
+
+                /**
+                 * Extract path until we stumble over an existing traversal id
+                 */
+                SPTEntry getFirstShareEE(SPTEntry startEE, boolean reverse) {
+                    while (startEE.parent != null) {
+                        // TODO we could make use of traversal ID directly if stored in SPTEntry
+                        int tid = traversalMode.createTraversalId(startEE.adjNode, startEE.parent.adjNode, startEE.edge, reverse);
+                        if (isAlreadyExisting(tid))
+                            return startEE;
+
+                        startEE = startEE.parent;
+                    }
+
+                    return startEE;
+                }
+
+                /**
+                 * This method returns true if the specified tid is already existent in the
+                 * traversalIDMap
+                 */
+                boolean isAlreadyExisting(final int tid) {
+                    return !traversalIDMap.forEachValue(new TObjectProcedure<TIntSet>() {
+                        @Override
+                        public boolean execute(TIntSet set) {
+                            return !set.contains(tid);
+                        }
+                    });
+                }
+
+                /**
+                 * Return the current worst weight for all alternatives
+                 */
+                double getWorstSortBy() {
+                    if (alternatives.isEmpty())
+                        throw new IllegalStateException("Empty alternative list cannot happen");
+                    return alternatives.get(alternatives.size() - 1).sortBy;
+                }
+
+                // returns true if fromSPTEntry is identical to the specified best path
+                boolean isBestPath(SPTEntry fromSPTEntry, Path bestPath) {
+                    if (traversalMode.isEdgeBased()) {
+                        if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromSPTEntry.edge) {
+                            if (fromSPTEntry.parent == null)
+                                throw new IllegalStateException("best path must have no parent but was non-null: " + fromSPTEntry);
+
+                            return true;
+                        }
+
+                    } else if (fromSPTEntry.parent == null) {
+                        bestPathEntries.add(fromSPTEntry);
+                        if (bestPathEntries.size() > 1)
+                            throw new IllegalStateException("There is only one best path but was: " + bestPathEntries);
+
+                        if (startTID.get() != fromSPTEntry.adjNode)
+                            throw new IllegalStateException("Start traversal ID has to be identical to root edge entry "
+                                    + "which is the plateau start of the best path but was: " + startTID + " vs. adjNode: " + fromSPTEntry.adjNode);
+
+                        return true;
+                    }
+
+                    return false;
+                }
+            });
+
+            return alternatives;
+        }
+
+        /**
+         * This method adds the traversal IDs of the specified path as set to the specified map.
+         */
+        AtomicInteger addToMap(TIntObjectHashMap<TIntSet> map, Path path) {
+            TIntSet set = new TIntHashSet();
+            final AtomicInteger startTID = new AtomicInteger(-1);
+            for (EdgeIteratorState iterState : path.calcEdges()) {
+                int tid = traversalMode.createTraversalId(iterState, false);
+                set.add(tid);
+                if (startTID.get() < 0) {
+                    // for node based traversal we need to explicitely add base node as starting node and to list
+                    if (!traversalMode.isEdgeBased()) {
+                        tid = iterState.getBaseNode();
+                        set.add(tid);
+                    }
+
+                    startTID.set(tid);
+                }
+            }
+            map.put(startTID.get(), set);
+            return startTID;
+        }
+    }
+
+    public static class PlateauInfo {
+        String name;
+        List<Integer> edges;
+
+        public PlateauInfo(String name, List<Integer> edges) {
+            this.name = name;
+            this.edges = edges;
+        }
+
+        @Override
+        public String toString() {
+            return name;
+        }
+
+        public List<Integer> getEdges() {
+            return edges;
+        }
+
+        public String getName() {
+            return name;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index 19a111a1cf..8e4c8a0a54 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -65,6 +65,8 @@ public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
             altRouteAlgo.setMaxExplorationFactor(opts.getHints().getDouble("alternative_route.max_exploration_factor", 1));
             ra = altRouteAlgo;
 
+        } else if (KSP.equalsIgnoreCase(algoStr)) {
+            ra = new KSP(g, opts.getWeighting(), opts.getTraversalMode());
         } else {
             throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java
deleted file mode 100644
index 76876ca81e..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-/**
- * Created by brandonsmock on 6/1/15.
- */
-import java.util.*;
-
-public final class DijkstraKSP {
-
-    private DijkstraKSP() {}
-
-    public static ShortestPathTreeKSP shortestPathTree(GraphKSP graph, String sourceLabel) throws Exception {
-        HashMap<String,NodeKSP> nodes = graph.getNodes();
-        if (!nodes.containsKey(sourceLabel))
-            throw new Exception("Source node not found in graph.");
-        ShortestPathTreeKSP predecessorTree = new ShortestPathTreeKSP(sourceLabel);
-        Set<DijkstraNodeKSP> visited = new HashSet<DijkstraNodeKSP>();
-        PriorityQueue<DijkstraNodeKSP> pq = new PriorityQueue<DijkstraNodeKSP>();
-        for (String nodeLabel:nodes.keySet()) {
-            DijkstraNodeKSP newNode = new DijkstraNodeKSP(nodeLabel);
-            newNode.setDist(Double.MAX_VALUE);
-            newNode.setDepth(Integer.MAX_VALUE);
-            predecessorTree.add(newNode);
-        }
-        DijkstraNodeKSP sourceNode = predecessorTree.getNodes().get(predecessorTree.getRoot());
-        sourceNode.setDist(0);
-        sourceNode.setDepth(0);
-        pq.add(sourceNode);
-
-        int count = 0;
-        while (!pq.isEmpty()) {
-            DijkstraNodeKSP current = pq.poll();
-            String currLabel = current.getLabel();
-            visited.add(current);
-            count++;
-            HashMap<String, Double> neighbors = nodes.get(currLabel).getNeighbors();
-            for (String currNeighborLabel:neighbors.keySet()) {
-                DijkstraNodeKSP neighborNode = predecessorTree.getNodes().get(currNeighborLabel);
-                Double currDistance = neighborNode.getDist();
-                Double newDistance = current.getDist() + nodes.get(currLabel).getNeighbors().get(currNeighborLabel);
-                if (newDistance < currDistance) {
-                    DijkstraNodeKSP neighbor = predecessorTree.getNodes().get(currNeighborLabel);
-
-                    pq.remove(neighbor);
-                    neighbor.setDist(newDistance);
-                    neighbor.setDepth(current.getDepth() + 1);
-                    neighbor.setParent(currLabel);
-                    pq.add(neighbor);
-                }
-            }
-        }
-
-        return predecessorTree;
-    }
-
-    public static PathKSP shortestPath(GraphKSP graph, String sourceLabel, String targetLabel) throws Exception {
-        //if (!nodes.containsKey(sourceLabel))
-        //    throw new Exception("Source node not found in graph.");
-        HashMap<String,NodeKSP> nodes = graph.getNodes();
-        ShortestPathTreeKSP predecessorTree = new ShortestPathTreeKSP(sourceLabel);
-        PriorityQueue<DijkstraNodeKSP> pq = new PriorityQueue<DijkstraNodeKSP>();
-        for (String nodeLabel:nodes.keySet()) {
-            DijkstraNodeKSP newNode = new DijkstraNodeKSP(nodeLabel);
-            newNode.setDist(Double.MAX_VALUE);
-            newNode.setDepth(Integer.MAX_VALUE);
-            predecessorTree.add(newNode);
-        }
-        DijkstraNodeKSP sourceNode = predecessorTree.getNodes().get(predecessorTree.getRoot());
-        sourceNode.setDist(0);
-        sourceNode.setDepth(0);
-        pq.add(sourceNode);
-
-        int count = 0;
-        while (!pq.isEmpty()) {
-            DijkstraNodeKSP current = pq.poll();
-            String currLabel = current.getLabel();
-            if (currLabel.equals(targetLabel)) {
-                PathKSP shortestPath = new PathKSP();
-                String currentN = targetLabel;
-                String parentN = predecessorTree.getParentOf(currentN);
-                while (parentN != null) {
-                    shortestPath.addFirst(new EdgeKSP(parentN,currentN,nodes.get(parentN).getNeighbors().get(currentN)));
-                    currentN = parentN;
-                    parentN = predecessorTree.getParentOf(currentN);
-                }
-                return shortestPath;
-            }
-            count++;
-            HashMap<String, Double> neighbors = nodes.get(currLabel).getNeighbors();
-            for (String currNeighborLabel:neighbors.keySet()) {
-                DijkstraNodeKSP neighborNode = predecessorTree.getNodes().get(currNeighborLabel);
-                Double currDistance = neighborNode.getDist();
-                Double newDistance = current.getDist() + nodes.get(currLabel).getNeighbors().get(currNeighborLabel);
-                if (newDistance < currDistance) {
-                    DijkstraNodeKSP neighbor = predecessorTree.getNodes().get(currNeighborLabel);
-
-                    pq.remove(neighbor);
-                    neighbor.setDist(newDistance);
-                    neighbor.setDepth(current.getDepth() + 1);
-                    neighbor.setParent(currLabel);
-                    pq.add(neighbor);
-                }
-            }
-        }
-
-        return null;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java
deleted file mode 100644
index 83cc38fe74..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-import java.util.HashMap;
-import java.util.Set;
-
-/**
- * Created by brandonsmock on 6/6/15.
- */
-public class DijkstraNodeKSP extends NodeKSP implements Comparable<DijkstraNodeKSP> {
-    private double dist = Double.MAX_VALUE;
-    private int depth;
-
-    public DijkstraNodeKSP(double dist) {
-        super();
-        this.dist = dist;
-    }
-
-    public DijkstraNodeKSP(String label) {
-        super(label);
-        this.dist = 0.0;
-    }
-
-    public DijkstraNodeKSP(String label, double dist) {
-        super(label);
-        this.dist = dist;
-    }
-
-    public DijkstraNodeKSP(String label, double dist, int depth, String parent) {
-        super(label);
-        this.dist = dist;
-        this.depth = depth;
-        super.addEdge(parent,0.0);
-    }
-
-    public double getDist() {
-        return dist;
-    }
-
-    public void setDist(double dist) {
-        this.dist = dist;
-    }
-
-    public int getDepth() {
-        return depth;
-    }
-
-    public void setDepth(int depth) {
-        this.depth = depth;
-    }
-
-    public void setParent(String parent) {
-        super.neighbors = new HashMap<String, Double>();
-        super.neighbors.put(parent,0.0);
-    }
-
-    public String getParent() {
-        Set<String> neighborLabels = super.neighbors.keySet();
-        if (neighborLabels.size() > 1) {
-            return null;
-        }
-        if (neighborLabels.size() < 1) {
-            return null;
-        }
-        return super.neighbors.keySet().iterator().next();
-    }
-
-    public int compareTo(DijkstraNodeKSP comparedNode) {
-        double distance1 = this.dist;
-        double distance2 = comparedNode.getDist();
-        if (distance1 == distance2)
-            return 0;
-        if (distance1 > distance2)
-            return 1;
-        return -1;
-    }
-
-    public boolean equals(DijkstraNodeKSP comparedNode) {
-        return this.getLabel().equals(comparedNode.getLabel());
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java
deleted file mode 100644
index 23c9532686..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-/**
- * The Edge class implements standard properties and methods for a weighted edge in a directed graph.
- *
- * Created by Brandon Smock on 6/19/15.
- */
-public class EdgeKSP implements Cloneable {
-    private String fromNode;
-    private String toNode;
-    private double weight;
-
-    public EdgeKSP() {
-        this.fromNode = null;
-        this.toNode = null;
-        this.weight = Double.MAX_VALUE;
-    }
-
-    public EdgeKSP(String fromNode, String toNode, double weight) {
-        this.fromNode = fromNode;
-        this.toNode = toNode;
-        this.weight = weight;
-    }
-
-    public String getFromNode() {
-        return fromNode;
-    }
-
-    public void setFromNode(String fromNode) {
-        this.fromNode = fromNode;
-    }
-
-    public String getToNode() {
-        return toNode;
-    }
-
-    public void setToNode(String toNode) {
-        this.toNode = toNode;
-    }
-
-    public double getWeight() {
-        return weight;
-    }
-
-    public void setWeight(double weight) {
-        this.weight = weight;
-    }
-
-    public EdgeKSP clone() {
-        return new EdgeKSP(fromNode, toNode, weight);
-    }
-
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("(");
-        sb.append(fromNode);
-        sb.append(",");
-        sb.append(toNode);
-        sb.append("){");
-        sb.append(weight);
-        sb.append("}");
-
-        return sb.toString();
-    }
-
-    public boolean equals(EdgeKSP edge2) {
-        if (hasSameEndpoints(edge2) && weight == edge2.getWeight())
-            return true;
-
-        return false;
-    }
-
-    public boolean hasSameEndpoints(EdgeKSP edge2) {
-        if (fromNode.equals(edge2.getFromNode()) && toNode.equals(edge2.getToNode()))
-            return true;
-
-        return false;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java
deleted file mode 100644
index 21aac6af19..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java
+++ /dev/null
@@ -1,247 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-/**
- * The Graph class implements a weighted, directed graph using an adjacency list representation.
- *
- * Created by brandonsmock on 6/1/15.
- */
-
-import java.io.*;
-import java.util.*;
-
-public class GraphKSP {
-    private HashMap<String,NodeKSP> nodes;
-
-    public GraphKSP() {
-        nodes = new HashMap<String,NodeKSP>();
-    }
-
-    public GraphKSP(String filename) {
-        this();
-        readFromFile(filename);
-    }
-
-    public GraphKSP(HashMap<String,NodeKSP> nodes) {
-        this.nodes = nodes;
-    }
-
-    public int numNodes() {
-        return nodes.size();
-    }
-
-    public int numEdges() {
-        int edgeCount = 0;
-        for (NodeKSP node : nodes.values()) {
-            edgeCount += node.getEdges().size();
-        }
-        return edgeCount;
-    }
-
-    public void addNode(String label) {
-        if (!nodes.containsKey(label))
-            nodes.put(label,new NodeKSP(label));
-    }
-
-    public void addNode(NodeKSP node) {
-        String label = node.getLabel();
-        if (!nodes.containsKey(label))
-            nodes.put(label,node);
-    }
-
-    public void addEdge(String label1, String label2, Double weight) {
-        if (!nodes.containsKey(label1))
-            addNode(label1);
-        if (!nodes.containsKey(label2))
-            addNode(label2);
-        nodes.get(label1).addEdge(label2,weight);
-    }
-
-    public void addEdge(EdgeKSP edge) {
-        addEdge(edge.getFromNode(),edge.getToNode(),edge.getWeight());
-    }
-
-    public void addEdges(List<EdgeKSP> edges) {
-        for (EdgeKSP edge : edges) {
-            addEdge(edge);
-        }
-    }
-
-    public EdgeKSP removeEdge(String label1, String label2) {
-        if (nodes.containsKey(label1)) {
-            double weight = nodes.get(label1).removeEdge(label2);
-            if (weight != Double.MAX_VALUE) {
-                return new EdgeKSP(label1, label2, weight);
-            }
-        }
-
-        return null;
-    }
-
-    public double getEdgeWeight(String label1, String label2) {
-        if (nodes.containsKey(label1)) {
-            NodeKSP node1 = nodes.get(label1);
-            if (node1.getNeighbors().containsKey(label2)) {
-                return node1.getNeighbors().get(label2);
-            }
-        }
-
-        return Double.MAX_VALUE;
-    }
-
-    public HashMap<String,NodeKSP> getNodes() {
-        return nodes;
-    }
-
-    public List<EdgeKSP> getEdgeList() {
-        List<EdgeKSP> edgeList = new LinkedList<EdgeKSP>();
-
-        for (NodeKSP node : nodes.values()) {
-            edgeList.addAll(node.getEdges());
-        }
-
-        return edgeList;
-    }
-
-    public Set<String> getNodeLabels() {
-        return nodes.keySet();
-    }
-
-    public NodeKSP getNode(String label) {
-        return nodes.get(label);
-    }
-
-    public List<EdgeKSP> removeNode(String label) {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-        if (nodes.containsKey(label)) {
-            NodeKSP node = nodes.remove(label);
-            edges.addAll(node.getEdges());
-            edges.addAll(removeEdgesToNode(label));
-        }
-
-        return edges;
-    }
-
-    public List<EdgeKSP> removeEdgesToNode(String label) {
-        List<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-        for (NodeKSP node : nodes.values()) {
-            if (node.getAdjacencyList().contains(label)) {
-                double weight = node.removeEdge(label);
-                edges.add(new EdgeKSP(node.getLabel(),label,weight));
-            }
-        }
-        return edges;
-    }
-
-
-
-    public GraphKSP transpose() {
-        HashMap<String,NodeKSP> newNodes = new HashMap<String, NodeKSP>();
-
-        Iterator<String> it = nodes.keySet().iterator();
-        while (it.hasNext()) {
-            String nodeLabel = it.next();
-            newNodes.put(nodeLabel,new NodeKSP(nodeLabel));
-        }
-
-        it = nodes.keySet().iterator();
-        while (it.hasNext()) {
-            String nodeLabel = it.next();
-            NodeKSP node = nodes.get(nodeLabel);
-            Set<String> adjacencyList = node.getAdjacencyList();
-            Iterator<String> alIt = adjacencyList.iterator();
-            HashMap<String, Double> neighbors = node.getNeighbors();
-            while (alIt.hasNext()) {
-                String neighborLabel = alIt.next();
-                newNodes.get(neighborLabel).addEdge(nodeLabel,neighbors.get(neighborLabel));
-            }
-        }
-
-        return new GraphKSP(newNodes);
-    }
-
-    public void clear() {
-        nodes = new HashMap<String,NodeKSP>();
-    }
-
-    public void readFromFile(String fileName) {
-        try {
-            BufferedReader in = new BufferedReader(new FileReader(fileName));
-
-            String line = in.readLine();
-
-            while (line != null) {
-                String[] edgeDescription = line.split("\\s");
-                if (edgeDescription.length == 3) {
-                    addEdge(edgeDescription[0],edgeDescription[1],Double.parseDouble(edgeDescription[2]));
-                    //addEdge(edgeDescription[1],edgeDescription[0],Double.parseDouble(edgeDescription[2]));
-                }
-                line = in.readLine();
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    public String toString() {
-        StringBuilder graphStringB = new StringBuilder();
-        Iterator<String> it = nodes.keySet().iterator();
-        while (it.hasNext()) {
-            String nodeLabel = it.next();
-            graphStringB.append(nodeLabel.toString());
-            graphStringB.append(": {");
-            NodeKSP node = nodes.get(nodeLabel);
-            Set<String> adjacencyList = node.getAdjacencyList();
-            Iterator<String> alIt = adjacencyList.iterator();
-            HashMap<String, Double> neighbors = node.getNeighbors();
-            while (alIt.hasNext()) {
-                String neighborLabel = alIt.next();
-                graphStringB.append(neighborLabel.toString());
-                graphStringB.append(": ");
-                graphStringB.append(neighbors.get(neighborLabel));
-                if (alIt.hasNext())
-                    graphStringB.append(", ");
-            }
-            graphStringB.append("}");
-            graphStringB.append("\n");
-        }
-
-        return graphStringB.toString();
-    }
-
-    public void graphToFile(String filename) {
-        BufferedWriter writer = null;
-        try {
-            File subgraphFile = new File(filename);
-
-            // This will output the full path where the file will be written to...
-            System.out.println(subgraphFile.getCanonicalPath());
-
-            writer = new BufferedWriter(new FileWriter(subgraphFile));
-            writer.write(Integer.toString(nodes.size()) + "\n\n");
-
-            Iterator<NodeKSP> it = nodes.values().iterator();
-            while (it.hasNext()) {
-                NodeKSP node = it.next();
-                String nodeLabel = node.getLabel();
-                if (nodes.containsKey(nodeLabel)) {
-                    HashMap<String,Double> neighbors = node.getNeighbors();
-                    Iterator<String> it2 = neighbors.keySet().iterator();
-                    while (it2.hasNext()) {
-                        String nodeLabel2 = it2.next();
-                        if (nodes.containsKey(nodeLabel2)) {
-                            writer.write(nodeLabel + " " + nodeLabel2 + " " + neighbors.get(nodeLabel2) + "\n");
-                        }
-                    }
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                // Close the writer regardless of what happens...
-                writer.close();
-            } catch (Exception e) {
-            }
-        }
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java
deleted file mode 100644
index ded61bf24d..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-/**
- * The Node class implements a node in a directed graph keyed on a label of type String, with adjacency lists for
- * representing edges.
- *
- * Created by brandonsmock on 5/31/15.
- */
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Set;
-
-public class NodeKSP {
-    protected String label;
-    protected HashMap<String,Double> neighbors; // adjacency list, with HashMap for each edge weight
-
-    public NodeKSP() {
-        neighbors = new HashMap();
-    }
-
-    public NodeKSP(String label) {
-        this.label = label;
-        neighbors = new HashMap();
-    }
-
-    public String getLabel() {
-        return label;
-    }
-
-    public void setLabel(String label) {
-        this.label = label;
-    }
-
-    public HashMap<String, Double> getNeighbors() {
-        return neighbors;
-    }
-
-    public void setNeighbors(HashMap<String, Double> neighbors) {
-        this.neighbors = neighbors;
-    }
-
-    public void addEdge(String toNodeLabel,Double weight) {
-        neighbors.put(toNodeLabel, weight);
-    }
-
-    public double removeEdge(String toNodeLabel) {
-        if (neighbors.containsKey(toNodeLabel)) {
-            double weight = neighbors.get(toNodeLabel);
-            neighbors.remove(toNodeLabel);
-            return weight;
-        }
-
-        return Double.MAX_VALUE;
-    }
-
-    public Set<String> getAdjacencyList() {
-        return neighbors.keySet();
-    }
-
-    public LinkedList<EdgeKSP> getEdges() {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-        for (String toNodeLabel : neighbors.keySet()) {
-            edges.add(new EdgeKSP(label,toNodeLabel,neighbors.get(toNodeLabel)));
-        }
-
-        return edges;
-    }
-    
-    public String toString() {
-        StringBuilder nodeStringB = new StringBuilder();
-        nodeStringB.append(label);
-        nodeStringB.append(": {");
-        Set<String> adjacencyList = this.getAdjacencyList();
-        Iterator<String> alIt = adjacencyList.iterator();
-        HashMap<String, Double> neighbors = this.getNeighbors();
-        while (alIt.hasNext()) {
-            String neighborLabel = alIt.next();
-            nodeStringB.append(neighborLabel.toString());
-            nodeStringB.append(": ");
-            nodeStringB.append(neighbors.get(neighborLabel));
-            if (alIt.hasNext())
-                nodeStringB.append(", ");
-        }
-        nodeStringB.append("}");
-        nodeStringB.append("\n");
-
-        return nodeStringB.toString();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java
deleted file mode 100644
index e4a917814f..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-import java.util.*;
-
-/**
- * The Path class implements a path in a weighted, directed graph as a sequence of Edges.
- *
- * Created by Brandon Smock on 6/18/15.
- */
-public class PathKSP implements Cloneable, Comparable<PathKSP> {
-    private LinkedList<EdgeKSP> edges;
-    private double totalCost;
-
-    public PathKSP() {
-        edges = new LinkedList<EdgeKSP>();
-        totalCost = 0;
-    }
-
-    public PathKSP(double totalCost) {
-        edges = new LinkedList<EdgeKSP>();
-        this.totalCost = totalCost;
-    }
-
-    public PathKSP(LinkedList<EdgeKSP> edges) {
-        this.edges = edges;
-        totalCost = 0;
-        for (EdgeKSP edge : edges) {
-            totalCost += edge.getWeight();
-        }
-    }
-
-    public PathKSP(LinkedList<EdgeKSP> edges, double totalCost) {
-        this.edges = edges;
-        this.totalCost = totalCost;
-    }
-
-    public LinkedList<EdgeKSP> getEdges() {
-        return edges;
-    }
-
-    public void setEdges(LinkedList<EdgeKSP> edges) {
-        this.edges = edges;
-    }
-
-    public List<String> getNodes() {
-        LinkedList<String> nodes = new LinkedList<String>();
-
-        for (EdgeKSP edge : edges) {
-            nodes.add(edge.getFromNode());
-        }
-
-        EdgeKSP lastEdge = edges.getLast();
-        if (lastEdge != null) {
-            nodes.add(lastEdge.getToNode());
-        }
-
-        return nodes;
-    }
-
-    public double getTotalCost() {
-        return totalCost;
-    }
-
-    public void setTotalCost(double totalCost) {
-        this.totalCost = totalCost;
-    }
-
-    public void addFirstNode(String nodeLabel) {
-        String firstNode = edges.getFirst().getFromNode();
-        edges.addFirst(new EdgeKSP(nodeLabel, firstNode,0));
-    }
-
-    public void addFirst(EdgeKSP edge) {
-        edges.addFirst(edge);
-        totalCost += edge.getWeight();
-    }
-
-    public void add(EdgeKSP edge) {
-        edges.add(edge);
-        totalCost += edge.getWeight();
-    }
-
-    public void addLastNode(String nodeLabel) {
-        String lastNode = edges.getLast().getToNode();
-        edges.addLast(new EdgeKSP(lastNode, nodeLabel,0));
-    }
-
-    public int size() {
-        return edges.size();
-    }
-
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        int numEdges = edges.size();
-        sb.append(totalCost);
-        sb.append(": [");
-        if (numEdges > 0) {
-            for (int i = 0; i < edges.size(); i++) {
-                sb.append(edges.get(i).getFromNode().toString());
-                sb.append("-");
-            }
-
-            sb.append(edges.getLast().getToNode().toString());
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-
-/*    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        Path path = (Path) o;
-
-        if (Double.compare(path.totalCost, totalCost) != 0) return false;
-        if (!edges.equals(path.edges)) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result;
-        long temp;
-        result = edges.hashCode();
-        temp = Double.doubleToLongBits(totalCost);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        return result;
-    }*/
-
-    public boolean equals(PathKSP path2) {
-        if (path2 == null)
-            return false;
-
-        LinkedList<EdgeKSP> edges2 = path2.getEdges();
-
-        int numEdges1 = edges.size();
-        int numEdges2 = edges2.size();
-
-        if (numEdges1 != numEdges2) {
-            return false;
-        }
-
-        for (int i = 0; i < numEdges1; i++) {
-            EdgeKSP edge1 = edges.get(i);
-            EdgeKSP edge2 = edges2.get(i);
-            if (!edge1.getFromNode().equals(edge2.getFromNode()))
-                return false;
-            if (!edge1.getToNode().equals(edge2.getToNode()))
-                return false;
-        }
-
-        return true;
-    }
-
-    public int compareTo(PathKSP path2) {
-        double path2Cost = path2.getTotalCost();
-        if (totalCost == path2Cost)
-            return 0;
-        if (totalCost > path2Cost)
-            return 1;
-        return -1;
-    }
-
-    public PathKSP clone() {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-
-        for (EdgeKSP edge : this.edges) {
-            edges.add(edge.clone());
-        }
-
-        return new PathKSP(edges);
-    }
-
-    public PathKSP shallowClone() {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-
-        for (EdgeKSP edge : this.edges) {
-            edges.add(edge);
-        }
-
-        return new PathKSP(edges,this.totalCost);
-    }
-
-    public PathKSP cloneTo(int i) {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-        int l = this.edges.size();
-        if (i > l)
-            i = l;
-
-        //for (Edge edge : this.edges.subList(0,i)) {
-        for (int j = 0; j < i; j++) {
-            edges.add(this.edges.get(j).clone());
-        }
-
-        return new PathKSP(edges);
-    }
-
-    public PathKSP cloneFrom(int i) {
-        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
-
-        for (EdgeKSP edge : this.edges.subList(i,this.edges.size())) {
-            edges.add(edge.clone());
-        }
-
-        return new PathKSP(edges);
-    }
-
-    public void addPath(PathKSP p2) {
-        // ADD CHECK TO SEE THAT PATH P2'S FIRST NODE IS SAME AS THIS PATH'S LAST NODE
-
-        this.edges.addAll(p2.getEdges());
-        this.totalCost += p2.getTotalCost();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java
deleted file mode 100644
index 7a105d415d..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.graphhopper.routing.ksp;
-
-import java.util.HashMap;
-
-/**
- * Created by brandonsmock on 6/8/15.
- */
-public class ShortestPathTreeKSP {
-    private HashMap<String,DijkstraNodeKSP> nodes;
-    private final String root;
-
-    public ShortestPathTreeKSP() {
-        this.nodes = new HashMap<String, DijkstraNodeKSP>();
-        this.root = "";
-    }
-
-    public ShortestPathTreeKSP(String root) {
-        this.nodes = new HashMap<String, DijkstraNodeKSP>();
-        this.root = root;
-    }
-
-    public HashMap<String, DijkstraNodeKSP> getNodes() {
-        return nodes;
-    }
-
-    public void setNodes(HashMap<String, DijkstraNodeKSP> nodes) {
-        this.nodes = nodes;
-    }
-
-    public String getRoot() {
-        return root;
-    }
-
-    public void add(DijkstraNodeKSP newNode) {
-        nodes.put(newNode.getLabel(),newNode);
-    }
-
-    public void setParentOf(String node, String parent) {
-//        if (parent != null && !nodes.containsKey(parent)) {
-//            System.out.println("Warning: parent node not present in tree.");
-//        }
-        if (!nodes.containsKey(node))
-            nodes.put(node,new DijkstraNodeKSP(node));
-
-        nodes.get(node).setParent(parent);
-
-    }
-
-    public String getParentOf(String node) {
-        if (nodes.containsKey(node))
-            return nodes.get(node).getParent();
-        else
-            return null;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java
deleted file mode 100644
index 49e120b569..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package edu.ufl.cise.bsmock.graph;
-
-/**
- * The WeightedEdge class implements standard properties and methods for a weighted edge in a directed graph.
- *
- * Created by Brandon Smock on 6/6/15.
- */
-public class WeightedEdge implements Comparable<WeightedEdge> {
-    private String sourceLabel;
-    private String targetLabel;
-    private double edgeWeight = 0.0;
-
-    public WeightedEdge(String targetLabel, double edgeWeight) {
-        this.targetLabel = targetLabel;
-        this.edgeWeight = edgeWeight;
-    }
-
-    public WeightedEdge(String sourceLabel, String targetLabel, double edgeWeight) {
-        this.sourceLabel = sourceLabel;
-        this.targetLabel = targetLabel;
-        this.edgeWeight = edgeWeight;
-    }
-
-    public String getSourceLabel() {
-        return sourceLabel;
-    }
-
-    public void setSourceLabel(String sourceLabel) {
-        this.sourceLabel = sourceLabel;
-    }
-
-    public String getTargetLabel() {
-        return targetLabel;
-    }
-
-    public void setTargetLabel(String targetLabel) {
-        this.targetLabel = targetLabel;
-    }
-
-    public double getEdgeWeight() {
-        return edgeWeight;
-    }
-
-    public void setEdgeWeight(double edgeWeight) {
-        this.edgeWeight = edgeWeight;
-    }
-
-    public int compareTo(WeightedEdge comparedObject) {
-        double weight1 = this.getEdgeWeight();
-        double weight2 = comparedObject.getEdgeWeight();
-
-        if (weight1 == weight2)
-            return 0;
-        if (weight1 > weight2)
-            return 1;
-        return -1;
-    }
-}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/RoutingExample.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
similarity index 99%
rename from reader-osm/src/main/java/com/graphhopper/reader/osm/RoutingExample.java
rename to reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
index 9c5f1ea545..7e16f0f868 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/RoutingExample.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
@@ -15,7 +15,7 @@
 /**
  * Created by isaac on 3/8/16.
  */
-public class RoutingExample {
+public class runFastest {
 
     private static final TranslationMap trMap = new TranslationMap().doImport();
     private static final Translation usTR = trMap.getWithFallBack(Locale.US);
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
new file mode 100644
index 0000000000..7c260a0372
--- /dev/null
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -0,0 +1,160 @@
+package com.graphhopper.reader.osm;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.*;
+
+import java.util.*;
+
+import java.io.*;
+
+
+/**
+ * Created by isaac on 3/8/16.
+ */
+public class runKSP {
+
+    private static final TranslationMap trMap = new TranslationMap().doImport();
+    private static final Translation usTR = trMap.getWithFallBack(Locale.US);
+
+    public static void process_routes(String city, String route_type) throws Exception {
+
+        // set paths
+        String osmFile = "./reader-osm/files/";
+        String graphFolder = "./reader-osm/target/tmp/";
+        String inputPointsFN = "../data/output/";
+        String outputPointsFN = "../data/output/";
+        if (city.equals("SF")) {
+            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sf";
+            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sf_" + route_type + "_graphhopper_routes.csv";
+        } else if (city.equals("NYC")) {
+            osmFile = osmFile + "new-york_new-york.osm.pbf";
+            graphFolder = graphFolder + "ghosm_nyc";
+            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_graphhopper_routes_TEST.csv";
+        } else {
+            return;
+        }
+
+        // create one GraphHopper instance
+        GraphHopper hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
+        hopper.setDataReaderFile(osmFile);
+        // where to store graphhopper files?
+        hopper.setGraphHopperLocation(graphFolder);
+        hopper.setEncodingManager(new EncodingManager("car"));
+
+        ArrayList<float[]> inputPoints = new ArrayList<float[]>();
+        ArrayList<String> id_to_points = new ArrayList<String>();
+        ArrayList<String> maneuvers = new ArrayList<>();
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
+        FileWriter sc_out = new FileWriter(outputPointsFN, true);
+        sc_out.write("ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers" +
+                System.getProperty("line.separator"));
+        String header = sc_in.nextLine();
+        String od_id;
+        float laF;
+        float loF;
+        float laT;
+        float loT;
+        float idx = 0;
+        System.out.println("Input data points header: " + header);
+        while (sc_in.hasNext()) {
+            idx = idx + 1;
+            String line = sc_in.nextLine();
+            String[] vals = line.split(",");
+            od_id = vals[0];
+            loF = Float.valueOf(vals[1]);
+            laF = Float.valueOf(vals[2]);
+            loT = Float.valueOf(vals[3]);
+            laT = Float.valueOf(vals[4]);
+            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
+            id_to_points.add(od_id);
+        }
+        int numPairs = inputPoints.size();
+        System.out.println(numPairs + " origin-destination pairs.");
+
+        // now this can take minutes if it imports or a few seconds for loading
+        // of course this is dependent on the area you import
+        hopper.importOrLoad();
+
+        // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
+        float[] points;
+        PointList pointList = null;
+        List<Map<String, Object>> iList = null;
+        int routes_skipped = 0;
+        for (int i=0; i<numPairs; i++) {
+            points = inputPoints.get(i);
+            od_id = id_to_points.get(i);
+            GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                    setWeighting("fastest").
+                    setVehicle("car").
+                    setLocale(Locale.US).
+                    setAlgorithm("ksp");
+            GHResponse rsp = hopper.route(req);
+            System.out.println("Num Responses: " + rsp.getAll().size());
+
+            // first check for errors
+            if (rsp.hasErrors()) {
+                // handle them!
+                System.out.println(rsp.getErrors().toString());
+                System.out.println(i + ": Skipping.");
+                sc_out.write(od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
+                        + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator"));
+                routes_skipped++;
+                continue;
+            }
+
+            // use the best path, see the GHResponse class for more possibilities.
+            List<PathWrapper> paths = rsp.getAll();
+            for (PathWrapper path : paths) {
+
+                // points, distance in meters and time in seconds (convert from ms) of the full path
+                pointList = path.getPoints();
+                double distance = Math.round(path.getDistance() * 100) / 100;
+                long timeInSec = path.getTime() / 1000;
+                InstructionList il = path.getInstructions();
+                int numDirections = il.getSize();
+                // iterate over every turn instruction
+                maneuvers.clear();
+                for (Instruction instruction : il) {
+                    maneuvers.add(instruction.getSimpleTurnDescription());
+                    // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
+                }
+                sc_out.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
+                        "," + maneuvers.toString() + System.getProperty("line.separator"));
+                System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections);
+            }
+            break;
+
+            // or get the json
+            //iList = il.createJson();
+            //System.out.println("JSON: " + iList);
+
+            // or get the result as gpx entries:
+            //List<GPXEntry> list = il.createGPXList();
+            //System.out.println("GPX: " + list);
+        }
+        // example JSON
+        //System.out.println("Example JSON: " + iList);
+        System.out.println(routes_skipped + " routes skipped out of " + numPairs);
+        sc_out.close();
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        // PBF from: https://mapzen.com/data/metro-extracts/
+        // NYC Grid
+        process_routes("NYC", "grid");
+        // NYC Random
+        //process_routes("NYC", "rand");
+        // SF Grid
+        //process_routes("SF", "grid");
+        // SF Random
+        //process_routes("SF", "rand");
+    }
+}
