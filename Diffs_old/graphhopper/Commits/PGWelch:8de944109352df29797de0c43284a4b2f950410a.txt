diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
index 981cafaeed..049d5744ee 100644
--- a/reader-shp/pom.xml
+++ b/reader-shp/pom.xml
@@ -58,10 +58,10 @@
         </dependency>
         
         <dependency>
+        	<!--  Inlucde the pbf reader for test purposes -->
             <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
+            <artifactId>graphhopper-reader-osm</artifactId>
             <version>${project.parent.version}</version>
-            <type>test-jar</type>
             <scope>test</scope>
         </dependency>        
     </dependencies>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java
index 725bb0f58e..a4c1492547 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphhopperShp.java
@@ -1,13 +1,27 @@
 package com.graphhopper.reader.shp;
 
+import java.util.HashSet;
+
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.shp.OSMShapeFileReader.EdgeAddedListener;
 import com.graphhopper.storage.GraphHopperStorage;
 
 public class GraphhopperShp extends GraphHopper {
+	private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
+
     @Override
     protected DataReader createReader(GraphHopperStorage ghStorage) {
-        return initDataReader(new OSMShapeFileReader(ghStorage));
+    	OSMShapeFileReader reader= new OSMShapeFileReader(ghStorage);
+    	for(EdgeAddedListener l:edgeAddedListeners){
+    		reader.addListener(l);
+    	}
+        return initDataReader(reader);
     }
+    
+
+	public void addListener(EdgeAddedListener l){
+		edgeAddedListeners.add(l);
+	}
 
 }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
index e0305d0b74..b693b83791 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.List;
 
 import org.geotools.data.DataStore;
@@ -22,27 +23,54 @@
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.GHPoint;
 import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.LineString;
 import com.vividsolutions.jts.geom.MultiLineString;
 
-import gnu.trove.map.hash.THashMap;
+import gnu.trove.impl.Constants;
+import gnu.trove.map.hash.TObjectIntHashMap;
 
 /**
  * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It extracts the data as per the structure of
  * shape files
  *
- * @author Vikas Veshishth
+ * @author Vikas Veshishth, Philip Welch
  */
 public class OSMShapeFileReader extends ShapeFileReader {
+	private static final int COORD_STATE_UNKNOWN = -1;
+	private static final int COORD_STATE_PILLAR = -2;
+	private static final int FIRST_NODE_ID = 1;
 	private static final String[] DIRECT_COPY_TAGS = new String[] { "name" };
 	private File roadsFile;
-	private THashMap<Coordinate, Integer> towerCoordIdMap = new THashMap<Coordinate, Integer>();
+	private TObjectIntHashMap<Coordinate> coordState = new TObjectIntHashMap<>(Constants.DEFAULT_CAPACITY, Constants.DEFAULT_LOAD_FACTOR,
+			COORD_STATE_UNKNOWN);
 	private final DistanceCalc distCalc = Helper.DIST_EARTH;
 	private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
+	private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
+	private int nextNodeId = FIRST_NODE_ID;
 
 	public OSMShapeFileReader(GraphHopperStorage ghStorage) {
 		super(ghStorage);
 	}
 
+	private List<Coordinate[]> getCoords(Object o) {
+		ArrayList<Coordinate[]> ret = new ArrayList<>();
+		if (o == null) {
+			return ret;
+		}
+
+		if (o instanceof LineString) {
+			ret.add(((LineString) o).getCoordinates());
+		} else if (o instanceof MultiLineString) {
+			MultiLineString mls = (MultiLineString) o;
+			int n = mls.getNumGeometries();
+			for (int i = 0; i < n; i++) {
+				ret.add(mls.getGeometryN(i).getCoordinates());
+			}
+		}
+
+		return ret;
+	}
+
 	@Override
 	void processJunctions() throws IOException {
 		{
@@ -53,24 +81,39 @@ void processJunctions() throws IOException {
 				dataStore = openShapefileDataStore(roadsFile);
 				roads = getFeatureIerator(dataStore);
 
+				HashSet<Coordinate> tmpSet = new HashSet<>();
 				while (roads.hasNext()) {
 					SimpleFeature road = roads.next();
 
-					MultiLineString geom = (MultiLineString) road.getDefaultGeometry();
-					if (geom.getNumGeometries() != 1) {
-						// TODO is this an error? Are roads split if they're too long?
-						// Will getting all coordinates as below still lead sensible results,
-						// providing the individual linestrings are digitised in a sensible order?
-						throw new RuntimeException("Found road with more than one geometry, OSM id " + getOSMId(road));
-					}
-					
-					Coordinate[] points = geom.getCoordinates();
+					for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
+						tmpSet.clear();
+						for (int i = 0; i < points.length; i++) {
+							Coordinate c = points[i];
 
-					Coordinate start = points[0];
-					Coordinate end = points[points.length - 1];
+							// don't add the same coord twice for the same edge - happens with bad geometry, i.e.
+							// duplicate coords or a road which forms a circle (e.g. roundabout)
+							if (tmpSet.contains(c)) {
+								continue;
+							}
+							tmpSet.add(c);
 
-					checkAndAdd(start);
-					checkAndAdd(end);
+							// skip if its already a node
+							int state = coordState.get(c);
+							if (state >= FIRST_NODE_ID) {
+								continue;
+							}
+
+							if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
+								// turn into a node if its the first or last point, or already appeared in another edge
+								int nodeId = nextNodeId++;
+								coordState.put(c, nodeId);
+								saveTowerPosition(nodeId, c);
+							} else if(state == COORD_STATE_UNKNOWN){
+								// mark it as a pillar (which may get upgraded to an edge later)
+								coordState.put(c, COORD_STATE_PILLAR);
+							}
+						}
+					}
 
 				}
 			} finally {
@@ -82,7 +125,7 @@ void processJunctions() throws IOException {
 				}
 			}
 
-			LOGGER.info("Number of junction points : " + towerCoordIdMap.size());
+			LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
 
 		}
 	}
@@ -100,37 +143,37 @@ void processRoads() throws IOException {
 			while (roads.hasNext()) {
 				SimpleFeature road = roads.next();
 
-				MultiLineString mls = (MultiLineString) road.getDefaultGeometry();
-
-				Coordinate[] points = mls.getCoordinates();
-
-				// Parse all points in the geometry, splitting into individual graphhopper edges
-				// whenever we find a node that's a start or end node elsewhere (can happen commonly
-				// with main roads that have several side roads coming off them).
-				Coordinate startTower = null;
-				List<Coordinate> pillars = new ArrayList<Coordinate>();
-				for (Coordinate point : points) {
-					if (startTower == null) {
-						startTower = point;
-					} else {
-						if (towerCoordIdMap.containsKey(point)) {
-							int fromTower = towerCoordIdMap.get(startTower);
-							int toTower = towerCoordIdMap.get(point);
-
-							// get distance and estimated centres
-							double distance = getWayLength(startTower, pillars, point);
-							GHPoint estmCentre = new GHPoint(0.5 * (lat(startTower) + lat(point)), 0.5 * (lng(startTower) + lng(point)));
-							PointList pillarNodes = new PointList(pillars.size(), false);
-
-							for (Coordinate pillar : pillars) {
-								pillarNodes.add(lat(pillar), lng(pillar));
-							}
+				for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
 
-							addEdge(fromTower, toTower, road, distance, estmCentre,pillarNodes);
-							startTower = point;
-							pillars.clear();
+					// Parse all points in the geometry, splitting into individual graphhopper edges
+					// whenever we find a node in the list of points
+					Coordinate startTowerPnt = null;
+					List<Coordinate> pillars = new ArrayList<Coordinate>();
+					for (Coordinate point : points) {
+						if (startTowerPnt == null) {
+							startTowerPnt = point;
 						} else {
-							pillars.add(point);
+							int state = coordState.get(point);
+							if (state >= FIRST_NODE_ID) {
+								int fromTowerNodeId = coordState.get(startTowerPnt);
+								int toTowerNodeId = state;
+
+								// get distance and estimated centres
+								double distance = getWayLength(startTowerPnt, pillars, point);
+								GHPoint estmCentre = new GHPoint(0.5 * (lat(startTowerPnt) + lat(point)),
+										0.5 * (lng(startTowerPnt) + lng(point)));
+								PointList pillarNodes = new PointList(pillars.size(), false);
+
+								for (Coordinate pillar : pillars) {
+									pillarNodes.add(lat(pillar), lng(pillar));
+								}
+
+								addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre, pillarNodes);
+								startTowerPnt = point;
+								pillars.clear();
+							} else {
+								pillars.add(point);
+							}
 						}
 					}
 				}
@@ -162,15 +205,6 @@ private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordina
 		return distance;
 	}
 
-
-	private void checkAndAdd(Coordinate point) {
-		if (!towerCoordIdMap.containsKey(point)) {
-			int nodeId = towerCoordIdMap.size();
-			towerCoordIdMap.put(point, nodeId);
-			saveTowerPosition(nodeId, point);
-		}
-	}
-
 	@Override
 	public DataReader setFile(File file) {
 		this.roadsFile = file;
@@ -200,7 +234,11 @@ public Date getDataDate() {
 		return null;
 	}
 
-	private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,GHPoint estmCentre , PointList pillarNodes) {
+	public static interface EdgeAddedListener {
+		void edgeAdded(ReaderWay way, EdgeIteratorState edge);
+	}
+
+	private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance, GHPoint estmCentre, PointList pillarNodes) {
 		EdgeIteratorState edge = graph.edge(fromTower, toTower);
 
 		// read the OSM id, should never be null
@@ -219,10 +257,10 @@ private void addEdge(int fromTower, int toTower, SimpleFeature road, double dist
 		if (type != null) {
 			way.setTag("highway", type.toString());
 		}
-		
+
 		// read maxspeed filtering for 0 which for Geofabrik shapefiles appears to correspond to no tag
 		Object maxSpeed = road.getAttribute("maxspeed");
-		if(maxSpeed!=null && !maxSpeed.toString().trim().equals("0")){
+		if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
 			way.setTag("maxspeed", maxSpeed.toString());
 		}
 
@@ -239,21 +277,19 @@ private void addEdge(int fromTower, int toTower, SimpleFeature road, double dist
 			// Geofabrik is using an odd convention for oneway field in shapefile.
 			// We map back to the standard convention so that tag can be dealt with correctly by the flag encoder.
 			String val = oneway.toString().trim().toLowerCase();
-			if(val.equals("b")){
+			if (val.equals("b")) {
 				// both ways
 				val = "no";
-			}else if (val.equals("t")){
+			} else if (val.equals("t")) {
 				// one way against the direction of digitisation
 				val = "-1";
-			}
-			else if (val.equals("f")){
+			} else if (val.equals("f")) {
 				// one way Forward in the direction of digitisation
 				val = "yes";
-			}
-			else{
+			} else {
 				throw new RuntimeException("Unrecognised value of oneway field \"" + val + "\" found in road with OSM id " + id);
 			}
-			
+
 			way.setTag("oneway", val);
 		}
 
@@ -273,6 +309,13 @@ else if (val.equals("f")){
 		edge.setDistance(distance);
 		edge.setFlags(wayFlags);
 		edge.setWayGeometry(pillarNodes);
+
+		if (edgeAddedListeners.size() > 0) {
+			// check size first so we only allocate the iterator if we have listeners
+			for (EdgeAddedListener l : edgeAddedListeners) {
+				l.edgeAdded(way, edge);
+			}
+		}
 	}
 
 	private long getOSMId(SimpleFeature road) {
@@ -280,4 +323,7 @@ private long getOSMId(SimpleFeature road) {
 		return id;
 	}
 
+	public void addListener(EdgeAddedListener l) {
+		edgeAddedListeners.add(l);
+	}
 }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
new file mode 100644
index 0000000000..7aafb7ffe1
--- /dev/null
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
@@ -0,0 +1,17 @@
+package com.graphhopper.reader.shp;
+
+import com.graphhopper.util.PointList;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.GeometryFactory;
+
+public class Utils {
+	public static String toWKT(PointList list){
+		int n = list.size();
+		GeometryFactory factory = new GeometryFactory();
+		Coordinate [] coords = new Coordinate[n];
+		for(int i =0 ; i< coords.length ; i++){
+			coords[i] = new Coordinate(list.getLon(i), list.getLat(i));
+		}
+		return factory.createLineString(coords).toText();	
+	}
+}
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
index 54602e4c9d..c32d7122b4 100644
--- a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
+++ b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
@@ -1,100 +1,290 @@
 package com.graphhopper.reader.shp;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import java.io.File;
-import java.io.IOException;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.DoubleSummaryStatistics;
+import java.util.Random;
 
-import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.Before;
+import org.junit.BeforeClass;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.PathWrapper;
-import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.GHPoint;
 
 /**
- * Tests the ShapeFileReader with the normal helper initialized.
- * <p>
- * 
- * @author Vikas Veshishth
+
+ * @author Philip Welch
  */
 public class ShapeFileReaderTest {
 
-	private final String shapefile = "/shapefiles/gis.osm_roads_free_1.shp";
-	private final String tempOutputDirectory = "./target/tmp/test-db";
-	// private CarFlagEncoder carEncoder;
-
-	@Before
-	public void setUp() {
-		new File(tempOutputDirectory).mkdirs();
-	}
+	private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
+	private static final String pbf = "/data/malta-latest.osm.pbf";
+	private static final String tempOutputDirFromShp = "target/test-db-shp";
+	private static final String tempOutputDirFromPbf = "target/test-db-pbf";
+	private static GraphHopper hopperShp;
+	private static GraphHopper hopperPbf;
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private static Exception BEFORE_CLASS_EXCEPTION=null;
 
-	@After
-	public void tearDown() {
-		Helper.removeDir(new File(tempOutputDirectory));
-	}
+	private static class FromToPair{
+		final GHPoint from;
+		final GHPoint to;	
+		
+		FromToPair(double fromLat, double fromLng, double toLat, double toLng) {
+			this( new GHPoint(fromLat, fromLng), new GHPoint(toLat, toLng));
+		}
 
+		FromToPair(GHPoint from, GHPoint to) {
+			this.from = from;
+			this.to = to;
+		}
 
-	private static class ExpectedDuration {
-		final GHPoint from;
-		final GHPoint to;
+		
+		PathWrapper getPath( GraphHopper hopper, boolean assertNoErrors) {
+			GHRequest request = new GHRequest(from, to).setVehicle("car");
+			GHResponse response = hopper.route(request);
+			
+			if(assertNoErrors){
+				assertFalse(response.hasErrors());				
+			}
+	
+			if(!response.hasErrors()){
+				return response.getBest();
+			}
+			return null;
+		}
+		
+	}
+	
+	private static class ExpectedDuration extends FromToPair {
 		final double minSecs;
 		final double maxSecs;
 
 		private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng, double minSecs, double maxSecs) {
-			from = new GHPoint(fromLat, fromLng);
-			to = new GHPoint(toLat, toLng);
+			super(fromLat, fromLng, toLat, toLng);
 			this.minSecs = minSecs;
 			this.maxSecs = maxSecs;
 		}
 	}
 
+	private static GraphHopper initHopper(GraphHopper gh, String inputFile, String outDir) {
+		URL resourceURL = ShapeFileReaderTest.class.getResource(inputFile);
+		try {
+			inputFile = new File(resourceURL.toURI()).getAbsolutePath();
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+
+		// turn off geometry simplification so geometry should be the same between pbf and shapefile readers
+		gh.setWayPointMaxDistance(0);
+		return gh.setStoreOnFlush(false).setDataReaderFile(inputFile).setGraphHopperLocation(new File(outDir).getAbsolutePath())
+				.setEncodingManager(new EncodingManager(new CarFlagEncoder())).setCHEnabled(false).importOrLoad();
+
+	}
+
+	/**
+	 * Build the graphs once only for the various tests
+	 */
+	@BeforeClass
+	public static void setupBeforeClass() {
+		try {
+			new File(tempOutputDirFromShp).mkdirs();
+			new File(tempOutputDirFromPbf).mkdirs();
+			
+			System.out.println("Building from shapefile");
+			hopperShp = initHopper(new GraphhopperShp(), shapefile, tempOutputDirFromShp);
+
+			System.out.println("Building from pbf");
+			hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
+
+			System.out.println("Finished building");			
+		} catch (Exception e) {
+			// Junit silently fails if we get an exception in the setup before class,
+			// so we record it here and explicitly rethrow it
+			BEFORE_CLASS_EXCEPTION = e;
+		}
+
+
+	}
+
+	@AfterClass
+	public static void teardownAfterClass() {
+		try {
+			hopperShp.close();
+			hopperShp.clean();
+		} catch (Exception e) {
+		}
+
+		try {
+			hopperPbf.close();
+			hopperPbf.clean();
+		} catch (Exception e) {
+		}
+
+	}
+
+	@Before
+	public void beforeTest()throws Exception{
+		// Rethrow the exception from @BeforeClass here so it doesn't silently fail.
+		// (Junit silently fails on exceptions thrown in @BeforeClass but not for 
+		// exceptions thrown in @Before)
+		if(BEFORE_CLASS_EXCEPTION!=null){
+			throw BEFORE_CLASS_EXCEPTION;
+		}
+	}
+	
 	@Test
-	public void testMain() throws URISyntaxException {
-		// test we can make a graph without any exceptions....
-		URL resourceURL = getClass().getResource(shapefile);
-		String shapeFile = new File(resourceURL.toURI()).getAbsolutePath();
+	public void testOneWay(){
+		// We setup 2 points very close together on a one-way street.
+		// As its a one way street, the ordering of the start and end requires going around the block to serve them.
+		// As the scenario is simple, we should get the same results from both shapefile and pbf.
+		// We should also get route distance to be many times physical distance
+		FromToPair pair = new FromToPair(35.898324,14.510729,35.898328,14.510681);
+		PathWrapper shp = pair.getPath(hopperShp,true);
+		PathWrapper pbf = pair.getPath(hopperPbf,true);
+		System.out.println("SHP:"+System.lineSeparator() +Utils.toWKT(shp.getPoints())+System.lineSeparator());
+		System.out.println("PBF:"+System.lineSeparator() +Utils.toWKT(pbf.getPoints())+System.lineSeparator());
+		double metresShp =shp.getDistance();
+		double metresPbf = pbf.getDistance();
 
-		GraphHopper hopper = new GraphhopperShp().setStoreOnFlush(false).setDataReaderFile(shapeFile)
-				.setGraphHopperLocation(tempOutputDirectory).setEncodingManager(new EncodingManager(new CarFlagEncoder()))
-				.setCHEnabled(false).importOrLoad();
+		// should be many times the physical separation between the points (as we had to go round the block)
+		double straightLineDistMetres = distCalc.calcDist(pair.from.lat, pair.from.lon,pair.to.lat, pair.to.lon);
+		assertTrue(metresShp > straightLineDistMetres * 25);
+		
+		// should be the same to within 1 cm
+		assertEquals(metresShp, metresPbf, 0.01);
+
+	}
+	
+	@Test
+	public void testGeometrySingleEdgePath()  {
+		// We choose a path along a single edge with a couple of minor bends,
+		// which we expect to give identical results...
+		FromToPair pair = new FromToPair(35.911694,14.492303, 35.911494,14.490489);
+		PointList shp = pair.getPath(hopperShp,true).getPoints();
+		PointList pbf = pair.getPath(hopperPbf,true).getPoints();
+		
+		assertTrue("The chosen edge had a couple of bends!", shp.getSize()>=2);
+		assertSameGeometry(shp, pbf);
+	}
+
+	private void assertSameGeometry(PointList shp, PointList pbf) {
+		assertEquals(shp.getSize(), pbf.getSize());
+		
+		for(int i=0;i<shp.getSize();  i++){
+			assertEquals(shp.getLat(i), pbf.getLat(i), 0.0000001);
+			assertEquals(shp.getLon(i), pbf.getLon(i), 0.0000001);
+		}
+	}
+
+	@Test
+	public void testTravelTimesBetweenRandomLocations(){
+		int nTests = 200;
+		final Random random = new Random(123);
+		final GHPoint min = new GHPoint(35.882931, 14.403076);
+		final GHPoint max = new GHPoint(35.913523, 14.448566);
+		
+		class RandPointGenerator{
+			double rand(double min, double max){
+				return min + random.nextDouble() * (max-min);
+			}
+			
+			GHPoint randPoint(){
+				return new GHPoint(rand(min.lat, max.lat), rand(min.lon, max.lon));
+			}
+			
+
+		}
+		RandPointGenerator pointGenerator = new RandPointGenerator();
+		
+		int nbFails =0;
+		DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
+		for(int i =0 ; i < nTests ; i++){
+			FromToPair pair = new FromToPair(pointGenerator.randPoint(), pointGenerator.randPoint());
+			
+			// paths from random points can fail to don't assert on failure
+			PathWrapper shpPath = pair.getPath(hopperShp,false);
+			PathWrapper pbfPath = pair.getPath(hopperPbf,false);
+			
+			// paths between random points can fail to find a route (i.e. be off the road network)
+			if(shpPath==null || pbfPath==null){
+				nbFails++;
+				continue;
+			}
+			double shpSecs = getSecondsTravel(shpPath);
+			double pbfSecs = getSecondsTravel(pbfPath);
+
+			double frac = shpSecs / pbfSecs;
+			stats.accept(frac);
+			System.out.println( "" + (i+1) + " from " + pair.from + " to " + pair.to + " pbfSecs=" + pbfSecs + " shpSecs=" + shpSecs + " frac=" + frac);
+		}
+		
+		assertTrue("Number of fails should be small for the chosen box",nbFails < nTests /3);
+		
+		// Test mean fraction. There will be some deviation as not all tags are considered etc,
+		// but we expect it to be small for a large number of tests
+		double mean = stats.getAverage();
+		System.out.println("Mean fraction between times " +mean);
+		double tol = 0.02;
+		assertTrue(mean > 1 - tol);
+		assertTrue(mean < 1 + tol);
+	}
+	
+	
+	@Test
+	public void testTravelTimesBetweenPredefinedLocations() throws URISyntaxException {
 
 		// try a couple of test points, with an expected time range that will only fail if something is really bad...
-		ExpectedDuration[] expected = new ExpectedDuration[] {
-				new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60, 60 * 6) ,
-				new ExpectedDuration(35.899167, 14.515171, 35.877645,14.398956, 8*60, 25*60 ),
-				new ExpectedDuration(35.85817,14.561348, 35.877645,14.398956, 10*60, 30*60 ),
-				new ExpectedDuration(35.812802,14.528732, 35.979673,14.335785, 20*60, 50*60 ),
+		ExpectedDuration[] expected = new ExpectedDuration[] { new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60, 60 * 6),
+				new ExpectedDuration(35.899167, 14.515171, 35.877645, 14.398956, 8 * 60, 25 * 60),
+				new ExpectedDuration(35.85817, 14.561348, 35.877645, 14.398956, 10 * 60, 30 * 60),
+				new ExpectedDuration(35.812802, 14.528732, 35.979673, 14.335785, 20 * 60, 50 * 60),
 
 		};
+
+		// The chosen locations should have small deviations in travel times
+		double tolDiffFromPbf = 0.01;
+
 		for (ExpectedDuration ed : expected) {
-			GHRequest request = new GHRequest(ed.from, ed.to).setVehicle("car");
-			GHResponse response = hopper.route(request);
-			assertFalse(response.hasErrors());
-			PathWrapper pw = response.getBest();
-			assertNotNull(pw);
-			long millis = pw.getTime();
-			double secs = 0.001 * millis;
+			double secsShp = getSecondsTravel(ed.getPath(hopperShp,true));
+			double secsPbf = getSecondsTravel(ed.getPath(hopperPbf,true));
+			double frac = secsShp / secsPbf;
 
 			String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs + " <= travelsecs <= " + ed.maxSecs
-					+ ", found " + secs + " secs";
-			assertTrue(message, secs >= ed.minSecs);
-			assertTrue(message, secs <= ed.maxSecs);
+					+ ", found " + secsShp + " secs, pbf was " + secsPbf + " secs, frac diff=" + frac;
+			assertTrue(message, secsShp >= ed.minSecs);
+			assertTrue(message, secsShp <= ed.maxSecs);
+
+			// we also use a tolerance difference with the pbf
+			assertTrue(frac > 1 - tolDiffFromPbf);
+			assertTrue(frac < 1 + tolDiffFromPbf);
+
 			System.out.println(message);
 		}
 
-		// assertEquals(2917, graph.getNodes());
 	}
 
+	private static double getSecondsTravel(PathWrapper pw) {
+		long millis = pw.getTime();
+		double secs = 0.001 * millis;
+		return secs;
+	}
+
+
 }
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.cpg b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
similarity index 100%
rename from reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.cpg
rename to reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.dbf b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf
similarity index 100%
rename from reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.dbf
rename to reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.prj b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
similarity index 100%
rename from reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.prj
rename to reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shp b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp
similarity index 100%
rename from reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shp
rename to reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp
diff --git a/reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shx b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx
similarity index 100%
rename from reader-shp/src/test/resources/shapefiles/gis.osm_roads_free_1.shx
rename to reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx
