diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 6904e8ec9e..8974379085 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -19,7 +19,6 @@
 package com.graphhopper.reader.gtfs;
 
 import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.FluentIterable;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.storage.Graph;
@@ -32,10 +31,11 @@
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.temporal.ChronoUnit;
-import java.util.Iterator;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterators;
 import java.util.function.Consumer;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
@@ -48,15 +48,14 @@
     private final boolean reverse;
     private final PtTravelTimeWeighting weighting;
     private final PointList extraNodes;
-    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
     private final Graph graph;
     private final boolean walkOnly;
-    private final boolean profileQuery;
 
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, boolean profileQuery) {
+    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
         this.graph = graph;
         this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
         this.flagEncoder = flagEncoder;
@@ -65,64 +64,31 @@
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
         this.extraNodes = extraNodes;
-        this.extraEdges = extraEdges;
+        this.extraEdges.addAll(extraEdges);
         for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge == null) {
+                throw new RuntimeException();
+            }
             extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
-            extraEdgesByDestination.put(extraEdge.getAdjNode(), (VirtualEdgeIteratorState) extraEdge.detach(true));
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalTraversalKey(), extraEdge.getEdge(), extraEdge.getAdjNode(), extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3)));
         }
         this.walkOnly = walkOnly;
-        this.profileQuery = profileQuery;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
         final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
         return Stream.concat(
                 label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
-                extraEdges.stream());
+                extraEdges.stream()).filter(new EdgeIteratorStatePredicate(label));
     }
 
-    Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+    private Stream<EdgeIteratorState> mainEdgesAround(Label label) {
         return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
-            boolean foundEnteredTimeExpandedNetworkEdge = false;
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
             @Override
             public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
-                while (edgeIterator.next()) {
-                    final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-                    if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
-                        continue;
-                    }
-                    if (profileQuery && (edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
-                        continue;
-                    }
-                    if (!isValidOn(edgeIterator, label.currentTime)) {
-                        continue;
-                    }
-                    if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
-                            continue;
-                        } else {
-                            if (foundEnteredTimeExpandedNetworkEdge) {
-                                continue;
-                            } else {
-                                foundEnteredTimeExpandedNetworkEdge = true;
-                            }
-                        }
-                    } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
-                            continue;
-                        }
-                    }
+                if (edgeIterator.next()) {
                     action.accept(edgeIterator);
                     return true;
                 }
@@ -181,19 +147,66 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         }
     }
 
-    public EdgeIteratorState getEdgeIteratorState(int edge, int adjNode) {
-        if (edge == -1) {
-            return extraEdges.iterator().next();
-        } else {
-            return graph.getEdgeIteratorState(edge, adjNode);
+    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+        if (edgeId == -1) {
+            throw new RuntimeException();
         }
+        return extraEdges.stream()
+                .filter(edge -> edge.getEdge() == edgeId)
+                .findFirst().orElseGet(() -> graph.getEdgeIteratorState(edgeId, adjNode));
     }
 
-    public NodeAccess getNodeAccess() {
+    NodeAccess getNodeAccess() {
         return graph.getNodeAccess();
     }
 
     public Graph getGraph() {
         return graph;
     }
+
+    private class EdgeIteratorStatePredicate implements Predicate<EdgeIteratorState> {
+        private final Label label;
+        boolean foundEnteredTimeExpandedNetworkEdge;
+
+        EdgeIteratorStatePredicate(Label label) {
+            this.label = label;
+            foundEnteredTimeExpandedNetworkEdge = false;
+        }
+
+        @Override
+        public boolean test(EdgeIteratorState edgeIterator) {
+            final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
+            if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
+                return false;
+            }
+            if (!isValidOn(edgeIterator, label.currentTime)) {
+                return false;
+            }
+            if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
+                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
+                    return false;
+                } else {
+                    if (foundEnteredTimeExpandedNetworkEdge) {
+                        return false;
+                    } else {
+                        foundEnteredTimeExpandedNetworkEdge = true;
+                    }
+                }
+            } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
+                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 1b26bca02f..ec80420efc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -62,7 +62,7 @@ private Factory(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphH
         }
 
         public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed) {
-            return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(gtfsStorage, realtimeFeed));
+            return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, flagEncoder, realtimeFeed));
         }
 
         public GraphHopperGtfs createWithoutRealtimeFeed() {
@@ -97,12 +97,13 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
-        private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
         private final PointList extraNodes = new PointList();
         private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
-        private final QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+        private final Graph graphWithExtraEdges = new WrapperGraph(graphHopperStorage, extraEdges);
+        private QueryGraph queryGraph = new QueryGraph(graphWithExtraEdges);
         private GraphExplorer graphExplorer;
 
         RequestHandler(GHRequest request) {
@@ -163,32 +164,36 @@ GHResponse route() {
         }
 
         private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), Collections.emptyList(), true, false);
+            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), extraEdges, true);
 
             extraNodes.add(ghPoint);
 
-            int newNode = graphHopperStorage.getNodes() + 1000 + index;
+            int nextNodeId = graphHopperStorage.getNodes() + 10000 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
+            int nextEdgeId = graphWithExtraEdges.getAllEdges().getMaxId() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
+
             final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
             for (Label stationNode : stationNodes) {
                 final PathWrapper pathWrapper = stationNode.parent.parent != null ?
                         tripFromLabel.parseSolutionIntoPath(reverse, flagEncoder, translation, graphExplorer, weighting, stationNode.parent, new PointList()) :
                         new PathWrapper();
                 final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        -1, reverse ? stationNode.adjNode : newNode, reverse ? newNode : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                        nextEdgeId++, reverse ? stationNode.adjNode : nextNodeId, reverse ? nextNodeId : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        -1, reverse ? newNode : stationNode.adjNode, reverse ? stationNode.adjNode : newNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                        nextEdgeId++, reverse ? nextNodeId : stationNode.adjNode, reverse ? stationNode.adjNode : nextNodeId, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
                 newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
                 final long time = pathWrapper.getTime() / 1000;
                 newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setTime(newEdge.getFlags(), time));
                 reverseNewEdge.setFlags(newEdge.getFlags());
                 newEdge.setReverseEdge(reverseNewEdge);
+                reverseNewEdge.setReverseEdge(newEdge);
                 newEdge.setDistance(pathWrapper.getDistance());
                 extraEdges.add(newEdge);
+                extraEdges.add(reverseNewEdge);
                 walkPaths.put(stationNode.adjNode, pathWrapper);
             }
 
             final QueryResult virtualNode = new QueryResult(ghPoint.getLat(), ghPoint.getLon());
-            virtualNode.setClosestNode(newNode);
+            virtualNode.setClosestNode(nextNodeId);
             allQueryResults.set(index, virtualNode);
         }
 
@@ -198,7 +203,6 @@ private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint
             final Stream<Label> labels = router.calcLabels(node, -1, initialTime);
             return labels
                     .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
-//                    .limit(limitSolutions)
                     .collect(Collectors.toList());
         }
 
@@ -249,7 +253,7 @@ private int egressNode(Label solution) {
 
         private List<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false, profileQuery);
+            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false);
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
             final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime);
             List<Label> solutions = labels
@@ -327,7 +331,7 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                 walkNetworkIndex = new EmptyLocationIndex();
             }
             for (int i = 0; i < id; i++) {
-                new GtfsReader("gtfs_" + i, graphHopperStorage, walkNetworkIndex).readGraph();
+                new GtfsReader("gtfs_" + i, graphHopperStorage, ptFlagEncoder, walkNetworkIndex).readGraph();
             }
             graphHopperStorage.flush();
             return graphHopperStorage;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 33a66522c7..6eef12943f 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -25,7 +25,7 @@
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -46,6 +46,21 @@
 
 class GtfsReader {
 
+    private LocalDate startDate;
+    private LocalDate endDate;
+
+    static class TripWithStopTimes {
+        public TripWithStopTimes(Trip trip, Iterable<StopTime> stopTimes, BitSet validOnDay) {
+            this.trip = trip;
+            this.stopTimes = stopTimes;
+            this.validOnDay = validOnDay;
+        }
+
+        Trip trip;
+        Iterable<StopTime> stopTimes;
+        BitSet validOnDay;
+    }
+
     private static class EnterAndExitNodeIdWithStopId {
         final String stopId;
         final Collection<Integer> enterNodeIds;
@@ -60,10 +75,12 @@ private EnterAndExitNodeIdWithStopId(Collection<Integer> enterNodeIds, String st
 
     private static class TimelineNodeIdWithTripId {
         final String tripId;
+        final String routeId;
         final int timelineNodeId;
 
-        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
+        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String routeId) {
             this.tripId = tripId;
+            this.routeId = routeId;
             this.timelineNodeId = timelineNodeId;
         }
     }
@@ -77,12 +94,12 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
         SINGLE_FREQUENCY.headway_secs = 1;
     }
 
-    private final GraphHopperStorage graph;
+    private final Graph graph;
     private final LocationIndex walkNetworkIndex;
     private final GtfsStorage gtfsStorage;
 
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private Transfers transfers;
+    private final Transfers transfers;
     private final NodeAccess nodeAccess;
     private final String id;
     private int i;
@@ -93,21 +110,28 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
     private Collection<EnterAndExitNodeIdWithStopId> stopEnterAndExitNodes = new ArrayList<>();
     private final PtFlagEncoder encoder;
 
-    GtfsReader(String id, GraphHopperStorage ghStorage, LocationIndex walkNetworkIndex) {
+    GtfsReader(String id, Graph graph, PtFlagEncoder encoder, LocationIndex walkNetworkIndex) {
         this.id = id;
-        this.graph = ghStorage;
-        this.gtfsStorage = (GtfsStorage) ghStorage.getExtension();
-        this.nodeAccess = ghStorage.getNodeAccess();
+        this.graph = graph;
+        this.gtfsStorage = (GtfsStorage) graph.getExtension();
+        this.nodeAccess = graph.getNodeAccess();
         this.walkNetworkIndex = walkNetworkIndex;
-        this.encoder = (PtFlagEncoder) graph.getEncodingManager().getEncoder("pt");
+        this.encoder = encoder;
+        this.feed = this.gtfsStorage.getGtfsFeeds().get(id);
+        this.transfers = new Transfers(feed);
+        this.i = graph.getNodes();
+        this.startDate = feed.calculateStats().getStartDate();
+        this.endDate = feed.calculateStats().getEndDate();
+        this.gtfsStorage.getFares().putAll(feed.fares);
     }
 
-    public void readGraph() {
-        feed = this.gtfsStorage.getGtfsFeeds().get(id);
-        transfers = new Transfers(feed);
-        gtfsStorage.getFares().putAll(feed.fares);
-        i = graph.getNodes();
+    void readGraph() {
         buildPtNetwork();
+        connectStopsToStreetNetwork();
+        connectStopsToStationNodes();
+    }
+
+    void connectStopsToStreetNetwork() {
         EdgeFilter filter = new EverythingButPt(encoder);
         for (EnterAndExitNodeIdWithStopId entry : stopEnterAndExitNodes) {
             Stop stop = feed.stops.get(entry.stopId);
@@ -120,6 +144,14 @@ public void readGraph() {
             } else {
                 streetNode = locationQueryResult.getClosestNode();
             }
+            gtfsStorage.getStationNodes().put(entry.stopId, streetNode);
+        }
+    }
+
+    void connectStopsToStationNodes() {
+        for (EnterAndExitNodeIdWithStopId entry : stopEnterAndExitNodes) {
+            Stop stop = feed.stops.get(entry.stopId);
+            int streetNode = gtfsStorage.getStationNodes().get(entry.stopId);
             for (Integer enterNodeId : entry.enterNodeIds) {
                 EdgeIteratorState entryEdge = graph.edge(streetNode, enterNodeId, 0.0, false);
                 setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
@@ -130,13 +162,10 @@ public void readGraph() {
                 setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                 exitEdge.setName(stop.stop_name);
             }
-            gtfsStorage.getStationNodes().put(entry.stopId, streetNode);
         }
     }
 
     private void buildPtNetwork() {
-        LocalDate startDate = feed.calculateStats().getStartDate();
-        LocalDate endDate = feed.calculateStats().getEndDate();
         HashMultimap<String, Trip> blockTrips = HashMultimap.create();
         for (Trip trip : feed.trips.values()) {
             if (trip.block_id != null) {
@@ -146,18 +175,8 @@ private void buildPtNetwork() {
             }
         }
         blockTrips.asMap().values().forEach(unsortedTrips -> {
-            ArrayList<Trip> trips = new ArrayList<>(unsortedTrips);
-            trips.sort(Comparator.comparingInt(trip -> getInterpolatedStopTimesForTrip(trip.trip_id).iterator().next().departure_time));
-            if (trips.stream().map(trip -> feed.getFrequencies(trip.trip_id)).distinct().count() != 1) {
-                throw new RuntimeException("Found a block with frequency-based trips. Not supported.");
-            }
-            Collection<Frequency> frequencies = feed.getFrequencies(trips.iterator().next().trip_id);
-            for (Frequency frequency : (frequencies.isEmpty() ? Collections.singletonList(SINGLE_FREQUENCY) : frequencies)) {
-                for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
-                    List<Integer> arrivalNodes = new ArrayList<>();
-                    IntArrayList boardEdges = new IntArrayList();
-                    IntArrayList alightEdges = new IntArrayList();
-                    for (Trip trip : trips) {
+            List<TripWithStopTimes> trips = unsortedTrips.stream()
+                    .map(trip -> {
                         Service service = feed.services.get(trip.service_id);
                         BitSet validOnDay = new BitSet((int) DAYS.between(startDate, endDate));
                         for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
@@ -165,139 +184,167 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
-                        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trip.route_id).agency_id).agency_timezone);
-                        StopTime prev = null;
-                        int arrivalNode = -1;
-                        int departureNode = -1;
-                        for (StopTime stopTime : getInterpolatedStopTimesForTrip(trip.trip_id)) {
-                            Stop stop = feed.stops.get(stopTime.stop_id);
-                            arrivalNode = i++;
-                            nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(arrivalNode, stopTime.arrival_time + time);
-                            if (prev != null) {
-                                Stop fromStop = feed.stops.get(prev.stop_id);
-                                double distance = distCalc.calcDist(
-                                        fromStop.stop_lat,
-                                        fromStop.stop_lon,
-                                        stop.stop_lat,
-                                        stop.stop_lon);
-                                EdgeIteratorState edge = graph.edge(
-                                        departureNode,
-                                        arrivalNode,
-                                        distance,
-                                        false);
-                                edge.setName(stop.stop_name);
-                                setEdgeType(edge, GtfsStorage.EdgeType.HOP);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
-                                gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                            }
-                            final int departureTimelineNode = i++;
-                            nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(departureTimelineNode, stopTime.departure_time + time);
-                            departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip_id));
-                            final int arrivalTimelineNode = i++;
-                            nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(arrivalTimelineNode, stopTime.arrival_time + time);
-                            arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip_id));
-                            departureNode = i++;
-                            nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(departureNode, stopTime.departure_time + time);
-                            int dayShift = stopTime.departure_time / (24 * 60 * 60);
-                            GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
-                            int validityId;
-                            if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
-                                validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
-                            } else {
-                                validityId = gtfsStorage.getOperatingDayPatterns().size();
-                                gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
-                            }
-
-                            EdgeIteratorState boardEdge = graph.edge(
-                                    departureTimelineNode,
-                                    departureNode,
-                                    0.0,
-                                    false);
-                            boardEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
-                            boardEdges.add(boardEdge.getEdge());
-                            gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
-                            gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip_id);
-                            boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
-                            boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
-
-                            EdgeIteratorState alightEdge = graph.edge(
-                                    arrivalNode,
-                                    arrivalTimelineNode,
-                                    0.0,
-                                    false);
-                            alightEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
-                            alightEdges.add(alightEdge.getEdge());
-                            gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
-                            gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip_id);
-                            alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
-//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
-
-
-                            EdgeIteratorState dwellEdge = graph.edge(
-                                    arrivalNode,
-                                    departureNode,
-                                    0.0,
-                                    false);
-                            dwellEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
-                            dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
-                            if (prev == null) {
-                                insertInboundBlockTransfers(arrivalNodes, trip, departureNode, stopTime, stop, validityId);
-                            }
-                            prev = stopTime;
-                        }
-                        final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
-                        gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
-                        gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
-                        arrivalNodes.add(arrivalNode);
-                    }
+                        return new TripWithStopTimes(trip, getInterpolatedStopTimesForTrip(trip.trip_id), validOnDay);
+                    })
+                    .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
+                    .collect(Collectors.toList());
+            if (trips.stream().map(trip -> feed.getFrequencies(trip.trip.trip_id)).distinct().count() != 1) {
+                throw new RuntimeException("Found a block with frequency-based trips. Not supported.");
+            }
+            ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trips.iterator().next().trip.route_id).agency_id).agency_timezone);
+            Collection<Frequency> frequencies = feed.getFrequencies(trips.iterator().next().trip.trip_id);
+            for (Frequency frequency : (frequencies.isEmpty() ? Collections.singletonList(SINGLE_FREQUENCY) : frequencies)) {
+                for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
+                    addTrips(zoneId, trips, time);
                 }
             }
         });
 
+        wireUpStops();
+    }
+
+    void wireUpStops() {
         for (Stop stop : feed.stops.values()) {
             if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
-                final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> feed.trips.get(t.tripId).route_id));
-
                 List<Integer> stopExitNodeIds = new ArrayList<>();
-                arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopExitNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-                    stopExitNodeIds.add(stopExitNode);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-                    timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                            .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-                    wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                });
 
+                if (arrivalTimelineNodes.containsKey(stop.stop_id)) {
+                    final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
 
+                    arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                        int stopExitNode = i-1;
+                        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
+                        stopExitNodeIds.add(stopExitNode);
+                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
+                        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
+                                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
+                        wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
+                    });
 
-                final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> feed.trips.get(t.tripId).route_id));
-
+                }
                 List<Integer> stopEnterNodeIds = new ArrayList<>();
-                departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopEnterNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-                    stopEnterNodeIds.add(stopEnterNode);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-                    timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                            .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-                    wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                });
+
+                if (departureTimelineNodes.containsKey(stop.stop_id)) {
+                    final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
+
+                    departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                        int stopEnterNode = i-1;
+                        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
+                        stopEnterNodeIds.add(stopEnterNode);
+                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
+                        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
+                                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
+                        wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
+                    });
+                }
+
                 stopEnterAndExitNodes.add(new EnterAndExitNodeIdWithStopId(stopEnterNodeIds, stop.stop_id, stopExitNodeIds));
+
+            }
+        }
+    }
+
+    void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
+        List<Integer> arrivalNodes = new ArrayList<>();
+        for (TripWithStopTimes trip : trips) {
+            IntArrayList boardEdges = new IntArrayList();
+            IntArrayList alightEdges = new IntArrayList();
+            StopTime prev = null;
+            int arrivalNode = -1;
+            int departureNode = -1;
+            for (StopTime stopTime : trip.stopTimes) {
+                Stop stop = feed.stops.get(stopTime.stop_id);
+                arrivalNode = i++;
+                nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(arrivalNode, stopTime.arrival_time + time);
+                if (prev != null) {
+                    Stop fromStop = feed.stops.get(prev.stop_id);
+                    double distance = distCalc.calcDist(
+                            fromStop.stop_lat,
+                            fromStop.stop_lon,
+                            stop.stop_lat,
+                            stop.stop_lon);
+                    EdgeIteratorState edge = graph.edge(
+                            departureNode,
+                            arrivalNode,
+                            distance,
+                            false);
+                    edge.setName(stop.stop_name);
+                    setEdgeType(edge, GtfsStorage.EdgeType.HOP);
+                    edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
+                    gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
+                }
+                final int departureTimelineNode = i++;
+                nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(departureTimelineNode, stopTime.departure_time + time);
+                departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+                final int arrivalTimelineNode = i++;
+                nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(arrivalTimelineNode, stopTime.arrival_time + time);
+                arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+                departureNode = i++;
+                nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(departureNode, stopTime.departure_time + time);
+                int dayShift = stopTime.departure_time / (24 * 60 * 60);
+                GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(trip.validOnDay, dayShift), zoneId, startDate);
+                int validityId;
+                if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
+                    validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
+                } else {
+                    validityId = gtfsStorage.getOperatingDayPatterns().size();
+                    gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
+                }
+
+                EdgeIteratorState boardEdge = graph.edge(
+                        departureTimelineNode,
+                        departureNode,
+                        0.0,
+                        false);
+                boardEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+                boardEdges.add(boardEdge.getEdge());
+                gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
+                gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip.trip_id);
+                boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
+                boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
+
+                EdgeIteratorState alightEdge = graph.edge(
+                        arrivalNode,
+                        arrivalTimelineNode,
+                        0.0,
+                        false);
+                alightEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
+                alightEdges.add(alightEdge.getEdge());
+                gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
+                gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip.trip_id);
+                alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
+//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
+
+
+                EdgeIteratorState dwellEdge = graph.edge(
+                        arrivalNode,
+                        departureNode,
+                        0.0,
+                        false);
+                dwellEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
+                dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
+                if (prev == null) {
+                    insertInboundBlockTransfers(arrivalNodes, trip.trip, departureNode, stopTime, stop, validityId);
+                }
+                prev = stopTime;
             }
+            final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
+            gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
+            gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
+            arrivalNodes.add(arrivalNode);
         }
     }
 
@@ -407,7 +454,7 @@ private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip,
 
     private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> toStopTimelineNode) {
         for (TimelineNodeIdWithTripId entry : arrivalTimelineNodes.get(fromStopId)) {
-            if (from_route_id == null || from_route_id.equals(feed.trips.get(entry.tripId).route_id)) {
+            if (from_route_id == null || from_route_id.equals(entry.routeId)) {
                 int arrivalTime = times.get(entry.timelineNodeId);
                 SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = toStopTimelineNode.tailSet(new Fun.Tuple2<>(arrivalTime + minimumTransferTime, -1));
                 if (!tailSet.isEmpty()) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index e5dc9416f8..9119b9e35a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -19,22 +19,50 @@
 package com.graphhopper.reader.gtfs;
 
 import com.carrotsearch.hppc.IntHashSet;
+import com.carrotsearch.hppc.IntIntHashMap;
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.StopTime;
+import com.conveyal.gtfs.model.Trip;
 import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+
+import java.time.*;
+import java.time.temporal.ChronoUnit;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
+import static java.time.temporal.ChronoUnit.DAYS;
 
 public class RealtimeFeed {
     private final IntHashSet blockedEdges;
 
-    private RealtimeFeed(IntHashSet blockedEdges) {
+    private final List<VirtualEdgeIteratorState> additionalEdges;
+
+    private RealtimeFeed(IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
         this.blockedEdges = blockedEdges;
+        this.additionalEdges = additionalEdges;
     }
 
     public static RealtimeFeed empty() {
-        return new RealtimeFeed(new IntHashSet());
+        return new RealtimeFeed(new IntHashSet(), Collections.emptyList());
     }
 
-    public static RealtimeFeed fromProtobuf(GtfsStorage staticGtfs, GtfsRealtime.FeedMessage feedMessage) {
+    public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
+        String feedKey = "gtfs_0"; //FIXME
+        GTFSFeed feed = staticGtfs.getGtfsFeeds().get(feedKey);
         final IntHashSet blockedEdges = new IntHashSet();
         feedMessage.getEntityList().stream()
             .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -50,10 +78,190 @@ public static RealtimeFeed fromProtobuf(GtfsStorage staticGtfs, GtfsRealtime.Fee
                             blockedEdges.add(leaveEdges[skippedStopSequenceNumber]);
                         });
             });
-        return new RealtimeFeed(blockedEdges);
+        final List<VirtualEdgeIteratorState> additionalEdges = new ArrayList<>();
+        final Graph overlayGraph = new Graph() {
+            int nNodes = 0;
+            int firstEdge = graph.getAllEdges().getMaxId()+1;
+            final NodeAccess nodeAccess = new NodeAccess() {
+                IntIntHashMap additionalNodeFields = new IntIntHashMap();
+
+                @Override
+                public int getAdditionalNodeField(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public void setAdditionalNodeField(int nodeId, int additionalValue) {
+                    additionalNodeFields.put(nodeId, additionalValue);
+                }
+
+                @Override
+                public boolean is3D() {
+                    return false;
+                }
+
+                @Override
+                public int getDimension() {
+                    return 0;
+                }
+
+                @Override
+                public void ensureNode(int nodeId) {
+
+                }
+
+                @Override
+                public void setNode(int nodeId, double lat, double lon) {
+
+                }
+
+                @Override
+                public void setNode(int nodeId, double lat, double lon, double ele) {
+
+                }
+
+                @Override
+                public double getLatitude(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLat(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLongitude(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLon(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getElevation(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getEle(int nodeId) {
+                    return 0;
+                }
+            };
+            @Override
+            public Graph getBaseGraph() {
+                return null;
+            }
+
+            @Override
+            public int getNodes() {
+                return graph.getNodes() + nNodes;
+            }
+
+            @Override
+            public NodeAccess getNodeAccess() {
+                return nodeAccess;
+            }
+
+            @Override
+            public BBox getBounds() {
+                return null;
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b) {
+                return null;
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+                int edge = firstEdge++;
+                final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(-1,
+                        edge, a, b, 0,0, "", new PointList());
+                final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(-1,
+                        edge, b, a, 0,0, "", new PointList());
+
+                newEdge.setReverseEdge(reverseNewEdge);
+                reverseNewEdge.setReverseEdge(newEdge);
+                additionalEdges.add(newEdge);
+//                additionalEdges.add(reverseNewEdge); //FIXME
+                return newEdge;
+            }
+
+            @Override
+            public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+                return null;
+            }
+
+            @Override
+            public AllEdgesIterator getAllEdges() {
+                return null;
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
+                return null;
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer() {
+                return null;
+            }
+
+            @Override
+            public Graph copyTo(Graph g) {
+                return null;
+            }
+
+            @Override
+            public GraphExtension getExtension() {
+                return staticGtfs;
+            }
+        };
+        final GtfsReader gtfsReader = new GtfsReader(feedKey, overlayGraph, encoder, null);
+        Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
+        LocalDate dateToChange = timestamp.atZone(ZoneId.of(feed.agency.values().iterator().next().agency_timezone)).toLocalDate(); //FIXME
+
+        feedMessage.getEntityList().stream()
+                .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
+                .map(GtfsRealtime.FeedEntity::getTripUpdate)
+                .filter(tripUpdate -> tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED)
+                .map(tripUpdate -> {
+                    Trip trip = new Trip();
+                    trip.trip_id = tripUpdate.getTrip().getTripId();
+                    trip.route_id = tripUpdate.getTrip().getRouteId();
+                    final List<StopTime> stopTimes = tripUpdate.getStopTimeUpdateList().stream()
+                            .map(stopTimeUpdate -> {
+                                final StopTime stopTime = new StopTime();
+                                stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
+                                stopTime.stop_id = stopTimeUpdate.getStopId();
+                                stopTime.trip_id = trip.trip_id;
+                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
+                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
+                                return stopTime;
+                            })
+                            .collect(Collectors.toList());
+                    BitSet validOnDay = new BitSet();
+                    LocalDate startDate = feed.calculateStats().getStartDate();
+                    validOnDay.set((int) DAYS.between(startDate, dateToChange));
+                    return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
+                })
+                .forEach(trip -> gtfsReader.addTrips(ZoneId.systemDefault(), Collections.singletonList(trip), 0));
+        gtfsReader.wireUpStops();
+        gtfsReader.connectStopsToStationNodes();
+        return new RealtimeFeed(blockedEdges, additionalEdges);
     }
 
     boolean isBlocked(int edgeId) {
         return blockedEdges.contains(edgeId);
     }
+
+    List<VirtualEdgeIteratorState> getAdditionalEdges() {
+        return additionalEdges;
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 13123114af..0afaaa4666 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -26,7 +26,6 @@
 import com.graphhopper.gtfs.fare.Fares;
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 import com.vividsolutions.jts.geom.Coordinate;
 import com.vividsolutions.jts.geom.Geometry;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
new file mode 100644
index 0000000000..189cbbe679
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -0,0 +1,211 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+
+import java.util.List;
+import java.util.stream.IntStream;
+
+public class WrapperGraph implements Graph {
+
+    private final Graph baseGraph;
+    private final List<VirtualEdgeIteratorState> extraEdges;
+
+    public WrapperGraph(Graph baseGraph, List<VirtualEdgeIteratorState> extraEdges) {
+        this.baseGraph = baseGraph;
+        this.extraEdges = extraEdges;
+    }
+
+    @Override
+    public Graph getBaseGraph() {
+        return baseGraph;
+    }
+
+    @Override
+    public int getNodes() {
+        return IntStream.concat(
+                IntStream.of(baseGraph.getNodes()-1),
+                extraEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
+                .max().getAsInt()+1;
+    }
+
+    @Override
+    public NodeAccess getNodeAccess() {
+        return baseGraph.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds() {
+        return baseGraph.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge(int a, int b) {
+        return baseGraph.getEdgeIteratorState(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
+    }
+
+    @Override
+    public AllEdgesIterator getAllEdges() {
+        return new AllEdgesIterator() {
+            @Override
+            public int getMaxId() {
+                return IntStream.concat(
+                        IntStream.of(baseGraph.getAllEdges().getMaxId()),
+                        extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
+                        .max().getAsInt();
+            }
+
+            @Override
+            public boolean next() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getEdge() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getBaseNode() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getAdjNode() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public PointList fetchWayGeometry(int mode) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setWayGeometry(PointList list) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public double getDistance() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setDistance(double dist) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long getFlags() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setFlags(long flags) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getAdditionalField() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setAdditionalField(int value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isForward(FlagEncoder encoder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isBackward(FlagEncoder encoder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean getBool(int key, boolean _default) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public String getName() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setName(String name) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState detach(boolean reverse) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
+                throw new UnsupportedOperationException();
+            }
+        };
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
+        return baseGraph.createEdgeExplorer(filter);
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer() {
+        return baseGraph.createEdgeExplorer();
+    }
+
+    @Override
+    public Graph copyTo(Graph g) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public GraphExtension getExtension() {
+        return baseGraph.getExtension();
+    }
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 208699dbe4..47bc982462 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -33,12 +33,11 @@
 import org.junit.Test;
 
 import java.io.File;
-import java.time.Instant;
-import java.time.LocalDateTime;
-import java.time.ZoneId;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
+import static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -85,9 +84,9 @@ public void testSkipDepartureStop() {
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -116,9 +115,9 @@ public void testSkipArrivalStop() {
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -147,9 +146,9 @@ public void testSkipTransferStop() {
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -162,6 +161,59 @@ public void testSkipTransferStop() {
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
     }
 
+    @Test
+    public void testExtraTrip() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // But the 6:00 departure of my line is going to skip my transfer stop :-(
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(5)
+                .setScheduleRelationship(SKIPPED);
+
+        final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
+                .setId("2")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setScheduleRelationship(ADDED).setTripId("EXTRA").setRouteId("CITY").setStartTime("06:45:00"));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(1)
+                .setStopId("NADAV")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(2)
+                .setStopId("BEATTY_AIRPORT")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, response.getAll().size());
+
+        assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
+    }
+
+
     @Test
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
@@ -177,9 +229,9 @@ public void testBlockTrips() {
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("AB1").setStartTime("00:00:00"))
                 .addStopTimeUpdateBuilder()
