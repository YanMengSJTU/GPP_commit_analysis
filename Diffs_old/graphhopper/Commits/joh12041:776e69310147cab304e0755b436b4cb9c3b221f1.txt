diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index d9a48e47d6..6d5e5a757b 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -46,6 +46,7 @@
     private InstructionList instructions;
     private PointList waypointList = PointList.EMPTY;
     private PointList pointList = PointList.EMPTY;
+    private int simplicity = 0;
 
     /**
      * @return the description of this route alternative to make it meaningful for the user e.g. it
@@ -100,6 +101,14 @@ public PointList getPoints() {
         return roundedPoints;
     }
 
+    public void setSimplicity(int sim) {
+        simplicity = sim;
+    }
+
+    public int getSimplicity() {
+        return simplicity;
+    }
+
     public PathWrapper setPoints(PointList points) {
         if (pointList != PointList.EMPTY)
             throw new IllegalStateException("Cannot call setPoint twice");
diff --git a/core/src/main/java/com/graphhopper/routing/KSP.java b/core/src/main/java/com/graphhopper/routing/KSP.java
index fa8a7c8891..ed60ef1041 100644
--- a/core/src/main/java/com/graphhopper/routing/KSP.java
+++ b/core/src/main/java/com/graphhopper/routing/KSP.java
@@ -63,7 +63,7 @@ public int compare(AlternativeInfo o1, AlternativeInfo o2) {
     // the higher the maxWeightFactor the higher the explorationFactor needs to be
     // 1 is default for bidir Dijkstra, 0.8 seems to be a very similar value for bidir A* but roughly 1/2 of the nodes explored
     private double maxExplorationFactor = 10;  //
-    private int maxPaths = 100000;  // K
+    private int maxPaths = 10000;  // K
 
     public KSP(Graph graph, Weighting weighting, TraversalMode traversalMode) {
         this.graph = graph;
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 52332845ae..707c99c190 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -62,6 +62,7 @@
     private TIntList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
+    private int simplicity = 0;  // how simple is the path based on turns
 
     public Path(Graph graph, Weighting weighting) {
         this.weight = Double.MAX_VALUE;
@@ -97,6 +98,10 @@ public Path setDescription(List<String> description) {
         return this;
     }
 
+    public int getSimplicity() {
+        return simplicity;
+    }
+
     public Path setSPTEntry(SPTEntry sptEntry) {
         this.sptEntry = sptEntry;
         return this;
@@ -390,6 +395,8 @@ public void next(EdgeIteratorState edge, int index) {
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
 
+                simplicity += 1;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
                 boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
 
@@ -416,6 +423,7 @@ public void next(EdgeIteratorState edge, int index) {
 
                 } else if (isRoundabout) {
                     // remark: names and annotations within roundabout are ignored
+                    simplicity += 4;
                     if (!prevInRoundabout) //just entered roundabout
                     {
                         int sign = Instruction.USE_ROUNDABOUT;
@@ -428,6 +436,7 @@ public void next(EdgeIteratorState edge, int index) {
                                 if ((edgeIter.getAdjNode() != prevNode)
                                         && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
                                     roundaboutInstruction.increaseExitNumber();
+                                    simplicity += 1;
                                     break;
                                 }
                             }
@@ -520,6 +529,17 @@ public void next(EdgeIteratorState edge, int index) {
                     ways.add(prevInstruction);
                     prevName = name;
                     prevAnnotation = annotation;
+
+                    if (absDelta > 0.2) {
+                        //TODO: check if at T and just increment simplicity by 5
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        int countEdges = 4;
+                        while (edgeIter.next()) {
+                            edgeIter.getAdjNode();
+                            countEdges += 1;
+                        }
+                        simplicity += countEdges;
+                    }
                 }
 
                 updatePointsAndInstruction(edge, wayGeo);
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 70a06cb2f0..0f2ca2d7d6 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -65,6 +65,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         double fullWeight = 0;
         double fullDistance = 0;
         boolean allFound = true;
+        int simplicity = 0;
 
         InstructionList fullInstructions = new InstructionList(tr);
         PointList fullPoints = PointList.EMPTY;
@@ -77,6 +78,8 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
             fullWeight += path.getWeight();
             if (enableInstructions) {
                 InstructionList il = path.calcInstructions(tr);
+                simplicity += path.getSimplicity();
+
 
                 if (!il.isEmpty()) {
                     if (fullPoints.isEmpty()) {
@@ -134,7 +137,8 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 setPoints(fullPoints).
                 setRouteWeight(fullWeight).
                 setDistance(fullDistance).
-                setTime(fullTimeInMillis);
+                setTime(fullTimeInMillis).
+                setSimplicity(simplicity);
     }
 
     private void calcAscendDescend(final PathWrapper rsp, final PointList pointList) {
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
index 2b6e67352b..cfef6e5c53 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -7,9 +7,11 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
 
+import java.awt.*;
 import java.util.*;
 
 import java.io.*;
+import java.util.List;
 
 
 /**
@@ -19,6 +21,7 @@
 
     private static final TranslationMap trMap = new TranslationMap().doImport();
     private static final Translation usTR = trMap.getWithFallBack(Locale.US);
+    private static final boolean outputAlternative = true;
 
     public static void process_routes(String city, String route_type, boolean useCH) throws Exception {
 
@@ -34,7 +37,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
             graphFolder = graphFolder + "ghosm_sf";
             inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
             outputPointsFN = outputPointsFN + "sf_" + route_type + "_graphhopper_routes_ksp.csv";
-            gridValuesFNs.add(gvfnStem + "06075_beauty_flickr.csv");
+            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_flickr.csv");
         } else if (city.equals("NYC")) {
             osmFile = osmFile + "new-york_new-york.osm.pbf";
             graphFolder = graphFolder + "ghosm_nyc";
@@ -95,6 +98,12 @@ public static void process_routes(String city, String route_type, boolean useCH)
         FileWriter sc_out = new FileWriter(outputPointsFN, true);
         sc_out.write("ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers" +
                 System.getProperty("line.separator"));
+        FileWriter sc_out_alt;
+        if (outputAlternative) {
+            sc_out_alt = new FileWriter(outputPointsFN.replaceFirst(".csv","_alt.csv"), true);
+            sc_out_alt.write("ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers" +
+                    System.getProperty("line.separator"));
+        }
         String header = sc_in.nextLine();
         String od_id;
         float laF;
@@ -125,7 +134,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
         // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
         float[] points;
         PointList pointList = null;
-        List<Map<String, Object>> iList = null;
+        //List<Map<String, Object>> iList = null;
         int routes_skipped = 0;
         for (int i=0; i<numPairs; i++) {
             points = inputPoints.get(i);
@@ -145,6 +154,10 @@ public static void process_routes(String city, String route_type, boolean useCH)
                 System.out.println(i + ": Skipping.");
                 sc_out.write(od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
                         + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator"));
+                if (outputAlternative) {
+                    sc_out_alt.write(od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
+                            + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator"));
+                }
                 routes_skipped++;
                 continue;
             }
@@ -170,6 +183,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
                 }
                 j++;
             }
+
             PathWrapper bestPath = paths.get(maxidx);
             // points, distance in meters and time in seconds (convert from ms) of the full path
             pointList = bestPath.getPoints();
@@ -183,13 +197,58 @@ public static void process_routes(String city, String route_type, boolean useCH)
                 maneuvers.add(instruction.getSimpleTurnDescription());
                 // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
             }
+
             sc_out.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
                     ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
+            System.out.println(i + ": Distance: " + Math.round(paths.get(0).getDistance() * 100) / 100 + "m;\tTime: " + paths.get(0).getTime() / 1000 + "sec;\t# Directions: " + paths.get(0).getInstructions().getSize());
+            System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tScore: " + maxscore);
 
-            System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections);
+            int k = 0;
+            int minidx = 0;
+            float minscore = 1000;
+            if (outputAlternative) {
+                double altdistance;
+                for (PathWrapper path: paths) {
+                    altdistance = path.getDistance();
+                    if (altdistance / distance > 1.05 || altdistance / distance < 0.95) {
+                        continue;
+                    }
+                    roundedPoints = path.roundPoints();
+                    float score = 0;
+                    for (String pt : roundedPoints) {
+                        if (gridBeauty.containsKey(pt)) {
+                            score = score + gridBeauty.get(pt);
+                        }
+                    }
+                    score = score / roundedPoints.size();
+                    if (score < minscore) {
+                        minscore = score;
+                        minidx = k;
+                    }
+                    k++;
+                }
+                bestPath = paths.get(minidx);
+                // points, distance in meters and time in seconds (convert from ms) of the full path
+                pointList = bestPath.getPoints();
+                distance = Math.round(bestPath.getDistance() * 100) / 100;
+                timeInSec = bestPath.getTime() / 1000;
+                il = bestPath.getInstructions();
+                numDirections = il.getSize();
+                // iterate over every turn instruction
+                maneuvers.clear();
+                for (Instruction instruction : il) {
+                    maneuvers.add(instruction.getSimpleTurnDescription());
+                    // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
+                }
+                sc_out_alt.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
+                        ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
+                System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tScore: " + minscore);
+
+            }
+            paths.clear();
 
             // or get the json
-            iList = il.createJson();
+            //iList = il.createJson();
             //System.out.println("JSON: " + iList);
 
             // or get the result as gpx entries:
@@ -210,9 +269,9 @@ public static void main(String[] args) throws Exception {
         // NYC Random
         //process_routes("NYC", "rand", true);
         // SF Grid
-        //process_routes("SF", "grid", true);
+        process_routes("SF", "grid", false);
         // SF Random
         //process_routes("SF", "rand", true);
-        process_routes("BOS", "check", true);
+        //process_routes("BOS", "check", true);
     }
 }
