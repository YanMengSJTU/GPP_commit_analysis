diff --git a/CHANGELOG.md b/CHANGELOG.md
index 80163a1..20780a2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,12 @@
+## 1.2.4 (2018-02-08)
+* Add `scheduleAsync()` to the `DailyJob` class for scheduling daily jobs asynchronously to avoid IO operations on the main thread, see #371
+
+## 1.2.3 (2018-02-07)
+* Add an `onCancel()` method to get notified when the job is canceled, see #359
+* Expose the `meetsRequirements()` method to have the option to check all requirements manually, see #349
+* Don't close the database automatically after each interaction, but give an option in the `JobConfig` class to revert this behavior, see #344
+* Add `scheduleAsync()` for scheduling jobs asynchronously to avoid IO operations on the main thread
+
 ## 1.2.2 (2018-01-13)
 * Use only the `support-compat` instead of the full `support-v4` library, see #326
 * Use a `ReadWriteLock` for synchronizing the database reads and writes, see #344
diff --git a/README.md b/README.md
index 4ee38bd..feeec4e 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@ Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evern
 
 ```groovy
 dependencies {
-    compile 'com.evernote:android-job:1.2.2'
+    compile 'com.evernote:android-job:1.2.4'
 }
 ```
 
diff --git a/build.gradle b/build.gradle
index f538255..534f90e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:3.0.1'
-        classpath 'com.github.ben-manes:gradle-versions-plugin:0.15.0'
+        classpath 'com.github.ben-manes:gradle-versions-plugin:0.17.0'
     }
 }
 
@@ -38,6 +38,6 @@ ext {
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '4.4.1'
+    gradleVersion = '4.5.1'
     distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
 }
diff --git a/gradle.properties b/gradle.properties
index d398fd2..9dcbca6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.2.2
-VERSION_NAME=1.2.2-SNAPSHOT
+#VERSION_NAME=1.2.4
+VERSION_NAME=1.2.4-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6..99340b4 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d..8941bfb 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-all.zip
diff --git a/library/src/main/java/com/evernote/android/job/DailyJob.java b/library/src/main/java/com/evernote/android/job/DailyJob.java
index 1a63fa9..ffa00ab 100644
--- a/library/src/main/java/com/evernote/android/job/DailyJob.java
+++ b/library/src/main/java/com/evernote/android/job/DailyJob.java
@@ -6,6 +6,7 @@
 import android.support.annotation.WorkerThread;
 
 import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.JobPreconditions;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import java.util.Calendar;
@@ -66,6 +67,42 @@ public static int schedule(@NonNull JobRequest.Builder baseBuilder, long startMs
         return schedule(baseBuilder, true, startMs, endMs);
     }
 
+    /**
+     * Helper method to schedule a daily job on a background thread. This is helpful to avoid IO operations
+     * on the main thread. For more information about scheduling daily jobs see {@link #schedule(JobRequest.Builder, long, long)}.
+     *
+     * <br>
+     * <br>
+     *
+     * In case of a failure an error is logged, but the application doesn't crash.
+     */
+    public static void scheduleAsync(@NonNull JobRequest.Builder baseBuilder, long startMs, long endMs) {
+        scheduleAsync(baseBuilder, startMs, endMs, JobRequest.DEFAULT_JOB_SCHEDULED_CALLBACK);
+    }
+
+    /**
+     * Helper method to schedule a daily job on a background thread. This is helpful to avoid IO operations
+     * on the main thread. The callback notifies you about the job ID or a possible failure. For more
+     * information about scheduling daily jobs see {@link #schedule(JobRequest.Builder, long, long)}.
+     *
+     * @param callback The callback which is invoked after the request has been scheduled.
+     */
+    public static void scheduleAsync(@NonNull final JobRequest.Builder baseBuilder, final long startMs, final long endMs,
+                                     @NonNull final JobRequest.JobScheduledCallback callback) {
+        JobPreconditions.checkNotNull(callback);
+        JobConfig.getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    int jobId = schedule(baseBuilder, startMs, endMs);
+                    callback.onJobScheduled(jobId, baseBuilder.mTag, null);
+                } catch (Exception e) {
+                    callback.onJobScheduled(JobRequest.JobScheduledCallback.JOB_ID_ERROR, baseBuilder.mTag, e);
+                }
+            }
+        });
+    }
+
     /**
      * Schedules the daily job only once and runs it immediately. This is helpful if you want to reuse your job
      * and want to trigger the execution immediately. It's possible to schedule a daily job normally with
@@ -156,7 +193,7 @@ protected final Result onRunJob(@NonNull Params params) {
         DailyJobResult result = null;
 
         try {
-            if (meetsRequirements()) {
+            if (meetsRequirements(true)) {
                 result = onRunDailyJob(params);
             } else {
                 result = DailyJobResult.SUCCESS; // reschedule
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index b1fecdc..3374e7c 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -113,10 +113,22 @@
     @WorkerThread
     protected abstract Result onRunJob(@NonNull Params params);
 
+    /**
+     * This method is intended to be overwritten. It is called once when the job is still running, but was
+     * canceled. This can happen when the system wants to stop the job or if you manually cancel the job
+     * yourself. It's a good indicator to stop your work and maybe retry your job later again. Alternatively,
+     * you can also call {@link #isCanceled()}.
+     *
+     * @see #isCanceled()
+     */
+    protected void onCancel() {
+        // override me
+    }
+
     /*package*/ final Result runJob() {
         try {
             // daily jobs check the requirements manually
-            if (this instanceof DailyJob || meetsRequirements()) {
+            if (this instanceof DailyJob || meetsRequirements(true)) {
                 mResult = onRunJob(getParams());
             } else {
                 mResult = getParams().isPeriodic() ? Result.FAILURE : Result.RESCHEDULE;
@@ -142,8 +154,18 @@ protected void onReschedule(int newJobId) {
         // override me
     }
 
-    /*package*/ boolean meetsRequirements() {
-        if (!getParams().getRequest().requirementsEnforced()) {
+    /**
+     * Checks all requirements for this job. It's also possible to check all requirements separately
+     * with the corresponding methods.
+     *
+     * @return Whether all set requirements are met.
+     */
+    protected boolean meetsRequirements() {
+        return meetsRequirements(false);
+    }
+
+    /*package*/ boolean meetsRequirements(boolean checkRequirementsEnforced) {
+        if (checkRequirementsEnforced && !getParams().getRequest().requirementsEnforced()) {
             return true;
         }
 
@@ -160,6 +182,15 @@ protected void onReschedule(int newJobId) {
                     Device.getNetworkType(getContext()));
             return false;
         }
+        if (!isRequirementBatteryNotLowMet()) {
+            CAT.w("Job requires battery not be low, reschedule");
+            return false;
+        }
+
+        if (!isRequirementStorageNotLowMet()) {
+            CAT.w("Job requires storage not be low, reschedule");
+            return false;
+        }
 
         return true;
     }
@@ -263,7 +294,10 @@ public final void cancel() {
 
     /*package*/ final void cancel(boolean deleted) {
         if (!isFinished()) {
-            mCanceled = true;
+            if (!mCanceled) {
+                mCanceled = true;
+                onCancel();
+            }
             mDeleted = deleted;
         }
     }
diff --git a/library/src/main/java/com/evernote/android/job/JobConfig.java b/library/src/main/java/com/evernote/android/job/JobConfig.java
index 93ad09a..11d6f7d 100644
--- a/library/src/main/java/com/evernote/android/job/JobConfig.java
+++ b/library/src/main/java/com/evernote/android/job/JobConfig.java
@@ -90,6 +90,7 @@ public Thread newThread(@NonNull Runnable r) {
 
     private static volatile Clock clock = Clock.DEFAULT;
     private static volatile ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
+    private static volatile boolean closeDatabase = false;
 
     static {
         ENABLED_APIS = new EnumMap<>(JobApi.class);
@@ -315,6 +316,23 @@ public static void setExecutorService(@NonNull ExecutorService executorService)
         JobConfig.executorService = JobPreconditions.checkNotNull(executorService);
     }
 
+    /**
+     * @return Whether the internal database is closed after each access. The default value is {@code false}.
+     */
+    public static boolean isCloseDatabase() {
+        return closeDatabase;
+    }
+
+    /**
+     * Controls whether the internal database should be closed after each access to clean up
+     * resources. The default value is {@code false}.
+     *
+     * @param closeDatabase Whether to close the database after each access.
+     */
+    public static void setCloseDatabase(boolean closeDatabase) {
+        JobConfig.closeDatabase = closeDatabase;
+    }
+
     /**
      * Resets all adjustments in the config.
      */
@@ -330,6 +348,7 @@ public static void reset() {
         forceRtc = false;
         clock = Clock.DEFAULT;
         executorService = DEFAULT_EXECUTOR_SERVICE;
+        closeDatabase = false;
         JobCat.setLogcatEnabled(true);
         JobCat.clearLogger();
     }
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index acc24da..fd88409 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -70,6 +70,20 @@
      */
     public static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.ANY;
 
+    /**
+     * The default callback that is used when you schedule a {@link JobRequest} asynchronously in
+     * {@link #scheduleAsync()}. This implementation only logs a message in case of a failure and
+     * doesn't crash.
+     */
+    public static final JobScheduledCallback DEFAULT_JOB_SCHEDULED_CALLBACK = new JobScheduledCallback() {
+        @Override
+        public void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception) {
+            if (exception != null) {
+                CAT.e(exception, "The job with tag %s couldn't be scheduled", tag);
+            }
+        }
+    };
+
     /**
      * The minimum interval of a periodic job. Specifying a smaller interval will result in an exception.
      *
@@ -405,6 +419,14 @@ public Bundle getTransientExtras() {
     }
 
     /**
+     * Schedule a request which will be executed in the future. If you want to update an existing
+     * {@link JobRequest}, call {@link JobRequest#cancelAndEdit()}, update your parameters and call
+     * this method again. Calling this method on the same request instance multiple times without
+     * cancelling is idempotent.
+     *
+     * <br>
+     * <br>
+     *
      * Convenience method. Internally it calls {@link JobManager#schedule(JobRequest)}
      * and {@link #getJobId()} for this request.
      *
@@ -415,6 +437,40 @@ public int schedule() {
         return getJobId();
     }
 
+    /**
+     * Helper method to schedule a request on a background thread. This is helpful to avoid IO operations
+     * on the main thread.
+     *
+     * <br>
+     * <br>
+     *
+     * In case of a failure an error is logged, but the application doesn't crash.
+     */
+    public void scheduleAsync() {
+        scheduleAsync(DEFAULT_JOB_SCHEDULED_CALLBACK);
+    }
+
+    /**
+     * Helper method to schedule a request on a background thread. This is helpful to avoid IO operations
+     * on the main thread. The callback notifies you about the job ID or a possible failure.
+     *
+     * @param callback The callback which is invoked after the request has been scheduled.
+     */
+    public void scheduleAsync(@NonNull final JobScheduledCallback callback) {
+        JobPreconditions.checkNotNull(callback);
+        JobConfig.getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    int jobId = schedule();
+                    callback.onJobScheduled(jobId, getTag(), null);
+                } catch (Exception e) {
+                    callback.onJobScheduled(JobScheduledCallback.JOB_ID_ERROR, getTag(), e);
+                }
+            }
+        });
+    }
+
     /**
      * Cancel this request if it has been scheduled. Note that if the job isn't periodic, then the
      * time passed since the job has been scheduled is subtracted from the time frame. For example
@@ -489,7 +545,7 @@ public Builder cancelAndEdit() {
         return contentValues;
     }
 
-    /*package*/ static JobRequest fromCursor(Cursor cursor) throws Exception {
+    /*package*/ static JobRequest fromCursor(Cursor cursor) {
         JobRequest request = new Builder(cursor).build();
         request.mFailureCount = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
         request.mScheduledAt = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_SCHEDULED_AT));
@@ -586,7 +642,7 @@ public Builder(@NonNull String tag) {
         }
 
         @SuppressWarnings("unchecked")
-        private Builder(Cursor cursor) throws Exception {
+        private Builder(Cursor cursor) {
             mId = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_ID));
             mTag = cursor.getString(cursor.getColumnIndex(JobStorage.COLUMN_TAG));
 
@@ -1165,4 +1221,23 @@ public int hashCode() {
          */
         METERED
     }
+
+    /**
+     * Callback that is used when scheduling a {@link JobRequest} asynchronously on a background thread.
+     */
+    public interface JobScheduledCallback {
+        /**
+         * The job ID in case scheduling the request failed.
+         */
+        int JOB_ID_ERROR = -1;
+
+        /**
+         * Called after your request was scheduled.
+         *
+         * @param jobId The unique ID of your new scheduled {@link JobRequest}. Or {@link #JOB_ID_ERROR} in case of a failure.
+         * @param tag The tag of the scheduled request.
+         * @param exception If scheduling the request failed, then the exception won't be {@code null}.
+         */
+        void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception);
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index 224720d..b9773b5 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -613,7 +613,7 @@ private static void closeCursor(@Nullable Cursor cursor) {
 
     private static void closeDatabase(@Nullable SQLiteDatabase database) {
         // SQLiteDatabase doesn't implement Closable on some 4.0.3 devices, see #182
-        if (database != null) {
+        if (database != null && JobConfig.isCloseDatabase()) {
             try {
                 database.close();
             } catch (Exception ignored) {
diff --git a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
index 64fff04..c306d04 100644
--- a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
+++ b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
@@ -104,7 +104,6 @@ public boolean onStopJob(JobParameters params) {
             CAT.d("Called onStopJob, job %d not found", params.getJobId());
         }
 
-
         // do not reschedule
         return false;
     }
diff --git a/library/src/test/java/android/support/v4/app/JobIntentServiceReset.java b/library/src/test/java/android/support/v4/app/JobIntentServiceReset.java
new file mode 100644
index 0000000..f3e20e4
--- /dev/null
+++ b/library/src/test/java/android/support/v4/app/JobIntentServiceReset.java
@@ -0,0 +1,14 @@
+package android.support.v4.app;
+
+/**
+ * @author rwondratschek
+ */
+public final class JobIntentServiceReset {
+    private JobIntentServiceReset() {
+        throw new IllegalArgumentException();
+    }
+
+    public static void reset() {
+        JobIntentService.sClassWorkEnqueuer.clear();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/AsyncScheduleTest.java b/library/src/test/java/com/evernote/android/job/AsyncScheduleTest.java
new file mode 100644
index 0000000..f46a407
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/AsyncScheduleTest.java
@@ -0,0 +1,160 @@
+package com.evernote.android.job;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.test.TestClock;
+import com.evernote.android.job.util.JobLogger;
+
+import org.junit.Before;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class AsyncScheduleTest extends BaseJobManagerTest {
+
+    @Before
+    public void prepare() {
+        JobConfig.setExecutorService(Executors.newSingleThreadExecutor());
+    }
+
+    @Test
+    public void verifyScheduleAsync() throws Exception {
+        DummyJobs.createBuilder(DummyJobs.SuccessJob.class).setExecutionWindow(300_000, 400_000).build().scheduleAsync();
+        waitUntilScheduled();
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+    }
+
+    @Test
+    public void verifyJobIdAsync() throws Exception {
+        final AtomicInteger jobId = new AtomicInteger(-2);
+        DummyJobs.createBuilder(DummyJobs.SuccessJob.class).setExecutionWindow(300_000, 400_000).build()
+                .scheduleAsync(new JobRequest.JobScheduledCallback() {
+                    @Override
+                    public void onJobScheduled(int id, @NonNull String tag, @Nullable Exception exception) {
+                        jobId.set(id);
+                    }
+                });
+
+        waitUntilScheduled();
+        assertThat(manager().getJobRequest(jobId.get())).isNotNull();
+    }
+
+    @Test
+    public void verifyErrorAsync() throws Exception {
+        JobScheduler jobScheduler = mock(JobScheduler.class);
+        when(jobScheduler.schedule(any(JobInfo.class))).thenThrow(new RuntimeException("test"));
+        when(context().getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(jobScheduler);
+
+        final AtomicReference<Exception> reference = new AtomicReference<>();
+
+        new JobRequest.Builder("tag")
+                .setExecutionWindow(200_000, 300_000)
+                .build()
+                .scheduleAsync(new JobRequest.JobScheduledCallback() {
+                    @Override
+                    public void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception) {
+                        assertThat(jobId).isEqualTo(JOB_ID_ERROR);
+                        reference.set(exception);
+                    }
+                });
+
+        waitUntilScheduled();
+        assertThat(reference.get()).isInstanceOf(RuntimeException.class);
+    }
+
+    @Test
+    public void verifyErrorIsLoggedInDefaultHandler() throws Exception {
+        final String errorMessage = "test ABC";
+
+        JobScheduler jobScheduler = mock(JobScheduler.class);
+        when(jobScheduler.schedule(any(JobInfo.class))).thenThrow(new RuntimeException(errorMessage));
+        when(context().getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(jobScheduler);
+
+        final AtomicInteger specificError = new AtomicInteger(0);
+        JobConfig.addLogger(new JobLogger() {
+            @Override
+            public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+                if (t != null && t.getMessage().equals(errorMessage)) {
+                    specificError.incrementAndGet();
+                }
+            }
+        });
+
+        new JobRequest.Builder("tag").setExecutionWindow(200_000, 300_000).build().scheduleAsync();
+        waitUntilScheduled();
+
+        assertThat(specificError.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void verifyJobIdAsyncDailyJob() throws Exception {
+        JobConfig.setClock(new TestClock());
+
+        final AtomicInteger jobId = new AtomicInteger(-2);
+        DailyJob.scheduleAsync(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), 1000, 2000, new JobRequest.JobScheduledCallback() {
+            @Override
+            public void onJobScheduled(int id, @NonNull String tag, @Nullable Exception exception) {
+                jobId.set(id);
+            }
+        });
+
+        waitUntilScheduled();
+        assertThat(manager().getJobRequest(jobId.get())).isNotNull();
+    }
+
+    @Test
+    public void verifyErrorAsyncDailyJob() throws Exception {
+        JobConfig.setClock(new TestClock());
+
+        JobScheduler jobScheduler = mock(JobScheduler.class);
+        when(jobScheduler.schedule(any(JobInfo.class))).thenThrow(new RuntimeException("test"));
+        when(context().getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(jobScheduler);
+
+        final AtomicReference<Exception> reference = new AtomicReference<>();
+
+        DailyJob.scheduleAsync(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), 1000, 2000, new JobRequest.JobScheduledCallback() {
+            @Override
+            public void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception) {
+                assertThat(jobId).isEqualTo(JOB_ID_ERROR);
+                reference.set(exception);
+            }
+        });
+
+        waitUntilScheduled();
+        assertThat(reference.get()).isInstanceOf(RuntimeException.class);
+    }
+
+    private void waitUntilScheduled() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        JobConfig.getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                latch.countDown();
+            }
+        });
+        latch.await(50, TimeUnit.SECONDS);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
index 4dd00fe..fc97b04 100644
--- a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
@@ -119,7 +119,7 @@ protected void resetJob(int jobId) {
      * {@link Context#getApplicationContext()}.
      */
     public static Context createMockContext() {
-        // otherwise the JobScheduler isn't supported we check if the service is enable
+        // otherwise the JobScheduler isn't supported we check if the service is enabled
         // Robolectric doesn't parse services from the manifest, see https://github.com/robolectric/robolectric/issues/416
         PackageManager packageManager = mock(PackageManager.class);
         when(packageManager.queryBroadcastReceivers(any(Intent.class), anyInt())).thenReturn(Collections.singletonList(new ResolveInfo()));
diff --git a/library/src/test/java/com/evernote/android/job/JobCanceledTest.java b/library/src/test/java/com/evernote/android/job/JobCanceledTest.java
new file mode 100644
index 0000000..3b16487
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobCanceledTest.java
@@ -0,0 +1,106 @@
+package com.evernote.android.job;
+
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobCanceledTest extends BaseJobManagerTest {
+
+    @Test
+    public void verifyOnCancelInvokedOnce() {
+        final AtomicInteger onCancelCalled = new AtomicInteger(0);
+        final Job job = new Job() {
+            @NonNull
+            @Override
+            protected Result onRunJob(@NonNull Params params) {
+                cancel();
+                cancel();
+                cancel();
+                return Result.SUCCESS;
+            }
+
+            @Override
+            protected void onCancel() {
+                onCancelCalled.incrementAndGet();
+            }
+        };
+
+        manager().addJobCreator(new JobCreator() {
+            @Override
+            public Job create(@NonNull String tag) {
+                return job;
+            }
+        });
+
+        final String tag = "something";
+        final int jobId = new JobRequest.Builder(tag)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.SUCCESS);
+
+        assertThat(manager().getAllJobRequestsForTag(tag)).isEmpty();
+
+        assertThat(manager().getJobRequest(jobId)).isNull();
+        assertThat(manager().getJobRequest(jobId, true)).isNull();
+
+        assertThat(job.isCanceled()).isTrue();
+        assertThat(onCancelCalled.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void verifyOnCancelNotInvokedWhenFinished() {
+        final AtomicInteger onCancelCalled = new AtomicInteger(0);
+        final Job job = new Job() {
+            @NonNull
+            @Override
+            protected Result onRunJob(@NonNull Params params) {
+                return Result.SUCCESS;
+            }
+
+            @Override
+            protected void onCancel() {
+                onCancelCalled.incrementAndGet();
+            }
+        };
+
+        manager().addJobCreator(new JobCreator() {
+            @Override
+            public Job create(@NonNull String tag) {
+                return job;
+            }
+        });
+
+        final String tag = "something";
+        final int jobId = new JobRequest.Builder(tag)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.SUCCESS);
+        job.cancel();
+
+        assertThat(manager().getAllJobRequestsForTag(tag)).isEmpty();
+
+        assertThat(manager().getJobRequest(jobId)).isNull();
+        assertThat(manager().getJobRequest(jobId, true)).isNull();
+
+        assertThat(job.isCanceled()).isFalse();
+        assertThat(onCancelCalled.get()).isEqualTo(0);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobConfigTest.java b/library/src/test/java/com/evernote/android/job/JobConfigTest.java
index 3fb8118..e33c47a 100644
--- a/library/src/test/java/com/evernote/android/job/JobConfigTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobConfigTest.java
@@ -1,5 +1,6 @@
 package com.evernote.android.job;
 
+import android.database.sqlite.SQLiteDatabase;
 import android.os.Build;
 
 import com.evernote.android.job.test.DummyJobs;
@@ -12,6 +13,12 @@
 import org.robolectric.annotation.Config;
 
 import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.nullable;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 /**
  * @author rwondratschek
@@ -158,4 +165,26 @@ public void verifyJobIdOffsetBounds() {
         JobConfig.setJobIdOffset(0);
         JobConfig.setJobIdOffset(2147480000 - 500);
     }
+
+    @Test
+    public void verifyCloseDatabase() {
+        assertThat(JobConfig.isCloseDatabase()).isFalse(); // default
+
+        SQLiteDatabase database = mock(SQLiteDatabase.class);
+
+        JobStorage storage = manager().getJobStorage();
+        storage.injectDatabase(database);
+
+        storage.get(1);
+        verify(database, times(1)).query(anyString(), nullable(String[].class), anyString(),
+                any(String[].class), nullable(String.class), nullable(String.class), nullable(String.class));
+        verify(database, times(0)).close();
+
+        JobConfig.setCloseDatabase(true);
+
+        storage.get(1);
+        verify(database, times(2)).query(anyString(), nullable(String[].class), anyString(),
+                any(String[].class), nullable(String.class), nullable(String.class), nullable(String.class));
+        verify(database, times(1)).close();
+    }
 }
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerRule.java b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
index 0b88ee8..0c05455 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerRule.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.support.annotation.NonNull;
+import android.support.v4.app.JobIntentServiceReset;
 
 import com.evernote.android.job.test.TestLogger;
 
@@ -23,6 +24,8 @@ public JobManagerRule(@NonNull JobCreator jobCreator, @NonNull Context context)
 
     @Override
     protected void before() throws Throwable {
+        JobIntentServiceReset.reset();
+
         JobConfig.addLogger(TestLogger.INSTANCE);
         JobConfig.setSkipJobReschedule(true);
 
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerTest.java b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
index d4f511c..5c94c3d 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
@@ -104,6 +104,24 @@ public void testScheduleIsIdempotent() throws Exception {
         assertThat(request.getScheduledAt()).isEqualTo(scheduledAt);
     }
 
+    @Test
+    public void testScheduleIsNotIdempotentWithNewRequest() throws Exception {
+        JobRequest.Builder builder = DummyJobs.createBuilder(DummyJobs.SuccessJob.class).setExecutionWindow(300_000, 400_000);
+        JobRequest request1 = builder.build();
+        int jobId = request1.schedule();
+
+        long scheduledAt = request1.getScheduledAt();
+        assertThat(scheduledAt).isGreaterThan(0L);
+
+        Thread.sleep(10);
+
+        JobRequest request2 = builder.build();
+        int newJobId = request2.schedule();
+
+        assertThat(newJobId).isGreaterThan(jobId);
+        assertThat(request2.getScheduledAt()).isGreaterThan(scheduledAt);
+    }
+
     @Test
     public void testSimultaneousCancel() throws Exception {
         final int threadCount = 5;
diff --git a/library/src/test/java/com/evernote/android/job/JobRequirementTest.java b/library/src/test/java/com/evernote/android/job/JobRequirementTest.java
index 68d9ed5..1a81d46 100644
--- a/library/src/test/java/com/evernote/android/job/JobRequirementTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobRequirementTest.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.PowerManager;
 import android.test.mock.MockContext;
 
 import com.evernote.android.job.test.DummyJobs;
@@ -25,125 +26,215 @@
 
     @Test
     public void verifyRequirementNetworkMeteredOnRoaming() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkMeteredOnMobile() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, false);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkMeteredOnWifi() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_WIFI, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_WIFI, false);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkMeteredNoConnection() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, false, ConnectivityManager.TYPE_WIFI, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.METERED, false, ConnectivityManager.TYPE_WIFI, false);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkNotRoamingOnRoaming() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, true);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkNotRoamingOnMobile() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, false);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkNotRoamingOnWifi() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkNotRoamingNoConnection() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, false, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.NOT_ROAMING, false, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkUnmeteredOnRoaming() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, true);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkUnmeteredOnMobile() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, false);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkUnmeteredOnWifi() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkUnmeteredNoConnection() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, false, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.UNMETERED, false, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkConnectedOnRoaming() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkConnectedOnMobile() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, false);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkConnectedWifi() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkConnectedNoConnection() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, false, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, false, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isFalse();
     }
 
     @Test
     public void verifyRequirementNetworkAnyOnRoaming() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkAnyOnMobile() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, false);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, false);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkAnyWifi() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
     @Test
     public void verifyRequirementNetworkAnyNoConnection() {
-        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, false, ConnectivityManager.TYPE_WIFI, true);
+        Job job = createMockedJob();
+        setupNetworkRequirement(job, JobRequest.NetworkType.ANY, false, ConnectivityManager.TYPE_WIFI, true);
         assertThat(job.isRequirementNetworkTypeMet()).isTrue();
     }
 
-    private Job setupNetworkRequirement(JobRequest.NetworkType requirement, boolean connected, int networkType, boolean roaming) {
+    @Test
+    public void verifyRequirementDeviceIdleIsIdle() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, true, true);
+        assertThat(job.isRequirementDeviceIdleMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementDeviceIdleIsNotIdle() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, true, false);
+        assertThat(job.isRequirementDeviceIdleMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementDeviceNoRequirement() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, false, false);
+        assertThat(job.isRequirementDeviceIdleMet()).isTrue();
+
+        setupDeviceIdle(job, false, true);
+        assertThat(job.isRequirementDeviceIdleMet()).isTrue();
+    }
+
+    @Test
+    public void verifyMeetsRequirementsAllMet() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, true, true);
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_WIFI, false);
+
+        assertThat(job.isRequirementDeviceIdleMet()).isTrue();
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+        assertThat(job.meetsRequirements()).isTrue();
+    }
+
+    @Test
+    public void verifyMeetsRequirementsOnlyIdle() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, true, true);
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, false, ConnectivityManager.TYPE_WIFI, false);
+
+        assertThat(job.isRequirementDeviceIdleMet()).isTrue();
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+        assertThat(job.meetsRequirements()).isFalse();
+    }
+
+    @Test
+    public void verifyMeetsRequirementsOnlyNetwork() {
+        Job job = createMockedJob();
+        setupDeviceIdle(job, true, false);
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_WIFI, false);
+
+        assertThat(job.isRequirementDeviceIdleMet()).isFalse();
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+        assertThat(job.meetsRequirements()).isFalse();
+    }
+
+    @Test
+    public void verifyMeetsRequirementsEnforcedIgnored() {
+        Job job = createMockedJob();
+        when(job.getParams().getRequest().requirementsEnforced()).thenReturn(false);
+        setupDeviceIdle(job, true, false);
+        setupNetworkRequirement(job, JobRequest.NetworkType.CONNECTED, false, ConnectivityManager.TYPE_WIFI, false);
+
+        assertThat(job.isRequirementDeviceIdleMet()).isFalse();
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+        assertThat(job.meetsRequirements()).isFalse();
+        assertThat(job.meetsRequirements(true)).isTrue();
+    }
+
+    private void setupNetworkRequirement(Job job, JobRequest.NetworkType requirement, boolean connected, int networkType, boolean roaming) {
         NetworkInfo networkInfo = mock(NetworkInfo.class);
         when(networkInfo.isConnected()).thenReturn(connected);
         when(networkInfo.isConnectedOrConnecting()).thenReturn(connected);
@@ -153,12 +244,28 @@ private Job setupNetworkRequirement(JobRequest.NetworkType requirement, boolean
         ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
         when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
 
+        when(job.getContext().getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        when(job.getParams().getRequest().requiredNetworkType()).thenReturn(requirement);
+    }
+
+    @SuppressWarnings("deprecation")
+    private void setupDeviceIdle(Job job, boolean requirement, boolean deviceIdle) {
+        PowerManager powerManager = mock(PowerManager.class);
+        when(powerManager.isDeviceIdleMode()).thenReturn(deviceIdle);
+        when(powerManager.isInteractive()).thenReturn(!deviceIdle);
+        when(powerManager.isScreenOn()).thenReturn(!deviceIdle);
+        when(powerManager.isInteractive()).thenReturn(!deviceIdle);
+
+        when(job.getParams().getRequest().requiresDeviceIdle()).thenReturn(requirement);
+
+        when(job.getContext().getSystemService(Context.POWER_SERVICE)).thenReturn(powerManager);
+    }
+
+    private Job createMockedJob() {
         Context context = mock(MockContext.class);
-        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
 
         JobRequest request = mock(JobRequest.class);
-        when(request.requiredNetworkType()).thenReturn(requirement);
-
         Job.Params params = mock(Job.Params.class);
         when(params.getRequest()).thenReturn(request);
 
diff --git a/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java b/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java
index 69c014c..b5bf68c 100644
--- a/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java
@@ -5,7 +5,6 @@
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Build;
 import android.os.Bundle;
 
 import com.evernote.android.job.test.JobRobolectricTestRunner;
@@ -30,7 +29,7 @@
 public class JobRescheduleTest extends BaseJobManagerTest {
 
     @Test
-    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    @Config(sdk = 21)
     public void verifyOneOffJobRescheduled() throws Exception {
         assertThat(manager().getAllJobRequests()).isEmpty();
 
@@ -50,7 +49,7 @@ public void verifyOneOffJobRescheduled() throws Exception {
     }
 
     @Test
-    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    @Config(sdk = 21)
     public void verifyPeriodicJobRescheduled() throws Exception {
         assertThat(manager().getAllJobRequests()).isEmpty();
 
@@ -73,7 +72,7 @@ public void verifyPeriodicJobRescheduled() throws Exception {
     }
 
     @Test
-    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    @Config(sdk = 21)
     public void verifyExactJobRescheduled() throws Exception {
         assertThat(manager().getAllJobRequests()).isEmpty();
 
