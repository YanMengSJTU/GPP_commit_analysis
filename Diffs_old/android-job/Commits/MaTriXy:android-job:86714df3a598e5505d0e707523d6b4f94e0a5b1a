diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6c9d234..fbd503a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,30 @@
+## 1.1.9
+
+* Improve logging by providing an option to add a custom logger
+* Fix crash when rescheduling jobs, see #164
+* Fix wrong returned network type, see #166
+* Expose failure count in the `JobRequest` class, see #168
+* Don't silently eat `JobScheduler`'s limit exception
+
+## 1.1.8 (2017-03-23)
+
+* Catch wake lock crashes in all cases, fixes #153
+* Use a better execution in parallel with the `AlarmManager`. This may prevent a process death.
+* Use better thread names
+* List for quick boot completed broad casts, see #157
+
+## 1.1.7 (2017-02-27)
+
+* Use a service to reschedule jobs and prevent a too early process death, fixes #142
+
+## 1.1.6 (2017-02-13)
+
+* Reschedule jobs after an app update occurred or the Google Play Services were updated, see #135
+
+## 1.1.5 (2017-01-25)
+
+* Use only back-off criteria when rescheduling jobs, see #134
+
 ## 1.1.4 (2017-01-05)
 
 * Expose schedule time of a job
diff --git a/FAQ.md b/FAQ.md
index e04e6f4..5434870 100644
--- a/FAQ.md
+++ b/FAQ.md
@@ -215,4 +215,79 @@ public final class AddReceiver extends AddJobCreatorReceiver {
         manager.addJobCreator(new DemoJobCreator());
     }
 }
+```
+
+### Why aren't my periodic jobs running as expected on Android 5 or higher?
+
+On Android Lollipop or above the `JobScheduler` is used for periodic jobs. Android optimizes apps for battery usage, meaning that it tries to save as much power as possible. If your jobs have a high frequency, then it's possible, that some periods are skipped, because the device is saving battery.
+
+You can read more about Doze and App Standby [in the official documentation](https://developer.android.com/training/monitoring-device-state/doze-standby.html) to understand how it works and its implications.
+
+### What happens with jobs after the app was forced killed?
+
+After the app was force killed (or swiped away from the recent list on some devices) Android clears all pending alarms from the `AlarmManager` for this app. This is problematic, because until the app is being relaunched alarms can't be rescheduled and jobs won't run. Unfortunately, there is no known workaround.
+
+When the app is being relaunched, this library automatically reschedules pending jobs if necessary. The library also register a [boot completed receiver](https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobBootReceiver.java), so that jobs are rescheduled after a reboot.
+
+Note that only the `AlarmManager` is affected. Jobs relying on the `JobScheduler` or `GcmNetworkManager` still work reliable.
+
+### Can I run a job in a different process?
+
+No, that's not possible. The library can't know your process name in advance to start all services in this process. The recommended way is to start your service in the other process from the job.
+
+```java
+public class SeparateProcessJob extends Job {
+    @Override
+    @NonNull
+    protected Result onRunJob(final Params params) {
+        Intent intent = new Intent(getContext(), SeparateProcessService.class);
+        startWakefulService(intent);
+        return Result.SUCCESS;
+    }
+}
+
+public class SeparateProcessService extends IntentService {
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        try {
+            // do work
+        } finally {
+            Job.completeWakefulIntent(intent);
+        }
+    }
+}
+```
+
+### How can I add a custom logger?
+
+By default the library prints all log statement in Logcat. But often you wish to store those somewhere else, e.g. in a file. The `JobCat` class gives you an option register a custom logger. It's recommended to add the logger before creating the `JobManager` instance.
+
+```java
+private class TestPrinter implements CatPrinter {
+
+    @Override
+    public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+        switch (priority) {
+            case Log.ERROR:
+                // do something
+                break;
+        }
+    }
+}
+
+public class App extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        JobCat.addLogPrinter(new TestPrinter());
+        JobManager.create(this).addJobCreator(new DemoJobCreator());
+    }
+}
+```
+
+If you wish, you can even disable printing messages to Logcat, if you own logger handles that for you
+```java
+JobCat.setLogcatEnabled(false);
 ```
\ No newline at end of file
diff --git a/README.md b/README.md
index e3a8b06..fb72345 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # Android-Job
 
-An utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post](https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/) or in [these slides](https://speakerdeck.com/vrallev/scheduling-background-job-on-android-at-the-right-time) why you should prefer this library than each separate API. All features from Android Nougat are backward compatible.
+An utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post](https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/) or in [these slides](https://speakerdeck.com/vrallev/scheduling-background-job-on-android-at-the-right-time-1) why you should prefer this library than each separate API. All features from Android Nougat are backward compatible.
 
 ## Download
 
@@ -8,7 +8,7 @@ Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evern
 
 ```groovy
 dependencies {
-    compile 'com.evernote:android-job:1.1.4'
+    compile 'com.evernote:android-job:1.1.8'
 }
 ```
 
diff --git a/build-config/gradle-push.gradle b/build-config/gradle-push.gradle
index d1a8628..5976637 100644
--- a/build-config/gradle-push.gradle
+++ b/build-config/gradle-push.gradle
@@ -1,16 +1,17 @@
 apply plugin: 'maven'
 apply plugin: 'signing'
 
+@SuppressWarnings(["GrMethodMayBeStatic", "GroovyUnusedDeclaration"])
 def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def isLocal() {
-    return hasProperty('local') ? Boolean.parseBoolean(getProperty('local')) : true;
+    return hasProperty('local') ? Boolean.parseBoolean(getProperty('local')) : true
 }
 
 def getReleaseRepositoryUrl() {
-    if (isLocal()) {
+    if (this.isLocal()) {
         return hasProperty('RELEASE_REPOSITORY_LOCAL') ? RELEASE_REPOSITORY_LOCAL : "file://${System.env.HOME}/.m2/repository"
     } else {
         return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
@@ -18,7 +19,7 @@ def getReleaseRepositoryUrl() {
 }
 
 def getSnapshotRepositoryUrl() {
-    if (isLocal()) {
+    if (this.isLocal()) {
         return hasProperty('SNAPSHOT_REPOSITORY_LOCAL') ? SNAPSHOT_REPOSITORY_LOCAL : "file://${System.env.HOME}/.m2/repository"
     } else {
         return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL : "https://oss.sonatype.org/content/repositories/snapshots/"
@@ -33,10 +34,28 @@ def getRepositoryPassword() {
     return hasProperty('SONATYPE_PASSWORD') ? SONATYPE_PASSWORD : ""
 }
 
+android.libraryVariants.all { variant ->
+    variant.outputs.each { output ->
+        File outputFile = output.outputFile
+        if (outputFile != null && outputFile.name.endsWith('.aar') && 'release'.equals(variant.buildType.name)) {
+            def fileName = "${project.archivesBaseName}-${version}.aar"
+            output.outputFile = new File(outputFile.parent, fileName)
+        }
+    }
+}
+
+version = VERSION_NAME
+
+artifacts {
+    archives file("$buildDir/outputs/jar/${project.archivesBaseName}-${project.version}-sources.jar")
+    archives file("$buildDir/outputs/jar/${project.archivesBaseName}-${project.version}-javadoc.jar")
+}
+
 afterEvaluate { project ->
     uploadArchives {
         //noinspection GradleMisplacedStatement
         repositories {
+            //noinspection GroovyAssignabilityCheck
             mavenDeployer {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
@@ -44,11 +63,11 @@ afterEvaluate { project ->
                 pom.artifactId = 'android-job'
                 pom.version = VERSION_NAME
 
-                repository(url: getReleaseRepositoryUrl()) {
-                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                repository(url: this.getReleaseRepositoryUrl()) {
+                    authentication(userName: this.getRepositoryUsername(), password: this.getRepositoryPassword())
                 }
-                snapshotRepository(url: getSnapshotRepositoryUrl()) {
-                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                snapshotRepository(url: this.getSnapshotRepositoryUrl()) {
+                    authentication(userName: this.getRepositoryUsername(), password: this.getRepositoryPassword())
                 }
 
                 pom.project {
@@ -95,31 +114,82 @@ afterEvaluate { project ->
     }
 
     signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        required { gradle.taskGraph.hasTask("uploadArchives") }
         sign configurations.archives
     }
+}
 
-    task androidJavadocs2(type: Javadoc) {
-        failOnError = false
-        source = android.sourceSets.main.java.sourceFiles
-        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+project.tasks.whenTaskAdded { task ->
+    if (task.name == 'signArchives') {
+        this.addSourcesAndJavadocTask task
     }
+}
 
-    task androidJavadocsJar2(type: Jar, dependsOn: androidJavadocs2) {
-        classifier = 'javadoc'
-        //basename = artifact_id
-        from androidJavadocs2.destinationDir
+def addSourcesAndJavadocTask(Task uploadTask) {
+    android.libraryVariants.all { variant ->
+        if (variant.name.equalsIgnoreCase('release')) {
+            uploadTask.dependsOn project.tasks.getByName("assemble${variant.name.capitalize()}")
+            uploadTask.dependsOn project.tasks.getByName("generate${variant.name.capitalize()}JavadocJar")
+            uploadTask.dependsOn project.tasks.getByName("generate${variant.name.capitalize()}SourcesJar")
+        }
     }
+}
 
-    task androidSourcesJar2(type: Jar) {
-        classifier = 'sources'
-        //basename = artifact_id
-        from android.sourceSets.main.java.sourceFiles
+// javadoc jar
+android.libraryVariants.all { variant ->
+    project.task("${variant.name.capitalize()}Javadoc", type: Javadoc) {
+        failOnError true
+
+        destinationDir = new File("$project.buildDir/javadoc/$variant.name")
+
+        source = variant.javaCompile.source
+
+        ext.androidJar = "${project.android.sdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"
+        classpath += project.files(variant.javaCompile.classpath.files) + project.files(ext.androidJar)
+        classpath += files("$buildDir/generated/source/r/${variant.name}/")
+        classpath += files("$buildDir/generated/source/buildConfig/${variant.name}/")
+
+        options {
+            linksOffline("http://d.android.com/reference", "${project.android.sdkDirectory}/docs/reference")
+            links("http://docs.oracle.com/javase/7/docs/api/")
+            setMemberLevel(JavadocMemberLevel.PACKAGE)
+            addStringOption('Xdoclint:none', '-quiet')
+            docEncoding = 'UTF-8'
+            encoding = 'UTF-8'
+            charSet = 'UTF-8'
+        }
+
+        exclude '**/BuildConfig.java'
+        exclude '**/R.java'
     }
 
-    artifacts {
-        //archives packageReleaseJar
-        archives androidSourcesJar2
-        archives androidJavadocsJar2
+    project.task("generate${variant.name.capitalize()}JavadocJar", type: Jar, dependsOn: "${variant.name.capitalize()}Javadoc") {
+        classifier 'javadoc'
+
+        description = 'Assembles a jar archive containing the generated Javadoc API documentation of $variant.name.'
+
+        destinationDir = new File("$project.buildDir/outputs/jar/")
+
+        exclude '**/BuildConfig.class'
+        exclude '**/R.class'
+
+        from "$project.buildDir/javadoc/$variant.name"
+    }
+}
+
+// sources jar
+android.libraryVariants.all { variant ->
+    project.task("generate${variant.name.capitalize()}SourcesJar", type: Jar) {
+        classifier = 'sources'
+
+        description = 'Assembles a jar archive containing the main sources of $variant.name..'
+
+        destinationDir = new File("$project.buildDir/outputs/jar/")
+
+        // exclude generated files
+        exclude '**/BuildConfig.java'
+        exclude '**/R.java'
+
+        from variant.javaCompile.source
     }
 }
\ No newline at end of file
diff --git a/build-config/gradle-quality.gradle b/build-config/gradle-quality.gradle
index 55c61e1..509d2cb 100644
--- a/build-config/gradle-quality.gradle
+++ b/build-config/gradle-quality.gradle
@@ -9,6 +9,7 @@ task checkstyle(type: Checkstyle) {
     source 'src'
     include '**/*.java'
     exclude '**/gen/**'
+    exclude '**/XmlUtils.java'
 
     classpath = files()
 //
diff --git a/build.gradle b/build.gradle
index 7771efc..2dc890b 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.3'
+        classpath 'com.android.tools.build:gradle:2.3.0'
         classpath 'com.github.ben-manes:gradle-versions-plugin:0.13.0'
     }
 }
@@ -22,10 +22,14 @@ ext {
     buildToolsVersion = '25.0.2'
 
     supportLibVersion = '25.0.0'
-    playServicesVersion = '9.8.0'
-    stethoVersion = '1.4.1'
+    playServicesVersion = '10.2.1'
+    stethoVersion = '1.4.2'
+    junitVersion = '4.12'
+    assertjVersion = '3.6.2'
+    mockitoVersion = '2.6.2'
+    robolectricVersion = '3.3.2'
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '3.3'
+    gradleVersion = '3.4.1'
 }
diff --git a/demo/build.gradle b/demo/build.gradle
index 5fe3602..58eb61d 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -40,17 +40,16 @@ android {
 
     lintOptions {
         abortOnError true
-
-        htmlOutput file("$project.buildDir/reports/lint/lint.html")
-        xmlOutput file("$project.buildDir/reports/lint/lint.xml")
     }
 }
 
 dependencies {
     compile project(':library')
-    compile "com.android.support:appcompat-v7:$rootProject.ext.supportLibVersion"
-
-    compile "com.facebook.stetho:stetho:$rootProject.ext.stethoVersion"
+    compile "com.android.support:support-v4:$supportLibVersion"
+    compile "com.android.support:appcompat-v7:$supportLibVersion"
+    compile "com.facebook.stetho:stetho:$stethoVersion"
 
-    gcmCompile "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
+    gcmCompile "com.google.android.gms:play-services-gcm:$playServicesVersion"
 }
+
+uploadArchives.enabled false
\ No newline at end of file
diff --git a/demo/lint.xml b/demo/lint.xml
index 5858c1c..3647a1a 100644
--- a/demo/lint.xml
+++ b/demo/lint.xml
@@ -6,4 +6,5 @@
     </issue>
     <issue id="GradleDependency" severity="ignore"/>
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GradleCompatible" severity="ignore"/>
 </lint>
\ No newline at end of file
diff --git a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
index 9ac2eec..cd3b72f 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
@@ -175,9 +175,7 @@ public void onClick(View view) {
                 break;
 
             case R.id.button_exact:
-                for (int i = 0; i < 5; i++) {
-                    testExact();
-                }
+                testExact();
                 break;
 
             case R.id.button_sync_history:
diff --git a/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
new file mode 100644
index 0000000..5c94385
--- /dev/null
+++ b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
@@ -0,0 +1,135 @@
+package com.evernote.android.job.demo;
+
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.support.PersistableBundleCompat;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author rwondratschek
+ */
+public final class UnitTestDatabaseCreator {
+
+    private static boolean random() {
+        return Math.random() > 0.5;
+    }
+
+    public void createV1() {
+        createJobs(new DummyJobCreatorV1());
+    }
+
+    public void createV2() {
+        createJobs(new DummyJobCreatorV1()); // same as v1, only transient column is new
+    }
+
+    public void createV3() {
+        createJobs(new DummyJobCreatorV3());
+    }
+
+    private void createJobs(DummyJobCreator creator) {
+        creator.createOneOff();
+        creator.createExact();
+        creator.createPeriodic();
+    }
+
+    private interface DummyJobCreator {
+        void createOneOff();
+
+        void createExact();
+
+        void createPeriodic();
+    }
+
+    private static class DummyJobCreatorV1 implements DummyJobCreator {
+        @Override
+        public void createOneOff() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setExecutionWindow(300_000, 400_000)
+                        .setBackoffCriteria(5_000L, random() ? JobRequest.BackoffPolicy.EXPONENTIAL : JobRequest.BackoffPolicy.LINEAR)
+                        .setRequiresCharging(random())
+                        .setRequiresDeviceIdle(random())
+                        .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
+                        .setRequirementsEnforced(random())
+                        .setPersisted(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+
+                builder.build().schedule();
+            }
+
+        }
+
+        @Override
+        public void createExact() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setExact(400_000)
+                        .setBackoffCriteria(5_000L, random() ? JobRequest.BackoffPolicy.EXPONENTIAL : JobRequest.BackoffPolicy.LINEAR)
+                        .setPersisted(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+
+                builder.build().schedule();
+            }
+
+        }
+
+        @Override
+        public void createPeriodic() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setPeriodic(TimeUnit.MINUTES.toMillis(1))
+                        .setRequiresCharging(random())
+                        .setRequiresDeviceIdle(random())
+                        .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
+                        .setRequirementsEnforced(random())
+                        .setPersisted(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+
+                builder.build().schedule();
+            }
+        }
+    }
+
+    private static final class DummyJobCreatorV3 extends DummyJobCreatorV1 {
+        @Override
+        public void createPeriodic() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setRequiresCharging(random())
+                        .setRequiresDeviceIdle(random())
+                        .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
+                        .setRequirementsEnforced(random())
+                        .setPersisted(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+                if (random()) {
+                    builder.setPeriodic(JobRequest.MIN_INTERVAL);
+                } else {
+                    builder.setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX);
+                }
+
+                builder.build().schedule();
+            }
+
+        }
+    }
+}
diff --git a/gradle.properties b/gradle.properties
index 1fe3ce6..be965e4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.1.4
-VERSION_NAME=1.1.4-SNAPSHOT
+#VERSION_NAME=1.1.9
+VERSION_NAME=1.1.9-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 634deed..0833ac4 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 21fd3d4..53d557f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Jan 05 14:09:58 CET 2017
+#Tue Mar 07 14:17:43 CET 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index ab26328..f66d38e 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -2,20 +2,27 @@ apply plugin: 'com.android.library'
 apply plugin: 'com.github.ben-manes.versions'
 apply from: '../build-config/gradle-quality.gradle'
 
+archivesBaseName = 'android-job'
+
 dependencies {
-    provided "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
-    //compile "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
+    provided "com.google.android.gms:play-services-gcm:$playServicesVersion"
 
     //noinspection GradleDependency
-    compile "com.android.support:support-annotations:$rootProject.ext.supportLibVersion"
+    compile "com.android.support:support-annotations:$supportLibVersion"
     compile 'net.vrallev.android:cat:1.0.5'
 
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
     androidTestCompile 'com.squareup.assertj:assertj-android:1.1.1'
+    androidTestCompile "com.google.android.gms:play-services-gcm:$playServicesVersion"
+
+    androidTestCompile "com.facebook.stetho:stetho:$stethoVersion"
 
-    androidTestCompile "com.facebook.stetho:stetho:$rootProject.ext.stethoVersion"
+    testCompile "junit:junit:$junitVersion"
+    testCompile "org.mockito:mockito-core:$mockitoVersion"
+    testCompile "org.assertj:assertj-core:$assertjVersion"
+    testCompile "org.robolectric:robolectric:$robolectricVersion"
 }
 
 android {
@@ -43,9 +50,15 @@ android {
 
     lintOptions {
         abortOnError true
+    }
 
-        htmlOutput file("$project.buildDir/reports/lint/lint.html")
-        xmlOutput file("$project.buildDir/reports/lint/lint.xml")
+    testOptions {
+        unitTests.returnDefaultValues = true
+        unitTests.all {
+            testLogging {
+                events 'passed', 'skipped', 'failed', 'standardOut', 'standardError'
+            }
+        }
     }
 }
 
diff --git a/library/proguard.txt b/library/proguard.txt
index 1f9ff63..92506fb 100644
--- a/library/proguard.txt
+++ b/library/proguard.txt
@@ -4,4 +4,5 @@
 -keep public class com.evernote.android.job.v21.PlatformJobService
 -keep public class com.evernote.android.job.v14.PlatformAlarmService
 -keep public class com.evernote.android.job.v14.PlatformAlarmReceiver
--keep public class com.evernote.android.job.JobBootReceiver
\ No newline at end of file
+-keep public class com.evernote.android.job.JobBootReceiver
+-keep public class com.evernote.android.job.JobRescheduleService
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java b/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java
deleted file mode 100644
index 585f84c..0000000
--- a/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package com.evernote.android.job;
-
-import android.content.Context;
-import android.os.SystemClock;
-import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.filters.LargeTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import com.facebook.stetho.Stetho;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * @author rwondratschek
- */
-@RunWith(AndroidJUnit4.class)
-@LargeTest
-public class JobExecutionTest {
-
-    private static Set<Integer> cachedJobIds;
-
-    @BeforeClass
-    public static void beforeClass() {
-        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
-
-        JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
-            @Override
-            public Job create(String tag) {
-                return new TestJob();
-            }
-        });
-        cachedJobIds = new HashSet<>();
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        Context context = InstrumentationRegistry.getContext();
-        for (Integer jobId : cachedJobIds) {
-            JobManager.instance().getApi().getCachedProxy(context).cancel(jobId);
-        }
-
-        JobManager.instance().destroy();
-    }
-
-    @Before
-    public void beforeTest() {
-        JobManager.instance().cancelAll();
-    }
-
-    @After
-    public void afterTest() {
-        JobManager.instance().cancelAll();
-    }
-
-    @Test
-    public void testSimpleJob() {
-        final int jobId = getBuilder()
-                .setExecutionWindow(200_000L, 400_000L)
-                .setPersisted(true)
-                .build()
-                .schedule();
-
-        cachedJobIds.add(jobId);
-
-        JobProxy.Common common = getCommon(jobId);
-        JobRequest pendingRequest = common.getPendingRequest(true);
-        assertThat(pendingRequest).isNotNull();
-
-        new Thread() {
-            @Override
-            public void run() {
-                SystemClock.sleep(200);
-                assertThat(JobManager.instance().getJobRequest(jobId)).isNull();
-
-                JobRequest transientRequest = JobManager.instance().getJobRequest(jobId, true);
-                assertThat(transientRequest).isNotNull();
-                assertThat(transientRequest.isTransient()).isTrue();
-            }
-        }.start();
-
-        Job.Result result = common.executeJobRequest(pendingRequest);
-        assertThat(result).isEqualTo(Job.Result.FAILURE);
-
-        assertThat(JobManager.instance().getAllJobRequestsForTag(TestJob.TAG)).isEmpty();
-
-        pendingRequest = common.getPendingRequest(true);
-        assertThat(pendingRequest).isNull();
-    }
-
-    @Test
-    public void testPeriodicJob() {
-        int jobId = getBuilder()
-                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
-                .setPersisted(true)
-                .build()
-                .schedule();
-
-        cachedJobIds.add(jobId);
-
-        JobProxy.Common common = getCommon(jobId);
-        JobRequest pendingRequest = common.getPendingRequest(true);
-        assertThat(pendingRequest).isNotNull();
-
-        Job.Result result = common.executeJobRequest(pendingRequest);
-        assertThat(result).isEqualTo(Job.Result.FAILURE);
-
-        pendingRequest = common.getPendingRequest(true);
-        assertThat(pendingRequest).isNull();
-
-        assertThat(JobManager.instance().getAllJobRequestsForTag(TestJob.TAG)).hasSize(1);
-
-        SystemClock.sleep(3_000);
-
-        pendingRequest = common.getPendingRequest(true);
-        assertThat(pendingRequest).isNotNull();
-    }
-
-    private JobRequest.Builder getBuilder() {
-        return new JobRequest.Builder(TestJob.TAG);
-    }
-
-    private JobProxy.Common getCommon(int jobId) {
-        return new JobProxy.Common(InstrumentationRegistry.getContext(), "JobExecutionTest", jobId);
-    }
-
-    private static final class TestJob extends Job {
-
-        private static final String TAG = "tag";
-
-        @NonNull
-        @Override
-        protected Result onRunJob(@NonNull Params params) {
-            SystemClock.sleep(1_000L);
-            return Result.FAILURE;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java
new file mode 100644
index 0000000..96ae15c
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java
@@ -0,0 +1,28 @@
+package com.evernote.android.job;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.rules.ExternalResource;
+
+/**
+ * @author rwondratschek
+ */
+public class JobManagerRule extends ExternalResource {
+
+    private JobManager mManager;
+
+    @Override
+    protected void before() throws Throwable {
+        mManager = JobManager.create(InstrumentationRegistry.getTargetContext());
+    }
+
+    @Override
+    protected void after() {
+        mManager.cancelAll();
+        mManager.destroy();
+    }
+
+    public JobManager getManager() {
+        return mManager;
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java b/library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java
deleted file mode 100644
index b4d7f21..0000000
--- a/library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package com.evernote.android.job;
-
-import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.filters.LargeTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import com.evernote.android.job.util.JobApi;
-import com.facebook.stetho.Stetho;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * @author rwondratschek
- */
-@RunWith(AndroidJUnit4.class)
-@LargeTest
-public class JobManagerTest {
-
-    @BeforeClass
-    public static void beforeClass() {
-        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
-
-        JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
-            @Override
-            public Job create(String tag) {
-                return new TestJob();
-            }
-        });
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        JobManager.instance().destroy();
-    }
-
-    @Test
-    public void testScheduleAndCancel() {
-        JobApi defaultApi = JobApi.getDefault(InstrumentationRegistry.getContext(), getManager().getConfig().isGcmApiEnabled());
-        assertThat(getManager().getApi()).isEqualTo(defaultApi);
-
-        JobRequest request = getJobRequest();
-        int id = request.schedule();
-
-        assertThat(getManager().getJobRequest(id)).isNotNull();
-        assertThat(getManager().getJob(id)).isNull();
-
-        boolean canceled = getManager().cancel(id);
-        assertThat(canceled).isTrue();
-
-        assertThat(getManager().getAllJobRequests()).isEmpty();
-        assertThat(getManager().getAllJobs()).isEmpty();
-
-        request.schedule();
-        request.schedule();
-        request.schedule();
-
-        assertThat(getManager().getAllJobRequests().size()).isEqualTo(1);
-
-        int cancelCount = getManager().cancelAll();
-        assertThat(cancelCount).isEqualTo(1);
-
-        assertThat(getManager().getAllJobRequests()).isEmpty();
-        assertThat(getManager().getAllJobs()).isEmpty();
-    }
-
-    @Test
-    public void testSameIdAfterCancel() {
-        JobRequest request = getJobRequest();
-        int jobId = request.getJobId();
-
-        getManager().schedule(request);
-
-        int newId = getManager().getJobRequest(jobId).cancelAndEdit().build().schedule();
-        assertThat(jobId).isEqualTo(newId);
-    }
-
-    @Test
-    public void testCancelTag() {
-        JobRequest request = getJobRequest();
-
-        request.schedule();
-
-        assertThat(getManager().getAllJobRequestsForTag(TestJob.TAG)).isNotNull().hasSize(1);
-        assertThat(getManager().getAllJobRequestsForTag("other")).isNotNull().isEmpty();
-
-        assertThat(getManager().cancelAllForTag(TestJob.TAG)).isEqualTo(1);
-        assertThat(getManager().cancelAllForTag(TestJob.TAG)).isZero();
-    }
-
-    @After
-    public void tearDown() {
-        getManager().cancelAll();
-    }
-
-    private JobRequest getJobRequest() {
-        return getBuilder()
-                .setExecutionWindow(300_000L, 300_000L)
-                .build();
-    }
-
-    private JobRequest.Builder getBuilder() {
-        return new JobRequest.Builder(TestJob.TAG);
-    }
-
-    private JobManager getManager() {
-        return JobManager.instance();
-    }
-
-    private static final class TestJob extends Job {
-
-        private static final String TAG = "tag";
-
-        @NonNull
-        @Override
-        protected Result onRunJob(@NonNull Params params) {
-            return Result.FAILURE;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java b/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java
new file mode 100644
index 0000000..89a411e
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java
@@ -0,0 +1,29 @@
+package com.evernote.android.job;
+
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class Platform21Test {
+
+    @Rule
+    public JobManagerRule mJobManagerRule = new JobManagerRule();
+
+    @Test(expected = IllegalStateException.class)
+    public void test100DistinctJobsLimit() {
+        for (int i = 0; i < 130; i++) {
+            new JobRequest.Builder("tag")
+                    .setExecutionWindow(30_000, 40_000)
+                    .build()
+                    .schedule();
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
new file mode 100644
index 0000000..b856e21
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
@@ -0,0 +1,147 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.evernote.android.job.gcm.PlatformGcmService;
+import com.evernote.android.job.util.JobApi;
+import com.evernote.android.job.v14.PlatformAlarmService;
+import com.evernote.android.job.v21.PlatformJobService;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class PlatformTest {
+
+    private JobManager mManager;
+
+    private TestJob mJob;
+
+    @Rule
+    public JobManagerRule mJobManagerRule = new JobManagerRule();
+
+    @Before
+    public void prepare() {
+        mManager = mJobManagerRule.getManager();
+        mManager.addJobCreator(new TestJobCreator());
+    }
+
+    @Test
+    public void testApi14() throws Exception {
+        testOneOff(JobApi.V_14);
+    }
+
+    @Test
+    public void testApi19() throws Exception {
+        testOneOff(JobApi.V_19);
+    }
+
+    @Test
+    public void testApiGcm() throws Exception {
+        testOneOff(JobApi.GCM, 40, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testApi21() throws Exception {
+        testOneOff(JobApi.V_21);
+    }
+
+    @Test
+    public void testApi24() throws Exception {
+        testOneOff(JobApi.V_24);
+    }
+
+    @Test
+    public void testExact() throws Exception {
+        mJob = new TestJob(PlatformAlarmService.class);
+
+        new JobRequest.Builder("tag")
+                .setExact(2_000)
+                .build()
+                .schedule();
+
+        mJob.mLatch.await(4, TimeUnit.SECONDS);
+    }
+
+    private void testOneOff(JobApi api) throws Exception {
+        testOneOff(api, 10, TimeUnit.SECONDS);
+    }
+
+    private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Exception {
+        switch (api) {
+            case V_14:
+            case V_19:
+                mJob = new TestJob(PlatformAlarmService.class);
+                break;
+            case GCM:
+                mJob = new TestJob(PlatformGcmService.class);
+                break;
+            case V_21:
+            case V_24:
+                mJob = new TestJob(PlatformJobService.class);
+                break;
+            default:
+                throw new IllegalStateException("not implemented");
+        }
+
+        // ignore test if not supported
+        assumeTrue(api.isSupported(InstrumentationRegistry.getTargetContext()));
+
+        mManager.forceApi(api);
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(2_000, 3_000)
+                .build()
+                .schedule();
+
+        mJob.mLatch.await(wait, timeUnit);
+
+        // give the platform implementation some time to clean everything up
+        Thread.sleep(300L);
+
+        assertThat(mManager.getJob(jobId)).isNotNull();
+        assertThat(mManager.getJobRequest(jobId)).isNull();
+    }
+
+    private final class TestJob extends Job {
+
+        private final CountDownLatch mLatch = new CountDownLatch(1);
+        private final Class<? extends Context> mExpectedContext;
+
+        private TestJob(Class<? extends Context> expectedContext) {
+            mExpectedContext = expectedContext;
+        }
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            assertThat(getContext()).isInstanceOf(mExpectedContext);
+
+            mLatch.countDown();
+            return Result.SUCCESS;
+        }
+    }
+
+    private final class TestJobCreator implements JobCreator {
+        @Override
+        public Job create(String tag) {
+            return mJob;
+        }
+    }
+}
diff --git a/library/src/androidTest/res/values/integers.xml b/library/src/androidTest/res/values/integers.xml
deleted file mode 100644
index 3da3d41..0000000
--- a/library/src/androidTest/res/values/integers.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <!-- required to make test project compile with provided dependency -->
-    <integer name="google_play_services_version">9683000</integer>
-</resources>
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index a1d6131..7bafeae 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -33,6 +33,9 @@
             android:exported="false">
             <intent-filter>
                 <action android:name="android.intent.action.BOOT_COMPLETED"/>
+                <action android:name="android.intent.action.QUICKBOOT_POWERON"/>
+                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
+                <action android:name="android.intent.action.MY_PACKAGE_REPLACED"/>
             </intent-filter>
         </receiver>
 
@@ -45,6 +48,10 @@
                 <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
             </intent-filter>
         </service>
+
+        <service
+            android:name="com.evernote.android.job.JobRescheduleService"
+            android:exported="false"/>
     </application>
 
 </manifest>
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 2bcf31f..5f05920 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -255,7 +255,9 @@ public final boolean isFinished() {
     }
 
     /**
-     * Delegates calls to {@link WakefulBroadcastReceiver#startWakefulService(Context, Intent)}.
+     * Similar call like {@link WakefulBroadcastReceiver#startWakefulService(Context, Intent)}.
+     * Compared to the original implementation it avoids crashes on some devices. Don't forget
+     * to call {@link #completeWakefulIntent(Intent)} on the Job class.
      *
      * <br>
      * <br>
@@ -274,11 +276,12 @@ public final boolean isFinished() {
      * @see WakefulBroadcastReceiver
      */
     protected ComponentName startWakefulService(@NonNull Intent intent) {
-        return WakefulBroadcastReceiver.startWakefulService(getContext(), intent);
+        return WakeLockUtil.startWakefulService(getContext(), intent);
     }
 
     /**
-     * Delegates calls to {@link WakefulBroadcastReceiver#completeWakefulIntent(Intent)}.
+     * Similar call like {@link WakefulBroadcastReceiver#completeWakefulIntent(Intent)}.
+     * Compared to the original implementation it avoids crashes on some devices.
      *
      * <br>
      * <br>
@@ -293,7 +296,7 @@ protected ComponentName startWakefulService(@NonNull Intent intent) {
      */
     public static boolean completeWakefulIntent(@NonNull Intent intent) {
         try {
-            return WakefulBroadcastReceiver.completeWakefulIntent(intent);
+            return WakeLockUtil.completeWakefulIntent(intent);
         } catch (Exception e) {
             // could end in a NPE if the intent no wake lock was found
             return true;
@@ -505,7 +508,7 @@ public boolean requirementsEnforced() {
          * @return How often the job already has failed.
          */
         public int getFailureCount() {
-            return mRequest.getNumFailures();
+            return mRequest.getFailureCount();
         }
 
         /**
diff --git a/library/src/main/java/com/evernote/android/job/JobExecutor.java b/library/src/main/java/com/evernote/android/job/JobExecutor.java
index f28bb4b..10c76a8 100644
--- a/library/src/main/java/com/evernote/android/job/JobExecutor.java
+++ b/library/src/main/java/com/evernote/android/job/JobExecutor.java
@@ -29,7 +29,7 @@
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.v4.util.LruCache;
+import android.util.LruCache;
 import android.util.SparseArray;
 
 import com.evernote.android.job.util.JobCat;
@@ -37,6 +37,7 @@
 import net.vrallev.android.cat.CatLog;
 
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
@@ -59,7 +60,7 @@
     private final LruCache<Integer, Job> mFinishedJobsCache;
 
     public JobExecutor() {
-        mExecutorService = Executors.newCachedThreadPool();
+        mExecutorService = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
         mJobs = new SparseArray<>();
         mFinishedJobsCache = new LruCache<>(20);
     }
@@ -70,7 +71,7 @@ public JobExecutor() {
             return null;
         }
         if (job.isFinished()) {
-            throw new IllegalStateException("Job for tag %s was already run, a creator should always create a new Job instance");
+            throw new IllegalStateException(String.format(Locale.ENGLISH, "Job for tag %s was already run, a creator should always create a new Job instance", request.getTag()));
         }
 
         job.setContext(context).setRequest(request);
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index 896d279..6322fac 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -34,8 +34,6 @@
 import android.content.pm.ActivityInfo;
 import android.content.pm.ResolveInfo;
 import android.os.Build;
-import android.os.PowerManager;
-import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -46,13 +44,10 @@
 import com.evernote.android.job.util.JobUtil;
 import com.google.android.gms.gcm.GcmNetworkManager;
 
-import net.vrallev.android.cat.Cat;
-import net.vrallev.android.cat.CatGlobal;
 import net.vrallev.android.cat.CatLog;
 
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.TimeUnit;
 
 /**
  * Entry point for scheduling jobs. Depending on the platform and SDK version it uses different APIs
@@ -82,10 +77,9 @@
  *
  * @author rwondratschek
  */
-@SuppressWarnings("unused")
+@SuppressWarnings({"unused", "WeakerAccess"})
 public final class JobManager {
 
-    private static final Package PACKAGE = JobManager.class.getPackage();
     private static final CatLog CAT = new JobCat("JobManager");
 
     @SuppressLint("StaticFieldLeak")
@@ -104,11 +98,6 @@ public static JobManager create(@NonNull Context context) {
                 if (instance == null) {
                     JobPreconditions.checkNotNull(context, "Context cannot be null");
 
-                    if (PACKAGE != null) {
-                        // package can be null when class is repackaged, then ignore this
-                        CatGlobal.setDefaultCatLogPackage(PACKAGE.getName(), new JobCat());
-                    }
-
                     if (context.getApplicationContext() != null) {
                         // could be null in unit tests
                         context = context.getApplicationContext();
@@ -117,10 +106,10 @@ public static JobManager create(@NonNull Context context) {
                     instance = new JobManager(context);
 
                     if (!JobUtil.hasWakeLockPermission(context)) {
-                        Cat.w("No wake lock permission");
+                        CAT.w("No wake lock permission");
                     }
                     if (!JobUtil.hasBootPermission(context)) {
-                        Cat.w("No boot permission");
+                        CAT.w("No boot permission");
                     }
 
                     sendAddJobCreatorIntent(context);
@@ -191,7 +180,7 @@ private JobManager(Context context) {
 
         setJobProxy(JobApi.getDefault(mContext, mConfig.isGcmApiEnabled()));
 
-        rescheduleTasksIfNecessary();
+        JobRescheduleService.startService(mContext);
     }
 
     /**
@@ -201,7 +190,7 @@ public Config getConfig() {
         return mConfig;
     }
 
-    protected void setJobProxy(JobApi api) {
+    private void setJobProxy(JobApi api) {
         mApi = api;
     }
 
@@ -410,6 +399,7 @@ private int cancelAllInner(@Nullable String tag) {
             }
         }
 
+        //noinspection ConstantConditions
         Set<Job> jobs = TextUtils.isEmpty(tag) ? getAllJobs() : getAllJobsForTag(tag);
         for (Job job : jobs) {
             if (cancelInner(job)) {
@@ -471,7 +461,7 @@ public void removeJobCreator(JobCreator jobCreator) {
         }
     }
 
-    private JobProxy getJobProxy(JobRequest request) {
+    /*package*/ JobProxy getJobProxy(JobRequest request) {
         return getJobProxy(request.getJobApi());
     }
 
@@ -479,60 +469,13 @@ private JobProxy getJobProxy(JobApi api) {
         return api.getCachedProxy(mContext);
     }
 
-    private void rescheduleTasksIfNecessary() {
-        final PowerManager.WakeLock wakeLock = WakeLockUtil.acquireWakeLock(mContext, JobManager.class.getName(), TimeUnit.MINUTES.toMillis(1));
-
-        new Thread() {
-            @Override
-            public void run() {
-                try {
-                    /*
-                     * Delay this slightly. This avoids a race condition if the app was launched by the
-                     * AlarmManager. Then the alarm was already removed, but the JobRequest might still
-                     * be available in the storage. We still catch this case, because we never execute
-                     * a job with the same ID twice. However, the still save resources with the delay.
-                     */
-                    SystemClock.sleep(10_000L);
-
-                    Set<JobRequest> requests = mJobStorage.getAllJobRequests(null, true);
-
-                    int rescheduledCount = 0;
-                    for (JobRequest request : requests) {
-                        boolean reschedule;
-                        if (request.isTransient()) {
-                            Job job = getJob(request.getJobId());
-                            reschedule = job == null;
-                        } else {
-                            reschedule = !getJobProxy(request).isPlatformJobScheduled(request);
-                        }
-
-                        if (reschedule) {
-                            // update execution window
-                            request.cancelAndEdit()
-                                    .build()
-                                    .schedule();
-
-                            rescheduledCount++;
-                        }
-                    }
-
-                    CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
-
-                } finally {
-                    WakeLockUtil.releaseWakeLock(wakeLock);
-                }
-            }
-        }.start();
-    }
-
+    // TODO: extract this class so that settings can be changed before the JobManager has been created
     public final class Config {
 
-        private boolean mVerbose;
         private boolean mGcmEnabled;
         private boolean mAllowSmallerIntervals;
 
         private Config() {
-            mVerbose = true;
             mGcmEnabled = true;
             mAllowSmallerIntervals = false;
         }
@@ -541,7 +484,7 @@ private Config() {
          * @return Whether logging is enabled for this library. The default value is {@code true}.
          */
         public boolean isVerbose() {
-            return mVerbose;
+            return JobCat.isLogcatEnabled();
         }
 
         /**
@@ -550,10 +493,7 @@ public boolean isVerbose() {
          * @param verbose Whether or not to print all log messages. The default value is {@code true}.
          */
         public void setVerbose(boolean verbose) {
-            if (mVerbose != verbose && PACKAGE != null) {
-                mVerbose = verbose;
-                CatGlobal.setPackageEnabled(PACKAGE.getName(), verbose);
-            }
+            JobCat.setLogcatEnabled(verbose);
         }
 
         /**
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 20a1316..a1e97e3 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -26,12 +26,13 @@
 package com.evernote.android.job;
 
 import android.app.Service;
+import android.content.ComponentName;
 import android.content.Context;
+import android.content.Intent;
 import android.os.Looper;
 import android.support.annotation.NonNull;
 
 import com.evernote.android.job.util.JobApi;
-import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
@@ -39,6 +40,8 @@
 import java.util.Locale;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A proxy for each {@link JobApi}.
@@ -59,6 +62,23 @@
 
     /*package*/ final class Common {
 
+        public static final ThreadFactory COMMON_THREAD_FACTORY = new ThreadFactory() {
+
+            private final AtomicInteger mThreadNumber = new AtomicInteger();
+
+            @Override
+            public Thread newThread(Runnable r) {
+                Thread thread = new Thread(r, "AndroidJob-" + mThreadNumber.incrementAndGet());
+                if (thread.isDaemon()) {
+                    thread.setDaemon(false);
+                }
+                if (thread.getPriority() != Thread.NORM_PRIORITY) {
+                    thread.setPriority(Thread.NORM_PRIORITY);
+                }
+                return thread;
+            }
+        };
+
         // see Google Guava: https://github.com/google/guava/blob/master/guava/src/com/google/common/math/LongMath.java
         private static long checkedAdd(long a, long b) {
             long result = a + b;
@@ -70,11 +90,19 @@ private static long checkNoOverflow(long result, boolean condition) {
         }
 
         public static long getStartMs(JobRequest request) {
-            return checkedAdd(request.getStartMs(), request.getBackoffOffset());
+            if (request.getFailureCount() > 0) {
+                return request.getBackoffOffset();
+            } else {
+                return request.getStartMs();
+            }
         }
 
         public static long getEndMs(JobRequest request) {
-            return checkedAdd(request.getEndMs(), request.getBackoffOffset());
+            if (request.getFailureCount() > 0) {
+                return request.getBackoffOffset();
+            } else {
+                return request.getEndMs();
+            }
         }
 
         public static long getAverageDelayMs(JobRequest request) {
@@ -93,20 +121,24 @@ public static long getAverageDelayMsSupportFlex(JobRequest request) {
             return checkedAdd(getStartMsSupportFlex(request), (getEndMsSupportFlex(request) - getStartMsSupportFlex(request)) / 2);
         }
 
+        public static int getRescheduleCount(JobRequest request) {
+            return request.getFailureCount();
+        }
+
         private final Context mContext;
         private final int mJobId;
         private final CatLog mCat;
 
         private final JobManager mJobManager;
 
-        public Common(@NonNull Service service, int jobId) {
-            this(service, service.getClass().getSimpleName(), jobId);
+        public Common(@NonNull Service service, CatLog cat, int jobId) {
+            this((Context) service, cat, jobId);
         }
 
-        /*package*/ Common(@NonNull Context context, String loggingTag, int jobId) {
+        /*package*/ Common(@NonNull Context context, CatLog cat, int jobId) {
             mContext = context;
             mJobId = jobId;
-            mCat = new JobCat(loggingTag);
+            mCat = cat;
 
             mJobManager = JobManager.create(context);
         }
@@ -231,5 +263,13 @@ public static void cleanUpOrphanedJob(Context context, int jobId) {
                 }
             }
         }
+
+        public static ComponentName startWakefulService(Context context, Intent intent) {
+            return WakeLockUtil.startWakefulService(context, intent);
+        }
+
+        public static boolean completeWakefulIntent(Intent intent) {
+            return WakeLockUtil.completeWakefulIntent(intent);
+        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 9f2ddbd..ca152fa 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -38,7 +38,6 @@
 import com.evernote.android.job.util.JobUtil;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
-import net.vrallev.android.cat.Cat;
 import net.vrallev.android.cat.CatLog;
 
 import java.util.concurrent.TimeUnit;
@@ -116,7 +115,7 @@
     private final Builder mBuilder;
     private final JobApi mJobApi;
 
-    private int mNumFailures;
+    private int mFailureCount;
     private long mScheduledAt;
     private boolean mTransient;
     private boolean mFlexSupport;
@@ -272,14 +271,14 @@ public boolean isExact() {
         long offset;
         switch (getBackoffPolicy()) {
             case LINEAR:
-                offset = mNumFailures * getBackoffMs();
+                offset = mFailureCount * getBackoffMs();
                 break;
 
             case EXPONENTIAL:
-                if (mNumFailures == 0) {
+                if (mFailureCount == 0) {
                     offset = 0L;
                 } else {
-                    offset = (long) (getBackoffMs() * Math.pow(2, mNumFailures - 1));
+                    offset = (long) (getBackoffMs() * Math.pow(2, mFailureCount - 1));
                 }
                 break;
 
@@ -314,15 +313,21 @@ public long getScheduledAt() {
         return mScheduledAt;
     }
 
-    /*package*/ int getNumFailures() {
-        return mNumFailures;
+    /**
+     * The failure count increases if a non periodic {@link Job} was rescheduled or if a periodic
+     * {@link Job} wasn't successful.
+     *
+     * @return How often the job already has failed.
+     */
+    public int getFailureCount() {
+        return mFailureCount;
     }
 
     /**
      * Only non-periodic jobs can be in a transient state. The transient state means, that
      * the job is running and is about to be removed. A job can get stuck in a transient state,
      * if the app terminates while the job is running. Then the job isn't scheduled anymore, but
-     * entry is still in the database. Since the job didn't finish successfully, reschedule
+     * the entry is still in the database. Since the job didn't finish successfully, reschedule
      * the job if necessary and treat it as it wouldn't have run, yet.
      *
      * @return Whether the job is in a transient state.
@@ -375,15 +380,15 @@ public Builder cancelAndEdit() {
     /*package*/ int reschedule(boolean failure, boolean newJob) {
         JobRequest newRequest = new Builder(this, newJob).build();
         if (failure) {
-            newRequest.mNumFailures = mNumFailures + 1;
+            newRequest.mFailureCount = mFailureCount + 1;
         }
         return newRequest.schedule();
     }
 
     /*package*/ void incNumFailures() {
-        mNumFailures++;
+        mFailureCount++;
         ContentValues contentValues = new ContentValues();
-        contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mNumFailures);
+        contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mFailureCount);
         JobManager.instance().getJobStorage().update(this, contentValues);
     }
 
@@ -397,7 +402,7 @@ public Builder cancelAndEdit() {
     /*package*/ ContentValues toContentValues() {
         ContentValues contentValues = new ContentValues();
         mBuilder.fillContentValues(contentValues);
-        contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mNumFailures);
+        contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mFailureCount);
         contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, mScheduledAt);
         contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
         contentValues.put(JobStorage.COLUMN_FLEX_SUPPORT, mFlexSupport);
@@ -406,12 +411,12 @@ public Builder cancelAndEdit() {
 
     /*package*/ static JobRequest fromCursor(Cursor cursor) throws Exception {
         JobRequest request = new Builder(cursor).build();
-        request.mNumFailures = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
+        request.mFailureCount = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
         request.mScheduledAt = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_SCHEDULED_AT));
         request.mTransient = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_TRANSIENT)) > 0;
         request.mFlexSupport = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_FLEX_SUPPORT)) > 0;
 
-        JobPreconditions.checkArgumentNonnegative(request.mNumFailures, "failure count can't be negative");
+        JobPreconditions.checkArgumentNonnegative(request.mFailureCount, "failure count can't be negative");
         JobPreconditions.checkArgumentNonnegative(request.mScheduledAt, "scheduled at can't be negative");
 
         return request;
@@ -615,11 +620,11 @@ public Builder setExecutionWindow(long startMs, long endMs) {
             mEndMs = JobPreconditions.checkArgumentInRange(endMs, startMs, Long.MAX_VALUE, "endMs");
 
             if (mStartMs > WINDOW_THRESHOLD_MAX) {
-                Cat.i("startMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mStartMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                CAT.i("startMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mStartMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
                 mStartMs = WINDOW_THRESHOLD_MAX;
             }
             if (mEndMs > WINDOW_THRESHOLD_MAX) {
-                Cat.i("endMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mEndMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                CAT.i("endMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mEndMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
                 mEndMs = WINDOW_THRESHOLD_MAX;
             }
 
@@ -771,7 +776,7 @@ public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {
         public Builder setExact(long exactMs) {
             mExact = true;
             if (exactMs > WINDOW_THRESHOLD_MAX) {
-                Cat.i("exactMs clamped from %d days to %d days", TimeUnit.MILLISECONDS.toDays(exactMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                CAT.i("exactMs clamped from %d days to %d days", TimeUnit.MILLISECONDS.toDays(exactMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
                 exactMs = WINDOW_THRESHOLD_MAX;
             }
 
@@ -912,7 +917,7 @@ public JobRequest build() {
             }
 
             if (mIntervalMs <= 0 && (mStartMs > WINDOW_THRESHOLD_WARNING || mEndMs > WINDOW_THRESHOLD_WARNING)) {
-                Cat.w("Attention: your execution window is too large. This could result in undesired behavior, see https://github.com/evernote/android-job/blob/master/FAQ.md");
+                CAT.w("Attention: your execution window is too large. This could result in undesired behavior, see https://github.com/evernote/android-job/blob/master/FAQ.md");
             }
 
             return new JobRequest(this);
diff --git a/library/src/main/java/com/evernote/android/job/JobRescheduleService.java b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
new file mode 100644
index 0000000..74cb99c
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
@@ -0,0 +1,73 @@
+package com.evernote.android.job;
+
+import android.app.IntentService;
+import android.content.Context;
+import android.content.Intent;
+import android.os.SystemClock;
+
+import com.evernote.android.job.util.JobCat;
+
+import net.vrallev.android.cat.CatLog;
+
+import java.util.Set;
+
+/**
+ * @author rwondratschek
+ */
+public final class JobRescheduleService extends IntentService {
+
+    private static final String TAG = "JobRescheduleService";
+    private static final CatLog CAT = new JobCat(TAG);
+
+    /*package*/ static void startService(Context context) {
+        Intent intent = new Intent(context, JobRescheduleService.class);
+        WakeLockUtil.startWakefulService(context, intent);
+    }
+
+    public JobRescheduleService() {
+        super(TAG);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        try {
+            /*
+             * Delay this slightly. This avoids a race condition if the app was launched by the
+             * AlarmManager. Then the alarm was already removed, but the JobRequest might still
+             * be available in the storage. We still catch this case, because we never execute
+             * a job with the same ID twice. However, the still save resources with the delay.
+             */
+            CAT.d("Reschedule service started");
+            SystemClock.sleep(10_000L);
+
+            JobManager manager = JobManager.create(this);
+            Set<JobRequest> requests = manager.getJobStorage().getAllJobRequests(null, true);
+
+            int rescheduledCount = 0;
+            for (JobRequest request : requests) {
+                boolean reschedule;
+                if (request.isTransient()) {
+                    Job job = manager.getJob(request.getJobId());
+                    reschedule = job == null;
+                } else {
+                    reschedule = !manager.getJobProxy(request).isPlatformJobScheduled(request);
+                }
+
+                if (reschedule) {
+                    // update execution window
+                    request.cancelAndEdit()
+                            .build()
+                            .schedule();
+
+                    rescheduledCount++;
+                }
+            }
+
+            CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
+
+        } finally {
+            WakeLockUtil.completeWakefulIntent(intent);
+        }
+
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index 8f93e5b..b0825e5 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -33,8 +33,8 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 import android.support.annotation.Nullable;
-import android.support.v4.util.LruCache;
 import android.text.TextUtils;
+import android.util.LruCache;
 
 import com.evernote.android.job.util.JobCat;
 
@@ -48,7 +48,9 @@
 /**
  * @author rwondratschek
  */
-/*package*/ class JobStorage {
+/*package*/
+@SuppressWarnings("WeakerAccess")
+class JobStorage {
 
     private static final CatLog CAT = new JobCat("JobStorage");
 
@@ -93,6 +95,10 @@
     private SQLiteDatabase mDatabase;
 
     public JobStorage(Context context) {
+        this(context, DATABASE_NAME);
+    }
+
+    public JobStorage(Context context, String databasePath) {
         mPreferences = context.getSharedPreferences(PREF_FILE_NAME, Context.MODE_PRIVATE);
 
         mCacheId = new JobCacheId();
@@ -100,7 +106,7 @@ public JobStorage(Context context) {
         int lastJobId = mPreferences.getInt(JOB_ID_COUNTER, 0);
         mJobCounter = new AtomicInteger(lastJobId);
 
-        mDbHelper = new JobOpenHelper(context);
+        mDbHelper = new JobOpenHelper(context, databasePath);
     }
 
     public synchronized void put(final JobRequest request) {
@@ -253,10 +259,10 @@ protected JobRequest create(Integer id) {
         }
     }
 
-    private class JobOpenHelper extends SQLiteOpenHelper {
+    private static final class JobOpenHelper extends SQLiteOpenHelper {
 
-        public JobOpenHelper(Context context) {
-            super(context, DATABASE_NAME, null, DATABASE_VERSION);
+        private JobOpenHelper(Context context, String databasePath) {
+            super(context, databasePath, null, DATABASE_VERSION);
         }
 
         @Override
diff --git a/library/src/main/java/com/evernote/android/job/WakeLockUtil.java b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
index 18bd0d1..368ace7 100644
--- a/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
+++ b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
@@ -1,15 +1,20 @@
 package com.evernote.android.job;
 
+import android.content.ComponentName;
 import android.content.Context;
+import android.content.Intent;
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.util.SparseArray;
 
 import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
 
+import java.util.concurrent.TimeUnit;
+
 /**
  * @author rwondratschek
  */
@@ -17,6 +22,8 @@
 
     private static final CatLog CAT = new JobCat("WakeLockUtil");
 
+    private static final String EXTRA_WAKE_LOCK_ID = "com.evernote.android.job.wakelockid";
+
     private WakeLockUtil() {
         // no op
     }
@@ -58,4 +65,69 @@ public static void releaseWakeLock(@Nullable PowerManager.WakeLock wakeLock) {
             CAT.e(e);
         }
     }
+
+    private static final SparseArray<PowerManager.WakeLock> ACTIVE_WAKE_LOCKS = new SparseArray<>();
+    private static int nextId = 1;
+
+    /**
+     * Do a {@link android.content.Context#startService(android.content.Intent)
+     * Context.startService}, but holding a wake lock while the service starts.
+     * This will modify the Intent to hold an extra identifying the wake lock;
+     * when the service receives it in {@link android.app.Service#onStartCommand
+     * Service.onStartCommand}, it should pass back the Intent it receives there to
+     * {@link #completeWakefulIntent(android.content.Intent)} in order to release
+     * the wake lock.
+     *
+     * @param context The Context in which it operate.
+     * @param intent The Intent with which to start the service, as per
+     * {@link android.content.Context#startService(android.content.Intent)
+     * Context.startService}.
+     */
+    public static ComponentName startWakefulService(Context context, Intent intent) {
+        synchronized (ACTIVE_WAKE_LOCKS) {
+            int id = nextId;
+            nextId++;
+            if (nextId <= 0) {
+                nextId = 1;
+            }
+
+            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);
+            ComponentName comp = context.startService(intent);
+            if (comp == null) {
+                return null;
+            }
+
+            String tag = "wake:" + comp.flattenToShortString();
+            PowerManager.WakeLock wakeLock = acquireWakeLock(context, tag, TimeUnit.MINUTES.toMillis(3));
+            if (wakeLock != null) {
+                ACTIVE_WAKE_LOCKS.put(id, wakeLock);
+            }
+
+            return comp;
+        }
+    }
+
+    /**
+     * Finish the execution from a previous {@link #startWakefulService}.  Any wake lock
+     * that was being held will now be released.
+     *
+     * @param intent The Intent as originally generated by {@link #startWakefulService}.
+     * @return Returns true if the intent is associated with a wake lock that is
+     * now released; returns false if there was no wake lock specified for it.
+     */
+    public static boolean completeWakefulIntent(Intent intent) {
+        if (intent == null) {
+            return false;
+        }
+
+        final int id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, 0);
+        if (id == 0) {
+            return false;
+        }
+        synchronized (ACTIVE_WAKE_LOCKS) {
+            releaseWakeLock(ACTIVE_WAKE_LOCKS.get(id));
+            ACTIVE_WAKE_LOCKS.remove(id);
+            return true;
+        }
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
index bd037cb..d3cd0b4 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
@@ -72,7 +72,8 @@ public void plantOneOff(JobRequest request) {
 
         mGcmNetworkManager.schedule(task);
 
-        CAT.d("Scheduled OneoffTask, %s, start %s, end %s", request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs));
+        CAT.d("Scheduled OneoffTask, %s, start %s, end %s, reschedule count %d", request, JobUtil.timeToString(startMs),
+                JobUtil.timeToString(endMs), Common.getRescheduleCount(request));
     }
 
     @Override
diff --git a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
index 0d069a2..c39353c 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
@@ -26,21 +26,27 @@
 package com.evernote.android.job.gcm;
 
 import com.evernote.android.job.Job;
+import com.evernote.android.job.JobManager;
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobCat;
 import com.google.android.gms.gcm.GcmNetworkManager;
 import com.google.android.gms.gcm.GcmTaskService;
 import com.google.android.gms.gcm.TaskParams;
 
+import net.vrallev.android.cat.CatLog;
+
 /**
  * @author rwondratschek
  */
 public class PlatformGcmService extends GcmTaskService {
 
+    private static final CatLog CAT = new JobCat("JobRequest");
+
     @Override
     public int onRunTask(TaskParams taskParams) {
         int jobId = Integer.parseInt(taskParams.getTag());
-        JobProxy.Common common = new JobProxy.Common(this, jobId);
+        JobProxy.Common common = new JobProxy.Common(this, CAT, jobId);
 
         JobRequest request = common.getPendingRequest(true);
         if (request == null) {
@@ -54,4 +60,16 @@ public int onRunTask(TaskParams taskParams) {
             return GcmNetworkManager.RESULT_FAILURE;
         }
     }
+
+    @Override
+    public void onInitializeTasks() {
+        super.onInitializeTasks();
+
+        /*
+         * When the app is being updated, then all jobs are cleared in the GcmNetworkManager. The manager
+         * calls this method to reschedule. Let's initialize the JobManager here, which will reschedule
+         * jobs manually.
+         */
+        JobManager.create(getApplicationContext());
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/util/Device.java b/library/src/main/java/com/evernote/android/job/util/Device.java
index 05935a7..83996f2 100644
--- a/library/src/main/java/com/evernote/android/job/util/Device.java
+++ b/library/src/main/java/com/evernote/android/job/util/Device.java
@@ -36,7 +36,6 @@
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.v4.net.ConnectivityManagerCompat;
-import android.telephony.TelephonyManager;
 
 import com.evernote.android.job.JobRequest;
 
@@ -83,20 +82,31 @@ public static boolean isIdle(Context context) {
         }
     }
 
+    /**
+     * Checks the network condition of the device and returns the best type. If the device
+     * is connected to a WiFi and mobile network at the same time, then it would assume
+     * that the connection is unmetered because of the WiFi connection.
+     *
+     * @param context Any context, e.g. the application context.
+     * @return The current network type of the device.
+     */
     @NonNull
-    public static JobRequest.NetworkType getNetworkType(Context context) {
+    public static JobRequest.NetworkType getNetworkType(@NonNull Context context) {
         ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
         NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
         if (networkInfo == null || !networkInfo.isConnectedOrConnecting()) {
             return JobRequest.NetworkType.ANY;
         }
 
-        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-        if (telephonyManager != null && telephonyManager.isNetworkRoaming()) {
-            return JobRequest.NetworkType.CONNECTED;
+        boolean metered = ConnectivityManagerCompat.isActiveNetworkMetered(connectivityManager);
+        if (!metered) {
+            return JobRequest.NetworkType.UNMETERED;
         }
 
-        boolean metered = ConnectivityManagerCompat.isActiveNetworkMetered(connectivityManager);
-        return metered ? JobRequest.NetworkType.NOT_ROAMING : JobRequest.NetworkType.UNMETERED;
+        if (networkInfo.isRoaming()) {
+            return JobRequest.NetworkType.CONNECTED;
+        } else {
+            return JobRequest.NetworkType.NOT_ROAMING;
+        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java b/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
index 1d9f1c1..962b97c 100644
--- a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
+++ b/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
@@ -11,7 +11,7 @@
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GoogleApiAvailability;
 
-import net.vrallev.android.cat.Cat;
+import net.vrallev.android.cat.CatLog;
 
 import java.util.List;
 
@@ -20,6 +20,8 @@
  */
 /*package*/ final class GcmAvailableHelper {
 
+    private static final CatLog CAT = new JobCat("GcmAvailableHelper");
+
     private static final String ACTION_TASK_READY = "com.google.android.gms.gcm.ACTION_TASK_READY";
     private static final String GCM_PERMISSION = "com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE";
 
@@ -52,7 +54,7 @@ public static boolean isGcmApiSupported(Context context) {
         } catch (Throwable t) {
             // seeing sometimes a DeadObjectException, return false, we can't do anything in this case
             // still sometimes seeing a NoClassDefFoundError here
-            Cat.w(t);
+            CAT.w(t);
             return false;
         }
     }
@@ -109,7 +111,7 @@ private static void setServiceEnabled(Context context, boolean enabled) {
                 case PackageManager.COMPONENT_ENABLED_STATE_ENABLED:
                     if (!enabled) {
                         packageManager.setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
-                        Cat.i("GCM service disabled");
+                        CAT.i("GCM service disabled");
                     }
                     break;
 
@@ -117,14 +119,14 @@ private static void setServiceEnabled(Context context, boolean enabled) {
                 case PackageManager.COMPONENT_ENABLED_STATE_DISABLED:
                     if (enabled) {
                         packageManager.setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
-                        Cat.i("GCM service enabled");
+                        CAT.i("GCM service enabled");
                     }
                     break;
             }
 
         } catch (Throwable t) {
             // just in case, don't let the app crash with each restart
-            Cat.e(t);
+            CAT.e(t);
         }
     }
 
diff --git a/library/src/main/java/com/evernote/android/job/util/JobCat.java b/library/src/main/java/com/evernote/android/job/util/JobCat.java
index e70aa33..d4ae71d 100644
--- a/library/src/main/java/com/evernote/android/job/util/JobCat.java
+++ b/library/src/main/java/com/evernote/android/job/util/JobCat.java
@@ -25,8 +25,13 @@
  */
 package com.evernote.android.job.util;
 
+import android.support.annotation.NonNull;
+
 import net.vrallev.android.cat.CatLog;
 import net.vrallev.android.cat.instance.CatLazy;
+import net.vrallev.android.cat.print.CatPrinter;
+
+import java.util.Arrays;
 
 /**
  * The default {@link CatLog} class for this library.
@@ -35,6 +40,67 @@
  */
 public class JobCat extends CatLazy {
 
+    private static volatile CatPrinter[] printers = new CatPrinter[0]; // use array to avoid synchronization while printing log statements
+    private static volatile boolean logcatEnabled = true;
+
+    /**
+     * Add a global logger for the job library, which will be notified about each log statement.
+     *
+     * @param printer Your desired logger.
+     * @return {@code true} if the printer was added. Returns {@code false} if the printer was
+     * already added.
+     */
+    public static synchronized boolean addLogPrinter(@NonNull CatPrinter printer) {
+        for (CatPrinter printer1 : printers) {
+            if (printer.equals(printer1)) {
+                return false;
+            }
+        }
+
+        for (int i = 0; i < printers.length; i++) {
+            if (printers[i] == null) {
+                printers[i] = printer;
+                return true;
+            }
+        }
+
+        int index = printers.length;
+        printers = Arrays.copyOf(printers, printers.length + 2);
+        printers[index] = printer;
+        return true;
+    }
+
+    /**
+     * Remove a global logger.
+     *
+     * @param printer Your desired logger.
+     * @see #addLogPrinter(CatPrinter)
+     */
+    public static synchronized void removeLogPrinter(@NonNull CatPrinter printer) {
+        for (int i = 0; i < printers.length; i++) {
+            if (printer.equals(printers[i])) {
+                printers[i] = null;
+                // continue, maybe for some reason the printer is twice in the array
+            }
+        }
+    }
+
+    /**
+     * Global switch to enable or disable printing log messages to Logcat.
+     *
+     * @param enabled Whether or not to print all log messages. The default value is {@code true}.
+     */
+    public static void setLogcatEnabled(boolean enabled) {
+        JobCat.logcatEnabled = enabled;
+    }
+
+    /**
+     * @return Whether logging is enabled for this library. The default value is {@code true}.
+     */
+    public static boolean isLogcatEnabled() {
+        return logcatEnabled;
+    }
+
     private final String mTag;
 
     public JobCat() {
@@ -56,6 +122,19 @@ public String getTag() {
 
     @Override
     protected void println(int priority, String message, Throwable t) {
-        super.println(priority, message, t);
+        if (logcatEnabled) {
+            super.println(priority, message, t);
+        }
+
+        CatPrinter[] printers = JobCat.printers;
+        if (printers.length > 0) {
+            String tag = getTag();
+
+            for (CatPrinter printer : printers) {
+                if (printer != null) {
+                    printer.println(priority, tag, message, t);
+                }
+            }
+        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
index 7f823c1..d3bf77a 100644
--- a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
+++ b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
@@ -111,8 +111,8 @@ protected long getTriggerAtMillis(JobRequest request) {
     }
 
     private void logScheduled(JobRequest request) {
-        mCat.d("Scheduled alarm, %s, delay %s, exact %b", request,
-                JobUtil.timeToString(Common.getAverageDelayMs(request)), request.isExact());
+        mCat.d("Scheduled alarm, %s, delay %s, exact %b, reschedule count %d", request,
+                JobUtil.timeToString(Common.getAverageDelayMs(request)), request.isExact(), Common.getRescheduleCount(request));
     }
 
     @Override
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
index 41b5086..63ab913 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
@@ -29,8 +29,8 @@
 import android.content.Intent;
 import android.support.v4.content.WakefulBroadcastReceiver;
 
+import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.util.JobCat;
-import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
 
@@ -54,23 +54,6 @@ public void onReceive(Context context, Intent intent) {
         }
 
         Intent serviceIntent = PlatformAlarmService.createIntent(context, intent.getIntExtra(EXTRA_JOB_ID, -1));
-
-        if (JobUtil.hasWakeLockPermission(context)) {
-            try {
-                startWakefulService(context, serviceIntent);
-            } catch (Exception e) {
-                /*
-                 * Saw a SecurityException, although WAKE_LOCK permission is granted.
-                 * https://gist.github.com/vRallev/715777806e0abe3777bc
-                 *
-                 * The wake lock is acquired after the service was started, so it's not necessary
-                 * to start the service another time.
-                 */
-                CAT.e(e);
-            }
-
-        } else {
-            context.startService(serviceIntent);
-        }
+        JobProxy.Common.startWakefulService(context, serviceIntent);
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
index 65cd5d9..fe13fea 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
@@ -25,24 +25,29 @@
  */
 package com.evernote.android.job.v14;
 
-import android.app.IntentService;
+import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
+import android.os.IBinder;
+import android.support.annotation.Nullable;
 
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobCat;
 
-import net.vrallev.android.cat.Cat;
+import net.vrallev.android.cat.CatLog;
 
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 /**
  * @author rwondratschek
  */
-public class PlatformAlarmService extends IntentService {
+public final class PlatformAlarmService extends Service {
 
-    private static final ExecutorService EXECUTOR_SERVICE = Executors.newCachedThreadPool();
+    private static final CatLog CAT = new JobCat("PlatformAlarmService");
 
     /*package*/ static Intent createIntent(Context context, int jobId) {
         Intent intent = new Intent(context, PlatformAlarmService.class);
@@ -50,39 +55,83 @@
         return intent;
     }
 
-    public PlatformAlarmService() {
-        super(PlatformAlarmService.class.getSimpleName());
+    private final Object mMonitor = new Object();
+
+    private volatile ExecutorService mExecutorService;
+    private volatile Set<Integer> mStartIds;
+    private volatile int mLastStartId;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mExecutorService = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
+        mStartIds = new HashSet<>();
     }
 
     @Override
-    protected void onHandleIntent(final Intent intent) {
+    public int onStartCommand(@Nullable final Intent intent, int flags, final int startId) {
+        synchronized (mMonitor) {
+            mStartIds.add(startId);
+            mLastStartId = startId;
+        }
+
+        mExecutorService.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    runJob(intent);
+                } finally {
+                    // call here, our own wake lock could be acquired too late
+                    JobProxy.Common.completeWakefulIntent(intent);
+                    stopSelfIfNecessary(startId);
+                }
+            }
+        });
+        return START_NOT_STICKY;
+    }
+
+    @Override
+    public void onDestroy() {
+        mExecutorService.shutdown();
+        mExecutorService = null;
+
+        synchronized (mMonitor) {
+            mStartIds = null;
+            mLastStartId = 0;
+        }
+    }
+
+    @Override
+    public final IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    private void runJob(Intent intent) {
         if (intent == null) {
-            Cat.i("Delivered intent is null");
+            CAT.i("Delivered intent is null");
             return;
         }
 
         int jobId = intent.getIntExtra(PlatformAlarmReceiver.EXTRA_JOB_ID, -1);
-        final JobProxy.Common common = new JobProxy.Common(this, jobId);
+        final JobProxy.Common common = new JobProxy.Common(this, CAT, jobId);
 
         // create the JobManager. Seeing sometimes exceptions, that it wasn't created, yet.
         final JobRequest request = common.getPendingRequest(true);
-        if (request == null) {
-            return;
+        if (request != null) {
+            common.executeJobRequest(request);
         }
+    }
 
-        // parallel execution
-        EXECUTOR_SERVICE.execute(new Runnable() {
-            @Override
-            public void run() {
-                common.executeJobRequest(request);
-
-                // call here, our own wake lock could be acquired too late
-                try {
-                    PlatformAlarmReceiver.completeWakefulIntent(intent);
-                } catch (Exception e) {
-                    // could end in a NPE if the intent has no wake lock
+    private void stopSelfIfNecessary(int startId) {
+        synchronized (mMonitor) {
+            Set<Integer> startIds = mStartIds;
+            if (startIds != null) {
+                // service not destroyed
+                startIds.remove(startId);
+                if (startIds.isEmpty()) {
+                    stopSelfResult(mLastStartId);
                 }
             }
-        });
+        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
index 18699c4..2c1ba7c 100644
--- a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
+++ b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
@@ -71,8 +71,8 @@ public void plantOneOff(JobRequest request) {
         JobInfo jobInfo = createBuilderOneOff(createBaseBuilder(request), startMs, endMs).build();
         int scheduleResult = schedule(jobInfo);
 
-        mCat.d("Schedule one-off jobInfo %s, %s, start %s, end %s", scheduleResultToString(scheduleResult),
-                request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs));
+        mCat.d("Schedule one-off jobInfo %s, %s, start %s, end %s, reschedule count %d", scheduleResultToString(scheduleResult),
+                request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs), Common.getRescheduleCount(request));
     }
 
     @Override
@@ -171,12 +171,7 @@ protected final JobScheduler getJobScheduler() {
     }
 
     protected final int schedule(JobInfo jobInfo) {
-        try {
-            return getJobScheduler().schedule(jobInfo);
-        } catch (Exception e) {
-            mCat.e(e);
-            return JobScheduler.RESULT_FAILURE;
-        }
+        return getJobScheduler().schedule(jobInfo);
     }
 
     protected static String scheduleResultToString(int scheduleResult) {
diff --git a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
index 437d328..9f39fcf 100644
--- a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
+++ b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
@@ -52,12 +52,12 @@
      */
 
     private static final CatLog CAT = new JobCat("PlatformJobService");
-    private static final ExecutorService EXECUTOR_SERVICE = Executors.newCachedThreadPool();
+    private static final ExecutorService EXECUTOR_SERVICE = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
 
     @Override
     public boolean onStartJob(final JobParameters params) {
         final int jobId = params.getJobId();
-        final JobProxy.Common common = new JobProxy.Common(this, jobId);
+        final JobProxy.Common common = new JobProxy.Common(this, CAT, jobId);
 
         final JobRequest request = common.getPendingRequest(true);
         if (request == null) {
diff --git a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
new file mode 100644
index 0000000..10fc2d3
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
@@ -0,0 +1,76 @@
+package com.evernote.android.job;
+
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.TestCat;
+
+import org.junit.Rule;
+import org.robolectric.RuntimeEnvironment;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.mockito.Mockito.doReturn;
+
+/**
+ * @author rwondratschek
+ */
+public abstract class BaseJobManagerTest {
+
+    @Rule
+    public final JobManagerRule mJobManagerRule = new JobManagerRule(provideJobCreator());
+
+    @NonNull
+    protected JobCreator provideJobCreator() {
+        return new DummyJobs.SpyableJobCreator(DummyJobs.TEST_JOB_CREATOR);
+    }
+
+    @NonNull
+    protected final JobManager manager() {
+        return mJobManagerRule.getJobManager();
+    }
+
+    @NonNull
+    protected void executeJob(int jobId, @NonNull Job.Result expected) {
+        try {
+            executeJobAsync(jobId, expected).get(3, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            throw new AssertionError("Job timeout");
+        }
+    }
+
+    protected Future<Job.Result> executeJobAsync(int jobId, @NonNull final Job.Result expected) {
+        final JobProxy.Common common = new JobProxy.Common(RuntimeEnvironment.application, TestCat.INSTANCE, jobId);
+
+        final JobRequest pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNotNull();
+
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        Future<Job.Result> future = executor.submit(new Callable<Job.Result>() {
+            @Override
+            public Job.Result call() throws Exception {
+                Job.Result result = common.executeJobRequest(pendingRequest);
+                assertThat(result).isEqualTo(expected);
+                assertThat(common.getPendingRequest(true)).isNull();
+
+                return result;
+            }
+        });
+
+        executor.shutdown();
+        return future;
+    }
+
+    @SuppressWarnings("ResultOfMethodCallIgnored")
+    protected void resetJob(int jobId) {
+        Job job = manager().getJob(jobId);
+        if (job != null) {
+            doReturn(-1L).when(job).getFinishedTimeStamp();
+        }
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java b/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java
new file mode 100644
index 0000000..e8e9851
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java
@@ -0,0 +1,77 @@
+package com.evernote.android.job;
+
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.RuntimeEnvironment;
+
+import java.io.File;
+import java.util.Set;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * Databases should be created with UnitTestDatabaseCreator.java and then be pulled from the device.
+ * Best is to use an emulator with API 23.
+ *
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class DatabaseExistingTest extends BaseJobManagerTest {
+
+    @Test
+    public void upgradeFromV1() {
+        testDatabase("evernote_jobs_v1.db");
+    }
+
+    @Test
+    public void upgradeFromV2() {
+        testDatabase("evernote_jobs_v2.db");
+    }
+
+    private void testDatabase(String name) {
+        String filePath = getClass().getResource("/databases/" + name).getPath();
+        assertThat(new File(filePath).exists()).isTrue();
+
+        JobStorage storage = new JobStorage(RuntimeEnvironment.application, filePath);
+
+        Set<JobRequest> requests = storage.getAllJobRequests("tag", true);
+        assertThat(requests).hasSize(30);
+
+        int exact = 0;
+        int oneOff = 0;
+        int periodic = 0;
+
+        for (JobRequest request : requests) {
+            if (request.isExact()) {
+                exact++;
+            } else if (request.isPeriodic()) {
+                periodic++;
+            } else {
+                oneOff++;
+            }
+        }
+
+        assertThat(exact).isEqualTo(10);
+        assertThat(oneOff).isEqualTo(10);
+        assertThat(periodic).isEqualTo(10);
+
+        // none of them should be transient
+        for (JobRequest request : requests) {
+            assertThat(request.isTransient()).isFalse();
+        }
+
+        for (JobRequest request : requests) {
+            if (!request.isPeriodic()) {
+                continue;
+            }
+
+            assertThat(request.getIntervalMs()).isGreaterThanOrEqualTo(JobRequest.MIN_INTERVAL);
+            assertThat(request.getFlexMs()).isGreaterThanOrEqualTo(JobRequest.MIN_FLEX);
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
similarity index 91%
rename from library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
rename to library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
index 10e3975..2fba623 100644
--- a/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
+++ b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
@@ -4,16 +4,15 @@
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.filters.LargeTest;
-import android.support.test.runner.AndroidJUnit4;
 
+import com.evernote.android.job.test.JobRobolectricTestRunner;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
-import com.facebook.stetho.Stetho;
 
-import org.junit.BeforeClass;
+import org.junit.FixMethodOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.RuntimeEnvironment;
 
 import java.util.concurrent.TimeUnit;
 
@@ -36,23 +35,18 @@
 import static com.evernote.android.job.JobStorage.COLUMN_TRANSIENT;
 import static com.evernote.android.job.JobStorage.DATABASE_NAME;
 import static com.evernote.android.job.JobStorage.JOB_TABLE_NAME;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Java6Assertions.assertThat;
 
 /**
  * @author rwondratschek
  */
-@RunWith(AndroidJUnit4.class)
-@LargeTest
-public class DatabaseUpgradeTest {
-
-    @BeforeClass
-    public static void beforeClass() {
-        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
-    }
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class DatabaseManualUpgradeTest {
 
     @Test
     public void testDatabaseUpgrade1to3() {
-        Context context = InstrumentationRegistry.getContext();
+        Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
         JobOpenHelper1 openHelper = new JobOpenHelper1(context);
@@ -64,7 +58,7 @@ public void testDatabaseUpgrade1to3() {
 
     @Test
     public void testDatabaseUpgrade2to3() {
-        Context context = InstrumentationRegistry.getContext();
+        Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
         JobOpenHelper2 openHelper = new JobOpenHelper2(context);
@@ -76,7 +70,7 @@ public void testDatabaseUpgrade2to3() {
 
     @Test
     public void testDatabaseUpgrade1to2to3() {
-        Context context = InstrumentationRegistry.getContext();
+        Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
         JobOpenHelper1 openHelper = new JobOpenHelper1(context);
@@ -167,12 +161,12 @@ public Job create(String tag) {
         JobManager.instance().destroy();
     }
 
-    private abstract class UpgradeAbleJobOpenHelper extends SQLiteOpenHelper {
+    private abstract static class UpgradeAbleJobOpenHelper extends SQLiteOpenHelper {
 
         private boolean mDatabaseCreated;
         private boolean mDatabaseUpgraded;
 
-        public UpgradeAbleJobOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
+        UpgradeAbleJobOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
             super(context, name, factory, version);
         }
 
@@ -222,9 +216,9 @@ protected ContentValues createBaseContentValues(int id) {
         }
     }
 
-    private class JobOpenHelper1 extends UpgradeAbleJobOpenHelper {
+    private static final class JobOpenHelper1 extends UpgradeAbleJobOpenHelper {
 
-        public JobOpenHelper1(Context context) {
+        JobOpenHelper1(Context context) {
             super(context, DATABASE_NAME, null, 1);
         }
 
@@ -259,9 +253,9 @@ private void createJobTable(SQLiteDatabase db) {
         }
     }
 
-    private class JobOpenHelper2 extends UpgradeAbleJobOpenHelper {
+    private static final class JobOpenHelper2 extends UpgradeAbleJobOpenHelper {
 
-        public JobOpenHelper2(Context context) {
+        JobOpenHelper2(Context context) {
             super(context, DATABASE_NAME, null, 2);
         }
 
diff --git a/library/src/test/java/com/evernote/android/job/FailureCountTest.java b/library/src/test/java/com/evernote/android/job/FailureCountTest.java
new file mode 100644
index 0000000..9c50598
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/FailureCountTest.java
@@ -0,0 +1,57 @@
+package com.evernote.android.job;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class FailureCountTest extends BaseJobManagerTest {
+
+    @Test
+    public void incrementPeriodicJobFailureCount() {
+        int jobId = DummyJobs.createBuilder(DummyJobs.FailureJob.class)
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.FAILURE);
+        assertThat(manager().getJobRequest(jobId).getFailureCount()).isEqualTo(1);
+
+        resetJob(jobId);
+
+        executeJob(jobId, Job.Result.FAILURE);
+        assertThat(manager().getJobRequest(jobId).getFailureCount()).isEqualTo(2);
+    }
+
+    @Test
+    public void incrementRescheduleJobFailureCount() {
+        int jobId = DummyJobs.createBuilder(DummyJobs.RescheduleJob.class)
+                .setExecutionWindow(1_000, 2_000)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        DummyJobs.RescheduleJob job = (DummyJobs.RescheduleJob) manager().getJob(jobId);
+        jobId = job.getNewJobId();
+
+        assertThat(manager().getJobRequest(jobId).getFailureCount()).isEqualTo(1);
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        job = (DummyJobs.RescheduleJob) manager().getJob(jobId);
+        jobId = job.getNewJobId();
+
+        assertThat(manager().getJobRequest(jobId).getFailureCount()).isEqualTo(2);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
new file mode 100644
index 0000000..e2b4d29
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
@@ -0,0 +1,86 @@
+package com.evernote.android.job;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobExecutionTest extends BaseJobManagerTest {
+
+    @Test
+    public void testPeriodicJob() throws Exception {
+        int jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
+                .setPersisted(true)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.SUCCESS);
+
+        // make sure job request is still around
+        assertThat(manager().getAllJobRequestsForTag(DummyJobs.SuccessJob.TAG)).hasSize(1);
+    }
+
+    @Test
+    public void testSimpleJob() throws Throwable {
+        final int jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.SUCCESS);
+
+        assertThat(manager().getAllJobRequestsForTag(DummyJobs.SuccessJob.TAG)).isEmpty();
+
+        assertThat(manager().getJobRequest(jobId)).isNull();
+        assertThat(manager().getJobRequest(jobId, true)).isNull();
+    }
+
+    @Test
+    public void testTransientState() throws Throwable {
+        int jobId = DummyJobs.createBuilder(DummyJobs.TwoSecondPauseJob.class)
+                .setExecutionWindow(300_000, 400_000)
+                .build()
+                .schedule();
+
+        executeJobAsync(jobId, Job.Result.SUCCESS);
+
+        // wait until the job is started
+        Thread.sleep(100);
+
+        // request should be in transient state, running but not removed from DB
+        JobRequest transientRequest = manager().getJobRequest(jobId, true);
+        assertThat(transientRequest).isNotNull();
+        assertThat(transientRequest.isTransient()).isTrue();
+    }
+
+    @Test
+    public void testPeriodicJobNotInTransientState() throws Throwable {
+        int jobId = DummyJobs.createBuilder(DummyJobs.TwoSecondPauseJob.class)
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
+                .build()
+                .schedule();
+
+        executeJobAsync(jobId, Job.Result.SUCCESS);
+
+        // wait until the job is started
+        Thread.sleep(100);
+
+        // request should be in transient state, running but not removed from DB
+        JobRequest transientRequest = manager().getJobRequest(jobId, true);
+        assertThat(transientRequest).isNotNull();
+        assertThat(transientRequest.isTransient()).isFalse();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerRule.java b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
new file mode 100644
index 0000000..55b21fc
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
@@ -0,0 +1,44 @@
+package com.evernote.android.job;
+
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.test.TestCat;
+import com.evernote.android.job.util.JobCat;
+
+import org.junit.rules.ExternalResource;
+import org.robolectric.RuntimeEnvironment;
+
+/**
+ * @author rwondratschek
+ */
+public final class JobManagerRule extends ExternalResource {
+
+    private JobManager mManager;
+    private final JobCreator mJobCreator;
+
+    public JobManagerRule(@NonNull JobCreator jobCreator) {
+        mJobCreator = jobCreator;
+    }
+
+    @Override
+    protected void before() throws Throwable {
+        JobCat.addLogPrinter(TestCat.INSTANCE);
+        mManager = JobManager.create(RuntimeEnvironment.application);
+        mManager.addJobCreator(mJobCreator);
+    }
+
+    @Override
+    protected void after() {
+        mManager.cancelAll();
+        mManager.destroy();
+        JobCat.removeLogPrinter(TestCat.INSTANCE);
+    }
+
+    public JobManager getJobManager() {
+        return mManager;
+    }
+
+    public void setJobFinished() {
+        mManager.removeJobCreator(mJobCreator);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerTest.java b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
new file mode 100644
index 0000000..de7d30d
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
@@ -0,0 +1,68 @@
+package com.evernote.android.job;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobManagerTest extends BaseJobManagerTest {
+
+    @Test
+    public void testScheduleAndCancel() {
+        JobRequest request = DummyJobs.createOneOff();
+        int jobId = request.schedule();
+
+        assertThat(manager().getJobRequest(jobId)).isNotNull();
+        assertThat(manager().getJob(jobId)).isNull();
+
+        assertThat(manager().cancel(jobId)).isTrue();
+
+        assertThat(manager().getAllJobRequests()).isEmpty();
+        assertThat(manager().getAllJobs()).isEmpty();
+
+        request.schedule();
+        request.schedule();
+        request.schedule();
+
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+        assertThat(manager().cancelAll()).isEqualTo(1);
+
+        assertThat(manager().getAllJobRequests()).isEmpty();
+        assertThat(manager().getAllJobs()).isEmpty();
+    }
+
+    @Test
+    public void testSameIdAfterCancel() {
+        JobRequest request = DummyJobs.createOneOff();
+        int jobId = request.getJobId();
+
+        manager().schedule(request);
+
+        int newId = request.cancelAndEdit().build().schedule();
+        assertThat(newId).isEqualTo(jobId);
+    }
+
+    @Test
+    public void testCancelTag() {
+        JobRequest request = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExecutionWindow(300_000, 400_000)
+                .build();
+        request.schedule();
+
+        assertThat(manager().getAllJobRequestsForTag(DummyJobs.SuccessJob.TAG)).hasSize(1);
+        assertThat(manager().getAllJobRequestsForTag("other")).isNotNull().isEmpty();
+
+        assertThat(manager().cancelAllForTag(DummyJobs.SuccessJob.TAG)).isEqualTo(1);
+        assertThat(manager().cancelAllForTag(DummyJobs.SuccessJob.TAG)).isZero();
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
similarity index 81%
rename from library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java
rename to library/src/test/java/com/evernote/android/job/JobRequestTest.java
index a1afb56..b48c1da 100644
--- a/library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
@@ -1,56 +1,23 @@
 package com.evernote.android.job;
 
-import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.filters.LargeTest;
-import android.support.test.runner.AndroidJUnit4;
-
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
 import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
-import com.facebook.stetho.Stetho;
 
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
+import org.junit.FixMethodOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Java6Assertions.assertThat;
 
 /**
  * @author rwondratschek
  */
-@RunWith(AndroidJUnit4.class)
-@LargeTest
-public class JobRequestTest {
-
-    @BeforeClass
-    public static void beforeClass() {
-        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
-
-        JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
-            @Override
-            public Job create(String tag) {
-                return new TestJob();
-            }
-        });
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        JobManager.instance().destroy();
-    }
-
-    @Before
-    public void beforeTest() {
-        JobManager.instance().cancelAll();
-    }
-
-    @After
-    public void afterTest() {
-        JobManager.instance().cancelAll();
-    }
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobRequestTest extends BaseJobManagerTest {
 
     @Test
     public void testSimpleJob() {
@@ -62,7 +29,7 @@ public void testSimpleJob() {
                 .build();
 
         assertThat(request.getJobId()).isGreaterThan(0);
-        assertThat(request.getTag()).isEqualTo(TestJob.TAG);
+        assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
         assertThat(request.getStartMs()).isEqualTo(2_000L);
         assertThat(request.getEndMs()).isEqualTo(3_000L);
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
@@ -89,7 +56,7 @@ public void testPeriodic() {
                 .build();
 
         assertThat(request.getJobId()).isGreaterThan(0);
-        assertThat(request.getTag()).isEqualTo(TestJob.TAG);
+        assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
         assertThat(request.isPersisted()).isTrue();
         assertThat(request.getIntervalMs()).isEqualTo(interval);
         assertThat(request.getFlexMs()).isEqualTo(interval);
@@ -110,17 +77,18 @@ public void testPeriodic() {
 
     @Test
     public void testFlex() {
+        JobManager.instance().forceApi(JobApi.V_14);
+
         long interval = JobRequest.MIN_INTERVAL * 5;
         long flex = JobRequest.MIN_FLEX * 5;
         JobRequest request = getBuilder()
                 .setPeriodic(interval, flex)
                 .build();
 
-        JobManager.instance().forceApi(JobApi.V_14);
         JobManager.instance().schedule(request);
 
         assertThat(request.getJobId()).isGreaterThan(0);
-        assertThat(request.getTag()).isEqualTo(TestJob.TAG);
+        assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
         assertThat(request.getIntervalMs()).isEqualTo(interval);
         assertThat(request.getFlexMs()).isEqualTo(flex);
         assertThat(request.isPeriodic()).isTrue();
@@ -137,7 +105,7 @@ public void testExact() {
                 .build();
 
         assertThat(request.getJobId()).isGreaterThan(0);
-        assertThat(request.getTag()).isEqualTo(TestJob.TAG);
+        assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
         assertThat(request.getStartMs()).isEqualTo(2_000L);
         assertThat(request.getEndMs()).isEqualTo(2_000L);
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
@@ -245,17 +213,6 @@ public void testExactNoRequirementsEnforced() {
     }
 
     private JobRequest.Builder getBuilder() {
-        return new JobRequest.Builder(TestJob.TAG);
-    }
-
-    private static final class TestJob extends Job {
-
-        private static final String TAG = "tag";
-
-        @NonNull
-        @Override
-        protected Result onRunJob(@NonNull Params params) {
-            return Result.FAILURE;
-        }
+        return DummyJobs.createBuilder(DummyJobs.SuccessJob.class);
     }
 }
diff --git a/library/src/test/java/com/evernote/android/job/test/DummyJobs.java b/library/src/test/java/com/evernote/android/job/test/DummyJobs.java
new file mode 100644
index 0000000..5d902a6
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/test/DummyJobs.java
@@ -0,0 +1,125 @@
+package com.evernote.android.job.test;
+
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.Job;
+import com.evernote.android.job.JobCreator;
+import com.evernote.android.job.JobRequest;
+
+import static org.mockito.Mockito.spy;
+
+/**
+ * @author rwondratschek
+ */
+public final class DummyJobs {
+
+    private DummyJobs() {
+        throw new UnsupportedOperationException();
+    }
+
+    public static final class SuccessJob extends Job {
+
+        public static final String TAG = "SuccessJob";
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            return Result.SUCCESS;
+        }
+    }
+
+    public static final class RescheduleJob extends Job {
+
+        public static final String TAG = "RescheduleJob";
+
+        private int mNewJobId;
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            return Result.RESCHEDULE;
+        }
+
+        @Override
+        protected void onReschedule(int newJobId) {
+            mNewJobId = newJobId;
+        }
+
+        public int getNewJobId() {
+            return mNewJobId;
+        }
+    }
+
+    public static final class FailureJob extends Job {
+
+        public static final String TAG = "FailureJob";
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            return Result.FAILURE;
+        }
+    }
+
+    public static final class TwoSecondPauseJob extends Job {
+        public static final String TAG = "TwoSecondPauseJob";
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            try {
+                Thread.sleep(2_000);
+            } catch (InterruptedException ignored) {
+            }
+            return Result.SUCCESS;
+        }
+    }
+
+    public static final JobCreator TEST_JOB_CREATOR = new JobCreator() {
+        @Override
+        public Job create(String tag) {
+            switch (tag) {
+                case SuccessJob.TAG:
+                    return new SuccessJob();
+                case RescheduleJob.TAG:
+                    return new RescheduleJob();
+                case FailureJob.TAG:
+                    return new FailureJob();
+                case TwoSecondPauseJob.TAG:
+                    return new TwoSecondPauseJob();
+                default:
+                    return null;
+            }
+        }
+    };
+
+    public static final class SpyableJobCreator implements JobCreator {
+
+        private final JobCreator mJobCreator;
+
+        public SpyableJobCreator(JobCreator jobCreator) {
+            mJobCreator = jobCreator;
+        }
+
+        @Override
+        public Job create(String tag) {
+            Job job = mJobCreator.create(tag);
+            return job == null ? null : spy(job);
+        }
+    }
+
+    public static JobRequest.Builder createBuilder(Class<? extends Job> jobClass) {
+        try {
+            String tag = (String) jobClass.getDeclaredField("TAG").get(null);
+            return new JobRequest.Builder(tag);
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public static JobRequest createOneOff() {
+        return createBuilder(SuccessJob.class)
+                .setExecutionWindow(300_000, 400_000)
+                .build();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java b/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java
new file mode 100644
index 0000000..22c3998
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java
@@ -0,0 +1,24 @@
+package com.evernote.android.job.test;
+
+import com.evernote.android.job.BuildConfig;
+
+import org.junit.runners.model.InitializationError;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * @author rwondratschek
+ */
+public class JobRobolectricTestRunner extends RobolectricTestRunner {
+
+    public JobRobolectricTestRunner(Class<?> testClass) throws InitializationError {
+        super(testClass);
+    }
+
+    @Override
+    protected Config buildGlobalConfig() {
+        return new Config.Builder()
+                .setConstants(BuildConfig.class)
+                .build();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/test/TestCat.java b/library/src/test/java/com/evernote/android/job/test/TestCat.java
new file mode 100644
index 0000000..2985959
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/test/TestCat.java
@@ -0,0 +1,32 @@
+package com.evernote.android.job.test;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import net.vrallev.android.cat.instance.CatLazy;
+import net.vrallev.android.cat.print.CatPrinter;
+
+/**
+ * @author rwondratschek
+ */
+public final class TestCat extends CatLazy implements CatPrinter {
+
+    public static final TestCat INSTANCE = new TestCat();
+
+    private TestCat() {
+        // no op
+    }
+
+    @Override
+    protected void println(int priority, String message, Throwable t) {
+        println(priority, "Unit-Test", message, t);
+    }
+
+    @Override
+    public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+        // System.out.println(message);
+        // if (t != null) {
+        //     t.printStackTrace();
+        // }
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/util/DeviceTest.java b/library/src/test/java/com/evernote/android/job/util/DeviceTest.java
new file mode 100644
index 0000000..cd49b45
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/util/DeviceTest.java
@@ -0,0 +1,132 @@
+package com.evernote.android.job.util;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.test.mock.MockContext;
+
+import com.evernote.android.job.JobRequest;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+/**
+ * @author rwondratschek
+ */
+@FixMethodOrder(MethodSorters. JVM)
+public class DeviceTest {
+
+    @Test
+    public void testNetworkStateNotConnectedWithNullNetworkInfo() {
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.ANY);
+    }
+
+    @Test
+    public void testNetworkStateNotConnected() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(false);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(false);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.ANY);
+    }
+
+    @Test
+    public void testNetworkStateUnmeteredWifi() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(true);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);
+        when(networkInfo.getType()).thenReturn(ConnectivityManager.TYPE_WIFI);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.UNMETERED);
+    }
+
+    @Test
+    public void testNetworkStateMeteredNotRoaming() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(true);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);
+        when(networkInfo.getType()).thenReturn(ConnectivityManager.TYPE_MOBILE);
+        when(networkInfo.isRoaming()).thenReturn(false);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.NOT_ROAMING);
+    }
+
+    @Test
+    public void testNetworkStateRoaming() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(true);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);
+        when(networkInfo.getType()).thenReturn(ConnectivityManager.TYPE_MOBILE);
+        when(networkInfo.isRoaming()).thenReturn(true);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.CONNECTED);
+    }
+
+    @Test
+    public void testNetworkStateWifiAndMobile() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(true);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);
+        when(networkInfo.getType()).thenReturn(ConnectivityManager.TYPE_WIFI);
+        when(networkInfo.isRoaming()).thenReturn(false);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.UNMETERED);
+    }
+
+    @Test
+    public void testNetworkStateWifiAndRoaming() {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(true);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);
+        when(networkInfo.getType()).thenReturn(ConnectivityManager.TYPE_WIFI);
+        when(networkInfo.isRoaming()).thenReturn(true);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        assertThat(Device.getNetworkType(context)).isEqualTo(JobRequest.NetworkType.UNMETERED);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/util/LoggerTest.java b/library/src/test/java/com/evernote/android/job/util/LoggerTest.java
new file mode 100644
index 0000000..ef757ef
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/util/LoggerTest.java
@@ -0,0 +1,143 @@
+package com.evernote.android.job.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import net.vrallev.android.cat.print.CatPrinter;
+
+import org.junit.After;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@FixMethodOrder(MethodSorters.JVM)
+public class LoggerTest {
+
+    private boolean mResetValueCalled;
+
+    @After
+    public void resetValue() {
+        JobCat.setLogcatEnabled(true);
+        mResetValueCalled = true;
+    }
+
+    @Test
+    public void testIsLogcatEnabled() {
+        // first test in class, so resetValue() hasn't been called, yet
+        assertThat(mResetValueCalled).isFalse();
+        assertThat(JobCat.isLogcatEnabled()).isTrue();
+
+        JobCat.setLogcatEnabled(false);
+        assertThat(JobCat.isLogcatEnabled()).isFalse();
+    }
+
+    @Test
+    public void testAddIsIdempotent() {
+        TestPrinter printer = new TestPrinter();
+        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+        assertThat(JobCat.addLogPrinter(printer)).isFalse();
+    }
+
+    @Test
+    public void testRemove() {
+        TestPrinter printer = new TestPrinter();
+        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+        JobCat.removeLogPrinter(printer);
+        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+    }
+
+    @Test
+    public void testSingleCustomLoggerAddBefore() {
+        TestPrinter printer = new TestPrinter();
+        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+
+        JobCat cat = new JobCat("Tag");
+        cat.d("hello");
+        cat.w("world");
+
+        assertThat(printer.mMessages).contains("hello", "world");
+    }
+
+    @Test
+    public void testSingleCustomLoggerAddAfter() {
+        JobCat cat = new JobCat("Tag");
+
+        TestPrinter printer = new TestPrinter();
+        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+
+        cat.d("hello");
+        cat.w("world");
+
+        assertThat(printer.mMessages).containsExactly("hello", "world");
+    }
+
+    @Test
+    public void test100Loggers() {
+        JobCat cat1 = new JobCat("Tag1");
+
+        List<TestPrinter> printers = new ArrayList<>();
+        for (int i = 0; i < 100; i++) {
+            TestPrinter printer = new TestPrinter();
+            assertThat(JobCat.addLogPrinter(printer)).isTrue();
+            printers.add(printer);
+        }
+
+        JobCat cat2 = new JobCat("Tag2");
+
+        cat1.d("hello");
+        cat2.w("world");
+
+        for (TestPrinter printer : printers) {
+            assertThat(printer.mTags).containsExactly("Tag1", "Tag2");
+            assertThat(printer.mMessages).containsExactly("hello", "world");
+        }
+
+        TestPrinter removedPrinter = printers.remove(50);
+        JobCat.removeLogPrinter(removedPrinter);
+
+        cat1.d("third");
+        for (TestPrinter printer : printers) {
+            assertThat(printer.mTags).containsExactly("Tag1", "Tag2", "Tag1");
+            assertThat(printer.mMessages).containsExactly("hello", "world", "third");
+        }
+        assertThat(removedPrinter.mTags).containsExactly("Tag1", "Tag2");
+        assertThat(removedPrinter.mMessages).containsExactly("hello", "world");
+    }
+
+    @Test
+    public void testNotVerboseLogging() {
+        JobCat cat = new JobCat("Tag");
+
+        TestPrinter fakeLogcatPrinter = new TestPrinter();
+        cat.addPrinter(fakeLogcatPrinter); // in this list logcat is enabled
+
+        cat.d("hello");
+
+        assertThat(fakeLogcatPrinter.mMessages).containsExactly("hello");
+
+        JobCat.setLogcatEnabled(false);
+
+        cat.d("world");
+        assertThat(fakeLogcatPrinter.mMessages).containsExactly("hello");
+    }
+
+    private static final class TestPrinter implements CatPrinter {
+
+        private final List<String> mTags = new ArrayList<>();
+        private final List<String> mMessages = new ArrayList<>();
+
+        @Override
+        public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+            mTags.add(tag);
+            mMessages.add(message);
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java b/library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java
similarity index 87%
rename from library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java
rename to library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java
index 2a61428..630f28b 100644
--- a/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java
+++ b/library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java
@@ -1,23 +1,21 @@
-package com.evernote.android.job.test;
+package com.evernote.android.job.util.support;
 
-import android.support.test.filters.SmallTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import com.evernote.android.job.util.support.PersistableBundleCompat;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
 
+import org.junit.FixMethodOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Java6Assertions.assertThat;
 
 /**
  * @author rwondratschek
  */
-@RunWith(AndroidJUnit4.class)
-@SmallTest
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
 public class PersistableBundleCompatTest {
 
-    @SuppressWarnings("ConstantConditions")
     @Test
     public void testBundle() {
         PersistableBundleCompat bundle = new PersistableBundleCompat();
diff --git a/library/src/test/resources/databases/evernote_jobs_v1.db b/library/src/test/resources/databases/evernote_jobs_v1.db
new file mode 100644
index 0000000..fcfea1e
Binary files /dev/null and b/library/src/test/resources/databases/evernote_jobs_v1.db differ
diff --git a/library/src/test/resources/databases/evernote_jobs_v2.db b/library/src/test/resources/databases/evernote_jobs_v2.db
new file mode 100644
index 0000000..791c254
Binary files /dev/null and b/library/src/test/resources/databases/evernote_jobs_v2.db differ
diff --git a/library/src/test/resources/databases/evernote_jobs_v3.db b/library/src/test/resources/databases/evernote_jobs_v3.db
new file mode 100644
index 0000000..86e1281
Binary files /dev/null and b/library/src/test/resources/databases/evernote_jobs_v3.db differ
diff --git a/library/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker b/library/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
new file mode 100644
index 0000000..ca6ee9c
--- /dev/null
+++ b/library/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker
@@ -0,0 +1 @@
+mock-maker-inline
\ No newline at end of file
