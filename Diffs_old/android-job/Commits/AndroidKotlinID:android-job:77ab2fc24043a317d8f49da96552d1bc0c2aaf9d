diff --git a/CHANGELOG.md b/CHANGELOG.md
index 97deaba..a9876d6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,6 @@
+## 1.3.0-alpha01
+* Implement an API that uses the `WorkManager` for scheduling work items
+
 ## 1.2.6 (2018-05-27)
 * Make the license in Java files clearer, see #422
 * Use own internal monitor for synchronizing access to variables in order to avoid deadlocks when using the library, see #414
diff --git a/README.md b/README.md
index 97f3600..34f45b3 100644
--- a/README.md
+++ b/README.md
@@ -12,6 +12,8 @@ dependencies {
 }
 ```
 
+Starting with version `1.3.0` the library will use the `WorkManager` internally, please read the [documentation](https://github.com/evernote/android-job#workmanager) and opt-in.
+
 If you didn't turn off the manifest merger from the Gradle build tools, then no further step is required to setup the library. Otherwise you manually need to add the permissions and services like in this [AndroidManifest](library/src/main/AndroidManifest.xml).
 
 You can read the [JavaDoc here](https://evernote.github.io/android-job/javadoc/).
@@ -149,6 +151,23 @@ The library doesn't use reflection, but it relies on three `Service`s and two `B
 
 See the [FAQ](https://github.com/evernote/android-job/wiki/FAQ) in the [Wiki](https://github.com/evernote/android-job/wiki).
 
+## WorkManager
+
+[WorkManager](https://developer.android.com/topic/libraries/architecture/workmanager) is a new architecture component from Google and tries to solve a very similar problem this library tries to solve: implementing background jobs only once for all Android versions. The API is very similar to this library, but provides more features like chaining work items and it runs its own executor.
+
+If you start a new project, you should be using `WorkManager` instead of this library. You should also start migrating your code from this library to `WorkManager`. At some point in the future this library will be deprecated.
+
+Starting with version `1.3.0` this library will use the `WorkManager` internally for scheduling jobs. That should ease the transition to the new architecture component. You only need to add the `WorkManager` to your classpath, e.g.
+```groovy
+dependencies {
+    implementation "android.arch.work:work-runtime:$work_version"
+}
+```
+This library will detect the `WorkManager` at runtime and use it from now on. To opt-out of this change (what isn't recommended) either exclude `WorkManager` from your app or turn the API off with
+```java
+JobConfig.setApiEnabled(JobApi.WORK_MANAGER, false);
+```
+
 ## Google Play Services
 
 This library does **not** automatically bundle the Google Play Services, because the dependency is really heavy and not all apps want to include them. That's why you need to add the dependency manually, if you want that the library uses the `GcmNetworkManager` on Android 4, then include the following dependency.
@@ -168,12 +187,6 @@ If you don't turn on the service, the library will always use the `AlarmManager`
 
 Crashes after removing the GCM dependency is a known limitation of the Google Play Services. Please take a look at [this workaround](https://github.com/evernote/android-job/wiki/FAQ#how-can-i-remove-the-gcm-dependency-from-my-app) to avoid those crashes.
 
-## WorkManager
-
-[WorkManager](https://developer.android.com/topic/libraries/architecture/workmanager) is a new architecture component from Google and tries to solve a very similar problem this library tries to solve: implementing background jobs only once for all Android versions. The API is very similar to this library, but provides more features like chaining work items and it runs its own executor.
-
-If you start a new project, you should be using `WorkManager` instead of this library. You should also start migrating your code from this library to `WorkManager`. At some point in the future this library will be deprecated.
-
 ## License
 ```
 Copyright (c) 2007-2017 by Evernote Corporation, All rights reserved.
diff --git a/build.gradle b/build.gradle
index 7269160..26592e6 100644
--- a/build.gradle
+++ b/build.gradle
@@ -30,6 +30,7 @@ ext {
 
     supportLibVersion = '26.1.0'
     playServicesVersion = '15.0.1'
+    workVersion = "1.0.0-alpha02"
     stethoVersion = '1.5.0'
     junitVersion = '4.12'
     assertjVersion = '3.6.2'
diff --git a/demo/build.gradle b/demo/build.gradle
index 279f065..03756f5 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -51,6 +51,7 @@ dependencies {
     implementation "com.facebook.stetho:stetho:$stethoVersion"
 
     gcmImplementation "com.google.android.gms:play-services-gcm:$playServicesVersion"
+    gcmImplementation "android.arch.work:work-runtime:$workVersion"
 }
 
 uploadArchives.enabled false
\ No newline at end of file
diff --git a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
index 09639ea..b824184 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
@@ -79,6 +79,11 @@ public boolean onCreateOptionsMenu(Menu menu) {
     public boolean onPrepareOptionsMenu(Menu menu) {
         super.onPrepareOptionsMenu(menu);
 
+        if (JobApi.WORK_MANAGER.isSupported(this)) {
+            menu.findItem(R.id.action_force_work).setChecked(false);
+        } else {
+            menu.findItem(R.id.action_force_work).setVisible(false);
+        }
         if (JobApi.V_26.isSupported(this)) {
             menu.findItem(R.id.action_force_26).setChecked(false);
         } else {
@@ -111,6 +116,9 @@ public boolean onPrepareOptionsMenu(Menu menu) {
         }
 
         switch (JobApi.getDefault(this)) {
+            case WORK_MANAGER:
+                menu.findItem(R.id.action_force_work).setChecked(true);
+                break;
             case V_26:
                 menu.findItem(R.id.action_force_26).setChecked(true);
                 break;
diff --git a/demo/src/main/res/menu/activity_main.xml b/demo/src/main/res/menu/activity_main.xml
index 9dd9b3c..ab051b1 100644
--- a/demo/src/main/res/menu/activity_main.xml
+++ b/demo/src/main/res/menu/activity_main.xml
@@ -5,6 +5,10 @@
       tools:ignore="HardcodedText">
 
     <group android:checkableBehavior="single">
+        <item
+            android:id="@+id/action_force_work"
+            android:title="WorkManager"
+            app:showAsAction="never"/>
         <item
             android:id="@+id/action_force_26"
             android:title="v26"
diff --git a/library/build.gradle b/library/build.gradle
index cc0f68b..d3ea554 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -6,6 +6,7 @@ archivesBaseName = 'android-job'
 
 dependencies {
     compileOnly "com.google.android.gms:play-services-gcm:$playServicesVersion"
+    compileOnly "android.arch.work:work-runtime:$workVersion"
 
     //noinspection GradleCompatible,GradleDependency
     api "com.android.support:support-compat:$supportLibVersion"
@@ -15,6 +16,8 @@ dependencies {
     androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
     androidTestImplementation 'com.squareup.assertj:assertj-android:1.1.1'
     androidTestImplementation "com.google.android.gms:play-services-gcm:$playServicesVersion"
+    androidTestImplementation "android.arch.work:work-runtime:$workVersion"
+    androidTestImplementation "android.arch.work:work-testing:$workVersion"
 
     androidTestImplementation "com.facebook.stetho:stetho:$stethoVersion"
     androidTestImplementation "com.android.support:support-v4:$supportLibVersion"
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java
index 72c3765..716db52 100644
--- a/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java
@@ -24,6 +24,7 @@
     protected void before() throws Throwable {
         JobConfig.setJobReschedulePause(0, TimeUnit.MILLISECONDS);
         JobConfig.setSkipJobReschedule(true);
+        JobConfig.setApiEnabled(JobApi.WORK_MANAGER, false);
 
         mManager = JobManager.create(InstrumentationRegistry.getTargetContext());
         mManager.cancelAll();
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
index 5274d35..db80528 100644
--- a/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
@@ -1,5 +1,6 @@
 package com.evernote.android.job;
 
+import android.app.Application;
 import android.content.Context;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
@@ -75,6 +76,11 @@ public void testApi26() throws Exception {
         testOneOff(JobApi.V_26);
     }
 
+    @Test
+    public void testApiWorkManager() throws Exception {
+        testOneOff(JobApi.WORK_MANAGER);
+    }
+
     @Test
     public void testExactRealTime() throws Exception {
         testJobExact();
@@ -130,6 +136,9 @@ private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Excepti
             case V_26:
                 mJob = new TestJob(PlatformJobService.class);
                 break;
+            case WORK_MANAGER:
+                mJob = new TestJob(Application.class);
+                break;
             default:
                 throw new IllegalStateException("not implemented");
         }
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java
new file mode 100644
index 0000000..1702748
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java
@@ -0,0 +1,53 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.rules.ExternalResource;
+
+import java.util.concurrent.TimeUnit;
+
+import androidx.work.Configuration;
+import androidx.work.impl.WorkManagerImpl;
+import androidx.work.test.WorkManagerTestInitHelper;
+
+/**
+ * @author rwondratschek
+ */
+public class PlatformWorkManagerRule extends ExternalResource {
+
+    private JobManager mManager;
+
+    @Override
+    protected void before() {
+        Context context = InstrumentationRegistry.getTargetContext();
+
+        JobConfig.setJobReschedulePause(0, TimeUnit.MILLISECONDS);
+        JobConfig.setSkipJobReschedule(true);
+        JobConfig.forceApi(JobApi.WORK_MANAGER);
+
+        mManager = JobManager.create(context);
+        mManager.cancelAll();
+    }
+
+    @Override
+    protected void after() {
+        mManager.cancelAll();
+        mManager.destroy();
+
+        JobConfig.reset();
+        resetWorkManager();
+    }
+
+    public void resetWorkManager() {
+        WorkManagerImpl.setDelegate(new WorkManagerImpl(InstrumentationRegistry.getTargetContext(), new Configuration.Builder().build()));
+    }
+
+    public void initTestWorkManager() {
+        WorkManagerTestInitHelper.initializeTestWorkManager(InstrumentationRegistry.getTargetContext());
+    }
+
+    public JobManager getManager() {
+        return mManager;
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java b/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java
new file mode 100644
index 0000000..a2f9405
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java
@@ -0,0 +1,188 @@
+package com.evernote.android.job.work;
+
+import android.arch.lifecycle.LiveData;
+import android.arch.lifecycle.Observer;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.evernote.android.job.Job;
+import com.evernote.android.job.JobCreator;
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.PlatformWorkManagerRule;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import androidx.work.State;
+import androidx.work.WorkManager;
+import androidx.work.WorkStatus;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class PlatformWorkManagerTest {
+
+    private static final String TAG = "my-tag";
+
+    @Rule
+    public PlatformWorkManagerRule mWorkManagerRule = new PlatformWorkManagerRule();
+
+    @Test
+    public void testConstraintsOneOff() {
+        testConstraints(new JobRequest.Builder(TAG)
+                .setExecutionWindow(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(5))
+                .setBackoffCriteria(TimeUnit.MINUTES.toMillis(4), JobRequest.BackoffPolicy.EXPONENTIAL)
+        );
+    }
+
+    @Test
+    public void testConstraintsPeriodic() {
+        testConstraints(new JobRequest.Builder(TAG)
+                .setPeriodic(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(2))
+        );
+    }
+
+    @Test
+    public void testCancel() {
+        int jobId = new JobRequest.Builder(TAG)
+                .setExecutionWindow(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(5))
+                .build()
+                .schedule();
+
+        JobRequest request = mWorkManagerRule.getManager().getJobRequest(jobId);
+        JobProxyWorkManager jobProxyWorkManager = new JobProxyWorkManager(InstrumentationRegistry.getTargetContext());
+        assertThat(jobProxyWorkManager.isPlatformJobScheduled(request)).isTrue();
+
+        String tag = JobProxyWorkManager.createTag(jobId);
+        List<WorkStatus> statuses = getWorkStatus(tag);
+
+        assertThat(statuses).isNotNull().hasSize(1);
+        assertThat(statuses.get(0).getState()).isEqualTo(State.ENQUEUED);
+
+        mWorkManagerRule.getManager().cancel(jobId);
+        assertThat(getWorkStatus(tag).get(0).getState()).isEqualTo(State.CANCELLED);
+        assertThat(jobProxyWorkManager.isPlatformJobScheduled(request)).isFalse();
+    }
+
+    @Test
+    public void testTransientExtras() {
+        Bundle extras = new Bundle();
+        extras.putInt("key", 5);
+
+        JobRequest.Builder builder = new JobRequest.Builder(TAG)
+                .setExecutionWindow(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(5))
+                .setTransientExtras(extras);
+
+        int jobId = builder.build().schedule();
+
+        Bundle bundle = TransientBundleHolder.getBundle(jobId);
+        assertThat(bundle).isNotNull();
+        assertThat(bundle.getInt("key")).isEqualTo(5);
+
+        mWorkManagerRule.getManager().cancel(jobId);
+        assertThat(TransientBundleHolder.getBundle(jobId)).isNull();
+
+        mWorkManagerRule.initTestWorkManager();
+
+        jobId = builder.build().schedule();
+        assertThat(TransientBundleHolder.getBundle(jobId)).isNull();
+    }
+
+    @Test
+    public void testExecution() {
+        final AtomicBoolean executed = new AtomicBoolean(false);
+        final Job job = new Job() {
+            @NonNull
+            @Override
+            protected Result onRunJob(@NonNull Params params) {
+                executed.set(true);
+                return Result.SUCCESS;
+            }
+        };
+
+        mWorkManagerRule.getManager().addJobCreator(new JobCreator() {
+            @Nullable
+            @Override
+            public Job create(@NonNull String tag) {
+                if (tag.equals(TAG)) {
+                    return job;
+                } else {
+                    return null;
+                }
+            }
+        });
+
+        mWorkManagerRule.initTestWorkManager();
+
+        int jobId = new JobRequest.Builder(TAG)
+                .setExecutionWindow(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(5))
+                .build()
+                .schedule();
+
+        String tag = JobProxyWorkManager.createTag(jobId);
+        State state = getWorkStatus(tag).get(0).getState();
+
+        assertThat(executed.get()).isTrue();
+        assertThat(state).isEqualTo(State.SUCCEEDED);
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    private void testConstraints(JobRequest.Builder builder) {
+        int jobId = builder
+                .setRequiredNetworkType(JobRequest.NetworkType.METERED)
+                .setRequiresBatteryNotLow(true)
+                .setRequiresCharging(true)
+                .setRequiresDeviceIdle(true)
+                .setRequiresStorageNotLow(true)
+                .build()
+                .schedule();
+
+        String tag = JobProxyWorkManager.createTag(jobId);
+        List<WorkStatus> statuses = getWorkStatus(tag);
+
+        assertThat(statuses).isNotNull().hasSize(1);
+        assertThat(statuses.get(0).getState()).isEqualTo(State.ENQUEUED);
+
+        mWorkManagerRule.getManager().cancelAllForTag(TAG);
+        assertThat(getWorkStatus(tag).get(0).getState()).isEqualTo(State.CANCELLED);
+    }
+
+    private List<WorkStatus> getWorkStatus(String tag) {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<List<WorkStatus>> reference = new AtomicReference<>();
+
+        final LiveData<List<WorkStatus>> liveData = WorkManager.getInstance().getStatusesByTag(tag);
+        liveData.observeForever(new Observer<List<WorkStatus>>() {
+            @Override
+            public void onChanged(@Nullable List<WorkStatus> workStatuses) {
+                if (reference.get() == null) {
+                    reference.set(workStatuses);
+                }
+                liveData.removeObserver(this);
+                latch.countDown();
+            }
+        });
+
+        try {
+            assertThat(latch.await(3, TimeUnit.SECONDS)).isTrue();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+        return reference.get();
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/JobApi.java b/library/src/main/java/com/evernote/android/job/JobApi.java
index 9f45b6a..6d21057 100644
--- a/library/src/main/java/com/evernote/android/job/JobApi.java
+++ b/library/src/main/java/com/evernote/android/job/JobApi.java
@@ -35,16 +35,23 @@
 import com.evernote.android.job.v21.PlatformJobService;
 import com.evernote.android.job.v24.JobProxy24;
 import com.evernote.android.job.v26.JobProxy26;
+import com.evernote.android.job.work.JobProxyWorkManager;
 import com.google.android.gms.gcm.GcmNetworkManager;
 
 import java.util.List;
 
+import androidx.work.WorkManager;
+
 /**
  * All available APIs.
  *
  * @author rwondratschek
  */
 public enum JobApi {
+    /**
+     * Uses the {@link WorkManager} for scheduling jobs.
+     */
+    WORK_MANAGER(true, false, true),
     /**
      * Uses the {@link JobScheduler} for scheduling jobs.
      */
@@ -98,6 +105,8 @@
 
     public boolean isSupported(Context context) {
         switch (this) {
+            case WORK_MANAGER:
+                return WorkManagerAvailableHelper.isWorkManagerApiSupported();
             case V_26:
                 return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isServiceEnabled(context, PlatformJobService.class);
             case V_24:
@@ -121,6 +130,8 @@ public boolean isSupported(Context context) {
     @NonNull
     private JobProxy createProxy(Context context) {
         switch (this) {
+            case WORK_MANAGER:
+                return new JobProxyWorkManager(context);
             case V_26:
                 return new JobProxy26(context);
             case V_24:
@@ -194,7 +205,9 @@ private boolean isBroadcastEnabled(@NonNull Context context, @NonNull Class<? ex
 
     @NonNull
     public static JobApi getDefault(Context context) {
-        if (V_26.isSupported(context) && JobConfig.isApiEnabled(V_26)) {
+        if (WORK_MANAGER.isSupported(context) && JobConfig.isApiEnabled(WORK_MANAGER)) {
+            return WORK_MANAGER;
+        } else if (V_26.isSupported(context) && JobConfig.isApiEnabled(V_26)) {
             return V_26;
         } else if (V_24.isSupported(context) && JobConfig.isApiEnabled(V_24)) {
             return V_24;
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 37c837a..b8fcb97 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -15,7 +15,6 @@
  */
 package com.evernote.android.job;
 
-import android.app.Service;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
@@ -128,11 +127,7 @@ public static int getRescheduleCount(JobRequest request) {
 
         private final JobManager mJobManager;
 
-        public Common(@NonNull Service service, JobCat cat, int jobId) {
-            this((Context) service, cat, jobId);
-        }
-
-        /*package*/ Common(@NonNull Context context, JobCat cat, int jobId) {
+        public Common(@NonNull Context context, JobCat cat, int jobId) {
             mContext = context;
             mJobId = jobId;
             mCat = cat;
diff --git a/library/src/main/java/com/evernote/android/job/WorkManagerAvailableHelper.java b/library/src/main/java/com/evernote/android/job/WorkManagerAvailableHelper.java
new file mode 100644
index 0000000..05f20cd
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/WorkManagerAvailableHelper.java
@@ -0,0 +1,28 @@
+package com.evernote.android.job;
+
+/**
+ * @author rwondratschek
+ */
+/*package*/ final class WorkManagerAvailableHelper {
+
+    private static final boolean MANAGER_IN_CLASSPATH;
+
+    static {
+        boolean managerInClasspath;
+        try {
+            Class.forName("androidx.work.WorkManager");
+            managerInClasspath = true;
+        } catch (Throwable t) {
+            managerInClasspath = false;
+        }
+        MANAGER_IN_CLASSPATH = managerInClasspath;
+    }
+
+    public static boolean isWorkManagerApiSupported() {
+        return MANAGER_IN_CLASSPATH;
+    }
+
+    private WorkManagerAvailableHelper() {
+        // no op
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java b/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java
new file mode 100644
index 0000000..2d8c214
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java
@@ -0,0 +1,161 @@
+package com.evernote.android.job.work;
+
+import android.arch.lifecycle.LiveData;
+import android.arch.lifecycle.Observer;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.JobProxy;
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobCat;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import androidx.work.Constraints;
+import androidx.work.NetworkType;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.PeriodicWorkRequest;
+import androidx.work.State;
+import androidx.work.WorkManager;
+import androidx.work.WorkStatus;
+
+/**
+ * @author rwondratschek
+ */
+public class JobProxyWorkManager implements JobProxy {
+
+    private static final String PREFIX = "android-job-";
+
+    private static final JobCat CAT = new JobCat("JobProxyWork");
+
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final Context mContext;
+
+    public JobProxyWorkManager(Context context) {
+        mContext = context;
+    }
+
+    @Override
+    public void plantOneOff(JobRequest request) {
+        if (request.isTransient()) {
+            TransientBundleHolder.putBundle(request.getJobId(), request.getTransientExtras());
+        }
+
+        OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(PlatformWorker.class)
+                .setInitialDelay(request.getStartMs(), TimeUnit.MILLISECONDS) // don't use the average here, WorkManager will do the right thing
+                .setConstraints(buildConstraints(request))
+                .addTag(createTag(request.getJobId()))
+                .build();
+
+        // don't set the back-off criteria, android-job is handling this
+
+        getWorkManager().enqueue(workRequest);
+    }
+
+    @Override
+    public void plantPeriodic(JobRequest request) {
+        PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(PlatformWorker.class, request.getIntervalMs(), TimeUnit.MILLISECONDS,
+                request.getFlexMs(), TimeUnit.MILLISECONDS)
+                .setConstraints(buildConstraints(request))
+                .addTag(createTag(request.getJobId()))
+                .build();
+
+        getWorkManager().enqueue(workRequest);
+    }
+
+    @Override
+    public void plantPeriodicFlexSupport(JobRequest request) {
+        CAT.w("plantPeriodicFlexSupport called although flex is supported");
+        plantPeriodic(request);
+    }
+
+    @Override
+    public void cancel(int jobId) {
+        getWorkManager().cancelAllWorkByTag(createTag(jobId));
+        TransientBundleHolder.cleanUpBundle(jobId);
+    }
+
+    @Override
+    public boolean isPlatformJobScheduled(JobRequest request) {
+        List<WorkStatus> statuses = getWorkStatusBlocking(createTag(request.getJobId()));
+        if (statuses == null || statuses.isEmpty()) {
+            return false;
+        }
+
+        State state = statuses.get(0).getState();
+        return state == State.ENQUEUED;
+    }
+
+    /*package*/ static String createTag(int jobId) {
+        return PREFIX + jobId;
+    }
+
+    /*package*/ static int getJobIdFromTag(String tag) {
+        return Integer.parseInt(tag.substring(PREFIX.length()));
+    }
+
+    private static Constraints buildConstraints(JobRequest request) {
+        Constraints.Builder constraintsBuilder = new Constraints.Builder()
+                .setRequiresBatteryNotLow(request.requiresBatteryNotLow())
+                .setRequiresCharging(request.requiresCharging())
+                .setRequiresStorageNotLow(request.requiresStorageNotLow())
+                .setRequiredNetworkType(mapNetworkType(request.requiredNetworkType()));
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            constraintsBuilder.setRequiresDeviceIdle(request.requiresDeviceIdle());
+        }
+
+        return constraintsBuilder.build();
+    }
+
+    @NonNull
+    private static NetworkType mapNetworkType(@NonNull JobRequest.NetworkType networkType) {
+        switch (networkType) {
+            case ANY:
+                return NetworkType.NOT_REQUIRED;
+            case METERED:
+                return NetworkType.METERED;
+            case CONNECTED:
+                return NetworkType.CONNECTED;
+            case UNMETERED:
+                return NetworkType.UNMETERED;
+            case NOT_ROAMING:
+                return NetworkType.NOT_ROAMING;
+            default:
+                throw new IllegalStateException("Not implemented");
+        }
+    }
+
+    private WorkManager getWorkManager() {
+        // don't cache the instance, it could change under the hood, e.g. during tests
+        return WorkManager.getInstance();
+    }
+
+    private List<WorkStatus> getWorkStatusBlocking(String tag) {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<List<WorkStatus>> reference = new AtomicReference<>();
+
+        final LiveData<List<WorkStatus>> liveData = WorkManager.getInstance().getStatusesByTag(tag);
+        liveData.observeForever(new Observer<List<WorkStatus>>() {
+            @Override
+            public void onChanged(@Nullable List<WorkStatus> workStatuses) {
+                if (reference.get() == null) {
+                    reference.set(workStatuses);
+                }
+                liveData.removeObserver(this);
+                latch.countDown();
+            }
+        });
+
+        try {
+            latch.await(3, TimeUnit.SECONDS);
+        } catch (InterruptedException ignored) {
+        }
+        return reference.get();
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java b/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java
new file mode 100644
index 0000000..c7c5578
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java
@@ -0,0 +1,73 @@
+package com.evernote.android.job.work;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.Job;
+import com.evernote.android.job.JobManager;
+import com.evernote.android.job.JobProxy;
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobCat;
+
+import androidx.work.Worker;
+
+/**
+ * @author rwondratschek
+ */
+public class PlatformWorker extends Worker {
+
+    private static final JobCat CAT = new JobCat("PlatformWorker");
+
+    @NonNull
+    @Override
+    public WorkerResult doWork() {
+        final int jobId = getJobId();
+        try {
+            JobProxy.Common common = new JobProxy.Common(getApplicationContext(), CAT, jobId);
+
+            JobRequest request = common.getPendingRequest(true, true);
+            if (request == null) {
+                return WorkerResult.FAILURE;
+            }
+
+            Bundle transientBundle = null;
+            if (request.isTransient()) {
+                transientBundle = TransientBundleHolder.getBundle(jobId);
+                if (transientBundle == null) {
+                    CAT.d("Transient bundle is gone for request %s", request);
+                    return WorkerResult.FAILURE;
+                }
+            }
+
+            Job.Result result = common.executeJobRequest(request, transientBundle);
+            if (Job.Result.SUCCESS == result) {
+                return WorkerResult.SUCCESS;
+            } else {
+                return WorkerResult.FAILURE;
+            }
+        } finally {
+            TransientBundleHolder.cleanUpBundle(jobId);
+        }
+    }
+
+    @Override
+    public void onStopped() {
+        int jobId = getJobId();
+        Job job = JobManager.create(getApplicationContext()).getJob(jobId);
+
+        if (job != null) {
+            job.cancel();
+            CAT.d("Called onStopped for %s", job);
+        } else {
+            CAT.d("Called onStopped, job %d not found", jobId);
+        }
+    }
+
+    private String getTag() {
+        return getTags().iterator().next();
+    }
+
+    private int getJobId() {
+        return JobProxyWorkManager.getJobIdFromTag(getTag());
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/work/TransientBundleHolder.java b/library/src/main/java/com/evernote/android/job/work/TransientBundleHolder.java
new file mode 100644
index 0000000..d6da9c7
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/work/TransientBundleHolder.java
@@ -0,0 +1,30 @@
+package com.evernote.android.job.work;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.util.SparseArray;
+
+/**
+ * @author rwondratschek
+ */
+/*package*/ final class TransientBundleHolder {
+
+    private TransientBundleHolder() {
+        // no-op
+    }
+
+    private static SparseArray<Bundle> bundles = new SparseArray<>();
+
+    public static synchronized void putBundle(int jobId, Bundle bundle) {
+        bundles.put(jobId, bundle);
+    }
+
+    @Nullable
+    public static synchronized Bundle getBundle(int jobId) {
+        return bundles.get(jobId);
+    }
+
+    public static synchronized void cleanUpBundle(int jobId) {
+        bundles.remove(jobId);
+    }
+}
