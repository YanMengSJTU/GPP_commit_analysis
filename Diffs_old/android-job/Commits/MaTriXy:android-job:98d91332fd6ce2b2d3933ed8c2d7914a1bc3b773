diff --git a/CHANGELOG.md b/CHANGELOG.md
index 00c602a..55cb84c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+## 1.1.7 (2017-02-21)
+
+* Use a service to reschedule jobs and prevent a too early process death, fixes #142
+
 ## 1.1.6 (2017-02-13)
 
 * Reschedule jobs after an app update occurred or the Google Play Services were updated, see #135
diff --git a/gradle.properties b/gradle.properties
index aee4bd7..41fd9a8 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
 #VERSION_NAME=1.1.6
-VERSION_NAME=1.1.6-SNAPSHOT
+VERSION_NAME=1.1.7-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/library/proguard.txt b/library/proguard.txt
index 1f9ff63..92506fb 100644
--- a/library/proguard.txt
+++ b/library/proguard.txt
@@ -4,4 +4,5 @@
 -keep public class com.evernote.android.job.v21.PlatformJobService
 -keep public class com.evernote.android.job.v14.PlatformAlarmService
 -keep public class com.evernote.android.job.v14.PlatformAlarmReceiver
--keep public class com.evernote.android.job.JobBootReceiver
\ No newline at end of file
+-keep public class com.evernote.android.job.JobBootReceiver
+-keep public class com.evernote.android.job.JobRescheduleService
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 87bfff7..fa210ed 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -46,6 +46,10 @@
                 <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
             </intent-filter>
         </service>
+
+        <service
+            android:name="com.evernote.android.job.JobRescheduleService"
+            android:exported="false"/>
     </application>
 
 </manifest>
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index 896d279..4a52329 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -34,8 +34,6 @@
 import android.content.pm.ActivityInfo;
 import android.content.pm.ResolveInfo;
 import android.os.Build;
-import android.os.PowerManager;
-import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -52,7 +50,6 @@
 
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.TimeUnit;
 
 /**
  * Entry point for scheduling jobs. Depending on the platform and SDK version it uses different APIs
@@ -191,7 +188,7 @@ private JobManager(Context context) {
 
         setJobProxy(JobApi.getDefault(mContext, mConfig.isGcmApiEnabled()));
 
-        rescheduleTasksIfNecessary();
+        JobRescheduleService.startService(mContext);
     }
 
     /**
@@ -471,7 +468,7 @@ public void removeJobCreator(JobCreator jobCreator) {
         }
     }
 
-    private JobProxy getJobProxy(JobRequest request) {
+    /*package*/ JobProxy getJobProxy(JobRequest request) {
         return getJobProxy(request.getJobApi());
     }
 
@@ -479,52 +476,6 @@ private JobProxy getJobProxy(JobApi api) {
         return api.getCachedProxy(mContext);
     }
 
-    private void rescheduleTasksIfNecessary() {
-        final PowerManager.WakeLock wakeLock = WakeLockUtil.acquireWakeLock(mContext, JobManager.class.getName(), TimeUnit.MINUTES.toMillis(1));
-
-        new Thread() {
-            @Override
-            public void run() {
-                try {
-                    /*
-                     * Delay this slightly. This avoids a race condition if the app was launched by the
-                     * AlarmManager. Then the alarm was already removed, but the JobRequest might still
-                     * be available in the storage. We still catch this case, because we never execute
-                     * a job with the same ID twice. However, the still save resources with the delay.
-                     */
-                    SystemClock.sleep(10_000L);
-
-                    Set<JobRequest> requests = mJobStorage.getAllJobRequests(null, true);
-
-                    int rescheduledCount = 0;
-                    for (JobRequest request : requests) {
-                        boolean reschedule;
-                        if (request.isTransient()) {
-                            Job job = getJob(request.getJobId());
-                            reschedule = job == null;
-                        } else {
-                            reschedule = !getJobProxy(request).isPlatformJobScheduled(request);
-                        }
-
-                        if (reschedule) {
-                            // update execution window
-                            request.cancelAndEdit()
-                                    .build()
-                                    .schedule();
-
-                            rescheduledCount++;
-                        }
-                    }
-
-                    CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
-
-                } finally {
-                    WakeLockUtil.releaseWakeLock(wakeLock);
-                }
-            }
-        }.start();
-    }
-
     public final class Config {
 
         private boolean mVerbose;
diff --git a/library/src/main/java/com/evernote/android/job/JobRescheduleService.java b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
new file mode 100644
index 0000000..528100e
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
@@ -0,0 +1,74 @@
+package com.evernote.android.job;
+
+import android.app.IntentService;
+import android.content.Context;
+import android.content.Intent;
+import android.os.SystemClock;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+import com.evernote.android.job.util.JobCat;
+
+import net.vrallev.android.cat.CatLog;
+
+import java.util.Set;
+
+/**
+ * @author rwondratschek
+ */
+public final class JobRescheduleService extends IntentService {
+
+    private static final String TAG = "JobRescheduleService";
+    private static final CatLog CAT = new JobCat(TAG);
+
+    /*package*/ static void startService(Context context) {
+        Intent intent = new Intent(context, JobRescheduleService.class);
+        WakefulBroadcastReceiver.startWakefulService(context, intent);
+    }
+
+    public JobRescheduleService() {
+        super(TAG);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        try {
+            /*
+             * Delay this slightly. This avoids a race condition if the app was launched by the
+             * AlarmManager. Then the alarm was already removed, but the JobRequest might still
+             * be available in the storage. We still catch this case, because we never execute
+             * a job with the same ID twice. However, the still save resources with the delay.
+             */
+            CAT.d("Reschedule service started");
+            SystemClock.sleep(10_000L);
+
+            JobManager manager = JobManager.create(this);
+            Set<JobRequest> requests = manager.getJobStorage().getAllJobRequests(null, true);
+
+            int rescheduledCount = 0;
+            for (JobRequest request : requests) {
+                boolean reschedule;
+                if (request.isTransient()) {
+                    Job job = manager.getJob(request.getJobId());
+                    reschedule = job == null;
+                } else {
+                    reschedule = !manager.getJobProxy(request).isPlatformJobScheduled(request);
+                }
+
+                if (reschedule) {
+                    // update execution window
+                    request.cancelAndEdit()
+                            .build()
+                            .schedule();
+
+                    rescheduledCount++;
+                }
+            }
+
+            CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
+
+        } finally {
+            WakefulBroadcastReceiver.completeWakefulIntent(intent);
+        }
+
+    }
+}
