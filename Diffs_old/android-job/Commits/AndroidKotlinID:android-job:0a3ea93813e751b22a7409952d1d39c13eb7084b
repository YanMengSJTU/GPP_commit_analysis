diff --git a/CHANGELOG.md b/CHANGELOG.md
index 49a4e1d..80163a1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+## 1.2.2 (2018-01-13)
+* Use only the `support-compat` instead of the full `support-v4` library, see #326
+* Use a `ReadWriteLock` for synchronizing the database reads and writes, see #344
+* Update the last run time for daily jobs, see #332
+* Shift the max execution delay if the requirements are enforced, see #325
+
 ## 1.2.1 (2017-11-23)
 * Add option to override the default background executor, see #292
 * Don't keep a strong reference to finished jobs to allow freeing memory, see #299
diff --git a/README.md b/README.md
index 861737f..4ee38bd 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@ Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evern
 
 ```groovy
 dependencies {
-    compile 'com.evernote:android-job:1.2.1'
+    compile 'com.evernote:android-job:1.2.2'
 }
 ```
 
diff --git a/build.gradle b/build.gradle
index 73983a3..f538255 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
         google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0'
+        classpath 'com.android.tools.build:gradle:3.0.1'
         classpath 'com.github.ben-manes:gradle-versions-plugin:0.15.0'
     }
 }
@@ -26,18 +26,18 @@ ext {
     targetSdkVersion = compileSdkVersion
     minSdkVersion = 14
 
-    buildToolsVersion = '26.0.2'
+    buildToolsVersion = '27.0.3'
 
-    supportLibVersion = '26.0.1'
+    supportLibVersion = '26.0.2'
     playServicesVersion = '11.0.2'
     stethoVersion = '1.5.0'
     junitVersion = '4.12'
     assertjVersion = '3.6.2'
     mockitoVersion = '2.7.22'
-    robolectricVersion = '3.5.1'
+    robolectricVersion = '3.6.1'
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '4.3.1'
+    gradleVersion = '4.4.1'
     distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
 }
diff --git a/gradle.properties b/gradle.properties
index cc94efe..d398fd2 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.2.1
-VERSION_NAME=1.2.1-SNAPSHOT
+#VERSION_NAME=1.2.2
+VERSION_NAME=1.2.2-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 27768f1..01b8bf6 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 702c4b6..57c7d2d 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 52ec44e..cc0f68b 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -7,16 +7,17 @@ archivesBaseName = 'android-job'
 dependencies {
     compileOnly "com.google.android.gms:play-services-gcm:$playServicesVersion"
 
-    //noinspection GradleDependency
-    api "com.android.support:support-v4:$supportLibVersion"
+    //noinspection GradleCompatible,GradleDependency
+    api "com.android.support:support-compat:$supportLibVersion"
 
-    androidTestImplementation 'com.android.support.test:runner:1.0.0'
-    androidTestImplementation 'com.android.support.test:rules:1.0.0'
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
     androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
     androidTestImplementation 'com.squareup.assertj:assertj-android:1.1.1'
     androidTestImplementation "com.google.android.gms:play-services-gcm:$playServicesVersion"
 
     androidTestImplementation "com.facebook.stetho:stetho:$stethoVersion"
+    androidTestImplementation "com.android.support:support-v4:$supportLibVersion"
 
     testImplementation "junit:junit:$junitVersion"
     testImplementation "org.mockito:mockito-core:$mockitoVersion"
diff --git a/library/lint.xml b/library/lint.xml
index 972ee49..a11e176 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -13,4 +13,5 @@
         <ignore path="src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java"/>
     </issue>
     <issue id="GradleDependency" severity="ignore"/>
+    <issue id="GradleCompatible" severity="ignore"/>
 </lint>
\ No newline at end of file
diff --git a/library/src/main/java/com/evernote/android/job/DailyJob.java b/library/src/main/java/com/evernote/android/job/DailyJob.java
index 97ede96..1a63fa9 100644
--- a/library/src/main/java/com/evernote/android/job/DailyJob.java
+++ b/library/src/main/java/com/evernote/android/job/DailyJob.java
@@ -176,9 +176,14 @@ protected final Result onRunJob(@NonNull Params params) {
                     CAT.i("Rescheduling daily job %s", request);
 
                     // don't update current, it would cancel this currently running job
-                    schedule(request.createBuilder(), false,
+                    int newJobId = schedule(request.createBuilder(), false,
                             extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY);
 
+                    request = JobManager.instance().getJobRequest(newJobId);
+                    if (request != null) {
+                        request.updateStats(false, true);
+                    }
+
                 } else {
                     CAT.i("Cancel daily job %s", request);
                 }
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 74c6f01..b1fecdc 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -511,7 +511,7 @@ public int getFailureCount() {
         }
 
         /**
-         * Returns the time the job did run the last time. This is only useful for periodic jobs
+         * Returns the time the job did run the last time. This is only useful for periodic jobs, daily jobs
          * or jobs which were rescheduled. If the job didn't run, yet, then it returns 0.
          *
          * @return The last time the rescheduled or periodic job did run.
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 516941b..3c68a41 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -69,6 +69,19 @@ private static long checkedAdd(long a, long b) {
             return checkNoOverflow(result, (a ^ b) < 0 | (a ^ result) >= 0);
         }
 
+        @SuppressWarnings("SameParameterValue")
+        private static long checkedMultiply(long a, long b) {
+            int leadingZeros = Long.numberOfLeadingZeros(a) + Long.numberOfLeadingZeros(~a) + Long.numberOfLeadingZeros(b) + Long.numberOfLeadingZeros(~b);
+            if (leadingZeros > Long.SIZE + 1) {
+                return a * b;
+            }
+            long result = a * b;
+            result = checkNoOverflow(result, leadingZeros >= Long.SIZE);
+            result = checkNoOverflow(result, a >= 0 | b != Long.MIN_VALUE);
+            result = checkNoOverflow(result, a == 0 || result / a == b);
+            return result;
+        }
+
         private static long checkNoOverflow(long result, boolean condition) {
             return condition ? result : Long.MAX_VALUE;
         }
@@ -82,11 +95,21 @@ public static long getStartMs(JobRequest request) {
         }
 
         public static long getEndMs(JobRequest request) {
+            return getEndMs(request, false);
+        }
+
+        public static long getEndMs(JobRequest request, boolean shiftEnd) {
+            long endMs;
             if (request.getFailureCount() > 0) {
-                return request.getBackoffOffset();
+                endMs = request.getBackoffOffset();
             } else {
-                return request.getEndMs();
+                endMs = request.getEndMs();
+            }
+            if (shiftEnd && request.requirementsEnforced() && request.hasRequirements()) {
+                // move the end backwards if the API is smart with the requirements
+                endMs = checkedMultiply(endMs, 100);
             }
+            return endMs;
         }
 
         public static long getAverageDelayMs(JobRequest request) {
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 36d743c..1a6cea2 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -251,6 +251,14 @@ public NetworkType requiredNetworkType() {
         return mBuilder.mNetworkType;
     }
 
+    /**
+     * @return Whether any of the requirements is different than the default value.
+     */
+    public boolean hasRequirements() {
+        return requiresCharging() || requiresDeviceIdle() || requiresBatteryNotLow() || requiresStorageNotLow()
+                || requiredNetworkType() != DEFAULT_NETWORK_TYPE;
+    }
+
     /**
      * @return The extras for this job.
      */
@@ -357,7 +365,7 @@ public int getFailureCount() {
     }
 
     /**
-     * Returns the time the job did run the last time. This is only useful for periodic jobs
+     * Returns the time the job did run the last time. This is only useful for periodic jobs, daily jobs
      * or jobs which were rescheduled. If the job didn't run, yet, then it returns 0.
      *
      * @return The last time the rescheduled or periodic job did run.
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index ff6642d..224720d 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -47,6 +47,8 @@
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
  * @author rwondratschek
@@ -111,12 +113,15 @@
     private final JobOpenHelper mDbHelper;
     private SQLiteDatabase mInjectedDatabase;
 
+    private final ReadWriteLock mLock;
+
     public JobStorage(Context context) {
         this(context, DATABASE_NAME);
     }
 
     public JobStorage(Context context, String databasePath) {
         mPreferences = context.getSharedPreferences(PREF_FILE_NAME, Context.MODE_PRIVATE);
+        mLock = new ReentrantReadWriteLock();
 
         mCacheId = new JobCacheId();
 
@@ -128,18 +133,25 @@ public JobStorage(Context context, String databasePath) {
         }
     }
 
-    public synchronized void put(final JobRequest request) {
-        // don't write to db async, there could be a race condition with remove()
-        store(request);
+    public void put(final JobRequest request) {
+        mLock.writeLock().lock();
+        try {
+            // don't write to db async, there could be a race condition with remove()
+            store(request);
 
-        // put in cache if store() was successful
-        updateRequestInCache(request);
+            // put in cache if store() was successful
+            updateRequestInCache(request);
+        } finally {
+            mLock.writeLock().unlock();
+        }
     }
 
-    public synchronized void update(JobRequest request, ContentValues contentValues) {
-        updateRequestInCache(request);
+    public void update(JobRequest request, ContentValues contentValues) {
         SQLiteDatabase database = null;
+        mLock.writeLock().lock();
+
         try {
+            updateRequestInCache(request);
             database = getDatabase();
             database.update(JOB_TABLE_NAME, contentValues, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
         } catch (Exception e) {
@@ -147,6 +159,7 @@ public synchronized void update(JobRequest request, ContentValues contentValues)
             CAT.e(e, "could not update %s", request);
         } finally {
             closeDatabase(database);
+            mLock.writeLock().unlock();
         }
     }
 
@@ -154,16 +167,24 @@ private void updateRequestInCache(JobRequest request) {
         mCacheId.put(request.getJobId(), request);
     }
 
-    public synchronized JobRequest get(int id) {
-        // not necessary to check if failed to delete, the cache is doing this
-        return mCacheId.get(id);
+    public JobRequest get(int id) {
+        mLock.readLock().lock();
+        try {
+            // not necessary to check if failed to delete, the cache is doing this
+            return mCacheId.get(id);
+        } finally {
+            mLock.readLock().unlock();
+        }
     }
 
-    public synchronized Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeStarted) {
+    public Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeStarted) {
         Set<JobRequest> result = new HashSet<>();
 
         SQLiteDatabase database = null;
         Cursor cursor = null;
+
+        mLock.readLock().lock();
+
         try {
             String where; // filter started requests
             String[] args;
@@ -199,19 +220,23 @@ public synchronized JobRequest get(int id) {
         } finally {
             closeCursor(cursor);
             closeDatabase(database);
+            mLock.readLock().unlock();
         }
 
         return result;
     }
 
-    public synchronized void remove(JobRequest request) {
+    public void remove(JobRequest request) {
         remove(request, request.getJobId());
     }
 
-    private synchronized boolean remove(@Nullable JobRequest request, int jobId) {
-        mCacheId.remove(jobId);
+    private boolean remove(@Nullable JobRequest request, int jobId) {
         SQLiteDatabase database = null;
+        mLock.writeLock().lock();
+
         try {
+            mCacheId.remove(jobId);
+
             database = getDatabase();
             database.delete(JOB_TABLE_NAME, COLUMN_ID + "=?", new String[]{String.valueOf(jobId)});
             return true;
@@ -221,6 +246,7 @@ private synchronized boolean remove(@Nullable JobRequest request, int jobId) {
             return false;
         } finally {
             closeDatabase(database);
+            mLock.writeLock().unlock();
         }
     }
 
diff --git a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
index 24a01e8..846df7b 100644
--- a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
+++ b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
@@ -68,7 +68,7 @@ protected JobProxy21(Context context, String logTag) {
     @Override
     public void plantOneOff(JobRequest request) {
         long startMs = Common.getStartMs(request);
-        long endMs = Common.getEndMs(request);
+        long endMs = Common.getEndMs(request, true);
 
         JobInfo jobInfo = createBuilderOneOff(createBaseBuilder(request, true), startMs, endMs).build();
         int scheduleResult = schedule(jobInfo);
diff --git a/library/src/test/java/com/evernote/android/job/DailyJobTest.java b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
index 1fd8071..dc3f3cf 100644
--- a/library/src/test/java/com/evernote/android/job/DailyJobTest.java
+++ b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
@@ -146,7 +146,7 @@ public void verifyScheduleAndExecutionOverMidnight() {
         verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(23),  TimeUnit.HOURS.toMillis(6));
     }
 
-    private void verifyExecutionAndSuccessfulReschedule(Clock clock, long start, long end) {
+    private JobRequest verifyExecutionAndSuccessfulReschedule(Clock clock, long start, long end) {
         JobConfig.setClock(clock);
 
         int jobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessDailyJob.class), start, end);
@@ -155,7 +155,10 @@ private void verifyExecutionAndSuccessfulReschedule(Clock clock, long start, lon
         executeJob(jobId, Job.Result.SUCCESS);
 
         assertThat(manager().getAllJobRequests()).hasSize(1);
-        assertThat(manager().getJobRequest(jobId + 1)).isNotNull();
+
+        JobRequest newRequest = manager().getJobRequest(jobId + 1);
+        assertThat(newRequest).isNotNull();
+        return newRequest;
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -259,6 +262,15 @@ public void verifyImmediateExecution() {
         assertThat(manager().getJobRequest(normalJobId)).isNotNull();
     }
 
+    @Test
+    public void verifyLastRunIsSet() {
+        TestClock clock = new TestClock();
+        clock.setTime(13, 0);
+
+        JobRequest request = verifyExecutionAndSuccessfulReschedule(clock, 0, 1);
+        assertThat(request.getLastRun()).isEqualTo(clock.currentTimeMillis());
+    }
+
     @Test
     public void verifyRequirementsEnforcedSkipsJob() {
         long time = 1L;
diff --git a/library/src/test/java/com/evernote/android/job/JobProxyTest.java b/library/src/test/java/com/evernote/android/job/JobProxyTest.java
index ab745d1..f956d50 100644
--- a/library/src/test/java/com/evernote/android/job/JobProxyTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobProxyTest.java
@@ -4,6 +4,7 @@
 import android.app.job.JobInfo;
 import android.app.job.JobScheduler;
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import com.evernote.android.job.test.JobRobolectricTestRunner;
 
@@ -17,6 +18,8 @@
 import org.robolectric.shadows.ShadowAlarmManager;
 
 import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Objects;
 
 import static org.assertj.core.api.Java6Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
@@ -43,11 +46,11 @@ public void cleanup() {
 
     @Test
     @Config(sdk = 21)
-    public void verifyRecoverWithJobScheduler() throws Exception {
+    public void verifyRecoverWithJobScheduler() {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        JobScheduler scheduler = (JobScheduler) applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        JobScheduler scheduler = getJobScheduler(applicationContext);
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(null, null, scheduler);
 
         JobManager.create(context);
@@ -57,7 +60,38 @@ public void verifyRecoverWithJobScheduler() throws Exception {
                 .build()
                 .schedule();
 
-        assertThat(scheduler.getAllPendingJobs()).isNotEmpty();
+        List<JobInfo> allPendingJobs = scheduler.getAllPendingJobs();
+        assertThat(allPendingJobs).hasSize(1);
+
+        JobInfo jobInfo = allPendingJobs.get(0);
+        assertThat(jobInfo.getMinLatencyMillis()).isEqualTo(200_000L);
+        assertThat(jobInfo.getMaxExecutionDelayMillis()).isEqualTo(300_000L);
+    }
+
+    @Test
+    @Config(sdk = 21)
+    public void verifyMaxExecutionDelayIsNotSetInJobScheduler() {
+        Context context = BaseJobManagerTest.createMockContext();
+        Context applicationContext = context.getApplicationContext();
+
+        JobScheduler scheduler = getJobScheduler(applicationContext);
+        when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(scheduler);
+
+        JobManager.create(context);
+
+        new JobRequest.Builder("tag")
+                .setExecutionWindow(3_000L, 4_000L)
+                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)
+                .setRequirementsEnforced(true)
+                .build()
+                .schedule();
+
+        List<JobInfo> allPendingJobs = scheduler.getAllPendingJobs();
+        assertThat(allPendingJobs).hasSize(1);
+
+        JobInfo jobInfo = allPendingJobs.get(0);
+        assertThat(jobInfo.getMinLatencyMillis()).isEqualTo(3_000L);
+        assertThat(jobInfo.getMaxExecutionDelayMillis()).isGreaterThan(4_000L);
     }
 
     @Test
@@ -66,7 +100,7 @@ public void verifyRecoverWithAlarmManager() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(null);
 
@@ -86,7 +120,7 @@ public void verifyNoRecoverWithAlarmManager() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
         when(applicationContext.getSystemService(Context.ALARM_SERVICE)).thenReturn(null);
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(null);
@@ -107,7 +141,7 @@ public void verifyRecoverWithAlarmManagerApi19() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(null, null, alarmManager);
 
@@ -127,7 +161,7 @@ public void verifyNoRecoverWithAlarmManagerApi19() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
         when(applicationContext.getSystemService(Context.ALARM_SERVICE)).thenReturn(null);
 
@@ -141,13 +175,14 @@ public void verifyNoRecoverWithAlarmManagerApi19() throws Exception {
         verifyAlarmCount(alarmManager, 0);
     }
 
+    @SuppressWarnings("ConstantConditions")
     @Test
     @Config(sdk = 21)
-    public void verifyRecoverWithoutBootPermissionJobScheduler() throws Exception {
+    public void verifyRecoverWithoutBootPermissionJobScheduler() {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        JobScheduler scheduler = spy((JobScheduler) applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE));
+        JobScheduler scheduler = spy(getJobScheduler(applicationContext));
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(scheduler);
 
         doThrow(new IllegalArgumentException("Error: requested job be persisted without holding RECEIVE_BOOT_COMPLETED permission."))
@@ -176,9 +211,9 @@ public void verifyRecoverWithoutServiceJobScheduler() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
-        JobScheduler scheduler = spy((JobScheduler) applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE));
+        JobScheduler scheduler = spy(getJobScheduler(applicationContext));
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(scheduler);
 
         doThrow(new IllegalArgumentException("No such service ComponentInfo{com.evernote/com.evernote.android.job.v21.PlatformJobService}"))
@@ -202,9 +237,9 @@ public void verifyRecoverWithNpeInJobScheduler() throws Exception {
         Context context = BaseJobManagerTest.createMockContext();
         Context applicationContext = context.getApplicationContext();
 
-        AlarmManager alarmManager = (AlarmManager) applicationContext.getSystemService(Context.ALARM_SERVICE);
+        AlarmManager alarmManager = getAlarmManager(applicationContext);
 
-        JobScheduler scheduler = spy((JobScheduler) applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE));
+        JobScheduler scheduler = spy(getJobScheduler(applicationContext));
         when(applicationContext.getSystemService(Context.JOB_SCHEDULER_SERVICE)).thenReturn(scheduler);
 
         doThrow(new NullPointerException("Attempt to invoke interface method 'int android.app.job.IJobScheduler.schedule(android.app.job.JobInfo)' on a null object reference"))
@@ -228,4 +263,14 @@ private void verifyAlarmCount(AlarmManager alarmManager, int count) throws NoSuc
         ShadowAlarmManager shadowAlarmManager = (ShadowAlarmManager) declaredField.get(alarmManager);
         assertThat(shadowAlarmManager.getScheduledAlarms()).hasSize(count);
     }
+
+    @NonNull
+    private AlarmManager getAlarmManager(@NonNull Context context) {
+        return Objects.requireNonNull((AlarmManager) context.getSystemService(Context.ALARM_SERVICE));
+    }
+
+    @NonNull
+    private JobScheduler getJobScheduler(@NonNull Context context) {
+        return Objects.requireNonNull((JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE));
+    }
 }
