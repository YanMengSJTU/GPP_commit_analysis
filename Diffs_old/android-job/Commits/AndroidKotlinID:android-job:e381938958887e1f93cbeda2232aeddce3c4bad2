diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2362152..ea01b57 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+## 1.3.0-alpha04 (2018-07-20)
+* Fix rare NPE when `WorkManager` is null for some reason, see #477
+* Fix rare NPE when `JobStorage` is null, see #492
+* Fix class loading error for the GCM API, see #487
+* Use a `JobIntentService` implementation that doesn't crash, see #255
+
 ## 1.3.0-alpha03 (2018-06-11)
 * Remove wrong restriction for `PersistableBundleCompat`
 
diff --git a/README.md b/README.md
index 12c7fdd..6fe8134 100644
--- a/README.md
+++ b/README.md
@@ -11,7 +11,7 @@ dependencies {
     implementation 'com.evernote:android-job:1.2.6'
 
     // or
-    implementation 'com.evernote:android-job:1.3.0-alpha03'
+    implementation 'com.evernote:android-job:1.3.0-alpha04'
 }
 ```
 
diff --git a/build.gradle b/build.gradle
index 26592e6..c9d0e26 100644
--- a/build.gradle
+++ b/build.gradle
@@ -30,7 +30,7 @@ ext {
 
     supportLibVersion = '26.1.0'
     playServicesVersion = '15.0.1'
-    workVersion = "1.0.0-alpha02"
+    workVersion = '1.0.0-alpha04'
     stethoVersion = '1.5.0'
     junitVersion = '4.12'
     assertjVersion = '3.6.2'
@@ -39,6 +39,6 @@ ext {
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '4.7'
+    gradleVersion = '4.8.1'
     distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
 }
diff --git a/gradle.properties b/gradle.properties
index 0b65ff1..130d76f 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.3.0-alpha03
+#VERSION_NAME=1.3.0-alpha04
 VERSION_NAME=1.3.0-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 91ca28c..758de96 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index e6a3091..debd024 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.7-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.8.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java
index 1702748..a11b9c2 100644
--- a/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformWorkManagerRule.java
@@ -1,14 +1,16 @@
 package com.evernote.android.job;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.test.InstrumentationRegistry;
 
 import org.junit.rules.ExternalResource;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
 import androidx.work.Configuration;
-import androidx.work.impl.WorkManagerImpl;
+import androidx.work.WorkManager;
 import androidx.work.test.WorkManagerTestInitHelper;
 
 /**
@@ -17,11 +19,25 @@
 public class PlatformWorkManagerRule extends ExternalResource {
 
     private JobManager mManager;
+    private Executor mExecutor;
+    private boolean mAllowExecution;
 
     @Override
     protected void before() {
         Context context = InstrumentationRegistry.getTargetContext();
 
+        mAllowExecution = false;
+        mExecutor = new Executor() {
+            @Override
+            public void execute(@NonNull Runnable command) {
+                if (mAllowExecution) {
+                    command.run();
+                }
+            }
+        };
+
+        WorkManagerTestInitHelper.initializeTestWorkManager(context, new Configuration.Builder().setExecutor(mExecutor).build());
+
         JobConfig.setJobReschedulePause(0, TimeUnit.MILLISECONDS);
         JobConfig.setSkipJobReschedule(true);
         JobConfig.forceApi(JobApi.WORK_MANAGER);
@@ -36,18 +52,14 @@ protected void after() {
         mManager.destroy();
 
         JobConfig.reset();
-        resetWorkManager();
-    }
-
-    public void resetWorkManager() {
-        WorkManagerImpl.setDelegate(new WorkManagerImpl(InstrumentationRegistry.getTargetContext(), new Configuration.Builder().build()));
-    }
-
-    public void initTestWorkManager() {
-        WorkManagerTestInitHelper.initializeTestWorkManager(InstrumentationRegistry.getTargetContext());
+        WorkManager.getInstance().cancelAllWork();
     }
 
     public JobManager getManager() {
         return mManager;
     }
+
+    public void setAllowExecution(boolean allowExecution) {
+        mAllowExecution = allowExecution;
+    }
 }
diff --git a/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java b/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java
index 9279f1e..225d35c 100644
--- a/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/work/PlatformWorkManagerTest.java
@@ -99,7 +99,7 @@ public void testTransientExtras() {
         mWorkManagerRule.getManager().cancel(jobId);
         assertThat(TransientBundleHolder.getBundle(jobId)).isNull();
 
-        mWorkManagerRule.initTestWorkManager();
+        mWorkManagerRule.setAllowExecution(true);
 
         jobId = builder.build().schedule();
         assertThat(TransientBundleHolder.getBundle(jobId)).isNull();
@@ -129,7 +129,7 @@ public Job create(@NonNull String tag) {
             }
         });
 
-        mWorkManagerRule.initTestWorkManager();
+        mWorkManagerRule.setAllowExecution(true);
 
         int jobId = new JobRequest.Builder(TAG)
                 .setExecutionWindow(TimeUnit.HOURS.toMillis(4), TimeUnit.HOURS.toMillis(5))
diff --git a/library/src/main/java/android/support/v4/app/SafeJobIntentService.java b/library/src/main/java/android/support/v4/app/SafeJobIntentService.java
index 93addd4..cf42da7 100644
--- a/library/src/main/java/android/support/v4/app/SafeJobIntentService.java
+++ b/library/src/main/java/android/support/v4/app/SafeJobIntentService.java
@@ -1,5 +1,6 @@
 package android.support.v4.app;
 
+import android.os.Build;
 import android.support.annotation.RestrictTo;
 
 /**
@@ -17,4 +18,15 @@ GenericWorkItem dequeueWork() {
             return null;
         }
     }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // override mJobImpl with safe class to ignore SecurityException
+        if (Build.VERSION.SDK_INT >= 26) {
+            mJobImpl = new SafeJobServiceEngineImpl(this);
+        } else {
+            mJobImpl = null;
+        }
+    }
 }
diff --git a/library/src/main/java/android/support/v4/app/SafeJobServiceEngineImpl.java b/library/src/main/java/android/support/v4/app/SafeJobServiceEngineImpl.java
new file mode 100644
index 0000000..5242df8
--- /dev/null
+++ b/library/src/main/java/android/support/v4/app/SafeJobServiceEngineImpl.java
@@ -0,0 +1,107 @@
+package android.support.v4.app;
+
+import android.app.job.JobParameters;
+import android.app.job.JobServiceEngine;
+import android.app.job.JobWorkItem;
+import android.content.Intent;
+import android.os.IBinder;
+import android.support.annotation.RequiresApi;
+import android.util.Log;
+
+/**
+ * Implementation of a JobServiceEngine for interaction with JobIntentService.
+ */
+@RequiresApi(26)
+public class SafeJobServiceEngineImpl extends JobServiceEngine
+        implements JobIntentService.CompatJobEngine {
+    static final String TAG = "JobServiceEngineImpl";
+
+    static final boolean DEBUG = false;
+
+    final JobIntentService mService;
+    final Object mLock = new Object();
+    JobParameters mParams;
+
+    final class WrapperWorkItem implements JobIntentService.GenericWorkItem {
+        final JobWorkItem mJobWork;
+
+        WrapperWorkItem(JobWorkItem jobWork) {
+            mJobWork = jobWork;
+        }
+
+        @Override
+        public Intent getIntent() {
+            return mJobWork.getIntent();
+        }
+
+        @Override
+        public void complete() {
+            synchronized (mLock) {
+                if (mParams != null) {
+                    try {
+                        mParams.completeWork(mJobWork);
+                    } catch (SecurityException se) {
+                        // ignore
+                        se.printStackTrace();
+                    }
+                }
+            }
+        }
+    }
+
+    SafeJobServiceEngineImpl(JobIntentService service) {
+        super(service);
+        mService = service;
+    }
+
+    @Override
+    public IBinder compatGetBinder() {
+        return getBinder();
+    }
+
+    @Override
+    public boolean onStartJob(JobParameters params) {
+        if (DEBUG) Log.d(TAG, "onStartJob: " + params);
+        mParams = params;
+        // We can now start dequeuing work!
+        mService.ensureProcessorRunningLocked(false);
+        return true;
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        if (DEBUG) Log.d(TAG, "onStartJob: " + params);
+        boolean result = mService.doStopCurrentWork();
+        synchronized (mLock) {
+            // Once we return, the job is stopped, so its JobParameters are no
+            // longer valid and we should not be doing anything with them.
+            mParams = null;
+        }
+        return result;
+    }
+
+    /**
+     * Dequeue some work.
+     */
+    @Override
+    public JobIntentService.GenericWorkItem dequeueWork() {
+        JobWorkItem work = null;
+        synchronized (mLock) {
+            if (mParams == null) {
+                return null;
+            }
+            try {
+                work = mParams.dequeueWork();
+            } catch (SecurityException se) {
+                //ignore
+                se.printStackTrace();
+            }
+        }
+        if (work != null) {
+            work.getIntent().setExtrasClassLoader(mService.getClassLoader());
+            return new WrapperWorkItem(work);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java b/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
index 35a6f22..8db56f0 100644
--- a/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
+++ b/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
@@ -23,7 +23,6 @@
 import android.support.annotation.RestrictTo;
 
 import com.evernote.android.job.gcm.JobProxyGcm;
-import com.evernote.android.job.gcm.PlatformGcmService;
 import com.evernote.android.job.util.JobCat;
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GoogleApiAvailability;
@@ -81,7 +80,8 @@ private static int isGcmServiceRegistered(Context context) {
         if (gcmServiceAvailable < 0) {
             synchronized (JobApi.class) {
                 if (gcmServiceAvailable < 0) {
-                    Intent intent = new Intent(context, PlatformGcmService.class);
+                    Intent intent = new Intent();
+                    intent.setComponent(new ComponentName(context, getPlatformGcmServiceClassName()));
                     List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentServices(intent, 0);
                     if (!hasPermission(resolveInfos)) {
                         gcmServiceAvailable = ConnectionResult.SERVICE_MISSING;
@@ -121,8 +121,7 @@ private static void setServiceEnabled(Context context, boolean enabled) {
             PackageManager packageManager = context.getPackageManager();
 
             // use a string, the class object probably cannot be instantiated
-            String className = JobProxyGcm.class.getPackage().getName() + ".PlatformGcmService";
-            ComponentName component = new ComponentName(context, className);
+            ComponentName component = new ComponentName(context, getPlatformGcmServiceClassName());
 
             int componentEnabled = packageManager.getComponentEnabledSetting(component);
             switch (componentEnabled) {
@@ -154,6 +153,10 @@ private static void setServiceEnabled(Context context, boolean enabled) {
         }
     }
 
+    private static String getPlatformGcmServiceClassName() {
+        return JobProxyGcm.class.getPackage().getName() + ".PlatformGcmService";
+    }
+
     private GcmAvailableHelper() {
         // no op
     }
diff --git a/library/src/main/java/com/evernote/android/job/JobApi.java b/library/src/main/java/com/evernote/android/job/JobApi.java
index 6d21057..ff5ccf5 100644
--- a/library/src/main/java/com/evernote/android/job/JobApi.java
+++ b/library/src/main/java/com/evernote/android/job/JobApi.java
@@ -121,7 +121,12 @@ public boolean isSupported(Context context) {
                         || (isServiceEnabled(context, PlatformAlarmService.class) && isServiceEnabled(context, PlatformAlarmServiceExact.class)
                         && isBroadcastEnabled(context, PlatformAlarmReceiver.class));
             case GCM:
-                return GcmAvailableHelper.isGcmApiSupported(context);
+                try {
+                    // see https://github.com/evernote/android-job/issues/487
+                    return GcmAvailableHelper.isGcmApiSupported(context);
+                } catch (Exception e) {
+                    return false;
+                }
             default:
                 throw new IllegalStateException("not implemented");
         }
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index e30ee03..1e7e15c 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -140,7 +140,7 @@ public static JobManager instance() {
     private final JobCreatorHolder mJobCreatorHolder;
     private final JobExecutor mJobExecutor;
 
-    private JobStorage mJobStorage;
+    private volatile JobStorage mJobStorage;
     private final CountDownLatch mJobStorageLatch;
 
     private JobManager(final Context context) {
@@ -153,13 +153,13 @@ private JobManager(final Context context) {
         }
 
         mJobStorageLatch = new CountDownLatch(1);
-        JobConfig.getExecutorService().execute(new Runnable() {
+        new Thread("AndroidJob-storage-init") {
             @Override
             public void run() {
                 mJobStorage = new JobStorage(context);
                 mJobStorageLatch.countDown();
             }
-        });
+        }.start();
     }
 
     /**
@@ -455,14 +455,18 @@ public void removeJobCreator(JobCreator jobCreator) {
         mJobCreatorHolder.removeJobCreator(jobCreator);
     }
 
+    @NonNull
     /*package*/ JobStorage getJobStorage() {
         if (mJobStorage == null) {
             try {
-                mJobStorageLatch.await(3, TimeUnit.SECONDS);
+                mJobStorageLatch.await(10, TimeUnit.SECONDS);
             } catch (InterruptedException e) {
                 throw new RuntimeException(e);
             }
         }
+        if (mJobStorage == null) {
+            throw new IllegalStateException("Job storage shouldn't be null");
+        }
 
         return mJobStorage;
     }
diff --git a/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java b/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java
index 8c230ce..0e3d876 100644
--- a/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java
+++ b/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java
@@ -11,14 +11,17 @@
 import android.support.annotation.RestrictTo;
 
 import com.evernote.android.job.JobProxy;
+import com.evernote.android.job.JobProxyIllegalStateException;
 import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
 
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
+import androidx.work.Configuration;
 import androidx.work.Constraints;
 import androidx.work.NetworkType;
 import androidx.work.OneTimeWorkRequest;
@@ -60,7 +63,12 @@ public void plantOneOff(JobRequest request) {
 
         // don't set the back-off criteria, android-job is handling this
 
-        getWorkManager().enqueue(workRequest);
+        WorkManager workManager = getWorkManager();
+        if (workManager == null) {
+            throw new JobProxyIllegalStateException("WorkManager is null");
+        }
+
+        workManager.enqueue(workRequest);
     }
 
     @Override
@@ -71,7 +79,12 @@ public void plantPeriodic(JobRequest request) {
                 .addTag(createTag(request.getJobId()))
                 .build();
 
-        getWorkManager().enqueue(workRequest);
+        WorkManager workManager = getWorkManager();
+        if (workManager == null) {
+            throw new JobProxyIllegalStateException("WorkManager is null");
+        }
+
+        workManager.enqueue(workRequest);
     }
 
     @Override
@@ -82,7 +95,12 @@ public void plantPeriodicFlexSupport(JobRequest request) {
 
     @Override
     public void cancel(int jobId) {
-        getWorkManager().cancelAllWorkByTag(createTag(jobId));
+        WorkManager workManager = getWorkManager();
+        if (workManager == null) {
+            return;
+        }
+
+        workManager.cancelAllWorkByTag(createTag(jobId));
         TransientBundleHolder.cleanUpBundle(jobId);
     }
 
@@ -139,14 +157,26 @@ private static NetworkType mapNetworkType(@NonNull JobRequest.NetworkType networ
 
     private WorkManager getWorkManager() {
         // don't cache the instance, it could change under the hood, e.g. during tests
-        return WorkManager.getInstance();
+        WorkManager workManager = WorkManager.getInstance();
+        if (workManager == null) {
+            WorkManager.initialize(mContext, new Configuration.Builder().build());
+            workManager = WorkManager.getInstance();
+            CAT.w("WorkManager getInstance() returned null, now: %s", workManager);
+        }
+
+        return workManager;
     }
 
     private List<WorkStatus> getWorkStatusBlocking(String tag) {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<List<WorkStatus>> reference = new AtomicReference<>();
 
-        final LiveData<List<WorkStatus>> liveData = WorkManager.getInstance().getStatusesByTag(tag);
+        WorkManager workManager = getWorkManager();
+        if (workManager == null) {
+            return Collections.emptyList();
+        }
+
+        final LiveData<List<WorkStatus>> liveData = workManager.getStatusesByTag(tag);
         liveData.observeForever(new Observer<List<WorkStatus>>() {
             @Override
             public void onChanged(@Nullable List<WorkStatus> workStatuses) {
diff --git a/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java b/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java
index f1c850a..0e10493 100644
--- a/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java
+++ b/library/src/main/java/com/evernote/android/job/work/PlatformWorker.java
@@ -22,14 +22,14 @@
 
     @NonNull
     @Override
-    public WorkerResult doWork() {
+    public Result doWork() {
         final int jobId = getJobId();
         try {
             JobProxy.Common common = new JobProxy.Common(getApplicationContext(), CAT, jobId);
 
             JobRequest request = common.getPendingRequest(true, true);
             if (request == null) {
-                return WorkerResult.FAILURE;
+                return Result.FAILURE;
             }
 
             Bundle transientBundle = null;
@@ -37,15 +37,15 @@ public WorkerResult doWork() {
                 transientBundle = TransientBundleHolder.getBundle(jobId);
                 if (transientBundle == null) {
                     CAT.d("Transient bundle is gone for request %s", request);
-                    return WorkerResult.FAILURE;
+                    return Result.FAILURE;
                 }
             }
 
             Job.Result result = common.executeJobRequest(request, transientBundle);
             if (Job.Result.SUCCESS == result) {
-                return WorkerResult.SUCCESS;
+                return Result.SUCCESS;
             } else {
-                return WorkerResult.FAILURE;
+                return Result.FAILURE;
             }
         } finally {
             TransientBundleHolder.cleanUpBundle(jobId);
@@ -53,7 +53,7 @@ public WorkerResult doWork() {
     }
 
     @Override
-    public void onStopped() {
+    public void onStopped(boolean cancelled) {
         int jobId = getJobId();
         Job job = JobManager.create(getApplicationContext()).getJob(jobId);
 
