diff --git a/CHANGELOG.md b/CHANGELOG.md
index 602cc8e..1418b73 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,7 @@
 ## 1.2.1
 * Add option to override the default background executor, see #292
 * Don't keep a strong reference to finished jobs to allow freeing memory, see #299
+* Allow running a daily job immediately once, this is helpful for testing purposes, see #317
 
 ## 1.2.0 (2017-10-05)
 
diff --git a/library/src/main/java/com/evernote/android/job/DailyJob.java b/library/src/main/java/com/evernote/android/job/DailyJob.java
index 58fcfc3..4f4d473 100644
--- a/library/src/main/java/com/evernote/android/job/DailyJob.java
+++ b/library/src/main/java/com/evernote/android/job/DailyJob.java
@@ -11,6 +11,8 @@
 import net.vrallev.android.cat.CatLog;
 
 import java.util.Calendar;
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -28,6 +30,8 @@
     /*package*/ static final String EXTRA_START_MS = "EXTRA_START_MS";
     @VisibleForTesting
     /*package*/ static final String EXTRA_END_MS = "EXTRA_END_MS";
+    @VisibleForTesting
+    /*package*/ static final String EXTRA_ONCE = "EXTRA_ONCE";
 
     private static final long DAY = TimeUnit.DAYS.toMillis(1);
 
@@ -64,6 +68,26 @@ public static int schedule(@NonNull JobRequest.Builder baseBuilder, long startMs
         return schedule(baseBuilder, true, startMs, endMs);
     }
 
+    /**
+     * Schedules the daily job only once and runs it immediately. This is helpful if you want to reuse your job
+     * and want to trigger the execution immediately. It's possible to schedule a daily job normally with
+     * {@link #schedule(JobRequest.Builder, long, long)} and this method at the same time to trigger the
+     * execution immediately.
+     *
+     * @param baseBuilder The builder of your daily job.
+     * @return The unique ID for this job.
+     */
+    public static int startNowOnce(@NonNull JobRequest.Builder baseBuilder) {
+        PersistableBundleCompat extras = new PersistableBundleCompat();
+        extras.putBoolean(EXTRA_ONCE, true);
+
+        return baseBuilder
+                .startNow()
+                .addExtras(extras)
+                .build()
+                .schedule();
+    }
+
     private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob, long startMs, long endMs) {
         if (startMs >= DAY || endMs >= DAY || startMs < 0 || endMs < 0) {
             throw new IllegalArgumentException("startMs or endMs should be less than one day (in milliseconds)");
@@ -98,9 +122,19 @@ private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob,
 
         builder.addExtras(extras);
 
+        if (newJob) {
+            // cancel all previous jobs, but not the one scheduled immediately
+            JobManager manager = JobManager.instance();
+            Set<JobRequest> requests = new HashSet<>(manager.getAllJobRequestsForTag(builder.mTag));
+            for (JobRequest request : requests) {
+                if (!request.isExact() || request.getStartMs() != JobRequest.START_NOW) {
+                    manager.cancel(request.getJobId());
+                }
+            }
+        }
+
         JobRequest request = builder
                 .setExecutionWindow(Math.max(1L, startDelay), Math.max(1L, endDelay))
-                .setUpdateCurrent(newJob)
                 .build();
 
         if (newJob && (request.isExact() || request.isPeriodic() || request.isTransient())) {
@@ -117,7 +151,9 @@ private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob,
     @Override
     protected final Result onRunJob(Params params) {
         PersistableBundleCompat extras = params.getExtras();
-        if (!extras.containsKey(EXTRA_START_MS) || !extras.containsKey(EXTRA_END_MS)) {
+        boolean runOnce = extras.getBoolean(EXTRA_ONCE, false);
+
+        if (!runOnce && (!extras.containsKey(EXTRA_START_MS) || !extras.containsKey(EXTRA_END_MS))) {
             CAT.e("Daily job doesn't contain start and end time");
             return Result.FAILURE;
         }
@@ -133,16 +169,18 @@ protected final Result onRunJob(Params params) {
                 CAT.e("Daily job result was null");
             }
 
-            JobRequest request = params.getRequest();
-            if (result == DailyJobResult.SUCCESS) {
-                CAT.i("Rescheduling daily job %s", request);
+            if (!runOnce) {
+                JobRequest request = params.getRequest();
+                if (result == DailyJobResult.SUCCESS) {
+                    CAT.i("Rescheduling daily job %s", request);
 
-                // don't update current, it would cancel this currently running job
-                schedule(request.createBuilder(), false,
-                        extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY);
+                    // don't update current, it would cancel this currently running job
+                    schedule(request.createBuilder(), false,
+                            extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY);
 
-            } else {
-                CAT.i("Cancel daily job %s", request);
+                } else {
+                    CAT.i("Cancel daily job %s", request);
+                }
             }
         }
 
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 9e2f461..81be06f 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -526,7 +526,7 @@ public String toString() {
         private static final int CREATE_ID = -8765; // magic number
 
         private int mId;
-        private final String mTag;
+        final String mTag;
 
         private long mStartMs;
         private long mEndMs;
diff --git a/library/src/test/java/com/evernote/android/job/DailyJobTest.java b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
index 3b35b64..e3eea3b 100644
--- a/library/src/test/java/com/evernote/android/job/DailyJobTest.java
+++ b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
@@ -12,6 +12,7 @@
 import org.junit.runners.MethodSorters;
 
 import java.util.Calendar;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import static org.assertj.core.api.Java6Assertions.assertThat;
@@ -214,4 +215,45 @@ public void verifyDailyJobIsNotExact() {
         assertThat(request).isNotNull();
         assertThat(request.isExact()).isFalse();
     }
+
+    @Test
+    public void verifyScheduledTwiceOverridesExisting() {
+        long time = 1L;
+
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), time, time);
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), time, time);
+        Set<JobRequest> requests = manager().getAllJobRequests();
+
+        assertThat(requests).hasSize(1);
+        assertThat(requests.iterator().next().getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
+    }
+
+    @Test
+    public void verifyScheduledImmediatelyIsNotOverridden() {
+        long time = 1L;
+
+        DailyJob.startNowOnce(DummyJobs.createBuilder(DummyJobs.SuccessJob.class));
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), time, time);
+        Set<JobRequest> requests = manager().getAllJobRequests();
+
+        assertThat(requests).hasSize(2);
+        for (JobRequest request : requests) {
+            assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
+        }
+    }
+
+    @Test
+    public void verifyImmediateExecution() {
+        long time = 1L;
+
+        int nowJobId = DailyJob.startNowOnce(DummyJobs.createBuilder(DummyJobs.SuccessJob.class));
+        int normalJobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), time, time);
+        assertThat(manager().getAllJobRequests()).hasSize(2);
+
+        assertThat(nowJobId).isEqualTo(1);
+        executeJob(nowJobId, Job.Result.SUCCESS);
+
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+        assertThat(manager().getJobRequest(normalJobId)).isNotNull();
+    }
 }
