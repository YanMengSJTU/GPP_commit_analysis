diff --git a/CHANGELOG.md b/CHANGELOG.md
index 268a1b2..907b914 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,7 @@
 * Handle platform bug where querying the network state throws an NPE internally, see #380
 * Fix database access on main thread, see #385
 * Fix misleading log message for some internal improvements, see #391
+* Fix race condition when scheduling a job with `setUpdateCurrent(true)` where multiple jobs could have been scheduled, see #396
 
 ## 1.2.4 (2018-02-08)
 * Add `scheduleAsync()` to the `DailyJob` class for scheduling daily jobs asynchronously to avoid IO operations on the main thread, see #371
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index e824733..042ec59 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -168,7 +168,9 @@ private JobManager(Context context) {
      *
      * @param request The {@link JobRequest} which will run in the future.
      */
-    public void schedule(@NonNull JobRequest request) {
+    public synchronized void schedule(@NonNull JobRequest request) {
+        // call must be synchronized, otherwise with isUpdateCurrent() true it's possible to end up in a race condition with multiple jobs scheduled
+
         if (mJobCreatorHolder.isEmpty()) {
             CAT.w("you haven't registered a JobCreator with addJobCreator(), it's likely that your job never will be executed");
         }
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerTest.java b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
index 5c94c3d..7fc731c 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
@@ -293,4 +293,35 @@ public void testCancelAndEdit() {
         JobRequest request = manager().getJobRequest(newId);
         assertThat(request.getEndMs()).isGreaterThan(9_000);
     }
+
+    @Test
+    public void testWithUpdateCurrentRaceCondition() throws InterruptedException {
+        final JobRequest.Builder builder = new JobRequest.Builder("any").setExecutionWindow(300_000, 400_000).setUpdateCurrent(true);
+
+        final CountDownLatch latchWait = new CountDownLatch(2);
+        final CountDownLatch latchStart = new CountDownLatch(1);
+        final CountDownLatch latchFinished = new CountDownLatch(2);
+
+        for (int i = 0; i < 5; i++) {
+            new Thread() {
+                @Override
+                public void run() {
+                    latchWait.countDown();
+                    try {
+                        latchStart.await();
+                    } catch (InterruptedException e) {
+                        throw new IllegalStateException(e);
+                    }
+                    manager().schedule(builder.build());
+                    latchFinished.countDown();
+                }
+            }.start();
+        }
+
+        assertThat(latchWait.await(10, TimeUnit.SECONDS)).isTrue();
+        latchStart.countDown();
+        assertThat(latchFinished.await(10, TimeUnit.SECONDS)).isTrue();
+
+        assertThat(manager().getAllJobRequests().size()).isEqualTo(1);
+    }
 }
