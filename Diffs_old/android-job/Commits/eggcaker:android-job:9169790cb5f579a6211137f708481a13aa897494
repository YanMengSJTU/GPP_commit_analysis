diff --git a/CHANGELOG.md b/CHANGELOG.md
index e7a03b7..9f544f8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,7 @@
 * Fix misleading log message for some internal improvements, see #391
 * Fix race condition when scheduling a job with `setUpdateCurrent(true)` where multiple jobs could have been scheduled, see #396
 * Fix bug where a daily job runs twice a day, see #406
+* Fix a bug where periodic jobs in the flex support mode weren't properly canceled while the job was running, see #407
 
 ## 1.2.4 (2018-02-08)
 * Add `scheduleAsync()` to the `DailyJob` class for scheduling daily jobs asynchronously to avoid IO operations on the main thread, see #371
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 3374e7c..8760ecc 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -82,9 +82,9 @@
     private WeakReference<Context> mContextReference;
     private Context mApplicationContext;
 
-    private boolean mCanceled;
-    private boolean mDeleted;
-    private long mFinishedTimeStamp = -1;
+    private volatile boolean mCanceled;
+    private volatile boolean mDeleted;
+    private volatile long mFinishedTimeStamp = -1;
 
     private Result mResult = Result.FAILURE;
 
@@ -292,31 +292,34 @@ public final void cancel() {
         cancel(false);
     }
 
-    /*package*/ final void cancel(boolean deleted) {
+    /*package*/ final synchronized boolean cancel(boolean deleted) {
         if (!isFinished()) {
             if (!mCanceled) {
                 mCanceled = true;
                 onCancel();
             }
-            mDeleted = deleted;
+            mDeleted |= deleted;
+            return true;
+        } else {
+            return false;
         }
     }
 
     /**
      * @return {@code true} if this {@link Job} was canceled.
      */
-    protected final boolean isCanceled() {
+    protected final synchronized boolean isCanceled() {
         return mCanceled;
     }
 
     /**
      * @return {@code true} if the {@link Job} finished.
      */
-    public final boolean isFinished() {
+    public final synchronized boolean isFinished() {
         return mFinishedTimeStamp > 0;
     }
 
-    /*package*/ final long getFinishedTimeStamp() {
+    /*package*/ final synchronized long getFinishedTimeStamp() {
         return mFinishedTimeStamp;
     }
 
@@ -324,7 +327,7 @@ public final boolean isFinished() {
         return mResult;
     }
 
-    /*package*/ final boolean isDeleted() {
+    /*package*/ final synchronized boolean isDeleted() {
         return mDeleted;
     }
 
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index 042ec59..9b12c22 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -406,9 +406,8 @@ private boolean cancelInner(@Nullable JobRequest request) {
     }
 
     private boolean cancelInner(@Nullable Job job) {
-        if (job != null && !job.isFinished() && !job.isCanceled()) {
+        if (job != null && job.cancel(true)) {
             CAT.i("Cancel running %s", job);
-            job.cancel(true);
             return true;
         } else {
             return false;
diff --git a/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
index f8bb0bd..76ba08c 100644
--- a/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
@@ -41,47 +41,89 @@ public Job create(@NonNull String tag) {
 
     @Test
     @Config(sdk = Build.VERSION_CODES.N)
-    public void verifyPeriodicFlexNotRescheduledN() throws Exception {
-        runJobAndCancelAllDuringExecution(true);
+    public void verifyPeriodicFlexNotRescheduledN() {
+        runJobAndCancelAllDuringExecution(true, false);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
     @Test
     @Config(sdk = Build.VERSION_CODES.N)
-    public void verifyPeriodicNotRescheduledN() throws Exception {
-        runJobAndCancelAllDuringExecution(false);
+    public void verifyPeriodicNotRescheduledN() {
+        runJobAndCancelAllDuringExecution(false, false);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyPeriodicFlexNotRescheduledNSwap() {
+        runJobAndCancelAllDuringExecution(true, true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyPeriodicNotRescheduledNSwao() {
+        runJobAndCancelAllDuringExecution(false, true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.M)
+    public void verifyPeriodicFlexNotRescheduledM() {
+        runJobAndCancelAllDuringExecution(true, false);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
     @Test
     @Config(sdk = Build.VERSION_CODES.M)
-    public void verifyPeriodicFlexNotRescheduledM() throws Exception {
-        runJobAndCancelAllDuringExecution(true);
+    public void verifyPeriodicNotRescheduledM() {
+        runJobAndCancelAllDuringExecution(false, false);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
     @Test
     @Config(sdk = Build.VERSION_CODES.M)
-    public void verifyPeriodicNotRescheduledM() throws Exception {
-        runJobAndCancelAllDuringExecution(false);
+    public void verifyPeriodicFlexNotRescheduledMSwap() {
+        runJobAndCancelAllDuringExecution(true, true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.M)
+    public void verifyPeriodicNotRescheduledMSwap() {
+        runJobAndCancelAllDuringExecution(false, true);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
     @Test
     @Config(sdk = Build.VERSION_CODES.KITKAT)
-    public void verifyPeriodicFlexNotRescheduledK() throws Exception {
-        runJobAndCancelAllDuringExecution(true);
+    public void verifyPeriodicFlexNotRescheduledK() {
+        runJobAndCancelAllDuringExecution(true, false);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
     @Test
     @Config(sdk = Build.VERSION_CODES.KITKAT)
-    public void verifyPeriodicNotRescheduledK() throws Exception {
-        runJobAndCancelAllDuringExecution(false);
+    public void verifyPeriodicNotRescheduledK() {
+        runJobAndCancelAllDuringExecution(false, false);
         assertThat(manager().getAllJobRequests()).isEmpty();
     }
 
-    private void runJobAndCancelAllDuringExecution(boolean flex) {
+    @Test
+    @Config(sdk = Build.VERSION_CODES.KITKAT)
+    public void verifyPeriodicFlexNotRescheduledKSwap() {
+        runJobAndCancelAllDuringExecution(true, true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.KITKAT)
+    public void verifyPeriodicNotRescheduledKSwap() {
+        runJobAndCancelAllDuringExecution(false, true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    private void runJobAndCancelAllDuringExecution(boolean flex, boolean swapCancelOrder) {
         try {
             final int jobId = new JobRequest.Builder("any")
                 .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(flex ? 5 : 15))
@@ -101,12 +143,18 @@ public void run() {
                 }
             }.start();
 
-            assertThat(mJob.mStartedLatch.await(3, TimeUnit.SECONDS)).isTrue();
+            assertThat(mJob.mStartedLatch.await(30, TimeUnit.SECONDS)).isTrue();
 
-            manager().cancelAll();
+            if (swapCancelOrder) {
+                manager().getJob(request.getJobId()).cancel(); // this might be called in onStopJob()
+                manager().cancelAll();
+            } else {
+                manager().cancelAll();
+                manager().getJob(request.getJobId()).cancel(); // this might be called in onStopJob()
+            }
 
             mJob.mBlockingLatch.countDown();
-            assertThat(waitFinishExecution.await(3, TimeUnit.SECONDS)).isTrue();
+            assertThat(waitFinishExecution.await(30, TimeUnit.SECONDS)).isTrue();
 
 
         } catch (InterruptedException e) {
