diff --git a/CHANGELOG.md b/CHANGELOG.md
index c3c586f..6c9d234 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,77 @@
+## 1.1.4 (2017-01-05)
+
+* Expose schedule time of a job
+
+## 1.1.3 (2016-11-09)
+
+* Add an alternative to register a `JobCreator`, if you don't have access to the `Application` class
+
+## 1.1.2 (2016-10-19)
+
+* Remove packaged `R.txt` file
+
+## 1.0.15 (2016-10-19)
+
+* Remove packaged `R.txt` file
+
+## 1.1.1 (2016-10-19)
+
+* Add test option to override minimum interval and flex for testing purposes
+* Fix issue that periodic jobs were accidentally canceled
+
+## 1.0.14 (2016-10-19)
+
+* Fix issue that periodic jobs were accidentally canceled
+
+## 1.1.0 (2016-09-23)
+
+* Bump SDK version to 24
+* Add option to specify flex parameter for periodic jobs
+ * Add support for flex parameter with GCM proxy
+ * Add API 24 proxy with support for flex parameter
+ * Add a flex support mode for all other APIs
+* Add API 19 proxy supporting an execution window
+* Add NOT_ROAMING network type
+* Adjust minimum interval for periodic jobs
+* Add GCM service declaration in library manifest
+
+## 1.0.13 (2016-09-12)
+
+* Fix crash while acquiring wake lock
+* Check boot permission only when persisted flag is set to true
+
+## 1.0.12 (2016-08-29)
+
+* Fix IllegalArgumentException with GCM API, see #72
+
+## 1.0.11 (2016-08-09)
+
+* Fix overflow for too large execution windows
+* Fix immediately starting jobs with JobScheduler if the execution window is too large
+
+## 1.0.10 (2016-07-25)
+
+* Create the JobManager in all API services
+
+## 1.0.9 (2016-07-18)
+
+* Bug fixes
+
+## 1.0.8 (2016-07-05)
+
+* Make PlatformAlarmReceiver intent explicit, fixes #56
+* Delete a job after it has finished, otherwise reschedule if app is crashing while job is running, fixes #55
+* Extend Params class with more parameters from the job request, fixes #52
+* Cache only 20 finished jobs to free up memory, fixes #57
+
+## 1.0.7 (2016-06-03)
+
+* Weird bug fixes
+
+## 1.0.6 (2016-05-20)
+
+* Clean up orphaned jobs after the database was deleted
+
 ## 1.0.5 (2016-05-03)
 
 * Fix "WakeLock under-locked" crash
@@ -16,8 +90,8 @@
 
 ## 1.0.1 (2015-12-18)
 
-* Catch curtain exceptions and runtime crashes
+* Catch certain exceptions and runtime crashes
 
 ## 1.0.0 (2015-08-20)
 
-* Initial release
\ No newline at end of file
+* Initial release
diff --git a/FAQ.md b/FAQ.md
new file mode 100644
index 0000000..e04e6f4
--- /dev/null
+++ b/FAQ.md
@@ -0,0 +1,218 @@
+### Can I run a job immediately?
+
+No, it's recommended to extract the logic from your job instead and to reuse it in a background thread.
+
+```java
+public class DemoSyncJob extends Job {
+
+    public static final String TAG = "job_demo_tag";
+
+    @Override
+    @NonNull
+    protected Result onRunJob(final Params params) {
+        boolean success = new DemoSyncEngine().sync();
+        return success ? Result.SUCCESS : Result.FAILURE;
+    }
+}
+
+public class DemoSyncEngine {
+
+    @WorkerThread
+    public boolean sync() {
+        // do something fancy
+        return true;
+    }
+}
+
+public class SyncHistoryActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_sync_history);
+
+        syncAsynchronously();
+    }
+
+    private void syncAsynchronously() {
+        new AsyncTask<Void, Void, Boolean>() {
+            @Override
+            protected Boolean doInBackground(Void... params) {
+                return new DemoSyncEngine().sync();
+            }
+
+            @Override
+            protected void onPostExecute(Boolean aBoolean) {
+                refreshView();
+            }
+        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+    }
+}
+```
+
+### How can I run a job at a specific time once a day?
+
+See this sample, which schedules a job between 1 AM and 6 AM each day. Note that this sample isn't using a periodic job, because the periodic jobs don't support a flex parameter (yet).
+
+```java
+public class JobSample extends Job {
+
+    public static final String TAG = "JobSample";
+
+    public static void schedule() {
+        schedule(true);
+    }
+
+    private static void schedule(boolean updateCurrent) {
+        Calendar calendar = Calendar.getInstance();
+        int hour = calendar.get(Calendar.HOUR_OF_DAY);
+        int minute = calendar.get(Calendar.MINUTE);
+
+        // 1 AM - 6 AM, ignore seconds
+        long startMs = TimeUnit.MINUTES.toMillis(60 - minute)
+                + TimeUnit.HOURS.toMillis((24 - hour) % 24);
+        long endMs = startMs + TimeUnit.HOURS.toMillis(5);
+
+        new JobRequest.Builder(TAG)
+                .setExecutionWindow(startMs, endMs)
+                .setPersisted(true)
+                .setUpdateCurrent(updateCurrent)
+                .build()
+                .schedule();
+    }
+
+    @NonNull
+    @Override
+    protected Result onRunJob(Params params) {
+        try {
+            // do something
+            return Result.SUCCESS;
+        } finally {
+            schedule(false); // don't update current, it would cancel this currently running job
+        }
+    }
+}
+```
+
+### Do NOT use `Long.MAX_VALUE` as argument!
+
+Don't use `Long.MAX_VALUE` as argument for the execution window. The `AlarmManager` doesn't allow setting a start date, instead the execution time is the arithmetic average between start and end date.
+
+Your job might work as expected on Android 5+, but maybe won't run at all on older devices.
+
+```java
+// bad, execution time on Android 4.X = startMs + (endMs - startMs) / 2
+new JobRequest.Builder(TAG)
+        .setExecutionWindow(3_000L, Long.MAX_VALUE)
+        .build()
+        .schedule();
+
+// better, execution time on Android 4.X is 2 days
+new JobRequest.Builder(TAG)
+        .setExecutionWindow(TimeUnit.DAYS.toMillis(1), TimeUnit.DAYS.toMillis(3))
+        .build()
+        .schedule();
+```
+
+### Why can't an interval be smaller than 15 minutes for periodic jobs?
+
+This library is a subset of 3 different APIs. Since Android Nougat the minimum interval of periodic jobs is 15 minutes. Although pre Nougat devices support smaller intervals, the least common was chosen as minimum for this library so that periodic jobs run with the same frequency on all devices.
+
+The `JobScheduler` with Android Nougat allows setting a smaller interval, but the value is silently adjusted and a warning is being logged. This library throws an exception instead, so that misbehaving jobs are caught early. You can read more about it [here](https://developer.android.com/reference/android/app/job/JobInfo.html#getMinPeriodMillis()).
+
+### How can I run async operations in a job?
+
+This library automatically creates a wake lock for you so that the system stays on until your job finished. When your job returns a result, then this wakelock is being released and async operations may not finish. The easiest solution is to not return a result until the async operation finished. Don't forget that your job is already executed on a background thread!
+
+```java
+public class AsyncJob extends Job {
+
+    @NonNull
+    @Override
+    protected Result onRunJob(Params params) {
+        final CountDownLatch countDownLatch = new CountDownLatch(1);
+
+        new Thread() {
+            @Override
+            public void run() {
+                // do async operation here
+
+                SystemClock.sleep(3_000L);
+                countDownLatch.countDown();
+            }
+        }.start();
+
+        try {
+            countDownLatch.await();
+        } catch (InterruptedException ignored) {
+        }
+
+        return Result.SUCCESS;
+    }
+}
+```
+
+### How can I remove the GCM dependency from my app?
+
+You need to be careful, if you remove this dependency after it has been already used for a while.
+
+```groovy
+dependencies {
+    compile 'com.google.android.gms:play-services-gcm:9.8.0'
+}
+```
+
+The reason is that jobs probably were scheduled with the GCM API on Android 4.X and after removing the dependency, the Play Services still look for the platform service, but can't find the class anymore. The result is that your app will crash with a runtime exception similar like this:
+
+```
+java.lang.RuntimeException: Unable to instantiate service com.evernote.android.job.gcm.PlatformGcmService: java.lang.ClassNotFoundException: Didn't find class "com.evernote.android.job.gcm.PlatformGcmService" on path: DexPathList[[zip file "/data/app/com.evernote.android.job.demo-2/base.apk"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]
+```
+
+Fortunately, there is a workaround to prevent the crash. You need to remove the GCM service declaration from the manifest like this and then the Play Services won't try to instantiate the missing class.
+
+```xml
+<application
+    ...>
+
+    <service
+        android:name="com.evernote.android.job.gcm.PlatformGcmService"
+        tools:node="remove"/>
+
+</application>
+```
+
+### Why does my job run while the device is offline, although I've requested a network connection?
+
+That's expected. The job should run once during a period or within the specified execution window. The timing is a higher requirement than the network type, which is more like a hint when it's best to run your job. To make sure that all requirements are met, you can call `.setRequirementsEnforced(true)`. This will make sure that your job won't run, if one check fails, e.g.
+
+```java
+new JobRequest.Builder(DemoSyncJob.TAG)
+        .setExecutionWindow(60_000L, 90_000L)
+        .setRequiresCharging(true)
+        .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)
+        .setRequirementsEnforced(true)
+        .build()
+        .schedule();
+```
+
+### I cannot override the Application class. How can I add my `JobCreator`?
+
+There is an alternative. You can register a `BroadcastReceiver` to get notified about that you should add your `JobCreator`, e.g.
+
+```xml
+<receiver
+    android:name=".AddReceiver"
+    android:exported="false">
+        <intent-filter>
+            <action android:name="com.evernote.android.job.ADD_JOB_CREATOR"/>
+        </intent-filter>
+</receiver>
+```
+```java
+public final class AddReceiver extends AddJobCreatorReceiver {
+    @Override
+    protected void addJobCreator(@NonNull Context context, @NonNull JobManager manager) {
+        manager.addJobCreator(new DemoJobCreator());
+    }
+}
+```
\ No newline at end of file
diff --git a/README.md b/README.md
index d3806a9..e3a8b06 100644
--- a/README.md
+++ b/README.md
@@ -1,29 +1,26 @@
-Android-Job
-============
+# Android-Job
 
-An utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post][1] why you should prefer this library than each separate API.
+An utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post](https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/) or in [these slides](https://speakerdeck.com/vrallev/scheduling-background-job-on-android-at-the-right-time) why you should prefer this library than each separate API. All features from Android Nougat are backward compatible.
 
-Download
---------
+## Download
 
-Download [the latest version][2] or grab via Gradle:
+Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evernote"%20AND%20a:"android-job") or grab via Gradle:
 
 ```groovy
 dependencies {
-    compile 'com.evernote:android-job:1.0.5'
+    compile 'com.evernote:android-job:1.1.4'
 }
 ```
 
-If you didn't turn off the manifest merger from the Gradle build tools, then no further step is required to setup the library. Otherwise you manually need to add the permissions and services like in this [AndroidManifest][3].
+If you didn't turn off the manifest merger from the Gradle build tools, then no further step is required to setup the library. Otherwise you manually need to add the permissions and services like in this [AndroidManifest](library/src/main/AndroidManifest.xml).
 
-You can read the [JavaDoc here][4].
+You can read the [JavaDoc here](https://evernote.github.io/android-job/javadoc/).
 
-Usage
------
+## Usage
 
 The class `JobManager` serves as entry point. Your jobs need to extend the class `Job`. Create a `JobRequest` with the corresponding builder class and schedule this request with the `JobManager`.
 
-Before you can use the `JobManager` you must initialize the singleton. You need to provide a `Context` and add a `JobCreator` implementation after that. The `JobCreator` maps a job tag to a specific job class. It's recommend to initialize the `JobManager` in the `onCreate()` method of your `Application` object.
+Before you can use the `JobManager` you must initialize the singleton. You need to provide a `Context` and add a `JobCreator` implementation after that. The `JobCreator` maps a job tag to a specific job class. It's recommend to initialize the `JobManager` in the `onCreate()` method of your `Application` object, but there is [an alternative](FAQ.md#i-cannot-override-the-application-class-how-can-i-add-my-jobcreator), if you don't have access to the `Application` class.
 
 ```java
 public class App extends Application {
@@ -42,8 +39,8 @@ public class DemoJobCreator implements JobCreator {
     @Override
     public Job create(String tag) {
         switch (tag) {
-            case DemoJob.TAG:
-                return new DemoJob();
+            case DemoSyncJob.TAG:
+                return new DemoSyncJob();
             default:
                 return null;
         }
@@ -54,28 +51,27 @@ public class DemoJobCreator implements JobCreator {
 After that you can start scheduling jobs.
 
 ```java
-public class DemoJob extends Job {
+public class DemoSyncJob extends Job {
 
     public static final String TAG = "job_demo_tag";
 
     @Override
     @NonNull
     protected Result onRunJob(Params params) {
-        // run your job
+        // run your job here
         return Result.SUCCESS;
     }
-}
 
-private void scheduleJob() {
-    new JobRequest.Builder(DemoJob.TAG)
-            .setExecutionWindow(30_000L, 40_000L)
-            .build()
-            .schedule();
+    public static void scheduleJob() {
+        new JobRequest.Builder(DemoSyncJob.TAG)
+                .setExecutionWindow(30_000L, 40_000L)
+                .build()
+                .schedule();
+    }
 }
 ```
 
-Advanced
---------
+## Advanced
 
 The `JobRequest.Builder` class has many extra options, e.g. you can specify a required network connection, make the job periodic, pass some extras with a bundle, restore the job after a reboot or run the job at an exact time.
 
@@ -86,7 +82,7 @@ private void scheduleAdvancedJob() {
     PersistableBundleCompat extras = new PersistableBundleCompat();
     extras.putString("key", "Hello world");
 
-    int jobId = new JobRequest.Builder(DemoJob.TAG)
+    int jobId = new JobRequest.Builder(DemoSyncJob.TAG)
             .setExecutionWindow(30_000L, 40_000L)
             .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
             .setRequiresCharging(true)
@@ -101,15 +97,15 @@ private void scheduleAdvancedJob() {
 }
 
 private void schedulePeriodicJob() {
-    int jobId = new JobRequest.Builder(DemoJob.TAG)
-            .setPeriodic(60_000L)
+    int jobId = new JobRequest.Builder(DemoSyncJob.TAG)
+            .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5))
             .setPersisted(true)
             .build()
             .schedule();
 }
 
 private void scheduleExactJob() {
-    int jobId = new JobRequest.Builder(DemoJob.class)
+    int jobId = new JobRequest.Builder(DemoSyncJob.class)
             .setExact(20_000L)
             .setPersisted(true)
             .build()
@@ -117,7 +113,7 @@ private void scheduleExactJob() {
 }
 
 private void cancelJob(int jobId) {
-    JobManger.instance().cancel(jobId);
+    JobManager.instance().cancel(jobId);
 }
 ```
 
@@ -158,35 +154,17 @@ And then referring to it in your application tag in `AndroidManifest.xml`:
 <application ...  android:fullBackupContent="@xml/backup_config">
 ```
 
-#### Using the GcmNetworkManager
-
-By default the API for the `GcmNetworkManager` is disabled. In order to use it for pre Lollipop devices you must add the GCM dependency in your `build.gradle` and then add the service in your `AndroidManifest.xml` manually.
-
-```groovy
-dependencies {
-    compile 'com.google.android.gms:play-services-gcm:8.4.0' // or newer
-}
-```
+#### Proguard
 
-```xml
-<service
-    android:name="com.evernote.android.job.gcm.PlatformGcmService"
-    android:exported="true"
-    android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE">
-    <intent-filter>
-        <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
-    </intent-filter>
-</service>
-```
+The library doesn't use reflection, but it relies on two `Service`s and two `BroadcastReceiver`s. In order to avoid any issues, you shouldn't obfuscate those four classes. The library bundles its own Proguard config and you don't need to do anything, but just in case you can add [these rules](library/proguard.txt) in your configuration.
 
-#### Proguard
+## FAQ
 
-The library doesn't use reflection, but it relies on two `Service`s and two `BroadcastReceiver`s. In order to avoid any issues, you shouldn't obfuscate those four classes. The library bundles its own Proguard config and you don't need to do anything, but just in case you can add [these rules][5] in your configuration.  
+See [here](FAQ.md).
 
-License
--------
+## License
 
-    Copyright (c) 2007-2015 by Evernote Corporation, All rights reserved.
+    Copyright (c) 2007-2016 by Evernote Corporation, All rights reserved.
 
     Use of the source code and binary libraries included in this package
     is permitted under the following terms:
@@ -211,9 +189,3 @@ License
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-[1]: https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/
-[2]: http://search.maven.org/#search|gav|1|g:"com.evernote"%20AND%20a:"android-job"
-[3]: https://github.com/evernote/android-job/blob/master/library/src/main/AndroidManifest.xml
-[4]: http://evernote.github.io/android-job/javadoc/
-[5]: https://github.com/evernote/android-job/blob/master/library/proguard.txt
\ No newline at end of file
diff --git a/build-config/gradle-quality.gradle b/build-config/gradle-quality.gradle
index aeef632..55c61e1 100644
--- a/build-config/gradle-quality.gradle
+++ b/build-config/gradle-quality.gradle
@@ -2,7 +2,7 @@ apply plugin: 'checkstyle'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
 
-check.dependsOn 'checkstyle', 'findbugs', 'pmd'
+check.dependsOn 'checkstyle', 'pmd' //,'findbugs'
 
 task checkstyle(type: Checkstyle) {
     configFile file("${project.rootDir}/build-config/checkstyle/checkstyle.xml")
diff --git a/build.gradle b/build.gradle
index c565d9e..7771efc 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,8 +3,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
-        classpath 'com.github.ben-manes:gradle-versions-plugin:0.12.0'
+        classpath 'com.android.tools.build:gradle:2.2.3'
+        classpath 'com.github.ben-manes:gradle-versions-plugin:0.13.0'
     }
 }
 
@@ -15,13 +15,17 @@ allprojects {
 }
 
 ext {
-    compileSdkVersion = 23
+    compileSdkVersion = 25
     targetSdkVersion = compileSdkVersion
     minSdkVersion = 14
 
-    buildToolsVersion = "23.0.3"
+    buildToolsVersion = '25.0.2'
 
-    supportLibVersion = '23.3.0'
-    playServicesVersion = '8.4.0'
+    supportLibVersion = '25.0.0'
+    playServicesVersion = '9.8.0'
+    stethoVersion = '1.4.1'
 }
 
+task wrapper(type: Wrapper) {
+    gradleVersion = '3.3'
+}
diff --git a/demo/build.gradle b/demo/build.gradle
index c541821..5fe3602 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -50,5 +50,7 @@ dependencies {
     compile project(':library')
     compile "com.android.support:appcompat-v7:$rootProject.ext.supportLibVersion"
 
+    compile "com.facebook.stetho:stetho:$rootProject.ext.stethoVersion"
+
     gcmCompile "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
 }
diff --git a/demo/lint.xml b/demo/lint.xml
new file mode 100644
index 0000000..5858c1c
--- /dev/null
+++ b/demo/lint.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="GoogleAppIndexingWarning">
+        <ignore path="src/main/AndroidManifest.xml"/>
+        <ignore path="src/gcm/AndroidManifest.xml"/>
+    </issue>
+    <issue id="GradleDependency" severity="ignore"/>
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+</lint>
\ No newline at end of file
diff --git a/demo/proguard.cfg b/demo/proguard.cfg
index 8e77146..eb5eb50 100644
--- a/demo/proguard.cfg
+++ b/demo/proguard.cfg
@@ -1 +1,2 @@
--optimizationpasses 1
\ No newline at end of file
+-optimizationpasses 1
+-repackageclasses
\ No newline at end of file
diff --git a/demo/src/gcm/AndroidManifest.xml b/demo/src/gcm/AndroidManifest.xml
deleted file mode 100644
index 8cdd7ff..0000000
--- a/demo/src/gcm/AndroidManifest.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<manifest
-    package="com.evernote.android.job.demo"
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools">
-
-    <application
-        android:name=".App"
-        android:allowBackup="false"
-        android:fullBackupContent="false"
-        android:icon="@mipmap/ic_launcher"
-        android:label="@string/demo"
-        android:theme="@style/AppTheme"
-        tools:ignore="UnusedAttribute">
-
-        <service
-            android:name="com.evernote.android.job.gcm.PlatformGcmService"
-            android:exported="true"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
-            </intent-filter>
-        </service>
-
-    </application>
-</manifest>
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 765f342..7fe1c3c 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -24,8 +24,16 @@
         </activity>
 
         <activity
-            android:name=".FileActivity"
+            android:name=".SyncHistoryActivity"
             android:label="@string/demo"/>
 
+        <receiver
+            android:name=".DemoJobCreator$AddReceiver"
+            android:exported="false">
+            <intent-filter>
+                <action android:name="com.evernote.android.job.ADD_JOB_CREATOR"/>
+            </intent-filter>
+        </receiver>
+
     </application>
 </manifest>
diff --git a/demo/src/main/java/com/evernote/android/job/demo/App.java b/demo/src/main/java/com/evernote/android/job/demo/App.java
index aa42908..5a730f6 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/App.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/App.java
@@ -3,6 +3,7 @@
 import android.app.Application;
 
 import com.evernote.android.job.JobManager;
+import com.facebook.stetho.Stetho;
 
 /**
  * @author rwondratschek
@@ -12,6 +13,8 @@
     @Override
     public void onCreate() {
         super.onCreate();
+        Stetho.initializeWithDefaults(this);
+
         JobManager.create(this).addJobCreator(new DemoJobCreator());
     }
 }
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoJob.java b/demo/src/main/java/com/evernote/android/job/demo/DemoJob.java
deleted file mode 100644
index cca572e..0000000
--- a/demo/src/main/java/com/evernote/android/job/demo/DemoJob.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package com.evernote.android.job.demo;
-
-import android.content.Context;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.SystemClock;
-import android.support.annotation.NonNull;
-import android.widget.Toast;
-
-import com.evernote.android.job.Job;
-
-import net.vrallev.android.cat.Cat;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.concurrent.CountDownLatch;
-
-/**
- * @author rwondratschek
- */
-public class DemoJob extends Job {
-
-    public static final String TAG = "job_demo_tag";
-
-    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault());
-
-    public static File getTestFile(Context context) {
-        return new File(context.getCacheDir(), "TestFile.txt");
-    }
-
-    @Override
-    @NonNull
-    protected Result onRunJob(final Params params) {
-        SystemClock.sleep(3000);
-
-        if (!isCanceled()) {
-            writeIntoFile();
-        }
-
-        final CountDownLatch latch = new CountDownLatch(1);
-        new Handler(Looper.getMainLooper()).post(new Runnable() {
-            @Override
-            public void run() {
-                StringBuilder message = new StringBuilder()
-                        .append(isCanceled() ? "Canceled" : "Success")
-                        .append(' ')
-                        .append(params.getId())
-                        .append(' ')
-                        .append(params.getExtras().getString("key", "NOT_FOUND"))
-                        .append(" failed ")
-                        .append(params.getFailureCount());
-
-                Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();
-                latch.countDown();
-            }
-        });
-
-        try {
-            latch.await();
-        } catch (InterruptedException e) {
-            Cat.e(e);
-        }
-
-        if (isCanceled()) {
-            return params.isPeriodic() ? Result.FAILURE : Result.RESCHEDULE;
-        } else {
-            return Result.SUCCESS;
-        }
-    }
-
-    private void writeIntoFile() {
-        String text = DATE_FORMAT.format(new Date()) + "\t\t" + getParams().getId() + "\t\t";
-        text += (hasInternetAccess() ? "has internet" : "no internet");
-        text += '\n';
-
-        try {
-            FileUtils.writeFile(getTestFile(getContext()), text, true);
-
-        } catch (IOException e) {
-            Cat.e(e);
-        }
-    }
-
-    private boolean hasInternetAccess() {
-        InputStream inputStream = null;
-        try {
-            inputStream = new URL("https://evernote.com/").openConnection().getInputStream();
-
-            byte[] buffer = new byte[128];
-            return inputStream.read(buffer) > 0;
-
-        } catch (IOException e) {
-            return false;
-
-        } finally {
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (IOException ignored) {
-                }
-            }
-        }
-    }
-}
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java b/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
index 1a62b8f..9a07f75 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
@@ -1,7 +1,11 @@
 package com.evernote.android.job.demo;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
+
 import com.evernote.android.job.Job;
 import com.evernote.android.job.JobCreator;
+import com.evernote.android.job.JobManager;
 
 /**
  * @author rwondratschek
@@ -11,10 +15,17 @@
     @Override
     public Job create(String tag) {
         switch (tag) {
-            case DemoJob.TAG:
-                return new DemoJob();
+            case DemoSyncJob.TAG:
+                return new DemoSyncJob();
             default:
                 return null;
         }
     }
+
+    public static final class AddReceiver extends AddJobCreatorReceiver {
+        @Override
+        protected void addJobCreator(@NonNull Context context, @NonNull JobManager manager) {
+            // manager.addJobCreator(new DemoJobCreator());
+        }
+    }
 }
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoSyncEngine.java b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncEngine.java
new file mode 100644
index 0000000..8ff1cfd
--- /dev/null
+++ b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncEngine.java
@@ -0,0 +1,70 @@
+package com.evernote.android.job.demo;
+
+import android.content.Context;
+import android.os.Looper;
+import android.os.NetworkOnMainThreadException;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
+
+import net.vrallev.android.cat.Cat;
+
+import java.io.File;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * @author rwondratschek
+ */
+public class DemoSyncEngine {
+
+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault());
+
+    private final Context mContext;
+
+    public DemoSyncEngine(Context context) {
+        mContext = context;
+    }
+
+    @WorkerThread
+    public boolean sync() {
+        // do something fancy
+
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            throw new NetworkOnMainThreadException();
+        }
+
+        SystemClock.sleep(1_000);
+        boolean success = Math.random() > 0.1; // successful 90% of the time
+        saveSuccess(success);
+        return success;
+    }
+
+    @NonNull
+    public String getSuccessHistory() {
+        try {
+            byte[] data = FileUtils.readFile(getSuccessFile());
+            if (data == null || data.length == 0) {
+                return "";
+            }
+            return new String(data);
+        } catch (IOException e) {
+            return "";
+        }
+    }
+
+    private void saveSuccess(boolean success) {
+        String text = DATE_FORMAT.format(new Date()) + "\t\t" + success + '\n';
+        try {
+            FileUtils.writeFile(getSuccessFile(), text, true);
+        } catch (IOException e) {
+            Cat.e(e);
+        }
+    }
+
+    private File getSuccessFile() {
+        return new File(mContext.getCacheDir(), "success.txt");
+    }
+}
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java
new file mode 100644
index 0000000..1fad8ef
--- /dev/null
+++ b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java
@@ -0,0 +1,46 @@
+package com.evernote.android.job.demo;
+
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.content.Intent;
+import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.v4.app.NotificationManagerCompat;
+import android.support.v7.app.NotificationCompat;
+
+import com.evernote.android.job.Job;
+
+import java.util.Random;
+
+/**
+ * @author rwondratschek
+ */
+public class DemoSyncJob extends Job {
+
+    public static final String TAG = "job_demo_tag";
+
+    @Override
+    @NonNull
+    protected Result onRunJob(final Params params) {
+        boolean success = new DemoSyncEngine(getContext()).sync();
+
+        if (params.isPeriodic()) {
+            PendingIntent pendingIntent = PendingIntent.getActivity(getContext(), 0, new Intent(getContext(), MainActivity.class), 0);
+
+            Notification notification = new NotificationCompat.Builder(getContext())
+                    .setContentTitle("Job Demo")
+                    .setContentText("Periodic job ran")
+                    .setAutoCancel(true)
+                    .setContentIntent(pendingIntent)
+                    .setSmallIcon(R.drawable.ic_notification)
+                    .setShowWhen(true)
+                    .setColor(Color.GREEN)
+                    .setLocalOnly(true)
+                    .build();
+
+            NotificationManagerCompat.from(getContext()).notify(new Random().nextInt(), notification);
+        }
+
+        return success ? Result.SUCCESS : Result.FAILURE;
+    }
+}
diff --git a/demo/src/main/java/com/evernote/android/job/demo/FileActivity.java b/demo/src/main/java/com/evernote/android/job/demo/FileActivity.java
deleted file mode 100644
index ae8c7ee..0000000
--- a/demo/src/main/java/com/evernote/android/job/demo/FileActivity.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.evernote.android.job.demo;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.widget.TextView;
-
-import net.vrallev.android.cat.Cat;
-
-import java.io.File;
-import java.io.IOException;
-
-/**
- * @author rwondratschek
- */
-public class FileActivity extends Activity {
-
-    private TextView mTextView;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_file);
-
-        mTextView = (TextView) findViewById(R.id.textView_log);
-        refreshView();
-    }
-
-    private void refreshView() {
-        File file = DemoJob.getTestFile(this);
-        if (!file.exists()) {
-            return;
-        }
-
-        try {
-            byte[] content = FileUtils.readFile(file);
-            if (content != null) {
-                mTextView.setText(new String(content, "UTF-8"));
-            }
-
-        } catch (IOException e) {
-            Cat.e(e);
-        }
-    }
-}
diff --git a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
index e1179ba..9ac2eec 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
@@ -27,6 +27,7 @@
 
     private int mLastJobId;
 
+    private CompoundButton mEnableGcm;
     private CompoundButton mRequiresCharging;
     private CompoundButton mRequiresDeviceIdle;
     private Spinner mNetworkTypeSpinner;
@@ -44,6 +45,7 @@ protected void onCreate(Bundle savedInstanceState) {
             mLastJobId = savedInstanceState.getInt(LAST_JOB_ID, 0);
         }
 
+        mEnableGcm = (CompoundButton) findViewById(R.id.enable_gcm);
         mRequiresCharging = (CompoundButton) findViewById(R.id.check_requires_charging);
         mRequiresDeviceIdle = (CompoundButton) findViewById(R.id.check_requires_device_idle);
         mNetworkTypeSpinner = (Spinner) findViewById(R.id.spinner_network_type);
@@ -51,6 +53,15 @@ protected void onCreate(Bundle savedInstanceState) {
         ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, getNetworkTypesAsString());
         adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
         mNetworkTypeSpinner.setAdapter(adapter);
+
+        mEnableGcm.setChecked(mJobManager.getConfig().isGcmApiEnabled());
+        mEnableGcm.setEnabled(JobApi.GCM.isSupported(this));
+        mEnableGcm.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                mJobManager.getConfig().setGcmApiEnabled(isChecked);
+            }
+        });
     }
 
     @Override
@@ -69,16 +80,26 @@ public boolean onCreateOptionsMenu(Menu menu) {
     public boolean onPrepareOptionsMenu(Menu menu) {
         super.onPrepareOptionsMenu(menu);
 
-        if (JobApi.V_14.isSupported(this)) {
-            menu.findItem(R.id.action_force_14).setChecked(false);
+        if (JobApi.V_24.isSupported(this)) {
+            menu.findItem(R.id.action_force_24).setChecked(false);
         } else {
-            menu.findItem(R.id.action_force_14).setVisible(false);
+            menu.findItem(R.id.action_force_24).setVisible(false);
         }
         if (JobApi.V_21.isSupported(this)) {
             menu.findItem(R.id.action_force_21).setChecked(false);
         } else {
             menu.findItem(R.id.action_force_21).setVisible(false);
         }
+        if (JobApi.V_19.isSupported(this)) {
+            menu.findItem(R.id.action_force_19).setChecked(false);
+        } else {
+            menu.findItem(R.id.action_force_19).setVisible(false);
+        }
+        if (JobApi.V_14.isSupported(this)) {
+            menu.findItem(R.id.action_force_14).setChecked(false);
+        } else {
+            menu.findItem(R.id.action_force_14).setVisible(false);
+        }
         if (JobApi.GCM.isSupported(this)) {
             menu.findItem(R.id.action_force_gcm).setChecked(false);
         } else {
@@ -86,9 +107,15 @@ public boolean onPrepareOptionsMenu(Menu menu) {
         }
 
         switch (mJobManager.getApi()) {
+            case V_24:
+                menu.findItem(R.id.action_force_24).setChecked(true);
+                break;
             case V_21:
                 menu.findItem(R.id.action_force_21).setChecked(true);
                 break;
+            case V_19:
+                menu.findItem(R.id.action_force_19).setChecked(true);
+                break;
             case V_14:
                 menu.findItem(R.id.action_force_14).setChecked(true);
                 break;
@@ -105,9 +132,15 @@ public boolean onPrepareOptionsMenu(Menu menu) {
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
+            case R.id.action_force_24:
+                mJobManager.forceApi(JobApi.V_24);
+                return true;
             case R.id.action_force_21:
                 mJobManager.forceApi(JobApi.V_21);
                 return true;
+            case R.id.action_force_19:
+                mJobManager.forceApi(JobApi.V_19);
+                return true;
             case R.id.action_force_14:
                 mJobManager.forceApi(JobApi.V_14);
                 return true;
@@ -147,8 +180,8 @@ public void onClick(View view) {
                 }
                 break;
 
-            case R.id.button_file_activity:
-                startActivity(new Intent(this, FileActivity.class));
+            case R.id.button_sync_history:
+                startActivity(new Intent(this, SyncHistoryActivity.class));
                 break;
         }
     }
@@ -157,7 +190,7 @@ private void testSimple() {
         PersistableBundleCompat extras = new PersistableBundleCompat();
         extras.putString("key", "Hello world");
 
-        mLastJobId = new JobRequest.Builder(DemoJob.TAG)
+        mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
                 .setExecutionWindow(3_000L, 4_000L)
                 .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.LINEAR)
                 .setRequiresCharging(mRequiresCharging.isChecked())
@@ -186,8 +219,8 @@ private void testAllImpl() {
     }
 
     private void testPeriodic() {
-        mLastJobId = new JobRequest.Builder(DemoJob.TAG)
-                .setPeriodic(60_000L)
+        mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
+                .setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX)
                 .setRequiresCharging(mRequiresCharging.isChecked())
                 .setRequiresDeviceIdle(mRequiresDeviceIdle.isChecked())
                 .setRequiredNetworkType(JobRequest.NetworkType.values()[mNetworkTypeSpinner.getSelectedItemPosition()])
@@ -200,7 +233,7 @@ private void testExact() {
         PersistableBundleCompat extras = new PersistableBundleCompat();
         extras.putString("key", "Hello world");
 
-        mLastJobId = new JobRequest.Builder(DemoJob.TAG)
+        mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
                 .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
                 .setExtras(extras)
                 .setExact(20_000L)
diff --git a/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java b/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java
new file mode 100644
index 0000000..ab24129
--- /dev/null
+++ b/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java
@@ -0,0 +1,62 @@
+package com.evernote.android.job.demo;
+
+import android.app.Activity;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.TextView;
+
+/**
+ * @author rwondratschek
+ */
+public class SyncHistoryActivity extends Activity {
+
+    private TextView mTextView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_sync_history);
+
+        mTextView = (TextView) findViewById(R.id.textView_log);
+        refreshView();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        super.onCreateOptionsMenu(menu);
+        getMenuInflater().inflate(R.menu.activity_sync_history, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.action_sync_now:
+                syncAsynchronously();
+                return true;
+
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    private void syncAsynchronously() {
+        new AsyncTask<Void, Void, Boolean>() {
+            @Override
+            protected Boolean doInBackground(Void... params) {
+                return new DemoSyncEngine(SyncHistoryActivity.this).sync();
+            }
+
+            @Override
+            protected void onPostExecute(Boolean aBoolean) {
+                refreshView();
+            }
+        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+    }
+
+    private void refreshView() {
+        mTextView.setText(new DemoSyncEngine(this).getSuccessHistory());
+    }
+}
diff --git a/demo/src/main/res/drawable-hdpi/ic_notification.png b/demo/src/main/res/drawable-hdpi/ic_notification.png
new file mode 100644
index 0000000..3cf3dbc
Binary files /dev/null and b/demo/src/main/res/drawable-hdpi/ic_notification.png differ
diff --git a/demo/src/main/res/drawable-mdpi/ic_notification.png b/demo/src/main/res/drawable-mdpi/ic_notification.png
new file mode 100644
index 0000000..53172b2
Binary files /dev/null and b/demo/src/main/res/drawable-mdpi/ic_notification.png differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_notification.png b/demo/src/main/res/drawable-xhdpi/ic_notification.png
new file mode 100644
index 0000000..7bb2fd0
Binary files /dev/null and b/demo/src/main/res/drawable-xhdpi/ic_notification.png differ
diff --git a/demo/src/main/res/drawable-xxhdpi/ic_notification.png b/demo/src/main/res/drawable-xxhdpi/ic_notification.png
new file mode 100644
index 0000000..8aa1c3a
Binary files /dev/null and b/demo/src/main/res/drawable-xxhdpi/ic_notification.png differ
diff --git a/demo/src/main/res/layout/activity_main.xml b/demo/src/main/res/layout/activity_main.xml
index a2ea6ba..4aa67cb 100644
--- a/demo/src/main/res/layout/activity_main.xml
+++ b/demo/src/main/res/layout/activity_main.xml
@@ -65,6 +65,14 @@
             android:onClick="onClick"
             android:text="Cancel all"/>
 
+        <Switch
+            android:id="@+id/enable_gcm"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="12dp"
+            android:text="Enable GCM API"/>
+
         <Switch
             android:id="@+id/check_requires_charging"
             android:layout_width="wrap_content"
@@ -89,12 +97,12 @@
             android:layout_height="wrap_content" />
 
         <Button
-            android:id="@+id/button_file_activity"
+            android:id="@+id/button_sync_history"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:layout_gravity="center_horizontal"
             android:layout_marginTop="12dp"
             android:onClick="onClick"
-            android:text="Open file activity"/>
+            android:text="Open sync history"/>
     </LinearLayout>
 </ScrollView>
\ No newline at end of file
diff --git a/demo/src/main/res/layout/activity_file.xml b/demo/src/main/res/layout/activity_sync_history.xml
similarity index 100%
rename from demo/src/main/res/layout/activity_file.xml
rename to demo/src/main/res/layout/activity_sync_history.xml
diff --git a/demo/src/main/res/menu/activity_main.xml b/demo/src/main/res/menu/activity_main.xml
index 8e81905..0dcfb3e 100644
--- a/demo/src/main/res/menu/activity_main.xml
+++ b/demo/src/main/res/menu/activity_main.xml
@@ -5,10 +5,18 @@
       tools:ignore="HardcodedText">
 
     <group android:checkableBehavior="single">
+        <item
+            android:id="@+id/action_force_24"
+            android:title="v24"
+            app:showAsAction="never"/>
         <item
             android:id="@+id/action_force_21"
             android:title="v21"
             app:showAsAction="never"/>
+        <item
+            android:id="@+id/action_force_19"
+            android:title="v19"
+            app:showAsAction="never"/>
         <item
             android:id="@+id/action_force_14"
             android:title="v14"
diff --git a/demo/src/main/res/menu/activity_sync_history.xml b/demo/src/main/res/menu/activity_sync_history.xml
new file mode 100644
index 0000000..21267e8
--- /dev/null
+++ b/demo/src/main/res/menu/activity_sync_history.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto"
+      xmlns:tools="http://schemas.android.com/tools"
+      tools:ignore="HardcodedText">
+
+    <item
+        android:id="@+id/action_sync_now"
+        android:showAsAction="always"
+        android:title="Sync now"
+        app:showAsAction="always"
+        tools:ignore="AlwaysShowAction,AppCompatResource"/>
+</menu>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 3aba211..1fe3ce6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.0.5
-VERSION_NAME=1.0.5-SNAPSHOT
+#VERSION_NAME=1.1.4
+VERSION_NAME=1.1.4-SNAPSHOT
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index ca78035..634deed 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6208c93..21fd3d4 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue May 03 14:46:56 CEST 2016
+#Thu Jan 05 14:09:58 CET 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.13-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/gradlew b/gradlew
index 27309d9..4453cce 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index f6d5974..e95643d 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/library/build.gradle b/library/build.gradle
index f8e929e..ab26328 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -7,13 +7,15 @@ dependencies {
     //compile "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
 
     //noinspection GradleDependency
-    compile "com.android.support:support-v4:$rootProject.ext.supportLibVersion"
-    compile 'net.vrallev.android:cat:1.0.3'
+    compile "com.android.support:support-annotations:$rootProject.ext.supportLibVersion"
+    compile 'net.vrallev.android:cat:1.0.5'
 
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
     androidTestCompile 'com.squareup.assertj:assertj-android:1.1.1'
+
+    androidTestCompile "com.facebook.stetho:stetho:$rootProject.ext.stethoVersion"
 }
 
 android {
diff --git a/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java b/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
new file mode 100644
index 0000000..10e3975
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
@@ -0,0 +1,313 @@
+package com.evernote.android.job;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.evernote.android.job.util.support.PersistableBundleCompat;
+import com.facebook.stetho.Stetho;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.TimeUnit;
+
+import static com.evernote.android.job.JobStorage.COLUMN_BACKOFF_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_BACKOFF_POLICY;
+import static com.evernote.android.job.JobStorage.COLUMN_END_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_EXACT;
+import static com.evernote.android.job.JobStorage.COLUMN_EXTRAS;
+import static com.evernote.android.job.JobStorage.COLUMN_ID;
+import static com.evernote.android.job.JobStorage.COLUMN_INTERVAL_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_NETWORK_TYPE;
+import static com.evernote.android.job.JobStorage.COLUMN_NUM_FAILURES;
+import static com.evernote.android.job.JobStorage.COLUMN_PERSISTED;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIREMENTS_ENFORCED;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_CHARGING;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_DEVICE_IDLE;
+import static com.evernote.android.job.JobStorage.COLUMN_SCHEDULED_AT;
+import static com.evernote.android.job.JobStorage.COLUMN_START_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_TAG;
+import static com.evernote.android.job.JobStorage.COLUMN_TRANSIENT;
+import static com.evernote.android.job.JobStorage.DATABASE_NAME;
+import static com.evernote.android.job.JobStorage.JOB_TABLE_NAME;
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class DatabaseUpgradeTest {
+
+    @BeforeClass
+    public static void beforeClass() {
+        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
+    }
+
+    @Test
+    public void testDatabaseUpgrade1to3() {
+        Context context = InstrumentationRegistry.getContext();
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper1 openHelper = new JobOpenHelper1(context);
+        createDatabase(openHelper, false);
+        createJobs(openHelper);
+
+        checkJob(context);
+    }
+
+    @Test
+    public void testDatabaseUpgrade2to3() {
+        Context context = InstrumentationRegistry.getContext();
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper2 openHelper = new JobOpenHelper2(context);
+        createDatabase(openHelper, false);
+        createJobs(openHelper);
+
+        checkJob(context);
+    }
+
+    @Test
+    public void testDatabaseUpgrade1to2to3() {
+        Context context = InstrumentationRegistry.getContext();
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper1 openHelper = new JobOpenHelper1(context);
+        createDatabase(openHelper, false);
+        createJobs(openHelper);
+
+        createDatabase(new JobOpenHelper2(context), true);
+
+        checkJob(context);
+    }
+
+    private void createDatabase(UpgradeAbleJobOpenHelper openHelper, boolean checkUpgraded) {
+        SQLiteDatabase database = openHelper.getWritableDatabase();
+        assertThat(openHelper.mDatabaseCreated).isTrue();
+        if (checkUpgraded) {
+            assertThat(openHelper.mDatabaseUpgraded).isTrue();
+        }
+
+        database.close();
+    }
+
+    private void createJobs(UpgradeAbleJobOpenHelper openHelper) {
+        SQLiteDatabase database = openHelper.getWritableDatabase();
+
+        ContentValues contentValues = openHelper.createBaseContentValues(1);
+        contentValues.put(JobStorage.COLUMN_START_MS, 60_000L);
+        contentValues.put(JobStorage.COLUMN_END_MS, 120_000L);
+        database.insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        contentValues = openHelper.createBaseContentValues(2);
+        contentValues.put(JobStorage.COLUMN_INTERVAL_MS, 60_000L);
+        database.insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        contentValues = openHelper.createBaseContentValues(3);
+        contentValues.put(JobStorage.COLUMN_INTERVAL_MS, TimeUnit.MINUTES.toMillis(20));
+        database.insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+    }
+
+    private void checkJob(Context context) {
+        JobManager.create(context).addJobCreator(new JobCreator() {
+            @Override
+            public Job create(String tag) {
+                return null;
+            }
+        });
+
+        assertThat(JobManager.instance().getAllJobRequests()).hasSize(3);
+
+        JobRequest jobRequest = JobManager.instance().getJobRequest(1);
+        assertThat(jobRequest.isPeriodic()).isFalse();
+        assertThat(jobRequest.getStartMs()).isEqualTo(60_000L);
+        assertThat(jobRequest.isTransient()).isFalse();
+
+        jobRequest = JobManager.instance().getJobRequest(2);
+        assertThat(jobRequest.isPeriodic()).isTrue();
+        assertThat(jobRequest.getIntervalMs()).isEqualTo(JobRequest.MIN_INTERVAL);
+        assertThat(jobRequest.getFlexMs()).isEqualTo(jobRequest.getIntervalMs());
+        assertThat(jobRequest.isTransient()).isFalse();
+
+        jobRequest = JobManager.instance().getJobRequest(3);
+        assertThat(jobRequest.isPeriodic()).isTrue();
+        assertThat(jobRequest.getIntervalMs()).isEqualTo(TimeUnit.MINUTES.toMillis(20));
+        assertThat(jobRequest.getFlexMs()).isEqualTo(jobRequest.getIntervalMs());
+        assertThat(jobRequest.isTransient()).isFalse();
+
+        JobManager.instance().cancelAll();
+
+        int jobId = new JobRequest.Builder("Tag")
+                .setExact(90_000L)
+                .build()
+                .schedule();
+
+        assertThat(JobManager.instance().getAllJobRequests()).hasSize(1);
+
+        jobRequest = JobManager.instance().getJobRequest(jobId);
+        assertThat(jobRequest).isNotNull();
+        assertThat(jobRequest.isTransient()).isFalse();
+
+        jobRequest.setTransient(true);
+        assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
+        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).hasSize(1);
+
+        JobManager.instance().cancelAll();
+
+        assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
+        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).isEmpty();
+
+        JobManager.instance().destroy();
+    }
+
+    private abstract class UpgradeAbleJobOpenHelper extends SQLiteOpenHelper {
+
+        private boolean mDatabaseCreated;
+        private boolean mDatabaseUpgraded;
+
+        public UpgradeAbleJobOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
+            super(context, name, factory, version);
+        }
+
+        @Override
+        public final void onCreate(SQLiteDatabase db) {
+            onCreateInner(db);
+            mDatabaseCreated = true;
+        }
+
+        protected abstract void onCreateInner(SQLiteDatabase db);
+
+        @Override
+        public final void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+            onUpgradeInner(sqLiteDatabase, oldVersion, newVersion);
+            mDatabaseCreated = true;
+            mDatabaseUpgraded = true;
+        }
+
+        protected abstract void onUpgradeInner(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion);
+
+        protected ContentValues createBaseContentValues(int id) {
+            ContentValues contentValues = new ContentValues();
+            contentValues.put(JobStorage.COLUMN_ID, id);
+            contentValues.put(JobStorage.COLUMN_TAG, "Tag");
+
+            contentValues.put(JobStorage.COLUMN_START_MS, -1L);
+            contentValues.put(JobStorage.COLUMN_END_MS, -1L);
+
+            contentValues.put(JobStorage.COLUMN_BACKOFF_MS, JobRequest.DEFAULT_BACKOFF_MS);
+            contentValues.put(JobStorage.COLUMN_BACKOFF_POLICY, JobRequest.DEFAULT_BACKOFF_POLICY.toString());
+
+            contentValues.put(JobStorage.COLUMN_INTERVAL_MS, 0L);
+
+            contentValues.put(JobStorage.COLUMN_REQUIREMENTS_ENFORCED, false);
+            contentValues.put(JobStorage.COLUMN_REQUIRES_CHARGING, false);
+            contentValues.put(JobStorage.COLUMN_REQUIRES_DEVICE_IDLE, false);
+            contentValues.put(JobStorage.COLUMN_EXACT, false);
+            contentValues.put(JobStorage.COLUMN_NETWORK_TYPE, JobRequest.DEFAULT_NETWORK_TYPE.toString());
+
+            contentValues.put(JobStorage.COLUMN_EXTRAS, new PersistableBundleCompat().saveToXml());
+            contentValues.put(JobStorage.COLUMN_PERSISTED, false);
+
+            contentValues.put(JobStorage.COLUMN_NUM_FAILURES, 0);
+            contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, System.currentTimeMillis());
+
+            return contentValues;
+        }
+    }
+
+    private class JobOpenHelper1 extends UpgradeAbleJobOpenHelper {
+
+        public JobOpenHelper1(Context context) {
+            super(context, DATABASE_NAME, null, 1);
+        }
+
+        @Override
+        public void onCreateInner(SQLiteDatabase db) {
+            createJobTable(db);
+        }
+
+        @Override
+        public void onUpgradeInner(SQLiteDatabase db, int oldVersion, int newVersion) {
+            // not needed at the moment
+        }
+
+        private void createJobTable(SQLiteDatabase db) {
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + COLUMN_PERSISTED + " integer, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer);");
+        }
+    }
+
+    private class JobOpenHelper2 extends UpgradeAbleJobOpenHelper {
+
+        public JobOpenHelper2(Context context) {
+            super(context, DATABASE_NAME, null, 2);
+        }
+
+        @Override
+        public void onCreateInner(SQLiteDatabase db) {
+            createJobTable(db);
+        }
+
+        @Override
+        public void onUpgradeInner(SQLiteDatabase db, int oldVersion, int newVersion) {
+            // with newer versions there should be a smarter way
+            if (oldVersion == 1 && newVersion == 2) {
+                upgradeFrom1To2(db);
+            }
+        }
+
+        @Override
+        protected ContentValues createBaseContentValues(int id) {
+            ContentValues contentValues = super.createBaseContentValues(id);
+            contentValues.put(JobStorage.COLUMN_TRANSIENT, false);
+            return contentValues;
+        }
+
+        private void createJobTable(SQLiteDatabase db) {
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + COLUMN_PERSISTED + " integer, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + COLUMN_TRANSIENT + " integer);");
+        }
+
+        private void upgradeFrom1To2(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java b/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java
new file mode 100644
index 0000000..585f84c
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/JobExecutionTest.java
@@ -0,0 +1,149 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.facebook.stetho.Stetho;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class JobExecutionTest {
+
+    private static Set<Integer> cachedJobIds;
+
+    @BeforeClass
+    public static void beforeClass() {
+        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
+
+        JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
+            @Override
+            public Job create(String tag) {
+                return new TestJob();
+            }
+        });
+        cachedJobIds = new HashSet<>();
+    }
+
+    @AfterClass
+    public static void afterClass() {
+        Context context = InstrumentationRegistry.getContext();
+        for (Integer jobId : cachedJobIds) {
+            JobManager.instance().getApi().getCachedProxy(context).cancel(jobId);
+        }
+
+        JobManager.instance().destroy();
+    }
+
+    @Before
+    public void beforeTest() {
+        JobManager.instance().cancelAll();
+    }
+
+    @After
+    public void afterTest() {
+        JobManager.instance().cancelAll();
+    }
+
+    @Test
+    public void testSimpleJob() {
+        final int jobId = getBuilder()
+                .setExecutionWindow(200_000L, 400_000L)
+                .setPersisted(true)
+                .build()
+                .schedule();
+
+        cachedJobIds.add(jobId);
+
+        JobProxy.Common common = getCommon(jobId);
+        JobRequest pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNotNull();
+
+        new Thread() {
+            @Override
+            public void run() {
+                SystemClock.sleep(200);
+                assertThat(JobManager.instance().getJobRequest(jobId)).isNull();
+
+                JobRequest transientRequest = JobManager.instance().getJobRequest(jobId, true);
+                assertThat(transientRequest).isNotNull();
+                assertThat(transientRequest.isTransient()).isTrue();
+            }
+        }.start();
+
+        Job.Result result = common.executeJobRequest(pendingRequest);
+        assertThat(result).isEqualTo(Job.Result.FAILURE);
+
+        assertThat(JobManager.instance().getAllJobRequestsForTag(TestJob.TAG)).isEmpty();
+
+        pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNull();
+    }
+
+    @Test
+    public void testPeriodicJob() {
+        int jobId = getBuilder()
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
+                .setPersisted(true)
+                .build()
+                .schedule();
+
+        cachedJobIds.add(jobId);
+
+        JobProxy.Common common = getCommon(jobId);
+        JobRequest pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNotNull();
+
+        Job.Result result = common.executeJobRequest(pendingRequest);
+        assertThat(result).isEqualTo(Job.Result.FAILURE);
+
+        pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNull();
+
+        assertThat(JobManager.instance().getAllJobRequestsForTag(TestJob.TAG)).hasSize(1);
+
+        SystemClock.sleep(3_000);
+
+        pendingRequest = common.getPendingRequest(true);
+        assertThat(pendingRequest).isNotNull();
+    }
+
+    private JobRequest.Builder getBuilder() {
+        return new JobRequest.Builder(TestJob.TAG);
+    }
+
+    private JobProxy.Common getCommon(int jobId) {
+        return new JobProxy.Common(InstrumentationRegistry.getContext(), "JobExecutionTest", jobId);
+    }
+
+    private static final class TestJob extends Job {
+
+        private static final String TAG = "tag";
+
+        @NonNull
+        @Override
+        protected Result onRunJob(@NonNull Params params) {
+            SystemClock.sleep(1_000L);
+            return Result.FAILURE;
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/test/JobManagerTest.java b/library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java
similarity index 84%
rename from library/src/androidTest/java/com/evernote/android/job/test/JobManagerTest.java
rename to library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java
index 386b5bc..b4d7f21 100644
--- a/library/src/androidTest/java/com/evernote/android/job/test/JobManagerTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/JobManagerTest.java
@@ -1,17 +1,15 @@
-package com.evernote.android.job.test;
+package com.evernote.android.job;
 
 import android.support.annotation.NonNull;
 import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
 import android.support.test.runner.AndroidJUnit4;
-import android.test.suitebuilder.annotation.LargeTest;
 
-import com.evernote.android.job.Job;
-import com.evernote.android.job.JobCreator;
-import com.evernote.android.job.JobManager;
-import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobApi;
+import com.facebook.stetho.Stetho;
 
 import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,7 +24,9 @@
 public class JobManagerTest {
 
     @BeforeClass
-    public static void createJobManager() {
+    public static void beforeClass() {
+        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
+
         JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
             @Override
             public Job create(String tag) {
@@ -35,9 +35,15 @@ public Job create(String tag) {
         });
     }
 
+    @AfterClass
+    public static void afterClass() {
+        JobManager.instance().destroy();
+    }
+
     @Test
     public void testScheduleAndCancel() {
-        assertThat(getManager().getApi()).isEqualTo(JobApi.getDefault(InstrumentationRegistry.getContext()));
+        JobApi defaultApi = JobApi.getDefault(InstrumentationRegistry.getContext(), getManager().getConfig().isGcmApiEnabled());
+        assertThat(getManager().getApi()).isEqualTo(defaultApi);
 
         JobRequest request = getJobRequest();
         int id = request.schedule();
diff --git a/library/src/androidTest/java/com/evernote/android/job/test/JobRequestTest.java b/library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java
similarity index 78%
rename from library/src/androidTest/java/com/evernote/android/job/test/JobRequestTest.java
rename to library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java
index d24f82f..a1afb56 100644
--- a/library/src/androidTest/java/com/evernote/android/job/test/JobRequestTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/JobRequestTest.java
@@ -1,16 +1,17 @@
-package com.evernote.android.job.test;
+package com.evernote.android.job;
 
 import android.support.annotation.NonNull;
 import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
 import android.support.test.runner.AndroidJUnit4;
-import android.test.suitebuilder.annotation.LargeTest;
 
-import com.evernote.android.job.Job;
-import com.evernote.android.job.JobCreator;
-import com.evernote.android.job.JobManager;
-import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
+import com.facebook.stetho.Stetho;
 
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,7 +26,9 @@
 public class JobRequestTest {
 
     @BeforeClass
-    public static void createJobManager() {
+    public static void beforeClass() {
+        Stetho.initializeWithDefaults(InstrumentationRegistry.getContext());
+
         JobManager.create(InstrumentationRegistry.getContext()).addJobCreator(new JobCreator() {
             @Override
             public Job create(String tag) {
@@ -34,6 +37,21 @@ public Job create(String tag) {
         });
     }
 
+    @AfterClass
+    public static void afterClass() {
+        JobManager.instance().destroy();
+    }
+
+    @Before
+    public void beforeTest() {
+        JobManager.instance().cancelAll();
+    }
+
+    @After
+    public void afterTest() {
+        JobManager.instance().cancelAll();
+    }
+
     @Test
     public void testSimpleJob() {
         JobRequest request = getBuilder()
@@ -63,8 +81,9 @@ public void testSimpleJob() {
 
     @Test
     public void testPeriodic() {
+        long interval = JobRequest.MIN_INTERVAL * 5;
         JobRequest request = getBuilder()
-                .setPeriodic(60_000L)
+                .setPeriodic(interval)
                 .setExtras(new PersistableBundleCompat())
                 .setPersisted(true)
                 .build();
@@ -72,8 +91,10 @@ public void testPeriodic() {
         assertThat(request.getJobId()).isGreaterThan(0);
         assertThat(request.getTag()).isEqualTo(TestJob.TAG);
         assertThat(request.isPersisted()).isTrue();
-        assertThat(request.getIntervalMs()).isEqualTo(60_000L);
+        assertThat(request.getIntervalMs()).isEqualTo(interval);
+        assertThat(request.getFlexMs()).isEqualTo(interval);
         assertThat(request.isPeriodic()).isTrue();
+        assertThat(request.isFlexSupport()).isFalse();
 
         assertThat(request.getStartMs()).isNegative();
         assertThat(request.getEndMs()).isNegative();
@@ -87,6 +108,25 @@ public void testPeriodic() {
         assertThat(request.requiresDeviceIdle()).isFalse();
     }
 
+    @Test
+    public void testFlex() {
+        long interval = JobRequest.MIN_INTERVAL * 5;
+        long flex = JobRequest.MIN_FLEX * 5;
+        JobRequest request = getBuilder()
+                .setPeriodic(interval, flex)
+                .build();
+
+        JobManager.instance().forceApi(JobApi.V_14);
+        JobManager.instance().schedule(request);
+
+        assertThat(request.getJobId()).isGreaterThan(0);
+        assertThat(request.getTag()).isEqualTo(TestJob.TAG);
+        assertThat(request.getIntervalMs()).isEqualTo(interval);
+        assertThat(request.getFlexMs()).isEqualTo(flex);
+        assertThat(request.isPeriodic()).isTrue();
+        assertThat(request.isFlexSupport()).isTrue();
+    }
+
     @Test
     public void testExact() {
         JobRequest request = getBuilder()
@@ -129,7 +169,14 @@ public void testExecutionWindow() {
     @Test(expected = Exception.class)
     public void testPeriodicTooLittleInterval() {
         getBuilder()
-                .setPeriodic(59_999L)
+                .setPeriodic(JobRequest.MIN_INTERVAL - 1)
+                .build();
+    }
+
+    @Test(expected = Exception.class)
+    public void testPeriodicTooLittleFlex() {
+        getBuilder()
+                .setPeriodic(JobRequest.MIN_FLEX - 1)
                 .build();
     }
 
diff --git a/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java b/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java
index 97a4b6f..2a61428 100644
--- a/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/test/PersistableBundleCompatTest.java
@@ -1,7 +1,7 @@
 package com.evernote.android.job.test;
 
+import android.support.test.filters.SmallTest;
 import android.support.test.runner.AndroidJUnit4;
-import android.test.suitebuilder.annotation.SmallTest;
 
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
diff --git a/library/src/androidTest/res/values/integers.xml b/library/src/androidTest/res/values/integers.xml
index 5ba1911..3da3d41 100644
--- a/library/src/androidTest/res/values/integers.xml
+++ b/library/src/androidTest/res/values/integers.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <!-- required to make test project compile with provided dependency -->
-    <integer name="google_play_services_version">7895000</integer>
+    <integer name="google_play_services_version">9683000</integer>
 </resources>
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index a69a33e..a1d6131 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -22,6 +22,7 @@
             android:name="com.evernote.android.job.v14.PlatformAlarmReceiver"
             android:exported="false">
             <intent-filter>
+                <!-- Keep the filter for legacy intents -->
                 <action android:name="com.evernote.android.job.v14.RUN_JOB"/>
                 <action android:name="net.vrallev.android.job.v14.RUN_JOB"/>
             </intent-filter>
@@ -34,6 +35,16 @@
                 <action android:name="android.intent.action.BOOT_COMPLETED"/>
             </intent-filter>
         </receiver>
+
+        <service
+            android:name="com.evernote.android.job.gcm.PlatformGcmService"
+            android:enabled="false"
+            android:exported="true"
+            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE">
+            <intent-filter>
+                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
+            </intent-filter>
+        </service>
     </application>
 
 </manifest>
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index d30cf3d..2bcf31f 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -31,6 +31,7 @@
 import android.content.Intent;
 import android.os.PowerManager.WakeLock;
 import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
 import android.support.v4.content.WakefulBroadcastReceiver;
 
 import com.evernote.android.job.util.Device;
@@ -99,6 +100,7 @@
      * {@link Job} is invalid and ignored.
      */
     @NonNull
+    @WorkerThread
     protected abstract Result onRunJob(Params params);
 
     /*package*/ final Result runJob() {
@@ -124,6 +126,7 @@
      * @param newJobId The new ID of the rescheduled {@link JobRequest}.
      */
     @SuppressWarnings("UnusedParameters")
+    @WorkerThread
     protected void onReschedule(int newJobId) {
         // override me
     }
@@ -172,15 +175,19 @@ protected boolean isRequirementDeviceIdleMet() {
      */
     protected boolean isRequirementNetworkTypeMet() {
         JobRequest.NetworkType requirement = getParams().getRequest().requiredNetworkType();
+        if (requirement == JobRequest.NetworkType.ANY) {
+            return true;
+        }
+
+        JobRequest.NetworkType current = Device.getNetworkType(getContext());
+
         switch (requirement) {
-            case ANY:
-                return true;
-            case UNMETERED:
-                JobRequest.NetworkType current = Device.getNetworkType(getContext());
-                return JobRequest.NetworkType.UNMETERED.equals(current);
             case CONNECTED:
-                current = Device.getNetworkType(getContext());
-                return !JobRequest.NetworkType.ANY.equals(current);
+                return current != JobRequest.NetworkType.ANY;
+            case NOT_ROAMING:
+                return current == JobRequest.NetworkType.NOT_ROAMING || current == JobRequest.NetworkType.UNMETERED;
+            case UNMETERED:
+                return current == JobRequest.NetworkType.UNMETERED;
             default:
                 throw new IllegalStateException("not implemented");
         }
@@ -322,7 +329,7 @@ public String toString() {
     }
 
     /**
-     * Holds several parameters for the executing {@link Job}.
+     * Holds several parameters for the {@link Job} execution.
      */
     protected static final class Params {
 
@@ -331,11 +338,11 @@ public String toString() {
 
         private Params(@NonNull JobRequest request) {
             mRequest = request;
-            mExtras = request.getExtras();
         }
 
         /**
          * @return The unique ID for this {@link Job}.
+         * @see JobRequest#getJobId()
          */
         public int getId() {
             return mRequest.getJobId();
@@ -343,6 +350,7 @@ public int getId() {
 
         /**
          * @return The tag for this {@link Job} which was passed in the constructor of the {@link JobRequest.Builder}.
+         * @see JobRequest#getTag()
          */
         public String getTag() {
             return mRequest.getTag();
@@ -351,11 +359,145 @@ public String getTag() {
         /**
          * @return Whether this {@link Job} is periodic or not. If this {@link Job} is periodic, then
          * you shouldn't return {@link Result#RESCHEDULE} as result.
+         * @see JobRequest#isPeriodic()
          */
         public boolean isPeriodic() {
             return mRequest.isPeriodic();
         }
 
+        /**
+         * @return {@code true} if this job was scheduled at an exact time by calling {@link JobRequest.Builder#setExact(long)}.
+         * @see JobRequest#isExact()
+         */
+        public boolean isExact() {
+            return mRequest.isExact();
+        }
+
+        /**
+         * @return If {@code true}, then the job persists across reboots.
+         * @see JobRequest#isPersisted()
+         */
+        public boolean isPersisted() {
+            return mRequest.isPersisted();
+        }
+
+        /**
+         * Only valid if the job isn't periodic.
+         *
+         * @return The start of the time frame when the job will run after it's been scheduled.
+         * @see JobRequest#getStartMs()
+         */
+        public long getStartMs() {
+            return mRequest.getStartMs();
+        }
+
+        /**
+         * Only valid if the job isn't periodic.
+         *
+         * @return The end of the time frame when the job will run after it's been scheduled.
+         * @see JobRequest#getEndMs()
+         */
+        public long getEndMs() {
+            return mRequest.getEndMs();
+        }
+
+        /**
+         * Only valid if the job is periodic.
+         *
+         * @return The interval in which the job runs once.
+         * @see JobRequest#getIntervalMs()
+         */
+        public long getIntervalMs() {
+            return mRequest.getIntervalMs();
+        }
+
+        /**
+         * Flex time for this job. Only valid if this is a periodic job. The job can execute
+         * at any time in a window of flex length at the end of the period.
+         *
+         * @return How close to the end of an interval a periodic job is allowed to run.
+         * @see JobRequest#getFlexMs()
+         */
+        public long getFlexMs() {
+            return mRequest.getFlexMs();
+        }
+
+        /**
+         * Returns the time when this job was scheduled.
+         * <br>
+         * <br>
+         * <b>Note</b> that this value is only useful for non-periodic jobs. The time for periodic
+         * jobs is inconsistent. Sometimes it will return the value when the periodic job was scheduled
+         * for the first time and sometimes it will be updated after each period. The reason for this
+         * limitation is the flex parameter, which was backported to older Android versions. You can
+         * only rely on this value during the first interval of the periodic job.
+         *
+         * @return The time when the job was scheduled.
+         */
+        public long getScheduledAt() {
+            return mRequest.getScheduledAt();
+        }
+
+        /**
+         * Only valid if the job isn't periodic.
+         *
+         * @return The initial back-off time which is increasing depending on the {@link #getBackoffPolicy()}
+         * if the job fails multiple times.
+         * @see JobRequest#getBackoffMs()
+         */
+        public long getBackoffMs() {
+            return mRequest.getBackoffMs();
+        }
+
+        /**
+         * Only valid if the job isn't periodic.
+         *
+         * @return The back-off policy if a job failed and is rescheduled.
+         * @see JobRequest#getBackoffPolicy()
+         */
+        public JobRequest.BackoffPolicy getBackoffPolicy() {
+            return mRequest.getBackoffPolicy();
+        }
+
+        /**
+         * Call {@link #isRequirementChargingMet()} to check whether this requirement is fulfilled.
+         *
+         * @return If {@code true}, then the job should only run if the device is charging.
+         * @see JobRequest#requiresCharging()
+         */
+        public boolean requiresCharging() {
+            return mRequest.requiresCharging();
+        }
+
+        /**
+         * Call {@link #isRequirementDeviceIdleMet()} to check whether this requirement is fulfilled.
+         *
+         * @return If {@code true}, then job should only run if the device is idle.
+         * @see JobRequest#requiresDeviceIdle()
+         */
+        public boolean requiresDeviceIdle() {
+            return mRequest.requiresDeviceIdle();
+        }
+
+        /**
+         * Call {@link #isRequirementNetworkTypeMet()} to check whether this requirement is fulfilled.
+         *
+         * @return The network state which is required to run the job.
+         * @see JobRequest#requiredNetworkType()
+         */
+        public JobRequest.NetworkType requiredNetworkType() {
+            return mRequest.requiredNetworkType();
+        }
+
+        /**
+         * @return If {@code true}, then all requirements are checked before the job runs. If one requirement
+         * isn't met, then the job is rescheduled right away.
+         * @see JobRequest#requirementsEnforced()
+         */
+        public boolean requirementsEnforced() {
+            return mRequest.requirementsEnforced();
+        }
+
         /**
          * The failure count increases if a non periodic {@link Job} was rescheduled or if a periodic
          * {@link Job} wasn't successful.
@@ -372,7 +514,10 @@ public int getFailureCount() {
         @NonNull
         public PersistableBundleCompat getExtras() {
             if (mExtras == null) {
-                mExtras = new PersistableBundleCompat();
+                mExtras = mRequest.getExtras();
+                if (mExtras == null) {
+                    mExtras = new PersistableBundleCompat();
+                }
             }
             return mExtras;
         }
diff --git a/library/src/main/java/com/evernote/android/job/JobBootReceiver.java b/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
index e8d675a..9497a25 100644
--- a/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
+++ b/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
@@ -42,9 +42,10 @@
     @Override
     public void onReceive(Context context, Intent intent) {
         /*
-         * We don't need to do anything. This receiver causes the app to be loaded. In the onCreate()
-         * method of the Application object we initialize the JobManager. There we reschedule tasks
-         * if necessary.
+         * Create the job manager. We may need to reschedule jobs and some applications aren't initializing the
+         * manager in Application.onCreate(). It may happen that some jobs can't be created if the JobCreator
+         * wasn't registered, yet. Apps / Libraries need to figure out how to solve this themselves.
          */
+        JobManager.create(context);
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobCreator.java b/library/src/main/java/com/evernote/android/job/JobCreator.java
index fa99f1a..161ac2f 100644
--- a/library/src/main/java/com/evernote/android/job/JobCreator.java
+++ b/library/src/main/java/com/evernote/android/job/JobCreator.java
@@ -1,5 +1,10 @@
 package com.evernote.android.job;
 
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+
 /**
  * A {@code JobCreator} maps a tag to a specific {@link Job} class. You need to pass the tag in the
  * {@link JobRequest.Builder} constructor.
@@ -27,4 +32,33 @@
      * @see JobRequest.Builder#Builder(String)
      */
     Job create(String tag);
+
+    /**
+     * Action to notify receives that the application was instantiated and {@link JobCreator}s should be added.
+     */
+    String ACTION_ADD_JOB_CREATOR = "com.evernote.android.job.ADD_JOB_CREATOR";
+
+    /**
+     * Abstract receiver to get notified about when {@link JobCreator}s need to be added.
+     */
+    abstract class AddJobCreatorReceiver extends BroadcastReceiver {
+
+        @Override
+        public final void onReceive(Context context, Intent intent) {
+            if (context ==  null || intent == null || !ACTION_ADD_JOB_CREATOR.equals(intent.getAction())) {
+                return;
+            }
+
+            addJobCreator(context, JobManager.create(context));
+        }
+
+        /**
+         * Called to add a {@link JobCreator} to this manager instance by calling {@link JobManager#addJobCreator(JobCreator)}.
+         *
+         * @param context Any context.
+         * @param manager The manager instance.
+         */
+        protected abstract void addJobCreator(@NonNull Context context, @NonNull JobManager manager);
+    }
+
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobExecutor.java b/library/src/main/java/com/evernote/android/job/JobExecutor.java
index 8bff3f6..f28bb4b 100644
--- a/library/src/main/java/com/evernote/android/job/JobExecutor.java
+++ b/library/src/main/java/com/evernote/android/job/JobExecutor.java
@@ -28,14 +28,16 @@
 import android.content.Context;
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.util.LruCache;
 import android.util.SparseArray;
 
 import com.evernote.android.job.util.JobCat;
-import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
 
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
@@ -49,17 +51,20 @@
 /*package*/ class JobExecutor {
 
     private static final CatLog CAT = new JobCat("JobExecutor");
+    private static final long WAKE_LOCK_TIMEOUT = TimeUnit.MINUTES.toMillis(3);
 
     private final ExecutorService mExecutorService;
+
     private final SparseArray<Job> mJobs; // only cached in memory, that's fine
+    private final LruCache<Integer, Job> mFinishedJobsCache;
 
     public JobExecutor() {
         mExecutorService = Executors.newCachedThreadPool();
         mJobs = new SparseArray<>();
+        mFinishedJobsCache = new LruCache<>(20);
     }
 
-    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @NonNull JobCreatorHolder jobCreatorHolder) {
-        Job job = jobCreatorHolder.createJob(request.getTag());
+    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @Nullable Job job) {
         if (job == null) {
             CAT.w("JobCreator returned null for tag %s", request.getTag());
             return null;
@@ -77,7 +82,8 @@ public JobExecutor() {
     }
 
     public synchronized Job getJob(int jobId) {
-        return mJobs.get(jobId);
+        Job job = mJobs.get(jobId);
+        return job != null ? job : mFinishedJobsCache.get(jobId);
     }
 
     public synchronized Set<Job> getAllJobs() {
@@ -92,9 +98,23 @@ public synchronized Job getJob(int jobId) {
                 result.add(job);
             }
         }
+
+        Map<Integer, Job> snapshot = mFinishedJobsCache.snapshot();
+        for (Job job : snapshot.values()) {
+            if (tag == null || tag.equals(job.getParams().getTag())) {
+                result.add(job);
+            }
+        }
+
         return result;
     }
 
+    private synchronized void markJobAsFinished(Job job) {
+        int id = job.getParams().getId();
+        mJobs.remove(id);
+        mFinishedJobsCache.put(id, job);
+    }
+
     private final class JobCallable implements Callable<Job.Result> {
 
         private final Job mJob;
@@ -104,32 +124,23 @@ private JobCallable(Job job) {
             mJob = job;
 
             Context context = mJob.getContext();
-            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-
-            mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "JobExecutor");
-            mWakeLock.setReferenceCounted(false);
-            acquireWakeLock();
+            mWakeLock = WakeLockUtil.acquireWakeLock(context, "JobExecutor", WAKE_LOCK_TIMEOUT);
         }
 
         @Override
         public Job.Result call() throws Exception {
             try {
                 // just in case something was blocking and the wake lock is no longer acquired
-                acquireWakeLock();
-
+                WakeLockUtil.acquireWakeLock(mJob.getContext(), mWakeLock, WAKE_LOCK_TIMEOUT);
                 return runJob();
 
             } finally {
-                if (mWakeLock.isHeld()) {
-                    try {
-                        mWakeLock.release();
-                    } catch (Exception e) {
-                        // just to make sure if the PowerManager crashes while acquiring a wake lock
-                        CAT.e(e);
-                    }
-                } else {
+                markJobAsFinished(mJob);
+
+                if (mWakeLock == null || !mWakeLock.isHeld()) {
                     CAT.w("Wake lock was not held after job %s was done. The job took too long to complete. This could have unintended side effects on your app.", mJob);
                 }
+                WakeLockUtil.releaseWakeLock(mWakeLock);
             }
         }
 
@@ -152,23 +163,11 @@ private JobCallable(Job job) {
         private void handleResult(Job.Result result) {
             JobRequest request = mJob.getParams().getRequest();
             if (!request.isPeriodic() && Job.Result.RESCHEDULE.equals(result)) {
-                int newJobId = request.reschedule(true);
+                int newJobId = request.reschedule(true, true);
                 mJob.onReschedule(newJobId);
             } else if (request.isPeriodic() && !Job.Result.SUCCESS.equals(result)) {
                 request.incNumFailures();
             }
         }
-
-        private void acquireWakeLock() {
-            if (!mWakeLock.isHeld() && JobUtil.hasWakeLockPermission(mJob.getContext())) {
-                try {
-                    mWakeLock.acquire(TimeUnit.MINUTES.toMillis(3));
-                } catch (Exception e) {
-                    // saw an NPE on rooted Galaxy Nexus Android 4.1.1
-                    // android.os.IPowerManager$Stub$Proxy.acquireWakeLock(IPowerManager.java:288)
-                    CAT.e(e);
-                }
-            }
-        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index f46b82e..896d279 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -25,10 +25,15 @@
  */
 package com.evernote.android.job;
 
+import android.annotation.SuppressLint;
 import android.app.AlarmManager;
 import android.app.Application;
 import android.app.job.JobScheduler;
 import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.PowerManager;
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
@@ -45,6 +50,7 @@
 import net.vrallev.android.cat.CatGlobal;
 import net.vrallev.android.cat.CatLog;
 
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
@@ -79,9 +85,10 @@
 @SuppressWarnings("unused")
 public final class JobManager {
 
-    private static final String PACKAGE = JobManager.class.getPackage().getName();
+    private static final Package PACKAGE = JobManager.class.getPackage();
     private static final CatLog CAT = new JobCat("JobManager");
 
+    @SuppressLint("StaticFieldLeak")
     private static volatile JobManager instance;
 
     /**
@@ -91,12 +98,16 @@
      * @param context Any {@link Context} to instantiate the singleton object.
      * @return The new or existing singleton object.
      */
-    public static JobManager create(Context context) {
+    public static JobManager create(@NonNull Context context) {
         if (instance == null) {
             synchronized (JobManager.class) {
                 if (instance == null) {
                     JobPreconditions.checkNotNull(context, "Context cannot be null");
-                    CatGlobal.setDefaultCatLogPackage(PACKAGE, new JobCat());
+
+                    if (PACKAGE != null) {
+                        // package can be null when class is repackaged, then ignore this
+                        CatGlobal.setDefaultCatLogPackage(PACKAGE.getName(), new JobCat());
+                    }
 
                     if (context.getApplicationContext() != null) {
                         // could be null in unit tests
@@ -111,6 +122,8 @@ public static JobManager create(Context context) {
                     if (!JobUtil.hasBootPermission(context)) {
                         Cat.w("No boot permission");
                     }
+
+                    sendAddJobCreatorIntent(context);
                 }
             }
         }
@@ -122,7 +135,7 @@ public static JobManager create(Context context) {
      * Initializes the singleton. It's necessary to call this function before using the {@code JobManager}.
      * Calling it multiple times has not effect.
      *
-     * @param context Any {@link Context} to instantiate the singleton object.
+     * @param context    Any {@link Context} to instantiate the singleton object.
      * @param jobCreator The mapping between a specific job tag and the job class.
      * @return The new or existing singleton object.
      * @deprecated Use {@link #create(Context)} instead and call {@link #addJobCreator(JobCreator)} after that.
@@ -165,6 +178,7 @@ public static JobManager instance() {
     private final JobCreatorHolder mJobCreatorHolder;
     private final JobStorage mJobStorage;
     private final JobExecutor mJobExecutor;
+    private final Config mConfig;
 
     private JobApi mApi;
 
@@ -173,12 +187,20 @@ private JobManager(Context context) {
         mJobCreatorHolder = new JobCreatorHolder();
         mJobStorage = new JobStorage(context);
         mJobExecutor = new JobExecutor();
+        mConfig = new Config();
 
-        setJobProxy(JobApi.getDefault(mContext));
+        setJobProxy(JobApi.getDefault(mContext, mConfig.isGcmApiEnabled()));
 
         rescheduleTasksIfNecessary();
     }
 
+    /**
+     * @return The current configuration for the job manager.
+     */
+    public Config getConfig() {
+        return mConfig;
+    }
+
     protected void setJobProxy(JobApi api) {
         mApi = api;
     }
@@ -191,7 +213,7 @@ protected void setJobProxy(JobApi api) {
      *
      * @param request The {@link JobRequest} which will be run in the future.
      */
-    public void schedule(JobRequest request) {
+    public void schedule(@NonNull JobRequest request) {
         if (mJobCreatorHolder.isEmpty()) {
             CAT.w("you haven't registered a JobCreator with addJobCreator(), it's likely that your job never will be executed");
         }
@@ -200,12 +222,28 @@ public void schedule(JobRequest request) {
             cancelAllForTag(request.getTag());
         }
 
+        JobProxy.Common.cleanUpOrphanedJob(mContext, request.getJobId());
+
+        JobApi jobApi = request.getJobApi();
+        boolean periodic = request.isPeriodic();
+        boolean flexSupport = periodic && jobApi.isFlexSupport() && request.getFlexMs() < request.getIntervalMs();
+
+        if (jobApi == JobApi.GCM && !mConfig.isGcmApiEnabled()) {
+            // shouldn't happen
+            CAT.w("GCM API disabled, but used nonetheless");
+        }
+
         request.setScheduledAt(System.currentTimeMillis());
+        request.setFlexSupport(flexSupport);
         mJobStorage.put(request);
 
-        JobProxy proxy = getJobProxy(request);
-        if (request.isPeriodic()) {
-            proxy.plantPeriodic(request);
+        JobProxy proxy = getJobProxy(jobApi);
+        if (periodic) {
+            if (flexSupport) {
+                proxy.plantPeriodicFlexSupport(request);
+            } else {
+                proxy.plantPeriodic(request);
+            }
         } else {
             proxy.plantOneOff(request);
         }
@@ -216,7 +254,16 @@ public void schedule(JobRequest request) {
      * @return The {@link JobRequest} if it's pending or {@code null} otherwise.
      */
     public JobRequest getJobRequest(int jobId) {
-        return mJobStorage.get(jobId);
+        return getJobRequest(jobId, false);
+    }
+
+    /*package*/ JobRequest getJobRequest(int jobId, boolean includeTransient) {
+        JobRequest jobRequest = mJobStorage.get(jobId);
+        if (!includeTransient && jobRequest != null && jobRequest.isTransient()) {
+            return null;
+        } else {
+            return jobRequest;
+        }
     }
 
     /**
@@ -227,7 +274,7 @@ public JobRequest getJobRequest(int jobId) {
      */
     @NonNull
     public Set<JobRequest> getAllJobRequests() {
-        return mJobStorage.getAllJobRequests();
+        return mJobStorage.getAllJobRequests(null, false);
     }
 
     /**
@@ -237,7 +284,7 @@ public JobRequest getJobRequest(int jobId) {
      * direct effects to the actual backing store.
      */
     public Set<JobRequest> getAllJobRequestsForTag(@NonNull String tag) {
-        return mJobStorage.getAllJobRequestsForTag(tag);
+        return mJobStorage.getAllJobRequests(tag, false);
     }
 
     /**
@@ -308,7 +355,9 @@ public JobApi getApi() {
      */
     public boolean cancel(int jobId) {
         // call both methods
-        return cancelInner(getJobRequest(jobId)) | cancelInner(getJob(jobId));
+        boolean result = cancelInner(getJobRequest(jobId, true)) | cancelInner(getJob(jobId));
+        JobProxy.Common.cleanUpOrphanedJob(mContext, jobId); // do this as well, just in case
+        return result;
     }
 
     /**
@@ -333,7 +382,7 @@ public int cancelAllForTag(@NonNull String tag) {
     private boolean cancelInner(@Nullable JobRequest request) {
         if (request != null) {
             CAT.i("Found pending job %s, canceling", request);
-            getJobProxy(request).cancel(request);
+            getJobProxy(request).cancel(request.getJobId());
             getJobStorage().remove(request);
             return true;
         } else {
@@ -354,7 +403,7 @@ private boolean cancelInner(@Nullable Job job) {
     private int cancelAllInner(@Nullable String tag) {
         int canceled = 0;
 
-        Set<JobRequest> requests = TextUtils.isEmpty(tag) ? getAllJobRequests() : getAllJobRequestsForTag(tag);
+        Set<JobRequest> requests = mJobStorage.getAllJobRequests(tag, true);
         for (JobRequest request : requests) {
             if (cancelInner(request)) {
                 canceled++;
@@ -374,9 +423,11 @@ private int cancelAllInner(@Nullable String tag) {
      * Global switch to enable or disable logging.
      *
      * @param verbose Whether or not to print log messages.
+     * @deprecated Use {@link Config#setVerbose(boolean)} instead.
      */
+    @Deprecated
     public void setVerbose(boolean verbose) {
-        CatGlobal.setPackageEnabled(PACKAGE, verbose);
+        mConfig.setVerbose(verbose);
     }
 
     /**
@@ -414,17 +465,22 @@ public void removeJobCreator(JobCreator jobCreator) {
         return mContext;
     }
 
+    /*package*/ void destroy() {
+        synchronized (JobManager.class) {
+            instance = null;
+        }
+    }
+
     private JobProxy getJobProxy(JobRequest request) {
-        return request.getJobApi().getCachedProxy(mContext);
+        return getJobProxy(request.getJobApi());
+    }
+
+    private JobProxy getJobProxy(JobApi api) {
+        return api.getCachedProxy(mContext);
     }
 
     private void rescheduleTasksIfNecessary() {
-        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
-        final PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, JobManager.class.getName());
-        if (JobUtil.hasWakeLockPermission(mContext)) {
-            wakeLock.setReferenceCounted(false);
-            wakeLock.acquire(TimeUnit.SECONDS.toMillis(3));
-        }
+        final PowerManager.WakeLock wakeLock = WakeLockUtil.acquireWakeLock(mContext, JobManager.class.getName(), TimeUnit.MINUTES.toMillis(1));
 
         new Thread() {
             @Override
@@ -438,11 +494,19 @@ public void run() {
                      */
                     SystemClock.sleep(10_000L);
 
-                    Set<JobRequest> requests = JobManager.instance().getAllJobRequests();
+                    Set<JobRequest> requests = mJobStorage.getAllJobRequests(null, true);
 
                     int rescheduledCount = 0;
                     for (JobRequest request : requests) {
-                        if (!getJobProxy(request).isPlatformJobScheduled(request)) {
+                        boolean reschedule;
+                        if (request.isTransient()) {
+                            Job job = getJob(request.getJobId());
+                            reschedule = job == null;
+                        } else {
+                            reschedule = !getJobProxy(request).isPlatformJobScheduled(request);
+                        }
+
+                        if (reschedule) {
                             // update execution window
                             request.cancelAndEdit()
                                     .build()
@@ -455,16 +519,126 @@ public void run() {
                     CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
 
                 } finally {
-                    try {
-                        if (wakeLock.isHeld()) {
-                            wakeLock.release();
-                        }
-                    } catch (Exception e) {
-                        // just to make sure if the PowerManager crashes while acquiring a wake lock
-                        CAT.e(e);
-                    }
+                    WakeLockUtil.releaseWakeLock(wakeLock);
                 }
             }
         }.start();
     }
+
+    public final class Config {
+
+        private boolean mVerbose;
+        private boolean mGcmEnabled;
+        private boolean mAllowSmallerIntervals;
+
+        private Config() {
+            mVerbose = true;
+            mGcmEnabled = true;
+            mAllowSmallerIntervals = false;
+        }
+
+        /**
+         * @return Whether logging is enabled for this library. The default value is {@code true}.
+         */
+        public boolean isVerbose() {
+            return mVerbose;
+        }
+
+        /**
+         * Global switch to enable or disable logging.
+         *
+         * @param verbose Whether or not to print all log messages. The default value is {@code true}.
+         */
+        public void setVerbose(boolean verbose) {
+            if (mVerbose != verbose && PACKAGE != null) {
+                mVerbose = verbose;
+                CatGlobal.setPackageEnabled(PACKAGE.getName(), verbose);
+            }
+        }
+
+        /**
+         * @return Whether the GCM API is enabled. The API is only used if the required class dependency
+         * is found, the Google Play Services are available and this setting is {@code true}. The default
+         * value is {@code true}.
+         */
+        public boolean isGcmApiEnabled() {
+            return mGcmEnabled;
+        }
+
+        /**
+         * Programmatic switch to disable the GCM API. If {@code false}, then the {@link AlarmManager} will
+         * be used for Android 4 devices in all cases.
+         *
+         * @param enabled Whether the GCM API should be enabled or disabled. Note that the API is only used,
+         *                if the required class dependency is found, the Google Play Services are available
+         *                and this setting is {@code true}. The default value is {@code true}.
+         */
+        public void setGcmApiEnabled(boolean enabled) {
+            if (enabled == mGcmEnabled) {
+                return;
+            }
+
+            mGcmEnabled = enabled;
+            if (enabled) {
+                JobApi defaultApi = JobApi.getDefault(mContext, true);
+                if (!defaultApi.equals(getApi())) {
+                    setJobProxy(defaultApi);
+                    CAT.i("Changed default proxy to %s after enabled the GCM API", defaultApi);
+                }
+            } else {
+                JobApi defaultApi = JobApi.getDefault(mContext, false);
+                if (JobApi.GCM == getApi()) {
+                    setJobProxy(defaultApi);
+                    CAT.i("Changed default proxy to %s after disabling the GCM API", defaultApi);
+                }
+            }
+        }
+
+        /**
+         * Checks whether a smaller interval and flex are allowed for periodic jobs. That's helpful
+         * for testing purposes.
+         *
+         * @return Whether a smaller interval and flex than the minimum values are allowed for periodic jobs
+         * are allowed. The default value is {@code false}.
+         */
+        public boolean isAllowSmallerIntervalsForMarshmallow() {
+            return mAllowSmallerIntervals && Build.VERSION.SDK_INT < Build.VERSION_CODES.N;
+        }
+
+        /**
+         * Option to override the minimum period and minimum flex for periodic jobs. This is useful for testing
+         * purposes. This method only works for Android M and earlier. Later versions throw an exception.
+         *
+         * @param allowSmallerIntervals Whether a smaller interval and flex than the minimum values are allowed
+         *                              for periodic jobs are allowed. The default value is {@code false}.
+         */
+        public void setAllowSmallerIntervalsForMarshmallow(boolean allowSmallerIntervals) {
+            if (allowSmallerIntervals && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+                throw new IllegalStateException("This method is only allowed to call on Android M or earlier");
+            }
+            mAllowSmallerIntervals = allowSmallerIntervals;
+        }
+    }
+
+    private static void sendAddJobCreatorIntent(@NonNull Context context) {
+        Intent intent = new Intent(JobCreator.ACTION_ADD_JOB_CREATOR);
+        List<ResolveInfo> resolveInfos = context.getPackageManager().queryBroadcastReceivers(intent, 0);
+        String myPackage = context.getPackageName();
+
+        for (ResolveInfo resolveInfo : resolveInfos) {
+            ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (activityInfo == null || activityInfo.exported || !myPackage.equals(activityInfo.packageName)
+                    || TextUtils.isEmpty(activityInfo.name)) {
+                continue;
+            }
+
+            try {
+                JobCreator.AddJobCreatorReceiver receiver =
+                        (JobCreator.AddJobCreatorReceiver) Class.forName(activityInfo.name).newInstance();
+
+                receiver.addJobCreator(context, instance);
+            } catch (Exception ignored) {
+            }
+        }
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 96c0b32..20a1316 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -51,54 +51,97 @@
 
     void plantPeriodic(JobRequest request);
 
-    void cancel(JobRequest request);
+    void plantPeriodicFlexSupport(JobRequest request);
+
+    void cancel(int jobId);
 
     boolean isPlatformJobScheduled(JobRequest request);
 
     /*package*/ final class Common {
 
+        // see Google Guava: https://github.com/google/guava/blob/master/guava/src/com/google/common/math/LongMath.java
+        private static long checkedAdd(long a, long b) {
+            long result = a + b;
+            return checkNoOverflow(result, (a ^ b) < 0 | (a ^ result) >= 0);
+        }
+
+        private static long checkNoOverflow(long result, boolean condition) {
+            return condition ? result : Long.MAX_VALUE;
+        }
+
         public static long getStartMs(JobRequest request) {
-            return request.getStartMs() + request.getBackoffOffset();
+            return checkedAdd(request.getStartMs(), request.getBackoffOffset());
         }
 
         public static long getEndMs(JobRequest request) {
-            return request.getEndMs() + request.getBackoffOffset();
+            return checkedAdd(request.getEndMs(), request.getBackoffOffset());
         }
 
         public static long getAverageDelayMs(JobRequest request) {
-            return getStartMs(request) + (getEndMs(request) - getStartMs(request)) / 2;
+            return checkedAdd(getStartMs(request), (getEndMs(request) - getStartMs(request)) / 2);
+        }
+
+        public static long getStartMsSupportFlex(JobRequest request) {
+            return Math.max(1, request.getIntervalMs() - request.getFlexMs());
+        }
+
+        public static long getEndMsSupportFlex(JobRequest request) {
+            return request.getIntervalMs();
+        }
+
+        public static long getAverageDelayMsSupportFlex(JobRequest request) {
+            return checkedAdd(getStartMsSupportFlex(request), (getEndMsSupportFlex(request) - getStartMsSupportFlex(request)) / 2);
         }
 
         private final Context mContext;
         private final int mJobId;
         private final CatLog mCat;
 
-        public Common(Service service, int jobId) {
-            mContext = service;
+        private final JobManager mJobManager;
+
+        public Common(@NonNull Service service, int jobId) {
+            this(service, service.getClass().getSimpleName(), jobId);
+        }
+
+        /*package*/ Common(@NonNull Context context, String loggingTag, int jobId) {
+            mContext = context;
             mJobId = jobId;
-            mCat = new JobCat(service.getClass());
+            mCat = new JobCat(loggingTag);
+
+            mJobManager = JobManager.create(context);
         }
 
-        public JobRequest getPendingRequest() {
+        public JobRequest getPendingRequest(boolean cleanUpOrphanedJob) {
             // order is important for logging purposes
-            JobRequest request = JobManager.instance().getJobRequest(mJobId);
-            Job job = JobManager.instance().getJob(mJobId);
+            JobRequest request = mJobManager.getJobRequest(mJobId, true);
+            Job job = mJobManager.getJob(mJobId);
             boolean periodic = request != null && request.isPeriodic();
 
             if (job != null && !job.isFinished()) {
+                // that's probably a platform bug http://stackoverflow.com/questions/33235754/jobscheduler-posting-jobs-twice-not-expected
                 mCat.d("Job %d is already running, %s", mJobId, request);
+                // not necessary to clean up, the running instance will do that
                 return null;
 
             } else if (job != null && !periodic) {
                 mCat.d("Job %d already finished, %s", mJobId, request);
+                cleanUpOrphanedJob(cleanUpOrphanedJob);
                 return null;
 
             } else if (job != null && System.currentTimeMillis() - job.getFinishedTimeStamp() < 2_000) {
+                // that's probably a platform bug http://stackoverflow.com/questions/33235754/jobscheduler-posting-jobs-twice-not-expected
                 mCat.d("Job %d is periodic and just finished, %s", mJobId, request);
+                // don't clean up, periodic job
+                return null;
+
+            } else if (request != null && request.isTransient()) {
+                mCat.d("Request %d is transient, %s", mJobId, request);
+                // not necessary to clean up, the JobManager will do this for transient jobs
                 return null;
 
             } else if (request == null) {
                 mCat.d("Request for ID %d was null", mJobId);
+                cleanUpOrphanedJob(cleanUpOrphanedJob);
                 return null;
             }
 
@@ -109,11 +152,14 @@ public JobRequest getPendingRequest() {
         public Job.Result executeJobRequest(@NonNull JobRequest request) {
             long waited = System.currentTimeMillis() - request.getScheduledAt();
             String timeWindow;
-            if (JobApi.V_14.equals(request.getJobApi())) {
-                timeWindow = "delay " + JobUtil.timeToString(getAverageDelayMs(request));
-            } else {
+            if (request.isPeriodic()) {
+                timeWindow = String.format(Locale.US, "interval %s, flex %s", JobUtil.timeToString(request.getIntervalMs()),
+                        JobUtil.timeToString(request.getFlexMs()));
+            } else if (request.getJobApi().supportsExecutionWindow()) {
                 timeWindow = String.format(Locale.US, "start %s, end %s", JobUtil.timeToString(getStartMs(request)),
                         JobUtil.timeToString(getEndMs(request)));
+            } else {
+                timeWindow = "delay " + JobUtil.timeToString(getAverageDelayMs(request));
             }
 
             if (Looper.myLooper() == Looper.getMainLooper()) {
@@ -121,15 +167,18 @@ public JobRequest getPendingRequest() {
             }
 
             mCat.d("Run job, %s, waited %s, %s", request, JobUtil.timeToString(waited), timeWindow);
-            JobManager manager = JobManager.instance();
-            JobExecutor jobExecutor = manager.getJobExecutor();
+            JobExecutor jobExecutor = mJobManager.getJobExecutor();
+            Job job = null;
 
             try {
+                // create job first before setting it transient, avoids a race condition while rescheduling jobs
+                job = mJobManager.getJobCreatorHolder().createJob(request.getTag());
+
                 if (!request.isPeriodic()) {
-                    manager.getJobStorage().remove(request);
+                    request.setTransient(true);
                 }
 
-                Future<Job.Result> future = jobExecutor.execute(mContext, request, manager.getJobCreatorHolder());
+                Future<Job.Result> future = jobExecutor.execute(mContext, request, job);
                 if (future == null) {
                     return Job.Result.FAILURE;
                 }
@@ -142,13 +191,44 @@ public JobRequest getPendingRequest() {
             } catch (InterruptedException | ExecutionException e) {
                 mCat.e(e);
 
-                Job job = jobExecutor.getJob(mJobId);
                 if (job != null) {
                     job.cancel();
                     mCat.e("Canceled %s", request);
                 }
 
                 return Job.Result.FAILURE;
+
+            } finally {
+                if (!request.isPeriodic()) {
+                    mJobManager.getJobStorage().remove(request);
+
+                } else if (request.isFlexSupport()) {
+                    mJobManager.getJobStorage().remove(request); // remove, we store the new job in JobManager.schedule()
+                    request.reschedule(false, false);
+                }
+            }
+        }
+
+        private void cleanUpOrphanedJob(boolean cleanUp) {
+            if (cleanUp) {
+                cleanUpOrphanedJob(mContext, mJobId);
+            }
+        }
+
+        public static void cleanUpOrphanedJob(Context context, int jobId) {
+            /*
+             * That's necessary if the database was deleted and jobs (especially the JobScheduler) are still around.
+             * Then if a new job is being scheduled, it's possible that the new job has the ID of the old one. Here
+             * we make sure, that no job is left in the system.
+             */
+            for (JobApi jobApi : JobApi.values()) {
+                if (jobApi.isSupported(context)) {
+                    try {
+                        jobApi.getCachedProxy(context).cancel(jobId);
+                    } catch (Exception ignored) {
+                        // GCM API could crash if it's disabled, ignore crashes at this point and continue
+                    }
+                }
             }
         }
     }
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 02d9e0d..9f2ddbd 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -38,6 +38,7 @@
 import com.evernote.android.job.util.JobUtil;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
+import net.vrallev.android.cat.Cat;
 import net.vrallev.android.cat.CatLog;
 
 import java.util.concurrent.TimeUnit;
@@ -70,13 +71,55 @@
      */
     public static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.ANY;
 
+    /**
+     * The minimum interval of a periodic job. Specifying a smaller interval will result in an exception.
+     *
+     * <br>
+     * <br>
+     *
+     * This limit comes from the {@code JobScheduler} starting with Android Nougat. You can read
+     * <a href="https://github.com/evernote/android-job/blob/master/FAQ.md">here</a> more about
+     * the limit.
+     *
+     * @see Builder#setPeriodic(long)
+     * @see Builder#setPeriodic(long, long)
+     */
+    public static final long MIN_INTERVAL = TimeUnit.MINUTES.toMillis(15);
+
+    /**
+     * The minimum flex of a periodic job. Specifying a smaller flex will result in an exception.
+     *
+     * <br>
+     * <br>
+     *
+     * This limit comes from the {@code JobScheduler} starting with Android Nougat. You can read
+     * <a href="https://github.com/evernote/android-job/blob/master/FAQ.md">here</a> more about
+     * the limit.
+     *
+     * @see Builder#setPeriodic(long, long)
+     */
+    public static final long MIN_FLEX = TimeUnit.MINUTES.toMillis(5);
+
+    private static final long WINDOW_THRESHOLD_WARNING = Long.MAX_VALUE / 3;
+    private static final long WINDOW_THRESHOLD_MAX = (Long.MAX_VALUE / 3) * 2;
+
     private static final CatLog CAT = new JobCat("JobRequest");
 
+    /*package*/ static long getMinInterval() {
+        return JobManager.instance().getConfig().isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.MINUTES.toMillis(1) : MIN_INTERVAL;
+    }
+
+    /*package*/ static long getMinFlex() {
+        return JobManager.instance().getConfig().isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.SECONDS.toMillis(30) : MIN_FLEX;
+    }
+
     private final Builder mBuilder;
     private final JobApi mJobApi;
 
     private int mNumFailures;
     private long mScheduledAt;
+    private boolean mTransient;
+    private boolean mFlexSupport;
 
     private JobRequest(Builder builder) {
         mBuilder = builder;
@@ -151,6 +194,16 @@ public long getIntervalMs() {
         return mBuilder.mIntervalMs;
     }
 
+    /**
+     * Flex time for this job. Only valid if this is a periodic job. The job can execute
+     * at any time in a window of flex length at the end of the period.
+     *
+     * @return How close to the end of an interval a periodic job is allowed to run.
+     */
+    public long getFlexMs() {
+        return mBuilder.mFlexMs;
+    }
+
     /**
      * @return If {@code true}, then all requirements are checked before the job runs. If one requirement
      * isn't met, then the job is rescheduled right away.
@@ -245,7 +298,19 @@ public boolean isExact() {
         mScheduledAt = timeStamp;
     }
 
-    /*package*/ long getScheduledAt() {
+    /**
+     * Returns the time when this job was scheduled.
+     * <br>
+     * <br>
+     * <b>Note</b> that this value is only useful for non-periodic jobs. The time for periodic
+     * jobs is inconsistent. Sometimes it will return the value when the periodic job was scheduled
+     * for the first time and sometimes it will be updated after each period. The reason for this
+     * limitation is the flex parameter, which was backported to older Android versions. You can
+     * only rely on this value during the first interval of the periodic job.
+     *
+     * @return The time when the job was scheduled.
+     */
+    public long getScheduledAt() {
         return mScheduledAt;
     }
 
@@ -253,6 +318,27 @@ public boolean isExact() {
         return mNumFailures;
     }
 
+    /**
+     * Only non-periodic jobs can be in a transient state. The transient state means, that
+     * the job is running and is about to be removed. A job can get stuck in a transient state,
+     * if the app terminates while the job is running. Then the job isn't scheduled anymore, but
+     * entry is still in the database. Since the job didn't finish successfully, reschedule
+     * the job if necessary and treat it as it wouldn't have run, yet.
+     *
+     * @return Whether the job is in a transient state.
+     */
+    /*package*/ boolean isTransient() {
+        return mTransient;
+    }
+
+    /*package*/ boolean isFlexSupport() {
+        return mFlexSupport;
+    }
+
+    /*package*/ void setFlexSupport(boolean flexSupport) {
+        mFlexSupport = flexSupport;
+    }
+
     /**
      * Convenience method. Internally it calls {@link JobManager#schedule(JobRequest)}
      * and {@link #getJobId()} for this request.
@@ -275,6 +361,7 @@ public int schedule() {
     public Builder cancelAndEdit() {
         JobManager.instance().cancel(getJobId());
         Builder builder = new Builder(this, false);
+        mTransient = false;
 
         if (!isPeriodic()) {
             long offset = System.currentTimeMillis() - mScheduledAt;
@@ -285,8 +372,8 @@ public Builder cancelAndEdit() {
         return builder;
     }
 
-    /*package*/ int reschedule(boolean failure) {
-        JobRequest newRequest = new Builder(this, true).build();
+    /*package*/ int reschedule(boolean failure, boolean newJob) {
+        JobRequest newRequest = new Builder(this, newJob).build();
         if (failure) {
             newRequest.mNumFailures = mNumFailures + 1;
         }
@@ -300,11 +387,20 @@ public Builder cancelAndEdit() {
         JobManager.instance().getJobStorage().update(this, contentValues);
     }
 
+    /*package*/ void setTransient(boolean isTransient) {
+        mTransient = isTransient;
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
+        JobManager.instance().getJobStorage().update(this, contentValues);
+    }
+
     /*package*/ ContentValues toContentValues() {
         ContentValues contentValues = new ContentValues();
         mBuilder.fillContentValues(contentValues);
         contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mNumFailures);
         contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, mScheduledAt);
+        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
+        contentValues.put(JobStorage.COLUMN_FLEX_SUPPORT, mFlexSupport);
         return contentValues;
     }
 
@@ -312,6 +408,8 @@ public Builder cancelAndEdit() {
         JobRequest request = new Builder(cursor).build();
         request.mNumFailures = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
         request.mScheduledAt = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_SCHEDULED_AT));
+        request.mTransient = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_TRANSIENT)) > 0;
+        request.mFlexSupport = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_FLEX_SUPPORT)) > 0;
 
         JobPreconditions.checkArgumentNonnegative(request.mNumFailures, "failure count can't be negative");
         JobPreconditions.checkArgumentNonnegative(request.mScheduledAt, "scheduled at can't be negative");
@@ -354,6 +452,7 @@ public String toString() {
         private BackoffPolicy mBackoffPolicy;
 
         private long mIntervalMs;
+        private long mFlexMs;
 
         private boolean mRequirementsEnforced;
         private boolean mRequiresCharging;
@@ -405,6 +504,7 @@ private Builder(JobRequest request, boolean createId) {
             mBackoffPolicy = request.getBackoffPolicy();
 
             mIntervalMs = request.getIntervalMs();
+            mFlexMs = request.getFlexMs();
 
             mRequirementsEnforced = request.requirementsEnforced();
             mRequiresCharging = request.requiresCharging();
@@ -434,6 +534,7 @@ private Builder(Cursor cursor) throws Exception {
             }
 
             mIntervalMs = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_INTERVAL_MS));
+            mFlexMs = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_FLEX_MS));
 
             mRequirementsEnforced = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIREMENTS_ENFORCED)) > 0;
             mRequiresCharging = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIRES_CHARGING)) > 0;
@@ -462,6 +563,7 @@ private void fillContentValues(ContentValues contentValues) {
             contentValues.put(JobStorage.COLUMN_BACKOFF_POLICY, mBackoffPolicy.toString());
 
             contentValues.put(JobStorage.COLUMN_INTERVAL_MS, mIntervalMs);
+            contentValues.put(JobStorage.COLUMN_FLEX_MS, mFlexMs);
 
             contentValues.put(JobStorage.COLUMN_REQUIREMENTS_ENFORCED, mRequirementsEnforced);
             contentValues.put(JobStorage.COLUMN_REQUIRES_CHARGING, mRequiresCharging);
@@ -483,12 +585,44 @@ private void fillContentValues(ContentValues contentValues) {
          * {@link #setPeriodic(long)} or {@link #setExact(long)}. For those types jobs it doesn't
          * make sense to have a time window.
          *
+         * <br>
+         * <br>
+         *
+         * The window specified is treated as offset from now, e.g. the job will run between
+         * {@code System.currentTimeMillis() + startMs} and
+         * {@code System.currentTimeMillis() + endMs}.
+         *
+         * <br>
+         * <br>
+         *
+         * The maximum value for each argument is {@code Long.MAX_VALUE / 3 * 2} (about 53_375_995_583 days).
+         * Otherwise some APIs schedule the job immediately. No exception is thrown if an argument is greater
+         * than the maximum value, the arguments are silently being clamped.
+         *
+         * <br>
+         * <br>
+         *
+         * <b>NOTE:</b> It's not recommended to have such big execution windows. The {@code AlarmManager} used
+         * as fallback API doesn't allow setting a start date. Although being inexact, the execution time is
+         * the arithmetic average of {@code startMs} and {@code endMs}. The result could be that your job never
+         * runs on pre Android 5.0 devices, if one argument is too large.
+         *
          * @param startMs Earliest point from which your task is eligible to run.
          * @param endMs Latest point at which your task must be run.
          */
         public Builder setExecutionWindow(long startMs, long endMs) {
             mStartMs = JobPreconditions.checkArgumentPositive(startMs, "startMs must be greater than 0");
             mEndMs = JobPreconditions.checkArgumentInRange(endMs, startMs, Long.MAX_VALUE, "endMs");
+
+            if (mStartMs > WINDOW_THRESHOLD_MAX) {
+                Cat.i("startMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mStartMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                mStartMs = WINDOW_THRESHOLD_MAX;
+            }
+            if (mEndMs > WINDOW_THRESHOLD_MAX) {
+                Cat.i("endMs reduced from %d days to %d days", TimeUnit.MILLISECONDS.toDays(mEndMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                mEndMs = WINDOW_THRESHOLD_MAX;
+            }
+
             return this;
         }
 
@@ -617,17 +751,36 @@ public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {
          * The default value is set to {@code false}. Internally an exact job is always using the
          * {@link AlarmManager}.
          *
+         * <br>
+         * <br>
+         *
+         * The milliseconds specified are treated as offset from now, e.g. the job will run at
+         * {@code System.currentTimeMillis() + exactMs}.
+         *
+         * <br>
+         * <br>
+         *
+         * The maximum value of the argument is {@code Long.MAX_VALUE / 3 * 2} (about 53_375_995_583 days).
+         * No exception is thrown if the argument is greater than the maximum value, the argument is
+         * silently being clamped.
+         *
          * @param exactMs The exact offset when the job should run from when the job was scheduled.
          * @see AlarmManager#setExact(int, long, android.app.PendingIntent)
          * @see AlarmManager#setExactAndAllowWhileIdle(int, long, android.app.PendingIntent)
          */
         public Builder setExact(long exactMs) {
             mExact = true;
+            if (exactMs > WINDOW_THRESHOLD_MAX) {
+                Cat.i("exactMs clamped from %d days to %d days", TimeUnit.MILLISECONDS.toDays(exactMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));
+                exactMs = WINDOW_THRESHOLD_MAX;
+            }
+
             return setExecutionWindow(exactMs, exactMs);
         }
 
         /**
-         * This job should run one time during each interval. As default a job isn't periodic.
+         * Specify that this job should recur with the provided interval, not more than once per period. As
+         * default a job isn't periodic.
          *
          * <br>
          * <br>
@@ -636,10 +789,33 @@ public Builder setExact(long exactMs) {
          * with this function. Since {@link Job.Result#RESCHEDULE} is ignored for periodic jobs,
          * setting a back-off criteria is illegal as well.
          *
-         * @param intervalMs The job should at most once every {@code intervalMs}.
+         * @param intervalMs The job should run at most once every {@code intervalMs}. The minimum value is {@code 15min}.
          */
         public Builder setPeriodic(long intervalMs) {
-            mIntervalMs = JobPreconditions.checkArgumentInRange(intervalMs, 60_000L, Long.MAX_VALUE, "intervalMs");
+            return setPeriodic(intervalMs, intervalMs);
+        }
+
+        /**
+         * Specify that this job should recur with the provided interval and flex, not more than once per period.
+         * The flex controls how close to the end of a period the job can run. For example, specifying an interval
+         * of 60 seconds and a flex of 15 seconds will allow the scheduler to determine the best moment between
+         * the 45th and 60th second at which to execute your job.
+         *
+         * <br>
+         * <br>
+         *
+         * As default a job isn't periodic. It isn't allowed to specify a time window for a periodic job.
+         * Instead you set an interval with this function. Since {@link Job.Result#RESCHEDULE} is ignored for
+         * periodic jobs, setting a back-off criteria is illegal as well.
+         *
+         * @param intervalMs The job should run at most once every {@code intervalMs}. The minimum value is {@code 15min}.
+         * @param flexMs How close to the end of the period the job should run. The minimum value is {@code 5min}.
+         * @see #MIN_INTERVAL
+         * @see #MIN_FLEX
+         */
+        public Builder setPeriodic(long intervalMs, long flexMs) {
+            mIntervalMs = JobPreconditions.checkArgumentInRange(intervalMs, getMinInterval(), Long.MAX_VALUE, "intervalMs");
+            mFlexMs = JobPreconditions.checkArgumentInRange(flexMs, getMinFlex(), mIntervalMs, "flexMs");
             return this;
         }
 
@@ -673,7 +849,7 @@ public Builder setBackoffCriteria(long backoffMs, @NonNull BackoffPolicy backoff
          * @param persisted If {@code true} the job is scheduled after a reboot.
          */
         public Builder setPersisted(boolean persisted) {
-            if (!JobUtil.hasBootPermission(JobManager.instance().getContext())) {
+            if (persisted && !JobUtil.hasBootPermission(JobManager.instance().getContext())) {
                 throw new IllegalStateException("Does not have RECEIVE_BOOT_COMPLETED permission, which is mandatory for this feature");
             }
             mPersisted = persisted;
@@ -704,7 +880,14 @@ public JobRequest build() {
             JobPreconditions.checkNotNull(mNetworkType);
 
             if (mIntervalMs > 0) {
-                JobPreconditions.checkArgumentInRange(mIntervalMs, 60_000L, Long.MAX_VALUE, "intervalMs");
+                JobPreconditions.checkArgumentInRange(mIntervalMs, getMinInterval(), Long.MAX_VALUE, "intervalMs");
+                JobPreconditions.checkArgumentInRange(mFlexMs, getMinFlex(), mIntervalMs, "flexMs");
+
+                if (mIntervalMs < MIN_INTERVAL || mFlexMs < MIN_FLEX) {
+                    // this means the debug flag is set to true
+                    CAT.w("AllowSmallerIntervals enabled, this will crash on Android N and later, interval %d (minimum is %d), flex %d (minimum is %d)",
+                            mIntervalMs, MIN_INTERVAL, mFlexMs, MIN_FLEX);
+                }
             }
 
             if (mExact && mIntervalMs > 0) {
@@ -728,6 +911,10 @@ public JobRequest build() {
                         + "setBackoffCriteria() with setPeriodic() is an error.");
             }
 
+            if (mIntervalMs <= 0 && (mStartMs > WINDOW_THRESHOLD_WARNING || mEndMs > WINDOW_THRESHOLD_WARNING)) {
+                Cat.w("Attention: your execution window is too large. This could result in undesired behavior, see https://github.com/evernote/android-job/blob/master/FAQ.md");
+            }
+
             return new JobRequest(this);
         }
 
@@ -770,6 +957,10 @@ public int hashCode() {
         /**
          * Network must be connected and unmetered.
          */
-        UNMETERED
+        UNMETERED,
+        /**
+         * Network must be connected and not roaming, but can be metered.
+         */
+        NOT_ROAMING
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index 56dece7..8f93e5b 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -25,12 +25,14 @@
  */
 package com.evernote.android.job;
 
+import android.annotation.SuppressLint;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.support.annotation.Nullable;
 import android.support.v4.util.LruCache;
 import android.text.TextUtils;
 
@@ -52,11 +54,11 @@
 
     private static final String JOB_ID_COUNTER = "JOB_ID_COUNTER";
 
-    private static final String PREF_FILE_NAME = "evernote_jobs";
-    private static final String DATABASE_NAME = PREF_FILE_NAME + ".db";
-    private static final int DATABASE_VERSION = 1;
+    public static final String PREF_FILE_NAME = "evernote_jobs";
+    public static final String DATABASE_NAME = PREF_FILE_NAME + ".db";
+    public static final int DATABASE_VERSION = 3;
 
-    private static final String JOB_TABLE_NAME = "jobs";
+    public static final String JOB_TABLE_NAME = "jobs";
 
     public static final String COLUMN_ID = "_id";
     public static final String COLUMN_TAG = "tag";
@@ -74,15 +76,21 @@
     public static final String COLUMN_PERSISTED = "persisted";
     public static final String COLUMN_NUM_FAILURES = "numFailures";
     public static final String COLUMN_SCHEDULED_AT = "scheduledAt";
+    public static final String COLUMN_TRANSIENT = "isTransient";
+    public static final String COLUMN_FLEX_MS = "flexMs";
+    public static final String COLUMN_FLEX_SUPPORT = "flexSupport";
 
     private static final int CACHE_SIZE = 30;
 
+    private static final String WHERE_NOT_TRANSIENT = "ifnull(" + COLUMN_TRANSIENT + ", 0)<=0";
+
     private final SharedPreferences mPreferences;
     private final JobCacheId mCacheId;
 
     private final AtomicInteger mJobCounter;
 
     private final JobOpenHelper mDbHelper;
+    private SQLiteDatabase mDatabase;
 
     public JobStorage(Context context) {
         mPreferences = context.getSharedPreferences(PREF_FILE_NAME, Context.MODE_PRIVATE);
@@ -104,7 +112,7 @@ public synchronized void put(final JobRequest request) {
     public synchronized void update(JobRequest request, ContentValues contentValues) {
         updateRequestInCache(request);
         try {
-            mDbHelper.getWritableDatabase().update(JOB_TABLE_NAME, contentValues, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
+            getDatabase().update(JOB_TABLE_NAME, contentValues, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
         } catch (Exception e) {
             CAT.e(e, "could not update %s", request);
         }
@@ -118,22 +126,25 @@ public synchronized JobRequest get(int id) {
         return mCacheId.get(id);
     }
 
-    public synchronized Set<JobRequest> getAllJobRequests() {
-        return getAllJobRequestsForTag(null);
-    }
-
-    public synchronized Set<JobRequest> getAllJobRequestsForTag(String tag) {
+    public synchronized Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeTransient) {
         Set<JobRequest> result = new HashSet<>();
 
         Cursor cursor = null;
         try {
-            SQLiteDatabase database = mDbHelper.getWritableDatabase();
+            String where; // filter transient requests
+            String[] args;
             if (TextUtils.isEmpty(tag)) {
-                cursor = database.query(JOB_TABLE_NAME, null, null, null, null, null, null);
+                where = includeTransient ? null : WHERE_NOT_TRANSIENT;
+                args = null;
             } else {
-                cursor = database.query(JOB_TABLE_NAME, null, COLUMN_TAG + "=?", new String[]{tag}, null, null, null);
+                where = includeTransient ? "" : (WHERE_NOT_TRANSIENT + " AND ");
+                where += COLUMN_TAG + "=?";
+                args = new String[]{tag};
             }
 
+            cursor = getDatabase().query(JOB_TABLE_NAME, null, where, args, null, null, null);
+
+            @SuppressLint("UseSparseArrays")
             HashMap<Integer, JobRequest> cachedRequests = new HashMap<>(mCacheId.snapshot());
 
             while (cursor.moveToNext()) {
@@ -160,7 +171,7 @@ public synchronized JobRequest get(int id) {
     public synchronized void remove(JobRequest request) {
         mCacheId.remove(request.getJobId());
         try {
-            mDbHelper.getWritableDatabase().delete(JOB_TABLE_NAME, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
+            getDatabase().delete(JOB_TABLE_NAME, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
         } catch (Exception e) {
             CAT.e(e, "could not delete %s", request);
         }
@@ -168,6 +179,16 @@ public synchronized void remove(JobRequest request) {
 
     public synchronized int nextJobId() {
         int id = mJobCounter.incrementAndGet();
+
+        if (id < 0) {
+            /*
+             * An overflow occurred. It'll happen rarely, but just in case reset the ID and start from scratch.
+             * Existing jobs will be treated as orphaned and will be overwritten.
+             */
+            id = 1;
+            mJobCounter.set(id);
+        }
+
         mPreferences.edit()
                 .putInt(JOB_ID_COUNTER, id)
                 .apply();
@@ -178,16 +199,21 @@ public synchronized int nextJobId() {
     private void store(JobRequest request) {
         try {
             ContentValues contentValues = request.toContentValues();
-            mDbHelper.getWritableDatabase().insert(JOB_TABLE_NAME, null, contentValues);
+            getDatabase().insert(JOB_TABLE_NAME, null, contentValues);
         } catch (Exception e) {
             CAT.e(e, "could not store %s", request);
         }
     }
 
-    private JobRequest load(int id) {
+    private JobRequest load(int id, boolean includeTransient) {
         Cursor cursor = null;
         try {
-            cursor = mDbHelper.getWritableDatabase().query(JOB_TABLE_NAME, null, COLUMN_ID + "=?", new String[]{String.valueOf(id)}, null, null, null);
+            String where = COLUMN_ID + "=?";
+            if (!includeTransient) {
+                where += " AND " + COLUMN_TRANSIENT + "<=0";
+            }
+
+            cursor = getDatabase().query(JOB_TABLE_NAME, null, where, new String[]{String.valueOf(id)}, null, null, null);
             if (cursor.moveToFirst()) {
                 return JobRequest.fromCursor(cursor);
             }
@@ -204,6 +230,17 @@ private JobRequest load(int id) {
         return null;
     }
 
+    private SQLiteDatabase getDatabase() {
+        if (mDatabase == null) {
+            synchronized (this) {
+                if (mDatabase == null) {
+                    mDatabase = mDbHelper.getWritableDatabase();
+                }
+            }
+        }
+        return mDatabase;
+    }
+
     private class JobCacheId extends LruCache<Integer, JobRequest> {
 
         public JobCacheId() {
@@ -212,7 +249,7 @@ public JobCacheId() {
 
         @Override
         protected JobRequest create(Integer id) {
-            return load(id);
+            return load(id, true);
         }
     }
 
@@ -229,7 +266,20 @@ public void onCreate(SQLiteDatabase db) {
 
         @Override
         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            // not needed at the moment
+            while (oldVersion < newVersion) {
+                switch (oldVersion) {
+                    case 1:
+                        upgradeFrom1To2(db);
+                        oldVersion++;
+                        break;
+                    case 2:
+                        upgradeFrom2To3(db);
+                        oldVersion++;
+                        break;
+                    default:
+                        throw new IllegalStateException("not implemented");
+                }
+            }
         }
 
         private void createJobTable(SQLiteDatabase db) {
@@ -249,7 +299,27 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXTRAS + " text, "
                     + COLUMN_PERSISTED + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
-                    + COLUMN_SCHEDULED_AT + " integer);");
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + COLUMN_TRANSIENT + " integer, "
+                    + COLUMN_FLEX_MS + " integer, "
+                    + COLUMN_FLEX_SUPPORT + " integer);");
+        }
+
+        private void upgradeFrom1To2(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+        }
+
+        private void upgradeFrom2To3(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_MS + " integer;");
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_SUPPORT + " integer;");
+
+            // adjust interval to minimum value if necessary
+            ContentValues contentValues = new ContentValues();
+            contentValues.put(COLUMN_INTERVAL_MS, JobRequest.MIN_INTERVAL);
+            db.update(JOB_TABLE_NAME, contentValues, COLUMN_INTERVAL_MS + ">0 AND " + COLUMN_INTERVAL_MS + "<" + JobRequest.MIN_INTERVAL, new String[0]);
+
+            // copy interval into flex column, that's the default value and the flex support mode is not required
+            db.execSQL("update " + JOB_TABLE_NAME + " set " + COLUMN_FLEX_MS + " = " + COLUMN_INTERVAL_MS + ";");
         }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/WakeLockUtil.java b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
new file mode 100644
index 0000000..18bd0d1
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
@@ -0,0 +1,61 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.os.PowerManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.JobUtil;
+
+import net.vrallev.android.cat.CatLog;
+
+/**
+ * @author rwondratschek
+ */
+/*package*/ final class WakeLockUtil {
+
+    private static final CatLog CAT = new JobCat("WakeLockUtil");
+
+    private WakeLockUtil() {
+        // no op
+    }
+
+    @Nullable
+    public static PowerManager.WakeLock acquireWakeLock(@NonNull Context context, @NonNull String tag, long timeoutMillis) {
+        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+
+        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, tag);
+        wakeLock.setReferenceCounted(false);
+
+        return acquireWakeLock(context, wakeLock, timeoutMillis) ? wakeLock : null;
+    }
+
+    public static boolean acquireWakeLock(@NonNull Context context, @Nullable PowerManager.WakeLock wakeLock, long timeoutMillis) {
+        if (wakeLock != null && !wakeLock.isHeld() && JobUtil.hasWakeLockPermission(context)) {
+            // Even if we have the permission, some devices throw an exception in the try block nonetheless,
+            // I'm looking at you, Samsung SM-T805
+
+            try {
+                wakeLock.acquire(timeoutMillis);
+                return true;
+            } catch (Exception e) {
+                // saw an NPE on rooted Galaxy Nexus Android 4.1.1
+                // android.os.IPowerManager$Stub$Proxy.acquireWakeLock(IPowerManager.java:288)
+                CAT.e(e);
+            }
+        }
+        return false;
+    }
+
+    public static void releaseWakeLock(@Nullable PowerManager.WakeLock wakeLock) {
+        try {
+            if (wakeLock != null && wakeLock.isHeld()) {
+                wakeLock.release();
+            }
+        } catch (Exception e) {
+            // just to make sure if the PowerManager crashes while acquiring a wake lock
+            CAT.e(e);
+        }
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
index a543e96..bd037cb 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
@@ -60,42 +60,54 @@ public JobProxyGcm(Context context) {
 
     @Override
     public void plantOneOff(JobRequest request) {
-        OneoffTask task = new OneoffTask.Builder()
-                .setTag(createTag(request))
-                .setService(PlatformGcmService.class)
-                .setUpdateCurrent(true)
-                .setExecutionWindow(Common.getStartMs(request) / 1_000, Common.getEndMs(request) / 1_000)
-                .setRequiredNetwork(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(request.isPersisted())
-                .setRequiresCharging(request.requiresCharging())
+        long startMs = Common.getStartMs(request);
+        long startSeconds = startMs / 1_000;
+
+        long endMs = Common.getEndMs(request);
+        long endSeconds = Math.max(endMs / 1_000, startSeconds + 1); // endSeconds must be greater than startSeconds
+
+        OneoffTask task = prepareBuilder(new OneoffTask.Builder(), request)
+                .setExecutionWindow(startSeconds, endSeconds)
                 .build();
 
         mGcmNetworkManager.schedule(task);
 
-        CAT.d("Scheduled OneoffTask, %s, start %s, end %s", request,
-                JobUtil.timeToString(Common.getStartMs(request)), JobUtil.timeToString(Common.getEndMs(request)));
+        CAT.d("Scheduled OneoffTask, %s, start %s, end %s", request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs));
     }
 
     @Override
     public void plantPeriodic(JobRequest request) {
-        PeriodicTask task = new PeriodicTask.Builder()
-                .setTag(createTag(request))
-                .setService(PlatformGcmService.class)
-                .setUpdateCurrent(true)
+        PeriodicTask task = prepareBuilder(new PeriodicTask.Builder(), request)
                 .setPeriod(request.getIntervalMs() / 1_000)
-                .setRequiredNetwork(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(request.isPersisted())
-                .setRequiresCharging(request.requiresCharging())
+                .setFlex(request.getFlexMs() / 1_000)
                 .build();
 
         mGcmNetworkManager.schedule(task);
 
-        CAT.d("Scheduled PeriodicTask, %s, interval %s", request, JobUtil.timeToString(request.getIntervalMs()));
+        CAT.d("Scheduled PeriodicTask, %s, interval %s, flex %s", request, JobUtil.timeToString(request.getIntervalMs()),
+                JobUtil.timeToString(request.getFlexMs()));
     }
 
     @Override
-    public void cancel(JobRequest request) {
-        mGcmNetworkManager.cancelTask(createTag(request), PlatformGcmService.class);
+    public void plantPeriodicFlexSupport(JobRequest request) {
+        CAT.w("plantPeriodicFlexSupport called although flex is supported");
+
+        long startMs = Common.getStartMsSupportFlex(request);
+        long endMs = Common.getEndMsSupportFlex(request);
+
+        OneoffTask task = prepareBuilder(new OneoffTask.Builder(), request)
+                .setExecutionWindow(startMs / 1_000, endMs / 1_000)
+                .build();
+
+        mGcmNetworkManager.schedule(task);
+
+        CAT.d("Scheduled periodic (flex support), %s, start %s, end %s, flex %s", request, JobUtil.timeToString(startMs),
+                JobUtil.timeToString(endMs), JobUtil.timeToString(request.getFlexMs()));
+    }
+
+    @Override
+    public void cancel(int jobId) {
+        mGcmNetworkManager.cancelTask(createTag(jobId), PlatformGcmService.class);
     }
 
     @Override
@@ -104,8 +116,22 @@ public boolean isPlatformJobScheduled(JobRequest request) {
         return true;
     }
 
+    protected <T extends Task.Builder> T prepareBuilder(T builder, JobRequest request) {
+        builder.setTag(createTag(request))
+                .setService(PlatformGcmService.class)
+                .setUpdateCurrent(true)
+                .setRequiredNetwork(convertNetworkType(request.requiredNetworkType()))
+                .setPersisted(request.isPersisted())
+                .setRequiresCharging(request.requiresCharging());
+        return builder;
+    }
+
     protected String createTag(JobRequest request) {
-        return String.valueOf(request.getJobId());
+        return createTag(request.getJobId());
+    }
+
+    protected String createTag(int jobId) {
+        return String.valueOf(jobId);
     }
 
     protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
@@ -116,6 +142,8 @@ protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
                 return Task.NETWORK_STATE_CONNECTED;
             case UNMETERED:
                 return Task.NETWORK_STATE_UNMETERED;
+            case NOT_ROAMING:
+                return Task.NETWORK_STATE_UNMETERED; // use as fallback, NOT_ROAMING not supported
             default:
                 throw new IllegalStateException("not implemented");
         }
diff --git a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
index d199a7d..0d069a2 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
@@ -25,13 +25,12 @@
  */
 package com.evernote.android.job.gcm;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.TaskParams;
-
 import com.evernote.android.job.Job;
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobRequest;
+import com.google.android.gms.gcm.GcmNetworkManager;
+import com.google.android.gms.gcm.GcmTaskService;
+import com.google.android.gms.gcm.TaskParams;
 
 /**
  * @author rwondratschek
@@ -43,7 +42,7 @@ public int onRunTask(TaskParams taskParams) {
         int jobId = Integer.parseInt(taskParams.getTag());
         JobProxy.Common common = new JobProxy.Common(this, jobId);
 
-        JobRequest request = common.getPendingRequest();
+        JobRequest request = common.getPendingRequest(true);
         if (request == null) {
             return GcmNetworkManager.RESULT_FAILURE;
         }
diff --git a/library/src/main/java/com/evernote/android/job/util/Device.java b/library/src/main/java/com/evernote/android/job/util/Device.java
index 0f75494..05935a7 100644
--- a/library/src/main/java/com/evernote/android/job/util/Device.java
+++ b/library/src/main/java/com/evernote/android/job/util/Device.java
@@ -34,7 +34,9 @@
 import android.os.BatteryManager;
 import android.os.Build;
 import android.os.PowerManager;
+import android.support.annotation.NonNull;
 import android.support.v4.net.ConnectivityManagerCompat;
+import android.telephony.TelephonyManager;
 
 import com.evernote.android.job.JobRequest;
 
@@ -81,6 +83,7 @@ public static boolean isIdle(Context context) {
         }
     }
 
+    @NonNull
     public static JobRequest.NetworkType getNetworkType(Context context) {
         ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
         NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
@@ -88,7 +91,12 @@ public static boolean isIdle(Context context) {
             return JobRequest.NetworkType.ANY;
         }
 
+        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        if (telephonyManager != null && telephonyManager.isNetworkRoaming()) {
+            return JobRequest.NetworkType.CONNECTED;
+        }
+
         boolean metered = ConnectivityManagerCompat.isActiveNetworkMetered(connectivityManager);
-        return metered ? JobRequest.NetworkType.CONNECTED : JobRequest.NetworkType.UNMETERED;
+        return metered ? JobRequest.NetworkType.NOT_ROAMING : JobRequest.NetworkType.UNMETERED;
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java b/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
index b66bb9c..1d9f1c1 100644
--- a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
+++ b/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
@@ -1,13 +1,18 @@
 package com.evernote.android.job.util;
 
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 
+import com.evernote.android.job.gcm.JobProxyGcm;
 import com.evernote.android.job.gcm.PlatformGcmService;
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GoogleApiAvailability;
 
+import net.vrallev.android.cat.Cat;
+
 import java.util.List;
 
 /**
@@ -21,6 +26,7 @@
     private static final boolean GCM_IN_CLASSPATH;
 
     private static int gcmServiceAvailable = -1;
+    private static boolean checkedServiceEnabled;
 
     static {
         boolean gcmInClasspath;
@@ -34,9 +40,21 @@
     }
 
     public static boolean isGcmApiSupported(Context context) {
-        return GCM_IN_CLASSPATH
-                && GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context) == ConnectionResult.SUCCESS
-                && isGcmServiceRegistered(context) == ConnectionResult.SUCCESS;
+        try {
+            if (!checkedServiceEnabled) {
+                checkedServiceEnabled = true;
+                setServiceEnabled(context, GCM_IN_CLASSPATH);
+            }
+
+            return GCM_IN_CLASSPATH
+                    && GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context) == ConnectionResult.SUCCESS
+                    && isGcmServiceRegistered(context) == ConnectionResult.SUCCESS;
+        } catch (Throwable t) {
+            // seeing sometimes a DeadObjectException, return false, we can't do anything in this case
+            // still sometimes seeing a NoClassDefFoundError here
+            Cat.w(t);
+            return false;
+        }
     }
 
     private static int isGcmServiceRegistered(Context context) {
@@ -78,6 +96,38 @@ private static boolean hasPermission(List<ResolveInfo> resolveInfos) {
         return false;
     }
 
+    private static void setServiceEnabled(Context context, boolean enabled) {
+        try {
+            PackageManager packageManager = context.getPackageManager();
+
+            // use a string, the class object probably cannot be instantiated
+            String className = JobProxyGcm.class.getPackage().getName() + ".PlatformGcmService";
+            ComponentName component = new ComponentName(context, className);
+
+            int componentEnabled = packageManager.getComponentEnabledSetting(component);
+            switch (componentEnabled) {
+                case PackageManager.COMPONENT_ENABLED_STATE_ENABLED:
+                    if (!enabled) {
+                        packageManager.setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
+                        Cat.i("GCM service disabled");
+                    }
+                    break;
+
+                case PackageManager.COMPONENT_ENABLED_STATE_DEFAULT: // default is disable
+                case PackageManager.COMPONENT_ENABLED_STATE_DISABLED:
+                    if (enabled) {
+                        packageManager.setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
+                        Cat.i("GCM service enabled");
+                    }
+                    break;
+            }
+
+        } catch (Throwable t) {
+            // just in case, don't let the app crash with each restart
+            Cat.e(t);
+        }
+    }
+
     private GcmAvailableHelper() {
         // no op
     }
diff --git a/library/src/main/java/com/evernote/android/job/util/JobApi.java b/library/src/main/java/com/evernote/android/job/util/JobApi.java
index b7c5661..4b3978e 100644
--- a/library/src/main/java/com/evernote/android/job/util/JobApi.java
+++ b/library/src/main/java/com/evernote/android/job/util/JobApi.java
@@ -29,11 +29,15 @@
 import android.app.job.JobScheduler;
 import android.content.Context;
 import android.os.Build;
+import android.support.annotation.NonNull;
 
+import com.evernote.android.job.JobManager;
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.gcm.JobProxyGcm;
 import com.evernote.android.job.v14.JobProxy14;
+import com.evernote.android.job.v19.JobProxy19;
 import com.evernote.android.job.v21.JobProxy21;
+import com.evernote.android.job.v24.JobProxy24;
 import com.google.android.gms.gcm.GcmNetworkManager;
 
 /**
@@ -45,22 +49,50 @@
     /**
      * Uses the {@link JobScheduler} for scheduling jobs.
      */
-    V_21,
+    V_24(true, false),
+    /**
+     * Uses the {@link JobScheduler} for scheduling jobs.
+     */
+    V_21(true, true),
     /**
      * Uses the {@link AlarmManager} for scheduling jobs.
      */
-    V_14,
+    V_19(true, true),
+    /**
+     * Uses the {@link AlarmManager} for scheduling jobs.
+     */
+    V_14(false, true),
     /**
      * Uses the {@link GcmNetworkManager} for scheduling jobs.
      */
-    GCM;
+    GCM(true, false);
 
     private JobProxy mCachedProxy;
 
+    private final boolean mSupportsExecutionWindow;
+    private final boolean mFlexSupport;
+
+    JobApi(boolean supportsExecutionWindow, boolean flexSupport) {
+        mSupportsExecutionWindow = supportsExecutionWindow;
+        mFlexSupport = flexSupport;
+    }
+
+    public boolean supportsExecutionWindow() {
+        return mSupportsExecutionWindow;
+    }
+
+    public boolean isFlexSupport() {
+        return mFlexSupport;
+    }
+
     public boolean isSupported(Context context) {
         switch (this) {
+            case V_24:
+                return Build.VERSION.SDK_INT >= Build.VERSION_CODES.N;
             case V_21:
                 return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP;
+            case V_19:
+                return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
             case V_14:
                 return true;
             case GCM:
@@ -70,10 +102,15 @@ public boolean isSupported(Context context) {
         }
     }
 
+    @NonNull
     public JobProxy createProxy(Context context) {
         switch (this) {
+            case V_24:
+                return new JobProxy24(context);
             case V_21:
                 return new JobProxy21(context);
+            case V_19:
+                return new JobProxy19(context);
             case V_14:
                 return new JobProxy14(context);
             case GCM:
@@ -83,6 +120,7 @@ public JobProxy createProxy(Context context) {
         }
     }
 
+    @NonNull
     public synchronized JobProxy getCachedProxy(Context context) {
         if (mCachedProxy == null) {
             mCachedProxy = createProxy(context);
@@ -90,11 +128,26 @@ public synchronized JobProxy getCachedProxy(Context context) {
         return mCachedProxy;
     }
 
+    /**
+     * @deprecated Use {@link #getDefault(Context, boolean)} instead.
+     */
+    @SuppressWarnings("unused")
+    @NonNull
+    @Deprecated
     public static JobApi getDefault(Context context) {
-        if (V_21.isSupported(context)) {
+        return getDefault(context, JobManager.instance().getConfig().isGcmApiEnabled());
+    }
+
+    @NonNull
+    public static JobApi getDefault(Context context, boolean gcmEnabled) {
+        if (V_24.isSupported(context)) {
+            return V_24;
+        } else if (V_21.isSupported(context)) {
             return V_21;
-        } else if (GCM.isSupported(context)) {
+        } else if (gcmEnabled && GCM.isSupported(context)) {
             return GCM;
+        } else if (V_19.isSupported(context)) {
+            return V_19;
         } else {
             return V_14;
         }
diff --git a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
index 3430563..7f823c1 100644
--- a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
+++ b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
@@ -44,21 +44,74 @@
  */
 public class JobProxy14 implements JobProxy {
 
-    private static final CatLog CAT = new JobCat("JobProxy14");
+    private static final String TAG = "JobProxy14";
+
+    protected final Context mContext;
+    protected final CatLog mCat;
 
-    private final Context mContext;
     private AlarmManager mAlarmManager;
 
     public JobProxy14(Context context) {
+        this(context, TAG);
+    }
+
+    protected JobProxy14(Context context, String logTag) {
         mContext = context;
+        mCat = new JobCat(logTag);
     }
 
     @Override
     public void plantOneOff(JobRequest request) {
         PendingIntent pendingIntent = getPendingIntent(request, false);
-        setAlarm(request, System.currentTimeMillis() + Common.getAverageDelayMs(request), pendingIntent);
 
-        CAT.d("Scheduled alarm, %s, delay %s, exact %b", request,
+        AlarmManager alarmManager = getAlarmManager();
+        if (alarmManager == null) {
+            return;
+        }
+
+        try {
+            if (request.isExact()) {
+                plantOneOffExact(request, alarmManager, pendingIntent);
+            } else {
+                plantOneOffInexact(request, alarmManager, pendingIntent);
+            }
+        } catch (Exception e) {
+            // https://gist.github.com/vRallev/621b0b76a14ddde8691c
+            mCat.e(e);
+        }
+    }
+
+    protected void plantOneOffInexact(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
+        alarmManager.set(AlarmManager.RTC, getTriggerAtMillis(request), pendingIntent);
+        logScheduled(request);
+    }
+
+    protected void plantOneOffExact(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
+        long triggerAtMillis = getTriggerAtMillis(request);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+        } else {
+            alarmManager.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+        }
+        logScheduled(request);
+    }
+
+    protected void plantOneOffFlexSupport(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
+        long triggerAtMs = System.currentTimeMillis() + Common.getAverageDelayMsSupportFlex(request);
+        alarmManager.set(AlarmManager.RTC, triggerAtMs, pendingIntent);
+
+        mCat.d("Scheduled repeating alarm (flex support), %s, interval %s, flex %s", request,
+                JobUtil.timeToString(request.getIntervalMs()), JobUtil.timeToString(request.getFlexMs()));
+    }
+
+    protected long getTriggerAtMillis(JobRequest request) {
+        return System.currentTimeMillis() + Common.getAverageDelayMs(request);
+    }
+
+    private void logScheduled(JobRequest request) {
+        mCat.d("Scheduled alarm, %s, delay %s, exact %b", request,
                 JobUtil.timeToString(Common.getAverageDelayMs(request)), request.isExact());
     }
 
@@ -70,19 +123,37 @@ public void plantPeriodic(JobRequest request) {
             alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + request.getIntervalMs(), request.getIntervalMs(), pendingIntent);
         }
 
-        CAT.d("Scheduled repeating alarm, %s, interval %s", request, JobUtil.timeToString(request.getIntervalMs()));
+        mCat.d("Scheduled repeating alarm, %s, interval %s", request, JobUtil.timeToString(request.getIntervalMs()));
+    }
+
+    @Override
+    public void plantPeriodicFlexSupport(JobRequest request) {
+        PendingIntent pendingIntent = getPendingIntent(request, false);
+
+        AlarmManager alarmManager = getAlarmManager();
+        if (alarmManager == null) {
+            return;
+        }
+
+        try {
+            plantOneOffFlexSupport(request, alarmManager, pendingIntent);
+        } catch (Exception e) {
+            // https://gist.github.com/vRallev/621b0b76a14ddde8691c
+            mCat.e(e);
+        }
     }
 
     @Override
-    public void cancel(JobRequest request) {
+    public void cancel(int jobId) {
         AlarmManager alarmManager = getAlarmManager();
         if (alarmManager != null) {
             try {
-                alarmManager.cancel(getPendingIntent(request, request.isPeriodic()));
+                alarmManager.cancel(getPendingIntent(jobId, createPendingIntentFlags(true)));
+                alarmManager.cancel(getPendingIntent(jobId, createPendingIntentFlags(false)));
             } catch (Exception e) {
                 // java.lang.SecurityException: get application info: Neither user 1010133 nor
                 // current process has android.permission.INTERACT_ACROSS_USERS.
-                CAT.e(e);
+                mCat.e(e);
             }
         }
     }
@@ -93,53 +164,36 @@ public boolean isPlatformJobScheduled(JobRequest request) {
         return pendingIntent != null;
     }
 
-    protected PendingIntent getPendingIntent(JobRequest request, boolean repeating) {
+    protected int createPendingIntentFlags(boolean repeating) {
         int flags = PendingIntent.FLAG_UPDATE_CURRENT;
         if (!repeating) {
             flags |= PendingIntent.FLAG_ONE_SHOT;
         }
-        return getPendingIntent(request, flags);
+        return flags;
+    }
+
+    protected PendingIntent getPendingIntent(JobRequest request, boolean repeating) {
+        return getPendingIntent(request, createPendingIntentFlags(repeating));
     }
 
     protected PendingIntent getPendingIntent(JobRequest request, int flags) {
-        Intent intent = PlatformAlarmReceiver.createIntent(request);
+        return getPendingIntent(request.getJobId(), flags);
+    }
+
+    protected PendingIntent getPendingIntent(int jobId, int flags) {
+        Intent intent = PlatformAlarmReceiver.createIntent(mContext, jobId);
 
         // repeating PendingIntent with service seams to have problems
         try {
-            return PendingIntent.getBroadcast(mContext, request.getJobId(), intent, flags);
+            return PendingIntent.getBroadcast(mContext, jobId, intent, flags);
         } catch (Exception e) {
             // java.lang.SecurityException: Permission Denial: getIntentSender() from pid=31482, uid=10057,
             // (need uid=-1) is not allowed to send as package com.evernote
-            CAT.e(e);
+            mCat.e(e);
             return null;
         }
     }
 
-    protected void setAlarm(JobRequest request, long triggerAtMillis, PendingIntent pendingIntent) {
-        AlarmManager alarmManager = getAlarmManager();
-        if (alarmManager == null) {
-            return;
-        }
-
-        try {
-            if (request.isExact()) {
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                    alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
-                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-                    alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
-                } else {
-                    alarmManager.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
-                }
-
-            } else {
-                alarmManager.set(AlarmManager.RTC, triggerAtMillis, pendingIntent);
-            }
-        } catch (Exception e) {
-            // https://gist.github.com/vRallev/621b0b76a14ddde8691c
-            CAT.e(e);
-        }
-    }
-
     @Nullable
     protected AlarmManager getAlarmManager() {
         if (mAlarmManager == null) {
@@ -147,7 +201,7 @@ protected AlarmManager getAlarmManager() {
         }
         if (mAlarmManager == null) {
             // https://gist.github.com/vRallev/5daef6e8a3b0d4a7c366
-            CAT.e("AlarmManager is null");
+            mCat.e("AlarmManager is null");
         }
         return mAlarmManager;
     }
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
index 17331e9..41b5086 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
@@ -29,7 +29,6 @@
 import android.content.Intent;
 import android.support.v4.content.WakefulBroadcastReceiver;
 
-import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobUtil;
 
@@ -42,19 +41,15 @@
 
     /*package*/ static final String EXTRA_JOB_ID = "EXTRA_JOB_ID";
 
-    private static final String ACTION_RUN_JOB = "com.evernote.android.job.v14.RUN_JOB";
-    private static final String ACTION_RUN_JOB_OLD = "net.vrallev.android.job.v14.RUN_JOB";
-
     private static final CatLog CAT = new JobCat("PlatformAlarmReceiver");
 
-    /*package*/ static Intent createIntent(JobRequest request) {
-        return new Intent(ACTION_RUN_JOB)
-                .putExtra(EXTRA_JOB_ID, request.getJobId());
+    /*package*/ static Intent createIntent(Context context, int jobId) {
+        return new Intent(context, PlatformAlarmReceiver.class).putExtra(EXTRA_JOB_ID, jobId);
     }
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        if (intent == null || !(ACTION_RUN_JOB.equals(intent.getAction()) || ACTION_RUN_JOB_OLD.equals(intent.getAction()))) {
+        if (intent == null || !intent.hasExtra(EXTRA_JOB_ID)) {
             return;
         }
 
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
index 29d404f..65cd5d9 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
@@ -62,25 +62,27 @@ protected void onHandleIntent(final Intent intent) {
         }
 
         int jobId = intent.getIntExtra(PlatformAlarmReceiver.EXTRA_JOB_ID, -1);
-
         final JobProxy.Common common = new JobProxy.Common(this, jobId);
 
-        final JobRequest request = common.getPendingRequest();
-        if (request != null) {
-            // parallel execution
-            EXECUTOR_SERVICE.execute(new Runnable() {
-                @Override
-                public void run() {
-                    common.executeJobRequest(request);
+        // create the JobManager. Seeing sometimes exceptions, that it wasn't created, yet.
+        final JobRequest request = common.getPendingRequest(true);
+        if (request == null) {
+            return;
+        }
 
-                    // call here, our own wake lock could be acquired too late
-                    try {
-                        PlatformAlarmReceiver.completeWakefulIntent(intent);
-                    } catch (Exception e) {
-                        // could end in a NPE if the intent has no wake lock
-                    }
+        // parallel execution
+        EXECUTOR_SERVICE.execute(new Runnable() {
+            @Override
+            public void run() {
+                common.executeJobRequest(request);
+
+                // call here, our own wake lock could be acquired too late
+                try {
+                    PlatformAlarmReceiver.completeWakefulIntent(intent);
+                } catch (Exception e) {
+                    // could end in a NPE if the intent has no wake lock
                 }
-            });
-        }
+            }
+        });
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v19/JobProxy19.java b/library/src/main/java/com/evernote/android/job/v19/JobProxy19.java
new file mode 100644
index 0000000..bf8df0f
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/v19/JobProxy19.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job.v19;
+
+import android.annotation.TargetApi;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.os.Build;
+
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobUtil;
+import com.evernote.android.job.v14.JobProxy14;
+
+/**
+ * @author rwondratschek
+ */
+@TargetApi(Build.VERSION_CODES.KITKAT)
+public class JobProxy19 extends JobProxy14 {
+
+    private static final String TAG = "JobProxy19";
+
+    public JobProxy19(Context context) {
+        super(context, TAG);
+    }
+
+    @Override
+    protected void plantOneOffInexact(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
+        long currentTime = System.currentTimeMillis();
+        long startMs = currentTime + Common.getStartMs(request);
+        long lengthMs = Common.getEndMs(request) - Common.getStartMs(request);
+
+        alarmManager.setWindow(AlarmManager.RTC, startMs, lengthMs, pendingIntent);
+
+        mCat.d("Schedule alarm, %s, start %s, end %s", request,
+                JobUtil.timeToString(Common.getStartMs(request)), JobUtil.timeToString(Common.getEndMs(request)));
+    }
+
+    @Override
+    protected void plantOneOffFlexSupport(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
+        long currentTime = System.currentTimeMillis();
+        long startMs = currentTime + Common.getStartMsSupportFlex(request);
+        long lengthMs = Common.getEndMsSupportFlex(request) - Common.getStartMsSupportFlex(request);
+
+        alarmManager.setWindow(AlarmManager.RTC, startMs, lengthMs, pendingIntent);
+
+        mCat.d("Scheduled repeating alarm (flex support), %s, start %s, end %s, flex %s", request,
+                JobUtil.timeToString(Common.getStartMsSupportFlex(request)), JobUtil.timeToString(Common.getEndMsSupportFlex(request)),
+                JobUtil.timeToString(request.getFlexMs()));
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
index 667e7e1..18699c4 100644
--- a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
+++ b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
@@ -49,66 +49,63 @@
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class JobProxy21 implements JobProxy {
 
-    private static final CatLog CAT = new JobCat("JobProxy21");
+    private static final String TAG = "JobProxy21";
 
-    private final Context mContext;
+    protected final Context mContext;
+    protected final CatLog mCat;
 
     public JobProxy21(Context context) {
+        this(context, TAG);
+    }
+
+    protected JobProxy21(Context context, String logTag) {
         mContext = context;
+        mCat = new JobCat(logTag);
     }
 
     @Override
     public void plantOneOff(JobRequest request) {
-        JobInfo jobInfo = createBaseBuilder(request)
-                .setMinimumLatency(Common.getStartMs(request))
-                .setOverrideDeadline(Common.getEndMs(request))
-                .setRequiresCharging(request.requiresCharging())
-                .setRequiresDeviceIdle(request.requiresDeviceIdle())
-                .setRequiredNetworkType(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(request.isPersisted())
-                .build();
+        long startMs = Common.getStartMs(request);
+        long endMs = Common.getEndMs(request);
 
-        int scheduleResult;
-        try {
-            scheduleResult = getJobScheduler().schedule(jobInfo);
-        } catch (Exception e) {
-            CAT.e(e);
-            scheduleResult = JobScheduler.RESULT_FAILURE;
-        }
+        JobInfo jobInfo = createBuilderOneOff(createBaseBuilder(request), startMs, endMs).build();
+        int scheduleResult = schedule(jobInfo);
 
-        CAT.d("Schedule one-off jobInfo %s, %s, start %s, end %s", scheduleResult == JobScheduler.RESULT_SUCCESS ? "success" : "failure",
-                request, JobUtil.timeToString(Common.getStartMs(request)), JobUtil.timeToString(Common.getEndMs(request)));
+        mCat.d("Schedule one-off jobInfo %s, %s, start %s, end %s", scheduleResultToString(scheduleResult),
+                request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs));
     }
 
     @Override
     public void plantPeriodic(JobRequest request) {
-        JobInfo jobInfo = createBaseBuilder(request)
-                .setPeriodic(request.getIntervalMs())
-                .setRequiresCharging(request.requiresCharging())
-                .setRequiresDeviceIdle(request.requiresDeviceIdle())
-                .setRequiredNetworkType(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(request.isPersisted())
-                .build();
+        long intervalMs = request.getIntervalMs();
+        long flexMs = request.getFlexMs();
 
-        int scheduleResult;
-        try {
-            scheduleResult = getJobScheduler().schedule(jobInfo);
-        } catch (Exception e) {
-            CAT.e(e);
-            scheduleResult = JobScheduler.RESULT_FAILURE;
-        }
+        JobInfo jobInfo = createBuilderPeriodic(createBaseBuilder(request), intervalMs, flexMs).build();
+        int scheduleResult = schedule(jobInfo);
 
-        CAT.d("Schedule periodic jobInfo %s, %s, interval %s", scheduleResult == JobScheduler.RESULT_SUCCESS ? "success" : "failure",
-                request, JobUtil.timeToString(request.getIntervalMs()));
+        mCat.d("Schedule periodic jobInfo %s, %s, interval %s, flex %s", scheduleResultToString(scheduleResult),
+                request, JobUtil.timeToString(intervalMs), JobUtil.timeToString(flexMs));
     }
 
     @Override
-    public void cancel(JobRequest request) {
+    public void plantPeriodicFlexSupport(JobRequest request) {
+        long startMs = Common.getStartMsSupportFlex(request);
+        long endMs = Common.getEndMsSupportFlex(request);
+
+        JobInfo jobInfo = createBuilderOneOff(createBaseBuilder(request), startMs, endMs).build();
+        int scheduleResult = schedule(jobInfo);
+
+        mCat.d("Schedule periodic (flex support) jobInfo %s, %s, start %s, end %s, flex %s", scheduleResultToString(scheduleResult),
+                request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs), JobUtil.timeToString(request.getFlexMs()));
+    }
+
+    @Override
+    public void cancel(int jobId) {
         try {
-            getJobScheduler().cancel(request.getJobId());
+            getJobScheduler().cancel(jobId);
         } catch (Exception e) {
             // https://gist.github.com/vRallev/5d48a4a8e8d05067834e
-            CAT.e(e);
+            mCat.e(e);
         }
     }
 
@@ -119,10 +116,11 @@ public boolean isPlatformJobScheduled(JobRequest request) {
             pendingJobs = getJobScheduler().getAllPendingJobs();
         } catch (Exception e) {
             // it's possible that this throws an exception, see https://gist.github.com/vRallev/a59947dd3932d2642641
-            CAT.e(e);
+            mCat.e(e);
             return false;
         }
 
+        //noinspection ConstantConditions
         if (pendingJobs == null || pendingJobs.isEmpty()) {
             return false;
         }
@@ -138,7 +136,19 @@ public boolean isPlatformJobScheduled(JobRequest request) {
     }
 
     protected JobInfo.Builder createBaseBuilder(JobRequest request) {
-        return new JobInfo.Builder(request.getJobId(), new ComponentName(mContext, PlatformJobService.class));
+        return new JobInfo.Builder(request.getJobId(), new ComponentName(mContext, PlatformJobService.class))
+                .setRequiresCharging(request.requiresCharging())
+                .setRequiresDeviceIdle(request.requiresDeviceIdle())
+                .setRequiredNetworkType(convertNetworkType(request.requiredNetworkType()))
+                .setPersisted(request.isPersisted());
+    }
+
+    protected JobInfo.Builder createBuilderOneOff(JobInfo.Builder builder, long startMs, long endMs) {
+        return builder.setMinimumLatency(startMs).setOverrideDeadline(endMs);
+    }
+
+    protected JobInfo.Builder createBuilderPeriodic(JobInfo.Builder builder, long intervalMs, long flexMs) {
+        return builder.setPeriodic(intervalMs);
     }
 
     protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
@@ -149,6 +159,8 @@ protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
                 return JobInfo.NETWORK_TYPE_ANY;
             case UNMETERED:
                 return JobInfo.NETWORK_TYPE_UNMETERED;
+            case NOT_ROAMING:
+                return JobInfo.NETWORK_TYPE_UNMETERED; // use unmetered here, is overwritten in v24
             default:
                 throw new IllegalStateException("not implemented");
         }
@@ -157,4 +169,17 @@ protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
     protected final JobScheduler getJobScheduler() {
         return (JobScheduler) mContext.getSystemService(Context.JOB_SCHEDULER_SERVICE);
     }
+
+    protected final int schedule(JobInfo jobInfo) {
+        try {
+            return getJobScheduler().schedule(jobInfo);
+        } catch (Exception e) {
+            mCat.e(e);
+            return JobScheduler.RESULT_FAILURE;
+        }
+    }
+
+    protected static String scheduleResultToString(int scheduleResult) {
+        return scheduleResult == JobScheduler.RESULT_SUCCESS ? "success" : "failure";
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
index 3d119dc..437d328 100644
--- a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
+++ b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
@@ -59,7 +59,7 @@ public boolean onStartJob(final JobParameters params) {
         final int jobId = params.getJobId();
         final JobProxy.Common common = new JobProxy.Common(this, jobId);
 
-        final JobRequest request = common.getPendingRequest();
+        final JobRequest request = common.getPendingRequest(true);
         if (request == null) {
             return false;
         }
diff --git a/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java b/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java
new file mode 100644
index 0000000..14f6785
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job.v24;
+
+import android.annotation.TargetApi;
+import android.app.job.JobInfo;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.v21.JobProxy21;
+
+
+/**
+ * @author rwondratschek
+ */
+@TargetApi(Build.VERSION_CODES.N)
+public class JobProxy24 extends JobProxy21 {
+
+    private static final String TAG = "JobProxy24";
+
+    public JobProxy24(Context context) {
+        super(context, TAG);
+    }
+
+    @Override
+    public void plantPeriodicFlexSupport(JobRequest request) {
+        mCat.w("plantPeriodicFlexSupport called although flex is supported");
+        super.plantPeriodicFlexSupport(request);
+    }
+
+    @Override
+    public boolean isPlatformJobScheduled(JobRequest request) {
+        try {
+            return getJobScheduler().getPendingJob(request.getJobId()) != null;
+        } catch (Exception e) {
+            mCat.e(e);
+            return false;
+        }
+    }
+
+    @Override
+    protected JobInfo.Builder createBuilderPeriodic(JobInfo.Builder builder, long intervalMs, long flexMs) {
+        return builder.setPeriodic(intervalMs, flexMs);
+    }
+
+    @Override
+    protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
+        switch (networkType) {
+            case NOT_ROAMING:
+                return JobInfo.NETWORK_TYPE_NOT_ROAMING;
+            default:
+                return super.convertNetworkType(networkType);
+        }
+    }
+}
