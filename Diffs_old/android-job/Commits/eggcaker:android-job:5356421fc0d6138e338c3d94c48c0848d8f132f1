diff --git a/CHANGELOG.md b/CHANGELOG.md
index a9641f7..b720ab9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -18,6 +18,7 @@
 * Handle 'Package manager has died' crash
 * Save the highest job ID in a pref file so that it isn't lost when no job is in the database anymore (makes debugging easier)
 * Fix rare NPE when rescheduling jobs after service has been restarted, see #234
+* Fix rescheduled periodic job although it has been canceled pre Android N, see #241
 
 ## 1.1.11 (2017-06-05)
 
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index bb21c60..d471820 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -267,7 +267,7 @@ public void markStarting(@NonNull JobRequest request) {
                 if (!request.isPeriodic()) {
                     mJobManager.getJobStorage().remove(request);
 
-                } else if (request.isFlexSupport()) {
+                } else if (request.isFlexSupport() && (job == null || !job.isDeleted())) {
                     mJobManager.getJobStorage().remove(request); // remove, we store the new job in JobManager.schedule()
                     request.reschedule(false, false);
                 }
diff --git a/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
new file mode 100644
index 0000000..160ba26
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
@@ -0,0 +1,134 @@
+package com.evernote.android.job;
+
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.test.TestLogger;
+
+import org.junit.Before;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.assertj.core.api.Java6Assertions.fail;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobPeriodicCancelTest extends BaseJobManagerTest {
+
+    private PeriodicJob mJob;
+
+    @Before
+    public void setup() {
+        mJob = new PeriodicJob();
+        manager().addJobCreator(new JobCreator() {
+            @Override
+            public Job create(String tag) {
+                return mJob;
+            }
+        });
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyPeriodicFlexNotRescheduledN() throws Exception {
+        runJobAndCancelAllDuringExecution(true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyPeriodicNotRescheduledN() throws Exception {
+        runJobAndCancelAllDuringExecution(false);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.M)
+    public void verifyPeriodicFlexNotRescheduledM() throws Exception {
+        runJobAndCancelAllDuringExecution(true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.M)
+    public void verifyPeriodicNotRescheduledM() throws Exception {
+        runJobAndCancelAllDuringExecution(false);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.KITKAT)
+    public void verifyPeriodicFlexNotRescheduledK() throws Exception {
+        runJobAndCancelAllDuringExecution(true);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.KITKAT)
+    public void verifyPeriodicNotRescheduledK() throws Exception {
+        runJobAndCancelAllDuringExecution(false);
+        assertThat(manager().getAllJobRequests()).isEmpty();
+    }
+
+    private void runJobAndCancelAllDuringExecution(boolean flex) {
+        try {
+            final int jobId = new JobRequest.Builder("any")
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(flex ? 5 : 15))
+                .build()
+                .schedule();
+
+            final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
+            final JobRequest request = common.getPendingRequest(true, true);
+            assertThat(request).isNotNull();
+
+            final CountDownLatch waitFinishExecution = new CountDownLatch(1);
+            new Thread() {
+                @Override
+                public void run() {
+                    common.executeJobRequest(request, null);
+                    waitFinishExecution.countDown();
+                }
+            }.start();
+
+            assertThat(mJob.mStartedLatch.await(3, TimeUnit.SECONDS)).isTrue();
+
+            manager().cancelAll();
+
+            mJob.mBlockingLatch.countDown();
+            assertThat(waitFinishExecution.await(3, TimeUnit.SECONDS)).isTrue();
+
+
+        } catch (InterruptedException e) {
+            fail("Shouldn't happen");
+        }
+    }
+
+    private static class PeriodicJob extends Job {
+
+        private final CountDownLatch mStartedLatch = new CountDownLatch(1);
+        private final CountDownLatch mBlockingLatch = new CountDownLatch(1);
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            mStartedLatch.countDown();
+
+            try {
+                mBlockingLatch.await(10, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+            return Result.SUCCESS;
+        }
+    }
+}
