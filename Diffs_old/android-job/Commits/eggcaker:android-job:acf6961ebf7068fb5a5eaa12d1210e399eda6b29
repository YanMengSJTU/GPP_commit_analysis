diff --git a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
index 6b81fdb..4694451 100644
--- a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
+++ b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
@@ -74,7 +74,7 @@ public void plantOneOff(JobRequest request) {
 
         try {
             if (request.isExact()) {
-                if (request.getStartMs() == 1) {
+                if (request.getStartMs() == 1 && request.getFailureCount() <= 0) {
                     // this job should start immediately
                     PlatformAlarmService.start(mContext, request.getJobId(), request.getTransientExtras());
                 } else {
diff --git a/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java b/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java
new file mode 100644
index 0000000..e141aa3
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java
@@ -0,0 +1,66 @@
+package com.evernote.android.job;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.app.job.JobWorkItem;
+import android.content.Context;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.test.TestClock;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class BackoffCriteriaTests extends BaseJobManagerTest {
+
+    @Test
+    public void verifyBackoffCriteriaIsAppliedForImmediatelyStartedJobs() {
+        JobConfig.setClock(new TestClock());
+
+        AlarmManager alarmManager = mock(AlarmManager.class);
+        JobScheduler jobScheduler = mock(JobScheduler.class);
+
+        doReturn(alarmManager).when(context()).getSystemService(eq(Context.ALARM_SERVICE));
+        doReturn(jobScheduler).when(context()).getSystemService(eq(Context.JOB_SCHEDULER_SERVICE));
+
+        int jobId = DummyJobs.createBuilder(DummyJobs.RescheduleJob.class)
+                .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
+                .startNow()
+                .build()
+                .schedule();
+
+        // this uses the JobIntentService under the hood, so verify that the JobScheduler was used for Android O and above
+        verify(jobScheduler).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        jobId = manager().getAllJobRequests().iterator().next().getJobId(); // because the job was rescheduled and its ID changed
+
+        // make sure that this method was not called again, because with the backoff criteria we have a delay
+        verify(jobScheduler, times(1)).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+
+        // instead the AlarmManager should be used
+        verify(alarmManager).setExactAndAllowWhileIdle(anyInt(), eq(5_000L), any(PendingIntent.class));
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        verify(jobScheduler, times(1)).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+        verify(alarmManager).setExactAndAllowWhileIdle(anyInt(), eq(10_000L), any(PendingIntent.class));
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
index a9206b6..4dd00fe 100644
--- a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
@@ -131,6 +131,7 @@ public static Context createMockContext() {
 
         Context context = spy(RuntimeEnvironment.application);
         when(context.getPackageManager()).thenReturn(packageManager);
+        when(context.getApplicationContext()).thenReturn(context);
 
         Context mockContext = mock(MockContext.class);
         when(mockContext.getApplicationContext()).thenReturn(context);
diff --git a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
index 7842da7..d77cffe 100644
--- a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
@@ -1,5 +1,6 @@
 package com.evernote.android.job;
 
+import android.os.Bundle;
 import android.support.annotation.NonNull;
 
 import com.evernote.android.job.test.DummyJobs;
@@ -214,4 +215,29 @@ public Job create(String tag) {
 
         assertThat(onRescheduleCalled.get()).isFalse();
     }
+
+    @Test
+    public void verifyReschedulingTransientJobsWorks() throws Throwable {
+        Bundle extras = new Bundle();
+        extras.putString("key", "hello");
+
+        int previousJobId = DummyJobs.createBuilder(DummyJobs.RescheduleJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .setTransientExtras(extras)
+                .build()
+                .schedule();
+
+        for (int i = 0; i < 5; i++) {
+            executeJob(previousJobId, Job.Result.RESCHEDULE);
+
+            assertThat(manager().getAllJobRequestsForTag(DummyJobs.RescheduleJob.TAG)).hasSize(1);
+
+            JobRequest request = manager().getAllJobRequestsForTag(DummyJobs.RescheduleJob.TAG).iterator().next();
+            assertThat(request.getJobId()).isNotEqualTo(previousJobId);
+
+            assertThat(request.getTransientExtras().getString("key", null)).isEqualTo("hello");
+
+            previousJobId = request.getJobId();
+        }
+    }
 }
