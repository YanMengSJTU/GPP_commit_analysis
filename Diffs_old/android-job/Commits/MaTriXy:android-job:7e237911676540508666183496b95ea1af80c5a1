diff --git a/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java b/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
new file mode 100644
index 0000000..41373c8
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/DatabaseUpgradeTest.java
@@ -0,0 +1,124 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.suitebuilder.annotation.LargeTest;
+
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static com.evernote.android.job.JobStorage.COLUMN_BACKOFF_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_BACKOFF_POLICY;
+import static com.evernote.android.job.JobStorage.COLUMN_END_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_EXACT;
+import static com.evernote.android.job.JobStorage.COLUMN_EXTRAS;
+import static com.evernote.android.job.JobStorage.COLUMN_ID;
+import static com.evernote.android.job.JobStorage.COLUMN_INTERVAL_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_NETWORK_TYPE;
+import static com.evernote.android.job.JobStorage.COLUMN_NUM_FAILURES;
+import static com.evernote.android.job.JobStorage.COLUMN_PERSISTED;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIREMENTS_ENFORCED;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_CHARGING;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_DEVICE_IDLE;
+import static com.evernote.android.job.JobStorage.COLUMN_SCHEDULED_AT;
+import static com.evernote.android.job.JobStorage.COLUMN_START_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_TAG;
+import static com.evernote.android.job.JobStorage.DATABASE_NAME;
+import static com.evernote.android.job.JobStorage.JOB_TABLE_NAME;
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class DatabaseUpgradeTest {
+
+    @Test
+    public void testDatabaseUpgrade() {
+        Context context = InstrumentationRegistry.getContext();
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper1 jobOpenHelper = new JobOpenHelper1(context);
+        SQLiteDatabase database = jobOpenHelper.getWritableDatabase();
+        assertThat(jobOpenHelper.mDatabaseCreated).isTrue();
+
+        database.close();
+
+        JobManager.create(context).addJobCreator(new JobCreator() {
+            @Override
+            public Job create(String tag) {
+                return null;
+            }
+        });
+
+        int jobId = new JobRequest.Builder("Tag")
+                .setExact(90_000L)
+                .build()
+                .schedule();
+
+        assertThat(JobManager.instance().getAllJobRequests()).hasSize(1);
+
+        JobRequest jobRequest = JobManager.instance().getJobRequest(jobId);
+        assertThat(jobRequest).isNotNull();
+        assertThat(jobRequest.isTransient()).isFalse();
+
+        jobRequest.setTransient(true);
+        assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
+        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).hasSize(1);
+
+        JobManager.instance().cancelAll();
+
+        assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
+        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).isEmpty();
+    }
+
+    @After
+    public void tearDown() {
+        JobManager.instance().cancelAll();
+    }
+
+    private class JobOpenHelper1 extends SQLiteOpenHelper {
+
+        private boolean mDatabaseCreated;
+
+        public JobOpenHelper1(Context context) {
+            super(context, DATABASE_NAME, null, 1);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            createJobTable(db);
+            mDatabaseCreated = true;
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            // not needed at the moment
+        }
+
+        private void createJobTable(SQLiteDatabase db) {
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + COLUMN_PERSISTED + " integer, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer);");
+        }
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/JobExecutor.java b/library/src/main/java/com/evernote/android/job/JobExecutor.java
index 8bff3f6..07ddc63 100644
--- a/library/src/main/java/com/evernote/android/job/JobExecutor.java
+++ b/library/src/main/java/com/evernote/android/job/JobExecutor.java
@@ -28,6 +28,7 @@
 import android.content.Context;
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.SparseArray;
 
 import com.evernote.android.job.util.JobCat;
@@ -58,8 +59,7 @@ public JobExecutor() {
         mJobs = new SparseArray<>();
     }
 
-    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @NonNull JobCreatorHolder jobCreatorHolder) {
-        Job job = jobCreatorHolder.createJob(request.getTag());
+    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @Nullable Job job) {
         if (job == null) {
             CAT.w("JobCreator returned null for tag %s", request.getTag());
             return null;
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index d15097d..8ba7790 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -218,7 +218,16 @@ public void schedule(JobRequest request) {
      * @return The {@link JobRequest} if it's pending or {@code null} otherwise.
      */
     public JobRequest getJobRequest(int jobId) {
-        return mJobStorage.get(jobId);
+        return getJobRequest(jobId, false);
+    }
+
+    /*package*/ JobRequest getJobRequest(int jobId, boolean includeTransient) {
+        JobRequest jobRequest = mJobStorage.get(jobId);
+        if (!includeTransient && jobRequest.isTransient()) {
+            return null;
+        } else {
+            return jobRequest;
+        }
     }
 
     /**
@@ -229,7 +238,7 @@ public JobRequest getJobRequest(int jobId) {
      */
     @NonNull
     public Set<JobRequest> getAllJobRequests() {
-        return mJobStorage.getAllJobRequests();
+        return mJobStorage.getAllJobRequests(null, false);
     }
 
     /**
@@ -239,7 +248,7 @@ public JobRequest getJobRequest(int jobId) {
      * direct effects to the actual backing store.
      */
     public Set<JobRequest> getAllJobRequestsForTag(@NonNull String tag) {
-        return mJobStorage.getAllJobRequestsForTag(tag);
+        return mJobStorage.getAllJobRequests(tag, false);
     }
 
     /**
@@ -310,7 +319,7 @@ public JobApi getApi() {
      */
     public boolean cancel(int jobId) {
         // call both methods
-        boolean result = cancelInner(getJobRequest(jobId)) | cancelInner(getJob(jobId));
+        boolean result = cancelInner(getJobRequest(jobId, true)) | cancelInner(getJob(jobId));
         JobProxy.Common.cleanUpOrphanedJob(mContext, jobId); // do this as well, just in case
         return result;
     }
@@ -358,7 +367,7 @@ private boolean cancelInner(@Nullable Job job) {
     private int cancelAllInner(@Nullable String tag) {
         int canceled = 0;
 
-        Set<JobRequest> requests = TextUtils.isEmpty(tag) ? getAllJobRequests() : getAllJobRequestsForTag(tag);
+        Set<JobRequest> requests = mJobStorage.getAllJobRequests(tag, true);
         for (JobRequest request : requests) {
             if (cancelInner(request)) {
                 canceled++;
@@ -442,11 +451,19 @@ public void run() {
                      */
                     SystemClock.sleep(10_000L);
 
-                    Set<JobRequest> requests = JobManager.instance().getAllJobRequests();
+                    Set<JobRequest> requests = mJobStorage.getAllJobRequests(null, true);
 
                     int rescheduledCount = 0;
                     for (JobRequest request : requests) {
-                        if (!getJobProxy(request).isPlatformJobScheduled(request)) {
+                        boolean reschedule;
+                        if (request.isTransient()) {
+                            Job job = getJob(request.getJobId());
+                            reschedule = job == null;
+                        } else {
+                            reschedule = !getJobProxy(request).isPlatformJobScheduled(request);
+                        }
+
+                        if (reschedule) {
                             // update execution window
                             request.cancelAndEdit()
                                     .build()
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 7e1117c..a001293 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -85,7 +85,7 @@ public JobRequest getPendingRequest() {
 
         public JobRequest getPendingRequest(JobManager manager) {
             // order is important for logging purposes
-            JobRequest request = manager.getJobRequest(mJobId);
+            JobRequest request = manager.getJobRequest(mJobId, true);
             Job job = manager.getJob(mJobId);
             boolean periodic = request != null && request.isPeriodic();
 
@@ -101,6 +101,10 @@ public JobRequest getPendingRequest(JobManager manager) {
                 mCat.d("Job %d is periodic and just finished, %s", mJobId, request);
                 return null;
 
+            } else if (request != null && request.isTransient()) {
+                mCat.d("Request %d is transient, %s", mJobId, request);
+                return null;
+
             } else if (request == null) {
                 mCat.d("Request for ID %d was null", mJobId);
                 return null;
@@ -129,11 +133,14 @@ public JobRequest getPendingRequest(JobManager manager) {
             JobExecutor jobExecutor = manager.getJobExecutor();
 
             try {
+                // create job first before setting it transient, avoids a race condition while rescheduling jobs
+                Job job = manager.getJobCreatorHolder().createJob(request.getTag());
+
                 if (!request.isPeriodic()) {
-                    manager.getJobStorage().remove(request);
+                    request.setTransient(true);
                 }
 
-                Future<Job.Result> future = jobExecutor.execute(mContext, request, manager.getJobCreatorHolder());
+                Future<Job.Result> future = jobExecutor.execute(mContext, request, job);
                 if (future == null) {
                     return Job.Result.FAILURE;
                 }
@@ -153,6 +160,11 @@ public JobRequest getPendingRequest(JobManager manager) {
                 }
 
                 return Job.Result.FAILURE;
+
+            } finally {
+                if (!request.isPeriodic()) {
+                    manager.getJobStorage().remove(request);
+                }
             }
         }
 
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 12d3040..45b1d54 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -77,6 +77,7 @@
 
     private int mNumFailures;
     private long mScheduledAt;
+    private boolean mTransient;
 
     private JobRequest(Builder builder) {
         mBuilder = builder;
@@ -253,6 +254,10 @@ public boolean isExact() {
         return mNumFailures;
     }
 
+    /*package*/ boolean isTransient() {
+        return mTransient;
+    }
+
     /**
      * Convenience method. Internally it calls {@link JobManager#schedule(JobRequest)}
      * and {@link #getJobId()} for this request.
@@ -275,6 +280,7 @@ public int schedule() {
     public Builder cancelAndEdit() {
         JobManager.instance().cancel(getJobId());
         Builder builder = new Builder(this, false);
+        mTransient = false;
 
         if (!isPeriodic()) {
             long offset = System.currentTimeMillis() - mScheduledAt;
@@ -300,11 +306,19 @@ public Builder cancelAndEdit() {
         JobManager.instance().getJobStorage().update(this, contentValues);
     }
 
+    /*package*/ void setTransient(boolean isTransient) {
+        mTransient = isTransient;
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
+        JobManager.instance().getJobStorage().update(this, contentValues);
+    }
+
     /*package*/ ContentValues toContentValues() {
         ContentValues contentValues = new ContentValues();
         mBuilder.fillContentValues(contentValues);
         contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mNumFailures);
         contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, mScheduledAt);
+        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
         return contentValues;
     }
 
@@ -312,6 +326,7 @@ public Builder cancelAndEdit() {
         JobRequest request = new Builder(cursor).build();
         request.mNumFailures = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
         request.mScheduledAt = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_SCHEDULED_AT));
+        request.mTransient = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_TRANSIENT)) > 0;
 
         JobPreconditions.checkArgumentNonnegative(request.mNumFailures, "failure count can't be negative");
         JobPreconditions.checkArgumentNonnegative(request.mScheduledAt, "scheduled at can't be negative");
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index 56dece7..4cb2087 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -25,12 +25,14 @@
  */
 package com.evernote.android.job;
 
+import android.annotation.SuppressLint;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.support.annotation.Nullable;
 import android.support.v4.util.LruCache;
 import android.text.TextUtils;
 
@@ -52,11 +54,11 @@
 
     private static final String JOB_ID_COUNTER = "JOB_ID_COUNTER";
 
-    private static final String PREF_FILE_NAME = "evernote_jobs";
-    private static final String DATABASE_NAME = PREF_FILE_NAME + ".db";
-    private static final int DATABASE_VERSION = 1;
+    public static final String PREF_FILE_NAME = "evernote_jobs";
+    public static final String DATABASE_NAME = PREF_FILE_NAME + ".db";
+    public static final int DATABASE_VERSION = 2;
 
-    private static final String JOB_TABLE_NAME = "jobs";
+    public static final String JOB_TABLE_NAME = "jobs";
 
     public static final String COLUMN_ID = "_id";
     public static final String COLUMN_TAG = "tag";
@@ -74,6 +76,7 @@
     public static final String COLUMN_PERSISTED = "persisted";
     public static final String COLUMN_NUM_FAILURES = "numFailures";
     public static final String COLUMN_SCHEDULED_AT = "scheduledAt";
+    public static final String COLUMN_TRANSIENT = "isTransient";
 
     private static final int CACHE_SIZE = 30;
 
@@ -83,6 +86,7 @@
     private final AtomicInteger mJobCounter;
 
     private final JobOpenHelper mDbHelper;
+    private SQLiteDatabase mDatabase;
 
     public JobStorage(Context context) {
         mPreferences = context.getSharedPreferences(PREF_FILE_NAME, Context.MODE_PRIVATE);
@@ -104,7 +108,7 @@ public synchronized void put(final JobRequest request) {
     public synchronized void update(JobRequest request, ContentValues contentValues) {
         updateRequestInCache(request);
         try {
-            mDbHelper.getWritableDatabase().update(JOB_TABLE_NAME, contentValues, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
+            getDatabase().update(JOB_TABLE_NAME, contentValues, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
         } catch (Exception e) {
             CAT.e(e, "could not update %s", request);
         }
@@ -118,22 +122,25 @@ public synchronized JobRequest get(int id) {
         return mCacheId.get(id);
     }
 
-    public synchronized Set<JobRequest> getAllJobRequests() {
-        return getAllJobRequestsForTag(null);
-    }
-
-    public synchronized Set<JobRequest> getAllJobRequestsForTag(String tag) {
+    public synchronized Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeTransient) {
         Set<JobRequest> result = new HashSet<>();
 
         Cursor cursor = null;
         try {
-            SQLiteDatabase database = mDbHelper.getWritableDatabase();
+            String where; // filter transient requests
+            String[] args;
             if (TextUtils.isEmpty(tag)) {
-                cursor = database.query(JOB_TABLE_NAME, null, null, null, null, null, null);
+                where = includeTransient ? null : (COLUMN_TRANSIENT + "<=0");
+                args = null;
             } else {
-                cursor = database.query(JOB_TABLE_NAME, null, COLUMN_TAG + "=?", new String[]{tag}, null, null, null);
+                where = includeTransient ? "" : (COLUMN_TRANSIENT + "<=0 AND ");
+                where += COLUMN_TAG + "=?";
+                args = new String[]{tag};
             }
 
+            cursor = getDatabase().query(JOB_TABLE_NAME, null, where, args, null, null, null);
+
+            @SuppressLint("UseSparseArrays")
             HashMap<Integer, JobRequest> cachedRequests = new HashMap<>(mCacheId.snapshot());
 
             while (cursor.moveToNext()) {
@@ -160,7 +167,7 @@ public synchronized JobRequest get(int id) {
     public synchronized void remove(JobRequest request) {
         mCacheId.remove(request.getJobId());
         try {
-            mDbHelper.getWritableDatabase().delete(JOB_TABLE_NAME, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
+            getDatabase().delete(JOB_TABLE_NAME, COLUMN_ID + "=?", new String[]{String.valueOf(request.getJobId())});
         } catch (Exception e) {
             CAT.e(e, "could not delete %s", request);
         }
@@ -178,16 +185,21 @@ public synchronized int nextJobId() {
     private void store(JobRequest request) {
         try {
             ContentValues contentValues = request.toContentValues();
-            mDbHelper.getWritableDatabase().insert(JOB_TABLE_NAME, null, contentValues);
+            getDatabase().insert(JOB_TABLE_NAME, null, contentValues);
         } catch (Exception e) {
             CAT.e(e, "could not store %s", request);
         }
     }
 
-    private JobRequest load(int id) {
+    private JobRequest load(int id, boolean includeTransient) {
         Cursor cursor = null;
         try {
-            cursor = mDbHelper.getWritableDatabase().query(JOB_TABLE_NAME, null, COLUMN_ID + "=?", new String[]{String.valueOf(id)}, null, null, null);
+            String where = COLUMN_ID + "=?";
+            if (!includeTransient) {
+                where += " AND " + COLUMN_TRANSIENT + "<=0";
+            }
+
+            cursor = getDatabase().query(JOB_TABLE_NAME, null, where, new String[]{String.valueOf(id)}, null, null, null);
             if (cursor.moveToFirst()) {
                 return JobRequest.fromCursor(cursor);
             }
@@ -204,6 +216,17 @@ private JobRequest load(int id) {
         return null;
     }
 
+    private SQLiteDatabase getDatabase() {
+        if (mDatabase == null) {
+            synchronized (this) {
+                if (mDatabase == null) {
+                    mDatabase = mDbHelper.getWritableDatabase();
+                }
+            }
+        }
+        return mDatabase;
+    }
+
     private class JobCacheId extends LruCache<Integer, JobRequest> {
 
         public JobCacheId() {
@@ -212,7 +235,7 @@ public JobCacheId() {
 
         @Override
         protected JobRequest create(Integer id) {
-            return load(id);
+            return load(id, true);
         }
     }
 
@@ -229,7 +252,10 @@ public void onCreate(SQLiteDatabase db) {
 
         @Override
         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            // not needed at the moment
+            // with newer versions there should be a smarter way
+            if (oldVersion == 1 && newVersion == 2) {
+                upgradeFrom1To2(db);
+            }
         }
 
         private void createJobTable(SQLiteDatabase db) {
@@ -249,7 +275,12 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXTRAS + " text, "
                     + COLUMN_PERSISTED + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
-                    + COLUMN_SCHEDULED_AT + " integer);");
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + COLUMN_TRANSIENT + " integer);");
+        }
+
+        private void upgradeFrom1To2(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
         }
     }
 }
