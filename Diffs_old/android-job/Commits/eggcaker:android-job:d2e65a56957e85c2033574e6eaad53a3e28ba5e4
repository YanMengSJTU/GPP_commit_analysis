diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index 504de38..a62a287 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -2,7 +2,7 @@ Before posting an issue, please check the following:
 
 * Do you have a question? Please take a look at the samples and read the FAQ first.
 ** https://github.com/evernote/android-job#usage
-** https://github.com/evernote/android-job/blob/master/FAQ.md
+** https://github.com/evernote/android-job/wiki/FAQ
 
 * Does the library crash for you? Please provide the version of the library, a log, stacktrace and even better a sample.
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index f593465..7b9baa7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,19 @@
+## 1.2.0
+
+* Extract `JobManager.Config` class into `JobConfig` class to make it possible to change settings before the `JobManager` is created
+* Add an option to disable any specific API and not just the GCM API (only useful for testing purposes)
+* Remove deprecated methods
+* Add the `startNow()` method to run a job immediately respecting all constraints in Android O
+* Remove the persisted parameter, which didn't work reliable, all jobs are persisted anyway
+* Remove `startWakefulService` from the `Job` class, `WakefulBroadcastReceiver` is now deprecated with `JobIntentService` as the better option
+* Add feature to make jobs transient and to add a `Bundle`, see `setTransientExtras(bundle)`
+* Add new `METERED` network type
+* Add new requirements battery not low and storage not low
+* Add helper job class `DailyJob` to make it easier to run jobs once a day, see #223
+* Add option in `JobConfig` to add a logger
+* Add option in `JobConfig` for a job ID offset to avoid clashes with other jobs in the `JobScheduler`
+* Switch to elapsed real time with the `AlarmManager` to have a consistent behavior with the `JobScheduler`, see #237
+
 ## 1.1.12 (2017-10-05)
 
 * Handle NPE inside of `JobScheduler`
diff --git a/FAQ.md b/FAQ.md
deleted file mode 100644
index cf3b289..0000000
--- a/FAQ.md
+++ /dev/null
@@ -1,289 +0,0 @@
-### Can I run a job immediately?
-
-No, it's recommended to extract the logic from your job instead and to reuse it in a background thread.
-
-```java
-public class DemoSyncJob extends Job {
-
-    public static final String TAG = "job_demo_tag";
-
-    @Override
-    @NonNull
-    protected Result onRunJob(final Params params) {
-        boolean success = new DemoSyncEngine().sync();
-        return success ? Result.SUCCESS : Result.FAILURE;
-    }
-}
-
-public class DemoSyncEngine {
-
-    @WorkerThread
-    public boolean sync() {
-        // do something fancy
-        return true;
-    }
-}
-
-public class SyncHistoryActivity extends Activity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_sync_history);
-
-        syncAsynchronously();
-    }
-
-    private void syncAsynchronously() {
-        new AsyncTask<Void, Void, Boolean>() {
-            @Override
-            protected Boolean doInBackground(Void... params) {
-                return new DemoSyncEngine().sync();
-            }
-
-            @Override
-            protected void onPostExecute(Boolean aBoolean) {
-                refreshView();
-            }
-        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-    }
-}
-```
-
-### How can I run a job at a specific time once a day?
-
-See this sample, which schedules a job between 1 AM and 6 AM each day. Note that this sample isn't using a periodic job, because the periodic jobs don't support a flex parameter (yet).
-
-```java
-public class JobSample extends Job {
-
-    public static final String TAG = "JobSample";
-
-    public static void schedule() {
-        schedule(true);
-    }
-
-    private static void schedule(boolean updateCurrent) {
-        Calendar calendar = Calendar.getInstance();
-        int hour = calendar.get(Calendar.HOUR_OF_DAY);
-        int minute = calendar.get(Calendar.MINUTE);
-
-        // 1 AM - 6 AM, ignore seconds
-        long startMs = TimeUnit.MINUTES.toMillis(60 - minute)
-                + TimeUnit.HOURS.toMillis((24 - hour) % 24);
-        long endMs = startMs + TimeUnit.HOURS.toMillis(5);
-
-        new JobRequest.Builder(TAG)
-                .setExecutionWindow(startMs, endMs)
-                .setPersisted(true)
-                .setUpdateCurrent(updateCurrent)
-                .build()
-                .schedule();
-    }
-
-    @NonNull
-    @Override
-    protected Result onRunJob(Params params) {
-        try {
-            // do something
-            return Result.SUCCESS;
-        } finally {
-            schedule(false); // don't update current, it would cancel this currently running job
-        }
-    }
-}
-```
-
-### Do NOT use `Long.MAX_VALUE` as argument!
-
-Don't use `Long.MAX_VALUE` as argument for the execution window. The `AlarmManager` doesn't allow setting a start date, instead the execution time is the arithmetic average between start and end date.
-
-Your job might work as expected on Android 5+, but maybe won't run at all on older devices.
-
-```java
-// bad, execution time on Android 4.X = startMs + (endMs - startMs) / 2
-new JobRequest.Builder(TAG)
-        .setExecutionWindow(3_000L, Long.MAX_VALUE)
-        .build()
-        .schedule();
-
-// better, execution time on Android 4.X is 2 days
-new JobRequest.Builder(TAG)
-        .setExecutionWindow(TimeUnit.DAYS.toMillis(1), TimeUnit.DAYS.toMillis(3))
-        .build()
-        .schedule();
-```
-
-### Why can't an interval be smaller than 15 minutes for periodic jobs?
-
-This library is a subset of 3 different APIs. Since Android Nougat the minimum interval of periodic jobs is 15 minutes. Although pre Nougat devices support smaller intervals, the least common was chosen as minimum for this library so that periodic jobs run with the same frequency on all devices.
-
-The `JobScheduler` with Android Nougat allows setting a smaller interval, but the value is silently adjusted and a warning is being logged. This library throws an exception instead, so that misbehaving jobs are caught early. You can read more about it [here](https://developer.android.com/reference/android/app/job/JobInfo.html#getMinPeriodMillis()).
-
-### How can I run async operations in a job?
-
-This library automatically creates a wake lock for you so that the system stays on until your job finished. When your job returns a result, then this wakelock is being released and async operations may not finish. The easiest solution is to not return a result until the async operation finished. Don't forget that your job is already executed on a background thread!
-
-```java
-public class AsyncJob extends Job {
-
-    @NonNull
-    @Override
-    protected Result onRunJob(Params params) {
-        final CountDownLatch countDownLatch = new CountDownLatch(1);
-
-        new Thread() {
-            @Override
-            public void run() {
-                // do async operation here
-
-                SystemClock.sleep(3_000L);
-                countDownLatch.countDown();
-            }
-        }.start();
-
-        try {
-            countDownLatch.await();
-        } catch (InterruptedException ignored) {
-        }
-
-        return Result.SUCCESS;
-    }
-}
-```
-
-### How can I remove the GCM dependency from my app?
-
-You need to be careful, if you remove this dependency after it has been already used for a while.
-
-```groovy
-dependencies {
-    compile 'com.google.android.gms:play-services-gcm:9.8.0'
-}
-```
-
-The reason is that jobs probably were scheduled with the GCM API on Android 4.X and after removing the dependency, the Play Services still look for the platform service, but can't find the class anymore. The result is that your app will crash with a runtime exception similar like this:
-
-```
-java.lang.RuntimeException: Unable to instantiate service com.evernote.android.job.gcm.PlatformGcmService: java.lang.ClassNotFoundException: Didn't find class "com.evernote.android.job.gcm.PlatformGcmService" on path: DexPathList[[zip file "/data/app/com.evernote.android.job.demo-2/base.apk"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]
-```
-
-Fortunately, there is a workaround to prevent the crash. You need to remove the GCM service declaration from the manifest like this and then the Play Services won't try to instantiate the missing class.
-
-```xml
-<application
-    ...>
-
-    <service
-        android:name="com.evernote.android.job.gcm.PlatformGcmService"
-        tools:node="remove"/>
-
-</application>
-```
-
-### Why does my job run while the device is offline, although I've requested a network connection?
-
-That's expected. The job should run once during a period or within the specified execution window. The timing is a higher requirement than the network type, which is more like a hint when it's best to run your job. To make sure that all requirements are met, you can call `.setRequirementsEnforced(true)`. This will make sure that your job won't run, if one check fails, e.g.
-
-```java
-new JobRequest.Builder(DemoSyncJob.TAG)
-        .setExecutionWindow(60_000L, 90_000L)
-        .setRequiresCharging(true)
-        .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)
-        .setRequirementsEnforced(true)
-        .build()
-        .schedule();
-```
-
-### I cannot override the Application class. How can I add my `JobCreator`?
-
-There is an alternative. You can register a `BroadcastReceiver` to get notified about that you should add your `JobCreator`, e.g.
-
-```xml
-<receiver
-    android:name=".AddReceiver"
-    android:exported="false">
-        <intent-filter>
-            <action android:name="com.evernote.android.job.ADD_JOB_CREATOR"/>
-        </intent-filter>
-</receiver>
-```
-```java
-public final class AddReceiver extends AddJobCreatorReceiver {
-    @Override
-    protected void addJobCreator(@NonNull Context context, @NonNull JobManager manager) {
-        manager.addJobCreator(new DemoJobCreator());
-    }
-}
-```
-
-### Why aren't my periodic jobs running as expected on Android 5 or higher?
-
-On Android Lollipop or above the `JobScheduler` is used for periodic jobs. Android optimizes apps for battery usage, meaning that it tries to save as much power as possible. If your jobs have a high frequency, then it's possible, that some periods are skipped, because the device is saving battery.
-
-You can read more about Doze and App Standby [in the official documentation](https://developer.android.com/training/monitoring-device-state/doze-standby.html) to understand how it works and its implications.
-
-### What happens with jobs after the app was forced killed?
-
-After the app was force killed (or swiped away from the recent list on some devices) Android clears all pending alarms from the `AlarmManager` for this app. This is problematic, because until the app is being relaunched alarms can't be rescheduled and jobs won't run. Unfortunately, there is no known workaround.
-
-When the app is being relaunched, this library automatically reschedules pending jobs if necessary. The library also register a [boot completed receiver](https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobBootReceiver.java), so that jobs are rescheduled after a reboot.
-
-Note that only the `AlarmManager` is affected. Jobs relying on the `JobScheduler` or `GcmNetworkManager` still work reliable.
-
-### Can I run a job in a different process?
-
-No, that's not possible. The library can't know your process name in advance to start all services in this process. The recommended way is to start your service in the other process from the job.
-
-```java
-public class SeparateProcessJob extends Job {
-    @Override
-    @NonNull
-    protected Result onRunJob(final Params params) {
-        Intent intent = new Intent(getContext(), SeparateProcessService.class);
-        getContext().startService(intent);
-        return Result.SUCCESS;
-    }
-}
-
-public class SeparateProcessService extends IntentService {
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        // do work
-    }
-}
-```
-
-### How can I add a custom logger?
-
-By default the library prints all log statement in Logcat. But often you wish to store those somewhere else, e.g. in a file. The `JobCat` class gives you an option register a custom logger. It's recommended to add the logger before creating the `JobManager` instance.
-
-```java
-private class TestPrinter implements CatPrinter {
-
-    @Override
-    public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
-        switch (priority) {
-            case Log.ERROR:
-                // do something
-                break;
-        }
-    }
-}
-
-public class App extends Application {
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
-        JobCat.addLogPrinter(new TestPrinter());
-        JobManager.create(this).addJobCreator(new DemoJobCreator());
-    }
-}
-```
-
-If you wish, you can even disable printing messages to Logcat, if you own logger handles that for you
-```java
-JobCat.setLogcatEnabled(false);
-```
\ No newline at end of file
diff --git a/README.md b/README.md
index 3702cb4..a80b30c 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # Android-Job
 
-A utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post](https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/) or in [these slides](https://speakerdeck.com/vrallev/scheduling-background-job-on-android-at-the-right-time-1) why you should prefer this library than each separate API. All features from Android Nougat are backward compatible.
+A utility library for Android to run jobs delayed in the background. Depending on the Android version either the `JobScheduler`, `GcmNetworkManager` or `AlarmManager` is getting used. You can find out in [this blog post](https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/) or in [these slides](https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=50) why you should prefer this library than each separate API. All features from Android Oreo are backward compatible back to Ice Cream Sandwich.
 
 ## Download
 
@@ -8,7 +8,7 @@ Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evern
 
 ```groovy
 dependencies {
-    compile 'com.evernote:android-job:1.1.12'
+    compile 'com.evernote:android-job:1.2.0'
 }
 ```
 
@@ -16,13 +16,11 @@ If you didn't turn off the manifest merger from the Gradle build tools, then no
 
 You can read the [JavaDoc here](https://evernote.github.io/android-job/javadoc/).
 
-Testing Android O? You can give version `1.2.0` a try. You find the instruction in the [wiki](https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O).
-
 ## Usage
 
 The class `JobManager` serves as entry point. Your jobs need to extend the class `Job`. Create a `JobRequest` with the corresponding builder class and schedule this request with the `JobManager`.
 
-Before you can use the `JobManager` you must initialize the singleton. You need to provide a `Context` and add a `JobCreator` implementation after that. The `JobCreator` maps a job tag to a specific job class. It's recommended to initialize the `JobManager` in the `onCreate()` method of your `Application` object, but there is [an alternative](FAQ.md#i-cannot-override-the-application-class-how-can-i-add-my-jobcreator), if you don't have access to the `Application` class.
+Before you can use the `JobManager` you must initialize the singleton. You need to provide a `Context` and add a `JobCreator` implementation after that. The `JobCreator` maps a job tag to a specific job class. It's recommended to initialize the `JobManager` in the `onCreate()` method of your `Application` object, but there is [an alternative](https://github.com/evernote/android-job/wiki/FAQ#i-cannot-override-the-application-class-how-can-i-add-my-jobcreator), if you don't have access to the `Application` class.
 
 ```java
 public class App extends Application {
@@ -38,8 +36,8 @@ public class App extends Application {
 ```java
 public class DemoJobCreator implements JobCreator {
 
-    @Override
-    public Job create(String tag) {
+    @Override @Nullable
+    public Job create(@NonNull String tag) {
         switch (tag) {
             case DemoSyncJob.TAG:
                 return new DemoSyncJob();
@@ -92,7 +90,6 @@ private void scheduleAdvancedJob() {
             .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)
             .setExtras(extras)
             .setRequirementsEnforced(true)
-            .setPersisted(true)
             .setUpdateCurrent(true)
             .build()
             .schedule();
@@ -101,7 +98,6 @@ private void scheduleAdvancedJob() {
 private void schedulePeriodicJob() {
     int jobId = new JobRequest.Builder(DemoSyncJob.TAG)
             .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5))
-            .setPersisted(true)
             .build()
             .schedule();
 }
@@ -109,7 +105,13 @@ private void schedulePeriodicJob() {
 private void scheduleExactJob() {
     int jobId = new JobRequest.Builder(DemoSyncJob.TAG)
             .setExact(20_000L)
-            .setPersisted(true)
+            .build()
+            .schedule();
+}
+
+private void runJobImmediately() {
+    int jobId = new JobRequest.Builder(DemoSyncJob.TAG)
+            .startNow()
             .build()
             .schedule();
 }
@@ -138,31 +140,13 @@ public class RescheduleDemoJob extends Job {
 }
 ```
 
-**Warning:** With Android Marshmallow Google introduced the auto backup feature. All job information are stored in a shared preference file called `evernote_jobs.xml` and in a database called `evernote_jobs.db`. You should exclude these files so that they aren't backed up.
-
-You can do this by defining a resource XML file (i.e., `res/xml/backup_config.xml`) with content:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<full-backup-content>
-    <exclude domain="sharedpref" path="evernote_jobs.xml" />
-    <exclude domain="database" path="evernote_jobs.db" />
-</full-backup-content>
-``` 
-
-And then referring to it in your application tag in `AndroidManifest.xml`:
-
-```xml
-<application ...  android:fullBackupContent="@xml/backup_config">
-```
-
 #### Proguard
 
 The library doesn't use reflection, but it relies on three `Service`s and two `BroadcastReceiver`s. In order to avoid any issues, you shouldn't obfuscate those four classes. The library bundles its own Proguard config and you don't need to do anything, but just in case you can add [these rules](library/proguard.txt) in your configuration.
 
-## FAQ
+## More questions?
 
-See [here](FAQ.md).
+See the [FAQ](https://github.com/evernote/android-job/wiki/FAQ) in the [Wiki](https://github.com/evernote/android-job/wiki).
 
 ## Google Play Services
 
@@ -172,7 +156,7 @@ dependencies {
     compile "com.google.android.gms:play-services-gcm:latest_version"
 }
 ```
-Crashes after removing the GCM dependency is a known limitation of the Google Play Services. Please take a look at [this workaround](FAQ.md#how-can-i-remove-the-gcm-dependency-from-my-app) to avoid those crashes.
+Crashes after removing the GCM dependency is a known limitation of the Google Play Services. Please take a look at [this workaround](https://github.com/evernote/android-job/wiki/FAQ#how-can-i-remove-the-gcm-dependency-from-my-app) to avoid those crashes.
 
 ## License
 ```
diff --git a/build-config/gradle-push.gradle b/build-config/gradle-push.gradle
index 5976637..5793ee3 100644
--- a/build-config/gradle-push.gradle
+++ b/build-config/gradle-push.gradle
@@ -39,7 +39,7 @@ android.libraryVariants.all { variant ->
         File outputFile = output.outputFile
         if (outputFile != null && outputFile.name.endsWith('.aar') && 'release'.equals(variant.buildType.name)) {
             def fileName = "${project.archivesBaseName}-${version}.aar"
-            output.outputFile = new File(outputFile.parent, fileName)
+            output.outputFileName = new File(outputFile.parent, fileName)
         }
     }
 }
diff --git a/build-config/gradle-quality.gradle b/build-config/gradle-quality.gradle
index 509d2cb..36d5a32 100644
--- a/build-config/gradle-quality.gradle
+++ b/build-config/gradle-quality.gradle
@@ -15,7 +15,7 @@ task checkstyle(type: Checkstyle) {
 //
 //    reports {
 //        xml {
-//            destination "$project.buildDir/outputs/checkstyle-results.xml"
+//            destination file("$project.buildDir/outputs/checkstyle-results.xml")
 //        }
 //    }
 }
@@ -36,11 +36,11 @@ task findbugs(type: FindBugs) {
         html.enabled = true
 
         xml {
-            destination "$project.buildDir/reports/findbugs/findbugs.xml"
+            destination file("$project.buildDir/reports/findbugs/findbugs.xml")
             xml.withMessages true
         }
         html {
-            destination "$project.buildDir/reports/findbugs/findbugs.html"
+            destination file("$project.buildDir/reports/findbugs/findbugs.html")
         }
     }
 
@@ -61,10 +61,10 @@ task pmd(type: Pmd) {
         html.enabled = true
 
         xml {
-            destination "$project.buildDir/reports/pmd/pmd.xml"
+            destination file("$project.buildDir/reports/pmd/pmd.xml")
         }
         html {
-            destination "$project.buildDir/reports/pmd/pmd.html"
+            destination file("$project.buildDir/reports/pmd/pmd.html")
         }
     }
 }
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index 8e9b158..55470de 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,36 +1,44 @@
 buildscript {
     repositories {
         jcenter()
+        google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.1'
-        classpath 'com.github.ben-manes:gradle-versions-plugin:0.14.0'
+        classpath 'com.android.tools.build:gradle:3.0.0-beta7'
+        classpath 'com.github.ben-manes:gradle-versions-plugin:0.15.0'
     }
 }
 
 allprojects {
     repositories {
         jcenter()
+        google()
+    }
+
+    tasks.withType(JavaCompile) {
+        options.compilerArgs << "-Xlint:unchecked"
+        options.compilerArgs << "-Xlint:deprecation"
     }
 }
 
 ext {
-    compileSdkVersion = 25
+    compileSdkVersion = 26
     targetSdkVersion = compileSdkVersion
     minSdkVersion = 14
 
-    buildToolsVersion = '25.0.2'
+    buildToolsVersion = '26.0.2'
 
-    supportLibVersion = '25.2.0'
-    playServicesVersion = '10.2.6'
-    stethoVersion = '1.4.2'
+    supportLibVersion = '26.0.1'
+    playServicesVersion = '11.0.2'
+    catVersion = '1.0.5'
+    stethoVersion = '1.5.0'
     junitVersion = '4.12'
     assertjVersion = '3.6.2'
     mockitoVersion = '2.7.22'
-    robolectricVersion = '3.3.2'
+    robolectricVersion = '3.4.2'
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '3.5'
+    gradleVersion = '4.1'
     distributionType = 'ALL'
 }
diff --git a/demo/build.gradle b/demo/build.gradle
index 58eb61d..208aed3 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -30,6 +30,7 @@ android {
         gcm.initWith(buildTypes.debug)
         gcm {
             applicationIdSuffix ".gcm"
+            matchingFallbacks = ['debug', 'release']
         }
     }
 
@@ -44,12 +45,13 @@ android {
 }
 
 dependencies {
-    compile project(':library')
-    compile "com.android.support:support-v4:$supportLibVersion"
-    compile "com.android.support:appcompat-v7:$supportLibVersion"
-    compile "com.facebook.stetho:stetho:$stethoVersion"
+    implementation project(':library')
+    implementation "com.android.support:support-v4:$supportLibVersion"
+    implementation "com.android.support:appcompat-v7:$supportLibVersion"
+    implementation "com.facebook.stetho:stetho:$stethoVersion"
+    implementation "net.vrallev.android:cat:$catVersion"
 
-    gcmCompile "com.google.android.gms:play-services-gcm:$playServicesVersion"
+    gcmImplementation "com.google.android.gms:play-services-gcm:$playServicesVersion"
 }
 
 uploadArchives.enabled false
\ No newline at end of file
diff --git a/demo/src/main/java/com/evernote/android/job/demo/App.java b/demo/src/main/java/com/evernote/android/job/demo/App.java
index 5a730f6..ce9d5dc 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/App.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/App.java
@@ -1,8 +1,12 @@
 package com.evernote.android.job.demo;
 
 import android.app.Application;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.evernote.android.job.JobConfig;
 import com.evernote.android.job.JobManager;
+import com.evernote.android.job.util.JobLogger;
 import com.facebook.stetho.Stetho;
 
 /**
@@ -15,6 +19,21 @@ public void onCreate() {
         super.onCreate();
         Stetho.initializeWithDefaults(this);
 
+        JobConfig.addLogger(new JobLogger() {
+            @Override
+            public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+                // log
+            }
+        });
+        JobConfig.setLogcatEnabled(false);
         JobManager.create(this).addJobCreator(new DemoJobCreator());
     }
+
+    private static class MyLogger implements JobLogger {
+        @Override
+        public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+            // log
+        }
+    }
 }
+
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java b/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
index 9a07f75..5f2831b 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/DemoJobCreator.java
@@ -13,7 +13,7 @@
 public class DemoJobCreator implements JobCreator {
 
     @Override
-    public Job create(String tag) {
+    public Job create(@NonNull String tag) {
         switch (tag) {
             case DemoSyncJob.TAG:
                 return new DemoSyncJob();
diff --git a/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java
index 1fad8ef..020284a 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/DemoSyncJob.java
@@ -1,12 +1,15 @@
 package com.evernote.android.job.demo;
 
 import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.Intent;
 import android.graphics.Color;
+import android.os.Build;
 import android.support.annotation.NonNull;
+import android.support.v4.app.NotificationCompat;
 import android.support.v4.app.NotificationManagerCompat;
-import android.support.v7.app.NotificationCompat;
 
 import com.evernote.android.job.Job;
 
@@ -24,23 +27,29 @@
     protected Result onRunJob(final Params params) {
         boolean success = new DemoSyncEngine(getContext()).sync();
 
-        if (params.isPeriodic()) {
-            PendingIntent pendingIntent = PendingIntent.getActivity(getContext(), 0, new Intent(getContext(), MainActivity.class), 0);
-
-            Notification notification = new NotificationCompat.Builder(getContext())
-                    .setContentTitle("Job Demo")
-                    .setContentText("Periodic job ran")
-                    .setAutoCancel(true)
-                    .setContentIntent(pendingIntent)
-                    .setSmallIcon(R.drawable.ic_notification)
-                    .setShowWhen(true)
-                    .setColor(Color.GREEN)
-                    .setLocalOnly(true)
-                    .build();
-
-            NotificationManagerCompat.from(getContext()).notify(new Random().nextInt(), notification);
+        PendingIntent pendingIntent = PendingIntent.getActivity(getContext(), 0, new Intent(getContext(), MainActivity.class), 0);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            NotificationChannel channel = new NotificationChannel(TAG, "Job Demo", NotificationManager.IMPORTANCE_LOW);
+            channel.setDescription("Job demo job");
+            getContext().getSystemService(NotificationManager.class).createNotificationChannel(channel);
         }
 
+        Notification notification = new NotificationCompat.Builder(getContext(), TAG)
+                .setContentTitle("ID " + params.getId())
+                .setContentText("Job ran, exact " + params.isExact() + " , periodic " + params.isPeriodic() + ", transient " + params.isTransient())
+                .setAutoCancel(true)
+                .setChannelId(TAG)
+                .setSound(null)
+                .setContentIntent(pendingIntent)
+                .setSmallIcon(R.drawable.ic_notification)
+                .setShowWhen(true)
+                .setColor(Color.GREEN)
+                .setLocalOnly(true)
+                .build();
+
+        NotificationManagerCompat.from(getContext()).notify(new Random().nextInt(), notification);
+
         return success ? Result.SUCCESS : Result.FAILURE;
     }
 }
diff --git a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
index cd3b72f..450f5c0 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
@@ -11,9 +11,10 @@
 import android.widget.CompoundButton;
 import android.widget.Spinner;
 
+import com.evernote.android.job.JobConfig;
 import com.evernote.android.job.JobManager;
 import com.evernote.android.job.JobRequest;
-import com.evernote.android.job.util.JobApi;
+import com.evernote.android.job.JobApi;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.Cat;
@@ -27,7 +28,6 @@
 
     private int mLastJobId;
 
-    private CompoundButton mEnableGcm;
     private CompoundButton mRequiresCharging;
     private CompoundButton mRequiresDeviceIdle;
     private Spinner mNetworkTypeSpinner;
@@ -45,21 +45,21 @@ protected void onCreate(Bundle savedInstanceState) {
             mLastJobId = savedInstanceState.getInt(LAST_JOB_ID, 0);
         }
 
-        mEnableGcm = (CompoundButton) findViewById(R.id.enable_gcm);
-        mRequiresCharging = (CompoundButton) findViewById(R.id.check_requires_charging);
-        mRequiresDeviceIdle = (CompoundButton) findViewById(R.id.check_requires_device_idle);
-        mNetworkTypeSpinner = (Spinner) findViewById(R.id.spinner_network_type);
+        CompoundButton enableGcm = findViewById(R.id.enable_gcm);
+        mRequiresCharging = findViewById(R.id.check_requires_charging);
+        mRequiresDeviceIdle = findViewById(R.id.check_requires_device_idle);
+        mNetworkTypeSpinner = findViewById(R.id.spinner_network_type);
 
         ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, getNetworkTypesAsString());
         adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
         mNetworkTypeSpinner.setAdapter(adapter);
 
-        mEnableGcm.setChecked(mJobManager.getConfig().isGcmApiEnabled());
-        mEnableGcm.setEnabled(JobApi.GCM.isSupported(this));
-        mEnableGcm.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+        enableGcm.setChecked(JobConfig.isApiEnabled(JobApi.GCM));
+        enableGcm.setEnabled(JobApi.GCM.isSupported(this));
+        enableGcm.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
             @Override
             public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                mJobManager.getConfig().setGcmApiEnabled(isChecked);
+                JobConfig.setApiEnabled(JobApi.GCM, isChecked);
             }
         });
     }
@@ -80,6 +80,11 @@ public boolean onCreateOptionsMenu(Menu menu) {
     public boolean onPrepareOptionsMenu(Menu menu) {
         super.onPrepareOptionsMenu(menu);
 
+        if (JobApi.V_26.isSupported(this)) {
+            menu.findItem(R.id.action_force_26).setChecked(false);
+        } else {
+            menu.findItem(R.id.action_force_26).setVisible(false);
+        }
         if (JobApi.V_24.isSupported(this)) {
             menu.findItem(R.id.action_force_24).setChecked(false);
         } else {
@@ -106,7 +111,10 @@ public boolean onPrepareOptionsMenu(Menu menu) {
             menu.findItem(R.id.action_force_gcm).setVisible(false);
         }
 
-        switch (mJobManager.getApi()) {
+        switch (JobApi.getDefault(this)) {
+            case V_26:
+                menu.findItem(R.id.action_force_26).setChecked(true);
+                break;
             case V_24:
                 menu.findItem(R.id.action_force_24).setChecked(true);
                 break;
@@ -132,20 +140,23 @@ public boolean onPrepareOptionsMenu(Menu menu) {
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
+            case R.id.action_force_26:
+                JobConfig.forceApi(JobApi.V_26);
+                return true;
             case R.id.action_force_24:
-                mJobManager.forceApi(JobApi.V_24);
+                JobConfig.forceApi(JobApi.V_24);
                 return true;
             case R.id.action_force_21:
-                mJobManager.forceApi(JobApi.V_21);
+                JobConfig.forceApi(JobApi.V_21);
                 return true;
             case R.id.action_force_19:
-                mJobManager.forceApi(JobApi.V_19);
+                JobConfig.forceApi(JobApi.V_19);
                 return true;
             case R.id.action_force_14:
-                mJobManager.forceApi(JobApi.V_14);
+                JobConfig.forceApi(JobApi.V_14);
                 return true;
             case R.id.action_force_gcm:
-                mJobManager.forceApi(JobApi.GCM);
+                JobConfig.forceApi(JobApi.GCM);
                 return true;
             default:
                 return super.onOptionsItemSelected(item);
@@ -196,24 +207,21 @@ private void testSimple() {
                 .setRequiredNetworkType(JobRequest.NetworkType.values()[mNetworkTypeSpinner.getSelectedItemPosition()])
                 .setExtras(extras)
                 .setRequirementsEnforced(true)
-                .setPersisted(true)
                 .build()
                 .schedule();
     }
 
     private void testAllImpl() {
-        JobApi currentApi = mJobManager.getApi();
-
         for (JobApi api : JobApi.values()) {
             if (api.isSupported(this)) {
-                mJobManager.forceApi(api);
+                JobConfig.forceApi(api);
                 testSimple();
             } else {
                 Cat.w("%s is not supported", api);
             }
         }
 
-        mJobManager.forceApi(currentApi);
+        JobConfig.reset();
     }
 
     private void testPeriodic() {
@@ -222,7 +230,6 @@ private void testPeriodic() {
                 .setRequiresCharging(mRequiresCharging.isChecked())
                 .setRequiresDeviceIdle(mRequiresDeviceIdle.isChecked())
                 .setRequiredNetworkType(JobRequest.NetworkType.values()[mNetworkTypeSpinner.getSelectedItemPosition()])
-                .setPersisted(true)
                 .build()
                 .schedule();
     }
@@ -234,9 +241,7 @@ private void testExact() {
         mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
                 .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
                 .setExtras(extras)
-                .setExact(20_000L)
-                .setPersisted(true)
-                .setUpdateCurrent(true)
+                .setExact(10_000L)
                 .build()
                 .schedule();
     }
diff --git a/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java b/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java
index ab24129..1085829 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/SyncHistoryActivity.java
@@ -1,5 +1,6 @@
 package com.evernote.android.job.demo;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.os.AsyncTask;
 import android.os.Bundle;
@@ -42,6 +43,7 @@ public boolean onOptionsItemSelected(MenuItem item) {
         }
     }
 
+    @SuppressLint("StaticFieldLeak")
     private void syncAsynchronously() {
         new AsyncTask<Void, Void, Boolean>() {
             @Override
diff --git a/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
index b6fe215..4f13696 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
@@ -19,7 +19,7 @@ public void createV1() {
     }
 
     public void createV2() {
-        createJobs(new DummyJobCreatorV1()); // same as v1, only transient column is new
+        createJobs(new DummyJobCreatorV1()); // same as v1, only isTransient column is new
     }
 
     public void createV3() {
@@ -30,6 +30,14 @@ public void createV4() {
         createJobs(new DummyJobCreatorV3()); // same as v3, only last run column is new
     }
 
+    public void createV5() {
+        createJobs(new DummyJobCreatorV3());
+    }
+
+    public void createV6() {
+        createJobs(new DummyJobCreatorV6());
+    }
+
     private void createJobs(DummyJobCreator creator) {
         creator.createOneOff();
         creator.createExact();
@@ -54,8 +62,7 @@ public void createOneOff() {
                         .setRequiresCharging(random())
                         .setRequiresDeviceIdle(random())
                         .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
-                        .setRequirementsEnforced(random())
-                        .setPersisted(random());
+                        .setRequirementsEnforced(random());
 
                 if (random()) {
                     PersistableBundleCompat extras = new PersistableBundleCompat();
@@ -65,7 +72,6 @@ public void createOneOff() {
 
                 builder.build().schedule();
             }
-
         }
 
         @Override
@@ -73,8 +79,7 @@ public void createExact() {
             for (int i = 0; i < 10; i++) {
                 JobRequest.Builder builder = new JobRequest.Builder("tag")
                         .setExact(400_000)
-                        .setBackoffCriteria(5_000L, random() ? JobRequest.BackoffPolicy.EXPONENTIAL : JobRequest.BackoffPolicy.LINEAR)
-                        .setPersisted(random());
+                        .setBackoffCriteria(5_000L, random() ? JobRequest.BackoffPolicy.EXPONENTIAL : JobRequest.BackoffPolicy.LINEAR);
 
                 if (random()) {
                     PersistableBundleCompat extras = new PersistableBundleCompat();
@@ -84,7 +89,6 @@ public void createExact() {
 
                 builder.build().schedule();
             }
-
         }
 
         @Override
@@ -95,8 +99,7 @@ public void createPeriodic() {
                         .setRequiresCharging(random())
                         .setRequiresDeviceIdle(random())
                         .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
-                        .setRequirementsEnforced(random())
-                        .setPersisted(random());
+                        .setRequirementsEnforced(random());
 
                 if (random()) {
                     PersistableBundleCompat extras = new PersistableBundleCompat();
@@ -109,7 +112,7 @@ public void createPeriodic() {
         }
     }
 
-    private static final class DummyJobCreatorV3 extends DummyJobCreatorV1 {
+    private static class DummyJobCreatorV3 extends DummyJobCreatorV1 {
         @Override
         public void createPeriodic() {
             for (int i = 0; i < 10; i++) {
@@ -117,8 +120,7 @@ public void createPeriodic() {
                         .setRequiresCharging(random())
                         .setRequiresDeviceIdle(random())
                         .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
-                        .setRequirementsEnforced(random())
-                        .setPersisted(random());
+                        .setRequirementsEnforced(random());
 
                 if (random()) {
                     PersistableBundleCompat extras = new PersistableBundleCompat();
@@ -133,7 +135,56 @@ public void createPeriodic() {
 
                 builder.build().schedule();
             }
-
         }
     }
+
+    private static class DummyJobCreatorV6 extends DummyJobCreatorV3 {
+        @Override
+        public void createOneOff() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setExecutionWindow(300_000, 400_000)
+                        .setBackoffCriteria(5_000L, random() ? JobRequest.BackoffPolicy.EXPONENTIAL : JobRequest.BackoffPolicy.LINEAR)
+                        .setRequiresCharging(random())
+                        .setRequiresDeviceIdle(random())
+                        .setRequiresBatteryNotLow(random())
+                        .setRequiresStorageNotLow(random())
+                        .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
+                        .setRequirementsEnforced(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+
+                builder.build().schedule();
+            }
+        }
+
+        @Override
+        public void createPeriodic() {
+            for (int i = 0; i < 10; i++) {
+                JobRequest.Builder builder = new JobRequest.Builder("tag")
+                        .setRequiresCharging(random())
+                        .setRequiresDeviceIdle(random())
+                        .setRequiresBatteryNotLow(random())
+                        .setRequiresStorageNotLow(random())
+                        .setRequiredNetworkType(random() ? JobRequest.NetworkType.ANY : JobRequest.NetworkType.CONNECTED)
+                        .setRequirementsEnforced(random());
+
+                if (random()) {
+                    PersistableBundleCompat extras = new PersistableBundleCompat();
+                    extras.putString("key", "Hello world");
+                    builder.setExtras(extras);
+                }
+                if (random()) {
+                    builder.setPeriodic(JobRequest.MIN_INTERVAL);
+                } else {
+                    builder.setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX);
+                }
+
+                builder.build().schedule();
+            }
+        }    }
 }
diff --git a/demo/src/main/res/menu/activity_main.xml b/demo/src/main/res/menu/activity_main.xml
index 0dcfb3e..9dd9b3c 100644
--- a/demo/src/main/res/menu/activity_main.xml
+++ b/demo/src/main/res/menu/activity_main.xml
@@ -5,6 +5,10 @@
       tools:ignore="HardcodedText">
 
     <group android:checkableBehavior="single">
+        <item
+            android:id="@+id/action_force_26"
+            android:title="v26"
+            app:showAsAction="never"/>
         <item
             android:id="@+id/action_force_24"
             android:title="v24"
diff --git a/gradle.properties b/gradle.properties
index 85f0cfe..ead10b4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,3 @@
-#VERSION_NAME=1.1.12
-VERSION_NAME=1.1.12-SNAPSHOT
+#VERSION_NAME=1.2.0
+VERSION_NAME=1.2.0-RC6
 VERSION_CODE=1
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 298103c..7a3265e 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 9cc9c14..bf1b63c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Sat Apr 15 12:24:53 CEST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.5-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/gradlew b/gradlew
index 4453cce..cccdd3d 100755
--- a/gradlew
+++ b/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/library/build.gradle b/library/build.gradle
index 1f9cd84..be804f9 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -5,25 +5,24 @@ apply from: '../build-config/gradle-quality.gradle'
 archivesBaseName = 'android-job'
 
 dependencies {
-    provided "com.google.android.gms:play-services-gcm:$playServicesVersion"
+    compileOnly "com.google.android.gms:play-services-gcm:$playServicesVersion"
 
     //noinspection GradleDependency
-    compile "com.android.support:support-annotations:$supportLibVersion"
-    compile "com.android.support:support-v4:$supportLibVersion"
-    compile 'net.vrallev.android:cat:1.0.5'
-
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
-    androidTestCompile 'com.squareup.assertj:assertj-android:1.1.1'
-    androidTestCompile "com.google.android.gms:play-services-gcm:$playServicesVersion"
-
-    androidTestCompile "com.facebook.stetho:stetho:$stethoVersion"
-
-    testCompile "junit:junit:$junitVersion"
-    testCompile "org.mockito:mockito-core:$mockitoVersion"
-    testCompile "org.assertj:assertj-core:$assertjVersion"
-    testCompile "org.robolectric:robolectric:$robolectricVersion"
+    api "com.android.support:support-v4:$supportLibVersion"
+    implementation "net.vrallev.android:cat:$catVersion"
+
+    androidTestImplementation 'com.android.support.test:runner:1.0.0'
+    androidTestImplementation 'com.android.support.test:rules:1.0.0'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
+    androidTestImplementation 'com.squareup.assertj:assertj-android:1.1.1'
+    androidTestImplementation "com.google.android.gms:play-services-gcm:$playServicesVersion"
+
+    androidTestImplementation "com.facebook.stetho:stetho:$stethoVersion"
+
+    testImplementation "junit:junit:$junitVersion"
+    testImplementation "org.mockito:mockito-core:$mockitoVersion"
+    testImplementation "org.assertj:assertj-core:$assertjVersion"
+    testImplementation "org.robolectric:robolectric:$robolectricVersion"
 }
 
 android {
@@ -39,7 +38,7 @@ android {
         versionName project.VERSION_NAME
         versionCode Integer.parseInt(project.VERSION_CODE)
 
-        consumerProguardFiles 'proguard.txt'
+        consumerProguardFiles 'proguard.cfg'
 
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
@@ -55,6 +54,7 @@ android {
 
     testOptions {
         unitTests.returnDefaultValues = true
+        unitTests.includeAndroidResources = true
         unitTests.all {
             testLogging {
                 events 'passed', 'skipped', 'failed', 'standardOut', 'standardError'
diff --git a/library/lint.xml b/library/lint.xml
index 75ce987..972ee49 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -12,4 +12,5 @@
     <issue id="Registered">
         <ignore path="src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java"/>
     </issue>
+    <issue id="GradleDependency" severity="ignore"/>
 </lint>
\ No newline at end of file
diff --git a/library/proguard.txt b/library/proguard.cfg
similarity index 86%
rename from library/proguard.txt
rename to library/proguard.cfg
index 92506fb..0c57ece 100644
--- a/library/proguard.txt
+++ b/library/proguard.cfg
@@ -1,5 +1,5 @@
 -dontwarn com.evernote.android.job.gcm.**
--dontwarn com.evernote.android.job.util.GcmAvailableHelper
+-dontwarn com.evernote.android.job.GcmAvailableHelper
 
 -keep public class com.evernote.android.job.v21.PlatformJobService
 -keep public class com.evernote.android.job.v14.PlatformAlarmService
diff --git a/library/src/androidTest/java/com/evernote/android/job/DisabledServiceTest.java b/library/src/androidTest/java/com/evernote/android/job/DisabledServiceTest.java
new file mode 100644
index 0000000..7348af0
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/DisabledServiceTest.java
@@ -0,0 +1,69 @@
+package com.evernote.android.job;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.evernote.android.job.v21.PlatformJobService;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ * @since 09.05.17
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class DisabledServiceTest {
+
+    private Context mContext;
+    private PackageManager mPackageManager;
+    private ComponentName mComponent;
+
+    @Rule
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
+
+    @Before
+    public void prepare() {
+        mContext = InstrumentationRegistry.getTargetContext();
+        mPackageManager = mContext.getPackageManager();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            mComponent = new ComponentName(mContext, PlatformJobService.class);
+        }
+    }
+
+    @After
+    public void cleanup() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            mPackageManager.setComponentEnabledSetting(mComponent, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT, PackageManager.DONT_KILL_APP);
+        }
+    }
+
+    @Test
+    public void verifyJobApiNotSupportedWhenServiceIsDisabled() {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            assertThat(JobApi.V_26.isSupported(mContext)).isTrue();
+        }
+        assertThat(JobApi.V_24.isSupported(mContext)).isTrue();
+        assertThat(JobApi.V_21.isSupported(mContext)).isTrue();
+
+        mPackageManager.setComponentEnabledSetting(mComponent, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
+
+        assertThat(JobApi.V_26.isSupported(mContext)).isFalse();
+        assertThat(JobApi.V_24.isSupported(mContext)).isFalse();
+        assertThat(JobApi.V_21.isSupported(mContext)).isFalse();
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java
deleted file mode 100644
index 96ae15c..0000000
--- a/library/src/androidTest/java/com/evernote/android/job/JobManagerRule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.evernote.android.job;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.rules.ExternalResource;
-
-/**
- * @author rwondratschek
- */
-public class JobManagerRule extends ExternalResource {
-
-    private JobManager mManager;
-
-    @Override
-    protected void before() throws Throwable {
-        mManager = JobManager.create(InstrumentationRegistry.getTargetContext());
-    }
-
-    @Override
-    protected void after() {
-        mManager.cancelAll();
-        mManager.destroy();
-    }
-
-    public JobManager getManager() {
-        return mManager;
-    }
-}
diff --git a/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java b/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java
index 7114d74..896d647 100644
--- a/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java
+++ b/library/src/androidTest/java/com/evernote/android/job/Platform21Test.java
@@ -1,9 +1,6 @@
 package com.evernote.android.job;
 
-import android.app.job.JobScheduler;
-import android.content.Context;
 import android.os.Build;
-import android.support.test.InstrumentationRegistry;
 import android.support.test.filters.LargeTest;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -11,9 +8,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.TimeUnit;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 import static org.junit.Assume.assumeTrue;
 
 /**
@@ -24,7 +20,7 @@
 public class Platform21Test {
 
     @Rule
-    public JobManagerRule mJobManagerRule = new JobManagerRule();
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
 
     @Test(expected = IllegalStateException.class)
     public void test100DistinctJobsLimit() {
@@ -37,31 +33,26 @@ public void test100DistinctJobsLimit() {
                     .schedule();
         }
 
-        throw new AssertionError("It shouldn't be possible to create more than 100 distinct jobs with the JobScheduler");
+        fail("It shouldn't be possible to create more than 100 distinct jobs with the JobScheduler");
     }
 
     @Test
     public void testRescheduleService() throws Exception {
         assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
 
-        JobManager manager = mJobManagerRule.getManager();
-        Context context = InstrumentationRegistry.getTargetContext();
-
         int jobId = new JobRequest.Builder("tag")
                 .setExecutionWindow(300_000, 400_000)
                 .build()
                 .schedule();
 
-        assertThat(manager.getAllJobRequests()).hasSize(1);
+        assertThat(mJobManagerRule.getManager().getAllJobRequests()).hasSize(1);
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).hasSize(1);
 
-        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        assertThat(jobScheduler.getAllPendingJobs()).hasSize(1);
+        mJobManagerRule.getJobScheduler().cancel(jobId);
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).isEmpty();
 
-        jobScheduler.cancel(jobId);
-        assertThat(jobScheduler.getAllPendingJobs()).isEmpty();
-
-        JobRescheduleService.latch.await(15, TimeUnit.SECONDS);
-        assertThat(jobScheduler.getAllPendingJobs()).hasSize(1);
+        waitForJobRescheduleService();
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).hasSize(1);
     }
 
     @Test
@@ -76,22 +67,20 @@ public void verifyNotLandingInCrashLoop() throws Exception {
                         .schedule();
             }
 
-            throw new AssertionError("It shouldn't be possible to create more than 100 distinct jobs with the JobScheduler");
+            fail("It shouldn't be possible to create more than 100 distinct jobs with the JobScheduler");
 
         } catch (Exception ignored) {
         }
 
         JobManager manager = mJobManagerRule.getManager();
-        Context context = InstrumentationRegistry.getTargetContext();
 
         int jobCount = manager.getAllJobRequests().size();
         assertThat(manager.getAllJobRequests()).isNotEmpty();
 
-        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        assertThat(jobScheduler.getAllPendingJobs()).hasSize(jobCount);
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).hasSize(jobCount);
 
-        jobScheduler.cancelAll();
-        assertThat(jobScheduler.getAllPendingJobs()).isEmpty();
+        mJobManagerRule.getJobScheduler().cancelAll();
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).isEmpty();
 
         final int moreJobs = 50;
         for (int i = 0; i < moreJobs; i++) {
@@ -103,7 +92,11 @@ public void verifyNotLandingInCrashLoop() throws Exception {
 
         assertThat(manager.getAllJobRequests()).hasSize(jobCount + moreJobs);
 
-        JobRescheduleService.latch.await(15, TimeUnit.SECONDS);
-        assertThat(jobScheduler.getAllPendingJobs()).hasSize(jobCount);
+        waitForJobRescheduleService();
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler().size()).isGreaterThanOrEqualTo(jobCount);
+    }
+
+    private void waitForJobRescheduleService() throws InterruptedException {
+        new JobRescheduleService().rescheduleJobs(mJobManagerRule.getManager());
     }
 }
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java b/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java
new file mode 100644
index 0000000..72c3765
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformJobManagerRule.java
@@ -0,0 +1,67 @@
+package com.evernote.android.job;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.content.Context;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.rules.ExternalResource;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author rwondratschek
+ */
+public class PlatformJobManagerRule extends ExternalResource {
+
+    private JobManager mManager;
+
+    @Override
+    protected void before() throws Throwable {
+        JobConfig.setJobReschedulePause(0, TimeUnit.MILLISECONDS);
+        JobConfig.setSkipJobReschedule(true);
+
+        mManager = JobManager.create(InstrumentationRegistry.getTargetContext());
+        mManager.cancelAll();
+    }
+
+    @Override
+    protected void after() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            getJobScheduler().cancelAll();
+        }
+
+        mManager.cancelAll();
+        mManager.destroy();
+
+        getJobScheduler().cancelAll();
+        JobConfig.reset();
+    }
+
+    public JobManager getManager() {
+        return mManager;
+    }
+
+    public JobScheduler getJobScheduler() {
+        return (JobScheduler) InstrumentationRegistry.getTargetContext().getSystemService(Context.JOB_SCHEDULER_SERVICE);
+    }
+
+    public List<JobInfo> getAllPendingJobsFromScheduler() {
+        JobScheduler jobScheduler = getJobScheduler();
+        ArrayList<JobInfo> jobs = new ArrayList<>(jobScheduler.getAllPendingJobs());
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            Iterator<JobInfo> iterator = jobs.iterator();
+            while (iterator.hasNext()) {
+                if (iterator.next().getId() == JobIdsInternal.JOB_ID_JOB_RESCHEDULE_SERVICE) {
+                    iterator.remove();
+                }
+            }
+        }
+        return jobs;
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
index b856e21..cca4406 100644
--- a/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
+++ b/library/src/androidTest/java/com/evernote/android/job/PlatformTest.java
@@ -1,17 +1,19 @@
 package com.evernote.android.job;
 
 import android.content.Context;
+import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.filters.LargeTest;
 import android.support.test.runner.AndroidJUnit4;
 
 import com.evernote.android.job.gcm.PlatformGcmService;
-import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.v14.PlatformAlarmService;
+import com.evernote.android.job.v14.PlatformAlarmServiceExact;
 import com.evernote.android.job.v21.PlatformJobService;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -34,7 +36,7 @@
     private TestJob mJob;
 
     @Rule
-    public JobManagerRule mJobManagerRule = new JobManagerRule();
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
 
     @Before
     public void prepare() {
@@ -53,8 +55,9 @@ public void testApi19() throws Exception {
     }
 
     @Test
+    @Ignore
     public void testApiGcm() throws Exception {
-        testOneOff(JobApi.GCM, 40, TimeUnit.SECONDS);
+        testOneOff(JobApi.GCM, 60, TimeUnit.SECONDS);
     }
 
     @Test
@@ -68,22 +71,52 @@ public void testApi24() throws Exception {
     }
 
     @Test
-    public void testExact() throws Exception {
+    public void testApi26() throws Exception {
+        testOneOff(JobApi.V_26);
+    }
+
+    @Test
+    public void testExactRealTime() throws Exception {
+        testJobExact();
+    }
+
+    @Test
+    public void testExactRtc() throws Exception {
+        JobConfig.setForceRtc(true);
+        testJobExact();
+    }
+
+    private void testJobExact() throws Exception {
+        mJob = new TestJob(PlatformAlarmServiceExact.class);
+
+        new JobRequest.Builder("tag")
+                .setExact(1_000)
+                .build()
+                .schedule();
+
+        mJob.verifyJob(12, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testStartNow() throws Exception {
         mJob = new TestJob(PlatformAlarmService.class);
 
         new JobRequest.Builder("tag")
-                .setExact(2_000)
+                .startNow()
                 .build()
                 .schedule();
 
-        mJob.mLatch.await(4, TimeUnit.SECONDS);
+        mJob.verifyJob(3, TimeUnit.SECONDS);
     }
 
     private void testOneOff(JobApi api) throws Exception {
-        testOneOff(api, 10, TimeUnit.SECONDS);
+        testOneOff(api, 15, TimeUnit.SECONDS);
     }
 
     private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Exception {
+        // ignore test if not supported
+        assumeTrue(api.isSupported(InstrumentationRegistry.getTargetContext()));
+
         switch (api) {
             case V_14:
             case V_19:
@@ -94,23 +127,21 @@ private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Excepti
                 break;
             case V_21:
             case V_24:
+            case V_26:
                 mJob = new TestJob(PlatformJobService.class);
                 break;
             default:
                 throw new IllegalStateException("not implemented");
         }
 
-        // ignore test if not supported
-        assumeTrue(api.isSupported(InstrumentationRegistry.getTargetContext()));
-
-        mManager.forceApi(api);
+        JobConfig.forceApi(api);
 
         int jobId = new JobRequest.Builder("tag")
-                .setExecutionWindow(2_000, 3_000)
+                .setExecutionWindow(1_000, 2_000)
                 .build()
                 .schedule();
 
-        mJob.mLatch.await(wait, timeUnit);
+        mJob.verifyJob(wait, timeUnit);
 
         // give the platform implementation some time to clean everything up
         Thread.sleep(300L);
@@ -124,6 +155,9 @@ private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Excepti
         private final CountDownLatch mLatch = new CountDownLatch(1);
         private final Class<? extends Context> mExpectedContext;
 
+        private Context mContext;
+        private Params mParams;
+
         private TestJob(Class<? extends Context> expectedContext) {
             mExpectedContext = expectedContext;
         }
@@ -131,16 +165,26 @@ private TestJob(Class<? extends Context> expectedContext) {
         @NonNull
         @Override
         protected Result onRunJob(Params params) {
-            assertThat(getContext()).isInstanceOf(mExpectedContext);
+            mContext = getContext();
+            mParams = params;
 
             mLatch.countDown();
             return Result.SUCCESS;
         }
+
+        private void verifyJob(long wait, TimeUnit timeUnit) throws InterruptedException {
+            assertThat(mJob.mLatch.await(wait, timeUnit)).isTrue();
+
+            assertThat(mContext).isInstanceOf(mExpectedContext);
+
+            Bundle extras = mParams.getTransientExtras();
+            assertThat(extras).isNotNull();
+        }
     }
 
     private final class TestJobCreator implements JobCreator {
         @Override
-        public Job create(String tag) {
+        public Job create(@NonNull String tag) {
             return mJob;
         }
     }
diff --git a/library/src/androidTest/java/com/evernote/android/job/TransientBundleRescheduleTest.java b/library/src/androidTest/java/com/evernote/android/job/TransientBundleRescheduleTest.java
new file mode 100644
index 0000000..bf1e89a
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/TransientBundleRescheduleTest.java
@@ -0,0 +1,106 @@
+package com.evernote.android.job;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ */
+@SuppressWarnings("SameParameterValue")
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class TransientBundleRescheduleTest {
+
+    private JobManager mManager;
+
+    private CountDownLatch mLatch;
+    private Job.Params mParams;
+    private int mCount;
+
+    @Rule
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
+
+    @Before
+    public void prepare() {
+        mManager = mJobManagerRule.getManager();
+        mManager.addJobCreator(new TestJobCreator());
+        mLatch = new CountDownLatch(1);
+    }
+
+    @Test
+    public void testRescheduleHasTransientBundle() throws Exception {
+        testOneOff(JobApi.V_21, 30, TimeUnit.SECONDS);
+    }
+
+    private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Exception {
+        // ignore test if not supported
+        assumeTrue(api.isSupported(InstrumentationRegistry.getTargetContext()));
+
+        JobConfig.forceApi(api);
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(500, 1_000)
+                .setTransientExtras(createTransientBundle())
+                .setBackoffCriteria(500, JobRequest.BackoffPolicy.LINEAR)
+                .build()
+                .schedule();
+
+        JobRequest request = mManager.getJobRequest(jobId);
+        assertThat(request).isNotNull();
+
+        boolean scheduled = api.getProxy(InstrumentationRegistry.getContext()).isPlatformJobScheduled(request);
+        assertThat(scheduled).isTrue();
+
+        assertThat(mLatch.await(wait, timeUnit)).isTrue();
+
+        Bundle extras = mParams.getTransientExtras();
+        assertThat(extras).isNotNull();
+        assertThat(extras.getString("Key")).isEqualTo("Value");
+    }
+
+    private final class TestJob extends Job {
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            Bundle extras = params.getTransientExtras();
+            assertThat(extras).isNotNull();
+            assertThat(extras.getString("Key")).isEqualTo("Value");
+
+            if (++mCount < 3) {
+                return Result.RESCHEDULE;
+            }
+
+            mParams = params;
+            mLatch.countDown();
+            return Result.SUCCESS;
+        }
+    }
+
+    private final class TestJobCreator implements JobCreator {
+        @Override
+        public Job create(@NonNull String tag) {
+            return new TestJob();
+        }
+    }
+
+    private static Bundle createTransientBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putString("Key", "Value");
+        return bundle;
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/TransientBundleTest.java b/library/src/androidTest/java/com/evernote/android/job/TransientBundleTest.java
new file mode 100644
index 0000000..73de6ac
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/TransientBundleTest.java
@@ -0,0 +1,161 @@
+package com.evernote.android.job;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class TransientBundleTest {
+
+    private JobManager mManager;
+
+    private TestJob mJob;
+
+    @Rule
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
+
+    @Before
+    public void prepare() {
+        mManager = mJobManagerRule.getManager();
+        mManager.addJobCreator(new TestJobCreator());
+    }
+
+    @Test
+    public void testApi14() throws Exception {
+        testOneOff(JobApi.V_14);
+    }
+
+    @Test
+    public void testApi19() throws Exception {
+        testOneOff(JobApi.V_19);
+    }
+
+    @Test
+    @Ignore
+    public void testApiGcm() throws Exception {
+        testOneOff(JobApi.GCM, 60, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testApi21() throws Exception {
+        testOneOff(JobApi.V_21);
+    }
+
+    @Test
+    public void testApi24() throws Exception {
+        testOneOff(JobApi.V_24);
+    }
+
+    @Test
+    public void testApi26() throws Exception {
+        testOneOff(JobApi.V_26);
+    }
+
+    @Test
+    public void testExact() throws Exception {
+        mJob = new TestJob();
+
+        new JobRequest.Builder("tag")
+                .setExact(1_000)
+                .setTransientExtras(createTransientBundle())
+                .build()
+                .schedule();
+
+        mJob.verifyJob(12, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testStartNow() throws Exception {
+        mJob = new TestJob();
+
+        new JobRequest.Builder("tag")
+                .startNow()
+                .setTransientExtras(createTransientBundle())
+                .build()
+                .schedule();
+
+        mJob.verifyJob(3, TimeUnit.SECONDS);
+    }
+
+    private void testOneOff(JobApi api) throws Exception {
+        testOneOff(api, 15, TimeUnit.SECONDS);
+    }
+
+    private void testOneOff(JobApi api, long wait, TimeUnit timeUnit) throws Exception {
+        mJob = new TestJob();
+
+        // ignore test if not supported
+        assumeTrue(api.isSupported(InstrumentationRegistry.getTargetContext()));
+
+        JobConfig.forceApi(api);
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(1_000, 2_000)
+                .setTransientExtras(createTransientBundle())
+                .build()
+                .schedule();
+
+        JobRequest request = mManager.getJobRequest(jobId);
+        assertThat(request).isNotNull();
+
+        boolean scheduled = api.getProxy(InstrumentationRegistry.getContext()).isPlatformJobScheduled(request);
+        assertThat(scheduled).isTrue();
+
+        mJob.verifyJob(wait, timeUnit);
+    }
+
+    private final class TestJob extends Job {
+
+        private final CountDownLatch mLatch = new CountDownLatch(1);
+
+        private Params mParams;
+
+        @NonNull
+        @Override
+        protected Result onRunJob(Params params) {
+            mParams = params;
+
+            mLatch.countDown();
+            return Result.SUCCESS;
+        }
+
+        private void verifyJob(long wait, TimeUnit timeUnit) throws InterruptedException {
+            assertThat(mJob.mLatch.await(wait, timeUnit)).isTrue();
+
+            Bundle extras = mParams.getTransientExtras();
+            assertThat(extras).isNotNull();
+            assertThat(extras.getString("Key")).isEqualTo("Value");
+        }
+    }
+
+    private final class TestJobCreator implements JobCreator {
+        @Override
+        public Job create(@NonNull String tag) {
+            return mJob;
+        }
+    }
+
+    private static Bundle createTransientBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putString("Key", "Value");
+        return bundle;
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/TransientJobCleanUpTest.java b/library/src/androidTest/java/com/evernote/android/job/TransientJobCleanUpTest.java
new file mode 100644
index 0000000..c258c64
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/TransientJobCleanUpTest.java
@@ -0,0 +1,100 @@
+package com.evernote.android.job;
+
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.test.filters.LargeTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(AndroidJUnit4.class)
+@LargeTest
+public class TransientJobCleanUpTest {
+
+    private JobManager mManager;
+
+    @Rule
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
+
+    @Before
+    public void prepare() {
+        mManager = mJobManagerRule.getManager();
+    }
+
+    @Test
+    public void verifyJobDeletedFromDatabaseSpecific() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+        JobConfig.forceApi(JobApi.V_21);
+
+        Bundle bundle = new Bundle();
+        bundle.putString("key", "value");
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(40_000, 50_000)
+                .setTransientExtras(bundle)
+                .build()
+                .schedule();
+
+        assertThat(mManager.getAllJobRequests()).hasSize(1);
+        assertThat(mManager.getJobRequest(jobId)).isNotNull();
+
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).hasSize(1);
+
+        mJobManagerRule.getJobScheduler().cancel(jobId);
+
+        // cached request gone
+        assertThat(mManager.getJobRequest(jobId)).isNull();
+
+        SQLiteDatabase database = mManager.getJobStorage().getDatabase();
+        try {
+            long numEntries = DatabaseUtils.queryNumEntries(database, JobStorage.JOB_TABLE_NAME);
+            assertThat(numEntries).isEqualTo(0);
+        } finally {
+            database.close();
+        }
+    }
+
+    @Test
+    public void verifyJobDeletedFromDatabaseAll() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+        JobConfig.forceApi(JobApi.V_21);
+
+        Bundle bundle = new Bundle();
+        bundle.putString("key", "value");
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(40_000, 50_000)
+                .setTransientExtras(bundle)
+                .build()
+                .schedule();
+
+        assertThat(mManager.getAllJobRequests()).hasSize(1);
+        assertThat(mManager.getJobRequest(jobId)).isNotNull();
+
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).hasSize(1);
+
+        mJobManagerRule.getJobScheduler().cancel(jobId);
+
+        // cached request gone
+        assertThat(mManager.getAllJobRequests()).isEmpty();
+
+        SQLiteDatabase database = mManager.getJobStorage().getDatabase();
+        try {
+            long numEntries = DatabaseUtils.queryNumEntries(database, JobStorage.JOB_TABLE_NAME);
+            assertThat(numEntries).isEqualTo(0);
+        } finally {
+            database.close();
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/evernote/android/job/v21/TransientBundleCompatTest.java b/library/src/androidTest/java/com/evernote/android/job/v21/TransientBundleCompatTest.java
new file mode 100644
index 0000000..a36efdb
--- /dev/null
+++ b/library/src/androidTest/java/com/evernote/android/job/v21/TransientBundleCompatTest.java
@@ -0,0 +1,136 @@
+package com.evernote.android.job.v21;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.evernote.android.job.JobApi;
+import com.evernote.android.job.JobConfig;
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.PlatformJobManagerRule;
+import com.evernote.android.job.v14.PlatformAlarmServiceExact;
+
+import org.junit.FixMethodOrder;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * @author rwondratschek
+ */
+@SuppressWarnings("ConstantConditions")
+@RunWith(AndroidJUnit4.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class TransientBundleCompatTest {
+
+    @Rule
+    public PlatformJobManagerRule mJobManagerRule = new PlatformJobManagerRule();
+
+    @Test
+    public void verifyAlarmIsCanceled() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+        JobConfig.forceApi(JobApi.V_21);
+
+        int jobId = scheduleJob();
+
+        final Intent intent = PlatformAlarmServiceExact.createIntent(context(), jobId, null);
+        PendingIntent pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNotNull();
+
+        mJobManagerRule.getManager().cancel(jobId);
+
+        pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNull();
+    }
+
+    @Test
+    public void verifyAlarmIsCanceledAfterStart() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+        JobConfig.forceApi(JobApi.V_21);
+
+        int jobId = scheduleJob();
+
+        final Intent intent = PlatformAlarmServiceExact.createIntent(context(), jobId, null);
+        PendingIntent pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNotNull();
+
+        boolean started = TransientBundleCompat.startWithTransientBundle(context(), mJobManagerRule.getManager().getJobRequest(jobId));
+        assertThat(started).isTrue();
+
+        pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNull();
+    }
+
+    @Test
+    public void verifyAlarmNotCanceledForPeriodicAfterStart() throws Exception {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
+        JobConfig.forceApi(JobApi.V_21);
+
+        Bundle extras = new Bundle();
+        extras.putString("key", "value");
+
+        int jobId = new JobRequest.Builder("tag")
+                .setPeriodic(TimeUnit.DAYS.toMillis(1))
+                .setTransientExtras(extras)
+                .build()
+                .schedule();
+
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).isNotNull().isNotEmpty();
+
+        assertThat(mJobManagerRule.getManager().getJobRequest(jobId).isTransient()).isTrue();
+
+        final Intent intent = PlatformAlarmServiceExact.createIntent(context(), jobId, null);
+        PendingIntent pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNotNull();
+
+        boolean started = TransientBundleCompat.startWithTransientBundle(context(), mJobManagerRule.getManager().getJobRequest(jobId));
+        assertThat(started).isTrue();
+
+        pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNotNull();
+    }
+
+    @Test
+    public void verifyNativeImplementationIsUsedWithO() throws Exception {
+        // ignore test if not supported
+        assumeTrue(JobApi.V_26.isSupported(InstrumentationRegistry.getTargetContext()));
+        JobConfig.forceApi(JobApi.V_26);
+
+        int jobId = scheduleJob();
+
+        final Intent intent = PlatformAlarmServiceExact.createIntent(context(), jobId, null);
+        PendingIntent pendingIntent = PendingIntent.getService(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE);
+        assertThat(pendingIntent).isNull();
+    }
+
+    private Context context() {
+        return InstrumentationRegistry.getContext();
+    }
+
+    private int scheduleJob() {
+        Bundle extras = new Bundle();
+        extras.putString("key", "value");
+
+        int jobId = new JobRequest.Builder("tag")
+                .setExecutionWindow(10_000, 20_000)
+                .setTransientExtras(extras)
+                .build()
+                .schedule();
+
+        assertThat(mJobManagerRule.getAllPendingJobsFromScheduler()).isNotNull().isNotEmpty();
+
+        assertThat(mJobManagerRule.getManager().getJobRequest(jobId).isTransient()).isTrue();
+
+        return jobId;
+    }
+}
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 7bafeae..e9c2249 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -16,6 +16,11 @@
 
         <service
             android:name="com.evernote.android.job.v14.PlatformAlarmService"
+            android:exported="false"
+            android:permission="android.permission.BIND_JOB_SERVICE"/>
+
+        <service
+            android:name="com.evernote.android.job.v14.PlatformAlarmServiceExact"
             android:exported="false"/>
 
         <receiver
@@ -51,7 +56,8 @@
 
         <service
             android:name="com.evernote.android.job.JobRescheduleService"
-            android:exported="false"/>
+            android:exported="false"
+            android:permission="android.permission.BIND_JOB_SERVICE"/>
     </application>
 
 </manifest>
diff --git a/library/src/main/java/com/evernote/android/job/DailyJob.java b/library/src/main/java/com/evernote/android/job/DailyJob.java
new file mode 100644
index 0000000..58fcfc3
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/DailyJob.java
@@ -0,0 +1,187 @@
+package com.evernote.android.job;
+
+import android.os.PowerManager.WakeLock;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import android.support.annotation.WorkerThread;
+
+import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.support.PersistableBundleCompat;
+
+import net.vrallev.android.cat.CatLog;
+
+import java.util.Calendar;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Helper class for jobs which should run once a day. Your daily job needs to extend {@link DailyJob}
+ * and you need to use the {@link #schedule(JobRequest.Builder, long, long)} to schedule the job.
+ *
+ * @author rwondratschek
+ */
+@SuppressWarnings("unused")
+public abstract class DailyJob extends Job {
+
+    private static final CatLog CAT = new JobCat("DailyJob");
+
+    @VisibleForTesting
+    /*package*/ static final String EXTRA_START_MS = "EXTRA_START_MS";
+    @VisibleForTesting
+    /*package*/ static final String EXTRA_END_MS = "EXTRA_END_MS";
+
+    private static final long DAY = TimeUnit.DAYS.toMillis(1);
+
+    /**
+     * Schedules your daily job. A builder is required for this method call. Within the builder, you may specify
+     * additional requirements and/or extras for the job. However, a daily job may not be exact,
+     * periodic or transient. Since the rescheduling of a daily job when requirements aren't met
+     * (e.g. low internet connectivity) isn't useful, the enforcing of such requirements isn't supported either.
+     * <br>
+     * <br>
+     * Daily jobs should use a unique tag and their classes shouldn't be reused for other jobs.
+     * <br>
+     * <br>
+     * The start and end parameter must be less than one day. The end value may be smaller than the start value,
+     * allowing you to run the job in the evening or morning.
+     * <br>
+     * <br>
+     * Sample usage:
+     * <pre>
+     * // schedule between 1am and 6am
+     * DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(1), TimeUnit.HOURS.toMillis(6));
+     *
+     * // schedule between 8pm and 3am
+     * JobRequest.Builder builder = new JobRequest.Builder("MyTag").setRequiresCharging(true);
+     * DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(20), TimeUnit.HOURS.toMillis(3));
+     * </pre>
+     *
+     * @param baseBuilder The builder of your daily job.
+     * @param startMs The time of the day when the job is allowed to start in milliseconds.
+     * @param endMs The time of the day when the job is not allowed to start later in milliseconds.
+     * @return The unique ID for this job.
+     */
+    public static int schedule(@NonNull JobRequest.Builder baseBuilder, long startMs, long endMs) {
+        return schedule(baseBuilder, true, startMs, endMs);
+    }
+
+    private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob, long startMs, long endMs) {
+        if (startMs >= DAY || endMs >= DAY || startMs < 0 || endMs < 0) {
+            throw new IllegalArgumentException("startMs or endMs should be less than one day (in milliseconds)");
+        }
+
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(JobConfig.getClock().currentTimeMillis());
+
+        int hour = calendar.get(Calendar.HOUR_OF_DAY);
+        int minute = calendar.get(Calendar.MINUTE);
+        int second = calendar.get(Calendar.SECOND);
+
+        // current time + startDelay = 00:00
+        long startDelay = TimeUnit.SECONDS.toMillis(60 - second)
+                + TimeUnit.MINUTES.toMillis(60 - minute)
+                + TimeUnit.HOURS.toMillis((24 - hour) % 24)
+                - TimeUnit.HOURS.toMillis(1)  // subtract because we're adding minutes
+                - TimeUnit.MINUTES.toMillis(1)  // subtract because we're adding seconds
+                + TimeUnit.DAYS.toMillis(1); // add one day, otherwise result could be negative, e.g. if startMs is 0 and time is 00:08
+
+        startDelay = (startDelay + startMs) % TimeUnit.DAYS.toMillis(1);
+
+        if (startMs > endMs) {
+            // e.g. when job should run between 10pm and 2am
+            endMs += TimeUnit.DAYS.toMillis(1);
+        }
+        long endDelay = startDelay + (endMs - startMs);
+
+        PersistableBundleCompat extras = new PersistableBundleCompat();
+        extras.putLong(EXTRA_START_MS, startMs);
+        extras.putLong(EXTRA_END_MS, endMs);
+
+        builder.addExtras(extras);
+
+        JobRequest request = builder
+                .setExecutionWindow(Math.max(1L, startDelay), Math.max(1L, endDelay))
+                .setUpdateCurrent(newJob)
+                .build();
+
+        if (newJob && (request.isExact() || request.isPeriodic() || request.isTransient())) {
+            throw new IllegalArgumentException("Daily jobs cannot be exact, periodic or transient");
+        }
+        if (newJob && (request.requirementsEnforced())) {
+            throw new IllegalArgumentException("Daily jobs cannot enforce requirements");
+        }
+
+        return request.schedule();
+    }
+
+    @NonNull
+    @Override
+    protected final Result onRunJob(Params params) {
+        PersistableBundleCompat extras = params.getExtras();
+        if (!extras.containsKey(EXTRA_START_MS) || !extras.containsKey(EXTRA_END_MS)) {
+            CAT.e("Daily job doesn't contain start and end time");
+            return Result.FAILURE;
+        }
+
+        DailyJobResult result = null;
+
+        try {
+            result = onRunDailyJob(params);
+        } finally {
+            if (result == null) {
+                // shouldn't happen if the job follows the contract
+                result = DailyJobResult.SUCCESS;
+                CAT.e("Daily job result was null");
+            }
+
+            JobRequest request = params.getRequest();
+            if (result == DailyJobResult.SUCCESS) {
+                CAT.i("Rescheduling daily job %s", request);
+
+                // don't update current, it would cancel this currently running job
+                schedule(request.createBuilder(), false,
+                        extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY);
+
+            } else {
+                CAT.i("Cancel daily job %s", request);
+            }
+        }
+
+        return Result.SUCCESS;
+    }
+
+    /**
+     * This method is invoked from a background thread. You should run your desired task here.
+     * This method is thread safe. Each time a job starts, a new instance of your {@link Job}
+     * is instantiated and executed. You can identify your {@link Job} with the passed {@code params}.
+     *
+     * <br>
+     * <br>
+     *
+     * You should call {@link #isCanceled()} frequently for long running jobs and stop your
+     * task if necessary.
+     *
+     * <br>
+     * <br>
+     *
+     * A {@link WakeLock} is acquired for 3 minutes for each {@link Job}. If your task
+     * needs more time, then you need to create an extra {@link WakeLock}.
+     *
+     * @param params The parameters for this concrete job.
+     * @return The result of this {@link DailyJob}.
+     */
+    @SuppressWarnings("WeakerAccess")
+    @NonNull
+    @WorkerThread
+    protected abstract DailyJobResult onRunDailyJob(Params params);
+
+    public enum DailyJobResult {
+        /**
+         * Indicates that the job was successful and should run again the next day.
+         */
+        SUCCESS,
+        /**
+         * Indicates that the job is finished and should NOT run again.
+         */
+        CANCEL
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java b/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
similarity index 91%
rename from library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
rename to library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
index 7d22c73..d932320 100644
--- a/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java
+++ b/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java
@@ -1,4 +1,4 @@
-package com.evernote.android.job.util;
+package com.evernote.android.job;
 
 import android.content.ComponentName;
 import android.content.Context;
@@ -8,6 +8,7 @@
 
 import com.evernote.android.job.gcm.JobProxyGcm;
 import com.evernote.android.job.gcm.PlatformGcmService;
+import com.evernote.android.job.util.JobCat;
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GoogleApiAvailability;
 
@@ -54,7 +55,9 @@ public static boolean isGcmApiSupported(Context context) {
         } catch (Throwable t) {
             // seeing sometimes a DeadObjectException, return false, we can't do anything in this case
             // still sometimes seeing a NoClassDefFoundError here
-            CAT.w(t.getMessage());
+            if (BuildConfig.DEBUG) {
+                CAT.w(t.getMessage());
+            }
             return false;
         }
     }
@@ -122,11 +125,17 @@ private static void setServiceEnabled(Context context, boolean enabled) {
                         CAT.i("GCM service enabled");
                     }
                     break;
+                case PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED:
+                case PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER:
+                    // do nothing
+                    break;
             }
 
         } catch (Throwable t) {
             // just in case, don't let the app crash with each restart
-            CAT.e(t.getMessage());
+            if (BuildConfig.DEBUG) {
+                CAT.e(t.getMessage());
+            }
         }
     }
 
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 751d070..1a1d92b 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -26,13 +26,11 @@
 package com.evernote.android.job;
 
 import android.app.Service;
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.Intent;
+import android.os.Bundle;
 import android.os.PowerManager.WakeLock;
 import android.support.annotation.NonNull;
 import android.support.annotation.WorkerThread;
-import android.support.v4.content.WakefulBroadcastReceiver;
 
 import com.evernote.android.job.util.Device;
 import com.evernote.android.job.util.JobCat;
@@ -172,7 +170,7 @@ private boolean meetsRequirements() {
      * Otherwise always returns {@code true}.
      */
     protected boolean isRequirementChargingMet() {
-        return !(getParams().getRequest().requiresCharging() && !Device.isCharging(getContext()));
+        return !(getParams().getRequest().requiresCharging() && !Device.getBatteryStatus(getContext()).isCharging());
     }
 
     /**
@@ -183,6 +181,23 @@ protected boolean isRequirementDeviceIdleMet() {
         return !(getParams().getRequest().requiresDeviceIdle() && !Device.isIdle(getContext()));
     }
 
+    /**
+     * @return Whether the battery not low requirement is met. That's true either if it's not a requirement
+     * or if the battery actually isn't low. The battery is low, if less than 15% are left and the device isn't
+     * charging.
+     */
+    protected boolean isRequirementBatteryNotLowMet() {
+        return !(getParams().getRequest().requiresBatteryNotLow() && Device.getBatteryStatus(getContext()).isBatteryLow());
+    }
+
+    /**
+     * @return Whether the storage not low requirement is met. That's true either if it's not a requirement
+     * or if the storage actually isn't low.
+     */
+    protected boolean isRequirementStorageNotLowMet() {
+        return !(getParams().getRequest().requiresStorageNotLow() && Device.isStorageLow());
+    }
+
     /**
      * @return {@code false} if the {@link Job} requires the device to be in a specific network state and it
      * isn't in this state. Otherwise always returns {@code true}.
@@ -199,16 +214,19 @@ protected boolean isRequirementNetworkTypeMet() {
             case CONNECTED:
                 return current != JobRequest.NetworkType.ANY;
             case NOT_ROAMING:
-                return current == JobRequest.NetworkType.NOT_ROAMING || current == JobRequest.NetworkType.UNMETERED;
+                return current == JobRequest.NetworkType.NOT_ROAMING || current == JobRequest.NetworkType.UNMETERED || current == JobRequest.NetworkType.METERED;
             case UNMETERED:
                 return current == JobRequest.NetworkType.UNMETERED;
+            case METERED:
+                return current == JobRequest.NetworkType.CONNECTED || current == JobRequest.NetworkType.NOT_ROAMING;
             default:
                 throw new IllegalStateException("not implemented");
         }
     }
 
-    /*package*/ final Job setRequest(JobRequest request) {
-        mParams = new Params(request);
+    @SuppressWarnings("UnusedReturnValue")
+    /*package*/ final Job setRequest(JobRequest request, @NonNull Bundle transientExtras) {
+        mParams = new Params(request, transientExtras);
         return this;
     }
 
@@ -277,55 +295,6 @@ public final boolean isFinished() {
         return mDeleted;
     }
 
-    /**
-     * Similar call like {@link WakefulBroadcastReceiver#startWakefulService(Context, Intent)}.
-     * Compared to the original implementation it avoids crashes on some devices. Don't forget
-     * to call {@link #completeWakefulIntent(Intent)} on the Job class.
-     *
-     * <br>
-     * <br>
-     *
-     * Do a {@link android.content.Context#startService(android.content.Intent)
-     * Context.startService}, but holding a wake lock while the service starts.
-     * This will modify the Intent to hold an extra identifying the wake lock;
-     * when the service receives it in {@link android.app.Service#onStartCommand
-     * Service.onStartCommand}, it should pass back the Intent it receives there to
-     * {@link #completeWakefulIntent(android.content.Intent)} in order to release
-     * the wake lock.
-     *
-     * @param intent The Intent with which to start the service, as per
-     * {@link android.content.Context#startService(android.content.Intent)
-     * Context.startService}.
-     * @see WakefulBroadcastReceiver
-     */
-    protected ComponentName startWakefulService(@NonNull Intent intent) {
-        return WakeLockUtil.startWakefulService(getContext(), intent);
-    }
-
-    /**
-     * Similar call like {@link WakefulBroadcastReceiver#completeWakefulIntent(Intent)}.
-     * Compared to the original implementation it avoids crashes on some devices.
-     *
-     * <br>
-     * <br>
-     *
-     * Finish the execution from a previous {@link #startWakefulService}.  Any wake lock
-     * that was being held will now be released.
-     *
-     * @param intent The Intent as originally generated by {@link #startWakefulService}.
-     * @return Returns true if the intent is associated with a wake lock that is
-     * now released; returns false if there was no wake lock specified for it.
-     * @see WakefulBroadcastReceiver
-     */
-    public static boolean completeWakefulIntent(@NonNull Intent intent) {
-        try {
-            return WakeLockUtil.completeWakefulIntent(intent);
-        } catch (Exception e) {
-            // could end in a NPE if the intent no wake lock was found
-            return true;
-        }
-    }
-
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
@@ -361,9 +330,11 @@ public String toString() {
 
         private final JobRequest mRequest;
         private PersistableBundleCompat mExtras;
+        private Bundle mTransientExtras;
 
-        private Params(@NonNull JobRequest request) {
+        private Params(@NonNull JobRequest request, @NonNull Bundle transientExtras) {
             mRequest = request;
+            mTransientExtras = transientExtras;
         }
 
         /**
@@ -399,14 +370,6 @@ public boolean isExact() {
             return mRequest.isExact();
         }
 
-        /**
-         * @return If {@code true}, then the job persists across reboots.
-         * @see JobRequest#isPersisted()
-         */
-        public boolean isPersisted() {
-            return mRequest.isPersisted();
-        }
-
         /**
          * Only valid if the job isn't periodic.
          *
@@ -515,6 +478,20 @@ public boolean requiresDeviceIdle() {
             return mRequest.requiredNetworkType();
         }
 
+        /**
+         * @return If {@code true}, then the job should only run if the battery isn't low.
+         */
+        public boolean requiresBatteryNotLow() {
+            return mRequest.requiresBatteryNotLow();
+        }
+
+        /**
+         * @return If {@code true}, then the job should only run if the battery isn't low.
+         */
+        public boolean requiresStorageNotLow() {
+            return mRequest.requiresStorageNotLow();
+        }
+
         /**
          * @return If {@code true}, then all requirements are checked before the job runs. If one requirement
          * isn't met, then the job is rescheduled right away.
@@ -544,6 +521,35 @@ public long getLastRun() {
             return mRequest.getLastRun();
         }
 
+        /**
+         * Returns whether this is a transient jobs. <b>WARNING:</b> It's not guaranteed that a transient job
+         * will run at all, e.g. rebooting the device or force closing the app will cancel the
+         * job.
+         *
+         * @return If this is a transient job.
+         */
+        public boolean isTransient() {
+            return mRequest.isTransient();
+        }
+
+        /**
+         * Returns the transient extras you passed in when constructing this job with
+         * {@link JobRequest.Builder#setTransientExtras(Bundle)}. <b>WARNING:</b> It's not guaranteed that a transient job
+         * will run at all, e.g. rebooting the device or force closing the app will cancel the
+         * job.
+         *
+         * <br>
+         * <br>
+         *
+         * This will never be {@code null}. If you did not set any extras this will be an empty bundle.
+         *
+         * @return The transient extras you passed in when constructing this job.
+         */
+        @NonNull
+        public Bundle getTransientExtras() {
+            return mTransientExtras;
+        }
+
         /**
          * @return Extra arguments for this {@link Job}. Never returns {@code null}.
          */
diff --git a/library/src/main/java/com/evernote/android/job/util/JobApi.java b/library/src/main/java/com/evernote/android/job/JobApi.java
similarity index 73%
rename from library/src/main/java/com/evernote/android/job/util/JobApi.java
rename to library/src/main/java/com/evernote/android/job/JobApi.java
index 56cacd0..7eb6757 100644
--- a/library/src/main/java/com/evernote/android/job/util/JobApi.java
+++ b/library/src/main/java/com/evernote/android/job/JobApi.java
@@ -23,7 +23,7 @@
  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package com.evernote.android.job.util;
+package com.evernote.android.job;
 
 import android.app.AlarmManager;
 import android.app.Service;
@@ -35,17 +35,16 @@
 import android.os.Build;
 import android.support.annotation.NonNull;
 
-import com.evernote.android.job.JobManager;
-import com.evernote.android.job.JobManagerCreateException;
-import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.gcm.JobProxyGcm;
 import com.evernote.android.job.v14.JobProxy14;
 import com.evernote.android.job.v14.PlatformAlarmReceiver;
 import com.evernote.android.job.v14.PlatformAlarmService;
+import com.evernote.android.job.v14.PlatformAlarmServiceExact;
 import com.evernote.android.job.v19.JobProxy19;
 import com.evernote.android.job.v21.JobProxy21;
 import com.evernote.android.job.v21.PlatformJobService;
 import com.evernote.android.job.v24.JobProxy24;
+import com.evernote.android.job.v26.JobProxy26;
 import com.google.android.gms.gcm.GcmNetworkManager;
 
 import java.util.List;
@@ -59,79 +58,58 @@
     /**
      * Uses the {@link JobScheduler} for scheduling jobs.
      */
-    V_24(true, false),
+    V_26(true, false, true),
     /**
      * Uses the {@link JobScheduler} for scheduling jobs.
      */
-    V_21(true, true),
+    V_24(true, false, false),
+    /**
+     * Uses the {@link JobScheduler} for scheduling jobs.
+     */
+    V_21(true, true, false),
     /**
      * Uses the {@link AlarmManager} for scheduling jobs.
      */
-    V_19(true, true),
+    V_19(true, true, true),
     /**
      * Uses the {@link AlarmManager} for scheduling jobs.
      */
-    V_14(false, true),
+    V_14(false, true, true),
     /**
      * Uses the {@link GcmNetworkManager} for scheduling jobs.
      */
-    GCM(true, false);
+    GCM(true, false, true);
 
     private static final String JOB_SCHEDULER_PERMISSION = "android.permission.BIND_JOB_SERVICE";
 
-    private static volatile boolean forceAllowApi14 = false;
-
-    /**
-     * On some devices for some reason all broadcast receiver and services are disabled. This library
-     * cannot work properly in this case. This switch allows to use the AlarmManager as fallback even
-     * in such a weird state.
-     *
-     * <br>
-     * <br>
-     *
-     * If the value is {@code true}, then this suppresses the {@link JobManagerCreateException} during
-     * the creation of the job manager.
-     *
-     * @param forceAllowApi14 Whether API 14 should be used as fallback in all scenarios. The default value
-     *                   is {@code false}.
-     * @deprecated In version 1.2.0 this method will be moved to the Config class.
-     */
-    @SuppressWarnings("DeprecatedIsStillUsed")
-    @Deprecated
-    public static void setForceAllowApi14(boolean forceAllowApi14) {
-        JobApi.forceAllowApi14 = forceAllowApi14;
-    }
-
-    /**
-     * @return Whether API 14 should be used as fallback in all scenarios. The default value is {@code false}.
-     *
-     * @deprecated In version 1.2.0 this method will be moved to the Config class.
-     */
-    @Deprecated
-    public static boolean isForceAllowApi14() {
-        return forceAllowApi14;
-    }
-
     private volatile JobProxy mCachedProxy;
 
     private final boolean mSupportsExecutionWindow;
     private final boolean mFlexSupport;
+    private final boolean mSupportsTransientJobs;
 
-    JobApi(boolean supportsExecutionWindow, boolean flexSupport) {
+    JobApi(boolean supportsExecutionWindow, boolean flexSupport, boolean supportsTransientJobs) {
         mSupportsExecutionWindow = supportsExecutionWindow;
         mFlexSupport = flexSupport;
+        mSupportsTransientJobs = supportsTransientJobs;
     }
 
-    public boolean supportsExecutionWindow() {
+    /*package*/ boolean supportsExecutionWindow() {
         return mSupportsExecutionWindow;
     }
 
-    public boolean isFlexSupport() {
+    /*package*/ boolean isFlexSupport() {
         return mFlexSupport;
     }
 
+    /*package*/ boolean supportsTransientJobs() {
+        return mSupportsTransientJobs;
+    }
+
     public boolean isSupported(Context context) {
         switch (this) {
+            case V_26:
+                return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isServiceEnabled(context, PlatformJobService.class);
             case V_24:
                 return Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && isServiceEnabledAndHasPermission(context, PlatformJobService.class, JOB_SCHEDULER_PERMISSION);
             case V_21:
@@ -140,8 +118,9 @@ public boolean isSupported(Context context) {
                 return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && isServiceEnabled(context, PlatformAlarmService.class)
                         && isBroadcastEnabled(context, PlatformAlarmReceiver.class);
             case V_14:
-                return forceAllowApi14
-                        || (isServiceEnabled(context, PlatformAlarmService.class) && isBroadcastEnabled(context, PlatformAlarmReceiver.class));
+                return JobConfig.isForceAllowApi14()
+                        || (isServiceEnabled(context, PlatformAlarmService.class) && isServiceEnabled(context, PlatformAlarmServiceExact.class)
+                        && isBroadcastEnabled(context, PlatformAlarmReceiver.class));
             case GCM:
                 return GcmAvailableHelper.isGcmApiSupported(context);
             default:
@@ -150,8 +129,10 @@ public boolean isSupported(Context context) {
     }
 
     @NonNull
-    public JobProxy createProxy(Context context) {
+    private JobProxy createProxy(Context context) {
         switch (this) {
+            case V_26:
+                return new JobProxy26(context);
             case V_24:
                 return new JobProxy24(context);
             case V_21:
@@ -168,7 +149,7 @@ public JobProxy createProxy(Context context) {
     }
 
     @NonNull
-    public synchronized JobProxy getCachedProxy(Context context) {
+    /*package*/ synchronized JobProxy getProxy(Context context) {
         if (mCachedProxy == null) {
             mCachedProxy = createProxy(context);
         }
@@ -221,28 +202,22 @@ private boolean isBroadcastEnabled(@NonNull Context context, @NonNull Class<? ex
         }
     }
 
-    /**
-     * @deprecated Use {@link #getDefault(Context, boolean)} instead.
-     */
-    @SuppressWarnings("unused")
     @NonNull
-    @Deprecated
     public static JobApi getDefault(Context context) {
-        return getDefault(context, JobManager.instance().getConfig().isGcmApiEnabled());
-    }
-
-    @NonNull
-    public static JobApi getDefault(Context context, boolean gcmEnabled) {
-        if (V_24.isSupported(context)) {
+        if (V_26.isSupported(context) && JobConfig.isApiEnabled(V_26)) {
+            return V_26;
+        } else if (V_24.isSupported(context) && JobConfig.isApiEnabled(V_24)) {
             return V_24;
-        } else if (V_21.isSupported(context)) {
+        } else if (V_21.isSupported(context) && JobConfig.isApiEnabled(V_21)) {
             return V_21;
-        } else if (gcmEnabled && GCM.isSupported(context)) {
+        } else if (GCM.isSupported(context) && JobConfig.isApiEnabled(GCM)) {
             return GCM;
-        } else if (V_19.isSupported(context)) {
+        } else if (V_19.isSupported(context) && JobConfig.isApiEnabled(V_19)) {
             return V_19;
-        } else {
+        } else if (JobConfig.isApiEnabled(V_14)) {
             return V_14;
+        } else {
+            throw new IllegalStateException("All supported APIs are disabled");
         }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobBootReceiver.java b/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
index da9b830..42a9857 100644
--- a/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
+++ b/library/src/main/java/com/evernote/android/job/JobBootReceiver.java
@@ -29,8 +29,6 @@
 import android.content.Context;
 import android.content.Intent;
 
-import com.evernote.android.job.util.JobApi;
-
 /**
  * A {@code BroadcastReceiver} rescheduling jobs after a reboot, if the underlying {@link JobApi} can't
  * handle it.
diff --git a/library/src/main/java/com/evernote/android/job/JobConfig.java b/library/src/main/java/com/evernote/android/job/JobConfig.java
new file mode 100644
index 0000000..2b4ea8b
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/JobConfig.java
@@ -0,0 +1,296 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job;
+
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+
+import com.evernote.android.job.util.Clock;
+import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.JobLogger;
+import com.evernote.android.job.util.JobPreconditions;
+
+import java.util.EnumMap;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A global configuration for the job library.
+ * <br>
+ * <br>
+ * See {@link JobCat} for settings to enable/disable logging.
+ *
+ * @author rwondratschek
+ */
+@SuppressWarnings({"WeakerAccess", "unused", "SameParameterValue"})
+public final class JobConfig {
+
+    private JobConfig() {
+        throw new UnsupportedOperationException();
+    }
+
+    private static final long DEFAULT_JOB_RESCHEDULE_PAUSE = 3_000L;
+
+    private static final EnumMap<JobApi, Boolean> ENABLED_APIS;
+    private static final JobCat CAT = new JobCat("JobConfig");
+
+    private static volatile boolean allowSmallerIntervals;
+    private static volatile boolean forceAllowApi14 = false;
+
+    private static volatile long jobReschedulePause = DEFAULT_JOB_RESCHEDULE_PAUSE;
+    private static volatile boolean skipJobReschedule = false;
+
+    private static volatile int jobIdOffset = 0;
+
+    private static volatile boolean forceRtc = false;
+
+    private static volatile Clock clock = Clock.DEFAULT;
+
+    static {
+        ENABLED_APIS = new EnumMap<>(JobApi.class);
+        for (JobApi api : JobApi.values()) {
+            ENABLED_APIS.put(api, Boolean.TRUE);
+        }
+    }
+
+    /**
+     * @return Whether the given API is enabled. By default all APIs are enabled, although the current
+     * device may not support it.
+     */
+    public static boolean isApiEnabled(@NonNull JobApi api) {
+        return ENABLED_APIS.get(api);
+    }
+
+    /**
+     * <b>WARNING:</b> Please use this method carefully. It's only meant to be used for testing purposes
+     * and could break how the library works.
+     * <br>
+     * <br>
+     * Programmatic switch to enable or disable the given API. This only has an impact for new scheduled jobs.
+     *
+     * @param api The API which should be enabled or disabled.
+     * @param enabled Whether the API should be enabled or disabled.
+     */
+    public static void setApiEnabled(@NonNull JobApi api, boolean enabled) {
+        ENABLED_APIS.put(api, enabled);
+        CAT.w("setApiEnabled - %s, %b", api, enabled);
+    }
+
+    /**
+     * <b>WARNING:</b> You shouldn't call this method. It only exists for testing and debugging
+     * purposes. The {@link JobManager} automatically decides which API suits best for a {@link Job}.
+     *
+     * @param api The {@link JobApi} which will be used for future scheduled JobRequests.
+     */
+    public static void forceApi(@NonNull JobApi api) {
+        for (JobApi jobApi : JobApi.values()) {
+            ENABLED_APIS.put(jobApi, jobApi == api);
+        }
+        CAT.w("forceApi - %s", api);
+    }
+
+    /**
+     * Checks whether a smaller interval and flex are allowed for periodic jobs. That's helpful
+     * for testing purposes.
+     *
+     * @return Whether a smaller interval and flex than the minimum values are allowed for periodic jobs
+     * are allowed. The default value is {@code false}.
+     */
+    public static boolean isAllowSmallerIntervalsForMarshmallow() {
+        return allowSmallerIntervals && Build.VERSION.SDK_INT < Build.VERSION_CODES.N;
+    }
+
+    /**
+     * Option to override the minimum period and minimum flex for periodic jobs. This is useful for testing
+     * purposes. This method only works for Android M and earlier. Later versions throw an exception.
+     *
+     * @param allowSmallerIntervals Whether a smaller interval and flex than the minimum values are allowed
+     *                              for periodic jobs are allowed. The default value is {@code false}.
+     */
+    public static void setAllowSmallerIntervalsForMarshmallow(boolean allowSmallerIntervals) {
+        if (allowSmallerIntervals && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            throw new IllegalStateException("This method is only allowed to call on Android M or earlier");
+        }
+        JobConfig.allowSmallerIntervals = allowSmallerIntervals;
+    }
+
+    /**
+     * On some devices for some reason all broadcast receiver and services are disabled. This library
+     * cannot work properly in this case. This switch allows to use the AlarmManager as fallback even
+     * in such a weird state.
+     *
+     * <br>
+     * <br>
+     *
+     * If the value is {@code true}, then this suppresses the {@link JobManagerCreateException} during
+     * the creation of the job manager.
+     *
+     * @param forceAllowApi14 Whether API 14 should be used as fallback in all scenarios. The default
+     *                        value is {@code false}.
+     */
+    public static void setForceAllowApi14(boolean forceAllowApi14) {
+        JobConfig.forceAllowApi14 = forceAllowApi14;
+    }
+
+    /**
+     * @return Whether API 14 should be used as fallback in all scenarios. The default value is {@code false}.
+     */
+    public static boolean isForceAllowApi14() {
+        return forceAllowApi14;
+    }
+
+    /**
+     * Add a global logger for the job library, which will be notified about each log statement.
+     *
+     * @param logger Your desired logger.
+     * @return {@code true} if the logger was added. Returns {@code false} if the logger was
+     * already added.
+     */
+    public static synchronized boolean addLogger(@NonNull JobLogger logger) {
+        return JobCat.addLogger(logger);
+    }
+
+    /**
+     * Remove a global logger.
+     *
+     * @param logger Your desired logger.
+     * @see #addLogger(JobLogger)
+     */
+    public static synchronized void removeLogger(@NonNull JobLogger logger) {
+        JobCat.removeLogger(logger);
+    }
+
+    /**
+     * Global switch to enable or disable printing log messages to Logcat.
+     *
+     * @param enabled Whether or not to print all log messages. The default value is {@code true}.
+     */
+    public static void setLogcatEnabled(boolean enabled) {
+        JobCat.setLogcatEnabled(enabled);
+    }
+
+    /**
+     * @return Whether logging is enabled for this library. The default value is {@code true}.
+     */
+    public static boolean isLogcatEnabled() {
+        return JobCat.isLogcatEnabled();
+    }
+
+    /**
+     * @return The pause of job reschedule service in milliseconds.
+     */
+    public static long getJobReschedulePause() {
+        return jobReschedulePause;
+    }
+
+    /**
+     * Overrides the default job reschedule pause. The default value is 3 seconds.
+     *
+     * @param pause The new pause.
+     * @param timeUnit The time unit of the pause argument.
+     */
+    public static void setJobReschedulePause(long pause, @NonNull TimeUnit timeUnit) {
+        jobReschedulePause = timeUnit.toMillis(pause);
+    }
+
+    /*package*/ static boolean isSkipJobReschedule() {
+        return skipJobReschedule;
+    }
+
+    /*package*/ static void setSkipJobReschedule(boolean skipJobReschedule) {
+        JobConfig.skipJobReschedule = skipJobReschedule;
+    }
+
+    /**
+     * @return The offset for the very first job ID. The default value is 0 and very first job ID will be 1.
+     */
+    public static int getJobIdOffset() {
+        return jobIdOffset;
+    }
+
+    /**
+     * Adds an offset to the job IDs. Job IDs are generated and usually start with 1. This offset shifts the
+     * very first job ID.
+     *
+     * @param jobIdOffset The offset for the very first job ID.
+     */
+    public static void setJobIdOffset(int jobIdOffset) {
+        JobPreconditions.checkArgumentNonnegative(jobIdOffset, "offset can't be negative");
+        if (jobIdOffset > JobIdsInternal.RESERVED_JOB_ID_RANGE_START - 500) {
+            throw new IllegalArgumentException("offset is too close to Integer.MAX_VALUE");
+        }
+
+        JobConfig.jobIdOffset = jobIdOffset;
+    }
+
+    /**
+     * @return Whether the alarm time should use System.currentTimeMillis() (wall clock time in UTC). The
+     *                 default value is {@code false} and will use the alarm time in SystemClock.elapsedRealtime()
+     *                 (time since boot, including sleep).
+     */
+    public static boolean isForceRtc() {
+        return forceRtc;
+    }
+
+    /**
+     * @param forceRtc Force using the alarm time in System.currentTimeMillis() (wall clock time in UTC). The
+     *                 default value is {@code false} and will use the alarm time in SystemClock.elapsedRealtime()
+     *                 (time since boot, including sleep).
+     */
+    public static void setForceRtc(boolean forceRtc) {
+        JobConfig.forceRtc = forceRtc;
+    }
+
+    /**
+     * @return A helper providing the system time
+     */
+    public static Clock getClock() {
+        return clock;
+    }
+
+    @VisibleForTesting
+    /*package*/ static void setClock(Clock clock) {
+        JobConfig.clock = clock;
+    }
+
+    /**
+     * Resets all adjustments in the config.
+     */
+    public static void reset() {
+        for (JobApi api : JobApi.values()) {
+            ENABLED_APIS.put(api, Boolean.TRUE);
+        }
+        allowSmallerIntervals = false;
+        forceAllowApi14 = false;
+        jobReschedulePause = DEFAULT_JOB_RESCHEDULE_PAUSE;
+        skipJobReschedule = false;
+        jobIdOffset = 0;
+        forceRtc = false;
+        clock = Clock.DEFAULT;
+        JobCat.setLogcatEnabled(true);
+        JobCat.clearLogger();
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/JobCreator.java b/library/src/main/java/com/evernote/android/job/JobCreator.java
index a201738..645bdcc 100644
--- a/library/src/main/java/com/evernote/android/job/JobCreator.java
+++ b/library/src/main/java/com/evernote/android/job/JobCreator.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 /**
  * A {@code JobCreator} maps a tag to a specific {@link Job} class. You need to pass the tag in the
@@ -31,7 +32,8 @@
      * and isn't rescheduled.
      * @see JobRequest.Builder#Builder(String)
      */
-    Job create(String tag);
+    @Nullable
+    Job create(@NonNull String tag);
 
     /**
      * Action to notify receives that the application was instantiated and {@link JobCreator}s should be added.
diff --git a/library/src/main/java/com/evernote/android/job/JobExecutor.java b/library/src/main/java/com/evernote/android/job/JobExecutor.java
index f9cea1d..ec4c735 100644
--- a/library/src/main/java/com/evernote/android/job/JobExecutor.java
+++ b/library/src/main/java/com/evernote/android/job/JobExecutor.java
@@ -26,6 +26,7 @@
 package com.evernote.android.job;
 
 import android.content.Context;
+import android.os.Bundle;
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -69,9 +70,8 @@ public JobExecutor() {
         mStartingRequests = new HashSet<>();
     }
 
-    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @Nullable Job job) {
+    public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @Nullable Job job, @NonNull Bundle transientExtras) {
         mStartingRequests.remove(request);
-
         if (job == null) {
             CAT.w("JobCreator returned null for tag %s", request.getTag());
             return null;
@@ -80,7 +80,7 @@ public JobExecutor() {
             throw new IllegalStateException(String.format(Locale.ENGLISH, "Job for tag %s was already run, a creator should always create a new Job instance", request.getTag()));
         }
 
-        job.setContext(context).setRequest(request);
+        job.setContext(context).setRequest(request, transientExtras);
 
         CAT.i("Executing %s, context %s", request, context.getClass().getSimpleName());
 
@@ -180,7 +180,7 @@ private void handleResult(Job job, Job.Result result) {
             boolean incFailureCount = false;
             boolean updateLastRun = false;
 
-            if (!request.isPeriodic() && Job.Result.RESCHEDULE.equals(result)) {
+            if (!request.isPeriodic() && Job.Result.RESCHEDULE.equals(result) && !job.isDeleted()) {
                 request = request.reschedule(true, true);
                 mJob.onReschedule(request.getJobId());
                 updateLastRun = true;
diff --git a/library/src/main/java/com/evernote/android/job/JobIdsInternal.java b/library/src/main/java/com/evernote/android/job/JobIdsInternal.java
new file mode 100644
index 0000000..d63be1e
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/JobIdsInternal.java
@@ -0,0 +1,25 @@
+package com.evernote.android.job;
+
+/**
+ * Constants for jobIds reserved for internal jobs.
+ *
+ * There are some internal jobs needing fixed platform jobIds, which should not conflict with those chosen dynamically
+ * for jobs scheduled with the {@link JobManager}.
+ */
+public final class JobIdsInternal {
+
+    /**
+     * JobIds between this and Integer.MAX_VALUE are reserved for internal purposes.
+     */
+    // close to Integer.MAX_VALUE
+    public static final int RESERVED_JOB_ID_RANGE_START = 2147480000;
+
+    // fixed and unique jobIds for internal jobs
+    public static final int JOB_ID_JOB_RESCHEDULE_SERVICE = 2147480000;
+    public static final int JOB_ID_PLATFORM_ALARM_SERVICE = 2147480001;
+
+    private JobIdsInternal() {
+        // do not instantiate; holder for constants
+    }
+
+}
diff --git a/library/src/main/java/com/evernote/android/job/JobManager.java b/library/src/main/java/com/evernote/android/job/JobManager.java
index 53662f5..73f54b5 100644
--- a/library/src/main/java/com/evernote/android/job/JobManager.java
+++ b/library/src/main/java/com/evernote/android/job/JobManager.java
@@ -33,12 +33,10 @@
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ResolveInfo;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
-import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobPreconditions;
 import com.evernote.android.job.util.JobUtil;
@@ -47,6 +45,7 @@
 import net.vrallev.android.cat.CatLog;
 
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
@@ -105,6 +104,11 @@ public static JobManager create(@NonNull Context context) throws JobManagerCreat
                         context = context.getApplicationContext();
                     }
 
+                    JobApi api = JobApi.getDefault(context);
+                    if (api == JobApi.V_14 && !api.isSupported(context)) {
+                        throw new JobManagerCreateException("All APIs are disabled, cannot schedule any job");
+                    }
+
                     instance = new JobManager(context);
 
                     if (!JobUtil.hasWakeLockPermission(context)) {
@@ -122,31 +126,6 @@ public static JobManager create(@NonNull Context context) throws JobManagerCreat
         return instance;
     }
 
-    /**
-     * Initializes the singleton. It's necessary to call this function before using the {@code JobManager}.
-     * Calling it multiple times has not effect.
-     *
-     * @param context    Any {@link Context} to instantiate the singleton object.
-     * @param jobCreator The mapping between a specific job tag and the job class.
-     * @return The new or existing singleton object.
-     * @deprecated Use {@link #create(Context)} instead and call {@link #addJobCreator(JobCreator)} after that.
-     */
-    @Deprecated
-    public static JobManager create(Context context, JobCreator jobCreator) {
-        boolean addJobCreator;
-        synchronized (JobManager.class) {
-            addJobCreator = instance == null;
-        }
-
-        create(context);
-
-        if (addJobCreator) {
-            instance.addJobCreator(jobCreator);
-        }
-
-        return instance;
-    }
-
     /**
      * Ensure that you've called {@link #create(Context)} first. Otherwise this method
      * throws an exception.
@@ -169,36 +148,16 @@ public static JobManager instance() {
     private final JobCreatorHolder mJobCreatorHolder;
     private final JobStorage mJobStorage;
     private final JobExecutor mJobExecutor;
-    private final Config mConfig;
-
-    private JobApi mApi;
 
     private JobManager(Context context) {
         mContext = context;
         mJobCreatorHolder = new JobCreatorHolder();
         mJobStorage = new JobStorage(context);
         mJobExecutor = new JobExecutor();
-        mConfig = new Config();
 
-        JobApi api = JobApi.getDefault(mContext, mConfig.isGcmApiEnabled());
-        if (api == JobApi.V_14 && !api.isSupported(mContext)) {
-            throw new JobManagerCreateException("All APIs are disabled, cannot schedule any job");
+        if (!JobConfig.isSkipJobReschedule()) {
+            JobRescheduleService.startService(mContext);
         }
-
-        setJobProxy(api);
-
-        JobRescheduleService.startService(mContext);
-    }
-
-    /**
-     * @return The current configuration for the job manager.
-     */
-    public Config getConfig() {
-        return mConfig;
-    }
-
-    private void setJobProxy(JobApi api) {
-        mApi = api;
     }
 
     /**
@@ -228,12 +187,7 @@ public void schedule(@NonNull JobRequest request) {
         boolean periodic = request.isPeriodic();
         boolean flexSupport = periodic && jobApi.isFlexSupport() && request.getFlexMs() < request.getIntervalMs();
 
-        if (jobApi == JobApi.GCM && !mConfig.isGcmApiEnabled()) {
-            // shouldn't happen
-            CAT.w("GCM API disabled, but used nonetheless");
-        }
-
-        request.setScheduledAt(System.currentTimeMillis());
+        request.setScheduledAt(JobConfig.getClock().currentTimeMillis());
         request.setFlexSupport(flexSupport);
         mJobStorage.put(request);
 
@@ -292,12 +246,18 @@ private void scheduleWithApi(JobRequest request, JobApi jobApi, boolean periodic
      * @return The {@link JobRequest} if it's pending or {@code null} otherwise.
      */
     public JobRequest getJobRequest(int jobId) {
-        return getJobRequest(jobId, false);
+        JobRequest request = getJobRequest(jobId, false);
+        if (request != null && request.isTransient() && !request.getJobApi().getProxy(mContext).isPlatformJobScheduled(request)) {
+            getJobStorage().remove(request);
+            return null;
+        } else {
+            return request;
+        }
     }
 
-    /*package*/ JobRequest getJobRequest(int jobId, boolean includeTransient) {
+    /*package*/ JobRequest getJobRequest(int jobId, boolean includeStarted) {
         JobRequest jobRequest = mJobStorage.get(jobId);
-        if (!includeTransient && jobRequest != null && jobRequest.isTransient()) {
+        if (!includeStarted && jobRequest != null && jobRequest.isStarted()) {
             return null;
         } else {
             return jobRequest;
@@ -312,7 +272,7 @@ public JobRequest getJobRequest(int jobId) {
      */
     @NonNull
     public Set<JobRequest> getAllJobRequests() {
-        return mJobStorage.getAllJobRequests(null, false);
+        return getAllJobRequests(null, false, true);
     }
 
     /**
@@ -322,7 +282,24 @@ public JobRequest getJobRequest(int jobId) {
      * direct effects to the actual backing store.
      */
     public Set<JobRequest> getAllJobRequestsForTag(@NonNull String tag) {
-        return mJobStorage.getAllJobRequests(tag, false);
+        return getAllJobRequests(tag, false, true);
+    }
+
+    /*package*/ Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeStarted, boolean cleanUpTransient) {
+        Set<JobRequest> requests = mJobStorage.getAllJobRequests(tag, includeStarted);
+
+        if (cleanUpTransient) {
+            Iterator<JobRequest> iterator = requests.iterator();
+            while (iterator.hasNext()) {
+                JobRequest request = iterator.next();
+                if (request.isTransient() && !request.getJobApi().getProxy(mContext).isPlatformJobScheduled(request)) {
+                    mJobStorage.remove(request);
+                    iterator.remove();
+                }
+            }
+        }
+
+        return requests;
     }
 
     /**
@@ -364,27 +341,6 @@ public Job getJob(int jobId) {
         return mJobExecutor.getAllJobsForTag(tag);
     }
 
-    /**
-     * <b>WARNING:</b> You shouldn't call this method. It only exists for testing and debugging
-     * purposes. The {@link JobManager} automatically decides which API suits best for a {@link Job}.
-     *
-     * @param api The {@link JobApi} which will be used for future scheduled JobRequests.
-     */
-    public void forceApi(@NonNull JobApi api) {
-        setJobProxy(JobPreconditions.checkNotNull(api));
-        CAT.w("Changed API to %s", api);
-    }
-
-    /**
-     * <b>WARNING:</b> Don't rely your logic on a specific {@link JobApi}. You shouldn't be worrying
-     * about it.
-     *
-     * @return The current {@link JobApi} which will be used for future schedules JobRequests.
-     */
-    public JobApi getApi() {
-        return mApi;
-    }
-
     /**
      * Cancel either the pending {@link JobRequest} or the running {@link Job}.
      *
@@ -442,7 +398,7 @@ private boolean cancelInner(@Nullable Job job) {
     private synchronized int cancelAllInner(@Nullable String tag) {
         int canceled = 0;
 
-        Set<JobRequest> requests = mJobStorage.getAllJobRequests(tag, true);
+        Set<JobRequest> requests = getAllJobRequests(tag, true, false);
         for (JobRequest request : requests) {
             if (cancelInner(request)) {
                 canceled++;
@@ -459,17 +415,6 @@ private synchronized int cancelAllInner(@Nullable String tag) {
         return canceled;
     }
 
-    /**
-     * Global switch to enable or disable logging.
-     *
-     * @param verbose Whether or not to print log messages.
-     * @deprecated Use {@link Config#setVerbose(boolean)} instead.
-     */
-    @Deprecated
-    public void setVerbose(boolean verbose) {
-        mConfig.setVerbose(verbose);
-    }
-
     /**
      * Registers this instance to create jobs for a specific tag. It's possible to have multiple
      * {@link JobCreator}s with a first come first serve order.
@@ -515,98 +460,7 @@ public void removeJobCreator(JobCreator jobCreator) {
     }
 
     /*package*/ JobProxy getJobProxy(JobApi api) {
-        return api.getCachedProxy(mContext);
-    }
-
-    // TODO: extract this class so that settings can be changed before the JobManager has been created
-    public final class Config {
-
-        private boolean mGcmEnabled;
-        private boolean mAllowSmallerIntervals;
-
-        private Config() {
-            mGcmEnabled = true;
-            mAllowSmallerIntervals = false;
-        }
-
-        /**
-         * @return Whether logging is enabled for this library. The default value is {@code true}.
-         */
-        public boolean isVerbose() {
-            return JobCat.isLogcatEnabled();
-        }
-
-        /**
-         * Global switch to enable or disable logging.
-         *
-         * @param verbose Whether or not to print all log messages. The default value is {@code true}.
-         */
-        public void setVerbose(boolean verbose) {
-            JobCat.setLogcatEnabled(verbose);
-        }
-
-        /**
-         * @return Whether the GCM API is enabled. The API is only used if the required class dependency
-         * is found, the Google Play Services are available and this setting is {@code true}. The default
-         * value is {@code true}.
-         */
-        public boolean isGcmApiEnabled() {
-            return mGcmEnabled;
-        }
-
-        /**
-         * Programmatic switch to disable the GCM API. If {@code false}, then the {@link AlarmManager} will
-         * be used for Android 4 devices in all cases.
-         *
-         * @param enabled Whether the GCM API should be enabled or disabled. Note that the API is only used,
-         *                if the required class dependency is found, the Google Play Services are available
-         *                and this setting is {@code true}. The default value is {@code true}.
-         */
-        public void setGcmApiEnabled(boolean enabled) {
-            if (enabled == mGcmEnabled) {
-                return;
-            }
-
-            mGcmEnabled = enabled;
-            if (enabled) {
-                JobApi defaultApi = JobApi.getDefault(mContext, true);
-                if (!defaultApi.equals(getApi())) {
-                    setJobProxy(defaultApi);
-                    CAT.i("Changed default proxy to %s after enabled the GCM API", defaultApi);
-                }
-            } else {
-                JobApi defaultApi = JobApi.getDefault(mContext, false);
-                if (JobApi.GCM == getApi()) {
-                    setJobProxy(defaultApi);
-                    CAT.i("Changed default proxy to %s after disabling the GCM API", defaultApi);
-                }
-            }
-        }
-
-        /**
-         * Checks whether a smaller interval and flex are allowed for periodic jobs. That's helpful
-         * for testing purposes.
-         *
-         * @return Whether a smaller interval and flex than the minimum values are allowed for periodic jobs
-         * are allowed. The default value is {@code false}.
-         */
-        public boolean isAllowSmallerIntervalsForMarshmallow() {
-            return mAllowSmallerIntervals && Build.VERSION.SDK_INT < Build.VERSION_CODES.N;
-        }
-
-        /**
-         * Option to override the minimum period and minimum flex for periodic jobs. This is useful for testing
-         * purposes. This method only works for Android M and earlier. Later versions throw an exception.
-         *
-         * @param allowSmallerIntervals Whether a smaller interval and flex than the minimum values are allowed
-         *                              for periodic jobs are allowed. The default value is {@code false}.
-         */
-        public void setAllowSmallerIntervalsForMarshmallow(boolean allowSmallerIntervals) {
-            if (allowSmallerIntervals && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-                throw new IllegalStateException("This method is only allowed to call on Android M or earlier");
-            }
-            mAllowSmallerIntervals = allowSmallerIntervals;
-        }
+        return api.getProxy(mContext);
     }
 
     private static void sendAddJobCreatorIntent(@NonNull Context context) {
diff --git a/library/src/main/java/com/evernote/android/job/JobManagerCreateException.java b/library/src/main/java/com/evernote/android/job/JobManagerCreateException.java
index cdacbaa..74d0580 100644
--- a/library/src/main/java/com/evernote/android/job/JobManagerCreateException.java
+++ b/library/src/main/java/com/evernote/android/job/JobManagerCreateException.java
@@ -25,15 +25,13 @@
  */
 package com.evernote.android.job;
 
-import com.evernote.android.job.util.JobApi;
-
 /**
  * Indicates illegal states during the creation of the {@link JobManager}.
  *
  * <br>
  * <br>
  *
- * You can suppress this exception with {@link JobApi#setForceAllowApi14(boolean)}.
+ * You can suppress this exception with {@link JobConfig#setForceAllowApi14(boolean)}.
  *
  * @author rwondratschek
  */
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index 4e06b44..d471820 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -29,10 +29,11 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Bundle;
 import android.os.Looper;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
@@ -60,6 +61,7 @@
 
     boolean isPlatformJobScheduled(JobRequest request);
 
+    @SuppressWarnings("UnusedReturnValue")
     /*package*/ final class Common {
 
         private static final Object COMMON_MONITOR = new Object();
@@ -69,7 +71,7 @@
             private final AtomicInteger mThreadNumber = new AtomicInteger();
 
             @Override
-            public Thread newThread(Runnable r) {
+            public Thread newThread(@NonNull Runnable r) {
                 Thread thread = new Thread(r, "AndroidJob-" + mThreadNumber.incrementAndGet());
                 if (thread.isDaemon()) {
                     thread.setDaemon(false);
@@ -152,7 +154,7 @@ public Common(@NonNull Service service, CatLog cat, int jobId) {
             mJobManager = manager;
         }
 
-        public JobRequest getPendingRequest(boolean cleanUpOrphanedJob, boolean markStarting) {
+        public JobRequest getPendingRequest(@SuppressWarnings("SameParameterValue") boolean cleanUpOrphanedJob, boolean markStarting) {
             synchronized (COMMON_MONITOR) {
                 if (mJobManager == null) {
                     return null;
@@ -180,9 +182,9 @@ public JobRequest getPendingRequest(boolean cleanUpOrphanedJob, boolean markStar
                     // don't clean up, periodic job
                     return null;
 
-                } else if (request != null && request.isTransient()) {
-                    mCat.d("Request %d is transient, %s", mJobId, request);
-                    // not necessary to clean up, the JobManager will do this for transient jobs
+                } else if (request != null && request.isStarted()) {
+                    mCat.d("Request %d already started, %s", mJobId, request);
+                    // not necessary to clean up, the JobManager will do this for started jobs
                     return null;
 
                 } else if (request != null && mJobManager.getJobExecutor().isRequestStarting(request)) {
@@ -196,15 +198,19 @@ public JobRequest getPendingRequest(boolean cleanUpOrphanedJob, boolean markStar
                 }
 
                 if (markStarting) {
-                    mJobManager.getJobExecutor().markJobRequestStarting(request);
+                    markStarting(request);
                 }
 
                 return request;
             }
         }
 
+        public void markStarting(@NonNull JobRequest request) {
+            mJobManager.getJobExecutor().markJobRequestStarting(request);
+        }
+
         @NonNull
-        public Job.Result executeJobRequest(@NonNull JobRequest request) {
+        public Job.Result executeJobRequest(@NonNull JobRequest request, @Nullable Bundle transientExtras) {
             long waited = System.currentTimeMillis() - request.getScheduledAt();
             String timeWindow;
             if (request.isPeriodic()) {
@@ -226,14 +232,18 @@ public JobRequest getPendingRequest(boolean cleanUpOrphanedJob, boolean markStar
             Job job = null;
 
             try {
-                // create job first before setting it transient, avoids a race condition while rescheduling jobs
+                // create job first before setting it started, avoids a race condition while rescheduling jobs
                 job = mJobManager.getJobCreatorHolder().createJob(request.getTag());
 
                 if (!request.isPeriodic()) {
-                    request.setTransient(true);
+                    request.setStarted(true);
+                }
+
+                if (transientExtras == null) {
+                    transientExtras = Bundle.EMPTY;
                 }
 
-                Future<Job.Result> future = jobExecutor.execute(mContext, request, job);
+                Future<Job.Result> future = jobExecutor.execute(mContext, request, job, transientExtras);
                 if (future == null) {
                     return Job.Result.FAILURE;
                 }
@@ -270,7 +280,7 @@ private void cleanUpOrphanedJob(boolean cleanUp) {
             }
         }
 
-        public static void cleanUpOrphanedJob(Context context, int jobId) {
+        /*package*/ static void cleanUpOrphanedJob(Context context, int jobId) {
             /*
              * That's necessary if the database was deleted and jobs (especially the JobScheduler) are still around.
              * Then if a new job is being scheduled, it's possible that the new job has the ID of the old one. Here
@@ -279,7 +289,7 @@ public static void cleanUpOrphanedJob(Context context, int jobId) {
             for (JobApi jobApi : JobApi.values()) {
                 if (jobApi.isSupported(context)) {
                     try {
-                        jobApi.getCachedProxy(context).cancel(jobId);
+                        jobApi.getProxy(context).cancel(jobId);
                     } catch (Exception ignored) {
                         // GCM API could crash if it's disabled, ignore crashes at this point and continue
                     }
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 6b4b186..9e2f461 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -26,16 +26,17 @@
 package com.evernote.android.job;
 
 import android.app.AlarmManager;
+import android.app.Service;
 import android.content.ContentValues;
+import android.content.Context;
 import android.database.Cursor;
+import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
-import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobPreconditions;
-import com.evernote.android.job.util.JobUtil;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.CatLog;
@@ -78,7 +79,7 @@
      * <br>
      *
      * This limit comes from the {@code JobScheduler} starting with Android Nougat. You can read
-     * <a href="https://github.com/evernote/android-job/blob/master/FAQ.md">here</a> more about
+     * <a href="https://github.com/evernote/android-job/wiki/FAQ">here</a> more about
      * the limit.
      *
      * @see Builder#setPeriodic(long)
@@ -93,7 +94,7 @@
      * <br>
      *
      * This limit comes from the {@code JobScheduler} starting with Android Nougat. You can read
-     * <a href="https://github.com/evernote/android-job/blob/master/FAQ.md">here</a> more about
+     * <a href="https://github.com/evernote/android-job/wiki/FAQ">here</a> more about
      * the limit.
      *
      * @see Builder#setPeriodic(long, long)
@@ -106,25 +107,29 @@
     private static final CatLog CAT = new JobCat("JobRequest");
 
     /*package*/ static long getMinInterval() {
-        return JobManager.instance().getConfig().isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.MINUTES.toMillis(1) : MIN_INTERVAL;
+        return JobConfig.isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.MINUTES.toMillis(1) : MIN_INTERVAL;
     }
 
     /*package*/ static long getMinFlex() {
-        return JobManager.instance().getConfig().isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.SECONDS.toMillis(30) : MIN_FLEX;
+        return JobConfig.isAllowSmallerIntervalsForMarshmallow() ? TimeUnit.SECONDS.toMillis(30) : MIN_FLEX;
+    }
+
+    /*package*/ static final long START_NOW = 1;
+
+    private static Context context() {
+        return JobManager.instance().getContext();
     }
 
     private final Builder mBuilder;
-    private final JobApi mJobApi;
 
     private int mFailureCount;
     private long mScheduledAt;
-    private boolean mTransient;
+    private boolean mStarted;
     private boolean mFlexSupport;
     private long mLastRun;
 
     private JobRequest(Builder builder) {
         mBuilder = builder;
-        mJobApi = builder.mExact ? JobApi.V_14 : JobManager.instance().getApi();
     }
 
     /**
@@ -221,12 +226,26 @@ public boolean requiresCharging() {
     }
 
     /**
-     * @return If {@code true}, then job should only run if the device is idle.
+     * @return If {@code true}, then the job should only run if the device is idle.
      */
     public boolean requiresDeviceIdle() {
         return mBuilder.mRequiresDeviceIdle;
     }
 
+    /**
+     * @return If {@code true}, then the job should only run if the battery isn't low.
+     */
+    public boolean requiresBatteryNotLow() {
+        return mBuilder.mRequiresBatteryNotLow;
+    }
+
+    /**
+     * @return If {@code true}, then the job should only run if the battery isn't low.
+     */
+    public boolean requiresStorageNotLow() {
+        return mBuilder.mRequiresStorageNotLow;
+    }
+
     /**
      * @return The network state which is required to run the job.
      */
@@ -244,13 +263,6 @@ public PersistableBundleCompat getExtras() {
         return mBuilder.mExtras;
     }
 
-    /**
-     * @return If {@code true}, then the job persists across reboots.
-     */
-    public boolean isPersisted() {
-        return mBuilder.mPersisted;
-    }
-
     /**
      * @return If {@code true}, then this request will overwrite any preexisting jobs.
      */
@@ -292,7 +304,7 @@ public boolean isExact() {
     }
 
     /*package*/ JobApi getJobApi() {
-        return mJobApi;
+        return mBuilder.mExact ? JobApi.V_14 : JobApi.getDefault(context());
     }
 
     /*package*/ void setScheduledAt(long timeStamp) {
@@ -326,16 +338,16 @@ public int getFailureCount() {
     }
 
     /**
-     * Only non-periodic jobs can be in a transient state. The transient state means, that
-     * the job is running and is about to be removed. A job can get stuck in a transient state,
+     * Only non-periodic jobs can be in a started state. The started state means, that
+     * the job is running and is about to be removed. A job can get stuck in a started state,
      * if the app terminates while the job is running. Then the job isn't scheduled anymore, but
      * the entry is still in the database. Since the job didn't finish successfully, reschedule
      * the job if necessary and treat it as it wouldn't have run, yet.
      *
-     * @return Whether the job is in a transient state.
+     * @return Whether the job is in a started state.
      */
-    /*package*/ boolean isTransient() {
-        return mTransient;
+    /*package*/ boolean isStarted() {
+        return mStarted;
     }
 
     /*package*/ boolean isFlexSupport() {
@@ -356,6 +368,36 @@ public long getLastRun() {
         return mLastRun;
     }
 
+    /**
+     * Returns whether this is a transient jobs. <b>WARNING:</b> It's not guaranteed that a transient job
+     * will run at all, e.g. rebooting the device or force closing the app will cancel the
+     * job.
+     *
+     * @return If this is a transient job.
+     */
+    public boolean isTransient() {
+        return mBuilder.mTransient;
+    }
+
+    /**
+     * Returns the transient extras you passed in when constructing this job with
+     * {@link Builder#setTransientExtras(Bundle)}. <b>WARNING:</b> It's not guaranteed that a transient job
+     * will run at all, e.g. rebooting the device or force closing the app will cancel the
+     * job.
+     *
+     * <br>
+     * <br>
+     *
+     * This will never be {@code null}. If you did not set any extras this will be an empty bundle.
+     * The returned bundle will also be empty, if the request isn't cached anymore.
+     *
+     * @return The transient extras you passed in when constructing this job.
+     */
+    @NonNull
+    public Bundle getTransientExtras() {
+        return mBuilder.mTransientExtras;
+    }
+
     /**
      * Convenience method. Internally it calls {@link JobManager#schedule(JobRequest)}
      * and {@link #getJobId()} for this request.
@@ -376,12 +418,15 @@ public int schedule() {
      * @return A builder to modify the parameters.
      */
     public Builder cancelAndEdit() {
+        // create a temporary variable, because .cancel() will reset mScheduledAt
+        long scheduledAt = mScheduledAt;
+
         JobManager.instance().cancel(getJobId());
         Builder builder = new Builder(this.mBuilder);
-        mTransient = false;
+        mStarted = false;
 
         if (!isPeriodic()) {
-            long offset = System.currentTimeMillis() - mScheduledAt;
+            long offset = JobConfig.getClock().currentTimeMillis() - scheduledAt;
             long minValue = 1L; // 1ms
             builder.setExecutionWindow(Math.max(minValue, getStartMs() - offset), Math.max(minValue, getEndMs() - offset));
         }
@@ -389,6 +434,10 @@ public Builder cancelAndEdit() {
         return builder;
     }
 
+    /*package*/ Builder createBuilder() {
+        return new Builder(mBuilder, true);
+    }
+
     /*package*/ JobRequest reschedule(boolean failure, boolean newJob) {
         JobRequest newRequest = new Builder(this.mBuilder, newJob).build();
         if (failure) {
@@ -410,16 +459,16 @@ public Builder cancelAndEdit() {
             contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mFailureCount);
         }
         if (updateLastRun) {
-            mLastRun = System.currentTimeMillis();
+            mLastRun = JobConfig.getClock().currentTimeMillis();
             contentValues.put(JobStorage.COLUMN_LAST_RUN, mLastRun);
         }
         JobManager.instance().getJobStorage().update(this, contentValues);
     }
 
-    /*package*/ void setTransient(boolean isTransient) {
-        mTransient = isTransient;
+    /*package*/ void setStarted(boolean started) {
+        mStarted = started;
         ContentValues contentValues = new ContentValues();
-        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
+        contentValues.put(JobStorage.COLUMN_STARTED, mStarted);
         JobManager.instance().getJobStorage().update(this, contentValues);
     }
 
@@ -428,7 +477,7 @@ public Builder cancelAndEdit() {
         mBuilder.fillContentValues(contentValues);
         contentValues.put(JobStorage.COLUMN_NUM_FAILURES, mFailureCount);
         contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, mScheduledAt);
-        contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
+        contentValues.put(JobStorage.COLUMN_STARTED, mStarted);
         contentValues.put(JobStorage.COLUMN_FLEX_SUPPORT, mFlexSupport);
         contentValues.put(JobStorage.COLUMN_LAST_RUN, mLastRun);
         return contentValues;
@@ -438,7 +487,7 @@ public Builder cancelAndEdit() {
         JobRequest request = new Builder(cursor).build();
         request.mFailureCount = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_NUM_FAILURES));
         request.mScheduledAt = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_SCHEDULED_AT));
-        request.mTransient = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_TRANSIENT)) > 0;
+        request.mStarted = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_STARTED)) > 0;
         request.mFlexSupport = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_FLEX_SUPPORT)) > 0;
         request.mLastRun = cursor.getLong(cursor.getColumnIndex(JobStorage.COLUMN_LAST_RUN));
 
@@ -465,12 +514,13 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "request{id=" + getJobId() + ", tag=" + getTag() + '}';
+        return "request{id=" + getJobId() + ", tag=" + getTag() + ", transient=" + isTransient() + '}';
     }
 
     /**
      * Builder class for constructing JobRequests.
      */
+    @SuppressWarnings("unused")
     public static final class Builder {
 
         private static final int CREATE_ID = -8765; // magic number
@@ -490,16 +540,19 @@ public String toString() {
         private boolean mRequirementsEnforced;
         private boolean mRequiresCharging;
         private boolean mRequiresDeviceIdle;
+        private boolean mRequiresBatteryNotLow;
+        private boolean mRequiresStorageNotLow;
         private boolean mExact;
         private NetworkType mNetworkType;
 
         private PersistableBundleCompat mExtras;
         private String mExtrasXml;
 
-        private boolean mPersisted;
-
         private boolean mUpdateCurrent;
 
+        private boolean mTransient;
+        private Bundle mTransientExtras = Bundle.EMPTY;
+
         /**
          * Creates a new instance to build a {@link JobRequest}. Note that the {@code tag} doesn't
          * need to be unique. Each created request has an unique ID to differentiate between jobs
@@ -548,6 +601,8 @@ private Builder(Cursor cursor) throws Exception {
             mRequirementsEnforced = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIREMENTS_ENFORCED)) > 0;
             mRequiresCharging = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIRES_CHARGING)) > 0;
             mRequiresDeviceIdle = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIRES_DEVICE_IDLE)) > 0;
+            mRequiresBatteryNotLow = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIRES_BATTERY_NOT_LOW)) > 0;
+            mRequiresStorageNotLow = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_REQUIRES_STORAGE_NOT_LOW)) > 0;
             mExact = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_EXACT)) > 0;
             try {
                 mNetworkType = NetworkType.valueOf(cursor.getString(cursor.getColumnIndex(JobStorage.COLUMN_NETWORK_TYPE)));
@@ -557,8 +612,7 @@ private Builder(Cursor cursor) throws Exception {
             }
 
             mExtrasXml = cursor.getString(cursor.getColumnIndex(JobStorage.COLUMN_EXTRAS));
-
-            mPersisted = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_PERSISTED)) > 0;
+            mTransient = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_TRANSIENT)) > 0;
         }
 
         // copy constructor
@@ -582,15 +636,17 @@ private Builder(@NonNull Builder builder, boolean createId) {
             mRequirementsEnforced = builder.mRequirementsEnforced;
             mRequiresCharging = builder.mRequiresCharging;
             mRequiresDeviceIdle = builder.mRequiresDeviceIdle;
+            mRequiresBatteryNotLow = builder.mRequiresBatteryNotLow;
+            mRequiresStorageNotLow = builder.mRequiresStorageNotLow;
             mExact = builder.mExact;
             mNetworkType = builder.mNetworkType;
 
             mExtras = builder.mExtras;
             mExtrasXml = builder.mExtrasXml;
 
-            mPersisted = builder.mPersisted;
-
             mUpdateCurrent = builder.mUpdateCurrent;
+            mTransient = builder.mTransient;
+            mTransientExtras = builder.mTransientExtras;
         }
 
         private void fillContentValues(ContentValues contentValues) {
@@ -609,6 +665,8 @@ private void fillContentValues(ContentValues contentValues) {
             contentValues.put(JobStorage.COLUMN_REQUIREMENTS_ENFORCED, mRequirementsEnforced);
             contentValues.put(JobStorage.COLUMN_REQUIRES_CHARGING, mRequiresCharging);
             contentValues.put(JobStorage.COLUMN_REQUIRES_DEVICE_IDLE, mRequiresDeviceIdle);
+            contentValues.put(JobStorage.COLUMN_REQUIRES_BATTERY_NOT_LOW, mRequiresBatteryNotLow);
+            contentValues.put(JobStorage.COLUMN_REQUIRES_STORAGE_NOT_LOW, mRequiresStorageNotLow);
             contentValues.put(JobStorage.COLUMN_EXACT, mExact);
             contentValues.put(JobStorage.COLUMN_NETWORK_TYPE, mNetworkType.toString());
 
@@ -617,7 +675,8 @@ private void fillContentValues(ContentValues contentValues) {
             } else if (!TextUtils.isEmpty(mExtrasXml)) {
                 contentValues.put(JobStorage.COLUMN_EXTRAS, mExtrasXml);
             }
-            contentValues.put(JobStorage.COLUMN_PERSISTED, mPersisted);
+
+            contentValues.put(JobStorage.COLUMN_TRANSIENT, mTransient);
         }
 
         /**
@@ -682,6 +741,22 @@ public Builder setExtras(@Nullable PersistableBundleCompat extras) {
             return this;
         }
 
+        /**
+         * Adds optional extras. This is persisted, so only primitive types are allowed. This method overrides
+         * values with the same keys inside of {@code extras}, which were set before.
+         *
+         * @param extras Bundle containing extras which you can retrieve with {@link Job.Params#getExtras()}.
+         */
+        public Builder addExtras(@NonNull PersistableBundleCompat extras) {
+            if (mExtras == null) {
+                mExtras = extras;
+            } else {
+                mExtras.putAll(extras);
+            }
+            mExtrasXml = null;
+            return this;
+        }
+
         /**
          * It's possible to set several requirements for a job, however, not all of them need to
          * be considered by the underlying {@link JobApi}. If the requirements are enforced, then
@@ -773,6 +848,46 @@ public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {
             return this;
         }
 
+        /**
+         * Specify that to run this job, the device battery shouldn't be below a curtain threshold.
+         * The default is set to {@code false}.
+         *
+         * <br>
+         * <br>
+         *
+         * Note that if the deadline is met and the requirements aren't enforced, then your job
+         * will run and ignore this requirement.
+         *
+         * @param requiresBatteryNotLow Whether or not the device batter shouldn't be low.
+         * @see #setRequirementsEnforced(boolean)
+         * @see #setExecutionWindow(long, long)
+         */
+        public Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow) {
+            mRequiresBatteryNotLow = requiresBatteryNotLow;
+            return this;
+        }
+
+        /**
+         * Specify that to run this job, the device storage shouldn't be low.
+         * The default is set to {@code false}. <b>Note: </b>This requirement only has an
+         * affect on Android O, but not lower versions. It's never guaranteed that enough
+         * space is available, when your job runs. This is more like a hint.
+         *
+         * <br>
+         * <br>
+         *
+         * Note that if the deadline is met and the requirements aren't enforced, then your job
+         * will run and ignore this requirement.
+         *
+         * @param requiresStorageNotLow Whether or not the device storage shouldn't be low.
+         * @see #setRequirementsEnforced(boolean)
+         * @see #setExecutionWindow(long, long)
+         */
+        public Builder setRequiresStorageNotLow(boolean requiresStorageNotLow) {
+            mRequiresStorageNotLow = requiresStorageNotLow;
+            return this;
+        }
+
         /**
          * Specify that the job should run at an exact time. This type of job must only be used
          * for situations where it is actually required that the alarm go off even while in idle.
@@ -819,6 +934,25 @@ public Builder setExact(long exactInMs) {
             return setExecutionWindow(exactInMs, exactInMs);
         }
 
+        /**
+         * Specify that the job should start immediately. This is similar to an exact job and has
+         * the same constraints, e.g. no other requirements like a specific network condition
+         * are allowed. This method overrides any specified time window.
+         *
+         * <br>
+         * <br>
+         *
+         * The advantage if a job that starts immediately compared to implementing your own
+         * {@link Service} is that jobs run in parallel and can be rescheduled if necessary. It
+         * also respect the background execution limit introduced in Android O, meaning that if
+         * it's not allowed to start a {@link Service}, then the work is delayed.
+         *
+         * @see #setExact(long)
+         */
+        public Builder startNow() {
+            return setExact(START_NOW);
+        }
+
         /**
          * Specify that this job should recur with the provided interval, not more than once per period. As
          * default a job isn't periodic.
@@ -881,22 +1015,6 @@ public Builder setBackoffCriteria(long backoffMs, @NonNull BackoffPolicy backoff
             return this;
         }
 
-        /**
-         * Set whether the job should be persisted across reboots. This will only have an
-         * effect if your application holds the permission
-         * {@link android.Manifest.permission#RECEIVE_BOOT_COMPLETED}. Otherwise an exception will
-         * be thrown. The default is set to {@code false}.
-         *
-         * @param persisted If {@code true} the job is scheduled after a reboot.
-         */
-        public Builder setPersisted(boolean persisted) {
-            if (persisted && !JobUtil.hasBootPermission(JobManager.instance().getContext())) {
-                throw new IllegalStateException("Does not have RECEIVE_BOOT_COMPLETED permission, which is mandatory for this feature");
-            }
-            mPersisted = persisted;
-            return this;
-        }
-
         /**
          * Sets whether this request should overwrite any preexisting jobs with the same tag. If {@code true},
          * then this request calls {@link JobManager#cancelAllForTag(String)} with the given tag before
@@ -910,6 +1028,25 @@ public Builder setUpdateCurrent(boolean updateCurrent) {
             return this;
         }
 
+        /**
+         * Set optional transient extras. <b>WARNING:</b> It's not guaranteed that a transient job will
+         * run at all, e.g. rebooting the device or force closing the app will cancel the job. This is
+         * only helpful for jobs which should start soon and can be cancelled automatically.
+         *
+         * <br>
+         * <br>
+         *
+         * If the passed in bundle is {@code null} or empty, then the previous extras are reset to the default
+         * and the job won't be transient.
+         *
+         * @param extras  Bundle containing extras you want the scheduler to hold on to for you.
+         */
+        public Builder setTransientExtras(@Nullable Bundle extras) {
+            mTransient = extras != null && !extras.isEmpty();
+            mTransientExtras = mTransient ? new Bundle(extras) : Bundle.EMPTY;
+            return this;
+        }
+
         /**
          * @return The {@link JobRequest} with this parameters to hand to the {@link JobManager}.
          */
@@ -936,7 +1073,8 @@ public JobRequest build() {
             if (mExact && mStartMs != mEndMs) {
                 throw new IllegalArgumentException("Can't call setExecutionWindow() for an exact job.");
             }
-            if (mExact && (mRequirementsEnforced || mRequiresDeviceIdle || mRequiresCharging || !DEFAULT_NETWORK_TYPE.equals(mNetworkType))) {
+            if (mExact && (mRequirementsEnforced || mRequiresDeviceIdle || mRequiresCharging || !DEFAULT_NETWORK_TYPE.equals(mNetworkType)
+                    || mRequiresBatteryNotLow || mRequiresStorageNotLow)) {
                 throw new IllegalArgumentException("Can't require any condition for an exact job.");
             }
 
@@ -952,7 +1090,7 @@ public JobRequest build() {
             }
 
             if (mIntervalMs <= 0 && (mStartMs > WINDOW_THRESHOLD_WARNING || mEndMs > WINDOW_THRESHOLD_WARNING)) {
-                CAT.w("Attention: your execution window is too large. This could result in undesired behavior, see https://github.com/evernote/android-job/blob/master/FAQ.md");
+                CAT.w("Attention: your execution window is too large. This could result in undesired behavior, see https://github.com/evernote/android-job/wiki/FAQ");
             }
 
             if (mIntervalMs <= 0 && (mStartMs > TimeUnit.DAYS.toMillis(365))) {
@@ -1015,6 +1153,10 @@ public int hashCode() {
         /**
          * Network must be connected and not roaming, but can be metered.
          */
-        NOT_ROAMING
+        NOT_ROAMING,
+        /**
+         * This job requires metered connectivity such as most cellular data networks.
+         */
+        METERED
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobRescheduleService.java b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
index 4503029..6c370c8 100644
--- a/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
+++ b/library/src/main/java/com/evernote/android/job/JobRescheduleService.java
@@ -1,30 +1,35 @@
 package com.evernote.android.job;
 
-import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
+import android.support.v4.app.JobIntentService;
 
 import com.evernote.android.job.util.JobCat;
 
 import net.vrallev.android.cat.CatLog;
+import net.vrallev.android.cat.instance.CatEmpty;
 
+import java.util.Collection;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 
 /**
+ * This service reschedules your jobs in case this should be necessary. Usually rescheduling is necessary
+ * after a reboot. If you don't want that your jobs are rescheduled, then you should use a transient job
+ * or cancel your job manually.
+ *
  * @author rwondratschek
  */
-public final class JobRescheduleService extends IntentService {
+public final class JobRescheduleService extends JobIntentService {
 
-    private static final String TAG = "JobRescheduleService";
-    private static final CatLog CAT = new JobCat(TAG);
+    private static final CatLog CAT = BuildConfig.DEBUG ? new JobCat("JobRescheduleService") : new CatEmpty();
 
     /*package*/ static void startService(Context context) {
         try {
-            Intent intent = new Intent(context, JobRescheduleService.class);
-            WakeLockUtil.startWakefulService(context, intent);
+            enqueueWork(context, JobRescheduleService.class, JobIdsInternal.JOB_ID_JOB_RESCHEDULE_SERVICE, new Intent());
             latch = new CountDownLatch(1);
         } catch (Exception e) {
             /*
@@ -44,21 +49,17 @@
     @VisibleForTesting
     /*package*/ static CountDownLatch latch;
 
-    public JobRescheduleService() {
-        super(TAG);
-    }
-
     @Override
-    protected void onHandleIntent(Intent intent) {
+    protected void onHandleWork(@NonNull Intent intent) {
+        /*
+         * Delay this slightly. This avoids a race condition if the app was launched by the
+         * AlarmManager. Then the alarm was already removed, but the JobRequest might still
+         * be available in the storage. We still catch this case, because we never execute
+         * a job with the same ID twice. Nonetheless, add the delay to save resources.
+         */
         try {
-            /*
-             * Delay this slightly. This avoids a race condition if the app was launched by the
-             * AlarmManager. Then the alarm was already removed, but the JobRequest might still
-             * be available in the storage. We still catch this case, because we never execute
-             * a job with the same ID twice. However, the still save resources with the delay.
-             */
             CAT.d("Reschedule service started");
-            SystemClock.sleep(10_000L);
+            SystemClock.sleep(JobConfig.getJobReschedulePause());
 
             JobManager manager;
             try {
@@ -67,49 +68,54 @@ protected void onHandleIntent(Intent intent) {
                 return;
             }
 
-            Set<JobRequest> requests = manager.getJobStorage().getAllJobRequests(null, true);
+            Set<JobRequest> requests = manager.getAllJobRequests(null, true, true);
 
-            int rescheduledCount = 0;
-            boolean exceptionThrown = false;
-
-            for (JobRequest request : requests) {
-                boolean reschedule;
-                if (request.isTransient()) {
-                    Job job = manager.getJob(request.getJobId());
-                    reschedule = job == null;
-                } else {
-                    reschedule = !manager.getJobProxy(request.getJobApi()).isPlatformJobScheduled(request);
-                }
-
-                if (reschedule) {
-                    // update execution window
-                    try {
-                        request.cancelAndEdit()
-                                .build()
-                                .schedule();
-                    } catch (Exception e) {
-                        // this may crash (e.g. more than 100 jobs with JobScheduler), but it's not catchable for the user
-                        // better catch here, otherwise app will end in a crash loop
-                        if (!exceptionThrown) {
-                            CAT.e(e);
-                            exceptionThrown = true;
-                        }
-                    }
-
-                    rescheduledCount++;
-                }
-            }
+            int rescheduledCount = rescheduleJobs(manager, requests);
 
             CAT.d("Reschedule %d jobs of %d jobs", rescheduledCount, requests.size());
-
+        } finally {
             if (latch != null) {
                 // latch can be null, if the service was restarted after a process death
                 latch.countDown();
             }
-
-        } finally {
-            WakeLockUtil.completeWakefulIntent(intent);
         }
+    }
+
+    @SuppressWarnings("UnusedReturnValue")
+    /*package*/ int rescheduleJobs(JobManager manager) {
+        return rescheduleJobs(manager, manager.getAllJobRequests(null, true, true));
+    }
+
+    /*package*/ int rescheduleJobs(JobManager manager, Collection<JobRequest> requests) {
+        int rescheduledCount = 0;
+        boolean exceptionThrown = false;
+        for (JobRequest request : requests) {
+            boolean reschedule;
+            if (request.isStarted()) {
+                Job job = manager.getJob(request.getJobId());
+                reschedule = job == null;
+            } else {
+                reschedule = !manager.getJobProxy(request.getJobApi()).isPlatformJobScheduled(request);
+            }
+
+            if (reschedule) {
+                // update execution window
+                try {
+                    request.cancelAndEdit()
+                            .build()
+                            .schedule();
+                } catch (Exception e) {
+                    // this may crash (e.g. more than 100 jobs with JobScheduler), but it's not catchable for the user
+                    // better catch here, otherwise app will end in a crash loop
+                    if (!exceptionThrown) {
+                        CAT.e(e);
+                        exceptionThrown = true;
+                    }
+                }
 
+                rescheduledCount++;
+            }
+        }
+        return rescheduledCount;
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index 7c23bbc..82f3514 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -58,12 +58,12 @@
 
     private static final CatLog CAT = new JobCat("JobStorage");
 
-    private static final String JOB_ID_COUNTER = "JOB_ID_COUNTER_v2";
+    public static final String JOB_ID_COUNTER = "JOB_ID_COUNTER_v2";
     private static final String FAILED_DELETE_IDS = "FAILED_DELETE_IDS";
 
     public static final String PREF_FILE_NAME = "evernote_jobs";
     public static final String DATABASE_NAME = PREF_FILE_NAME + ".db";
-    public static final int DATABASE_VERSION = 4;
+    public static final int DATABASE_VERSION = 6;
 
     public static final String JOB_TABLE_NAME = "jobs";
 
@@ -80,17 +80,29 @@
     public static final String COLUMN_EXACT = "exact";
     public static final String COLUMN_NETWORK_TYPE = "networkType";
     public static final String COLUMN_EXTRAS = "extras";
-    public static final String COLUMN_PERSISTED = "persisted";
+
+    @SuppressWarnings("unused")
+    @Deprecated
+    private static final String COLUMN_PERSISTED = "persisted";
+
     public static final String COLUMN_NUM_FAILURES = "numFailures";
     public static final String COLUMN_SCHEDULED_AT = "scheduledAt";
-    public static final String COLUMN_TRANSIENT = "isTransient";
+
+    @SuppressWarnings("DeprecatedIsStillUsed")
+    @Deprecated
+    private static final String COLUMN_TRANSIENT_OLD = "isTransient";
+
+    public static final String COLUMN_STARTED = "started";
     public static final String COLUMN_FLEX_MS = "flexMs";
     public static final String COLUMN_FLEX_SUPPORT = "flexSupport";
     public static final String COLUMN_LAST_RUN = "lastRun";
+    public static final String COLUMN_TRANSIENT = "transient";
+    public static final String COLUMN_REQUIRES_BATTERY_NOT_LOW = "requiresBatteryNotLow";
+    public static final String COLUMN_REQUIRES_STORAGE_NOT_LOW = "requiresStorageNotLow";
 
     private static final int CACHE_SIZE = 30;
 
-    private static final String WHERE_NOT_TRANSIENT = "ifnull(" + COLUMN_TRANSIENT + ", 0)<=0";
+    private static final String WHERE_NOT_STARTED = "ifnull(" + COLUMN_STARTED + ", 0)<=0";
 
     private final SharedPreferences mPreferences;
     private final JobCacheId mCacheId;
@@ -149,19 +161,19 @@ public synchronized JobRequest get(int id) {
         return mCacheId.get(id);
     }
 
-    public synchronized Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeTransient) {
+    public synchronized Set<JobRequest> getAllJobRequests(@Nullable String tag, boolean includeStarted) {
         Set<JobRequest> result = new HashSet<>();
 
         SQLiteDatabase database = null;
         Cursor cursor = null;
         try {
-            String where; // filter transient requests
+            String where; // filter started requests
             String[] args;
             if (TextUtils.isEmpty(tag)) {
-                where = includeTransient ? null : WHERE_NOT_TRANSIENT;
+                where = includeStarted ? null : WHERE_NOT_STARTED;
                 args = null;
             } else {
-                where = includeTransient ? "" : (WHERE_NOT_TRANSIENT + " AND ");
+                where = includeStarted ? "" : (WHERE_NOT_STARTED + " AND ");
                 where += COLUMN_TAG + "=?";
                 args = new String[]{tag};
             }
@@ -221,13 +233,14 @@ public synchronized int nextJobId() {
 
         int id = mJobCounter.incrementAndGet();
 
-        if (id < 0) {
+        int offset = JobConfig.getJobIdOffset();
+        if (id < offset || id >= JobIdsInternal.RESERVED_JOB_ID_RANGE_START) {
             /*
              * An overflow occurred. It'll happen rarely, but just in case reset the ID and start from scratch.
              * Existing jobs will be treated as orphaned and will be overwritten.
              */
-            id = 1;
-            mJobCounter.set(id);
+            mJobCounter.set(offset);
+            id = mJobCounter.incrementAndGet();
         }
 
         mPreferences.edit().putInt(JOB_ID_COUNTER, id).apply();
@@ -253,7 +266,8 @@ private void store(JobRequest request) {
         }
     }
 
-    private JobRequest load(int id, boolean includeTransient) {
+    @SuppressWarnings("SameParameterValue")
+    private JobRequest load(int id, boolean includeStarted) {
         if (didFailToDelete(id)) {
             return null;
         }
@@ -262,8 +276,8 @@ private JobRequest load(int id, boolean includeTransient) {
         Cursor cursor = null;
         try {
             String where = COLUMN_ID + "=?";
-            if (!includeTransient) {
-                where += " AND " + COLUMN_TRANSIENT + "<=0";
+            if (!includeStarted) {
+                where += " AND " + COLUMN_STARTED + "<=0";
             }
 
             database = getDatabase();
@@ -333,7 +347,7 @@ private JobRequest load(int id, boolean includeTransient) {
             closeDatabase(database);
         }
 
-        return Math.max(jobId, mPreferences.getInt(JOB_ID_COUNTER, 0));
+        return Math.max(JobConfig.getJobIdOffset(), Math.max(jobId, mPreferences.getInt(JOB_ID_COUNTER, 0)));
     }
 
     private void addFailedDeleteId(int id) {
@@ -431,7 +445,15 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                         oldVersion++;
                         break;
                     case 3:
-                        upgradeFrom3to4(db);
+                        upgradeFrom3To4(db);
+                        oldVersion++;
+                        break;
+                    case 4:
+                        upgradeFrom4To5(db);
+                        oldVersion++;
+                        break;
+                    case 5:
+                        upgradeFrom5To6(db);
                         oldVersion++;
                         break;
                     default:
@@ -455,17 +477,20 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXACT + " integer, "
                     + COLUMN_NETWORK_TYPE + " text not null, "
                     + COLUMN_EXTRAS + " text, "
-                    + COLUMN_PERSISTED + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
                     + COLUMN_SCHEDULED_AT + " integer, "
-                    + COLUMN_TRANSIENT + " integer, "
+                    + COLUMN_STARTED + " integer, "
                     + COLUMN_FLEX_MS + " integer, "
                     + COLUMN_FLEX_SUPPORT + " integer, "
-                    + COLUMN_LAST_RUN + " integer);");
+                    + COLUMN_LAST_RUN + " integer, "
+                    + COLUMN_TRANSIENT + " integer, "
+                    + COLUMN_REQUIRES_BATTERY_NOT_LOW + " integer, "
+                    + COLUMN_REQUIRES_STORAGE_NOT_LOW +" integer);");
         }
 
+        @SuppressWarnings("deprecation")
         private void upgradeFrom1To2(SQLiteDatabase db) {
-            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT_OLD + " integer;");
         }
 
         private void upgradeFrom2To3(SQLiteDatabase db) {
@@ -481,9 +506,75 @@ private void upgradeFrom2To3(SQLiteDatabase db) {
             db.execSQL("update " + JOB_TABLE_NAME + " set " + COLUMN_FLEX_MS + " = " + COLUMN_INTERVAL_MS + ";");
         }
 
-        private void upgradeFrom3to4(SQLiteDatabase db) {
+        private void upgradeFrom3To4(SQLiteDatabase db) {
             db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_LAST_RUN + " integer;");
         }
+
+        @SuppressWarnings("deprecation")
+        private void upgradeFrom4To5(SQLiteDatabase db) {
+            // remove "persisted" column and rename "isTransient" to "started", add "transient" column for O
+            try {
+                db.beginTransaction();
+
+                String newTable = JOB_TABLE_NAME + "_new";
+
+                db.execSQL("create table " + newTable + " ("
+                        + COLUMN_ID + " integer primary key, "
+                        + COLUMN_TAG + " text not null, "
+                        + COLUMN_START_MS + " integer, "
+                        + COLUMN_END_MS + " integer, "
+                        + COLUMN_BACKOFF_MS + " integer, "
+                        + COLUMN_BACKOFF_POLICY + " text not null, "
+                        + COLUMN_INTERVAL_MS + " integer, "
+                        + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                        + COLUMN_REQUIRES_CHARGING + " integer, "
+                        + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                        + COLUMN_EXACT + " integer, "
+                        + COLUMN_NETWORK_TYPE + " text not null, "
+                        + COLUMN_EXTRAS + " text, "
+                        + COLUMN_NUM_FAILURES + " integer, "
+                        + COLUMN_SCHEDULED_AT + " integer, "
+                        + COLUMN_STARTED + " integer, "
+                        + COLUMN_FLEX_MS + " integer, "
+                        + COLUMN_FLEX_SUPPORT + " integer, "
+                        + COLUMN_LAST_RUN + " integer);");
+
+                db.execSQL("INSERT INTO " + newTable + " SELECT "
+                        + COLUMN_ID + ","
+                        + COLUMN_TAG + ","
+                        + COLUMN_START_MS + ","
+                        + COLUMN_END_MS + ","
+                        + COLUMN_BACKOFF_MS + ","
+                        + COLUMN_BACKOFF_POLICY + ","
+                        + COLUMN_INTERVAL_MS + ","
+                        + COLUMN_REQUIREMENTS_ENFORCED + ","
+                        + COLUMN_REQUIRES_CHARGING + ","
+                        + COLUMN_REQUIRES_DEVICE_IDLE + ","
+                        + COLUMN_EXACT + ","
+                        + COLUMN_NETWORK_TYPE + ","
+                        + COLUMN_EXTRAS + ","
+                        + COLUMN_NUM_FAILURES + ","
+                        + COLUMN_SCHEDULED_AT + ","
+                        + COLUMN_TRANSIENT_OLD + ","
+                        + COLUMN_FLEX_MS + ","
+                        + COLUMN_FLEX_SUPPORT + ","
+                        + COLUMN_LAST_RUN + " FROM " + JOB_TABLE_NAME);
+
+                db.execSQL("DROP TABLE " + JOB_TABLE_NAME);
+                db.execSQL("ALTER TABLE " + newTable + " RENAME TO " + JOB_TABLE_NAME);
+
+                db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+
+        private void upgradeFrom5To6(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_REQUIRES_BATTERY_NOT_LOW + " integer;");
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_REQUIRES_STORAGE_NOT_LOW + " integer;");
+        }
     }
 
     private static void closeCursor(@Nullable Cursor cursor) {
diff --git a/library/src/main/java/com/evernote/android/job/WakeLockUtil.java b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
index 368ace7..dc4ff6c 100644
--- a/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
+++ b/library/src/main/java/com/evernote/android/job/WakeLockUtil.java
@@ -28,8 +28,9 @@ private WakeLockUtil() {
         // no op
     }
 
+    @SuppressWarnings("SameParameterValue")
     @Nullable
-    public static PowerManager.WakeLock acquireWakeLock(@NonNull Context context, @NonNull String tag, long timeoutMillis) {
+    static PowerManager.WakeLock acquireWakeLock(@NonNull Context context, @NonNull String tag, long timeoutMillis) {
         PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
 
         PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, tag);
@@ -38,7 +39,7 @@ private WakeLockUtil() {
         return acquireWakeLock(context, wakeLock, timeoutMillis) ? wakeLock : null;
     }
 
-    public static boolean acquireWakeLock(@NonNull Context context, @Nullable PowerManager.WakeLock wakeLock, long timeoutMillis) {
+    static boolean acquireWakeLock(@NonNull Context context, @Nullable PowerManager.WakeLock wakeLock, long timeoutMillis) {
         if (wakeLock != null && !wakeLock.isHeld() && JobUtil.hasWakeLockPermission(context)) {
             // Even if we have the permission, some devices throw an exception in the try block nonetheless,
             // I'm looking at you, Samsung SM-T805
@@ -55,7 +56,7 @@ public static boolean acquireWakeLock(@NonNull Context context, @Nullable PowerM
         return false;
     }
 
-    public static void releaseWakeLock(@Nullable PowerManager.WakeLock wakeLock) {
+    static void releaseWakeLock(@Nullable PowerManager.WakeLock wakeLock) {
         try {
             if (wakeLock != null && wakeLock.isHeld()) {
                 wakeLock.release();
diff --git a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
index d3cd0b4..2116532 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/JobProxyGcm.java
@@ -28,14 +28,14 @@
 import android.content.Context;
 import android.support.annotation.NonNull;
 
+import com.evernote.android.job.JobProxy;
+import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.JobUtil;
 import com.google.android.gms.gcm.GcmNetworkManager;
 import com.google.android.gms.gcm.OneoffTask;
 import com.google.android.gms.gcm.PeriodicTask;
 import com.google.android.gms.gcm.Task;
-import com.evernote.android.job.JobProxy;
-import com.evernote.android.job.JobRequest;
-import com.evernote.android.job.util.JobUtil;
 
 import net.vrallev.android.cat.CatLog;
 
@@ -52,9 +52,11 @@
      * already plugged in again.
      */
 
+    private final Context mContext;
     private final GcmNetworkManager mGcmNetworkManager;
 
     public JobProxyGcm(Context context) {
+        mContext = context;
         mGcmNetworkManager = GcmNetworkManager.getInstance(context);
     }
 
@@ -72,7 +74,7 @@ public void plantOneOff(JobRequest request) {
 
         mGcmNetworkManager.schedule(task);
 
-        CAT.d("Scheduled OneoffTask, %s, start %s, end %s, reschedule count %d", request, JobUtil.timeToString(startMs),
+        CAT.d("Scheduled OneoffTask, %s, start %s, end %s (from now), reschedule count %d", request, JobUtil.timeToString(startMs),
                 JobUtil.timeToString(endMs), Common.getRescheduleCount(request));
     }
 
@@ -122,8 +124,9 @@ public boolean isPlatformJobScheduled(JobRequest request) {
                 .setService(PlatformGcmService.class)
                 .setUpdateCurrent(true)
                 .setRequiredNetwork(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(request.isPersisted())
-                .setRequiresCharging(request.requiresCharging());
+                .setPersisted(JobUtil.hasBootPermission(mContext))
+                .setRequiresCharging(request.requiresCharging())
+                .setExtras(request.getTransientExtras());
         return builder;
     }
 
diff --git a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
index 936cf9d..18924ff 100644
--- a/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
+++ b/library/src/main/java/com/evernote/android/job/gcm/PlatformGcmService.java
@@ -42,7 +42,7 @@
  */
 public class PlatformGcmService extends GcmTaskService {
 
-    private static final CatLog CAT = new JobCat("JobRequest");
+    private static final CatLog CAT = new JobCat("PlatformGcmService");
 
     @Override
     public int onRunTask(TaskParams taskParams) {
@@ -54,7 +54,7 @@ public int onRunTask(TaskParams taskParams) {
             return GcmNetworkManager.RESULT_FAILURE;
         }
 
-        Job.Result result = common.executeJobRequest(request);
+        Job.Result result = common.executeJobRequest(request, taskParams.getExtras());
         if (Job.Result.SUCCESS.equals(result)) {
             return GcmNetworkManager.RESULT_SUCCESS;
         } else {
diff --git a/library/src/main/java/com/evernote/android/job/util/BatteryStatus.java b/library/src/main/java/com/evernote/android/job/util/BatteryStatus.java
new file mode 100644
index 0000000..bb248b3
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/util/BatteryStatus.java
@@ -0,0 +1,39 @@
+package com.evernote.android.job.util;
+
+/**
+ * @author rwondratschek
+ */
+public final class BatteryStatus {
+
+    public static final BatteryStatus DEFAULT = new BatteryStatus(false, 1f);
+
+    private final boolean mCharging;
+    private final float mBatteryPercent;
+
+    /*package*/ BatteryStatus(boolean charging, float batteryPercent) {
+        mCharging = charging;
+        mBatteryPercent = batteryPercent;
+    }
+
+    /**
+     * @return Whether the device is charging.
+     */
+    public boolean isCharging() {
+        return mCharging;
+    }
+
+    /**
+     * @return The battery percent from 0..1
+     */
+    public float getBatteryPercent() {
+        return mBatteryPercent;
+    }
+
+    /**
+     * @return Whether the battery is low. The battery is low if has less 15 percent
+     * and is not charging.
+     */
+    public boolean isBatteryLow() {
+        return mBatteryPercent < 0.15f && !mCharging;
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/util/Clock.java b/library/src/main/java/com/evernote/android/job/util/Clock.java
new file mode 100644
index 0000000..a3844b8
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/util/Clock.java
@@ -0,0 +1,25 @@
+package com.evernote.android.job.util;
+
+import android.os.SystemClock;
+
+/**
+ * @author rwondratschek
+ */
+public interface Clock {
+
+    long currentTimeMillis();
+
+    long elapsedRealtime();
+
+    Clock DEFAULT = new Clock() {
+        @Override
+        public long currentTimeMillis() {
+            return System.currentTimeMillis();
+        }
+
+        @Override
+        public long elapsedRealtime() {
+            return SystemClock.elapsedRealtime();
+        }
+    };
+}
diff --git a/library/src/main/java/com/evernote/android/job/util/Device.java b/library/src/main/java/com/evernote/android/job/util/Device.java
index 83996f2..4785e7f 100644
--- a/library/src/main/java/com/evernote/android/job/util/Device.java
+++ b/library/src/main/java/com/evernote/android/job/util/Device.java
@@ -51,18 +51,24 @@ private Device() {
     }
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    public static boolean isCharging(Context context) {
+    public static BatteryStatus getBatteryStatus(Context context) {
         Intent intent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
         if (intent == null) {
             // should not happen
-            return false;
+            return BatteryStatus.DEFAULT;
         }
 
+        int level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
+        int scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
+        float batteryPct = level / (float) scale;
+
         // 0 is on battery
         int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0);
-        return plugged == BatteryManager.BATTERY_PLUGGED_AC
+        boolean charging = plugged == BatteryManager.BATTERY_PLUGGED_AC
                 || plugged == BatteryManager.BATTERY_PLUGGED_USB
                 || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS);
+
+        return new BatteryStatus(charging, batteryPct);
     }
 
     @SuppressWarnings("deprecation")
@@ -109,4 +115,9 @@ public static boolean isIdle(Context context) {
             return JobRequest.NetworkType.NOT_ROAMING;
         }
     }
+
+    public static boolean isStorageLow() {
+        // figure this out
+        return false;
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/util/JobCat.java b/library/src/main/java/com/evernote/android/job/util/JobCat.java
index d4ae71d..7428fef 100644
--- a/library/src/main/java/com/evernote/android/job/util/JobCat.java
+++ b/library/src/main/java/com/evernote/android/job/util/JobCat.java
@@ -29,7 +29,6 @@
 
 import net.vrallev.android.cat.CatLog;
 import net.vrallev.android.cat.instance.CatLazy;
-import net.vrallev.android.cat.print.CatPrinter;
 
 import java.util.Arrays;
 
@@ -40,51 +39,55 @@
  */
 public class JobCat extends CatLazy {
 
-    private static volatile CatPrinter[] printers = new CatPrinter[0]; // use array to avoid synchronization while printing log statements
+    private static volatile JobLogger[] loggers = new JobLogger[0]; // use array to avoid synchronization while printing log statements
     private static volatile boolean logcatEnabled = true;
 
     /**
      * Add a global logger for the job library, which will be notified about each log statement.
      *
-     * @param printer Your desired logger.
-     * @return {@code true} if the printer was added. Returns {@code false} if the printer was
+     * @param logger Your desired logger.
+     * @return {@code true} if the logger was added. Returns {@code false} if the logger was
      * already added.
      */
-    public static synchronized boolean addLogPrinter(@NonNull CatPrinter printer) {
-        for (CatPrinter printer1 : printers) {
-            if (printer.equals(printer1)) {
+    public static synchronized boolean addLogger(@NonNull JobLogger logger) {
+        for (JobLogger printer1 : loggers) {
+            if (logger.equals(printer1)) {
                 return false;
             }
         }
 
-        for (int i = 0; i < printers.length; i++) {
-            if (printers[i] == null) {
-                printers[i] = printer;
+        for (int i = 0; i < loggers.length; i++) {
+            if (loggers[i] == null) {
+                loggers[i] = logger;
                 return true;
             }
         }
 
-        int index = printers.length;
-        printers = Arrays.copyOf(printers, printers.length + 2);
-        printers[index] = printer;
+        int index = loggers.length;
+        loggers = Arrays.copyOf(loggers, loggers.length + 2);
+        loggers[index] = logger;
         return true;
     }
 
     /**
      * Remove a global logger.
      *
-     * @param printer Your desired logger.
-     * @see #addLogPrinter(CatPrinter)
+     * @param logger Your desired logger.
+     * @see #addLogger(JobLogger)
      */
-    public static synchronized void removeLogPrinter(@NonNull CatPrinter printer) {
-        for (int i = 0; i < printers.length; i++) {
-            if (printer.equals(printers[i])) {
-                printers[i] = null;
-                // continue, maybe for some reason the printer is twice in the array
+    public static synchronized void removeLogger(@NonNull JobLogger logger) {
+        for (int i = 0; i < loggers.length; i++) {
+            if (logger.equals(loggers[i])) {
+                loggers[i] = null;
+                // continue, maybe for some reason the logger is twice in the array
             }
         }
     }
 
+    public static synchronized void clearLogger() {
+        Arrays.fill(loggers, null);
+    }
+
     /**
      * Global switch to enable or disable printing log messages to Logcat.
      *
@@ -126,13 +129,13 @@ protected void println(int priority, String message, Throwable t) {
             super.println(priority, message, t);
         }
 
-        CatPrinter[] printers = JobCat.printers;
+        JobLogger[] printers = JobCat.loggers;
         if (printers.length > 0) {
             String tag = getTag();
 
-            for (CatPrinter printer : printers) {
-                if (printer != null) {
-                    printer.println(priority, tag, message, t);
+            for (JobLogger logger : printers) {
+                if (logger != null) {
+                    logger.log(priority, tag, message, t);
                 }
             }
         }
diff --git a/library/src/main/java/com/evernote/android/job/util/JobLogger.java b/library/src/main/java/com/evernote/android/job/util/JobLogger.java
new file mode 100644
index 0000000..dddc31d
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/util/JobLogger.java
@@ -0,0 +1,22 @@
+package com.evernote.android.job.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+/**
+ * Logger interface for the library.
+ *
+ * @author rwondratschek
+ */
+public interface JobLogger {
+    /**
+     * Log a message from the library.
+     *
+     * @param priority The priority of the log message. See {@link Log} for all values.
+     * @param tag The tag of the log message.
+     * @param message The message itself.
+     * @param t The thrown exception in case of a failure.
+     */
+    void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t);
+}
diff --git a/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java b/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java
index 535a985..071c1a7 100644
--- a/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java
+++ b/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java
@@ -18,7 +18,6 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.graphics.Bitmap.CompressFormat;
 import android.net.Uri;
 import android.util.Base64;
 import android.util.Xml;
@@ -27,7 +26,6 @@
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlSerializer;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -41,7 +39,7 @@
 import java.util.Set;
 
 /*package*/ @SuppressWarnings({"unused", "StatementWithEmptyBody", "FinalStaticMethod", "WhileLoopReplaceableByForEach",
-        "ForLoopReplaceableByForEach", "FinalPrivateMethod", "AccessStaticViaInstance", "unchecked", "IfCanBeSwitch"})
+        "ForLoopReplaceableByForEach", "FinalPrivateMethod", "AccessStaticViaInstance", "unchecked", "IfCanBeSwitch", "WeakerAccess", "SameParameterValue", "JavaDoc", "StringConcatenationInLoop"})
 final class XmlUtils {
 
     private XmlUtils() {
@@ -1488,16 +1486,6 @@ public static Bitmap readBitmapAttribute(XmlPullParser in, String name) {
         }
     }
 
-    @Deprecated
-    public static void writeBitmapAttribute(XmlSerializer out, String name, Bitmap value)
-            throws IOException {
-        if (value != null) {
-            final ByteArrayOutputStream os = new ByteArrayOutputStream();
-            value.compress(CompressFormat.PNG, 90, os);
-            writeByteArrayAttribute(out, name, os.toByteArray());
-        }
-    }
-
     @SuppressWarnings("UnnecessaryInterfaceModifier")
     public interface WriteMapCallback {
         /**
diff --git a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
index d3bf77a..8101b48 100644
--- a/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
+++ b/library/src/main/java/com/evernote/android/job/v14/JobProxy14.java
@@ -30,8 +30,10 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
+import android.os.Bundle;
 import android.support.annotation.Nullable;
 
+import com.evernote.android.job.JobConfig;
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
@@ -42,6 +44,7 @@
 /**
  * @author rwondratschek
  */
+@SuppressWarnings("WeakerAccess")
 public class JobProxy14 implements JobProxy {
 
     private static final String TAG = "JobProxy14";
@@ -71,7 +74,12 @@ public void plantOneOff(JobRequest request) {
 
         try {
             if (request.isExact()) {
-                plantOneOffExact(request, alarmManager, pendingIntent);
+                if (request.getStartMs() == 1 && request.getFailureCount() <= 0) {
+                    // this job should start immediately
+                    PlatformAlarmService.start(mContext, request.getJobId(), request.getTransientExtras());
+                } else {
+                    plantOneOffExact(request, alarmManager, pendingIntent);
+                }
             } else {
                 plantOneOffInexact(request, alarmManager, pendingIntent);
             }
@@ -82,24 +90,24 @@ public void plantOneOff(JobRequest request) {
     }
 
     protected void plantOneOffInexact(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
-        alarmManager.set(AlarmManager.RTC, getTriggerAtMillis(request), pendingIntent);
+        alarmManager.set(getType(false), getTriggerAtMillis(request), pendingIntent);
         logScheduled(request);
     }
 
     protected void plantOneOffExact(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
         long triggerAtMillis = getTriggerAtMillis(request);
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+            alarmManager.setExactAndAllowWhileIdle(getType(true), triggerAtMillis, pendingIntent);
         } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+            alarmManager.setExact(getType(true), triggerAtMillis, pendingIntent);
         } else {
-            alarmManager.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
+            alarmManager.set(getType(true), triggerAtMillis, pendingIntent);
         }
         logScheduled(request);
     }
 
     protected void plantOneOffFlexSupport(JobRequest request, AlarmManager alarmManager, PendingIntent pendingIntent) {
-        long triggerAtMs = System.currentTimeMillis() + Common.getAverageDelayMsSupportFlex(request);
+        long triggerAtMs = JobConfig.getClock().currentTimeMillis() + Common.getAverageDelayMsSupportFlex(request);
         alarmManager.set(AlarmManager.RTC, triggerAtMs, pendingIntent);
 
         mCat.d("Scheduled repeating alarm (flex support), %s, interval %s, flex %s", request,
@@ -107,11 +115,23 @@ protected void plantOneOffFlexSupport(JobRequest request, AlarmManager alarmMana
     }
 
     protected long getTriggerAtMillis(JobRequest request) {
-        return System.currentTimeMillis() + Common.getAverageDelayMs(request);
+        if (JobConfig.isForceRtc()) {
+            return JobConfig.getClock().currentTimeMillis() + Common.getAverageDelayMs(request);
+        } else {
+            return JobConfig.getClock().elapsedRealtime() + Common.getAverageDelayMs(request);
+        }
+    }
+
+    protected int getType(boolean wakeup) {
+        if (wakeup) {
+            return JobConfig.isForceRtc() ? AlarmManager.RTC_WAKEUP : AlarmManager.ELAPSED_REALTIME_WAKEUP;
+        } else {
+            return JobConfig.isForceRtc() ? AlarmManager.RTC : AlarmManager.ELAPSED_REALTIME;
+        }
     }
 
     private void logScheduled(JobRequest request) {
-        mCat.d("Scheduled alarm, %s, delay %s, exact %b, reschedule count %d", request,
+        mCat.d("Scheduled alarm, %s, delay %s (from now), exact %b, reschedule count %d", request,
                 JobUtil.timeToString(Common.getAverageDelayMs(request)), request.isExact(), Common.getRescheduleCount(request));
     }
 
@@ -120,7 +140,7 @@ public void plantPeriodic(JobRequest request) {
         PendingIntent pendingIntent = getPendingIntent(request, true);
         AlarmManager alarmManager = getAlarmManager();
         if (alarmManager != null) {
-            alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + request.getIntervalMs(), request.getIntervalMs(), pendingIntent);
+            alarmManager.setRepeating(getType(true), getTriggerAtMillis(request), request.getIntervalMs(), pendingIntent);
         }
 
         mCat.d("Scheduled repeating alarm, %s, interval %s", request, JobUtil.timeToString(request.getIntervalMs()));
@@ -148,8 +168,9 @@ public void cancel(int jobId) {
         AlarmManager alarmManager = getAlarmManager();
         if (alarmManager != null) {
             try {
-                alarmManager.cancel(getPendingIntent(jobId, createPendingIntentFlags(true)));
-                alarmManager.cancel(getPendingIntent(jobId, createPendingIntentFlags(false)));
+                // exact parameter doesn't matter
+                alarmManager.cancel(getPendingIntent(jobId, false, null, createPendingIntentFlags(true)));
+                alarmManager.cancel(getPendingIntent(jobId, false, null, createPendingIntentFlags(false)));
             } catch (Exception e) {
                 // java.lang.SecurityException: get application info: Neither user 1010133 nor
                 // current process has android.permission.INTERACT_ACROSS_USERS.
@@ -177,11 +198,11 @@ protected PendingIntent getPendingIntent(JobRequest request, boolean repeating)
     }
 
     protected PendingIntent getPendingIntent(JobRequest request, int flags) {
-        return getPendingIntent(request.getJobId(), flags);
+        return getPendingIntent(request.getJobId(), request.isExact(), request.getTransientExtras(), flags);
     }
 
-    protected PendingIntent getPendingIntent(int jobId, int flags) {
-        Intent intent = PlatformAlarmReceiver.createIntent(mContext, jobId);
+    protected PendingIntent getPendingIntent(int jobId, boolean exact, @Nullable Bundle transientExtras, int flags) {
+        Intent intent = PlatformAlarmReceiver.createIntent(mContext, jobId, exact, transientExtras);
 
         // repeating PendingIntent with service seams to have problems
         try {
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
index 63ab913..f954f60 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmReceiver.java
@@ -25,35 +25,43 @@
  */
 package com.evernote.android.job.v14;
 
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.support.v4.content.WakefulBroadcastReceiver;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
 
 import com.evernote.android.job.JobProxy;
-import com.evernote.android.job.util.JobCat;
-
-import net.vrallev.android.cat.CatLog;
 
 /**
  * @author rwondratschek
  */
-public class PlatformAlarmReceiver extends WakefulBroadcastReceiver {
+public class PlatformAlarmReceiver extends BroadcastReceiver {
 
     /*package*/ static final String EXTRA_JOB_ID = "EXTRA_JOB_ID";
+    /*package*/ static final String EXTRA_JOB_EXACT = "EXTRA_JOB_EXACT";
+    /*package*/ static final String EXTRA_TRANSIENT_EXTRAS = "EXTRA_TRANSIENT_EXTRAS";
 
-    private static final CatLog CAT = new JobCat("PlatformAlarmReceiver");
-
-    /*package*/ static Intent createIntent(Context context, int jobId) {
-        return new Intent(context, PlatformAlarmReceiver.class).putExtra(EXTRA_JOB_ID, jobId);
+    /*package*/ static Intent createIntent(Context context, int jobId, boolean exact, @Nullable Bundle transientExtras) {
+        Intent intent = new Intent(context, PlatformAlarmReceiver.class).putExtra(EXTRA_JOB_ID, jobId).putExtra(EXTRA_JOB_EXACT, exact);
+        if (transientExtras != null) {
+            intent.putExtra(EXTRA_TRANSIENT_EXTRAS, transientExtras);
+        }
+        return intent;
     }
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        if (intent == null || !intent.hasExtra(EXTRA_JOB_ID)) {
-            return;
-        }
+        if (intent != null && intent.hasExtra(EXTRA_JOB_ID) && intent.hasExtra(EXTRA_JOB_EXACT)) {
+            int jobId = intent.getIntExtra(EXTRA_JOB_ID, -1);
+            Bundle transientExtras = intent.getBundleExtra(EXTRA_TRANSIENT_EXTRAS);
 
-        Intent serviceIntent = PlatformAlarmService.createIntent(context, intent.getIntExtra(EXTRA_JOB_ID, -1));
-        JobProxy.Common.startWakefulService(context, serviceIntent);
+            if (intent.getBooleanExtra(EXTRA_JOB_EXACT, false)) {
+                Intent serviceIntent = PlatformAlarmServiceExact.createIntent(context, jobId, transientExtras);
+                JobProxy.Common.startWakefulService(context, serviceIntent);
+            } else {
+                PlatformAlarmService.start(context, jobId, transientExtras);
+            }
+        }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
index 39fd3f8..819b03a 100644
--- a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java
@@ -28,110 +28,54 @@
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
-import android.os.IBinder;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.app.JobIntentService;
 
+import com.evernote.android.job.JobIdsInternal;
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
 
 import net.vrallev.android.cat.CatLog;
 
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
 /**
  * @author rwondratschek
  */
-public final class PlatformAlarmService extends Service {
+public final class PlatformAlarmService extends JobIntentService {
 
     private static final CatLog CAT = new JobCat("PlatformAlarmService");
 
-    /*package*/ static Intent createIntent(Context context, int jobId) {
-        Intent intent = new Intent(context, PlatformAlarmService.class);
+    public static void start(Context context, int jobId, @Nullable Bundle transientExtras) {
+        Intent intent = new Intent();
         intent.putExtra(PlatformAlarmReceiver.EXTRA_JOB_ID, jobId);
-        return intent;
-    }
-
-    private final Object mMonitor = new Object();
-
-    private volatile ExecutorService mExecutorService;
-    private volatile Set<Integer> mStartIds;
-    private volatile int mLastStartId;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        mExecutorService = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
-        mStartIds = new HashSet<>();
-    }
-
-    @Override
-    public int onStartCommand(@Nullable final Intent intent, int flags, final int startId) {
-        synchronized (mMonitor) {
-            mStartIds.add(startId);
-            mLastStartId = startId;
+        if (transientExtras != null) {
+            intent.putExtra(PlatformAlarmReceiver.EXTRA_TRANSIENT_EXTRAS, transientExtras);
         }
 
-        mExecutorService.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    runJob(intent);
-                } finally {
-                    // call here, our own wake lock could be acquired too late
-                    JobProxy.Common.completeWakefulIntent(intent);
-                    stopSelfIfNecessary(startId);
-                }
-            }
-        });
-        return START_NOT_STICKY;
+        enqueueWork(context, PlatformAlarmService.class, JobIdsInternal.JOB_ID_PLATFORM_ALARM_SERVICE, intent);
     }
 
     @Override
-    public void onDestroy() {
-        mExecutorService.shutdown();
-        mExecutorService = null;
-
-        synchronized (mMonitor) {
-            mStartIds = null;
-            mLastStartId = 0;
-        }
-    }
-
-    @Override
-    public final IBinder onBind(Intent intent) {
-        return null;
+    protected void onHandleWork(@NonNull Intent intent) {
+        runJob(intent, this, CAT);
     }
 
-    private void runJob(Intent intent) {
+    /*package*/ static void runJob(@Nullable Intent intent, @NonNull Service service, @NonNull CatLog cat) {
         if (intent == null) {
-            CAT.i("Delivered intent is null");
+            cat.i("Delivered intent is null");
             return;
         }
 
         int jobId = intent.getIntExtra(PlatformAlarmReceiver.EXTRA_JOB_ID, -1);
-        final JobProxy.Common common = new JobProxy.Common(this, CAT, jobId);
+        Bundle transientExtras = intent.getBundleExtra(PlatformAlarmReceiver.EXTRA_TRANSIENT_EXTRAS);
+        final JobProxy.Common common = new JobProxy.Common(service, cat, jobId);
 
         // create the JobManager. Seeing sometimes exceptions, that it wasn't created, yet.
         final JobRequest request = common.getPendingRequest(true, true);
         if (request != null) {
-            common.executeJobRequest(request);
-        }
-    }
-
-    private void stopSelfIfNecessary(int startId) {
-        synchronized (mMonitor) {
-            Set<Integer> startIds = mStartIds;
-            if (startIds != null) {
-                // service not destroyed
-                startIds.remove(startId);
-                if (startIds.isEmpty()) {
-                    stopSelfResult(mLastStartId);
-                }
-            }
+            common.executeJobRequest(request, transientExtras);
         }
     }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmServiceExact.java b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmServiceExact.java
new file mode 100644
index 0000000..b7593a0
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmServiceExact.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job.v14;
+
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.JobProxy;
+import com.evernote.android.job.util.JobCat;
+
+import net.vrallev.android.cat.CatLog;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * @author rwondratschek
+ */
+public final class PlatformAlarmServiceExact extends Service {
+
+    private static final CatLog CAT = new JobCat("PlatformAlarmServiceExact");
+
+    public static Intent createIntent(Context context, int jobId, @Nullable Bundle transientExtras) {
+        Intent intent = new Intent(context, PlatformAlarmServiceExact.class);
+        intent.putExtra(PlatformAlarmReceiver.EXTRA_JOB_ID, jobId);
+        if (transientExtras != null) {
+            intent.putExtra(PlatformAlarmReceiver.EXTRA_TRANSIENT_EXTRAS, transientExtras);
+        }
+        return intent;
+    }
+
+    private final Object mMonitor = new Object();
+
+    private volatile ExecutorService mExecutorService;
+    private volatile Set<Integer> mStartIds;
+    private volatile int mLastStartId;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mExecutorService = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
+        mStartIds = new HashSet<>();
+    }
+
+    @Override
+    public int onStartCommand(@Nullable final Intent intent, int flags, final int startId) {
+        synchronized (mMonitor) {
+            mStartIds.add(startId);
+            mLastStartId = startId;
+        }
+
+        mExecutorService.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    PlatformAlarmService.runJob(intent, PlatformAlarmServiceExact.this, CAT);
+                } finally {
+                    // call here, our own wake lock could be acquired too late
+                    JobProxy.Common.completeWakefulIntent(intent);
+                    stopSelfIfNecessary(startId);
+                }
+            }
+        });
+        return START_NOT_STICKY;
+    }
+
+    @Override
+    public void onDestroy() {
+        mExecutorService.shutdown();
+        mExecutorService = null;
+
+        synchronized (mMonitor) {
+            mStartIds = null;
+            mLastStartId = 0;
+        }
+    }
+
+    @Override
+    public final IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    private void stopSelfIfNecessary(int startId) {
+        synchronized (mMonitor) {
+            Set<Integer> startIds = mStartIds;
+            if (startIds != null) {
+                // service not destroyed
+                startIds.remove(startId);
+                if (startIds.isEmpty()) {
+                    stopSelfResult(mLastStartId);
+                }
+            }
+        }
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
index 0884ff1..70d5d0f 100644
--- a/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
+++ b/library/src/main/java/com/evernote/android/job/v21/JobProxy21.java
@@ -32,6 +32,7 @@
 import android.content.Context;
 import android.os.Build;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.evernote.android.job.JobProxy;
 import com.evernote.android.job.JobProxyIllegalStateException;
@@ -79,7 +80,7 @@ public void plantOneOff(JobRequest request) {
             scheduleResult = schedule(jobInfo);
         }
 
-        mCat.d("Schedule one-off jobInfo %s, %s, start %s, end %s, reschedule count %d", scheduleResultToString(scheduleResult),
+        mCat.d("Schedule one-off jobInfo %s, %s, start %s, end %s (from now), reschedule count %d", scheduleResultToString(scheduleResult),
                 request, JobUtil.timeToString(startMs), JobUtil.timeToString(endMs), Common.getRescheduleCount(request));
     }
 
@@ -125,6 +126,8 @@ public void cancel(int jobId) {
             // https://gist.github.com/vRallev/5d48a4a8e8d05067834e
             mCat.e(e);
         }
+
+        TransientBundleCompat.cancel(mContext, jobId, null);
     }
 
     @Override
@@ -143,9 +146,8 @@ public boolean isPlatformJobScheduled(JobRequest request) {
             return false;
         }
 
-        int requestId = request.getJobId();
         for (JobInfo info : pendingJobs) {
-            if (info.getId() == requestId) {
+            if (isJobInfoScheduled(info, request)) {
                 return true;
             }
         }
@@ -153,12 +155,23 @@ public boolean isPlatformJobScheduled(JobRequest request) {
         return false;
     }
 
+    @SuppressWarnings("SimplifiableIfStatement")
+    protected boolean isJobInfoScheduled(@Nullable JobInfo info, @NonNull JobRequest request) {
+        boolean correctInfo = info != null && info.getId() == request.getJobId();
+        if (!correctInfo) {
+            return false;
+        }
+        return !request.isTransient() || TransientBundleCompat.isScheduled(mContext, request.getJobId());
+    }
+
     protected JobInfo.Builder createBaseBuilder(JobRequest request, boolean allowPersisting) {
-        return new JobInfo.Builder(request.getJobId(), new ComponentName(mContext, PlatformJobService.class))
+        JobInfo.Builder builder = new JobInfo.Builder(request.getJobId(), new ComponentName(mContext, PlatformJobService.class))
                 .setRequiresCharging(request.requiresCharging())
                 .setRequiresDeviceIdle(request.requiresDeviceIdle())
                 .setRequiredNetworkType(convertNetworkType(request.requiredNetworkType()))
-                .setPersisted(allowPersisting && request.isPersisted());
+                .setPersisted(allowPersisting && !request.isTransient() && JobUtil.hasBootPermission(mContext));
+
+        return setTransientBundle(request, builder);
     }
 
     protected JobInfo.Builder createBuilderOneOff(JobInfo.Builder builder, long startMs, long endMs) {
@@ -169,6 +182,14 @@ public boolean isPlatformJobScheduled(JobRequest request) {
         return builder.setPeriodic(intervalMs);
     }
 
+    protected JobInfo.Builder setTransientBundle(JobRequest request, JobInfo.Builder builder) {
+        if (request.isTransient()) {
+            TransientBundleCompat.persistBundle(mContext, request);
+        }
+
+        return builder;
+    }
+
     protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
         switch (networkType) {
             case ANY:
@@ -179,6 +200,8 @@ protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
                 return JobInfo.NETWORK_TYPE_UNMETERED;
             case NOT_ROAMING:
                 return JobInfo.NETWORK_TYPE_UNMETERED; // use unmetered here, is overwritten in v24
+            case METERED:
+                return JobInfo.NETWORK_TYPE_ANY; // use any here as fallback
             default:
                 throw new IllegalStateException("not implemented");
         }
diff --git a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
index aa62bb2..2748da1 100644
--- a/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
+++ b/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java
@@ -29,6 +29,7 @@
 import android.app.job.JobParameters;
 import android.app.job.JobService;
 import android.os.Build;
+import android.os.Bundle;
 
 import com.evernote.android.job.Job;
 import com.evernote.android.job.JobManager;
@@ -36,7 +37,7 @@
 import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobCat;
 
-import net.vrallev.android.cat.CatLog;
+import net.vrallev.android.cat.Cat;
 
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -51,7 +52,7 @@
      * JobScheduler can have issues: http://stackoverflow.com/questions/32079407/android-jobscheduler-onstartjob-called-multiple-times
      */
 
-    private static final CatLog CAT = new JobCat("PlatformJobService");
+    private static final JobCat CAT = new JobCat("PlatformJobService");
     private static final ExecutorService EXECUTOR_SERVICE = Executors.newCachedThreadPool(JobProxy.Common.COMMON_THREAD_FACTORY);
 
     @Override
@@ -59,16 +60,33 @@ public boolean onStartJob(final JobParameters params) {
         final int jobId = params.getJobId();
         final JobProxy.Common common = new JobProxy.Common(this, CAT, jobId);
 
-        final JobRequest request = common.getPendingRequest(true, true);
+        // don't mark starting!
+        final JobRequest request = common.getPendingRequest(true, false);
         if (request == null) {
             return false;
         }
 
+        if (request.isTransient()) {
+            if (TransientBundleCompat.startWithTransientBundle(this, request)) {
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                    // should only happen during testing if an API is disabled
+                    Cat.d("PendingIntent for transient bundle is not null although running on O, using compat mode, request %s", request);
+                }
+                return false;
+
+            } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+                CAT.d("PendingIntent for transient job %s expired", request);
+                return false;
+            }
+        }
+
+        common.markStarting(request);
+
         EXECUTOR_SERVICE.execute(new Runnable() {
             @Override
             public void run() {
                 try {
-                    common.executeJobRequest(request);
+                    common.executeJobRequest(request, getTransientBundle(params));
 
                 } finally {
                     // do not reschedule
@@ -95,4 +113,13 @@ public boolean onStopJob(JobParameters params) {
         // do not reschedule
         return false;
     }
+
+    @TargetApi(Build.VERSION_CODES.O)
+    private Bundle getTransientBundle(JobParameters params) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            return params.getTransientExtras();
+        } else {
+            return Bundle.EMPTY;
+        }
+    }
 }
diff --git a/library/src/main/java/com/evernote/android/job/v21/TransientBundleCompat.java b/library/src/main/java/com/evernote/android/job/v21/TransientBundleCompat.java
new file mode 100644
index 0000000..96f44f0
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/v21/TransientBundleCompat.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job.v21;
+
+import android.annotation.TargetApi;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.v14.PlatformAlarmServiceExact;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Dirty workaround. We schedule an alarm with the AlarmManager really far in the future.
+ * The job will still be started by the JobScheduler, but executed by the PlatformAlarmService
+ * with the help of the PendingIntent, because the PendingIntent holds the transient Bundle.
+ *
+ * If the PendingIntent is gone, that means our transient state is lost.
+ *
+ * Created by rwondratschek on 01.05.17.
+ */
+@SuppressWarnings("WeakerAccess")
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+/*package*/ final class TransientBundleCompat {
+
+    private static final JobCat CAT = new JobCat("TransientBundleCompat");
+
+    private TransientBundleCompat() {
+        throw new UnsupportedOperationException();
+    }
+
+    public static void persistBundle(@NonNull Context context, @NonNull JobRequest request) {
+        Intent intent = PlatformAlarmServiceExact.createIntent(context, request.getJobId(), request.getTransientExtras());
+        PendingIntent pendingIntent = PendingIntent.getService(context, request.getJobId(), intent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        long when = System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1000);
+
+        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+        alarmManager.setExact(AlarmManager.RTC, when, pendingIntent);
+    }
+
+    public static boolean startWithTransientBundle(@NonNull Context context, @NonNull JobRequest request) {
+        // transientExtras are not necessary in this case
+        Intent intent = PlatformAlarmServiceExact.createIntent(context, request.getJobId(), null);
+        PendingIntent pendingIntent = PendingIntent.getService(context, request.getJobId(), intent, PendingIntent.FLAG_NO_CREATE);
+
+        if (pendingIntent == null) {
+            return false;
+        }
+
+        try {
+            CAT.i("Delegating transient job %s to API 14", request);
+            pendingIntent.send();
+        } catch (PendingIntent.CanceledException e) {
+            CAT.e(e);
+            return false;
+        }
+
+        if (!request.isPeriodic()) {
+            cancel(context, request.getJobId(), pendingIntent);
+        }
+
+        return true;
+    }
+
+    public static boolean isScheduled(Context context, int jobId) {
+        Intent intent = PlatformAlarmServiceExact.createIntent(context, jobId, null);
+        return PendingIntent.getService(context, jobId, intent, PendingIntent.FLAG_NO_CREATE) != null;
+    }
+
+    public static void cancel(@NonNull Context context, int jobId, @Nullable PendingIntent pendingIntent) {
+        try {
+            if (pendingIntent == null) {
+                Intent intent = PlatformAlarmServiceExact.createIntent(context, jobId, null);
+                pendingIntent = PendingIntent.getService(context, jobId, intent, PendingIntent.FLAG_NO_CREATE);
+
+                if (pendingIntent == null) {
+                    return;
+                }
+            }
+
+            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+            alarmManager.cancel(pendingIntent);
+
+            pendingIntent.cancel();
+        } catch (Exception e) {
+            CAT.e(e); // we don't care if it fails, we don't want to crash the library
+        }
+    }
+}
diff --git a/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java b/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java
index 14f6785..d34ff26 100644
--- a/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java
+++ b/library/src/main/java/com/evernote/android/job/v24/JobProxy24.java
@@ -44,7 +44,11 @@
     private static final String TAG = "JobProxy24";
 
     public JobProxy24(Context context) {
-        super(context, TAG);
+        this(context, TAG);
+    }
+
+    public JobProxy24(Context context, String tag) {
+        super(context, tag);
     }
 
     @Override
@@ -56,7 +60,7 @@ public void plantPeriodicFlexSupport(JobRequest request) {
     @Override
     public boolean isPlatformJobScheduled(JobRequest request) {
         try {
-            return getJobScheduler().getPendingJob(request.getJobId()) != null;
+            return isJobInfoScheduled(getJobScheduler().getPendingJob(request.getJobId()), request);
         } catch (Exception e) {
             mCat.e(e);
             return false;
diff --git a/library/src/main/java/com/evernote/android/job/v26/JobProxy26.java b/library/src/main/java/com/evernote/android/job/v26/JobProxy26.java
new file mode 100644
index 0000000..5bdee1b
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/v26/JobProxy26.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2007-present Evernote Corporation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.evernote.android.job.v26;
+
+import android.annotation.TargetApi;
+import android.app.job.JobInfo;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.evernote.android.job.JobRequest;
+import com.evernote.android.job.v24.JobProxy24;
+
+
+/**
+ * @author rwondratschek
+ */
+@SuppressWarnings("unused")
+@TargetApi(Build.VERSION_CODES.O)
+public class JobProxy26 extends JobProxy24 {
+
+    private static final String TAG = "JobProxy26";
+
+    public JobProxy26(Context context) {
+        super(context, TAG);
+    }
+
+    public JobProxy26(Context context, String tag) {
+        super(context, tag);
+    }
+
+    @Override
+    protected JobInfo.Builder setTransientBundle(JobRequest request, JobInfo.Builder builder) {
+        return builder.setTransientExtras(request.getTransientExtras());
+    }
+
+    @Override
+    protected boolean isJobInfoScheduled(@Nullable JobInfo info, @NonNull JobRequest request) {
+        return info != null && info.getId() == request.getJobId();
+    }
+
+    @Override
+    protected JobInfo.Builder createBaseBuilder(JobRequest request, boolean allowPersisting) {
+        return super.createBaseBuilder(request, allowPersisting)
+                .setRequiresBatteryNotLow(request.requiresBatteryNotLow())
+                .setRequiresStorageNotLow(request.requiresStorageNotLow());
+    }
+
+    @Override
+    protected int convertNetworkType(@NonNull JobRequest.NetworkType networkType) {
+        switch (networkType) {
+            case METERED:
+                return JobInfo.NETWORK_TYPE_METERED;
+            default:
+                return super.convertNetworkType(networkType);
+        }
+
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java b/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java
new file mode 100644
index 0000000..e141aa3
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/BackoffCriteriaTests.java
@@ -0,0 +1,66 @@
+package com.evernote.android.job;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.app.job.JobWorkItem;
+import android.content.Context;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.test.TestClock;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class BackoffCriteriaTests extends BaseJobManagerTest {
+
+    @Test
+    public void verifyBackoffCriteriaIsAppliedForImmediatelyStartedJobs() {
+        JobConfig.setClock(new TestClock());
+
+        AlarmManager alarmManager = mock(AlarmManager.class);
+        JobScheduler jobScheduler = mock(JobScheduler.class);
+
+        doReturn(alarmManager).when(context()).getSystemService(eq(Context.ALARM_SERVICE));
+        doReturn(jobScheduler).when(context()).getSystemService(eq(Context.JOB_SCHEDULER_SERVICE));
+
+        int jobId = DummyJobs.createBuilder(DummyJobs.RescheduleJob.class)
+                .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
+                .startNow()
+                .build()
+                .schedule();
+
+        // this uses the JobIntentService under the hood, so verify that the JobScheduler was used for Android O and above
+        verify(jobScheduler).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        jobId = manager().getAllJobRequests().iterator().next().getJobId(); // because the job was rescheduled and its ID changed
+
+        // make sure that this method was not called again, because with the backoff criteria we have a delay
+        verify(jobScheduler, times(1)).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+
+        // instead the AlarmManager should be used
+        verify(alarmManager).setExactAndAllowWhileIdle(anyInt(), eq(5_000L), any(PendingIntent.class));
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+        verify(jobScheduler, times(1)).enqueue(any(JobInfo.class), any(JobWorkItem.class));
+        verify(alarmManager).setExactAndAllowWhileIdle(anyInt(), eq(10_000L), any(PendingIntent.class));
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
index f1f1270..4dd00fe 100644
--- a/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java
@@ -9,7 +9,7 @@
 import android.test.mock.MockContext;
 
 import com.evernote.android.job.test.DummyJobs;
-import com.evernote.android.job.test.TestCat;
+import com.evernote.android.job.test.TestLogger;
 
 import org.junit.Rule;
 import org.robolectric.RuntimeEnvironment;
@@ -33,6 +33,7 @@
 /**
  * @author rwondratschek
  */
+@SuppressWarnings("WeakerAccess")
 public abstract class BaseJobManagerTest {
 
     @Rule
@@ -68,7 +69,6 @@ protected final JobManager createManager() {
         return JobManager.create(mockContext);
     }
 
-    @NonNull
     protected void executeJob(int jobId, @NonNull Job.Result expected) {
         try {
             executeJobAsync(jobId, expected).get(3, TimeUnit.SECONDS);
@@ -78,7 +78,7 @@ protected void executeJob(int jobId, @NonNull Job.Result expected) {
     }
 
     protected Future<Job.Result> executeJobAsync(int jobId, @NonNull final Job.Result expected) throws InterruptedException {
-        final JobProxy.Common common = new JobProxy.Common(context(), TestCat.INSTANCE, jobId);
+        final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
 
         final JobRequest pendingRequest = common.getPendingRequest(true, true);
         assertThat(pendingRequest).isNotNull();
@@ -91,7 +91,7 @@ protected void executeJob(int jobId, @NonNull Job.Result expected) {
             public Job.Result call() throws Exception {
                 latch.countDown();
 
-                Job.Result result = common.executeJobRequest(pendingRequest);
+                Job.Result result = common.executeJobRequest(pendingRequest, null);
                 assertThat(result).isEqualTo(expected);
                 assertThat(common.getPendingRequest(true, false)).isNull();
 
@@ -131,6 +131,7 @@ public static Context createMockContext() {
 
         Context context = spy(RuntimeEnvironment.application);
         when(context.getPackageManager()).thenReturn(packageManager);
+        when(context.getApplicationContext()).thenReturn(context);
 
         Context mockContext = mock(MockContext.class);
         when(mockContext.getApplicationContext()).thenReturn(context);
diff --git a/library/src/test/java/com/evernote/android/job/DailyJobTest.java b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
new file mode 100644
index 0000000..3b35b64
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
@@ -0,0 +1,217 @@
+package com.evernote.android.job;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.test.TestClock;
+import com.evernote.android.job.util.Clock;
+import com.evernote.android.job.util.support.PersistableBundleCompat;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+
+import java.util.Calendar;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class DailyJobTest extends BaseJobManagerTest {
+
+    @Test
+    public void verifyScheduleInNextHourMinute0() {
+        TestClock clock = new TestClock();
+        clock.setTime(20, 0);
+        verifyScheduleInNextHour(clock);
+    }
+
+    @Test
+    public void verifyScheduleInNextHourMinute57() {
+        TestClock clock = new TestClock();
+        clock.setTime(20, 57);
+        verifyScheduleInNextHour(clock);
+    }
+
+    private void verifyScheduleInNextHour(Clock clock) {
+        JobConfig.setClock(clock);
+
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(clock.currentTimeMillis());
+
+        int hour = calendar.get(Calendar.HOUR_OF_DAY);
+        int minute = calendar.get(Calendar.MINUTE);
+        long start = TimeUnit.HOURS.toMillis(hour + 1) + TimeUnit.MINUTES.toMillis(minute);
+        long end = start + TimeUnit.HOURS.toMillis(1);
+
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), start, end);
+
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+
+        JobRequest request = manager().getAllJobRequests().iterator().next();
+
+        assertThat(request.getStartMs()).isEqualTo(TimeUnit.HOURS.toMillis(1));
+        assertThat(request.getEndMs()).isEqualTo(TimeUnit.HOURS.toMillis(2));
+    }
+
+    @Test
+    public void verifyScheduleOverMidnight8pm() {
+        TestClock clock = new TestClock();
+        clock.setTime(20, 0);
+
+        verifyScheduleOverMidnight(clock);
+    }
+
+    @Test
+    public void verifyScheduleOverMidnightAtMidnight() {
+        TestClock clock = new TestClock();
+        clock.setTime(0, 0);
+
+        verifyScheduleOverMidnight(clock);
+    }
+
+    private void verifyScheduleOverMidnight(Clock clock) {
+        JobConfig.setClock(clock);
+
+        long start = TimeUnit.HOURS.toMillis(24) - 1L;
+        long end = 1L;
+
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), start, end);
+
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+        JobRequest request = manager().getAllJobRequests().iterator().next();
+
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(clock.currentTimeMillis());
+        int hour = calendar.get(Calendar.HOUR_OF_DAY);
+
+        long maxStart = TimeUnit.HOURS.toMillis(24 - hour);
+        assertThat(request.getStartMs()).isLessThan(maxStart);
+        assertThat(request.getEndMs()).isLessThan(maxStart + 3);
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionInFuture() {
+        TestClock clock = new TestClock();
+        clock.setTime(0, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(2),  TimeUnit.HOURS.toMillis(6));
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionInPast() {
+        TestClock clock = new TestClock();
+        clock.setTime(12, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(2),  TimeUnit.HOURS.toMillis(6));
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionStartInPast() {
+        TestClock clock = new TestClock();
+        clock.setTime(4, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(2),  TimeUnit.HOURS.toMillis(6));
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionExactStart() {
+        TestClock clock = new TestClock();
+        clock.setTime(13, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(13),  TimeUnit.HOURS.toMillis(14));
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionExactEnd() {
+        TestClock clock = new TestClock();
+        clock.setTime(14, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(13),  TimeUnit.HOURS.toMillis(14));
+    }
+
+    @Test
+    public void verifyScheduleAndExecutionOverMidnight() {
+        TestClock clock = new TestClock();
+        clock.setTime(0, 0);
+
+        verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(23),  TimeUnit.HOURS.toMillis(6));
+    }
+
+    private void verifyExecutionAndSuccessfulReschedule(Clock clock, long start, long end) {
+        JobConfig.setClock(clock);
+
+        int jobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessDailyJob.class), start, end);
+        assertThat(jobId).isEqualTo(1);
+
+        executeJob(jobId, Job.Result.SUCCESS);
+
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+        assertThat(manager().getJobRequest(jobId + 1)).isNotNull();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void verifyTooLargeValue() {
+        long start = TimeUnit.HOURS.toMillis(24);
+        long end = 1L;
+
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), start, end);
+    }
+
+    @Test
+    public void verifyScheduledAtMidnight() {
+        long start = 0;
+        long end = 1L;
+
+        DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), start, end);
+        assertThat(manager().getAllJobRequests()).hasSize(1);
+    }
+
+    @Test
+    public void verifyHasExtras() {
+        long start = 0;
+        long end = 1L;
+
+        int jobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), start, end);
+        JobRequest request = manager().getJobRequest(jobId);
+
+        assertThat(request).isNotNull();
+        assertThat(request.getExtras().getLong(DailyJob.EXTRA_START_MS, -1)).isEqualTo(0L);
+        assertThat(request.getExtras().getLong(DailyJob.EXTRA_END_MS, -1)).isEqualTo(1L);
+        assertThat(request.getExtras().size()).isEqualTo(2);
+    }
+
+    @Test
+    public void verifyExtraValuesAreOverwritten() {
+        long start = 0;
+        long end = 1L;
+
+        PersistableBundleCompat extras = new PersistableBundleCompat();
+        extras.putLong("something", 9L); // make sure this value is not overwritten
+        extras.putLong(DailyJob.EXTRA_START_MS, 9L); // make sure they're overwritten
+        extras.putLong(DailyJob.EXTRA_END_MS, 9L);
+
+        int jobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class).setExtras(extras), start, end);
+        JobRequest request = manager().getJobRequest(jobId);
+
+        assertThat(request).isNotNull();
+        assertThat(request.getExtras().getLong(DailyJob.EXTRA_START_MS, -1)).isEqualTo(0L);
+        assertThat(request.getExtras().getLong(DailyJob.EXTRA_END_MS, -1)).isEqualTo(1L);
+        assertThat(request.getExtras().size()).isEqualTo(3);
+    }
+
+    @Test
+    public void verifyDailyJobIsNotExact() {
+        long time = 1L;
+
+        int jobId = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessJob.class), time, time);
+        JobRequest request = manager().getJobRequest(jobId);
+
+        assertThat(request).isNotNull();
+        assertThat(request.isExact()).isFalse();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java b/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java
index 6607bea..3fcaa53 100644
--- a/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java
+++ b/library/src/test/java/com/evernote/android/job/DatabaseExistingTest.java
@@ -37,6 +37,21 @@ public void upgradeFromV3() {
         testDatabase("evernote_jobs_v3.db");
     }
 
+    @Test
+    public void upgradeFromV4() {
+        testDatabase("evernote_jobs_v4.db");
+    }
+
+    @Test
+    public void upgradeFromV5() {
+        testDatabase("evernote_jobs_v5.db");
+    }
+
+    @Test
+    public void upgradeFromV6() {
+        testDatabase("evernote_jobs_v6.db");
+    }
+
     private void testDatabase(String name) {
         String filePath = getClass().getResource("/databases/" + name).getPath();
         assertThat(new File(filePath).exists()).isTrue();
@@ -64,9 +79,9 @@ private void testDatabase(String name) {
         assertThat(oneOff).isEqualTo(10);
         assertThat(periodic).isEqualTo(10);
 
-        // none of them should be transient
+        // none of them should be started
         for (JobRequest request : requests) {
-            assertThat(request.isTransient()).isFalse();
+            assertThat(request.isStarted()).isFalse();
         }
 
         for (JobRequest request : requests) {
diff --git a/library/src/test/java/com/evernote/android/job/DatabaseFailureTest.java b/library/src/test/java/com/evernote/android/job/DatabaseFailureTest.java
index 866f460..24c1bd3 100644
--- a/library/src/test/java/com/evernote/android/job/DatabaseFailureTest.java
+++ b/library/src/test/java/com/evernote/android/job/DatabaseFailureTest.java
@@ -138,7 +138,6 @@ public void run() {
         }.start();
         latch.await(3, TimeUnit.SECONDS);
 
-        assertThat(manager().getJobStorage().getFailedDeleteIds()).isEmpty();
-
+        assertThat(manager.getJobStorage().getFailedDeleteIds()).isEmpty();
     }
 }
diff --git a/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
index 449e9e6..3ceba46 100644
--- a/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
+++ b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.support.annotation.NonNull;
 
 import com.evernote.android.job.test.JobRobolectricTestRunner;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
@@ -25,13 +26,16 @@
 import static com.evernote.android.job.JobStorage.COLUMN_FLEX_SUPPORT;
 import static com.evernote.android.job.JobStorage.COLUMN_ID;
 import static com.evernote.android.job.JobStorage.COLUMN_INTERVAL_MS;
+import static com.evernote.android.job.JobStorage.COLUMN_LAST_RUN;
 import static com.evernote.android.job.JobStorage.COLUMN_NETWORK_TYPE;
 import static com.evernote.android.job.JobStorage.COLUMN_NUM_FAILURES;
-import static com.evernote.android.job.JobStorage.COLUMN_PERSISTED;
 import static com.evernote.android.job.JobStorage.COLUMN_REQUIREMENTS_ENFORCED;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_BATTERY_NOT_LOW;
 import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_CHARGING;
 import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_DEVICE_IDLE;
+import static com.evernote.android.job.JobStorage.COLUMN_REQUIRES_STORAGE_NOT_LOW;
 import static com.evernote.android.job.JobStorage.COLUMN_SCHEDULED_AT;
+import static com.evernote.android.job.JobStorage.COLUMN_STARTED;
 import static com.evernote.android.job.JobStorage.COLUMN_START_MS;
 import static com.evernote.android.job.JobStorage.COLUMN_TAG;
 import static com.evernote.android.job.JobStorage.COLUMN_TRANSIENT;
@@ -44,10 +48,11 @@
  */
 @RunWith(JobRobolectricTestRunner.class)
 @FixMethodOrder(MethodSorters.JVM)
+@SuppressWarnings("unused")
 public class DatabaseManualUpgradeTest extends BaseJobManagerTest {
 
     @Test
-    public void testDatabaseUpgrade1to4() {
+    public void testDatabaseUpgrade1to6() {
         Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
@@ -59,7 +64,7 @@ public void testDatabaseUpgrade1to4() {
     }
 
     @Test
-    public void testDatabaseUpgrade2to4() {
+    public void testDatabaseUpgrade2to6() {
         Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
@@ -71,7 +76,7 @@ public void testDatabaseUpgrade2to4() {
     }
 
     @Test
-    public void testDatabaseUpgrade3to4() {
+    public void testDatabaseUpgrade3to6() {
         Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
@@ -83,7 +88,31 @@ public void testDatabaseUpgrade3to4() {
     }
 
     @Test
-    public void testDatabaseUpgrade1to2to3to4() {
+    public void testDatabaseUpgrade4to6() {
+        Context context = RuntimeEnvironment.application;
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper4 openHelper = new JobOpenHelper4(context);
+        createDatabase(openHelper, false);
+        createJobs(openHelper, true);
+
+        checkJob();
+    }
+
+    @Test
+    public void testDatabaseUpgrade5to6() {
+        Context context = RuntimeEnvironment.application;
+        context.deleteDatabase(DATABASE_NAME);
+
+        JobOpenHelper5 openHelper = new JobOpenHelper5(context);
+        createDatabase(openHelper, false);
+        createJobs(openHelper, true);
+
+        checkJob();
+    }
+
+    @Test
+    public void testDatabaseUpgrade1to2to3to4to5to6() {
         Context context = RuntimeEnvironment.application;
         context.deleteDatabase(DATABASE_NAME);
 
@@ -93,6 +122,8 @@ public void testDatabaseUpgrade1to2to3to4() {
 
         createDatabase(new JobOpenHelper2(context), true);
         createDatabase(new JobOpenHelper3(context), true);
+        createDatabase(new JobOpenHelper4(context), true);
+        createDatabase(new JobOpenHelper5(context), true);
 
         checkJob();
     }
@@ -139,7 +170,7 @@ private void createJobs(UpgradeAbleJobOpenHelper openHelper, boolean validInterv
     private void checkJob() {
         createManager().addJobCreator(new JobCreator() {
             @Override
-            public Job create(String tag) {
+            public Job create(@NonNull String tag) {
                 return null;
             }
         });
@@ -149,18 +180,19 @@ public Job create(String tag) {
         JobRequest jobRequest = JobManager.instance().getJobRequest(1);
         assertThat(jobRequest.isPeriodic()).isFalse();
         assertThat(jobRequest.getStartMs()).isEqualTo(60_000L);
-        assertThat(jobRequest.isTransient()).isFalse();
+        assertThat(jobRequest.isStarted()).isFalse();
 
         jobRequest = JobManager.instance().getJobRequest(2);
         assertThat(jobRequest.isPeriodic()).isTrue();
         assertThat(jobRequest.getIntervalMs()).isEqualTo(JobRequest.MIN_INTERVAL);
         assertThat(jobRequest.getFlexMs()).isEqualTo(jobRequest.getIntervalMs());
-        assertThat(jobRequest.isTransient()).isFalse();
+        assertThat(jobRequest.isStarted()).isFalse();
 
         jobRequest = JobManager.instance().getJobRequest(3);
         assertThat(jobRequest.isPeriodic()).isTrue();
         assertThat(jobRequest.getIntervalMs()).isEqualTo(TimeUnit.MINUTES.toMillis(20));
         assertThat(jobRequest.getFlexMs()).isEqualTo(jobRequest.getIntervalMs());
+        assertThat(jobRequest.isStarted()).isFalse();
         assertThat(jobRequest.isTransient()).isFalse();
 
         JobManager.instance().cancelAll();
@@ -174,16 +206,16 @@ public Job create(String tag) {
 
         jobRequest = JobManager.instance().getJobRequest(jobId);
         assertThat(jobRequest).isNotNull();
-        assertThat(jobRequest.isTransient()).isFalse();
+        assertThat(jobRequest.isStarted()).isFalse();
 
-        jobRequest.setTransient(true);
+        jobRequest.setStarted(true);
         assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
-        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).hasSize(1);
+        assertThat(JobManager.instance().getAllJobRequests(null, true, true)).hasSize(1);
 
         JobManager.instance().cancelAll();
 
         assertThat(JobManager.instance().getAllJobRequests()).isEmpty();
-        assertThat(JobManager.instance().getJobStorage().getAllJobRequests(null, true)).isEmpty();
+        assertThat(JobManager.instance().getAllJobRequests(null, true, true)).isEmpty();
 
         JobManager.instance().destroy();
     }
@@ -193,8 +225,8 @@ public Job create(String tag) {
         private boolean mDatabaseCreated;
         private boolean mDatabaseUpgraded;
 
-        UpgradeAbleJobOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
-            super(context, name, factory, version);
+        UpgradeAbleJobOpenHelper(Context context, int version) {
+            super(context, DATABASE_NAME, null, version);
         }
 
         @Override
@@ -206,13 +238,57 @@ public final void onCreate(SQLiteDatabase db) {
         protected abstract void onCreateInner(SQLiteDatabase db);
 
         @Override
-        public final void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-            onUpgradeInner(sqLiteDatabase, oldVersion, newVersion);
+        public final void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            while (oldVersion < newVersion) {
+                switch (oldVersion) {
+                    case 1:
+                        upgradeFrom1To2(db);
+                        oldVersion++;
+                        break;
+                    case 2:
+                        upgradeFrom2To3(db);
+                        oldVersion++;
+                        break;
+                    case 3:
+                        upgradeFrom3To4(db);
+                        oldVersion++;
+                        break;
+                    case 4:
+                        upgradeFrom4To5(db);
+                        oldVersion++;
+                        break;
+                    case 5:
+                        upgradeFrom5To6(db);
+                        oldVersion++;
+                        break;
+                    default:
+                        throw new IllegalStateException("not implemented");
+                }
+            }
+
             mDatabaseCreated = true;
             mDatabaseUpgraded = true;
         }
 
-        protected abstract void onUpgradeInner(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion);
+        protected void upgradeFrom1To2(SQLiteDatabase db) {
+            // override me
+        }
+
+        protected void upgradeFrom2To3(SQLiteDatabase db) {
+            // override me
+        }
+
+        protected void upgradeFrom3To4(SQLiteDatabase db) {
+            // override me
+        }
+
+        protected void upgradeFrom4To5(SQLiteDatabase db) {
+            // override me
+        }
+
+        protected void upgradeFrom5To6(SQLiteDatabase db) {
+            // override me
+        }
 
         protected ContentValues createBaseContentValues(int id) {
             ContentValues contentValues = new ContentValues();
@@ -234,7 +310,7 @@ protected ContentValues createBaseContentValues(int id) {
             contentValues.put(JobStorage.COLUMN_NETWORK_TYPE, JobRequest.DEFAULT_NETWORK_TYPE.toString());
 
             contentValues.put(JobStorage.COLUMN_EXTRAS, new PersistableBundleCompat().saveToXml());
-            contentValues.put(JobStorage.COLUMN_PERSISTED, false);
+            contentValues.put("persisted", false);
 
             contentValues.put(JobStorage.COLUMN_NUM_FAILURES, 0);
             contentValues.put(JobStorage.COLUMN_SCHEDULED_AT, System.currentTimeMillis());
@@ -243,23 +319,18 @@ protected ContentValues createBaseContentValues(int id) {
         }
     }
 
-    private static final class JobOpenHelper1 extends UpgradeAbleJobOpenHelper {
+    private static class JobOpenHelper1 extends UpgradeAbleJobOpenHelper {
 
         JobOpenHelper1(Context context) {
-            super(context, DATABASE_NAME, null, 1);
+            this(context, 1);
         }
 
-        @Override
-        public void onCreateInner(SQLiteDatabase db) {
-            createJobTable(db);
+        JobOpenHelper1(Context context, int version) {
+            super(context, version);
         }
 
         @Override
-        public void onUpgradeInner(SQLiteDatabase db, int oldVersion, int newVersion) {
-            // not needed at the moment
-        }
-
-        private void createJobTable(SQLiteDatabase db) {
+        public void onCreateInner(SQLiteDatabase db) {
             db.execSQL("create table " + JOB_TABLE_NAME + " ("
                     + COLUMN_ID + " integer primary key, "
                     + COLUMN_TAG + " text not null, "
@@ -274,39 +345,68 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXACT + " integer, "
                     + COLUMN_NETWORK_TYPE + " text not null, "
                     + COLUMN_EXTRAS + " text, "
-                    + COLUMN_PERSISTED + " integer, "
+                    + "persisted" + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
                     + COLUMN_SCHEDULED_AT + " integer);");
         }
     }
 
-    private static final class JobOpenHelper2 extends UpgradeAbleJobOpenHelper {
+    private static class JobOpenHelper2 extends JobOpenHelper1 {
 
         JobOpenHelper2(Context context) {
-            super(context, DATABASE_NAME, null, 2);
+            this(context, 2);
         }
 
-        @Override
-        public void onCreateInner(SQLiteDatabase db) {
-            createJobTable(db);
+        JobOpenHelper2(Context context, int version) {
+            super(context, version);
         }
 
         @Override
-        public void onUpgradeInner(SQLiteDatabase db, int oldVersion, int newVersion) {
-            // with newer versions there should be a smarter way
-            if (oldVersion == 1 && newVersion == 2) {
-                upgradeFrom1To2(db);
-            }
+        public void onCreateInner(SQLiteDatabase db) {
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + "persisted" + " integer, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + "isTransient" + " integer);");
         }
 
         @Override
         protected ContentValues createBaseContentValues(int id) {
             ContentValues contentValues = super.createBaseContentValues(id);
-            contentValues.put(JobStorage.COLUMN_TRANSIENT, false);
+            contentValues.put("isTransient", false);
             return contentValues;
         }
 
-        private void createJobTable(SQLiteDatabase db) {
+        protected void upgradeFrom1To2(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + "isTransient" + " integer;");
+        }
+    }
+
+    private static class JobOpenHelper3 extends JobOpenHelper2 {
+
+        JobOpenHelper3(Context context) {
+            this(context, 3);
+        }
+
+        JobOpenHelper3(Context context, int version) {
+            super(context, version);
+        }
+
+        @Override
+        public void onCreateInner(SQLiteDatabase db) {
             db.execSQL("create table " + JOB_TABLE_NAME + " ("
                     + COLUMN_ID + " integer primary key, "
                     + COLUMN_TAG + " text not null, "
@@ -321,47 +421,88 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXACT + " integer, "
                     + COLUMN_NETWORK_TYPE + " text not null, "
                     + COLUMN_EXTRAS + " text, "
-                    + COLUMN_PERSISTED + " integer, "
+                    + "persisted" + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
                     + COLUMN_SCHEDULED_AT + " integer, "
-                    + COLUMN_TRANSIENT + " integer);");
+                    + "isTransient" + " integer, "
+                    + COLUMN_FLEX_MS + " integer, "
+                    + COLUMN_FLEX_SUPPORT + " integer);");
         }
 
-        private void upgradeFrom1To2(SQLiteDatabase db) {
-            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+        protected void upgradeFrom2To3(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_MS + " integer;");
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_SUPPORT + " integer;");
+
+            // adjust interval to minimum value if necessary
+            ContentValues contentValues = new ContentValues();
+            contentValues.put(COLUMN_INTERVAL_MS, JobRequest.MIN_INTERVAL);
+            db.update(JOB_TABLE_NAME, contentValues, COLUMN_INTERVAL_MS + ">0 AND " + COLUMN_INTERVAL_MS + "<" + JobRequest.MIN_INTERVAL, new String[0]);
+
+            // copy interval into flex column, that's the default value and the flex support mode is not required
+            db.execSQL("update " + JOB_TABLE_NAME + " set " + COLUMN_FLEX_MS + " = " + COLUMN_INTERVAL_MS + ";");
         }
     }
 
-    private static final class JobOpenHelper3 extends UpgradeAbleJobOpenHelper {
+    private static class JobOpenHelper4 extends JobOpenHelper3 {
 
-        JobOpenHelper3(Context context) {
-            super(context, DATABASE_NAME, null, 3);
+        JobOpenHelper4(Context context) {
+            this(context, 4);
+        }
+
+        JobOpenHelper4(Context context, int version) {
+            super(context, version);
         }
 
         @Override
         public void onCreateInner(SQLiteDatabase db) {
-            createJobTable(db);
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + "persisted" + " integer, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + "isTransient" + " integer, "
+                    + COLUMN_FLEX_MS + " integer, "
+                    + COLUMN_FLEX_SUPPORT + " integer, "
+                    + COLUMN_LAST_RUN + " integer);");
+        }
+
+        protected void upgradeFrom3To4(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_LAST_RUN + " integer;");
+        }
+    }
+
+    private static class JobOpenHelper5 extends JobOpenHelper4 {
+
+        JobOpenHelper5(Context context) {
+            this(context, 5);
+        }
+
+        JobOpenHelper5(Context context, int version) {
+            super(context, version);
         }
 
         @Override
-        public void onUpgradeInner(SQLiteDatabase db, int oldVersion, int newVersion) {
-            while (oldVersion < newVersion) {
-                switch (oldVersion) {
-                    case 1:
-                        upgradeFrom1To2(db);
-                        oldVersion++;
-                        break;
-                    case 2:
-                        upgradeFrom2To3(db);
-                        oldVersion++;
-                        break;
-                    default:
-                        throw new IllegalStateException("not implemented");
-                }
-            }
+        protected ContentValues createBaseContentValues(int id) {
+            ContentValues values = super.createBaseContentValues(id);
+            values.remove("isTransient");
+            values.remove("persisted");
+            return values;
         }
 
-        private void createJobTable(SQLiteDatabase db) {
+        @Override
+        public void onCreateInner(SQLiteDatabase db) {
             db.execSQL("create table " + JOB_TABLE_NAME + " ("
                     + COLUMN_ID + " integer primary key, "
                     + COLUMN_TAG + " text not null, "
@@ -376,29 +517,119 @@ private void createJobTable(SQLiteDatabase db) {
                     + COLUMN_EXACT + " integer, "
                     + COLUMN_NETWORK_TYPE + " text not null, "
                     + COLUMN_EXTRAS + " text, "
-                    + COLUMN_PERSISTED + " integer, "
                     + COLUMN_NUM_FAILURES + " integer, "
                     + COLUMN_SCHEDULED_AT + " integer, "
-                    + COLUMN_TRANSIENT + " integer, "
+                    + COLUMN_STARTED + " integer, "
                     + COLUMN_FLEX_MS + " integer, "
-                    + COLUMN_FLEX_SUPPORT + " integer);");
+                    + COLUMN_FLEX_SUPPORT + " integer, "
+                    + COLUMN_LAST_RUN + " integer, "
+                    + COLUMN_TRANSIENT + " integer);");
         }
 
-        private void upgradeFrom1To2(SQLiteDatabase db) {
-            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+        @SuppressWarnings("deprecation")
+        @Override
+        protected void upgradeFrom4To5(SQLiteDatabase db) {
+            // remove "persisted" column and rename "isTransient" to "started", add "transient" column for O
+            try {
+                db.beginTransaction();
+
+                String newTable = JOB_TABLE_NAME + "_new";
+
+                db.execSQL("create table " + newTable + " ("
+                        + COLUMN_ID + " integer primary key, "
+                        + COLUMN_TAG + " text not null, "
+                        + COLUMN_START_MS + " integer, "
+                        + COLUMN_END_MS + " integer, "
+                        + COLUMN_BACKOFF_MS + " integer, "
+                        + COLUMN_BACKOFF_POLICY + " text not null, "
+                        + COLUMN_INTERVAL_MS + " integer, "
+                        + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                        + COLUMN_REQUIRES_CHARGING + " integer, "
+                        + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                        + COLUMN_EXACT + " integer, "
+                        + COLUMN_NETWORK_TYPE + " text not null, "
+                        + COLUMN_EXTRAS + " text, "
+                        + COLUMN_NUM_FAILURES + " integer, "
+                        + COLUMN_SCHEDULED_AT + " integer, "
+                        + COLUMN_STARTED + " integer, "
+                        + COLUMN_FLEX_MS + " integer, "
+                        + COLUMN_FLEX_SUPPORT + " integer, "
+                        + COLUMN_LAST_RUN + " integer);");
+
+                db.execSQL("INSERT INTO " + newTable + " SELECT "
+                        + COLUMN_ID + ","
+                        + COLUMN_TAG + ","
+                        + COLUMN_START_MS + ","
+                        + COLUMN_END_MS + ","
+                        + COLUMN_BACKOFF_MS + ","
+                        + COLUMN_BACKOFF_POLICY + ","
+                        + COLUMN_INTERVAL_MS + ","
+                        + COLUMN_REQUIREMENTS_ENFORCED + ","
+                        + COLUMN_REQUIRES_CHARGING + ","
+                        + COLUMN_REQUIRES_DEVICE_IDLE + ","
+                        + COLUMN_EXACT + ","
+                        + COLUMN_NETWORK_TYPE + ","
+                        + COLUMN_EXTRAS + ","
+                        + COLUMN_NUM_FAILURES + ","
+                        + COLUMN_SCHEDULED_AT + ","
+                        + "isTransient" + ","
+                        + COLUMN_FLEX_MS + ","
+                        + COLUMN_FLEX_SUPPORT + ","
+                        + COLUMN_LAST_RUN + " FROM " + JOB_TABLE_NAME);
+
+                db.execSQL("DROP TABLE " + JOB_TABLE_NAME);
+                db.execSQL("ALTER TABLE " + newTable + " RENAME TO " + JOB_TABLE_NAME);
+
+                db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_TRANSIENT + " integer;");
+
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
         }
+    }
 
-        private void upgradeFrom2To3(SQLiteDatabase db) {
-            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_MS + " integer;");
-            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_FLEX_SUPPORT + " integer;");
+    private static final class JobOpenHelper6 extends JobOpenHelper5 {
 
-            // adjust interval to minimum value if necessary
-            ContentValues contentValues = new ContentValues();
-            contentValues.put(COLUMN_INTERVAL_MS, JobRequest.MIN_INTERVAL);
-            db.update(JOB_TABLE_NAME, contentValues, COLUMN_INTERVAL_MS + ">0 AND " + COLUMN_INTERVAL_MS + "<" + JobRequest.MIN_INTERVAL, new String[0]);
+        JobOpenHelper6(Context context) {
+            this(context, 6);
+        }
 
-            // copy interval into flex column, that's the default value and the flex support mode is not required
-            db.execSQL("update " + JOB_TABLE_NAME + " set " + COLUMN_FLEX_MS + " = " + COLUMN_INTERVAL_MS + ";");
+        JobOpenHelper6(Context context, int version) {
+            super(context, version);
+        }
+
+        @Override
+        public void onCreateInner(SQLiteDatabase db) {
+            db.execSQL("create table " + JOB_TABLE_NAME + " ("
+                    + COLUMN_ID + " integer primary key, "
+                    + COLUMN_TAG + " text not null, "
+                    + COLUMN_START_MS + " integer, "
+                    + COLUMN_END_MS + " integer, "
+                    + COLUMN_BACKOFF_MS + " integer, "
+                    + COLUMN_BACKOFF_POLICY + " text not null, "
+                    + COLUMN_INTERVAL_MS + " integer, "
+                    + COLUMN_REQUIREMENTS_ENFORCED + " integer, "
+                    + COLUMN_REQUIRES_CHARGING + " integer, "
+                    + COLUMN_REQUIRES_DEVICE_IDLE + " integer, "
+                    + COLUMN_EXACT + " integer, "
+                    + COLUMN_NETWORK_TYPE + " text not null, "
+                    + COLUMN_EXTRAS + " text, "
+                    + COLUMN_NUM_FAILURES + " integer, "
+                    + COLUMN_SCHEDULED_AT + " integer, "
+                    + COLUMN_STARTED + " integer, "
+                    + COLUMN_FLEX_MS + " integer, "
+                    + COLUMN_FLEX_SUPPORT + " integer, "
+                    + COLUMN_LAST_RUN + " integer, "
+                    + COLUMN_TRANSIENT + " integer, "
+                    + COLUMN_REQUIRES_BATTERY_NOT_LOW + " integer, "
+                    + COLUMN_REQUIRES_STORAGE_NOT_LOW +" integer);");
+        }
+
+        @Override
+        protected void upgradeFrom5To6(SQLiteDatabase db) {
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_REQUIRES_BATTERY_NOT_LOW + " integer;");
+            db.execSQL("alter table " + JOB_TABLE_NAME + " add column " + COLUMN_REQUIRES_STORAGE_NOT_LOW + " integer;");
         }
     }
 }
diff --git a/library/src/test/java/com/evernote/android/job/JobConfigTest.java b/library/src/test/java/com/evernote/android/job/JobConfigTest.java
new file mode 100644
index 0000000..3fb8118
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobConfigTest.java
@@ -0,0 +1,161 @@
+package com.evernote.android.job;
+
+import android.os.Build;
+
+import com.evernote.android.job.test.DummyJobs;
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.annotation.Config;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobConfigTest extends BaseJobManagerTest {
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP)
+    public void verifyReset() {
+        assertThat(JobConfig.isApiEnabled(JobApi.V_19)).isTrue(); // default
+        JobConfig.setApiEnabled(JobApi.V_19, false);
+        assertThat(JobConfig.isApiEnabled(JobApi.V_19)).isFalse(); // did change
+
+        assertThat(JobConfig.isAllowSmallerIntervalsForMarshmallow()).isFalse(); // default
+        JobConfig.setAllowSmallerIntervalsForMarshmallow(true);
+        assertThat(JobConfig.isAllowSmallerIntervalsForMarshmallow()).isTrue(); // did change
+
+        JobConfig.reset();
+        assertThat(JobConfig.isApiEnabled(JobApi.V_19)).isTrue(); // default
+        assertThat(JobConfig.isAllowSmallerIntervalsForMarshmallow()).isFalse(); // default
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP)
+    public void verifyMinIntervalChanged() {
+        assertThat(JobRequest.getMinInterval()).isEqualTo(JobRequest.MIN_INTERVAL);
+        assertThat(JobRequest.getMinFlex()).isEqualTo(JobRequest.MIN_FLEX);
+
+        JobConfig.setAllowSmallerIntervalsForMarshmallow(true);
+
+        assertThat(JobRequest.getMinInterval()).isLessThan(JobRequest.MIN_INTERVAL);
+        assertThat(JobRequest.getMinFlex()).isLessThan(JobRequest.MIN_FLEX);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyMinIntervalCantBeChangedAfterN() {
+        JobConfig.setAllowSmallerIntervalsForMarshmallow(true);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.O)
+    public void verifyApi26Supported() {
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_26);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.N)
+    public void verifyApi24Supported() {
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_24);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP)
+    public void verifyApi21Supported() {
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_21);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.KITKAT)
+    public void verifyApi19Supported() {
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_19);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.O)
+    public void verifyApiDisabled() {
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_26);
+
+        JobConfig.setApiEnabled(JobApi.V_26, false);
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_24);
+
+        JobConfig.setApiEnabled(JobApi.V_24, false);
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_21);
+
+        JobConfig.setApiEnabled(JobApi.V_21, false);
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_19);
+
+        JobConfig.setApiEnabled(JobApi.V_19, false);
+        assertThat(JobApi.getDefault(context())).isEqualTo(JobApi.V_14);
+    }
+
+    @Test
+    public void verifyForceApiDisabledOtherApis() {
+        JobApi forcedApi = JobApi.GCM;
+        for (JobApi api : JobApi.values()) {
+            assertThat(JobConfig.isApiEnabled(api)).isTrue();
+        }
+
+        JobConfig.forceApi(forcedApi);
+
+        for (JobApi api : JobApi.values()) {
+            assertThat(JobConfig.isApiEnabled(api)).isEqualTo(api == forcedApi);
+        }
+    }
+
+    @Test
+    public void verifyJobIdOffset() {
+        assertThat(JobConfig.getJobIdOffset()).isEqualTo(0);
+        assertThat(manager().getJobStorage().getMaxJobId()).isEqualTo(0);
+
+        int jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        assertThat(jobId).isEqualTo(1);
+
+        JobConfig.setJobIdOffset(100);
+        assertThat(JobConfig.getJobIdOffset()).isEqualTo(100);
+
+        jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        assertThat(jobId).isEqualTo(101);
+
+        JobConfig.setJobIdOffset(0);
+        assertThat(JobConfig.getJobIdOffset()).isEqualTo(0);
+
+        jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        assertThat(jobId).isEqualTo(102);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void verifyJobIdOffsetUpperBound() {
+        JobConfig.setJobIdOffset(2147480000 - 500 + 1);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void verifyJobIdOffsetLowerBound() {
+        JobConfig.setJobIdOffset(-1);
+    }
+
+    @Test
+    public void verifyJobIdOffsetBounds() {
+        JobConfig.setJobIdOffset(0);
+        JobConfig.setJobIdOffset(2147480000 - 500);
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobCreatorHolderTest.java b/library/src/test/java/com/evernote/android/job/JobCreatorHolderTest.java
index e8afe5c..9963b1b 100644
--- a/library/src/test/java/com/evernote/android/job/JobCreatorHolderTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobCreatorHolderTest.java
@@ -1,8 +1,8 @@
 package com.evernote.android.job;
 
-import com.evernote.android.job.util.JobCat;
+import android.support.annotation.NonNull;
 
-import net.vrallev.android.cat.print.CatPrinter;
+import com.evernote.android.job.util.JobLogger;
 
 import org.junit.After;
 import org.junit.Before;
@@ -26,28 +26,27 @@
 
 @RunWith(MockitoJUnitRunner.class)
 public class JobCreatorHolderTest {
-    @Mock CatPrinter catPrinter;
+    @Mock JobLogger jobLogger;
     @Mock JobCreator mockJobCreator;
 
     private JobCreatorHolder holder;
 
     @Before
     public void setup() {
-        JobCat.addLogPrinter(catPrinter);
-
+        JobConfig.addLogger(jobLogger);
         holder = new JobCreatorHolder();
     }
 
     @After
     public void tearDown() {
-        JobCat.removeLogPrinter(catPrinter);
+        JobConfig.reset();
     }
 
     @Test
     public void createJobLogsWarningWhenNoCreatorsAreAdded() {
         holder.createJob("DOES_NOT_EXIST");
 
-        verify(catPrinter).println(
+        verify(jobLogger).log(
                 anyInt(),                  // priority
                 eq("JobCreatorHolder"),    // tag
                 eq("no JobCreator added"), // message
@@ -60,7 +59,7 @@ public void createJobLogsNothingWhenAtLeastOneCreatorIsAdded() {
 
         holder.createJob("DOES_NOT_EXIST");
 
-        verifyZeroInteractions(catPrinter);
+        verifyZeroInteractions(jobLogger);
     }
 
     @Test
@@ -91,7 +90,7 @@ public void createJobSucceedsWhenCreatorListIsModifiedConcurrently() {
 
         class BlockingJobCreator implements JobCreator {
             @Override
-            public Job create(String tag) {
+            public Job create(@NonNull String tag) {
                 lock.lock();
                 try {
                     isIteratorActive.set(true);
diff --git a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
index 7831ad3..45e5874 100644
--- a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
@@ -1,8 +1,11 @@
 package com.evernote.android.job;
 
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+
 import com.evernote.android.job.test.DummyJobs;
 import com.evernote.android.job.test.JobRobolectricTestRunner;
-import com.evernote.android.job.test.TestCat;
+import com.evernote.android.job.test.TestLogger;
 
 import org.junit.FixMethodOrder;
 import org.junit.Test;
@@ -11,6 +14,7 @@
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static org.assertj.core.api.Java6Assertions.assertThat;
 
@@ -25,7 +29,6 @@
     public void testPeriodicJob() throws Exception {
         int jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
                 .setPeriodic(TimeUnit.MINUTES.toMillis(15))
-                .setPersisted(true)
                 .build()
                 .schedule();
 
@@ -51,7 +54,7 @@ public void testSimpleJob() throws Throwable {
     }
 
     @Test
-    public void testTransientState() throws Throwable {
+    public void testStartedState() throws Throwable {
         int jobId = DummyJobs.createBuilder(DummyJobs.TwoSecondPauseJob.class)
                 .setExecutionWindow(300_000, 400_000)
                 .build()
@@ -62,14 +65,14 @@ public void testTransientState() throws Throwable {
         // wait until the job is started
         Thread.sleep(100);
 
-        // request should be in transient state, running but not removed from DB
-        JobRequest transientRequest = manager().getJobRequest(jobId, true);
-        assertThat(transientRequest).isNotNull();
-        assertThat(transientRequest.isTransient()).isTrue();
+        // request should be in started state, running but not removed from DB
+        JobRequest startedRequest = manager().getJobRequest(jobId, true);
+        assertThat(startedRequest).isNotNull();
+        assertThat(startedRequest.isStarted()).isTrue();
     }
 
     @Test
-    public void testPeriodicJobNotInTransientState() throws Throwable {
+    public void testPeriodicJobNotInStartedState() throws Throwable {
         int jobId = DummyJobs.createBuilder(DummyJobs.TwoSecondPauseJob.class)
                 .setPeriodic(TimeUnit.MINUTES.toMillis(15))
                 .build()
@@ -80,10 +83,10 @@ public void testPeriodicJobNotInTransientState() throws Throwable {
         // wait until the job is started
         Thread.sleep(100);
 
-        // request should be in transient state, running but not removed from DB
-        JobRequest transientRequest = manager().getJobRequest(jobId, true);
-        assertThat(transientRequest).isNotNull();
-        assertThat(transientRequest.isTransient()).isFalse();
+        // request should be in started state, running but not removed from DB
+        JobRequest startedRequest = manager().getJobRequest(jobId, true);
+        assertThat(startedRequest).isNotNull();
+        assertThat(startedRequest.isStarted()).isFalse();
     }
 
     @Test
@@ -93,7 +96,7 @@ public void verifyNoRaceConditionOneOff() throws Exception {
                 .build()
                 .schedule();
 
-        final JobProxy.Common common = new JobProxy.Common(context(), TestCat.INSTANCE, jobId);
+        final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
         final JobRequest request = common.getPendingRequest(true, true);
         assertThat(request).isNotNull();
 
@@ -107,7 +110,7 @@ public void run() {
                 } catch (InterruptedException ignored) {
                 }
 
-                common.executeJobRequest(request);
+                common.executeJobRequest(request, null);
                 latch.countDown();
             }
         }.start();
@@ -126,7 +129,7 @@ public void verifyNoRaceConditionPeriodic() throws Exception {
                 .build()
                 .schedule();
 
-        final JobProxy.Common common = new JobProxy.Common(context(), TestCat.INSTANCE, jobId);
+        final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
         final JobRequest request = common.getPendingRequest(true, true);
         assertThat(request).isNotNull();
 
@@ -140,7 +143,7 @@ public void run() {
                 } catch (InterruptedException ignored) {
                 }
 
-                common.executeJobRequest(request);
+                common.executeJobRequest(request, null);
                 latch.countDown();
             }
         }.start();
@@ -151,4 +154,90 @@ public void run() {
         Thread.sleep(2_000);
         assertThat(common.getPendingRequest(true, false)).isNotNull();
     }
+
+    @Test
+    public void verifyPendingRequestNullWhenMarkedStated() {
+        final int jobId = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setPeriodic(TimeUnit.MINUTES.toMillis(15))
+                .build()
+                .schedule();
+
+        final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
+
+        assertThat(common.getPendingRequest(true, false)).isNotNull();
+        assertThat(common.getPendingRequest(true, false)).isNotNull();
+
+        JobRequest request = common.getPendingRequest(true, false);
+        assertThat(request).isNotNull();
+
+        common.markStarting(request);
+        assertThat(common.getPendingRequest(true, false)).isNull();
+    }
+
+    @Test
+    public void verifyCanceledJobNotRescheduled() {
+        final AtomicBoolean onRescheduleCalled = new AtomicBoolean(false);
+        final Job job = new Job() {
+            @NonNull
+            @Override
+            protected Result onRunJob(Params params) {
+                manager().cancelAll();
+                return Result.RESCHEDULE;
+            }
+
+            @Override
+            protected void onReschedule(int newJobId) {
+                onRescheduleCalled.set(true);
+            }
+        };
+
+        JobCreator jobCreator = new JobCreator() {
+            @Override
+            public Job create(@NonNull String tag) {
+                return job;
+            }
+        };
+
+        manager().addJobCreator(jobCreator);
+
+        final String tag = "something";
+        final int jobId = new JobRequest.Builder(tag)
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        executeJob(jobId, Job.Result.RESCHEDULE);
+
+        assertThat(manager().getAllJobRequestsForTag(tag)).isEmpty();
+
+        assertThat(manager().getJobRequest(jobId)).isNull();
+        assertThat(manager().getJobRequest(jobId, true)).isNull();
+
+        assertThat(onRescheduleCalled.get()).isFalse();
+    }
+
+    @Test
+    public void verifyReschedulingTransientJobsWorks() throws Throwable {
+        Bundle extras = new Bundle();
+        extras.putString("key", "hello");
+
+        int previousJobId = DummyJobs.createBuilder(DummyJobs.RescheduleJob.class)
+                .setExecutionWindow(200_000L, 400_000L)
+                .setTransientExtras(extras)
+                .build()
+                .schedule();
+
+        for (int i = 0; i < 5; i++) {
+            executeJob(previousJobId, Job.Result.RESCHEDULE);
+
+            assertThat(manager().getAllJobRequestsForTag(DummyJobs.RescheduleJob.TAG)).hasSize(1);
+
+            JobRequest request = manager().getAllJobRequestsForTag(DummyJobs.RescheduleJob.TAG).iterator().next();
+            assertThat(request.getJobId()).isNotEqualTo(previousJobId);
+
+            assertThat(request.getTransientExtras().getString("key", null)).isEqualTo("hello");
+
+            previousJobId = request.getJobId();
+        }
+    }
 }
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerCreateTest.java b/library/src/test/java/com/evernote/android/job/JobManagerCreateTest.java
index 162765c..073bd6d 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerCreateTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerCreateTest.java
@@ -7,8 +7,6 @@
 import android.content.pm.ResolveInfo;
 import android.test.mock.MockContext;
 
-import com.evernote.android.job.util.JobApi;
-
 import org.junit.After;
 import org.junit.FixMethodOrder;
 import org.junit.Test;
@@ -32,10 +30,9 @@
 @FixMethodOrder(MethodSorters.JVM)
 public class JobManagerCreateTest {
 
-    @SuppressWarnings("deprecation")
     @After
     public void cleanup() {
-        JobApi.setForceAllowApi14(false);
+        JobConfig.setForceAllowApi14(false);
         try {
             JobManager.instance().destroy();
         } catch (Exception ignored) {
@@ -59,10 +56,9 @@ public void verifyCreateSuccessful() {
         JobManager.create(context);
     }
 
-    @SuppressWarnings("deprecation")
     @Test
     public void verifyForceAllowApi14() {
-        JobApi.setForceAllowApi14(true);
+        JobConfig.setForceAllowApi14(true);
 
         Context context = mockContext();
 
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerRule.java b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
index ca7a6ec..0b88ee8 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerRule.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerRule.java
@@ -3,8 +3,7 @@
 import android.content.Context;
 import android.support.annotation.NonNull;
 
-import com.evernote.android.job.test.TestCat;
-import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.test.TestLogger;
 
 import org.junit.rules.ExternalResource;
 
@@ -24,7 +23,9 @@ public JobManagerRule(@NonNull JobCreator jobCreator, @NonNull Context context)
 
     @Override
     protected void before() throws Throwable {
-        JobCat.addLogPrinter(TestCat.INSTANCE);
+        JobConfig.addLogger(TestLogger.INSTANCE);
+        JobConfig.setSkipJobReschedule(true);
+
         mManager = JobManager.create(mContext);
         mManager.addJobCreator(mJobCreator);
     }
@@ -33,7 +34,7 @@ protected void before() throws Throwable {
     protected void after() {
         mManager.cancelAll();
         mManager.destroy();
-        JobCat.removeLogPrinter(TestCat.INSTANCE);
+        JobConfig.reset();
     }
 
     public JobManager getJobManager() {
diff --git a/library/src/test/java/com/evernote/android/job/JobManagerTest.java b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
index a0b1297..d4f511c 100644
--- a/library/src/test/java/com/evernote/android/job/JobManagerTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobManagerTest.java
@@ -6,9 +6,7 @@
 
 import com.evernote.android.job.test.DummyJobs;
 import com.evernote.android.job.test.JobRobolectricTestRunner;
-import com.evernote.android.job.util.JobCat;
-
-import net.vrallev.android.cat.print.CatPrinter;
+import com.evernote.android.job.util.JobLogger;
 
 import org.junit.FixMethodOrder;
 import org.junit.Test;
@@ -118,11 +116,11 @@ public void testSimultaneousCancel() throws Exception {
         }
 
         // that sucks, but the storage can't be injected to verify it better
-        class TestPrinter implements CatPrinter {
+        class TestPrinter implements JobLogger {
             private final List<String> mMessages = new ArrayList<>();
 
             @Override
-            public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+            public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
                 if (message.endsWith("canceling")) {
                     mMessages.add(message);
                 }
@@ -130,7 +128,7 @@ public void println(int priority, @NonNull String tag, @NonNull String message,
         }
 
         TestPrinter testPrinter = new TestPrinter();
-        JobCat.addLogPrinter(testPrinter);
+        JobConfig.addLogger(testPrinter);
 
         for (int i = 0; i < jobCount; i++) {
             DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
@@ -251,4 +249,30 @@ public void testJobIdIncremented() throws Exception {
         // if something goes wrong with the pref file, use the highest value from the database
         assertThat(manager().getJobStorage().getMaxJobId()).isEqualTo(1);
     }
+
+    @Test
+    public void testJobIdRollover() throws Exception {
+        JobConfig.setJobIdOffset(10);
+
+        context().getSharedPreferences(JobStorage.PREF_FILE_NAME, Context.MODE_PRIVATE).edit()
+                .putInt(JobStorage.JOB_ID_COUNTER, JobIdsInternal.RESERVED_JOB_ID_RANGE_START - 2)
+                .apply();
+
+        assertThat(manager().getJobStorage().nextJobId()).isEqualTo(JobIdsInternal.RESERVED_JOB_ID_RANGE_START - 1);
+        assertThat(manager().getJobStorage().nextJobId()).isEqualTo(11);
+        assertThat(manager().getJobStorage().nextJobId()).isEqualTo(12);
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    @Test
+    public void testCancelAndEdit() {
+        int id = DummyJobs.createBuilder(DummyJobs.SuccessJob.class)
+                .setExact(10_000)
+                .build().schedule();
+
+        int newId = manager().getJobRequest(id).cancelAndEdit().build().schedule();
+
+        JobRequest request = manager().getJobRequest(newId);
+        assertThat(request.getEndMs()).isGreaterThan(9_000);
+    }
 }
diff --git a/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
index 8c3bad7..bb7d018 100644
--- a/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobPeriodicCancelTest.java
@@ -4,7 +4,7 @@
 import android.support.annotation.NonNull;
 
 import com.evernote.android.job.test.JobRobolectricTestRunner;
-import com.evernote.android.job.test.TestCat;
+import com.evernote.android.job.test.TestLogger;
 
 import org.junit.Before;
 import org.junit.FixMethodOrder;
@@ -33,7 +33,7 @@ public void setup() {
         mJob = new PeriodicJob();
         manager().addJobCreator(new JobCreator() {
             @Override
-            public Job create(String tag) {
+            public Job create(@NonNull String tag) {
                 return mJob;
             }
         });
@@ -88,7 +88,7 @@ private void runJobAndCancelAllDuringExecution(boolean flex) {
                 .build()
                 .schedule();
 
-            final JobProxy.Common common = new JobProxy.Common(context(), TestCat.INSTANCE, jobId);
+            final JobProxy.Common common = new JobProxy.Common(context(), TestLogger.INSTANCE, jobId);
             final JobRequest request = common.getPendingRequest(true, true);
             assertThat(request).isNotNull();
 
@@ -96,7 +96,7 @@ private void runJobAndCancelAllDuringExecution(boolean flex) {
             new Thread() {
                 @Override
                 public void run() {
-                    common.executeJobRequest(request);
+                    common.executeJobRequest(request, null);
                     waitFinishExecution.countDown();
                 }
             }.start();
diff --git a/library/src/test/java/com/evernote/android/job/JobProxyTest.java b/library/src/test/java/com/evernote/android/job/JobProxyTest.java
index 8f5e671..ab745d1 100644
--- a/library/src/test/java/com/evernote/android/job/JobProxyTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobProxyTest.java
@@ -163,7 +163,6 @@ public boolean matches(JobInfo argument) {
 
         new JobRequest.Builder("tag")
                 .setExecutionWindow(200_000, 300_000)
-                .setPersisted(true)
                 .build()
                 .schedule();
 
@@ -190,7 +189,6 @@ public void verifyRecoverWithoutServiceJobScheduler() throws Exception {
 
         new JobRequest.Builder("tag")
                 .setExecutionWindow(200_000, 300_000)
-                .setPersisted(true)
                 .build()
                 .schedule();
 
@@ -217,7 +215,6 @@ public void verifyRecoverWithNpeInJobScheduler() throws Exception {
 
         new JobRequest.Builder("tag")
                 .setExecutionWindow(200_000, 300_000)
-                .setPersisted(true)
                 .build()
                 .schedule();
 
diff --git a/library/src/test/java/com/evernote/android/job/JobRequestTest.java b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
index 9129934..6670601 100644
--- a/library/src/test/java/com/evernote/android/job/JobRequestTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
@@ -5,12 +5,9 @@
 
 import com.evernote.android.job.test.DummyJobs;
 import com.evernote.android.job.test.JobRobolectricTestRunner;
-import com.evernote.android.job.util.JobApi;
-import com.evernote.android.job.util.JobCat;
+import com.evernote.android.job.util.JobLogger;
 import com.evernote.android.job.util.support.PersistableBundleCompat;
 
-import net.vrallev.android.cat.print.CatPrinter;
-
 import org.junit.FixMethodOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,7 +32,6 @@ public void testSimpleJob() {
                 .setExecutionWindow(2_000L, 3_000L)
                 .setBackoffCriteria(4_000, JobRequest.BackoffPolicy.LINEAR)
                 .setExtras(new PersistableBundleCompat())
-                .setPersisted(true)
                 .build();
 
         assertThat(request.getJobId()).isGreaterThan(0);
@@ -44,7 +40,6 @@ public void testSimpleJob() {
         assertThat(request.getEndMs()).isEqualTo(3_000L);
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
         assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.BackoffPolicy.LINEAR);
-        assertThat(request.isPersisted()).isTrue();
         assertThat(request.getExtras()).isNotNull();
 
         assertThat(request.getIntervalMs()).isZero();
@@ -62,12 +57,10 @@ public void testPeriodic() {
         JobRequest request = getBuilder()
                 .setPeriodic(interval)
                 .setExtras(new PersistableBundleCompat())
-                .setPersisted(true)
                 .build();
 
         assertThat(request.getJobId()).isGreaterThan(0);
         assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
-        assertThat(request.isPersisted()).isTrue();
         assertThat(request.getIntervalMs()).isEqualTo(interval);
         assertThat(request.getFlexMs()).isEqualTo(interval);
         assertThat(request.isPeriodic()).isTrue();
@@ -87,7 +80,7 @@ public void testPeriodic() {
 
     @Test
     public void testFlex() {
-        JobManager.instance().forceApi(JobApi.V_14);
+        JobConfig.forceApi(JobApi.V_14);
 
         long interval = JobRequest.MIN_INTERVAL * 5;
         long flex = JobRequest.MIN_FLEX * 5;
@@ -105,12 +98,36 @@ public void testFlex() {
         assertThat(request.isFlexSupport()).isTrue();
     }
 
+    @Test
+    public void verifyStartNow() {
+        JobRequest request = getBuilder()
+                .setBackoffCriteria(4_000, JobRequest.BackoffPolicy.LINEAR)
+                .setExtras(new PersistableBundleCompat())
+                .startNow()
+                .build();
+
+        assertThat(request.getJobId()).isGreaterThan(0);
+        assertThat(request.getTag()).isEqualTo(DummyJobs.SuccessJob.TAG);
+        assertThat(request.getStartMs()).isEqualTo(JobRequest.START_NOW);
+        assertThat(request.getEndMs()).isEqualTo(JobRequest.START_NOW);
+        assertThat(request.getBackoffMs()).isEqualTo(4_000L);
+        assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.BackoffPolicy.LINEAR);
+        assertThat(request.getExtras()).isNotNull();
+        assertThat(request.isExact()).isTrue();
+
+        assertThat(request.getIntervalMs()).isZero();
+        assertThat(request.isPeriodic()).isFalse();
+        assertThat(request.requiredNetworkType()).isEqualTo(JobRequest.DEFAULT_NETWORK_TYPE);
+        assertThat(request.requirementsEnforced()).isFalse();
+        assertThat(request.requiresCharging()).isFalse();
+        assertThat(request.requiresDeviceIdle()).isFalse();
+    }
+
     @Test
     public void testExact() {
         JobRequest request = getBuilder()
                 .setBackoffCriteria(4_000, JobRequest.BackoffPolicy.LINEAR)
                 .setExtras(new PersistableBundleCompat())
-                .setPersisted(true)
                 .setExact(2_000L)
                 .build();
 
@@ -120,7 +137,6 @@ public void testExact() {
         assertThat(request.getEndMs()).isEqualTo(2_000L);
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
         assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.BackoffPolicy.LINEAR);
-        assertThat(request.isPersisted()).isTrue();
         assertThat(request.getExtras()).isNotNull();
         assertThat(request.isExact()).isTrue();
 
@@ -224,22 +240,22 @@ public void testExactNoRequirementsEnforced() {
 
     @Test
     public void testWarningWhenTooFarInTheFuture() {
-        class TestPrinter implements CatPrinter {
+        class TestPrinter implements JobLogger {
             private final List<String> mMessages = new ArrayList<>();
 
             @Override
-            public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+            public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
                 mMessages.add(message);
             }
         }
 
         TestPrinter testPrinter = new TestPrinter();
-        JobCat.addLogPrinter(testPrinter);
+        JobConfig.addLogger(testPrinter);
 
         getBuilder().setExecutionWindow(TimeUnit.DAYS.toMillis(366), TimeUnit.DAYS.toMillis(367)).build();
         getBuilder().setExact(TimeUnit.DAYS.toMillis(366)).build();
 
-        JobCat.removeLogPrinter(testPrinter);
+        JobConfig.removeLogger(testPrinter);
 
         assertThat(testPrinter.mMessages).containsSubsequence(
                 "Warning: job with tag SuccessJob scheduled over a year in the future",
diff --git a/library/src/test/java/com/evernote/android/job/JobRequirementTest.java b/library/src/test/java/com/evernote/android/job/JobRequirementTest.java
new file mode 100644
index 0000000..68d9ed5
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobRequirementTest.java
@@ -0,0 +1,171 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.test.mock.MockContext;
+
+import com.evernote.android.job.test.DummyJobs;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+/**
+ * @author rwondratschek
+ */
+@FixMethodOrder(MethodSorters.JVM)
+public class JobRequirementTest {
+
+    @Test
+    public void verifyRequirementNetworkMeteredOnRoaming() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkMeteredOnMobile() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_MOBILE, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkMeteredOnWifi() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, true, ConnectivityManager.TYPE_WIFI, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkMeteredNoConnection() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.METERED, false, ConnectivityManager.TYPE_WIFI, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkNotRoamingOnRoaming() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkNotRoamingOnMobile() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_MOBILE, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkNotRoamingOnWifi() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, true, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkNotRoamingNoConnection() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.NOT_ROAMING, false, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkUnmeteredOnRoaming() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkUnmeteredOnMobile() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_MOBILE, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkUnmeteredOnWifi() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, true, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkUnmeteredNoConnection() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.UNMETERED, false, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkConnectedOnRoaming() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkConnectedOnMobile() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_MOBILE, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkConnectedWifi() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, true, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkConnectedNoConnection() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.CONNECTED, false, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isFalse();
+    }
+
+    @Test
+    public void verifyRequirementNetworkAnyOnRoaming() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkAnyOnMobile() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_MOBILE, false);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkAnyWifi() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, true, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    @Test
+    public void verifyRequirementNetworkAnyNoConnection() {
+        Job job = setupNetworkRequirement(JobRequest.NetworkType.ANY, false, ConnectivityManager.TYPE_WIFI, true);
+        assertThat(job.isRequirementNetworkTypeMet()).isTrue();
+    }
+
+    private Job setupNetworkRequirement(JobRequest.NetworkType requirement, boolean connected, int networkType, boolean roaming) {
+        NetworkInfo networkInfo = mock(NetworkInfo.class);
+        when(networkInfo.isConnected()).thenReturn(connected);
+        when(networkInfo.isConnectedOrConnecting()).thenReturn(connected);
+        when(networkInfo.getType()).thenReturn(networkType);
+        when(networkInfo.isRoaming()).thenReturn(roaming);
+
+        ConnectivityManager connectivityManager = mock(ConnectivityManager.class);
+        when(connectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);
+
+        Context context = mock(MockContext.class);
+        when(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager);
+
+        JobRequest request = mock(JobRequest.class);
+        when(request.requiredNetworkType()).thenReturn(requirement);
+
+        Job.Params params = mock(Job.Params.class);
+        when(params.getRequest()).thenReturn(request);
+
+        Job job = spy(new DummyJobs.SuccessJob());
+        when(job.getParams()).thenReturn(params);
+        doReturn(context).when(job).getContext();
+
+        return job;
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java b/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java
new file mode 100644
index 0000000..69c014c
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/JobRescheduleTest.java
@@ -0,0 +1,121 @@
+package com.evernote.android.job;
+
+import android.app.PendingIntent;
+import android.app.job.JobScheduler;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Bundle;
+
+import com.evernote.android.job.test.JobRobolectricTestRunner;
+import com.evernote.android.job.v14.PlatformAlarmReceiver;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.annotation.Config;
+
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import static org.assertj.core.api.Java6Assertions.assertThat;
+
+/**
+ * @author rwondratschek
+ */
+@RunWith(JobRobolectricTestRunner.class)
+@FixMethodOrder(MethodSorters.JVM)
+public class JobRescheduleTest extends BaseJobManagerTest {
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    public void verifyOneOffJobRescheduled() throws Exception {
+        assertThat(manager().getAllJobRequests()).isEmpty();
+
+        ContentValues contentValues = new JobRequest.Builder("tag")
+                .setExecutionWindow(40_000, 50_000)
+                .build()
+                .toContentValues();
+
+        manager().getJobStorage().getDatabase()
+                .insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        Set<JobRequest> requests = manager().getAllJobRequests();
+        assertThat(requests).isNotEmpty();
+
+        int rescheduledJobs = new JobRescheduleService().rescheduleJobs(manager());
+        assertThat(rescheduledJobs).isEqualTo(1);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    public void verifyPeriodicJobRescheduled() throws Exception {
+        assertThat(manager().getAllJobRequests()).isEmpty();
+
+        ContentValues contentValues = new JobRequest.Builder("tag")
+                .setPeriodic(TimeUnit.HOURS.toMillis(1))
+                .build()
+                .toContentValues();
+
+        manager().getJobStorage().getDatabase()
+                .insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        Set<JobRequest> requests = manager().getAllJobRequests();
+        assertThat(requests).isNotEmpty();
+
+        JobScheduler scheduler = (JobScheduler) context().getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        assertThat(scheduler.getAllPendingJobs()).isEmpty();
+
+        int rescheduledJobs = new JobRescheduleService().rescheduleJobs(manager());
+        assertThat(rescheduledJobs).isEqualTo(1);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.LOLLIPOP_MR1)
+    public void verifyExactJobRescheduled() throws Exception {
+        assertThat(manager().getAllJobRequests()).isEmpty();
+
+        ContentValues contentValues = new JobRequest.Builder("tag")
+                .setExact(TimeUnit.HOURS.toMillis(1))
+                .build()
+                .toContentValues();
+
+        manager().getJobStorage().getDatabase()
+                .insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        Set<JobRequest> requests = manager().getAllJobRequests();
+        assertThat(requests).isNotEmpty();
+
+        final int jobId = 1;
+
+        Intent intent = new Intent(context(), PlatformAlarmReceiver.class);
+        assertThat(PendingIntent.getBroadcast(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE)).isNull();
+
+        int rescheduledJobs = new JobRescheduleService().rescheduleJobs(manager());
+        assertThat(rescheduledJobs).isEqualTo(1);
+
+        assertThat(PendingIntent.getBroadcast(context(), jobId, intent, PendingIntent.FLAG_NO_CREATE)).isNotNull();
+    }
+
+    @Test
+    public void verifyTransientJobNotRescheduled() throws Exception {
+        assertThat(manager().getAllJobRequests()).isEmpty();
+
+        Bundle bundle = new Bundle();
+        bundle.putString("key", "value");
+
+        ContentValues contentValues = new JobRequest.Builder("tag")
+                .setExact(TimeUnit.HOURS.toMillis(1))
+                .setTransientExtras(bundle)
+                .build()
+                .toContentValues();
+
+        manager().getJobStorage().getDatabase()
+                .insert(JobStorage.JOB_TABLE_NAME, null, contentValues);
+
+        Set<JobRequest> requests = manager().getAllJobRequests();
+        assertThat(requests).isEmpty();
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/test/DummyJobs.java b/library/src/test/java/com/evernote/android/job/test/DummyJobs.java
index 5d902a6..5e08d64 100644
--- a/library/src/test/java/com/evernote/android/job/test/DummyJobs.java
+++ b/library/src/test/java/com/evernote/android/job/test/DummyJobs.java
@@ -2,6 +2,7 @@
 
 import android.support.annotation.NonNull;
 
+import com.evernote.android.job.DailyJob;
 import com.evernote.android.job.Job;
 import com.evernote.android.job.JobCreator;
 import com.evernote.android.job.JobRequest;
@@ -75,9 +76,19 @@ protected Result onRunJob(Params params) {
         }
     }
 
+    public static final class SuccessDailyJob extends DailyJob {
+        public static final String TAG = "SuccessDailyJob";
+
+        @NonNull
+        @Override
+        protected DailyJobResult onRunDailyJob(Params params) {
+            return DailyJobResult.SUCCESS;
+        }
+    }
+
     public static final JobCreator TEST_JOB_CREATOR = new JobCreator() {
         @Override
-        public Job create(String tag) {
+        public Job create(@NonNull String tag) {
             switch (tag) {
                 case SuccessJob.TAG:
                     return new SuccessJob();
@@ -87,6 +98,8 @@ public Job create(String tag) {
                     return new FailureJob();
                 case TwoSecondPauseJob.TAG:
                     return new TwoSecondPauseJob();
+                case SuccessDailyJob.TAG:
+                    return new SuccessDailyJob();
                 default:
                     return null;
             }
@@ -102,7 +115,7 @@ public SpyableJobCreator(JobCreator jobCreator) {
         }
 
         @Override
-        public Job create(String tag) {
+        public Job create(@NonNull String tag) {
             Job job = mJobCreator.create(tag);
             return job == null ? null : spy(job);
         }
diff --git a/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java b/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java
index 22c3998..c9e2137 100644
--- a/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java
+++ b/library/src/test/java/com/evernote/android/job/test/JobRobolectricTestRunner.java
@@ -1,7 +1,5 @@
 package com.evernote.android.job.test;
 
-import com.evernote.android.job.BuildConfig;
-
 import org.junit.runners.model.InitializationError;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
@@ -18,7 +16,7 @@ public JobRobolectricTestRunner(Class<?> testClass) throws InitializationError {
     @Override
     protected Config buildGlobalConfig() {
         return new Config.Builder()
-                .setConstants(BuildConfig.class)
+                .setSdk(26)
                 .build();
     }
 }
diff --git a/library/src/test/java/com/evernote/android/job/test/TestClock.java b/library/src/test/java/com/evernote/android/job/test/TestClock.java
new file mode 100644
index 0000000..eaef0c5
--- /dev/null
+++ b/library/src/test/java/com/evernote/android/job/test/TestClock.java
@@ -0,0 +1,40 @@
+package com.evernote.android.job.test;
+
+import com.evernote.android.job.util.Clock;
+import com.evernote.android.job.util.JobPreconditions;
+
+import java.util.Calendar;
+
+/**
+ * @author rwondratschek
+ */
+public class TestClock implements Clock {
+
+    private long mTime;
+
+    @Override
+    public long currentTimeMillis() {
+        return mTime;
+    }
+
+    @Override
+    public long elapsedRealtime() {
+        return mTime;
+    }
+
+    public void setTime(long time) {
+        mTime = time;
+    }
+
+    public void setTime(int hour, int minute) {
+        JobPreconditions.checkArgumentInRange(hour, 0, 23, "hour");
+        JobPreconditions.checkArgumentInRange(minute, 0, 59, "minute");
+
+        Calendar calendar = Calendar.getInstance();
+        calendar.set(Calendar.HOUR_OF_DAY, hour);
+        calendar.set(Calendar.MINUTE, minute);
+        calendar.set(Calendar.SECOND, 0);
+        calendar.set(Calendar.MILLISECOND, 0);
+        setTime(calendar.getTimeInMillis());
+    }
+}
diff --git a/library/src/test/java/com/evernote/android/job/test/TestCat.java b/library/src/test/java/com/evernote/android/job/test/TestLogger.java
similarity index 63%
rename from library/src/test/java/com/evernote/android/job/test/TestCat.java
rename to library/src/test/java/com/evernote/android/job/test/TestLogger.java
index 2985959..817d09c 100644
--- a/library/src/test/java/com/evernote/android/job/test/TestCat.java
+++ b/library/src/test/java/com/evernote/android/job/test/TestLogger.java
@@ -3,17 +3,19 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.evernote.android.job.util.JobLogger;
+
 import net.vrallev.android.cat.instance.CatLazy;
 import net.vrallev.android.cat.print.CatPrinter;
 
 /**
  * @author rwondratschek
  */
-public final class TestCat extends CatLazy implements CatPrinter {
+public final class TestLogger extends CatLazy implements CatPrinter, JobLogger {
 
-    public static final TestCat INSTANCE = new TestCat();
+    public static final TestLogger INSTANCE = new TestLogger();
 
-    private TestCat() {
+    private TestLogger() {
         // no op
     }
 
@@ -24,6 +26,11 @@ protected void println(int priority, String message, Throwable t) {
 
     @Override
     public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+        log(priority, tag, message, t);
+    }
+
+    @Override
+    public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
         // System.out.println(message);
         // if (t != null) {
         //     t.printStackTrace();
diff --git a/library/src/test/java/com/evernote/android/job/util/LoggerTest.java b/library/src/test/java/com/evernote/android/job/util/LoggerTest.java
index ef757ef..42da2b8 100644
--- a/library/src/test/java/com/evernote/android/job/util/LoggerTest.java
+++ b/library/src/test/java/com/evernote/android/job/util/LoggerTest.java
@@ -3,6 +3,8 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.evernote.android.job.JobConfig;
+
 import net.vrallev.android.cat.print.CatPrinter;
 
 import org.junit.After;
@@ -41,23 +43,23 @@ public void testIsLogcatEnabled() {
 
     @Test
     public void testAddIsIdempotent() {
-        TestPrinter printer = new TestPrinter();
-        assertThat(JobCat.addLogPrinter(printer)).isTrue();
-        assertThat(JobCat.addLogPrinter(printer)).isFalse();
+        TestLogger printer = new TestLogger();
+        assertThat(JobConfig.addLogger(printer)).isTrue();
+        assertThat(JobConfig.addLogger(printer)).isFalse();
     }
 
     @Test
     public void testRemove() {
-        TestPrinter printer = new TestPrinter();
-        assertThat(JobCat.addLogPrinter(printer)).isTrue();
-        JobCat.removeLogPrinter(printer);
-        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+        TestLogger printer = new TestLogger();
+        assertThat(JobConfig.addLogger(printer)).isTrue();
+        JobConfig.removeLogger(printer);
+        assertThat(JobConfig.addLogger(printer)).isTrue();
     }
 
     @Test
     public void testSingleCustomLoggerAddBefore() {
-        TestPrinter printer = new TestPrinter();
-        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+        TestLogger printer = new TestLogger();
+        assertThat(JobConfig.addLogger(printer)).isTrue();
 
         JobCat cat = new JobCat("Tag");
         cat.d("hello");
@@ -70,8 +72,8 @@ public void testSingleCustomLoggerAddBefore() {
     public void testSingleCustomLoggerAddAfter() {
         JobCat cat = new JobCat("Tag");
 
-        TestPrinter printer = new TestPrinter();
-        assertThat(JobCat.addLogPrinter(printer)).isTrue();
+        TestLogger printer = new TestLogger();
+        assertThat(JobConfig.addLogger(printer)).isTrue();
 
         cat.d("hello");
         cat.w("world");
@@ -83,10 +85,10 @@ public void testSingleCustomLoggerAddAfter() {
     public void test100Loggers() {
         JobCat cat1 = new JobCat("Tag1");
 
-        List<TestPrinter> printers = new ArrayList<>();
+        List<TestLogger> printers = new ArrayList<>();
         for (int i = 0; i < 100; i++) {
-            TestPrinter printer = new TestPrinter();
-            assertThat(JobCat.addLogPrinter(printer)).isTrue();
+            TestLogger printer = new TestLogger();
+            assertThat(JobConfig.addLogger(printer)).isTrue();
             printers.add(printer);
         }
 
@@ -95,16 +97,16 @@ public void test100Loggers() {
         cat1.d("hello");
         cat2.w("world");
 
-        for (TestPrinter printer : printers) {
+        for (TestLogger printer : printers) {
             assertThat(printer.mTags).containsExactly("Tag1", "Tag2");
             assertThat(printer.mMessages).containsExactly("hello", "world");
         }
 
-        TestPrinter removedPrinter = printers.remove(50);
-        JobCat.removeLogPrinter(removedPrinter);
+        TestLogger removedPrinter = printers.remove(50);
+        JobConfig.removeLogger(removedPrinter);
 
         cat1.d("third");
-        for (TestPrinter printer : printers) {
+        for (TestLogger printer : printers) {
             assertThat(printer.mTags).containsExactly("Tag1", "Tag2", "Tag1");
             assertThat(printer.mMessages).containsExactly("hello", "world", "third");
         }
@@ -116,7 +118,7 @@ public void test100Loggers() {
     public void testNotVerboseLogging() {
         JobCat cat = new JobCat("Tag");
 
-        TestPrinter fakeLogcatPrinter = new TestPrinter();
+        TestLogger fakeLogcatPrinter = new TestLogger();
         cat.addPrinter(fakeLogcatPrinter); // in this list logcat is enabled
 
         cat.d("hello");
@@ -129,15 +131,20 @@ public void testNotVerboseLogging() {
         assertThat(fakeLogcatPrinter.mMessages).containsExactly("hello");
     }
 
-    private static final class TestPrinter implements CatPrinter {
+    private static final class TestLogger implements JobLogger, CatPrinter {
 
         private final List<String> mTags = new ArrayList<>();
         private final List<String> mMessages = new ArrayList<>();
 
         @Override
-        public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+        public void log(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
             mTags.add(tag);
             mMessages.add(message);
         }
+
+        @Override
+        public void println(int priority, @NonNull String tag, @NonNull String message, @Nullable Throwable t) {
+            log(priority, tag, message, t);
+        }
     }
 }
diff --git a/library/src/test/resources/databases/evernote_jobs_v5.db b/library/src/test/resources/databases/evernote_jobs_v5.db
new file mode 100644
index 0000000..7037dbe
Binary files /dev/null and b/library/src/test/resources/databases/evernote_jobs_v5.db differ
diff --git a/library/src/test/resources/databases/evernote_jobs_v6.db b/library/src/test/resources/databases/evernote_jobs_v6.db
new file mode 100644
index 0000000..c21d301
Binary files /dev/null and b/library/src/test/resources/databases/evernote_jobs_v6.db differ
