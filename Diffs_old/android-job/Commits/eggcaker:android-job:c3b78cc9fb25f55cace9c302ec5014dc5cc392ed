diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3932ce9..9760b6c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,6 @@
 ## 1.2.6
 * Make the license in Java files clearer, see #422
+* Use own internal monitor for synchronizing access to variables in order to avoid deadlocks when using the library, see #414
 
 ## 1.2.5 (2018-03-19)
 * Handle platform bug where querying the network state throws an NPE internally, see #380
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 26fccad..2383f9f 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -78,6 +78,8 @@
 
     private Result mResult = Result.FAILURE;
 
+    private final Object mMonitor = new Object();
+
     /**
      * This method is invoked from a background thread. You should run your desired task here.
      * This method is thread safe. Each time a job starts executing a new instance of your {@link Job}
@@ -282,43 +284,53 @@ public final void cancel() {
         cancel(false);
     }
 
-    /*package*/ final synchronized boolean cancel(boolean deleted) {
-        if (!isFinished()) {
-            if (!mCanceled) {
-                mCanceled = true;
-                onCancel();
+    /*package*/ final boolean cancel(boolean deleted) {
+        synchronized (mMonitor) {
+            if (!isFinished()) {
+                if (!mCanceled) {
+                    mCanceled = true;
+                    onCancel();
+                }
+                mDeleted |= deleted;
+                return true;
+            } else {
+                return false;
             }
-            mDeleted |= deleted;
-            return true;
-        } else {
-            return false;
         }
     }
 
     /**
      * @return {@code true} if this {@link Job} was canceled.
      */
-    protected final synchronized boolean isCanceled() {
-        return mCanceled;
+    protected final boolean isCanceled() {
+        synchronized (mMonitor) {
+            return mCanceled;
+        }
     }
 
     /**
      * @return {@code true} if the {@link Job} finished.
      */
-    public final synchronized boolean isFinished() {
-        return mFinishedTimeStamp > 0;
+    public final boolean isFinished() {
+        synchronized (mMonitor) {
+            return mFinishedTimeStamp > 0;
+        }
     }
 
-    /*package*/ final synchronized long getFinishedTimeStamp() {
-        return mFinishedTimeStamp;
+    /*package*/ final long getFinishedTimeStamp() {
+        synchronized (mMonitor) {
+            return mFinishedTimeStamp;
+        }
     }
 
     /*package*/ final Result getResult() {
         return mResult;
     }
 
-    /*package*/ final synchronized boolean isDeleted() {
-        return mDeleted;
+    /*package*/ final boolean isDeleted() {
+        synchronized (mMonitor) {
+            return mDeleted;
+        }
     }
 
     @Override
diff --git a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
index 209847b..2fdc3ad 100644
--- a/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobExecutionTest.java
@@ -217,7 +217,54 @@ public Job create(@NonNull String tag) {
     }
 
     @Test
-    public void verifyReschedulingTransientJobsWorks() throws Throwable {
+    public void verifySynchronizedAllowed() throws InterruptedException {
+        final CountDownLatch start = new CountDownLatch(1);
+
+        final Job job = new Job() {
+            @NonNull
+            @Override
+            protected synchronized Result onRunJob(@NonNull Params params) {
+                start.countDown();
+                try {
+                    Thread.sleep(8_000L);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                return Result.SUCCESS;
+            }
+        };
+
+        JobCreator jobCreator = new JobCreator() {
+            @Override
+            public Job create(@NonNull String tag) {
+                return job;
+            }
+        };
+
+        manager().addJobCreator(jobCreator);
+
+        final int jobId = new JobRequest.Builder("something")
+                .setExecutionWindow(200_000L, 400_000L)
+                .build()
+                .schedule();
+
+        executeJobAsync(jobId, Job.Result.SUCCESS);
+        assertThat(start.await(2, TimeUnit.SECONDS)).isTrue();
+
+        final CountDownLatch canceledWithin2Seconds = new CountDownLatch(1);
+        new Thread() {
+            @Override
+            public void run() {
+                job.cancel();
+                canceledWithin2Seconds.countDown();
+            }
+        }.start();
+
+        assertThat(canceledWithin2Seconds.await(2, TimeUnit.MILLISECONDS)).isTrue();
+    }
+
+    @Test
+    public void verifyReschedulingTransientJobsWorks() {
         Bundle extras = new Bundle();
         extras.putString("key", "hello");
 
