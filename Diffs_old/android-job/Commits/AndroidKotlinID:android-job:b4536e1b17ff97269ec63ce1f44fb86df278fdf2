diff --git a/CHANGELOG.md b/CHANGELOG.md
index 907b914..e7a03b7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,7 @@
 * Fix database access on main thread, see #385
 * Fix misleading log message for some internal improvements, see #391
 * Fix race condition when scheduling a job with `setUpdateCurrent(true)` where multiple jobs could have been scheduled, see #396
+* Fix bug where a daily job runs twice a day, see #406
 
 ## 1.2.4 (2018-02-08)
 * Add `scheduleAsync()` to the `DailyJob` class for scheduling daily jobs asynchronously to avoid IO operations on the main thread, see #371
diff --git a/library/src/main/java/com/evernote/android/job/DailyJob.java b/library/src/main/java/com/evernote/android/job/DailyJob.java
index ffa00ab..1e31996 100644
--- a/library/src/main/java/com/evernote/android/job/DailyJob.java
+++ b/library/src/main/java/com/evernote/android/job/DailyJob.java
@@ -64,7 +64,7 @@
      * @return The unique ID for this job.
      */
     public static int schedule(@NonNull JobRequest.Builder baseBuilder, long startMs, long endMs) {
-        return schedule(baseBuilder, true, startMs, endMs);
+        return schedule(baseBuilder, true, startMs, endMs, false);
     }
 
     /**
@@ -123,7 +123,7 @@ public static int startNowOnce(@NonNull JobRequest.Builder baseBuilder) {
                 .schedule();
     }
 
-    private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob, long startMs, long endMs) {
+    private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob, long startMs, long endMs, boolean isReschedule) {
         if (startMs >= DAY || endMs >= DAY || startMs < 0 || endMs < 0) {
             throw new IllegalArgumentException("startMs or endMs should be less than one day (in milliseconds)");
         }
@@ -145,6 +145,11 @@ private static int schedule(@NonNull JobRequest.Builder builder, boolean newJob,
 
         startDelay = (startDelay + startMs) % TimeUnit.DAYS.toMillis(1);
 
+        if (isReschedule && startDelay < TimeUnit.HOURS.toMillis(12)) {
+            // it happens that the job runs too early and while rescheduling we schedule the job for the same day again
+            startDelay += TimeUnit.DAYS.toMillis(1);
+        }
+
         if (startMs > endMs) {
             // e.g. when job should run between 10pm and 2am
             endMs += TimeUnit.DAYS.toMillis(1);
@@ -214,7 +219,7 @@ protected final Result onRunJob(@NonNull Params params) {
 
                     // don't update current, it would cancel this currently running job
                     int newJobId = schedule(request.createBuilder(), false,
-                            extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY);
+                            extras.getLong(EXTRA_START_MS, 0) % DAY, extras.getLong(EXTRA_END_MS, 0L) % DAY, true);
 
                     request = JobManager.instance().getJobRequest(newJobId);
                     if (request != null) {
diff --git a/library/src/test/java/com/evernote/android/job/DailyJobTest.java b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
index dc3f3cf..0696bed 100644
--- a/library/src/test/java/com/evernote/android/job/DailyJobTest.java
+++ b/library/src/test/java/com/evernote/android/job/DailyJobTest.java
@@ -271,6 +271,22 @@ public void verifyLastRunIsSet() {
         assertThat(request.getLastRun()).isEqualTo(clock.currentTimeMillis());
     }
 
+    @SuppressWarnings("ConstantConditions")
+    @Test
+    public void verifyEarlyExecution() {
+        TestClock clock = new TestClock();
+        clock.setTime(13, 0);
+
+        JobRequest request = verifyExecutionAndSuccessfulReschedule(clock, TimeUnit.HOURS.toMillis(14), TimeUnit.HOURS.toMillis(15));
+        assertThat(request.getStartMs()).isEqualTo(TimeUnit.HOURS.toMillis(25));
+        assertThat(request.getEndMs()).isEqualTo(TimeUnit.HOURS.toMillis(26));
+
+        int id = DailyJob.schedule(DummyJobs.createBuilder(DummyJobs.SuccessDailyJob.class), TimeUnit.HOURS.toMillis(14), TimeUnit.HOURS.toMillis(15));
+        request = manager().getJobRequest(id);
+        assertThat(request.getStartMs()).isEqualTo(TimeUnit.HOURS.toMillis(1));
+        assertThat(request.getEndMs()).isEqualTo(TimeUnit.HOURS.toMillis(2));
+    }
+
     @Test
     public void verifyRequirementsEnforcedSkipsJob() {
         long time = 1L;
