diff --git a/CHANGELOG.md b/CHANGELOG.md
index a1e7f7f..9fdd167 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,7 @@
 * Make PlatformAlarmReceiver intent explicit, fixes #56
 * Delete a job after it has finished, otherwise reschedule if app is crashing while job is running, fixes #55
 * Extend Params class with more parameters from the job request, fixes #52
+* Cache only 20 finished jobs to free up memory, fixes #57
 
 ## 1.0.7 (2016-06-03)
 
diff --git a/library/src/main/java/com/evernote/android/job/JobExecutor.java b/library/src/main/java/com/evernote/android/job/JobExecutor.java
index 07ddc63..390fdf3 100644
--- a/library/src/main/java/com/evernote/android/job/JobExecutor.java
+++ b/library/src/main/java/com/evernote/android/job/JobExecutor.java
@@ -29,6 +29,7 @@
 import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.util.LruCache;
 import android.util.SparseArray;
 
 import com.evernote.android.job.util.JobCat;
@@ -37,6 +38,7 @@
 import net.vrallev.android.cat.CatLog;
 
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
@@ -52,11 +54,14 @@
     private static final CatLog CAT = new JobCat("JobExecutor");
 
     private final ExecutorService mExecutorService;
+
     private final SparseArray<Job> mJobs; // only cached in memory, that's fine
+    private final LruCache<Integer, Job> mFinishedJobsCache;
 
     public JobExecutor() {
         mExecutorService = Executors.newCachedThreadPool();
         mJobs = new SparseArray<>();
+        mFinishedJobsCache = new LruCache<>(20);
     }
 
     public synchronized Future<Job.Result> execute(@NonNull Context context, @NonNull JobRequest request, @Nullable Job job) {
@@ -77,7 +82,8 @@ public JobExecutor() {
     }
 
     public synchronized Job getJob(int jobId) {
-        return mJobs.get(jobId);
+        Job job = mJobs.get(jobId);
+        return job != null ? job : mFinishedJobsCache.get(jobId);
     }
 
     public synchronized Set<Job> getAllJobs() {
@@ -92,9 +98,23 @@ public synchronized Job getJob(int jobId) {
                 result.add(job);
             }
         }
+
+        Map<Integer, Job> snapshot = mFinishedJobsCache.snapshot();
+        for (Job job : snapshot.values()) {
+            if (tag == null || tag.equals(job.getParams().getTag())) {
+                result.add(job);
+            }
+        }
+
         return result;
     }
 
+    private synchronized void markJobAsFinished(Job job) {
+        int id = job.getParams().getId();
+        mJobs.remove(id);
+        mFinishedJobsCache.put(id, job);
+    }
+
     private final class JobCallable implements Callable<Job.Result> {
 
         private final Job mJob;
@@ -130,6 +150,8 @@ private JobCallable(Job job) {
                 } else {
                     CAT.w("Wake lock was not held after job %s was done. The job took too long to complete. This could have unintended side effects on your app.", mJob);
                 }
+
+                markJobAsFinished(mJob);
             }
         }
 
diff --git a/library/src/main/java/com/evernote/android/job/JobProxy.java b/library/src/main/java/com/evernote/android/job/JobProxy.java
index a001293..916fa45 100644
--- a/library/src/main/java/com/evernote/android/job/JobProxy.java
+++ b/library/src/main/java/com/evernote/android/job/JobProxy.java
@@ -131,10 +131,11 @@ public JobRequest getPendingRequest(JobManager manager) {
             mCat.d("Run job, %s, waited %s, %s", request, JobUtil.timeToString(waited), timeWindow);
             JobManager manager = JobManager.instance();
             JobExecutor jobExecutor = manager.getJobExecutor();
+            Job job = null;
 
             try {
                 // create job first before setting it transient, avoids a race condition while rescheduling jobs
-                Job job = manager.getJobCreatorHolder().createJob(request.getTag());
+                job = manager.getJobCreatorHolder().createJob(request.getTag());
 
                 if (!request.isPeriodic()) {
                     request.setTransient(true);
@@ -153,7 +154,6 @@ public JobRequest getPendingRequest(JobManager manager) {
             } catch (InterruptedException | ExecutionException e) {
                 mCat.e(e);
 
-                Job job = jobExecutor.getJob(mJobId);
                 if (job != null) {
                     job.cancel();
                     mCat.e("Canceled %s", request);
